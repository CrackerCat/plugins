{"file_sha256":"bbe34331e5068d7dc5b990fbef10002358b4ef8e07ab92c0d5620ed60fc36b30","base_addr":65536,"functions":{"100584":{"score":0.91404617,"function_name":"_do_recovery","code":"static iot_error_t _do_recovery(struct iot_context *ctx,\n\t\t\tiot_state_t fail_state)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\n\tIOT_WARN(\"state changing fail for %d, curr_state :%d\",\n\t\tfail_state, ctx-\u003ecurr_state);\n\n\tif ((fail_state != IOT_STATE_PROV_ENTER) \u0026\u0026 (fail_state != IOT_STATE_PROV_CONFIRM)) {\n\t\tif (fail_state != ctx-\u003ercv_fail_state) {\n\t\t\tctx-\u003ercv_try_cnt = 0;\n\t\t\tctx-\u003ercv_fail_state = fail_state;\n\t\t} else {\n\t\t\tctx-\u003ercv_try_cnt++;\n\t\t}\n\t}\n\n\t/* Repeated same exceptional cases\n\t * So try do something more first\n\t */\n\tif (ctx-\u003ercv_try_cnt \u003e RECOVER_TRY_MAX) {\n\t\tIOT_WARN(\"Recovery state:[%d] repeated MAX times(%d)\",\n\t\t\tfail_state, ctx-\u003ercv_try_cnt);\n\t\tIOT_DUMP_MAIN(WARN, BASE, fail_state);\n\t\tswitch (fail_state) {\n\t\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\t\t/* fall through */\n\t\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\t\t/* wifi off */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* wifi on againg by station */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_STATION);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI station command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_WARN(\"No action for repeating state:[%d] failure (%d)\",\n\t\t\t\tfail_state, ctx-\u003ercv_try_cnt);\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, ctx-\u003ercv_try_cnt);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* reset rcv_try_cnt */\n\t\tctx-\u003ercv_try_cnt = 0;\n\t}\n\n\tif (ctx-\u003ecurr_state == fail_state) {\n\t\t/* We assume that these are intentional timeout cases\n\t\t * when target didn't receive PROV_CONFIRM, CLOUD_REGISTERED\n\t\t */\n\t\tswitch (fail_state) {\n\t\tcase IOT_STATE_PROV_ENTER:\n\t\tcase IOT_STATE_PROV_CONFIRM:\n\t\t\tIOT_ERROR(\"Failed process [%d] on time, STOP\", fail_state);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADFEED);\n\n\t\t\tif (ctx-\u003escan_result) {\n\t\t\t\tfree(ctx-\u003escan_result);\n\t\t\t\tctx-\u003escan_result = NULL;\n\t\t\t}\n\t\t\tctx-\u003escan_num = 0;\n\n\t\t\t/* change its state by UNKNOWN to prevent self-reentrant */\n\t\t\tiot_err = iot_state_update(ctx, IOT_STATE_UNKNOWN, 0);\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\t\tIOT_ERROR(\"Failed to go to CLOUD_REGISTERED on time\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xC1EAC1EA);\n\n\t\t\tiot_device_cleanup(ctx);\n\t\t\tIOT_REBOOT();\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\t\tIOT_ERROR(\"Failed to go to CLOUD_CONNECTED on time\");\n\t\t\t/* wifi off */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* wifi on againg for station */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_STATION);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI station command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* retry CLOUD_CONNECTING */\n\t\t\tiot_err = iot_command_send(ctx,\n\t\t\t\t\t\tIOT_COMMAND_CLOUD_CONNECTING,\n\t\t\t\t\t\tNULL, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_WARN(\"No action for state:[%d] failure\",\n\t\t\t\tfail_state);\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, fail_state);\n\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\t/* These are exceptional timeout cases\n\t\t * when the target can't do somthing\n\t\t */\n\t\tswitch (fail_state) {\n\t\tcase IOT_STATE_PROV_ENTER:\n\t\tcase IOT_STATE_PROV_CONFIRM:\n\t\t\tIOT_ERROR(\"Failed to do process [%d] on time, STOP\",\n\t\t\t\tfail_state);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADFEED);\n\n\t\t\tif (ctx-\u003escan_result) {\n\t\t\t\tfree(ctx-\u003escan_result);\n\t\t\t\tctx-\u003escan_result = NULL;\n\t\t\t}\n\t\t\tctx-\u003escan_num = 0;\n\n\t\t\t/* change its state by UNKNOWN to prevent self-reentrant */\n\t\t\tiot_err = iot_state_update(ctx, IOT_STATE_UNKNOWN, 0);\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_PROV_DONE:\n\t\t\tIOT_ERROR(\"Failed to do process [%d] on time, retry\",\n\t\t\t\tfail_state);\n\t\t\t/* wifi off */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tiot_err = iot_state_update(ctx, fail_state, 0);\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\t\t/* fall through */\n\t\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\t\tIOT_ERROR(\"Failed to do process [%d] on time, retry\",\n\t\t\t\tfail_state);\n\t\t\tiot_err = iot_state_update(ctx,\n\t\t\t\t\t\tIOT_STATE_CLOUD_DISCONNECTED, 0);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't update Disconnected state(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t}\n\n\t\t\tIOT_WARN(\"Self retry/recovery it again\\n\");\n\t\t\tiot_err = iot_state_update(ctx, fail_state, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_WARN(\"No action for process:[%d] failure\",\n\t\t\t\tfail_state);\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, fail_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1413,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"102056":{"score":0.82725143,"function_name":"_do_state_updating","code":"static iot_error_t _do_state_updating(struct iot_context *ctx,\n\t\tiot_state_t new_state, int opt, unsigned int *timeout_ms)\n{\n\tiot_error_t iot_err = IOT_ERROR_INVALID_ARGS;\n\tenum iot_command_type iot_cmd;\n\n\t/* Set default timeout value for next state */\n\t*timeout_ms = NEXT_STATE_TIMEOUT_MS;\n\n\tswitch (new_state) {\n\tcase IOT_STATE_INITIALIZED:\n\t\tiot_cmd = IOT_COMMAND_CHECK_PROV_STATUS;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tIOT_DUMP_MAIN_ARG2(INFO, STATE, new_state, iot_err);\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_ENTER:\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_SCAN);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't control WIFI mode scan.(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n \t\t\tbreak;\n \t\t}\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_DISCOVERY_SSID)\n\t\t/*wifi soft-ap mode w/ ssid E4 format*/\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_SOFTAP);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't send WIFI mode softap.(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n \t\t\tbreak;\n \t\t}\n#endif\n\t\t/* Update next state waiting time for Easy-setup process */\n\t\t*timeout_ms = EASYSETUP_TIMEOUT_MS;\n\t\tIOT_MEM_CHECK(\"ES_PROV_ENTER DONE \u003e\u003ePT\u003c\u003c\");\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONN_MOBILE:\n\t\tIOT_INFO(\"Notification only with IOT_STATE_PROV_CONN_MOBILE\");\n\t\t*timeout_ms = 0;\n\t\tiot_err = IOT_ERROR_NONE;\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONFIRM:\n\t\tIOT_REMARK(\"the state changes to IOT_STATE_PROV_CONFIRM\");\n\t\tiot_err = IOT_ERROR_NONE;\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_DONE:\n\t\t/* Wakeup user interaction by provisioning done */\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_PROV_DONE);\n\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_STATION);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't send WIFI mode command(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t} else {\n\t\t\tiot_cmd = IOT_COMMAND_CHECK_CLOUD_STATE;\n\t\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\t}\n\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\tif (ctx-\u003ees_res_created)\n\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t*timeout_ms = REGISTRATION_TIMEOUT_MS;\n\t\tiot_cmd = IOT_COMMAND_CLOUD_REGISTERING;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tIOT_REMARK(\"the state changes to IOT_STATE_CLOUD_REGISTERING\");\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\tif (ctx-\u003ees_res_created)\n\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\tiot_cmd = IOT_COMMAND_CLOUD_CONNECTING;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTED:\n\t\tiot_cmd = IOT_COMMAND_READY_TO_CTL;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tIOT_DUMP_MAIN_ARG2(INFO, STATE, new_state, iot_err);\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_DISCONNECTED:\n\t\tiot_err = IOT_ERROR_NONE;\n\t\t*timeout_ms = IOT_OS_MAX_DELAY;\n\t\tbreak;\n\n\tcase IOT_STATE_CHANGE_FAILED:\n\t\tiot_err = _do_recovery(ctx, (iot_state_t)opt);\n\t\t*timeout_ms = IOT_OS_MAX_DELAY;\n\t\tbreak;\n\n\tcase IOT_STATE_UNKNOWN:\n\t\t/* At this state, iot-core can't make next decision by itself\n\t\t * So just wait(stop) process until external triggering happened\n\t\t * such as reboot, re-start command from user-apps\n\t\t */\n\t\tIOT_WARN(\"Iot-core task will be stopped, needed ext-triggering\\n\");\n\t\tIOT_DUMP_MAIN_ARG2(WARN, STATE, new_state, iot_err);\n\n\t\t/* if there is previous connection, disconnect it first. */\n\t\tif (ctx-\u003ereg_mqttcli != NULL) {\n\t\t\tIOT_INFO(\"There is active registering, disconnect it first.\\n\");\n\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t}\n\n\t\tif (ctx-\u003eevt_mqttcli != NULL) {\n\t\t\tIOT_INFO(\"There is previous connecting, disconnect it first.\\n\");\n\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t}\n\n\t\t/* wifi off */\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\tiot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t}\n\n\t\tif (ctx-\u003ees_http_ready) {\n\t\t\tctx-\u003ees_http_ready = false;\n\t\t\tiot_easysetup_deinit(ctx);\n\t\t}\n\n\t\tif (ctx-\u003ees_res_created)\n\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t/* This is final state of iot-core, so update it now */\n\t\tctx-\u003ecurr_state = ctx-\u003ereq_state = IOT_STATE_UNKNOWN;\n\n\t\t/* clear reported_stat for the next connection */\n\t\tif (ctx-\u003estatus_cb) {\n\t\t\t_do_status_report(ctx, IOT_STATE_CLOUD_DISCONNECTED, false);\n\t\t}\n\n\t\t/* Reset recovery flags */\n\t\tctx-\u003ercv_fail_state = IOT_STATE_UNKNOWN;\n\t\tctx-\u003ercv_try_cnt = 0;\n\n\t\tif (opt == IOT_STATE_OPT_CLEANUP) {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\tIOT_USR_INTERACT_BIT_STATE_UNKNOWN | IOT_USR_INTERACT_BIT_CLEANUP_DONE);\n\t\t} else {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\tIOT_USR_INTERACT_BIT_STATE_UNKNOWN);\n\t\t}\n\n\t\t*timeout_ms = IOT_OS_MAX_DELAY;\n\t\tiot_err = IOT_ERROR_NONE;\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported new IOT_STATE!!(%d)\\n\", new_state);\n\t\tIOT_DUMP_MAIN(ERROR, STATE, new_state);\n\t\tbreak;\n\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1596,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"103296":{"score":0.8003658,"function_name":"st_conn_start","code":"int st_conn_start(IOT_CTX *iot_ctx, st_status_cb status_cb,\n\t\tiot_status_t maps, void *usr_data, iot_pin_t *pin_num)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t iot_err;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tunsigned char curr_events;\n\tiot_os_thread curr_thread;\n\n\tif (!IS_CTX_VALID(ctx))\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tif (iot_os_thread_get_current_handle(\u0026curr_thread) == IOT_OS_TRUE) {\n\t\tif (curr_thread == ctx-\u003emain_thread) {\n\t\t\tIOT_WARN(\"Can't support it on same thread!!\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBABE);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t} else {\n\t\tIOT_WARN(\"Can't get thread info. Please check it called same thread or not!!\");\n\t\tIOT_DUMP_MAIN(WARN, BASE, 0xDEADBABE);\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%s)\", __func__, pin_num ? \"pin\" : \"no-pin\");\n\tIOT_DUMP_MAIN(INFO, BASE, (pin_num ? 1 : 0));\n\n\tif ((ctx-\u003ecurr_state != IOT_STATE_UNKNOWN) || (ctx-\u003ereq_state != IOT_STATE_UNKNOWN)) {\n\t\tIOT_WARN(\"Can't start it, iot_main_task is already working(%d)\", ctx-\u003ecurr_state);\n\t\tIOT_DUMP_MAIN(WARN, BASE, ctx-\u003ecurr_state);\n\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tgoto end_st_conn_start;\n\t}\n\n\tif (ctx-\u003edevconf.ownership_validation_type \u0026 IOT_OVF_TYPE_BUTTON) {\n\t\tif (!status_cb) {\n\t\t\tIOT_ERROR(\"There is no status_cb for otm\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0);\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t\tgoto end_st_conn_start;\n\t\t}\n\t}\n\n\tif (ctx-\u003ees_res_created) {\n\t\tIOT_WARN(\"Already easysetup resources are created!!\");\n\t} else {\n\t\tiot_err = _create_easysetup_resources(ctx, pin_num);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to create easysetup resources(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\tgoto end_st_conn_start;\n\t\t}\n\t}\n\n\tstate_data.iot_state = IOT_STATE_INITIALIZED;\n\tstate_data.opt = IOT_STATE_OPT_NONE;\n\n\tctx-\u003eadd_justworks = false;\n\n\tif (status_cb) {\n\t\tSET_STATUS_CB(status_cb, maps, usr_data);\n\t}\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BITS_ST_CONN);\n\n\tiot_err = iot_command_send(ctx, IOT_COMMNAD_STATE_UPDATE,\n\t\t\t\t\u0026state_data, sizeof(struct iot_state_data));\n\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to send command(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tif (ctx-\u003estatus_cb) {\n\t\t\tUNSET_STATUS_CB();\n\t\t}\n\n\t\tif (ctx-\u003ees_res_created) {\n\t\t\t_delete_easysetup_resources_all(ctx);\n\t\t}\n\t\tgoto end_st_conn_start;\n\t}\n\n\tWAIT_USR_INTERACT();\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\nend_st_conn_start:\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1813,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"104562":{"score":0.8664093,"function_name":"st_conn_cleanup","code":"int st_conn_cleanup(IOT_CTX *iot_ctx, bool reboot)\n{\n\tiot_error_t iot_err;\n\tunsigned char curr_events;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tiot_os_thread curr_thread;\n\n\tif (!IS_CTX_VALID(ctx))\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tif (iot_os_thread_get_current_handle(\u0026curr_thread) == IOT_OS_TRUE) {\n\t\tif (curr_thread == ctx-\u003emain_thread) {\n\t\t\tIOT_WARN(\"Can't support it on same thread!!\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBABE);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t} else {\n\t\tIOT_WARN(\"Can't get thread info. Please check it called same thread or not!!\");\n\t\tIOT_DUMP_MAIN(WARN, BASE, 0xDEADBABE);\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%d)\", __func__, reboot);\n\tIOT_DUMP_MAIN(INFO, BASE, reboot);\n\n\t/* remove all queued commands */\n\tif (iot_os_mutex_lock(\u0026ctx-\u003eiot_cmd_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\t_throw_away_all_cmd_queue(ctx);\n\tiot_os_mutex_unlock(\u0026ctx-\u003eiot_cmd_lock);\n\n\t/* Try to delete device_card first, but it depends on connection-status */\n\tiot_err = _delete_dev_card_by_usr(ctx);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to delete device_card(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t}\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_CLEANUP_DONE);\n\n\tiot_err = iot_command_send(ctx,\n\t\t\tIOT_COMMAND_SELF_CLEANUP, \u0026reboot, sizeof(bool));\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to send cleanup(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tgoto err_cleanup;\n\t}\n\n\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\tIOT_USR_INTERACT_BIT_CLEANUP_DONE, true, (NEXT_STATE_TIMEOUT_MS * 2));\n\n\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_CLEANUP_DONE)) {\n\t\tIOT_ERROR(\"Timeout happened for st_conn_cleanup\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0x8BADF00D);\n\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t}\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\nerr_cleanup:\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1907,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"105303":{"score":0.86950517,"function_name":"st_conn_start_ex","code":"int st_conn_start_ex(IOT_CTX *iot_ctx, iot_ext_args_t *ext_args)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t iot_err;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tunsigned char curr_events;\n\tiot_os_thread curr_thread;\n\n\tif (!IS_CTX_VALID(ctx) || !ext_args) {\n\t\tIOT_ERROR(\"invalid parameters\\n\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (iot_os_thread_get_current_handle(\u0026curr_thread) == IOT_OS_TRUE) {\n\t\tif (curr_thread == ctx-\u003emain_thread) {\n\t\t\tIOT_WARN(\"Can't support it on same thread!!\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBABE);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t} else {\n\t\tIOT_WARN(\"Can't get thread info. Please check it called same thread or not!!\");\n\t\tIOT_DUMP_MAIN(WARN, BASE, 0xDEADBABE);\n\t}\n\n\tif ((ext_args-\u003estart_pt != IOT_STATUS_CONNECTING) \u0026\u0026\n\t\t\t(ext_args-\u003estart_pt != IOT_STATUS_PROVISIONING)) {\n\t\tIOT_ERROR(\"Unsupported request (%d)\\n\", ext_args-\u003estart_pt);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (!(ext_args-\u003eskip_usr_confirm) \u0026\u0026\n\t\t\t(ctx-\u003edevconf.ownership_validation_type \u0026 IOT_OVF_TYPE_BUTTON)) {\n\t\tif (!ext_args-\u003estatus_cb \u0026\u0026 (ext_args-\u003estart_pt == IOT_STATUS_PROVISIONING)) {\n\t\t\tIOT_ERROR(\"There is no status_cb for otm\");\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%d/%d)\", __func__,\n\t\text_args-\u003estart_pt, ext_args-\u003eskip_usr_confirm);\n\tIOT_DUMP_MAIN(INFO, BASE, ((ext_args-\u003estart_pt \u003c\u003c 8u) | ext_args-\u003eskip_usr_confirm));\n\n\tif ((ctx-\u003ecurr_state != IOT_STATE_UNKNOWN) || (ctx-\u003ereq_state != IOT_STATE_UNKNOWN)) {\n\t\tIOT_WARN(\"iot-core is already working(%d), stop \u0026 remove all cmd first\",\n\t\t\tctx-\u003ecurr_state);\n\t\tIOT_DUMP_MAIN(WARN, BASE, ctx-\u003ecurr_state);\n\n\t\t/* remove all queued commands */\n\t\tiot_os_mutex_lock(\u0026ctx-\u003eiot_cmd_lock);\n\t\t_throw_away_all_cmd_queue(ctx);\n\t\tiot_os_mutex_unlock(\u0026ctx-\u003eiot_cmd_lock);\n\n\t\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_STATE_UNKNOWN);\n\n\t\t/* change its state by UNKNOWN to reset all */\n\t\tiot_err = iot_state_update(ctx, IOT_STATE_UNKNOWN, 0);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to change IOT_STATE_UNKNOWN(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\t/* Wait until IOT_STATE_UNKNOWN changing done */\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_STATE_UNKNOWN, true, (NEXT_STATE_TIMEOUT_MS * 2));\n\n\t\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_STATE_UNKNOWN)) {\n\t\t\tIOT_ERROR(\"Timeout happened to change IOT_STATE_UNKNOWN\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0x8BADF00D);\n\t\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\t}\n\n\t/* Forcely set iot_state by initialized */\n\tctx-\u003ecurr_state = ctx-\u003ereq_state = IOT_STATE_INITIALIZED;\n\n\tif (ext_args-\u003estart_pt == IOT_STATUS_CONNECTING) {\n\t\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_CMD_DONE);\n\n\t\t/* Check if STDK can try to connect to sever */\n\t\tiot_err = _iot_command_peek(ctx, IOT_COMMAND_CHECK_PROV_STATUS);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to send check_prov(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE, true, (NEXT_STATE_TIMEOUT_MS * 2));\n\n\t\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_CMD_DONE)) {\n\t\t\tIOT_ERROR(\"Timeout happened for check_prov\");\n\t\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\tif (ctx-\u003eiot_reg_data.new_reged) {\n\t\t\tIOT_ERROR(\"Can't support request to go to connecting\");\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\tctx-\u003eiot_reg_data.updated = false;\n\t\tstate_data.iot_state = IOT_STATE_PROV_DONE;\n\t\tstate_data.opt = IOT_STATE_OPT_NONE;\n\t} else {\n\t\tif (ctx-\u003ees_res_created) {\n\t\t\tIOT_WARN(\"Already easysetup resources are created!!\");\n\t\t} else {\n\t\t\tiot_err = _create_easysetup_resources(ctx, ext_args-\u003epin_num);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to create easysetup resources(%d)\", iot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tgoto end_st_conn_start_ex;\n\t\t\t}\n\t\t}\n\n\t\tctx-\u003eiot_reg_data.new_reged = true;\n\t\tstate_data.iot_state = IOT_STATE_PROV_ENTER;\n\t\tstate_data.opt = IOT_STATE_OPT_NONE;\n\n\t\tif (ext_args-\u003eskip_usr_confirm) {\n\t\t\tctx-\u003eadd_justworks = true;\n\t\t\tIOT_DEBUG(\"Skip user confirm adding by JUSTWORK\");\n\t\t} else {\n\t\t\tctx-\u003eadd_justworks = false;\n\t\t}\n\t}\n\n\tif (ext_args-\u003estatus_cb) {\n\t\tSET_STATUS_CB(ext_args-\u003estatus_cb, ext_args-\u003emaps, ext_args-\u003eusr_data);\n\t}\n\n\tif (ext_args-\u003estart_pt == IOT_STATUS_PROVISIONING) {\n\t\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BITS_ST_CONN);\n\t}\n\n\tiot_err = iot_command_send(ctx, IOT_COMMNAD_STATE_UPDATE,\n\t\t\t\t\u0026state_data, sizeof(struct iot_state_data));\n\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to send command(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tif (ctx-\u003estatus_cb) {\n\t\t\tUNSET_STATUS_CB();\n\t\t}\n\n\t\tif (ctx-\u003ees_res_created) {\n\t\t\t_delete_easysetup_resources_all(ctx);\n\t\t}\n\t\tgoto end_st_conn_start_ex;\n\t}\n\n\tif (ext_args-\u003estart_pt == IOT_STATUS_PROVISIONING) {\n\t\tWAIT_USR_INTERACT();\n\t}\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\nend_st_conn_start_ex:\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1976,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"107315":{"score":0.8882276,"function_name":"st_info_get","code":"int st_info_get(IOT_CTX *iot_ctx, iot_info_type_t info_type, iot_info_data_t *info_data)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (!IS_CTX_VALID(ctx) || !info_data) {\n\t\tIOT_ERROR(\"invalid parameters\\n\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%d)\", __func__, info_type);\n\tIOT_DUMP_MAIN(INFO, BASE, info_type);\n\n\tswitch (info_type) {\n\tcase IOT_INFO_TYPE_IOT_STATUS_AND_STAT:\n\t\tif (ctx-\u003ereported_stat) {\n\t\t\tinfo_data-\u003est_status.iot_status = (ctx-\u003ereported_stat \u0026 IOT_STATUS_ALL);\n\t\t\tinfo_data-\u003est_status.stat_lv = (ctx-\u003ereported_stat \u003e\u003e 8u);\n\t\t} else {\n\t\t\tIOT_WARN(\"There is no reported_stat!!\");\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_INFO_TYPE_IOT_PROVISIONED:\n\t\tinfo_data-\u003eprovisioned = iot_nv_prov_data_exist();\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported iot_info_type!!(%d)\\n\", info_type);\n\t\tiot_err = IOT_ERROR_INVALID_ARGS;\n\t\tbreak;\n\t}\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":2145,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"107786":{"score":0.83042836,"function_name":"st_change_device_name","code":"int st_change_device_name(IOT_CTX *iot_ctx, const char *new_name)\n{\n\tint ret = IOT_ERROR_NONE;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tst_mqtt_msg msg = {0};\n\tJSON_H *json_root = NULL;\n\n\tif (!ctx || !new_name) {\n\t\tIOT_ERROR(\"invalid input params\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (strlen(new_name) \u003e IOT_DEVICE_NAME_MAX_LENGTH) {\n\t\tIOT_ERROR(\"new device name is over length(%d)\", IOT_DEVICE_NAME_MAX_LENGTH);\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tjson_root = JSON_CREATE_OBJECT();\n\tJSON_ADD_STRING_TO_OBJECT(json_root, \"label\", new_name);\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(json_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(json_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to make json string\");\n\t\tret = IOT_ERROR_BAD_REQ;\n\t\tgoto exit;\n\t}\n\tmsg.payloadlen = strlen(msg.payload);\n#endif\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = IOT_PUB_TOPIC_DEVICES_UPDATE;\n\n\tIOT_INFO(\"change device name, topic : %s, payload :\\n%s\",\n\t\t(char *)msg.topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tret = IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t\tIOT_ERROR(\"Failt to publish change period packet\");\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (msg.payload)\n\t\tfree(msg.payload);\n\tif (json_root)\n\t\tJSON_DELETE(json_root);\n\n\treturn ret;\n}","filepath":"src/iot_main.c","line_number":2189,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"108418":{"score":0.8227184,"function_name":"st_change_health_period","code":"int st_change_health_period(IOT_CTX *iot_ctx, unsigned int new_period)\n{\n\tint ret = IOT_ERROR_NONE;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tst_mqtt_msg msg = {0};\n\tJSON_H *json_root = NULL;\n\t/* MQTT connection expired after twice ping period */\n\tunsigned int new_mqtt_period = new_period/2;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"ctx is null\");\n\t    return IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tjson_root = JSON_CREATE_OBJECT();\n\tJSON_ADD_STRING_TO_OBJECT(json_root, \"status\", \"changePeriod\");\n\tJSON_ADD_NUMBER_TO_OBJECT(json_root, \"newPeriod\", new_mqtt_period);\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(json_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(json_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to make json string\");\n\t\tret = IOT_ERROR_BAD_REQ;\n\t\tgoto exit;\n\t}\n\tmsg.payloadlen = strlen(msg.payload);\n#endif\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = ctx-\u003emqtt_health_topic;\n\n\tIOT_INFO(\"publish event, topic : %s, payload :\\n%s\",\n\t\tctx-\u003emqtt_health_topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tret = IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t\tIOT_ERROR(\"Failt to publish change period packet\");\n\t\tgoto exit;\n\t}\n\tst_mqtt_change_ping_period(ctx-\u003eevt_mqttcli, new_mqtt_period);\n\nexit:\n\tif (msg.payload)\n\t\tfree(msg.payload);\n\tif (json_root)\n\t\tJSON_DELETE(json_root);\n\n\treturn ret;\n}","filepath":"src/iot_main.c","line_number":2247,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109051":{"score":0.77707094,"function_name":"_iot_mqtt_chunk_destroy","code":"static void _iot_mqtt_chunk_destroy(iot_mqtt_packet_chunk_t *chunk)\n{\n\tif (chunk \u0026\u0026 chunk-\u003echunk_data) {\n\t\tiot_os_free(chunk-\u003echunk_data);\n\t}\n\n\tif (chunk \u0026\u0026 chunk-\u003eexpiry_time) {\n\t\tiot_os_timer_destroy(\u0026chunk-\u003eexpiry_time);\n\t}\n\n\tif (chunk) {\n\t\tiot_os_free(chunk);\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":27,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109163":{"score":0.9062457,"function_name":"_iot_mqtt_chunk_create","code":"static iot_mqtt_packet_chunk_t * _iot_mqtt_chunk_create(size_t chunk_size)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL;\n\tiot_error_t iot_err;\n\n\tchunk = iot_os_malloc(sizeof(iot_mqtt_packet_chunk_t));\n\tif (chunk == NULL) {\n\t\tIOT_ERROR(\"chunk malloc fail\");\n\t\treturn NULL;\n\t}\n\tmemset(chunk, '\\0', sizeof(iot_mqtt_packet_chunk_t));\n\n\tchunk-\u003echunk_data = iot_os_malloc(chunk_size);\n\tif (chunk-\u003echunk_data == NULL) {\n\t\tIOT_ERROR(\"chunk data malloc fail\");\n\t\tiot_os_free(chunk);\n\t\treturn NULL;\n\t}\n\tchunk-\u003echunk_size = chunk_size;\n\n\tiot_err = iot_os_timer_init(\u0026chunk-\u003eexpiry_time);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init chunk expiry\");\n\t\tiot_os_free(chunk-\u003echunk_data);\n\t\tiot_os_free(chunk);\n\t\treturn NULL;\n\t}\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109482":{"score":0.8208867,"function_name":"_iot_mqtt_queue_push","code":"static int _iot_mqtt_queue_push(iot_mqtt_packet_chunk_queue_t *queue, iot_mqtt_packet_chunk_t *chunk)\n{\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn -1;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tqueue-\u003ehead = queue-\u003etail = chunk;\n\t} else {\n\t\tqueue-\u003etail-\u003enext = chunk;\n\t\tqueue-\u003etail = chunk;\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn 0;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":73,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109625":{"score":0.81532425,"function_name":"_iot_mqtt_queue_pop_by_type_and_id","code":"static iot_mqtt_packet_chunk_t* _iot_mqtt_queue_pop_by_type_and_id(iot_mqtt_packet_chunk_queue_t *queue,\n\t\t\t\t\t\t\t\tint packet_type, unsigned int packet_id)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL, *iterator = NULL;\n\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn NULL;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tchunk = NULL;\n\t} else if (queue-\u003ehead == queue-\u003etail) {\n\t\tif (queue-\u003ehead-\u003epacket_type == packet_type \u0026\u0026 queue-\u003ehead-\u003epacket_id == packet_id) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003etail = NULL;\n\t\t}\n\t} else {\n\t\tif (queue-\u003ehead-\u003epacket_type == packet_type \u0026\u0026 queue-\u003ehead-\u003epacket_id == packet_id) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003ehead-\u003enext;\n\t\t\tchunk-\u003enext = NULL;\n\t\t} else {\n\t\t\titerator = queue-\u003ehead;\n\t\t\twhile (iterator-\u003enext) {\n\t\t\t\tif (iterator-\u003enext-\u003epacket_type == packet_type \u0026\u0026 iterator-\u003enext-\u003epacket_id == packet_id) {\n\t\t\t\t\tchunk = iterator-\u003enext;\n\t\t\t\t\titerator-\u003enext = iterator-\u003enext-\u003enext;\n\t\t\t\t\tchunk-\u003enext = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titerator = iterator-\u003enext;\n\t\t\t}\n\t\t}\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109994":{"score":0.8275891,"function_name":"_iot_mqtt_queue_pop_by_expiry","code":"static iot_mqtt_packet_chunk_t* _iot_mqtt_queue_pop_by_expiry(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL, *iterator = NULL;\n\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn NULL;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tchunk = NULL;\n\t} else if (queue-\u003ehead == queue-\u003etail) {\n\t\tif (iot_os_timer_isexpired(queue-\u003ehead-\u003eexpiry_time)) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003etail = NULL;\n\t\t}\n\t} else {\n\t\tif (iot_os_timer_isexpired(queue-\u003ehead-\u003eexpiry_time)) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003ehead-\u003enext;\n\t\t\tchunk-\u003enext = NULL;\n\t\t} else {\n\t\t\titerator = queue-\u003ehead;\n\t\t\twhile (iterator-\u003enext) {\n\t\t\t\tif (iot_os_timer_isexpired(iterator-\u003enext-\u003eexpiry_time)) {\n\t\t\t\t\tchunk = iterator-\u003enext;\n\t\t\t\t\titerator-\u003enext = iterator-\u003enext-\u003enext;\n\t\t\t\t\tchunk-\u003enext = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titerator = iterator-\u003enext;\n\t\t\t}\n\t\t}\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":129,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110353":{"score":0.7784498,"function_name":"_iot_mqtt_queue_pop","code":"static iot_mqtt_packet_chunk_t* _iot_mqtt_queue_pop(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL;\n\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn NULL;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tchunk = NULL;\n\t} else if (queue-\u003ehead == queue-\u003etail) {\n\t\tchunk = queue-\u003ehead;\n\t\tqueue-\u003ehead = queue-\u003etail = NULL;\n\t} else {\n\t\tchunk = queue-\u003ehead;\n\t\tqueue-\u003ehead = queue-\u003ehead-\u003enext;\n\t\tchunk-\u003enext = NULL;\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":167,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110552":{"score":0.9377531,"function_name":"_iot_mqtt_queue_init","code":"static int _iot_mqtt_queue_init(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tiot_os_mutex_init(\u0026queue-\u003elock);\n\tif (queue-\u003elock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init queue lock\");\n\t\treturn -1;\n\t}\n\tqueue-\u003ehead = NULL;\n\tqueue-\u003etail = NULL;\n\n\treturn 0;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":190,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110670":{"score":0.72773904,"function_name":"_iot_mqtt_queue_destroy","code":"static void _iot_mqtt_queue_destroy(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tdo {\n\t\tif (queue-\u003elock.sem == NULL)\n\t\t\treturn;\n\t} while ((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE);\n\tiot_mqtt_packet_chunk_t *iterator = queue-\u003ehead, *tmp;\n\twhile (iterator) {\n\t\ttmp = iterator;\n\t\titerator = iterator-\u003enext;\n\t\tif (tmp-\u003ehave_owner) {\n\t\t\ttmp-\u003enext = NULL;\n\t\t\ttmp-\u003echunk_state = PACKET_CHUNK_QUEUE_DESTROYED;\n\t\t} else {\n\t\t\t_iot_mqtt_chunk_destroy(tmp);\n\t\t}\n\t}\n\tqueue-\u003ehead = queue-\u003etail = NULL;\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\tif (queue-\u003elock.sem != NULL) {\n\t\tiot_os_mutex_destroy(\u0026queue-\u003elock);\n\t\tqueue-\u003elock.sem = NULL;\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":203,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110887":{"score":0.81730896,"function_name":"_iot_mqtt_process_post_write","code":"static void _iot_mqtt_process_post_write(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tswitch(chunk-\u003epacket_type) {\n\t\tcase CONNECT:\n\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_ACK_PENDING;\n\t\t\tiot_os_timer_count_ms(chunk-\u003eexpiry_time, MQTT_CONNECT_TIMEOUT);\n\t\t\t_iot_mqtt_queue_push(\u0026client-\u003eack_pending_queue, chunk);\n\t\t\tbreak;\n\t\tcase SUBSCRIBE:\n\t\tcase UNSUBSCRIBE:\n\t\tcase PUBREL:\n\t\tcase PUBREC:\n\t\tcase PINGREQ:\n\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_ACK_PENDING;\n\t\t\tiot_os_timer_count_ms(chunk-\u003eexpiry_time, MQTT_RETRY_TIMEOUT);\n\t\t\t_iot_mqtt_queue_push(\u0026client-\u003eack_pending_queue, chunk);\n\t\t\tbreak;\n\t\tcase PUBLISH:\n\t\t\tif (chunk-\u003eqos == 0) {\n\t\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_WRITE_COMPLETED;\n\t\t\t\tif (!chunk-\u003ehave_owner) {\n\t\t\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_ACK_PENDING;\n\t\t\t\tiot_os_timer_count_ms(chunk-\u003eexpiry_time, MQTT_RETRY_TIMEOUT);\n\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003eack_pending_queue, chunk);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DISCONNECT:\n\t\t\tif (chunk-\u003ehave_owner) {\n\t\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_WRITE_COMPLETED;\n\t\t\t} else {\n\t\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\tbreak;\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":229,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"111225":{"score":0.9033985,"function_name":"_iot_mqtt_run_write_stream","code":"static int _iot_mqtt_run_write_stream(MQTTClient *client)\n{\n\tint rc = 0, written = 0;\n\tiot_error_t iot_err;\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\tiot_os_timer expiry_timer = NULL;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003ewrite_lock)) != IOT_OS_TRUE) {\n\t\treturn 0;\n\t}\n\n\tw_chunk = _iot_mqtt_queue_pop(\u0026client-\u003ewrite_pending_queue);\n\tif (w_chunk == NULL) {\n\t\tgoto exit;\n\t} else {\n\t\tiot_err = iot_os_timer_init(\u0026expiry_timer);\n\t\tif (iot_err) {\n\t\t\tIOT_ERROR(\"fail to init timer\");\n\t\t\twritten = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\t\tgoto exit;\n\t\t}\n\t\tiot_os_timer_count_ms(expiry_timer, MQTT_WRITE_TIMEOUT);\n\t}\n\n\tif(!client-\u003eisconnected) {\n\t\twritten = E_ST_MQTT_DISCONNECTED;\n\t\tgoto exit;\n\t}\n\n\twhile (written != w_chunk-\u003echunk_size \u0026\u0026 !iot_os_timer_isexpired(expiry_timer)) {\n\t\trc = client-\u003enet-\u003ewrite(client-\u003enet, \u0026w_chunk-\u003echunk_data[written],\n\t\t\t\tw_chunk-\u003echunk_size - written, expiry_timer);\n\n\t\tif (rc \u003e 0) {\n\t\t\twritten += rc;\n\t\t\tiot_os_timer_count_ms(expiry_timer, MQTT_WRITE_TIMEOUT);\n\t\t} else if (rc \u003c 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (written == w_chunk-\u003echunk_size) {\n\t\t_iot_mqtt_process_post_write(client, w_chunk);\n\t\tw_chunk = NULL;\n\t} else {\n\t\twritten = E_ST_MQTT_NETWORK_ERROR;\n\t}\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003ewrite_lock);\n\n\tif (expiry_timer) {\n\t\tiot_os_timer_destroy(\u0026expiry_timer);\n\t}\n\n\tif (written \u003c 0 \u0026\u0026 w_chunk != NULL) {\n\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_WRITE_FAIL;\n\t\tw_chunk-\u003ereturn_code = written;\n\t\tif (!w_chunk-\u003ehave_owner) {\n\t\t\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, w_chunk);\n\t\t}\n\t}\n\n\tif (written \u003e 0) {\n\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\tif((iot_os_mutex_lock(\u0026client-\u003eclient_manage_lock)) == IOT_OS_TRUE) {\n\t\t\t\tiot_os_timer_count_ms(client-\u003elast_sent, client-\u003ekeepAliveInterval * 1000);\n\t\t\t\tiot_os_mutex_unlock(\u0026client-\u003eclient_manage_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn written;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":271,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"111931":{"score":0.67301285,"function_name":"_convert_return_code","code":"static int _convert_return_code(int mqtt_rc)\n{\n\tint rc;\n\tswitch (mqtt_rc) {\n\tcase MQTT_CONNECTION_ACCEPTED:\n\t\trc = 0;\n\t\tbreak;\n\tcase MQTT_UNNACCEPTABLE_PROTOCOL:\n\t\trc = E_ST_MQTT_UNNACCEPTABLE_PROTOCOL;\n\t\tbreak;\n\tcase MQTT_SERVER_UNAVAILABLE:\n\t\trc = E_ST_MQTT_SERVER_UNAVAILABLE;\n\t\tbreak;\n\tcase MQTT_CLIENTID_REJECTED:\n\t\trc = E_ST_MQTT_CLIENTID_REJECTED;\n\t\tbreak;\n\tcase MQTT_BAD_USERNAME_OR_PASSWORD:\n\t\trc = E_ST_MQTT_BAD_USERNAME_OR_PASSWORD;\n\t\tbreak;\n\tcase MQTT_NOT_AUTHORIZED:\n\t\trc = E_ST_MQTT_NOT_AUTHORIZED;\n\t\tbreak;\n\tdefault:\n\t\trc = E_ST_MQTT_FAILURE;\n\t\tbreak;\n\t}\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":350,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"112037":{"score":0.83691496,"function_name":"_iot_mqtt_process_received_ack","code":"static void _iot_mqtt_process_received_ack(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tiot_mqtt_packet_chunk_t *tmp = NULL;\n\n\tif (chunk-\u003epacket_type == CONNACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, CONNECT, 0);\n\t} else if (chunk-\u003epacket_type == PUBACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBLISH, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == SUBACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, SUBSCRIBE, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == UNSUBACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, UNSUBSCRIBE, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == PUBCOMP) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBREL, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == PINGRESP) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PINGREQ, 0);\n\t} else {\n\t\treturn;\n\t}\n\n\tif (tmp != NULL) {\n\t\tif (chunk-\u003epacket_type == CONNACK) {\n\t\t\tunsigned char ack_rc = 0;\n\t\t\tunsigned char sessionPresent = 0;\n\n\t\t\tMQTTDeserialize_connack(\u0026sessionPresent, \u0026ack_rc, chunk-\u003echunk_data, chunk-\u003echunk_size);\n\t\t\ttmp-\u003ereturn_code = _convert_return_code(ack_rc);\n\t\t} else if (chunk-\u003epacket_type == SUBACK) {\n\t\t\tint count = 0, ack_qos;\n\t\t\tunsigned short mypacketid;\n\t\t\tMQTTDeserialize_suback(\u0026mypacketid, 1, \u0026count, (int *)\u0026ack_qos, chunk-\u003echunk_data, chunk-\u003echunk_size);\n\t\t\tif (ack_qos == 0x80) {\n\t\t\t\ttmp-\u003ereturn_code = E_ST_MQTT_FAILURE;\n\t\t\t} else {\n\t\t\t\ttmp-\u003ereturn_code = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp-\u003ehave_owner) {\n\t\t\ttmp-\u003echunk_state = PACKET_CHUNK_ACKNOWLEDGED;\n\t\t} else {\n\t\t\t_iot_mqtt_chunk_destroy(tmp);\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"There is no ack packet matched\");\n\t}\n\t_iot_mqtt_chunk_destroy(chunk);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":379,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"112631":{"score":0.88750464,"function_name":"_iot_mqtt_process_received_publish","code":"static void _iot_mqtt_process_received_publish(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\t// Send Ack back\n\tif (chunk-\u003eqos != st_mqtt_qos0) {\n\t\tiot_mqtt_packet_chunk_t *puback;\n\t\tpuback = _iot_mqtt_chunk_create(MQTT_ACK_PACKET_SIZE);\n\t\tif (puback == NULL) {\n\t\t\tIOT_ERROR(\"chunk malloc fail\");\n\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\treturn;\n\t\t}\n\n\t\tpuback-\u003epacket_id = chunk-\u003epacket_id;\n\t\tif (chunk-\u003eqos == st_mqtt_qos1) {\n\t\t\tpuback-\u003epacket_type = PUBACK;\n\t\t\tMQTTSerialize_ack(puback-\u003echunk_data, puback-\u003echunk_size, PUBACK, 0, puback-\u003epacket_id);\n\t\t} else if (chunk-\u003eqos == st_mqtt_qos2) {\n\t\t\tpuback-\u003epacket_type = PUBREC;\n\t\t\tMQTTSerialize_ack(puback-\u003echunk_data, puback-\u003echunk_size, PUBREC, 0, puback-\u003epacket_id);\n\t\t}\n\t\tpuback-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, puback);\n\t}\n\n\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, chunk);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":428,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"112936":{"score":0.8590853,"function_name":"_iot_mqtt_process_received_pubrec_pubrel","code":"static void _iot_mqtt_process_received_pubrec_pubrel(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tiot_mqtt_packet_chunk_t *tmp = NULL;\n\n\tif (chunk-\u003epacket_type == PUBREC) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBLISH, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == PUBREL) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBREC, chunk-\u003epacket_id);\n\t} else {\n\t\treturn;\n\t}\n\t_iot_mqtt_chunk_destroy(chunk);\n\n\t// Recycling packet\n\tif (tmp != NULL) {\n\t\tiot_os_free(tmp-\u003echunk_data);\n\t\ttmp-\u003echunk_data = NULL;\n\n\t\ttmp-\u003echunk_size = MQTT_ACK_PACKET_SIZE;\n\t\ttmp-\u003echunk_data = iot_os_malloc(tmp-\u003echunk_size);\n\t\tif (tmp-\u003echunk_data == NULL) {\n\t\t\tIOT_ERROR(\"chunk data malloc fail\");\n\t\t\t_iot_mqtt_chunk_destroy(tmp);\n\t\t\treturn;\n\t\t}\n\t\tif (tmp-\u003epacket_type == PUBLISH) {\n\t\t\ttmp-\u003epacket_type = PUBREL;\n\t\t\tMQTTSerialize_ack(tmp-\u003echunk_data, tmp-\u003echunk_size, PUBREL, 0, tmp-\u003epacket_id);\n\t\t} else if (tmp-\u003epacket_type == PUBREC) {\n\t\t\ttmp-\u003epacket_type = PUBCOMP;\n\t\t\tMQTTSerialize_ack(tmp-\u003echunk_data, tmp-\u003echunk_size, PUBCOMP, 0, tmp-\u003epacket_id);\n\t\t}\n\t\ttmp-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, tmp);\n\t} else {\n\t\tIOT_ERROR(\"There is no ack packet matched\");\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":455,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"113405":{"score":0.87487894,"function_name":"_iot_mqtt_process_post_read","code":"static void _iot_mqtt_process_post_read(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tswitch (chunk-\u003epacket_type) {\n\t\tcase CONNACK:\n\t\tcase PUBACK:\n\t\tcase SUBACK:\n\t\tcase UNSUBACK:\n\t\tcase PUBCOMP:\n\t\tcase PINGRESP:\n\t\t\t_iot_mqtt_process_received_ack(client, chunk);\n\t\t\tbreak;\n\t\tcase PUBLISH:\n\t\t\t_iot_mqtt_process_received_publish(client, chunk);\n\t\t\tbreak;\n\t\tcase PUBREC:\n\t\tcase PUBREL:\n\t\t\t_iot_mqtt_process_received_pubrec_pubrel(client, chunk);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIOT_WARN(\"There is no read packet type handle %d\", chunk-\u003epacket_type);\n\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\tbreak;\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":494,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"113571":{"score":0.9040868,"function_name":"_iot_mqtt_run_read_stream","code":"static int _iot_mqtt_run_read_stream(MQTTClient *client)\n{\n\tint rc = 0 , read = 0;\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\tiot_error_t iot_err;\n\tiot_os_timer expiry_timer = NULL;\n\tunsigned char packet_fixed_header[MAX_NUM_OF_REMAINING_LENGTH_BYTES + 1];\n\tint rem_size = 0, multiplier = 1;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003eread_lock)) != IOT_OS_TRUE) {\n\t\treturn 0;\n\t}\n\tif(!client-\u003eisconnected) {\n\t\tread = E_ST_MQTT_DISCONNECTED;\n\t\tgoto exit;\n\t}\n\n\trc = client-\u003enet-\u003eselect(client-\u003enet, 0);\n\tif (rc \u003c 0) {\n\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\tgoto exit;\n\t} else if (rc == 0) {\n\t\tgoto exit;\n\t} else {\n\t\tiot_err = iot_os_timer_init(\u0026expiry_timer);\n\t\tif (iot_err) {\n\t\t\tIOT_ERROR(\"fail to init timer\");\n\t\t\tread = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\t\tgoto exit;\n\t\t}\n\t\tiot_os_timer_count_ms(expiry_timer, MQTT_READ_TIMEOUT);\n\t}\n\n\trc = client-\u003enet-\u003eread(client-\u003enet, \u0026packet_fixed_header[0], 1, expiry_timer);\n\tif (rc \u003c= 0) {\n\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\tgoto exit;\n\t}\n\tread++;\n\tdo {\n\t\tif (read - 1 \u003e= MAX_NUM_OF_REMAINING_LENGTH_BYTES) {\n\t\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\trc = client-\u003enet-\u003eread(client-\u003enet, \u0026packet_fixed_header[read], 1, expiry_timer);\n\t\tif (rc \u003c= 0) {\n\t\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\trem_size += (packet_fixed_header[read] \u0026 127) * multiplier;\n\t\tmultiplier *= 128;\n\t\tread++;\n\t} while ((packet_fixed_header[read - 1] \u0026 128) != 0);\n\n\tw_chunk = _iot_mqtt_chunk_create(read + rem_size);\n\tif (w_chunk == NULL) {\n\t\tIOT_ERROR(\"chunk malloc fail\");\n\t\tread = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tmemcpy(w_chunk-\u003echunk_data, packet_fixed_header, read);\n\n\twhile (read != w_chunk-\u003echunk_size \u0026\u0026 !iot_os_timer_isexpired(expiry_timer)) {\n\t\trc = client-\u003enet-\u003eread(client-\u003enet, w_chunk-\u003echunk_data + read,\n\t\t\t\tw_chunk-\u003echunk_size - read, expiry_timer);\n\t\tif (rc \u003c 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tread += rc;\n\t\t\tiot_os_timer_count_ms(expiry_timer, MQTT_READ_TIMEOUT);\n\t\t}\n\t}\n\n\tif (read == w_chunk-\u003echunk_size) {\n\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_READ_COMPLETED;\n\t\tw_chunk-\u003epacket_type = (w_chunk-\u003echunk_data[0] \u0026 MQTT_FIXED_HEADER_PACKET_TYPE_MASK) \u003e\u003e MQTT_FIXED_HEADER_PACKET_TYPE_OFFSET;\n\t\tw_chunk-\u003eqos = (w_chunk-\u003echunk_data[0] \u0026 MQTT_FIXED_HEADER_QOS_MASK) \u003e\u003e MQTT_FIXED_HEADER_QOS_OFFSET;\n\t\tw_chunk-\u003epacket_id = MQTTPacket_getPacketId(w_chunk-\u003echunk_data);\n\t\t_iot_mqtt_process_post_read(client, w_chunk);\n\t\tw_chunk = NULL;\n\t} else {\n\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t}\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\n\tif (expiry_timer) {\n\t\tiot_os_timer_destroy(\u0026expiry_timer);\n\t}\n\n\tif (w_chunk != NULL) {\n\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t}\n\n\tif (read \u003e 0) {\n\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\tif((iot_os_mutex_lock(\u0026client-\u003eclient_manage_lock)) == IOT_OS_TRUE) {\n\t\t\t\tiot_os_timer_count_ms(client-\u003elast_received, client-\u003ekeepAliveInterval * 1000);\n\t\t\t\tiot_os_mutex_unlock(\u0026client-\u003eclient_manage_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn read;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":519,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"114645":{"score":0.83593607,"function_name":"st_mqtt_create","code":"int st_mqtt_create(st_mqtt_client *client, st_mqtt_event_callback callback_fp, void *user_data)\n{\n\tMQTTClient *c = NULL;\n\tint rc = E_ST_MQTT_FAILURE;\n\tiot_error_t iot_err;\n\n\tif (callback_fp == NULL) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\t*client = iot_os_malloc(sizeof(MQTTClient));\n\tif (*client == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\tgoto error_handle;\n\t}\n\tmemset(*client, '\\0', sizeof(MQTTClient));\n\n\tc = *client;\n\tc-\u003emagic = MQTT_CLIENT_STRUCT_MAGIC_NUMBER;\n\tc-\u003euser_callback_fp = callback_fp;\n\tc-\u003euser_callback_user_data = user_data;\n\n\tc-\u003enet = iot_os_malloc(sizeof(iot_net_interface_t));\n\tif (c-\u003enet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\tgoto error_handle;\n\t}\n\tmemset(c-\u003enet, '\\0', sizeof(iot_net_interface_t));\n\tc-\u003enext_packetid = 1;\n\tiot_err = iot_os_timer_init(\u0026c-\u003elast_sent);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init last_send timer\");\n\t\tgoto error_handle;\n\t}\n\tiot_err = iot_os_timer_init(\u0026c-\u003elast_received);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init last_received timer\");\n\t\tgoto error_handle;\n\t}\n\tiot_os_mutex_init(\u0026c-\u003eclient_manage_lock);\n\tif (c-\u003eclient_manage_lock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init mutex\");\n\t\tgoto error_handle;\n\t}\n\tc-\u003ethread = NULL;\n\tiot_os_mutex_init(\u0026c-\u003ewrite_lock);\n\tif (c-\u003ewrite_lock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init write_lock\");\n\t\tgoto error_handle;\n\t}\n\tiot_os_mutex_init(\u0026c-\u003eread_lock);\n\tif (c-\u003eread_lock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init read_lock\");\n\t\tgoto error_handle;\n\t}\n\tif ((_iot_mqtt_queue_init(\u0026c-\u003ewrite_pending_queue))) {\n\t\tgoto error_handle;\n\t}\n\tif ((_iot_mqtt_queue_init(\u0026c-\u003eack_pending_queue))) {\n\t\tgoto error_handle;\n\t}\n\tif ((_iot_mqtt_queue_init(\u0026c-\u003euser_event_callback_queue))) {\n\t\tgoto error_handle;\n\t}\n\tif ((c-\u003eping_packet = _iot_mqtt_chunk_create(MQTT_PINGREQ_PACKET_SIZE)) == NULL) {\n\t\tgoto error_handle;\n\t}\n\tMQTTSerialize_pingreq(c-\u003eping_packet-\u003echunk_data, MQTT_PINGREQ_PACKET_SIZE);\n\tc-\u003eping_packet-\u003epacket_type = PINGREQ;\n\tc-\u003eping_packet-\u003ehave_owner = 1;\n\n\treturn 0;\nerror_handle:\n\tif (c) {\n\t\tif (c-\u003enet)\n\t\t\tiot_os_free(c-\u003enet);\n\t\tif (c-\u003elast_sent)\n\t\t\tiot_os_timer_destroy(\u0026c-\u003elast_sent);\n\t\tif (c-\u003elast_received)\n\t\t\tiot_os_timer_destroy(\u0026c-\u003elast_received);\n\t\tif (c-\u003eclient_manage_lock.sem)\n\t\t\tiot_os_mutex_destroy(\u0026c-\u003eclient_manage_lock);\n\t\tif (c-\u003ewrite_lock.sem)\n\t\t\tiot_os_mutex_destroy(\u0026c-\u003ewrite_lock);\n\t\tif (c-\u003eread_lock.sem)\n\t\t\tiot_os_mutex_destroy(\u0026c-\u003eread_lock);\n\t\t_iot_mqtt_queue_destroy(\u0026c-\u003ewrite_pending_queue);\n\t\t_iot_mqtt_queue_destroy(\u0026c-\u003eack_pending_queue);\n\t\t_iot_mqtt_queue_destroy(\u0026c-\u003euser_event_callback_queue);\n\t\tif (c-\u003eping_packet) {\n\t\t\t_iot_mqtt_chunk_destroy(c-\u003eping_packet);\n\t\t}\n\t\tiot_os_free(c);\n\t\t*client = NULL;\n\t}\n\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_MQTT_CREATE_FAIL, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":630,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"115760":{"score":0.83335376,"function_name":"_iot_mqtt_close_net","code":"static void _iot_mqtt_close_net(MQTTClient *client)\n{\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif (client-\u003eread_lock.sem == NULL)\n\t\t\treturn;\n\t} while ((iot_os_mutex_lock(\u0026client-\u003eread_lock)) != IOT_OS_TRUE);\n\n\tdo {\n\t\tif (client-\u003ewrite_lock.sem == NULL) {\n\t\t\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\t\t\treturn;\n\t\t}\n\t} while ((iot_os_mutex_lock(\u0026client-\u003ewrite_lock)) != IOT_OS_TRUE);\n\tif (client-\u003eisconnected) {\n\t\tclient-\u003eisconnected = 0;\n\t\tclient-\u003enet-\u003eshow_status(client-\u003enet);\n\t\tclient-\u003enet-\u003edisconnect(client-\u003enet);\n\t}\n\tiot_os_mutex_unlock(\u0026client-\u003ewrite_lock);\n\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":729,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"116036":{"score":0.90561265,"function_name":"_iot_mqtt_connect_net","code":"static int _iot_mqtt_connect_net(MQTTClient *client, st_mqtt_broker_info_t *broker)\n{\n\tint rc = 0, connect_retry = 3;\n\tiot_error_t iot_err;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003eread_lock)) != IOT_OS_TRUE) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003ewrite_lock)) != IOT_OS_TRUE) {\n\t\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tiot_err = iot_net_init(client-\u003enet);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"failed to init network\");\n\t\trc = E_ST_MQTT_FAILURE;\n\t\tgoto exit;\n\t}\n\n\tclient-\u003enet-\u003econnection.url = broker-\u003eurl;\n\tclient-\u003enet-\u003econnection.port = broker-\u003eport;\n\tclient-\u003enet-\u003econnection.ca_cert = broker-\u003eca_cert;\n\tclient-\u003enet-\u003econnection.ca_cert_len = broker-\u003eca_cert_len;\n\n\tdo {\n\t\tiot_err = client-\u003enet-\u003econnect(client-\u003enet);\n\t\tif (iot_err) {\n\t\t\tIOT_ERROR(\"net-\u003econnect = %d, retry (%d)\", iot_err, connect_retry);\n\t\t\tconnect_retry--;\n\t\t\tiot_os_delay(2000);\n\t\t}\n\t} while ((iot_err != IOT_ERROR_NONE) \u0026\u0026 connect_retry);\n\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"MQTT net connection failed\");\n\t\trc = E_ST_MQTT_FAILURE;\n\t\tgoto exit;\n\t}\n\n\tif (client-\u003enet-\u003etcp_keepalive) {\n\t\tiot_err = client-\u003enet-\u003etcp_keepalive(client-\u003enet, ST_MQTT_TCP_KEEPALIVE_IDLE,\n\t\t\t\tST_MQTT_TCP_KEEPALIVE_COUNT,\n\t\t\t\tST_MQTT_TCP_KEEPALIVE_INTERVAL);\n\t\tif (iot_err) {\n\t\t\tIOT_WARN(\"fail to set keepalive %d\", iot_err);\n\t\t}\n\t}\n\n\tclient-\u003eisconnected = 1;\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003ewrite_lock);\n\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":755,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"116655":{"score":0.84203696,"function_name":"st_mqtt_destroy","code":"void st_mqtt_destroy(st_mqtt_client client)\n{\n\tMQTTClient *c = client;\n\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn;\n\t}\n\t// invalidate MQTTClient struct\n\tc-\u003emagic = 0;\n\n\t_iot_mqtt_close_net(c);\n\tiot_os_free(c-\u003enet);\n\tiot_os_mutex_destroy(\u0026c-\u003ewrite_lock);\n\tiot_os_mutex_destroy(\u0026c-\u003eread_lock);\n\n\t_iot_mqtt_queue_destroy(\u0026c-\u003ewrite_pending_queue);\n\t_iot_mqtt_queue_destroy(\u0026c-\u003eack_pending_queue);\n\t_iot_mqtt_queue_destroy(\u0026c-\u003euser_event_callback_queue);\n\tdo {\n\t\tif (c-\u003eclient_manage_lock.sem == NULL)\n\t\t\tgoto skip_manage_lock;\n\t} while ((iot_os_mutex_lock(\u0026c-\u003eclient_manage_lock)) != IOT_OS_TRUE);\n\tiot_os_timer_destroy(\u0026c-\u003elast_sent);\n\tiot_os_timer_destroy(\u0026c-\u003elast_received);\n\tif (c-\u003eping_packet) {\n\t\t_iot_mqtt_chunk_destroy(c-\u003eping_packet);\n\t}\n\tiot_os_mutex_unlock(\u0026c-\u003eclient_manage_lock);\n\tiot_os_mutex_destroy(\u0026c-\u003eclient_manage_lock);\n\nskip_manage_lock:\n\tc-\u003ethread = NULL;\n\tiot_os_free(c);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":818,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"117017":{"score":0.8323635,"function_name":"_iot_mqtt_check_alive","code":"static int _iot_mqtt_check_alive(MQTTClient *client)\n{\n\tint rc = 0;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003eclient_manage_lock)) != IOT_OS_TRUE) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\tif (iot_os_timer_isexpired(client-\u003elast_sent) || iot_os_timer_isexpired(client-\u003elast_received)) {\n\t\tswitch (client-\u003eping_packet-\u003echunk_state) {\n\t\t\tcase PACKET_CHUNK_ACKNOWLEDGED :\n\t\t\tcase PACKET_CHUNK_INIT :\n\t\t\t\tclient-\u003eping_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t\t\tclient-\u003eping_packet-\u003eretry_count = 0;\n\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, client-\u003eping_packet);\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_TIMEOUT:\n\t\t\t\tclient-\u003eping_packet-\u003echunk_state = PACKET_CHUNK_INIT;\n\t\t\t\tIOT_WARN(\"mqtt didn't get PINGRESP\");\n\t\t\t\trc = E_ST_MQTT_FAILURE;\n\t\t\t\tgoto exit;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003eclient_manage_lock);\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":853,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"117326":{"score":0.79128313,"function_name":"_iot_mqtt_process_pending_packets","code":"static void _iot_mqtt_process_pending_packets(MQTTClient *client)\n{\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\n\twhile (1) {\n\t\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\treturn;\n\t\t}\n\t\tw_chunk = _iot_mqtt_queue_pop_by_expiry(\u0026client-\u003eack_pending_queue);\n\t\tif (w_chunk == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (w_chunk-\u003epacket_type) {\n\t\t\tcase CONNECT:\n\t\t\t\tif (w_chunk-\u003ehave_owner) {\n\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t} else {\n\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, w_chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tw_chunk-\u003eretry_count++;\n\t\t\t\tif (w_chunk-\u003eretry_count \u003c MQTT_PUBLISH_RETRY) {\n\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t\t\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, w_chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (w_chunk-\u003ehave_owner) {\n\t\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\t\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, w_chunk);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":888,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"117885":{"score":0.7342379,"function_name":"_iot_mqtt_notify_publish_failed","code":"static void _iot_mqtt_notify_publish_failed(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tst_mqtt_msg msg;\n\tMQTTString topic_name;\n\tint qos;\n\tunsigned char dup;\n\tunsigned short id;\n\n\tMQTTDeserialize_publish(\u0026dup, \u0026qos, \u0026msg.retained, \u0026id, \u0026topic_name,\n\t\t\t\t\t\t\t(unsigned char **)\u0026msg.payload, (int *)\u0026msg.payloadlen, chunk-\u003echunk_data, chunk-\u003echunk_size);\n\n\tmsg.qos = qos;\n\tmsg.topic = topic_name.lenstring.data;\n\tmsg.topiclen = topic_name.lenstring.len;\n\tclient-\u003euser_callback_fp(ST_MQTT_EVENT_PUBLISH_FAILED, \u0026msg, client-\u003euser_callback_user_data);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":956,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118060":{"score":0.77492577,"function_name":"_iot_mqtt_process_user_callback","code":"static void _iot_mqtt_process_user_callback(MQTTClient *client)\n{\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\n\twhile (1) {\n\t\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\treturn;\n\t\t}\n\t\tw_chunk = _iot_mqtt_queue_pop(\u0026client-\u003euser_event_callback_queue);\n\t\tif (w_chunk == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (w_chunk-\u003echunk_state) {\n\t\t\tcase PACKET_CHUNK_TIMEOUT:\n\t\t\tcase PACKET_CHUNK_WRITE_FAIL:\n\t\t\t\tif (w_chunk-\u003epacket_type == PUBLISH) {\n\t\t\t\t\t_iot_mqtt_notify_publish_failed(client, w_chunk);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_READ_COMPLETED:\n\t\t\t\tif (w_chunk-\u003epacket_type == PUBLISH) {\n\t\t\t\t\t_iot_mqtt_deliver_publish(client, w_chunk);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tbreak;\n\t\t}\n\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":973,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118246":{"score":0.5615359,"function_name":"_iot_mqtt_run_cycle","code":"static int _iot_mqtt_run_cycle(MQTTClient *client)\n{\n\tint rc = 0;\n\n\trc = _iot_mqtt_run_write_stream(client);\n\tif (rc \u003c 0) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_MQTT_WRITE_STREAM_FAIL, rc, 0);\n\t\treturn rc;\n\t}\n\n\trc = _iot_mqtt_run_read_stream(client);\n\tif (rc \u003c 0) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_MQTT_READ_STREAM_FAIL, rc, 0);\n\t\treturn rc;\n\t}\n\n\t_iot_mqtt_process_pending_packets(client);\n\n\trc = _iot_mqtt_check_alive(client);\n\tif (rc \u003c 0) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_MQTT_PING_FAIL, rc, 0);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1004,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118372":{"score":0.82981354,"function_name":"st_mqtt_yield","code":"int st_mqtt_yield(st_mqtt_client client, int time)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tiot_error_t iot_err;\n\tiot_os_timer timer;\n\n\tiot_err = iot_os_timer_init(\u0026timer);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init timer\");\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\tiot_os_timer_count_ms(timer, time);\n\n\tdo {\n\t\trc = _iot_mqtt_run_cycle(c);\n\t\t_iot_mqtt_process_user_callback(c);\n\t} while (!iot_os_timer_isexpired(timer) \u0026\u0026 !rc);\n\tiot_os_timer_destroy(\u0026timer);\n\n\t// Check if there is left work to do.\n\tif (rc == 0) {\n\t\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\treturn E_ST_MQTT_FAILURE;\n\t\t}\n\n\t\tif((iot_os_mutex_lock(\u0026c-\u003eread_lock)) == IOT_OS_TRUE) {\n\t\t\tif (c-\u003ewrite_pending_queue.head != NULL) {\n\t\t\t\trc = 1;\n\t\t\t} else if (c-\u003euser_event_callback_queue.head != NULL) {\n\t\t\t\trc = 1;\n\t\t\t} else if(c-\u003eisconnected \u0026\u0026 (c-\u003enet-\u003eselect(c-\u003enet, 0) \u003e 0)) {\n\t\t\t\trc = 1;\n\t\t\t}\n\n\t\t\tiot_os_mutex_unlock(\u0026c-\u003eread_lock);\n\t\t}\n\t}\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1031,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118784":{"score":0.7041745,"function_name":"_iot_mqtt_thread_run","code":"static void _iot_mqtt_thread_run(void *parm)\n{\n\tMQTTClient *client = (MQTTClient *)parm;\n\tint rc = 0;\n\n\tdo {\n\t\trc = _iot_mqtt_run_cycle(client);\n\t\t_iot_mqtt_process_user_callback(client);\n\t\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\tbreak;\n\t\t}\n\t} while (!rc \u0026\u0026 client-\u003ethread);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1073,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118998":{"score":0.7701795,"function_name":"_iot_mqtt_wait_for","code":"static int _iot_mqtt_wait_for(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tiot_mqtt_packet_chunk_t *tmp = NULL;\n\tint rc = 0;\n\n\twhile (1) {\n\t\trc = _iot_mqtt_run_cycle(client);\n\t\tswitch (chunk-\u003echunk_state) {\n\t\t\tcase PACKET_CHUNK_WRITE_PENDING:\n\t\t\t\tif (rc \u003c 0) {\n\t\t\t\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003ewrite_pending_queue, chunk-\u003epacket_type, chunk-\u003epacket_id);\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_ACK_PENDING:\n\t\t\t\tif (rc \u003c 0) {\n\t\t\t\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, chunk-\u003epacket_type, chunk-\u003epacket_id);\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiot_os_delay(MQTT_ACKPENDING_WAITCYCLE_IN_SYNC_FUNCTION);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_WRITE_COMPLETED:\n\t\t\tcase PACKET_CHUNK_ACKNOWLEDGED:\n\t\t\t\trc = chunk-\u003ereturn_code;\n\t\t\t\tgoto exit;\n\t\t\tcase PACKET_CHUNK_QUEUE_DESTROYED:\n\t\t\tcase PACKET_CHUNK_WRITE_FAIL:\n\t\t\tcase PACKET_CHUNK_TIMEOUT:\n\t\t\t\trc = E_ST_MQTT_FAILURE;\n\t\t\t\tgoto exit;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\nexit:\n\t_iot_mqtt_chunk_destroy(chunk);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1103,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"119251":{"score":0.8537276,"function_name":"st_mqtt_connect","code":"int st_mqtt_connect(st_mqtt_client client, st_mqtt_broker_info_t *broker, st_mqtt_connect_data *connect_data)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tMQTTPacket_connectData options = MQTTPacket_connectData_initializer;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *connect_packet = NULL;\n\n\trc = _iot_mqtt_connect_net(c, broker);\n\tif (rc \u003c 0) {\n\t\treturn rc;\n\t}\n\n\tif (connect_data-\u003ewill_flag) {\n\t\toptions.willFlag = 1;\n\t\toptions.will.topicName.cstring = connect_data-\u003ewill_topic;\n\t\toptions.will.message.cstring = connect_data-\u003ewill_message;\n\t\toptions.will.retained = connect_data-\u003ewill_retained;\n\t\toptions.will.qos = connect_data-\u003ewill_qos;\n\t} else\n\t\toptions.willFlag = 0;\n\n\toptions.MQTTVersion  = connect_data-\u003emqtt_ver;\n\toptions.clientID.cstring  = connect_data-\u003eclientid;\n\toptions.username.cstring  = connect_data-\u003eusername;\n\toptions.password.cstring  = connect_data-\u003epassword;\n\toptions.keepAliveInterval = connect_data-\u003ealive_interval;\n\toptions.cleansession = connect_data-\u003ecleansession;\n\n\tchunk_size = MQTTSerialize_connect_size(\u0026options);\n\tconnect_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (connect_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tMQTTSerialize_connect(connect_packet-\u003echunk_data, chunk_size, \u0026options);\n\tconnect_packet-\u003epacket_type = CONNECT;\n\tconnect_packet-\u003ehave_owner = 1;\n\tif (c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(connect_packet);\n\t\tgoto exit;\n\t}\n\tc-\u003ekeepAliveInterval = options.keepAliveInterval;\n\tiot_os_timer_count_ms(c-\u003elast_sent, c-\u003ekeepAliveInterval * 1000);\n\tiot_os_timer_count_ms(c-\u003elast_received, c-\u003ekeepAliveInterval * 1000);\n\tconnect_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, connect_packet);\n\n\trc = _iot_mqtt_wait_for(c, connect_packet);\n\nexit:\n\tif (rc \u003c 0) {\n\t\t_iot_mqtt_close_net(c);\n\t}\n\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_CONNECT_RESULT, rc, connect_data-\u003ealive_interval);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1148,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"119914":{"score":0.75464755,"function_name":"st_mqtt_subscribe","code":"int st_mqtt_subscribe(st_mqtt_client client, const char *topic, int qos)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *sub_packet = NULL;\n\tMQTTString Topic = MQTTString_initializer;\n\tTopic.cstring = (char *)topic;\n\n\tchunk_size = MQTTSerialize_subscribe_size(1, \u0026Topic);\n\tsub_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (sub_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(sub_packet);\n\t\tgoto exit;\n\t}\n\tc-\u003enext_packetid = (c-\u003enext_packetid \u003e= MAX_PACKET_ID) ? 1 : c-\u003enext_packetid + 1;\n\tsub_packet-\u003epacket_id = c-\u003enext_packetid;\n\tMQTTSerialize_subscribe(sub_packet-\u003echunk_data, chunk_size, 0, sub_packet-\u003epacket_id, 1, \u0026Topic, (int *)\u0026qos);\n\tsub_packet-\u003epacket_type = SUBSCRIBE;\n\tsub_packet-\u003ehave_owner = 1;\n\tsub_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, sub_packet);\n\n\trc = _iot_mqtt_wait_for(c, sub_packet);\n\nexit:\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_SUBSCRIBE, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1209,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"120323":{"score":0.8373562,"function_name":"st_mqtt_unsubscribe","code":"int st_mqtt_unsubscribe(st_mqtt_client client, const char *topic)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tMQTTString Topic = MQTTString_initializer;\n\tTopic.cstring = (char *)topic;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *unsub_packet = NULL;\n\n\tchunk_size = MQTTSerialize_unsubscribe_size(1, \u0026Topic);\n\tunsub_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (unsub_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(unsub_packet);\n\t\tgoto exit;\n\t}\n\tc-\u003enext_packetid = (c-\u003enext_packetid \u003e= MAX_PACKET_ID) ? 1 : c-\u003enext_packetid + 1;\n\tunsub_packet-\u003epacket_id = c-\u003enext_packetid;\n\tMQTTSerialize_unsubscribe(unsub_packet-\u003echunk_data, chunk_size, 0, unsub_packet-\u003epacket_id, 1, \u0026Topic);\n\tunsub_packet-\u003epacket_type = UNSUBSCRIBE;\n\tunsub_packet-\u003ehave_owner = 1;\n\tunsub_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, unsub_packet);\n\n\trc = _iot_mqtt_wait_for(c, unsub_packet);\n\nexit:\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_UNSUBSCRIBE, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1245,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"120728":{"score":0.8685541,"function_name":"_iot_mqtt_push_publish_packet","code":"static iot_mqtt_packet_chunk_t * _iot_mqtt_push_publish_packet(MQTTClient *c, st_mqtt_msg *msg, unsigned char is_sync)\n{\n\tMQTTString topic = MQTTString_initializer;\n\ttopic.cstring = (char *)msg-\u003etopic;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *pub_packet = NULL;\n\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn NULL;\n\t}\n\tif((iot_os_mutex_lock(\u0026c-\u003eclient_manage_lock)) != IOT_OS_TRUE) {\n\t\treturn NULL;\n\t}\n\n\tchunk_size = MQTTSerialize_publish_size(msg-\u003eqos, topic, msg-\u003epayloadlen);\n\tpub_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (pub_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\tgoto exit;\n\t}\n\n\tif (msg-\u003eqos == st_mqtt_qos1 || msg-\u003eqos == st_mqtt_qos2) {\n\t\tc-\u003enext_packetid = (c-\u003enext_packetid \u003e= MAX_PACKET_ID) ? 1 : c-\u003enext_packetid + 1;\n\t\tpub_packet-\u003epacket_id = c-\u003enext_packetid;\n\t}\n\n\tMQTTSerialize_publish(pub_packet-\u003echunk_data, chunk_size, 0, msg-\u003eqos, msg-\u003eretained, pub_packet-\u003epacket_id,\n\t\t\t\t\t\t\t\t\ttopic, (unsigned char *)msg-\u003epayload, msg-\u003epayloadlen);\n\tpub_packet-\u003epacket_type = PUBLISH;\n\tpub_packet-\u003ehave_owner = is_sync;\n\tpub_packet-\u003eqos = msg-\u003eqos;\n\tpub_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, pub_packet);\n\nexit:\n\tiot_os_mutex_unlock(\u0026c-\u003eclient_manage_lock);\n\n\treturn pub_packet;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1281,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121204":{"score":0.88518906,"function_name":"st_mqtt_change_ping_period","code":"void st_mqtt_change_ping_period(st_mqtt_client client, unsigned int new_period)\n{\n\tMQTTClient *c = client;\n\n\tif (c != NULL \u0026\u0026 c-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\tif((iot_os_mutex_lock(\u0026c-\u003eclient_manage_lock)) == IOT_OS_TRUE) {\n\t\t\tc-\u003ekeepAliveInterval = new_period;\n\t\t\tiot_os_timer_count_ms(c-\u003elast_sent, c-\u003ekeepAliveInterval * 1000);\n\t\t\tiot_os_timer_count_ms(c-\u003elast_received, c-\u003ekeepAliveInterval * 1000);\n\t\t\tiot_os_mutex_unlock(\u0026c-\u003eclient_manage_lock);\n\t\t}\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1321,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121377":{"score":0.6298362,"function_name":"st_mqtt_publish","code":"int st_mqtt_publish(st_mqtt_client client, st_mqtt_msg *msg)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tiot_mqtt_packet_chunk_t *pub_packet = NULL;\n\n\tpub_packet = _iot_mqtt_push_publish_packet(c, msg, 1);\n\tif (!pub_packet) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\tgoto exit;\n\t}\n\trc = _iot_mqtt_wait_for(c, pub_packet);\n\nexit:\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_PUBLISH, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1335,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121475":{"score":0.60337883,"function_name":"st_mqtt_publish_async","code":"int st_mqtt_publish_async(st_mqtt_client client, st_mqtt_msg *msg)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\n\tif ((_iot_mqtt_push_publish_packet(c, msg, 0) == NULL)) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t}\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1353,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121539":{"score":0.9111738,"function_name":"st_mqtt_disconnect","code":"int st_mqtt_disconnect(st_mqtt_client client)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tiot_mqtt_packet_chunk_t *disconnect_packet = NULL;\n\n\tdisconnect_packet = _iot_mqtt_chunk_create(MQTT_DISCONNECT_PACKET_SIZE);\n\tif (disconnect_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tMQTTSerialize_disconnect(disconnect_packet-\u003echunk_data, MQTT_DISCONNECT_PACKET_SIZE);\n\tdisconnect_packet-\u003epacket_type = DISCONNECT;\n\tdisconnect_packet-\u003ehave_owner = 1;\n\tdisconnect_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(disconnect_packet);\n\t\tgoto exit;\n\t}\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, disconnect_packet);\n\n\trc = _iot_mqtt_wait_for(c, disconnect_packet);\n\nexit:\n\tIOT_INFO(\"mqtt disconnect %d\", rc);\n\t_iot_mqtt_close_net(c);\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_DISCONNECT, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1365,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121842":{"score":0.6316152,"function_name":"MQTTSerialize_connectLength","code":"int MQTTSerialize_connectLength(MQTTPacket_connectData* options)\n{\n\tint len = 0;\n\n\tFUNC_ENTRY;\n\n\tif (options-\u003eMQTTVersion == 3)\n\t\tlen = 12; /* variable depending on MQTT or MQIsdp */\n\telse if (options-\u003eMQTTVersion == 4)\n\t\tlen = 10;\n\n\tlen += MQTTstrlen(options-\u003eclientID)+2;\n\tif (options-\u003ewillFlag)\n\t\tlen += MQTTstrlen(options-\u003ewill.topicName)+2 + MQTTstrlen(options-\u003ewill.message)+2;\n\tif (options-\u003eusername.cstring || options-\u003eusername.lenstring.data)\n\t\tlen += MQTTstrlen(options-\u003eusername)+2;\n\tif (options-\u003epassword.cstring || options-\u003epassword.lenstring.data)\n\t\tlen += MQTTstrlen(options-\u003epassword)+2;\n\n\tFUNC_EXIT_RC(len);\n\treturn len;\n}","filepath":"src/mqtt/packet/iot_mqtt_connect_client.c","line_number":27,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"122111":{"score":0.68099344,"function_name":"MQTTSerialize_connect","code":"int MQTTSerialize_connect(unsigned char* buf, int buflen, MQTTPacket_connectData* options)\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tMQTTConnectFlags flags = {0};\n\tint len = 0;\n\tint rc = -1;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.byte = 0;\n\theader.bits.type = CONNECT;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, len); /* write remaining length */\n\n\tif (options-\u003eMQTTVersion == 4)\n\t{\n\t\twriteCString(\u0026ptr, \"MQTT\");\n\t\twriteChar(\u0026ptr, (char) 4);\n\t}\n\telse\n\t{\n\t\twriteCString(\u0026ptr, \"MQIsdp\");\n\t\twriteChar(\u0026ptr, (char) 3);\n\t}\n\n\tflags.all = 0;\n\tflags.bits.cleansession = options-\u003ecleansession;\n\tflags.bits.will = (options-\u003ewillFlag) ? 1 : 0;\n\tif (flags.bits.will)\n\t{\n\t\tflags.bits.willQoS = options-\u003ewill.qos;\n\t\tflags.bits.willRetain = options-\u003ewill.retained;\n\t}\n\n\tif (options-\u003eusername.cstring || options-\u003eusername.lenstring.data)\n\t\tflags.bits.username = 1;\n\tif (options-\u003epassword.cstring || options-\u003epassword.lenstring.data)\n\t\tflags.bits.password = 1;\n\n\twriteChar(\u0026ptr, flags.all);\n\twriteInt(\u0026ptr, options-\u003ekeepAliveInterval);\n\twriteMQTTString(\u0026ptr, options-\u003eclientID);\n\tif (options-\u003ewillFlag)\n\t{\n\t\twriteMQTTString(\u0026ptr, options-\u003ewill.topicName);\n\t\twriteMQTTString(\u0026ptr, options-\u003ewill.message);\n\t}\n\tif (flags.bits.username)\n\t\twriteMQTTString(\u0026ptr, options-\u003eusername);\n\tif (flags.bits.password)\n\t\twriteMQTTString(\u0026ptr, options-\u003epassword);\n\n\trc = ptr - buf;\n\n\texit: FUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_connect_client.c","line_number":58,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"122883":{"score":0.64348733,"function_name":"MQTTDeserialize_connack","code":"int MQTTDeserialize_connack(unsigned char* sessionPresent, unsigned char* connack_rc, unsigned char* buf, int buflen)\n{\n\tMQTTHeader header = {0};\n\tunsigned char* curdata = buf;\n\tunsigned char* enddata = NULL;\n\tint rc = 0;\n\tint mylen;\n\tMQTTConnackFlags flags = {0};\n\n\tFUNC_ENTRY;\n\theader.byte = readChar(\u0026curdata);\n\tif (header.bits.type != CONNACK)\n\t\tgoto exit;\n\n\tcurdata += (rc = MQTTPacket_decodeBuf(curdata, \u0026mylen)); /* read remaining length */\n\tenddata = curdata + mylen;\n\tif (enddata - curdata \u003c 2)\n\t\tgoto exit;\n\n\tflags.all = readChar(\u0026curdata);\n\t*sessionPresent = flags.bits.sessionpresent;\n\t*connack_rc = readChar(\u0026curdata);\n\n\trc = 1;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_connect_client.c","line_number":136,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"123142":{"score":0.58148545,"function_name":"MQTTSerialize_zero","code":"int MQTTSerialize_zero(unsigned char* buf, int buflen, unsigned char packettype)\n{\n\tMQTTHeader header = {0};\n\tint rc = -1;\n\tunsigned char *ptr = buf;\n\n\tFUNC_ENTRY;\n\tif (buflen \u003c 2)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\theader.byte = 0;\n\theader.bits.type = packettype;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, 0); /* write remaining length */\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_connect_client.c","line_number":173,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"123412":{"score":0.6965897,"function_name":"MQTTDeserialize_publish","code":"int MQTTDeserialize_publish(unsigned char* dup, int* qos, unsigned char* retained, unsigned short* packetid, MQTTString* topicName,\n\t\tunsigned char** payload, int* payloadlen, unsigned char* buf, int buflen)\n{\n\tMQTTHeader header = {0};\n\tunsigned char* curdata = buf;\n\tunsigned char* enddata = NULL;\n\tint rc = 0;\n\tint mylen = 0;\n\n\tFUNC_ENTRY;\n\theader.byte = readChar(\u0026curdata);\n\tif (header.bits.type != PUBLISH)\n\t\tgoto exit;\n\t*dup = header.bits.dup;\n\t*qos = header.bits.qos;\n\t*retained = header.bits.retain;\n\n\tcurdata += (rc = MQTTPacket_decodeBuf(curdata, \u0026mylen)); /* read remaining length */\n\tenddata = curdata + mylen;\n\n\tif (!readMQTTLenString(topicName, \u0026curdata, enddata) ||\n\t\tenddata - curdata \u003c 0) /* do we have enough data to read the protocol version byte? */\n\t\tgoto exit;\n\n\tif (*qos \u003e 0)\n\t\t*packetid = readInt(\u0026curdata);\n\n\t*payloadlen = enddata - curdata;\n\t*payload = curdata;\n\trc = 1;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_deserialize_publish.c","line_number":36,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"124022":{"score":0.58468676,"function_name":"MQTTPacket_encode","code":"int MQTTPacket_encode(unsigned char* buf, int length)\n{\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\tdo\n\t{\n\t\tchar d = length % 128;\n\t\tlength /= 128;\n\t\t/* if there are more digits to encode, set the top bit of this digit */\n\t\tif (length \u003e 0)\n\t\t\td |= 0x80;\n\t\tbuf[rc++] = d;\n\t} while (length \u003e 0);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":29,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"124122":{"score":0.8392893,"function_name":"MQTTPacket_decode","code":"int MQTTPacket_decode(int (*getcharfn)(unsigned char*, int), int* value)\n{\n\tunsigned char c;\n\tint multiplier = 1;\n\tint len = 0;\n#define MAX_NO_OF_REMAINING_LENGTH_BYTES 4\n\n\tFUNC_ENTRY;\n\t*value = 0;\n\tdo\n\t{\n\t\tint rc = MQTTPACKET_READ_ERROR;\n\n\t\tif (++len \u003e MAX_NO_OF_REMAINING_LENGTH_BYTES)\n\t\t{\n\t\t\trc = MQTTPACKET_READ_ERROR;\t/* bad data */\n\t\t\tgoto exit;\n\t\t}\n\t\trc = (*getcharfn)(\u0026c, 1);\n\t\tif (rc != 1)\n\t\t\tgoto exit;\n\t\t*value += (c \u0026 127) * multiplier;\n\t\tmultiplier *= 128;\n\t} while ((c \u0026 128) != 0);\nexit:\n\tFUNC_EXIT_RC(len);\n\treturn len;\n}","filepath":"components/connectivity/Eclipse-Paho-MQTT/3rdparty/src/MQTTPacket.c","line_number":54,"entry_url":"https://github.com/Tencent/TencentOS-tiny.git","slot_name":"v2.1.0"},"124299":{"score":0.85561085,"function_name":"MQTTPacket_len","code":"int MQTTPacket_len(int rem_len)\n{\n\trem_len += 1; /* header byte */\n\n\t/* now remaining_length field */\n\tif (rem_len \u003c 128)\n\t\trem_len += 1;\n\telse if (rem_len \u003c 16384)\n\t\trem_len += 2;\n\telse if (rem_len \u003c 2097151)\n\t\trem_len += 3;\n\telse\n\t\trem_len += 4;\n\treturn rem_len;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":83,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"124888":{"score":0.6857247,"function_name":"writeMQTTString","code":"void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)\n{\n\tif (mqttstring.lenstring.len \u003e 0)\n\t{\n\t\twriteInt(pptr, mqttstring.lenstring.len);\n\t\tmemcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);\n\t\t*pptr += mqttstring.lenstring.len;\n\t}\n\telse if (mqttstring.cstring)\n\t\twriteCString(pptr, mqttstring.cstring);\n\telse\n\t\twriteInt(pptr, 0);\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":193,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125021":{"score":0.76515186,"function_name":"readMQTTLenString","code":"int readMQTTLenString(MQTTString* mqttstring, unsigned char** pptr, unsigned char* enddata)\n{\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\t/* the first two bytes are the length of the string */\n\tif (enddata - (*pptr) \u003e 1) /* enough length to read the integer? */\n\t{\n\t\tmqttstring-\u003elenstring.len = readInt(pptr); /* increments pptr to point past length */\n\t\tif (\u0026(*pptr)[mqttstring-\u003elenstring.len] \u003c= enddata)\n\t\t{\n\t\t\tmqttstring-\u003elenstring.data = (char*)*pptr;\n\t\t\t*pptr += mqttstring-\u003elenstring.len;\n\t\t\trc = 1;\n\t\t}\n\t}\n\tmqttstring-\u003ecstring = NULL;\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":214,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125148":{"score":0.7103715,"function_name":"MQTTstrlen","code":"int MQTTstrlen(MQTTString mqttstring)\n{\n\tint rc = 0;\n\n\tif (mqttstring.cstring)\n\t\trc = strlen(mqttstring.cstring);\n\telse\n\t\trc = mqttstring.lenstring.len;\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":241,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125215":{"score":0.94307435,"function_name":"MQTTPacket_equals","code":"int MQTTPacket_equals(MQTTString* a, char* bptr)\n{\n\tint alen = 0,\n\t\tblen = 0;\n\tchar *aptr;\n\t\n\tif (a-\u003ecstring)\n\t{\n\t\taptr = a-\u003ecstring;\n\t\talen = strlen(a-\u003ecstring);\n\t}\n\telse\n\t{\n\t\taptr = a-\u003elenstring.data;\n\t\talen = a-\u003elenstring.len;\n\t}\n\tblen = strlen(bptr);\n\t\n\treturn (alen == blen) \u0026\u0026 (strncmp(aptr, bptr, alen) == 0);\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":259,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125371":{"score":0.8579855,"function_name":"MQTTPacket_read","code":"int MQTTPacket_read(unsigned char* buf, int buflen, int (*getfn)(unsigned char*, int))\n{\n\tint rc = -1;\n\tMQTTHeader header = {0};\n\tint len = 0;\n\tint rem_len = 0;\n\n\t/* 1. read the header byte.  This has the packet type in it */\n\tif ((*getfn)(buf, 1) != 1)\n\t\tgoto exit;\n\n\tlen = 1;\n\t/* 2. read the remaining length.  This is variable in itself */\n\tMQTTPacket_decode(getfn, \u0026rem_len);\n\tlen += MQTTPacket_encode(buf + 1, rem_len); /* put the original remaining length back into the buffer */\n\n\t/* 3. read the rest of the buffer using a callback to supply the rest of the data */\n\tif((rem_len + len) \u003e buflen)\n\t\tgoto exit;\n\tif (rem_len \u0026\u0026 ((*getfn)(buf + len, rem_len) != rem_len))\n\t\tgoto exit;\n\n\theader.byte = buf[0];\n\trc = header.bits.type;\nexit:\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":289,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125615":{"score":0.7410416,"function_name":"MQTTPacket_decodenb","code":"static int MQTTPacket_decodenb(MQTTTransport *trp)\n{\n\tunsigned char c;\n\tint rc = MQTTPACKET_READ_ERROR;\n\n\tFUNC_ENTRY;\n\tif(trp-\u003elen == 0){\t\t/* initialize on first call */\n\t\ttrp-\u003emultiplier = 1;\n\t\ttrp-\u003erem_len = 0;\n\t}\n\tdo {\n\t\tint frc;\n\t\tif (trp-\u003elen \u003e= MAX_NUM_OF_REMAINING_LENGTH_BYTES)\n\t\t\tgoto exit;\n\t\tif ((frc=(*trp-\u003egetfn)(trp-\u003esck, \u0026c, 1)) == -1)\n\t\t\tgoto exit;\n\t\tif (frc == 0){\n\t\t\trc = 0;\n\t\t\tgoto exit;\n\t\t}\n\t\t++(trp-\u003elen);\n\t\ttrp-\u003erem_len += (c \u0026 127) * trp-\u003emultiplier;\n\t\ttrp-\u003emultiplier *= 128;\n\t} while ((c \u0026 128) != 0);\n\trc = trp-\u003elen;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":323,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125866":{"score":0.81428754,"function_name":"MQTTPacket_readnb","code":"int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)\n{\n\tint rc = -1, frc;\n\tMQTTHeader header = {0};\n\n\tswitch(trp-\u003estate){\n\tdefault:\n\t\ttrp-\u003estate = 0;\n\t\t/*FALLTHROUGH*/\n\tcase 0:\n\t\t/* read the header byte.  This has the packet type in it */\n\t\tif ((frc=(*trp-\u003egetfn)(trp-\u003esck, buf, 1)) == -1)\n\t\t\tgoto exit;\n\t\tif (frc == 0)\n\t\t\treturn 0;\n\t\ttrp-\u003elen = 0;\n\t\t++trp-\u003estate;\n\t\t/*FALLTHROUGH*/\n\t\t/* read the remaining length.  This is variable in itself */\n\tcase 1:\n\t\tif((frc=MQTTPacket_decodenb(trp)) == MQTTPACKET_READ_ERROR)\n\t\t\tgoto exit;\n\t\tif(frc == 0)\n\t\t\treturn 0;\n\t\ttrp-\u003elen = 1 + MQTTPacket_encode(buf + 1, trp-\u003erem_len); /* put the original remaining length back into the buffer */\n\t\tif((trp-\u003erem_len + trp-\u003elen) \u003e buflen)\n\t\t\tgoto exit;\n\t\t++trp-\u003estate;\n\t\t/*FALLTHROUGH*/\n\tcase 2:\n\t\tif(trp-\u003erem_len){\n\t\t\t/* read the rest of the buffer using a callback to supply the rest of the data */\n\t\t\tif ((frc=(*trp-\u003egetfn)(trp-\u003esck, buf + trp-\u003elen, trp-\u003erem_len)) == -1)\n\t\t\t\tgoto exit;\n\t\t\tif (frc == 0)\n\t\t\t\treturn 0;\n\t\t\ttrp-\u003erem_len -= frc;\n\t\t\ttrp-\u003elen += frc;\n\t\t\tif(trp-\u003erem_len)\n\t\t\t\treturn 0;\n\t\t}\n\t\theader.byte = buf[0];\n\t\trc = header.bits.type;\n\t\tbreak;\n\t}\n\nexit:\n\ttrp-\u003estate = 0;\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":361,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126305":{"score":0.92879164,"function_name":"MQTTPacket_msgTypesToString","code":"const char* MQTTPacket_msgTypesToString(enum msgTypes msgType)\n{\n\tswitch (msgType)\n\t{\n\t\tcase CONNECT: return \"CONNECT\";\n\t\tcase CONNACK: return \"CONNACK\";\n\t\tcase PUBLISH: return \"PUBLISH\";\n\t\tcase PUBACK: return \"PUBACK\";\n\t\tcase PUBREC: return \"PUBREC\";\n\t\tcase PUBREL: return \"PUBREL\";\n\t\tcase PUBCOMP: return \"PUBCOMP\";\n\t\tcase SUBSCRIBE: return \"SUBSCRIBE\";\n\t\tcase SUBACK: return \"SUBACK\";\n\t\tcase UNSUBSCRIBE: return \"UNSUBSCRIBE\";\n\t\tcase UNSUBACK: return \"UNSUBACK\";\n\t\tcase PINGREQ: return \"PINGREQ\";\n\t\tcase PINGRESP: return \"PINGRESP\";\n\t\tcase DISCONNECT: return \"DISCONNECT\";\n\t\tdefault: return NULL;\n\t}\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":412,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126464":{"score":0.83525074,"function_name":"MQTTPacket_getPacketId","code":"unsigned int MQTTPacket_getPacketId(unsigned char *buf)\n{\n\tint packet_type = (buf[0] \u0026 0xf0) \u003e\u003e 4;\n\tint qos = (buf[0] \u0026 0x06) \u003e\u003e 1;\n\tint rem_size = 0;\n\tunsigned int packet_id = 0;\n\n\tswitch (packet_type) {\n\t\tcase PUBLISH:\n\t\t\tif (qos == 0)\n\t\t\t\tbreak;\n\t\t\tbuf++;\n\t\t\tbuf += MQTTPacket_decodeBuf(buf, \u0026rem_size);\n\t\t\tbuf += readInt(\u0026buf);\n\t\t\tpacket_id = readInt(\u0026buf);\n\t\t\tbreak;\n\t\tcase PUBACK:\n\t\tcase PUBREC:\n\t\tcase PUBREL:\n\t\tcase PUBCOMP:\n\t\tcase SUBSCRIBE:\n\t\tcase SUBACK:\n\t\tcase UNSUBSCRIBE:\n\t\tcase UNSUBACK:\n\t\t\tbuf++;\n\t\t\tbuf += MQTTPacket_decodeBuf(buf, \u0026rem_size);\n\t\t\tpacket_id += readInt(\u0026buf);\n\t\t\tbreak;\n\t}\n\n\treturn packet_id;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":434,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126745":{"score":0.6430692,"function_name":"MQTTSerialize_publishLength","code":"int MQTTSerialize_publishLength(int qos, MQTTString topicName, int payloadlen)\n{\n\tint len = 0;\n\n\tlen += 2 + MQTTstrlen(topicName) + payloadlen;\n\tif (qos \u003e 0)\n\t\tlen += 2; /* packetid */\n\treturn len;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":31,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126820":{"score":0.67424846,"function_name":"MQTTSerialize_publish","code":"int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,\n\t\tMQTTString topicName, unsigned char* payload, int payloadlen)\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.bits.type = PUBLISH;\n\theader.bits.dup = dup;\n\theader.bits.qos = qos;\n\theader.bits.retain = retained;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteMQTTString(\u0026ptr, topicName);\n\n\tif (qos \u003e 0)\n\t\twriteInt(\u0026ptr, packetid);\n\n\tmemcpy(ptr, payload, payloadlen);\n\tptr += payloadlen;\n\n\trc = ptr - buf;\n\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":55,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"127298":{"score":0.7377858,"function_name":"MQTTSerialize_publish_header","code":"int MQTTSerialize_publish_header(unsigned char* buf, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,\n\t\tMQTTString topicName, int payloadlen)\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = 0;\n\n\trem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen);\n\n\theader.bits.type = PUBLISH;\n\theader.bits.dup = dup;\n\theader.bits.qos = qos;\n\theader.bits.retain = retained;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteMQTTString(\u0026ptr, topicName);\n\n\tif (qos \u003e 0)\n\t\twriteInt(\u0026ptr, packetid);\n\n\trc = ptr - buf;\n\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":98,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"127645":{"score":0.72168195,"function_name":"MQTTSerialize_ack","code":"int MQTTSerialize_ack(unsigned char* buf, int buflen, unsigned char packettype, unsigned char dup, unsigned short packetid)\n{\n\tMQTTHeader header = {0};\n\tint rc = 0;\n\tunsigned char *ptr = buf;\n\n\tFUNC_ENTRY;\n\tif (buflen \u003c 4)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\theader.bits.type = packettype;\n\theader.bits.dup = dup;\n\theader.bits.qos = (packettype == PUBREL) ? 1 : 0;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, 2); /* write remaining length */\n\twriteInt(\u0026ptr, packetid);\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":135,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"128099":{"score":0.5895932,"function_name":"MQTTSerialize_subscribeLength","code":"int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])\n{\n\tint i;\n\tint len = 2; /* packetid */\n\n\tfor (i = 0; i \u003c count; ++i)\n\t\tlen += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */\n\treturn len;\n}","filepath":"src/lib/MQTTSubscribeClient.c","line_number":28,"entry_url":"https://github.com/256dpi/arduino-mqtt.git","slot_name":"v1.0"},"128197":{"score":0.70991564,"function_name":"MQTTSerialize_subscribe","code":"int MQTTSerialize_subscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid, int count,\n\t\tMQTTString topicFilters[], int requestedQoSs[])\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = 0;\n\tint i = 0;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(rem_len = MQTTSerialize_subscribeLength(count, topicFilters)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.byte = 0;\n\theader.bits.type = SUBSCRIBE;\n\theader.bits.dup = dup;\n\theader.bits.qos = 1;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteInt(\u0026ptr, packetid);\n\n\tfor (i = 0; i \u003c count; ++i)\n\t{\n\t\twriteMQTTString(\u0026ptr, topicFilters[i]);\n\t\twriteChar(\u0026ptr, requestedQoSs[i]);\n\t}\n\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/lib/MQTTSubscribeClient.c","line_number":50,"entry_url":"https://github.com/256dpi/arduino-mqtt.git","slot_name":"v1.0"},"128664":{"score":0.66687834,"function_name":"MQTTDeserialize_suback","code":"int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)\n{\n\tMQTTHeader header = {0};\n\tunsigned char* curdata = buf;\n\tunsigned char* enddata = NULL;\n\tint rc = 0;\n\tint mylen;\n\n\tFUNC_ENTRY;\n\theader.byte = readChar(\u0026curdata);\n\tif (header.bits.type != SUBACK)\n\t\tgoto exit;\n\n\tcurdata += (rc = MQTTPacket_decodeBuf(curdata, \u0026mylen)); /* read remaining length */\n\tenddata = curdata + mylen;\n\tif (enddata - curdata \u003c 2)\n\t\tgoto exit;\n\n\t*packetid = readInt(\u0026curdata);\n\n\t*count = 0;\n\twhile (curdata \u003c enddata)\n\t{\n\t\tif (*count \u003e maxcount)\n\t\t{\n\t\t\trc = -1;\n\t\t\tgoto exit;\n\t\t}\n\t\tgrantedQoSs[(*count)++] = readChar(\u0026curdata);\n\t}\n\n\trc = 1;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/lib/MQTTSubscribeClient.c","line_number":100,"entry_url":"https://github.com/256dpi/arduino-mqtt.git","slot_name":"v1.0"},"128985":{"score":0.68096095,"function_name":"MQTTSerialize_subscribeLength","code":"int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])\n{\n\tint i;\n\tint len = 2; /* packetid */\n\n\tfor (i = 0; i \u003c count; ++i)\n\t\tlen += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */\n\treturn len;\n}","filepath":"middleware/linkkit/sdk-c/src/protocol/mqtt/MQTTPacket/MQTTSubscribeClient.c","line_number":15,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"v2.0.0"},"129083":{"score":0.69011104,"function_name":"MQTTSerialize_unsubscribe","code":"int MQTTSerialize_unsubscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid,\n\t\tint count, MQTTString topicFilters[])\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = -1;\n\tint i = 0;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(rem_len = MQTTSerialize_unsubscribeLength(count, topicFilters)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.byte = 0;\n\theader.bits.type = UNSUBSCRIBE;\n\theader.bits.dup = dup;\n\theader.bits.qos = 1;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteInt(\u0026ptr, packetid);\n\n\tfor (i = 0; i \u003c count; ++i)\n\t\twriteMQTTString(\u0026ptr, topicFilters[i]);\n\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"platform/mcu/rtl8710bn/sdk/component/common/application/mqtt/MQTTPacket/MQTTUnsubscribeClient.c","line_number":49,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"v1.2.2"},"129637":{"score":0.913042,"function_name":"_iot_net_check_interface","code":"static iot_error_t _iot_net_check_interface(iot_net_interface_t *net)\n{\n\tif (net == NULL) {\n\t\tIOT_ERROR(\"interface is null\");\n\t\treturn IOT_ERROR_NET_INVALID_INTERFACE;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":48,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"129715":{"score":0.8683787,"function_name":"_iot_net_show_status","code":"static void _iot_net_show_status(iot_net_interface_t *net)\n{\n\tstruct timeval tv;\n\tstruct timeval timeout = {0};\n\tint socket;\n\tint sock_err = 0;\n\tsocklen_t err_len = sizeof(sock_err);\n\tfd_set rfdset;\n\tfd_set wfdset;\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn;\n\t}\n\n\tsocket = net-\u003econtext.server_fd.fd;\n\n\tFD_ZERO(\u0026rfdset);\n\tFD_ZERO(\u0026wfdset);\n\tFD_SET(socket, \u0026rfdset);\n\tFD_SET(socket, \u0026wfdset);\n\n\tif (select(socket + 1, \u0026rfdset, \u0026wfdset, NULL, \u0026timeout) \u003c 0) {\n\t\tIOT_ERROR(\"failed to select :%d/%d\", (socket + 1), errno);\n\t}\n\tif (getsockopt(socket, SOL_SOCKET, SO_ERROR, \u0026sock_err, \u0026err_len) \u003c 0) {\n\t\tIOT_ERROR(\"failed to getsockopt :%d/%d\", socket, errno);\n\t}\n\tif (gettimeofday(\u0026tv, NULL) \u003c 0) {\n\t\tIOT_ERROR(\"failed to gettimeofday :%d\", errno);\n\t}\n\n\tIOT_INFO(\"[%ld] network socket status: sockfd %d readable %d writable %d sock_err %d errno %d\",\n\t\t\t\ttv.tv_sec, socket,\n\t\t\t\tFD_ISSET(socket, \u0026rfdset),\n\t\t\t\tFD_ISSET(socket, \u0026wfdset), sock_err, errno);\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":58,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"130559":{"score":0.8402877,"function_name":"_iot_net_select","code":"static int _iot_net_select(iot_net_interface_t *net, unsigned int timeout_ms)\n{\n\tstruct timeval timeout;\n\tfd_set fdset;\n\tint socket;\n\tint ret;\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn 0;\n\t}\n\n\tsocket = net-\u003econtext.server_fd.fd;\n\n\tFD_ZERO(\u0026fdset);\n\tFD_SET(socket, \u0026fdset);\n\n\ttimeout.tv_sec = timeout_ms / 1000;\n\ttimeout.tv_usec = (timeout_ms % 1000) * 1000;\n\n\tret = select(socket + 1, \u0026fdset, NULL, NULL, \u0026timeout);\n\n\treturn ret;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":95,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"130892":{"score":0.854289,"function_name":"_iot_net_cleanup_platform_context","code":"static void _iot_net_cleanup_platform_context(iot_net_interface_t *net)\n{\n\tif (_iot_net_check_interface(net)) {\n\t\treturn;\n\t}\n\n\tmbedtls_net_free(\u0026net-\u003econtext.server_fd);\n\n\tmbedtls_x509_crt_free(\u0026net-\u003econtext.cacert);\n\tmbedtls_ssl_free(\u0026net-\u003econtext.ssl);\n\tmbedtls_ssl_config_free(\u0026net-\u003econtext.conf);\n\tmbedtls_ctr_drbg_free(\u0026net-\u003econtext.ctr_drbg);\n\tmbedtls_entropy_free(\u0026net-\u003econtext.entropy);\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":119,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"131068":{"score":0.8821553,"function_name":"_iot_net_tls_connect","code":"static iot_error_t _iot_net_tls_connect(iot_net_interface_t *net)\n{\n\tiot_error_t err;\n\tconst char *pers = \"iot_net_mbedtls\";\n\tchar port[5] = {0};\n\tunsigned int flags;\n\tint ret;\n\n\terr = _iot_net_check_interface(net);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tmbedtls_net_init(\u0026net-\u003econtext.server_fd);\n\tmbedtls_ssl_init(\u0026net-\u003econtext.ssl);\n\tmbedtls_ssl_config_init(\u0026net-\u003econtext.conf);\n\tmbedtls_x509_crt_init(\u0026net-\u003econtext.cacert);\n\tmbedtls_ctr_drbg_init(\u0026net-\u003econtext.ctr_drbg);\n\n\tmbedtls_entropy_init(\u0026net-\u003econtext.entropy);\n\tret = mbedtls_ctr_drbg_seed(\u0026net-\u003econtext.ctr_drbg,\n\t\t\t\tmbedtls_entropy_func, \u0026net-\u003econtext.entropy,\n\t\t\t\t(const unsigned char *)pers, strlen((char *)pers));\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ctr_drbg_seed = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tif ((net-\u003econnection.ca_cert == NULL) ||\n\t    (net-\u003econnection.ca_cert_len == 0)) {\n\t\tIOT_ERROR(\"ca cert is invalid\");\n\t\tret = IOT_ERROR_INVALID_ARGS;\n\t\tgoto exit;\n\t}\n\n\tIOT_INFO(\"Loading the CA root certificate %d@%p\",\n\t\t\t\tnet-\u003econnection.ca_cert_len + 1,\n\t\t\t\tnet-\u003econnection.ca_cert);\n\n\t/* iot-core passed the certificate without NULL character */\n\tret = mbedtls_x509_crt_parse(\u0026net-\u003econtext.cacert,\n\t\t\t\t(const unsigned char *)net-\u003econnection.ca_cert,\n\t\t\t\tnet-\u003econnection.ca_cert_len + 1);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_x509_crt_parse = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tif ((net-\u003econnection.url == NULL) ||\n\t    (net-\u003econnection.port == 0)) {\n\t\tIOT_ERROR(\"server infomation is invalid\");\n\t\tret = IOT_ERROR_INVALID_ARGS;\n\t\tgoto exit;\n\t}\n\n\tIOT_DEBUG(\"Connecting to %s:%d\", net-\u003econnection.url, net-\u003econnection.port);\n\n\tsnprintf(port, sizeof(port), \"%d\", net-\u003econnection.port);\n\tret = mbedtls_net_connect(\u0026net-\u003econtext.server_fd,\n\t\t\t\tnet-\u003econnection.url, port,\n\t\t\t\tMBEDTLS_NET_PROTO_TCP);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_net_connect = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ssl_config_defaults(\u0026net-\u003econtext.conf,\n\t\t\t\tMBEDTLS_SSL_IS_CLIENT,\n\t\t\t\tMBEDTLS_SSL_TRANSPORT_STREAM,\n\t\t\t\tMBEDTLS_SSL_PRESET_DEFAULT);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ssl_config_defaults = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tmbedtls_ssl_conf_authmode(\u0026net-\u003econtext.conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n\tmbedtls_ssl_conf_ca_chain(\u0026net-\u003econtext.conf, \u0026net-\u003econtext.cacert, NULL);\n\tmbedtls_ssl_conf_rng(\u0026net-\u003econtext.conf, mbedtls_ctr_drbg_random,\n\t\t\t\t\u0026net-\u003econtext.ctr_drbg);\n\tmbedtls_ssl_conf_read_timeout(\u0026net-\u003econtext.conf, IOT_MBEDTLS_READ_TIMEOUT_MS);\n\n#ifdef CONFIG_MBEDTLS_DEBUG\n\tmbedtls_ssl_conf_dbg(\u0026net-\u003econtext.conf, _iot_net_mbedtls_debug, NULL);\n\tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL);\n#endif\n\n\tret = mbedtls_ssl_setup(\u0026net-\u003econtext.ssl, \u0026net-\u003econtext.conf);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ssl_setup = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ssl_set_hostname(\u0026net-\u003econtext.ssl, net-\u003econnection.url);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ssl_set_hostname = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tmbedtls_ssl_set_bio(\u0026net-\u003econtext.ssl,\n\t\t\t\t\u0026net-\u003econtext.server_fd,\n\t\t\t\tmbedtls_net_send, NULL, mbedtls_net_recv_timeout);\n\n\tIOT_DEBUG(\"Performing the SSL/TLS handshake\");\n\n\twhile ((ret = mbedtls_ssl_handshake(\u0026net-\u003econtext.ssl)) != 0) {\n\t\tif ((ret != MBEDTLS_ERR_SSL_WANT_READ) \u0026\u0026\n\t\t    (ret != MBEDTLS_ERR_SSL_WANT_WRITE)) {\n\t\t\tIOT_ERROR(\"mbedtls_ssl_handshake = -0x%x\", -ret);\n\t\t\tif (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {\n\t\t\t\tIOT_ERROR(\"failed to verify the server's certificate\");\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tIOT_DEBUG(\"Protocol is %s\", mbedtls_ssl_get_version(\u0026net-\u003econtext.ssl));\n\tIOT_DEBUG(\"Ciphersuite is %s\", mbedtls_ssl_get_ciphersuite(\u0026net-\u003econtext.ssl));\n\n\tIOT_DEBUG(\"Verifying peer X.509 certificate\");\n\n\tflags = mbedtls_ssl_get_verify_result(\u0026net-\u003econtext.ssl);\n\tif (flags) {\n\t\tIOT_ERROR(\"mbedtls_ssl_get_verify_result = 0x%x\", flags);\n\t\tgoto exit;\n\t}\n#if defined(STDK_IOT_CORE_TLS_DEBUG)\n\tif (mbedtls_ssl_get_peer_cert(\u0026net-\u003econtext.ssl) != NULL) {\n\t\tunsigned char buf[2048];\n\t\tIOT_INFO(\"Peer certificate information\");\n\t\tmbedtls_x509_crt_info((char *)buf, sizeof(buf) - 1,\n\t\t\t\t\"!\", mbedtls_ssl_get_peer_cert(\u0026net-\u003econtext.ssl));\n\t\tIOT_INFO(\"%s\\n\", buf);\n\t}\n#endif\n\n\treturn IOT_ERROR_NONE;\n\nexit:\n\t_iot_net_cleanup_platform_context(net);\n\n\treturn IOT_ERROR_NET_CONNECT;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":257,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"132473":{"score":0.73644567,"function_name":"_iot_net_tcp_keepalive","code":"static iot_error_t _iot_net_tcp_keepalive(iot_net_interface_t *net, unsigned int idle, unsigned int count, unsigned int intval)\n{\n\tiot_error_t err;\n\tint socket;\n\tint keepAlive = 1;\n\tint ret;\n\n\terr = _iot_net_check_interface(net);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tsocket = net-\u003econtext.server_fd.fd;\n\tret = setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, \u0026keepAlive, sizeof(keepAlive));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVE error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tret = setsockopt(socket, IPPROTO_TCP, TCP_KEEPIDLE, \u0026idle, sizeof(idle));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVEIDLE error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tret = setsockopt(socket, IPPROTO_TCP, TCP_KEEPCNT, \u0026count, sizeof(count));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVECOUNT error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tret = setsockopt(socket, IPPROTO_TCP, TCP_KEEPINTVL, \u0026intval, sizeof(intval));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVEINTERVAL error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":400,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"132949":{"score":0.87946534,"function_name":"_iot_net_tls_read","code":"static int _iot_net_tls_read(iot_net_interface_t *net,\n\t\tunsigned char *buf, size_t len, iot_os_timer timer)\n{\n\tint recvLen = 0, ret = 0;\n\n\tIOT_DEBUG(\"%d@%p\", len, buf);\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn 0;\n\t}\n\n\tif (buf == NULL || timer == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (len == 0) {\n\t\treturn 0;\n\t}\n\n\tmbedtls_ssl_conf_read_timeout(\u0026net-\u003econtext.conf, (uint32_t)iot_os_timer_left_ms(timer));\n\n\tdo {\n\t\tret = mbedtls_ssl_read(\u0026net-\u003econtext.ssl, buf, len);\n\n\t\tif(ret \u003e 0) {\n\t\t\trecvLen += ret;\n\t\t} else {\n\t\t\tif ((ret != MBEDTLS_ERR_SSL_WANT_READ) \u0026\u0026\n\t\t\t\t(ret != MBEDTLS_ERR_SSL_WANT_WRITE) \u0026\u0026\n\t\t\t\t(ret != MBEDTLS_ERR_SSL_TIMEOUT)) {\n\t\t\t\tIOT_ERROR(\"mbedtls_ssl_read = -0x%04X\", -ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} while(recvLen \u003c len \u0026\u0026 !iot_os_timer_isexpired(timer));\n\n\treturn recvLen;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":446,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"133240":{"score":0.8405138,"function_name":"_iot_net_tls_write","code":"static int _iot_net_tls_write(iot_net_interface_t *net,\n\t\tunsigned char *buf, int len, iot_os_timer timer)\n{\n\tint sentLen = 0, ret = 0;\n\n\tIOT_DEBUG(\"%d@%p\", len, buf);\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tret = mbedtls_ssl_write(\u0026net-\u003econtext.ssl, buf + sentLen, (size_t)len - sentLen);\n\n\t\tif(ret \u003e 0) {\n\t\t\tsentLen += ret;\n\t\t} else {\n\t\t\tif ((ret != MBEDTLS_ERR_SSL_WANT_READ) \u0026\u0026\n\t\t\t\t(ret != MBEDTLS_ERR_SSL_WANT_WRITE)) {\n\t\t\t\tIOT_ERROR(\"mbedtls_ssl_write = -0x%04X\\n\", -ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} while (sentLen \u003c len \u0026\u0026 !iot_os_timer_isexpired(timer));\n\n\treturn sentLen;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":485,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"133461":{"score":0.7859549,"function_name":"iot_net_init","code":"iot_error_t iot_net_init(iot_net_interface_t *net)\n{\n\tiot_error_t err;\n\n\terr = _iot_net_check_interface(net);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tnet-\u003econnect = _iot_net_tls_connect;\n\tnet-\u003etcp_keepalive = _iot_net_tcp_keepalive;\n\tnet-\u003edisconnect = _iot_net_tls_disconnect;\n\tnet-\u003eselect = _iot_net_select;\n\tnet-\u003eread = _iot_net_tls_read;\n\tnet-\u003ewrite = _iot_net_tls_write;\n\tnet-\u003eshow_status = _iot_net_show_status;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":513,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"133622":{"score":0.9412868,"function_name":"_iot_nv_io_storage_init","code":"STATIC_FUNCTION\niot_security_context_t *_iot_nv_io_storage_init(void)\n{\n\tiot_error_t err;\n\tiot_security_context_t *security_context;\n\n\tsecurity_context = iot_security_init();\n\tif (!security_context) {\n\t\tIOT_ERROR(\"failed to init security\");\n\t\treturn NULL;\n\t}\n\n\terr = iot_security_storage_init(security_context);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_storage_init = %d\", err);\n\t\tiot_security_deinit(security_context);\n\t\treturn NULL;\n\t}\n\n\treturn security_context;\n}","filepath":"src/iot_nv_data.c","line_number":56,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"133872":{"score":0.9132102,"function_name":"_iot_nv_io_storage","code":"STATIC_FUNCTION\niot_error_t _iot_nv_io_storage(const iot_nvd_t nv_id, iot_nv_io_mode_t mode, char *data, size_t data_len, size_t *read_len)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_context_t *security_context;\n\tiot_security_buffer_t data_buf = {0};\n\n\tIOT_DEBUG(\"id = %d, mode = %d\", nv_id, mode);\n\n\tif ((nv_id \u003c 0 || nv_id \u003e= IOT_NVD_MAX)) {\n\t\tIOT_ERROR(\"nv type is invalid\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif ((mode != IOT_NV_MODE_REMOVE) \u0026\u0026 (!data || (data_len == 0))) {\n\t\tIOT_ERROR(\"data input is invalid\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tsecurity_context = _iot_nv_io_storage_init();\n\tIOT_ERROR_CHECK(security_context == NULL, IOT_ERROR_NV_DATA_ERROR, \"failed to init storage\");\n\n\tswitch (mode) {\n\tcase IOT_NV_MODE_READ:\n\t\terr = iot_security_storage_read(security_context, nv_id, \u0026data_buf);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\t\tIOT_DEBUG(\"nv '%d' does not exist\", nv_id);\n\t\t\t\terr = IOT_ERROR_NV_DATA_NOT_EXIST;\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_security_storage_read = %d\", err);\n\t\t\t\terr = IOT_ERROR_NV_DATA_ERROR;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data_len \u003c data_buf.len) {\n\t\t\tIOT_ERROR(\"output buffer is not enough (%d \u003c %d)\", data_len, data_buf.len);\n\t\t\terr = IOT_ERROR_SECURITY_FS_BUFFER;\n\t\t\tiot_os_free(data_buf.p);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(data, data_buf.p, data_buf.len);\n\t\t/* make null terminated string */\n\t\tif (data_buf.len \u003c data_len) {\n\t\t\tdata[data_buf.len] = '\\0';\n\t\t}\n\n\t\tif (read_len != NULL) {\n\t\t\t*read_len = data_buf.len;\n\t\t}\n\n\t\tiot_os_free(data_buf.p);\n\t\tbreak;\n\tcase IOT_NV_MODE_WRITE:\n\t\tdata_buf.p = (unsigned char *)data;\n\t\tdata_buf.len = data_len;\n\n\t\terr = iot_security_storage_write(security_context, nv_id, \u0026data_buf);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"iot_security_storage_write = %d\", err);\n\t\t\terr = IOT_ERROR_NV_DATA_ERROR;\n\t\t}\n\t\tbreak;\n\tcase IOT_NV_MODE_REMOVE:\n                err = iot_security_storage_remove(security_context, nv_id);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\t\tIOT_DEBUG(\"nv '%d' does not exist\", nv_id);\n\t\t\t\terr = IOT_ERROR_NV_DATA_NOT_EXIST;\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_security_storage_remove = %d\", err);\n\t\t\t\terr = IOT_ERROR_NV_DATA_ERROR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t(void)_iot_nv_io_storage_deinit(security_context);\n\n\treturn err;\n}","filepath":"src/iot_nv_data.c","line_number":96,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"134896":{"score":0.54868937,"function_name":"iot_nv_prov_data_exist","code":"bool iot_nv_prov_data_exist(void)\n{\n\tiot_error_t ret;\n\tchar nv_status[5];\n\n\tmemset(nv_status, 0, sizeof(nv_status));\n\n\t/* CHECK IOT_NVD_WIFI_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_WIFI_PROV_STATUS, nv_status, sizeof(nv_status) - 1, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\treturn false;\n\t}\n\n\tif (strncmp(nv_status, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No wifi provisioning data\");\n\t\treturn false;\n\t}\n\n\tmemset(nv_status, 0, sizeof(nv_status));\n\n\t/* CHECK IOT_NVD_CLOUD_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_CLOUD_PROV_STATUS, nv_status, sizeof(nv_status) - 1, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\treturn false;\n\t}\n\n\tif (strncmp(nv_status, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No cloud provisioning data\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}","filepath":"src/iot_nv_data.c","line_number":221,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"135131":{"score":0.8062928,"function_name":"iot_nv_get_prov_data","code":"iot_error_t iot_nv_get_prov_data(struct iot_device_prov_data* prov_data)\n{\n\tHIT();\n\tIOT_WARN_CHECK(prov_data == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tiot_error_t ret;\n\n\tret = iot_nv_get_wifi_prov_data(\u0026prov_data-\u003ewifi);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"get wifi prov fail\");\n\n\tret = iot_nv_get_cloud_prov_data(\u0026prov_data-\u003ecloud);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"get cloud prov fail\");\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":259,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"135277":{"score":0.78888494,"function_name":"iot_nv_set_prov_data","code":"iot_error_t iot_nv_set_prov_data(struct iot_device_prov_data* prov_data)\n{\n\tHIT();\n\tIOT_WARN_CHECK(prov_data == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tiot_error_t ret;\n\n\tret = iot_nv_set_wifi_prov_data(\u0026prov_data-\u003ewifi);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"set wifi prov fail\");\n\n\tret = iot_nv_set_cloud_prov_data(\u0026prov_data-\u003ecloud);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"set cloud prov fail\");\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":275,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"135423":{"score":0.501122,"function_name":"iot_nv_erase_prov_data","code":"iot_error_t iot_nv_erase_prov_data()\n{\n\tHIT();\n\n\t/*\n\t * Todo :\n\t * IOT_NVD_WIFI_PROV_STATUS\n\t * IOT_NVD_CLOUD_PROV_STATUS\n\t */\n\tiot_error_t ret;\n\tconst char* status = \"NONE\";\n\n\tret = _iot_nv_write_data(IOT_NVD_WIFI_PROV_STATUS, status, strlen(status));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tret = _iot_nv_write_data(IOT_NVD_CLOUD_PROV_STATUS, status, strlen(status));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":291,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"135554":{"score":0.8748232,"function_name":"iot_nv_get_wifi_prov_data","code":"iot_error_t iot_nv_get_wifi_prov_data(struct iot_wifi_prov_data* wifi_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(wifi_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_WIFI_PROV_STATUS\n\t * IOT_NVD_AP_SSID\n\t * IOT_NVD_AP_PASS\n\t * IOT_NVD_AP_BSSID\n\t * IOT_NVD_AP_AUTH_TYPE\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_PW_LEN + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* CHECK IOT_NVD_WIFI_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_WIFI_PROV_STATUS, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tif (strncmp(data, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No wifi provisioning data\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_SSID */\n\tret = _iot_nv_read_data(IOT_NVD_AP_SSID, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tif (size \u003c IOT_WIFI_PROV_SSID_LEN) {\n\t\t\tsnprintf(wifi_prov-\u003essid, IOT_WIFI_PROV_SSID_LEN, \"%s\", data);\n\t\t} else {\n\t\t\tmemcpy(wifi_prov-\u003essid, data, IOT_WIFI_PROV_SSID_LEN);\n\t\t\twifi_prov-\u003essid[IOT_WIFI_PROV_SSID_LEN - 1] = '\\0';\n\t\t}\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\twifi_prov-\u003essid[0] = '\\0';\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"AP SSID : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_SSID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_PASS */\n\tret = _iot_nv_read_data(IOT_NVD_AP_PASS, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tif (size \u003c IOT_WIFI_PROV_PASSWORD_LEN) {\n\t\t\tsnprintf(wifi_prov-\u003epassword, IOT_WIFI_PROV_PASSWORD_LEN, \"%s\", data);\n\t\t} else {\n\t\t\tmemcpy(wifi_prov-\u003epassword, data, IOT_WIFI_PROV_PASSWORD_LEN);\n\t\t\twifi_prov-\u003epassword[IOT_WIFI_PROV_PASSWORD_LEN - 1] = '\\0';\n\t\t}\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\twifi_prov-\u003epassword[0] = '\\0';\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"AP PW : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_PASS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_BSSID */\n\tsize_t read_len = 0;\n\tret = _iot_nv_read_data(IOT_NVD_AP_BSSID, data, DATA_SIZE, \u0026read_len);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tif (read_len \u003e= IOT_WIFI_PROV_MAC_STR_LEN) {\n\t\t\t/* bssid : new style, 17byte string case */\n\t\t\tmemcpy(wifi_prov-\u003emac_str, data, IOT_WIFI_PROV_MAC_STR_LEN);\n\t\t\twifi_prov-\u003emac_str[IOT_WIFI_PROV_MAC_STR_LEN] = '\\0';\n\t\t\tret = iot_util_convert_str_mac(wifi_prov-\u003emac_str, \u0026wifi_prov-\u003ebssid);\n\t\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\t\tIOT_INFO(\"Saved AP BSSID is invalid string(%d):%s\",\n\t\t\t\t\tret, wifi_prov-\u003emac_str);\n\t\t\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\t\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\t\t\tret = IOT_ERROR_NONE;\n\t\t\t}\n\t\t} else if (read_len \u003e= IOT_NVD_MAX_BSSID_LEN) {\n\t\t\t/* bssid : old style, 6byte chunk data case */\n\t\t\tmemcpy(wifi_prov-\u003ebssid.addr, data, IOT_NVD_MAX_BSSID_LEN);\n\t\t\tret = iot_util_convert_mac_str(\u0026wifi_prov-\u003ebssid, wifi_prov-\u003emac_str,\n\t\t\t\t\tsizeof(wifi_prov-\u003emac_str));\n\t\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\t\tIOT_INFO(\"Saved AP BSSID is invalid chunk(%d)\", ret);\n\t\t\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\t\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\t\t\tret = IOT_ERROR_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tIOT_INFO(\"Saved AP BSSID is invalid length:%u\", (unsigned int)read_len);\n\t\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\t}\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"AP BSSID : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_BSSID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_AUTH_TYPE */\n\tret = _iot_nv_read_data(IOT_NVD_AP_AUTH_TYPE, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\twifi_prov-\u003esecurity_type = atoi(data);\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\twifi_prov-\u003esecurity_type = -1;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Auth Type : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_AUTH_TYPE, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":320,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"136775":{"score":0.8746948,"function_name":"iot_nv_set_wifi_prov_data","code":"iot_error_t iot_nv_set_wifi_prov_data(struct iot_wifi_prov_data* wifi_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(wifi_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_WIFI_PROV_STATUS\n\t * IOT_NVD_AP_SSID\n\t * IOT_NVD_AP_PASS\n\t * IOT_NVD_AP_BSSID\n\t * IOT_NVD_AP_AUTH_TYPE\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_PW_LEN + 1;\n\tunsigned int size;\n\tint state;\n\tchar* data = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* IOT_NVD_WIFI_PROV_STATUS - NONE */\n\tsize = 4;\n\tmemcpy(data, \"NONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_WIFI_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_SSID */\n\tif (wifi_prov-\u003essid[0] == '\\0') {\n\t\tiot_nv_erase(IOT_NVD_AP_SSID);\n\t} else {\n\t\tsize = IOT_WIFI_PROV_SSID_LEN;\n\t\tmemcpy(data, wifi_prov-\u003essid, size);\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_SSID, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"AP SSID : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_SSID, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_AP_PASS */\n\tif (wifi_prov-\u003epassword[0] == '\\0') {\n\t\tiot_nv_erase(IOT_NVD_AP_PASS);\n\t} else {\n\t\tsize = IOT_WIFI_PROV_PASSWORD_LEN;\n\t\tmemcpy(data, wifi_prov-\u003epassword, size);\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_PASS, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"AP PASS : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_PASS, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_AP_BSSID */\n\tif (wifi_prov-\u003emac_str[0] == '\\0') {\n\t\tiot_nv_erase(IOT_NVD_AP_BSSID);\n\t} else {\n\t\tsize = IOT_WIFI_PROV_MAC_STR_LEN;\n\t\tmemcpy(data, wifi_prov-\u003emac_str, size);\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_BSSID, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"AP BSSID : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_BSSID, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_AP_AUTH_TYPE */\n\tif (wifi_prov-\u003esecurity_type \u003c IOT_WIFI_AUTH_OPEN || wifi_prov-\u003esecurity_type \u003e IOT_WIFI_AUTH_MAX) {\n\t\tiot_nv_erase(IOT_NVD_AP_AUTH_TYPE);\n\t} else {\n\t\tstate = snprintf(data, DATA_SIZE, \"%d\", wifi_prov-\u003esecurity_type);\n\t\tif (state \u003c= 0) {\n\t\t\tIOT_DEBUG(\"Auth Type : data load failed from prov structure\");\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tsize = state;\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_AUTH_TYPE, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"Auth Type : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_AUTH_TYPE, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_WIFI_PROV_STATUS - DONE */\n\tsize = 4;\n\tmemcpy(data, \"DONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_WIFI_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":458,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"137569":{"score":0.9053289,"function_name":"iot_nv_get_cloud_prov_data","code":"iot_error_t iot_nv_get_cloud_prov_data(struct iot_cloud_prov_data* cloud_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(cloud_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_CLOUD_PROV_STATUS\n\t * IOT_NVD_SERVER_URL\n\t * IOT_NVD_SERVER_PORT\n\t * IOT_NVD_LOCATION_ID\n\t * IOT_NVD_ROOM_ID\n\t * IOT_NVD_LABEL\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = (IOT_NVD_MAX_DATA_LEN / 2) + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = iot_os_malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* CHECK IOT_NVD_CLOUD_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_CLOUD_PROV_STATUS, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tif (strncmp(data, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No cloud provisioning data\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_SERVER_URL */\n\tret = _iot_nv_read_data(IOT_NVD_SERVER_URL, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tnew_buff = (char *)iot_os_malloc(size + 1);\n\t\tif (new_buff == NULL) {\n\t\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmemcpy(new_buff, data, size);\n\t\tnew_buff[size] = '\\0';\n\n\t\tcloud_prov-\u003ebroker_url = new_buff;\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tcloud_prov-\u003ebroker_url = NULL;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Server Url : read fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_SERVER_URL, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_SERVER_PORT */\n\tret = _iot_nv_read_data(IOT_NVD_SERVER_PORT, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tcloud_prov-\u003ebroker_port = atoi(data);\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tcloud_prov-\u003ebroker_port = -1;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Server Port : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_SERVER_PORT, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_LABEL */\n\tmemset(data, 0, DATA_SIZE);\n\n\tret = _iot_nv_read_data(IOT_NVD_LABEL, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tnew_buff = (char *)iot_os_malloc(size + 1);\n\t\tif (new_buff == NULL) {\n\t\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmemcpy(new_buff, data, size);\n\t\tnew_buff[size] = '\\0';\n\n\t\tcloud_prov-\u003elabel = new_buff;\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tcloud_prov-\u003elabel = NULL;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Label : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_LABEL, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tiot_os_free(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":585,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"138349":{"score":0.87440705,"function_name":"iot_nv_set_cloud_prov_data","code":"iot_error_t iot_nv_set_cloud_prov_data(struct iot_cloud_prov_data* cloud_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(cloud_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_CLOUD_PROV_STATUS\n\t * IOT_NVD_SERVER_URL\n\t * IOT_NVD_SERVER_PORT\n\t * IOT_NVD_LOCATION_ID\n\t * IOT_NVD_ROOM_ID\n\t * IOT_NVD_LABEL\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = (IOT_NVD_MAX_DATA_LEN / 2) + 1;\n\tsize_t size;\n\tint state;\n\tchar* data = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* IOT_NVD_CLOUD_PROV_STATUS - NONE */\n\tsize = 4;\n\tmemcpy(data, \"NONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_CLOUD_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_SERVER_URL */\n\tif (cloud_prov-\u003ebroker_url == NULL) {\n\t\tiot_nv_erase(IOT_NVD_SERVER_URL);\n\t} else {\n\t\tsize = strlen(cloud_prov-\u003ebroker_url);\n\n\t\tret = _iot_nv_write_data(IOT_NVD_SERVER_URL, cloud_prov-\u003ebroker_url, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"Server Url : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_SERVER_URL, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_SERVER_PORT */\n\tstate = snprintf(data, DATA_SIZE, \"%d\", cloud_prov-\u003ebroker_port);\n\tif (state \u003c= 0) {\n\t\tIOT_DEBUG(\"Server Port : data load failed from prov structure\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = state;\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_SERVER_PORT, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Server Port : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_SERVER_PORT, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_LABEL */\n\tif (cloud_prov-\u003elabel == NULL) {\n\t\tiot_nv_erase(IOT_NVD_LABEL);\n\t} else {\n\t\tsize = strlen(cloud_prov-\u003elabel);\n\t\tret = _iot_nv_write_data(IOT_NVD_LABEL, cloud_prov-\u003elabel, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"Label : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_LABEL, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_CLOUD_PROV_STATUS - DONE */\n\tsize = 4;\n\tmemcpy(data, \"DONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_CLOUD_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":694,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"138974":{"score":0.89073366,"function_name":"iot_nv_get_certificate","code":"iot_error_t iot_nv_get_certificate(iot_security_cert_id_t cert_id, char** cert, size_t* len)\n{\n\tiot_error_t ret;\n\tiot_security_context_t *security_context;\n\tiot_security_buffer_t cert_buf;\n\n\tHIT();\n\tIOT_WARN_CHECK((cert == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tsecurity_context = _iot_nv_io_storage_init();\n\tif (security_context == NULL) {\n\t\tIOT_ERROR(\"failed to init storage\");\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tret = iot_security_manager_init(security_context);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to init manager\");\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tret = iot_security_manager_get_certificate(security_context, cert_id, \u0026cert_buf);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get cert(%d), ret = %d\", cert_id, ret);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\t*cert = (char *)cert_buf.p;\n\t*len = cert_buf.len;\n\n\t(void)iot_security_manager_deinit(security_context);\n\t(void)_iot_nv_io_storage_deinit(security_context);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":796,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"139364":{"score":0.8914309,"function_name":"iot_nv_get_device_id","code":"iot_error_t iot_nv_get_device_id(char** device_id, size_t* len)\n{\n\tHIT();\n\tIOT_WARN_CHECK((device_id == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_DEVICE_ID\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_UID_LEN + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = iot_os_malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\tret = _iot_nv_read_data(IOT_NVD_DEVICE_ID, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_DEVICE_ID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = strlen(data);\n\tnew_buff = (char*)iot_os_malloc(size + 1);\n\tif (new_buff == NULL) {\n\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(new_buff, data, size);\n\tnew_buff[size] = '\\0';\n\n\t*device_id = new_buff;\n\t*len = size;\n\nexit:\n\tiot_os_free(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":832,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"139738":{"score":0.8123923,"function_name":"iot_nv_set_device_id","code":"iot_error_t iot_nv_set_device_id(const char* device_id)\n{\n\tHIT();\n\tIOT_WARN_CHECK(device_id == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_DEVICE_ID\n\t */\n\tiot_error_t ret;\n\n\tret = _iot_nv_write_data(IOT_NVD_DEVICE_ID, device_id, strlen(device_id));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_DEVICE_ID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":877,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"139866":{"score":0.9081552,"function_name":"iot_nv_get_serial_number","code":"iot_error_t iot_nv_get_serial_number(char** sn, size_t* len)\n{\n\tHIT();\n\tIOT_WARN_CHECK((sn == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tiot_error_t ret;\n\tunsigned int size;\n\tconst int DATA_SIZE = IOT_NVD_MAX_SN_LEN + 1;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = iot_os_malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\tret = _iot_nv_read_data(IOT_NVD_SERIAL_NUM, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_SERIAL_NUM, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = strlen(data);\n\tnew_buff = (char*)iot_os_malloc(size + 1);\n\tif (new_buff == NULL) {\n\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(new_buff, data, size);\n\tnew_buff[size] = '\\0';\n\n\t*sn = new_buff;\n\t*len = size;\n\nexit:\n\tiot_os_free(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":897,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"140240":{"score":0.89943075,"function_name":"iot_nv_get_misc_info","code":"iot_error_t iot_nv_get_misc_info(char** misc_info, size_t* len)\n{\n\tHIT();\n\tIOT_WARN_CHECK((misc_info == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_MISC_INFO\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_DATA_LEN + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\tret = _iot_nv_read_data(IOT_NVD_MISC_INFO, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_MISC_INFO, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = strlen(data);\n\tnew_buff = (char*)malloc(size + 1);\n\tif (new_buff == NULL) {\n\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(new_buff, data, size);\n\tnew_buff[size] = '\\0';\n\n\t*misc_info = new_buff;\n\t*len = size;\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":939,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"140614":{"score":0.83926845,"function_name":"iot_nv_set_misc_info","code":"iot_error_t iot_nv_set_misc_info(const char* misc_info)\n{\n\tHIT();\n\tIOT_WARN_CHECK(misc_info == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_MISC_INFO\n\t */\n\tiot_error_t ret;\n\n\tret = _iot_nv_write_data(IOT_NVD_MISC_INFO, misc_info, strlen(misc_info));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_MISC_INFO, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":984,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"140742":{"score":0.7906608,"function_name":"iot_nv_erase","code":"iot_error_t iot_nv_erase(iot_nvd_t nv_type)\n{\n\tHIT();\n\tIOT_WARN_CHECK((nv_type \u003c 0 || nv_type \u003e= IOT_NVD_MAX), IOT_ERROR_INVALID_ARGS, \"Invalid args\");\n\n\tiot_error_t ret;\n\n\tret = _iot_nv_remove_data(nv_type);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tif (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\t\tIOT_DEBUG(\"file does not exist\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_NOT_EXIST, nv_type, __LINE__);\n\t\t\treturn IOT_ERROR_NV_DATA_NOT_EXIST;\n\t\t} else {\n\t\t\tIOT_DEBUG(\"file remove failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_ERASE_FAIL, nv_type, __LINE__);\n\t\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":1004,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"140866":{"score":0.90200454,"function_name":"iot_nv_get_static_certificate","code":"iot_error_t iot_nv_get_static_certificate(iot_security_cert_id_t cert_id, iot_security_buffer_t *output_buf)\n{\n\tunsigned char *data = NULL;\n\tunsigned char *cert;\n\tunsigned int cert_len;\n\n\tIOT_DEBUG(\"cert id = %d\", cert_id);\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buf is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tswitch (cert_id) {\n\tcase IOT_SECURITY_CERT_ID_ROOT_CA:\n\t\tcert = st_root_ca;\n\t\tcert_len = st_root_ca_len;\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"%d is not a supported static certificate\", cert_id);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tdata = (unsigned char *)iot_os_malloc(cert_len + 1);\n\tif (!data) {\n\t\tIOT_ERROR(\"failed to malloc for static nv\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, cert, cert_len);\n\tdata[cert_len] = '\\0';\n\n\toutput_buf-\u003ep = data;\n\toutput_buf-\u003elen = cert_len;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":1027,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141157":{"score":0.8186568,"function_name":"iot_nv_get_data_from_device_info","code":"iot_error_t iot_nv_get_data_from_device_info(iot_nvd_t nv_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tconst char *di_name;\n\tchar *data = NULL;\n\n\tIOT_DEBUG(\"nv id = %d\", nv_id);\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tswitch (nv_id) {\n\tcase IOT_NVD_PRIVATE_KEY:\n\t\tdi_name = name_privateKey;\n\t\tbreak;\n\tcase IOT_NVD_PUBLIC_KEY:\n\t\tdi_name = name_publicKey;\n\t\tbreak;\n\tcase IOT_NVD_DEVICE_CERT:\n\t\tdi_name = name_deviceCert;\n\t\tbreak;\n\tcase IOT_NVD_SERIAL_NUM:\n\t\tdi_name = name_serialNumber;\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"%d is not a device info nv\", nv_id);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\terr = iot_api_read_device_identity(device_nv_info, device_nv_info_len, di_name, \u0026data);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_api_read_device_identity = %d\", err);\n\t\treturn err;\n\t}\n\n\tif (data) {\n\t\toutput_buf-\u003ep = (unsigned char *)data;\n\t\toutput_buf-\u003elen = strlen(data);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":1066,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141592":{"score":0.8837966,"function_name":"iot_os_thread_create","code":"int iot_os_thread_create(void * thread_function, const char* name, int stack_size,\n\t\tvoid* data, int priority, iot_os_thread* thread_handle)\n{\n\tpthread_t* thread = malloc(sizeof(pthread_t));\n\tpthread_attr_t attr;\n\n\tif (thread == NULL)\n\t\treturn IOT_OS_FALSE;\n\n\tpthread_attr_init(\u0026attr);\n\tpthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED);\n\n\tpthread_create(thread, \u0026attr, thread_function, data);\n\n\tpthread_attr_destroy(\u0026attr);\n\n\tif (thread_handle != NULL) {\n\t\t*thread_handle = (iot_os_thread*)thread;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":55,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141784":{"score":0.9224105,"function_name":"iot_os_thread_delete","code":"void iot_os_thread_delete(iot_os_thread thread_handle)\n{\n\tif (thread_handle != NULL) {\n\t\tpthread_t* thread = (pthread_t*)thread_handle;\n\t\tpthread_cancel(*thread);\n\t\tfree(thread);\n\t} else {\n\t\tpthread_cancel(pthread_self());\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":78,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141901":{"score":0.92900777,"function_name":"iot_os_thread_get_current_handle","code":"int iot_os_thread_get_current_handle(iot_os_thread* thread_handle)\n{\n    if (thread_handle == NULL) {\n        return IOT_OS_FALSE;\n    }\n\n    *thread_handle = (iot_os_thread)pthread_self();\n    return IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":94,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141956":{"score":0.8765708,"function_name":"iot_os_queue_create","code":"iot_os_queue* iot_os_queue_create(int queue_length, int item_size)\n{\n\tiot_os_queue_posix_t* queue = malloc(sizeof(iot_os_queue_posix_t));\n\tstruct mq_attr attr;\n\n\tif (queue == NULL)\n\t\treturn NULL;\n\n\tattr.mq_flags = 0;\n\tattr.mq_maxmsg = (queue_length \u003c= 10) ? queue_length : 10;\n\tattr.mq_msgsize = item_size;\n\tattr.mq_curmsgs = 0;\n\n\tsnprintf(queue-\u003ename, sizeof(queue-\u003ename), \"/q%u\", iot_bsp_random());\n\tqueue-\u003elength = queue_length;\n\tqueue-\u003emsg_size = item_size;\n\n\tqueue-\u003emqd = mq_open(queue-\u003ename, O_CREAT | O_RDWR, 0644, \u0026attr);\n\tif (queue-\u003emqd == -1) {\n\t\tfree(queue);\n\t\treturn NULL;\n\t}\n\n\treturn (void*)queue;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":112,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142188":{"score":0.86733645,"function_name":"iot_os_queue_reset","code":"int iot_os_queue_reset(iot_os_queue* queue_handle)\n{\n\tiot_os_queue_posix_t* queue = (iot_os_queue_posix_t*)queue_handle;\n\n\tmq_close(queue-\u003emqd);\n\tmq_unlink(queue-\u003ename);\n\n\tstruct mq_attr attr;\n\n\tattr.mq_flags = 0;\n\tattr.mq_maxmsg = (queue-\u003elength \u003c= 10) ? queue-\u003elength : 10;\n\tattr.mq_msgsize = queue-\u003emsg_size;\n\tattr.mq_curmsgs = 0;\n\n\tqueue-\u003emqd = mq_open(queue-\u003ename, O_CREAT | O_RDWR, 0644, \u0026attr);\n\tif (queue-\u003emqd == -1) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":138,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142458":{"score":0.93489844,"function_name":"iot_os_queue_send","code":"int iot_os_queue_send(iot_os_queue* queue_handle, void * data, unsigned int wait_time_ms)\n{\n\tiot_os_queue_posix_t* queue = (iot_os_queue_posix_t*)queue_handle;\n\tstruct timespec ts = {0,};\n\n\tif (!queue || !data)\n\t    return IOT_OS_FALSE;\n\n\tts.tv_sec = wait_time_ms / 1000;\n\tts.tv_nsec = (wait_time_ms % 1000) * 1000000;\n\n\tint ret = mq_timedsend(queue-\u003emqd, data, queue-\u003emsg_size, 0, \u0026ts);\n\tif (ret == -1) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":169,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142671":{"score":0.91305804,"function_name":"iot_os_queue_receive","code":"int iot_os_queue_receive(iot_os_queue* queue_handle, void * data, unsigned int wait_time_ms)\n{\n\tiot_os_queue_posix_t* queue = (iot_os_queue_posix_t*)queue_handle;\n\tstruct timespec ts = {0,};\n\n\tts.tv_sec = wait_time_ms / 1000;\n\tts.tv_nsec = (wait_time_ms % 1000) * 1000000;\n\n\tint ret = mq_timedreceive(queue-\u003emqd, data, queue-\u003emsg_size, NULL, \u0026ts);\n\tif (ret == -1) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":188,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142865":{"score":0.87862283,"function_name":"iot_os_eventgroup_create","code":"iot_os_eventgroup* iot_os_eventgroup_create(void)\n{\n\teventgroup_t *eventgroup = malloc(sizeof(eventgroup_t));\n\tif (eventgroup == NULL)\n\t\treturn NULL;\n\n\tif (pthread_mutex_init(\u0026eventgroup-\u003emutex, NULL)) {\n\t\tfree(eventgroup);\n\t\treturn NULL;\n\t}\n\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\teventgroup-\u003egroup[i].id = (1 \u003c\u003c i);\n\t\tint ret = pipe(eventgroup-\u003egroup[i].fd);\n\t\tif (ret == -1) {\n\t\t\tfree(eventgroup);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\teventgroup-\u003eevent_status = 0;\n\n\treturn eventgroup;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":219,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"143099":{"score":0.95492405,"function_name":"iot_os_eventgroup_delete","code":"void iot_os_eventgroup_delete(iot_os_eventgroup* eventgroup_handle)\n{\n\teventgroup_t* eventgroup = eventgroup_handle;\n\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\tclose(eventgroup-\u003egroup[i].fd[0]);\n\t\tclose(eventgroup-\u003egroup[i].fd[1]);\n\t}\n\tpthread_mutex_destroy(\u0026eventgroup-\u003emutex);\n\tfree(eventgroup);\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":244,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"143248":{"score":0.8563489,"function_name":"iot_os_eventgroup_wait_bits","code":"unsigned char iot_os_eventgroup_wait_bits(iot_os_eventgroup* eventgroup_handle,\n\t\tconst unsigned char bits_to_wait_for, const int clear_on_exit, const unsigned int wait_time_ms)\n{\n\teventgroup_t *eventgroup = eventgroup_handle;\n\tfd_set readfds;\n\tint fd_max = 0;\n\tunsigned char event_status_backup;\n\n\tFD_ZERO(\u0026readfds);\n\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\tif (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 bits_to_wait_for)) {\n\t\t\tFD_SET(eventgroup-\u003egroup[i].fd[0], \u0026readfds);\n\t\t\tif (eventgroup-\u003egroup[i].fd[0] \u003e= fd_max) {\n\t\t\t\tfd_max = eventgroup-\u003egroup[i].fd[0];\n\t\t\t}\n\t\t}\n\t}\n\n\tchar buf[3] = {0,};\n\tstruct timeval tv;\n\tmemset(\u0026tv, 0x00, sizeof(tv));\n\tunsigned char bits = 0x00;\n\tssize_t read_size = 0;\n\n\ttv.tv_sec = wait_time_ms / 1000;\n\ttv.tv_usec = (wait_time_ms % 1000) * 1000;\n\n\tint ret = select(fd_max + 1, \u0026readfds, NULL, NULL, \u0026tv);\n\tpthread_mutex_lock(\u0026eventgroup-\u003emutex);\n\tif (ret == -1) {\n\t\t// Select Error\n\t\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\t\treturn 0;\n\t} else if (ret == 0) {\n\t\t// Select Timeout\n\t\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\t\treturn (unsigned int)eventgroup-\u003eevent_status;\n\t} else {\n\t\t// read pipe\n\t\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\t\tif (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 bits_to_wait_for)) {\n\t\t\t\tif (FD_ISSET(eventgroup-\u003egroup[i].fd[0], \u0026readfds)) {\n\t\t\t\t\tmemset(buf, 0, sizeof(buf));\n\t\t\t\t\tread_size = read(eventgroup-\u003egroup[i].fd[0], buf, sizeof(buf));\n\t\t\t\t\tIOT_DEBUG(\"read_size = %d (%d)\", read_size, i);\n\t\t\t\t\tbits |= eventgroup-\u003egroup[i].id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tevent_status_backup = eventgroup-\u003eevent_status;\n\t\tif (clear_on_exit) {\n\t\t\teventgroup-\u003eevent_status \u0026= ~(bits);\n\t\t}\n\t\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\n\t\treturn (unsigned int)event_status_backup;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":256,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144318":{"score":0.745113,"function_name":"iot_os_eventgroup_set_bits","code":"int iot_os_eventgroup_set_bits(iot_os_eventgroup* eventgroup_handle,\n\t\tconst unsigned char bits_to_set)\n{\n\teventgroup_t *eventgroup = eventgroup_handle;\n\tunsigned char bits = 0;\n\tssize_t write_size = 0;\n\n\tpthread_mutex_lock(\u0026eventgroup-\u003emutex);\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n        if (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 eventgroup-\u003eevent_status)) {\n            IOT_DEBUG(\"already set 0x%08x (%d)\", eventgroup-\u003egroup[i].id, i);\n            continue;\n        }\n\t\tif (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 bits_to_set)) {\n\t\t\twrite_size = write(eventgroup-\u003egroup[i].fd[1], \"Set\", strlen(\"Set\"));\n\t\t\tIOT_DEBUG(\"write_size = %d (%d)\", write_size, i);\n\t\t\tbits |= eventgroup-\u003egroup[i].id;\n\t\t}\n\t}\n\n\teventgroup-\u003eevent_status |= bits;\n\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":317,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144725":{"score":0.9352515,"function_name":"iot_os_mutex_init","code":"int iot_os_mutex_init(iot_os_mutex* mutex)\n{\n\tif (!mutex) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\tpthread_mutex_t* mutex_p = malloc(sizeof(pthread_mutex_t));\n\tif (!mutex_p) {\n\t\treturn IOT_OS_FALSE;\n\t} else {\n\t\tpthread_mutex_init(mutex_p, NULL);\n\t\tmutex-\u003esem = mutex_p;\n\t}\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":358,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144819":{"score":0.8975137,"function_name":"iot_os_mutex_lock","code":"int iot_os_mutex_lock(iot_os_mutex* mutex)\n{\n\tint ret;\n\n\tif (!mutex || !mutex-\u003esem) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\tpthread_mutex_t* mutex_p = mutex-\u003esem;\n\n\tret = pthread_mutex_trylock(mutex_p);\n\tif (ret) {\n\t\treturn IOT_OS_FALSE;\n\t} else {\n\t\treturn IOT_OS_TRUE;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":374,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144908":{"score":0.8884561,"function_name":"iot_os_mutex_unlock","code":"int iot_os_mutex_unlock(iot_os_mutex* mutex)\n{\n\tint ret;\n\n\tif (!mutex || !mutex-\u003esem) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\tpthread_mutex_t* mutex_p = mutex-\u003esem;\n\n\tret = pthread_mutex_unlock(mutex_p);\n\tif (ret) {\n\t\treturn IOT_OS_FALSE;\n\t} else {\n\t\treturn IOT_OS_TRUE;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":392,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144997":{"score":0.9080553,"function_name":"iot_os_mutex_destroy","code":"void iot_os_mutex_destroy(iot_os_mutex* mutex)\n{\n\tif (!mutex || !mutex-\u003esem) {\n\t\treturn;\n\t}\n\tpthread_mutex_t* mutex_p = mutex-\u003esem;\n\n\tpthread_mutex_destroy(mutex_p);\n\tfree(mutex_p);\n\tmutex-\u003esem = NULL;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":410,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145220":{"score":0.8695401,"function_name":"iot_os_timer_count_ms","code":"void iot_os_timer_count_ms(iot_os_timer timer, unsigned int timeout_ms)\n{\n\ttimer_t* timer_id = (timer_t*) timer;\n\tstruct itimerspec it;\n\n\tit.it_interval.tv_sec = 0;\n\tit.it_interval.tv_nsec = 0;\n\tit.it_value.tv_sec = timeout_ms / 1000;\n\tit.it_value.tv_nsec = (timeout_ms % 1000) * 1000000;\n\n\tint ret = timer_settime(*timer_id, 0, \u0026it, NULL);\n\tif (ret == -1) {\n\t\treturn;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":433,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145380":{"score":0.91524816,"function_name":"iot_os_timer_left_ms","code":"unsigned int iot_os_timer_left_ms(iot_os_timer timer)\n{\n\ttimer_t* timer_id = (timer_t*) timer;\n\tstruct itimerspec it = {0,};\n\tunsigned int left = 0;\n\n\tint ret = timer_gettime(*timer_id, \u0026it);\n\tif (ret == -1) {\n\t\treturn 0;\n\t}\n\n\treturn (it.it_value.tv_sec * 1000) + (it.it_value.tv_nsec / 1000000);\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":449,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145552":{"score":0.8890009,"function_name":"iot_os_timer_isexpired","code":"char iot_os_timer_isexpired(iot_os_timer timer)\n{\n\ttimer_t* timer_id = (timer_t*) timer;\n\tstruct itimerspec it = {0,};\n\n\tint ret = timer_gettime(*timer_id, \u0026it);\n\tif (ret == -1) {\n\t\treturn IOT_OS_TRUE;\n\t}\n\n\tif (it.it_value.tv_sec == 0 \u0026\u0026 it.it_value.tv_nsec == 0) {\n\t\treturn IOT_OS_TRUE;\n\t} else {\n\t\treturn IOT_OS_FALSE;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":463,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145708":{"score":0.896694,"function_name":"iot_os_timer_init","code":"int iot_os_timer_init(iot_os_timer *timer)\n{\n\ttimer_t* timer_id = malloc(sizeof(timer_t));\n\tstruct sigevent sig;\n\n\tif (timer_id == NULL)\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\n\tmemset(\u0026sig, '\\0', sizeof(struct sigevent));\n\tsig.sigev_notify = SIGEV_NONE;\n\tsig.sigev_value.sival_ptr = timer_id;\n\tint ret = timer_create(CLOCK_REALTIME, \u0026sig, timer_id);\n\tif (ret == -1) {\n\t\tfree(timer_id);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\t*timer = timer_id;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":480,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"146188":{"score":0.6240622,"function_name":"iot_security_check_backend_funcs_entry_is_valid","code":"iot_error_t iot_security_check_backend_funcs_entry_is_valid(iot_security_context_t *context)\n{\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (!context-\u003ebe_context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_CONTEXT_NULL, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNCS_ENTRY_NULL, 0);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_common.c","line_number":35,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"146258":{"score":0.9232974,"function_name":"iot_security_init","code":"iot_security_context_t *iot_security_init(void)\n{\n\tiot_security_context_t *context;\n\tiot_security_be_context_t *be_context;\n#if defined(CONFIG_STDK_IOT_CORE_SUPPORT_STNV_PARTITION)\n\texternal_nv_callback external_nv_cb = NULL;\n#else\n\texternal_nv_callback external_nv_cb = iot_nv_get_data_from_device_info;\n#endif\n\n\tcontext = (iot_security_context_t *)iot_os_malloc(sizeof(iot_security_context_t));\n\tif (!context) {\n\t\tIOT_ERROR(\"failed to malloc for context\");\n\t\treturn NULL;\n\t}\n\n\tmemset(context, 0, sizeof(iot_security_context_t));\n\n\tbe_context = iot_security_be_init(external_nv_cb);\n\tif (!be_context) {\n\t\tIOT_ERROR(\"failed to malloc for backend context\");\n\t\tiot_os_free(context);\n\t\treturn NULL;\n\t}\n\n\tcontext-\u003ebe_context = be_context;\n\n\treturn context;\n}","filepath":"src/security/iot_security_common.c","line_number":52,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"146465":{"score":0.87199765,"function_name":"iot_security_deinit","code":"iot_error_t iot_security_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_context_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_security_be_deinit(context-\u003ebe_context);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_be_deinit = %d\", err);\n\t\treturn err;\n\t}\n\n\tmemset(context, 0, sizeof(iot_security_context_t));\n\n\tiot_os_free(context);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_common.c","line_number":82,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"146621":{"score":0.82282794,"function_name":"iot_security_manager_init","code":"iot_error_t iot_security_manager_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003emanager_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003emanager_init(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_MANAGER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":26,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"146750":{"score":0.8210534,"function_name":"iot_security_manager_deinit","code":"iot_error_t iot_security_manager_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003emanager_deinit) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003emanager_deinit(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system \u0026= ~IOT_SECURITY_SUB_MANAGER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":48,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"146879":{"score":0.91863734,"function_name":"iot_security_manager_set_key","code":"iot_error_t iot_security_manager_set_key(iot_security_context_t *context, iot_security_key_params_t *key_params)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!key_params) {\n\t\tIOT_ERROR(\"key params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003emanager_set_key) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_set_key is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\tIOT_DEBUG(\"key id = %d\", key_params-\u003ekey_id);\n\n\terr = context-\u003ebe_context-\u003efn-\u003emanager_set_key(context, key_params);\n\tif (err) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_set_key = %d\", err);\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":70,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147128":{"score":0.9357389,"function_name":"iot_security_manager_get_key","code":"iot_error_t iot_security_manager_get_key(iot_security_context_t *context, iot_security_key_id_t key_id, iot_security_buffer_t *key_buf)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"key id = %d\", key_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif ((key_id \u003c= IOT_SECURITY_KEY_ID_UNKNOWN) || (key_id \u003e= IOT_SECURITY_KEY_ID_MAX)) {\n\t\tIOT_ERROR(\"'%d' is invalid\", key_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_INVALID_ID, 0);\n\t}\n\n\tif (!key_buf) {\n\t\tIOT_ERROR(\"key buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(key_buf, 0, sizeof(iot_security_buffer_t));\n\n\tif (!context-\u003ebe_context-\u003efn-\u003emanager_get_key) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_key is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003emanager_get_key(context, key_id, key_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_key = %d\", err);\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":100,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147462":{"score":0.704016,"function_name":"_iot_security_manager_check_certificate_target","code":"STATIC_FUNCTION\niot_security_storage_target_t _iot_security_manager_check_certificate_target(iot_security_cert_id_t cert_id)\n{\n\tswitch (cert_id) {\n\tcase IOT_SECURITY_CERT_ID_ROOT_CA:\n\t\treturn IOT_SECURITY_STORAGE_TARGET_STATIC;\n\tdefault:\n\t\treturn IOT_SECURITY_STORAGE_TARGET_NV;\n\t}\n}","filepath":"src/security/iot_security_manager.c","line_number":137,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147497":{"score":0.9094163,"function_name":"iot_security_manager_get_certificate","code":"iot_error_t iot_security_manager_get_certificate(iot_security_context_t *context, iot_security_cert_id_t cert_id, iot_security_buffer_t *cert_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"cert id = %d\", cert_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif ((cert_id \u003c= IOT_SECURITY_CERT_ID_UNKNOWN) || (cert_id \u003e= IOT_SECURITY_CERT_ID_MAX)) {\n\t\tIOT_ERROR(\"'%d' is invalid\", cert_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CERT_INVALID_ID, 0);\n\t}\n\n\tif (!cert_buf) {\n\t\tIOT_ERROR(\"cert buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(cert_buf, 0, sizeof(iot_security_buffer_t));\n\n\tstorage_target = _iot_security_manager_check_certificate_target(cert_id);\n\tif (storage_target == IOT_SECURITY_STORAGE_TARGET_STATIC) {\n\t\treturn iot_nv_get_static_certificate(cert_id, cert_buf);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003emanager_get_certificate) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_certificate is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003emanager_get_certificate(context, cert_id, cert_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_certificate = %d\", err);\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":148,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147885":{"score":0.88221395,"function_name":"_iot_security_storage_set_storage_id","code":"STATIC_FUNCTION\niot_error_t _iot_security_storage_set_storage_id(iot_security_context_t *context, iot_security_storage_id_t storage_id)\n{\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (!context-\u003estorage_params) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_PARAMS_NULL, 0);\n\t}\n\n\tif ((storage_id \u003c= IOT_NVD_UNKNOWN) || (storage_id \u003e= IOT_NVD_MAX)) {\n\t\tIOT_ERROR(\"'%d' is invalid id\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_INVALID_ID, storage_id);\n\t}\n\n\tcontext-\u003estorage_params-\u003estorage_id = storage_id;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":26,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148013":{"score":0.9329775,"function_name":"iot_security_storage_init","code":"iot_error_t iot_security_storage_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tstorage_params = (iot_security_storage_params_t *)iot_os_malloc(sizeof(iot_security_storage_params_t));\n\tif (!storage_params) {\n\t\tIOT_ERROR(\"failed to malloc for storage params\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemset(storage_params, 0, sizeof(iot_security_storage_params_t));\n\n\tcontext-\u003estorage_params = storage_params;\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003estorage_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003estorage_init(context);\n\t\tif (err) {\n\t\t\tiot_os_free(context-\u003estorage_params);\n\t\t\tcontext-\u003estorage_params = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_STORAGE;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":47,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148273":{"score":0.7576022,"function_name":"iot_security_storage_deinit","code":"iot_error_t iot_security_storage_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003estorage_deinit) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003estorage_deinit(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (context-\u003estorage_params) {\n\t\tmemset(context-\u003estorage_params, 0, sizeof(iot_security_storage_params_t));\n\t\tiot_os_free(context-\u003estorage_params);\n\t\tcontext-\u003estorage_params = NULL;\n\t}\n\n\tcontext-\u003esub_system \u0026= ~IOT_SECURITY_SUB_STORAGE;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":82,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148470":{"score":0.8604538,"function_name":"iot_security_storage_read","code":"iot_error_t iot_security_storage_read(iot_security_context_t *context, iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"id:%d\", storage_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_storage_set_storage_id(context, storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tif (!context-\u003ebe_context-\u003efn-\u003estorage_read) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003estorage_read is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003estorage_read(context, output_buf);\n\tif (err) {\n\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\tIOT_DEBUG(\"id:%d not found\", context-\u003estorage_params-\u003estorage_id);\n\t\t}\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"id:%d read %d@%p\", context-\u003estorage_params-\u003estorage_id, (int)output_buf-\u003elen, output_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":110,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148732":{"score":0.8789703,"function_name":"iot_security_storage_write","code":"iot_error_t iot_security_storage_write(iot_security_context_t *context, iot_security_storage_id_t storage_id, iot_security_buffer_t *input_buf)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"id:%d\", storage_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_storage_set_storage_id(context, storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003estorage_write) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003estorage_write is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003estorage_write(context, input_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"id:%d written %d@%p\", context-\u003estorage_params-\u003estorage_id, (int)input_buf-\u003elen, input_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":151,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148998":{"score":0.8705998,"function_name":"iot_security_storage_remove","code":"iot_error_t iot_security_storage_remove(iot_security_context_t *context, iot_security_storage_id_t storage_id)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"id:%d\", storage_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_storage_set_storage_id(context, storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003estorage_remove) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003estorage_remove is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003estorage_remove(context);\n\tif (err) {\n\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\tIOT_DEBUG(\"id:%d not found\", context-\u003estorage_params-\u003estorage_id);\n\t\t}\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"id:%d removed\", context-\u003estorage_params-\u003estorage_id);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":187,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"149187":{"score":0.8999749,"function_name":"_isalpha","code":"static int _isalpha(char c)\n{\n\tif (('A' \u003c= c) \u0026\u0026 (c \u003c= 'Z'))\n\t\treturn 1;\n\n\tif (('a' \u003c= c) \u0026\u0026 (c \u003c= 'z'))\n\t\treturn 1;\n\n\treturn 0;\n}","filepath":"src/iot_util.c","line_number":27,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"149254":{"score":0.6504066,"function_name":"mbedtls_ssl_pk_alg_from_sig","code":"mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig( unsigned char sig )\n{\n    switch( sig )\n    {\n#if defined(MBEDTLS_RSA_C)\n        case MBEDTLS_SSL_SIG_RSA:\n            return( MBEDTLS_PK_RSA );\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n        case MBEDTLS_SSL_SIG_ECDSA:\n            return( MBEDTLS_PK_ECDSA );\n#endif\n        default:\n            return( MBEDTLS_PK_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":9988,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"149302":{"score":0.8870027,"function_name":"_ishex","code":"static int _ishex(char c)\n{\n\tif (c \u003e= '0' \u0026\u0026 c \u003c= '9') {\n\t\treturn 1;\n\t}\n\n\tif (c \u003e= 'a' \u0026\u0026 c \u003c= 'f') {\n\t\treturn 1;\n\t}\n\n\tif (c \u003e= 'A' \u0026\u0026 c \u003c= 'Z') {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}","filepath":"src/iot_util.c","line_number":45,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"149388":{"score":0.83537453,"function_name":"_ishex_len","code":"static int _ishex_len(char *c, size_t len)\n{\n\tint i;\n\tfor (i = 0; i \u003c len; i++, c++)\n\t{\n\t\tif (!_ishex(*c)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}","filepath":"src/iot_util.c","line_number":62,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"149465":{"score":0.9044037,"function_name":"iot_util_dump_mem","code":"void iot_util_dump_mem(char *tag, uint8_t *buf, size_t len)\n{\n\tconst char *newline = \"\";\n\tconst char *space = \" \";\n\tint i, j;\n\tint w = 16;\n\n\tif (!strcmp(tag, \"raw\")) {\n\t\tspace = \"\";\n\t}\n\n\tfor (i = 0; i \u003c len; i += w) {\n\t\tif (!strcmp(tag, \"dump\") \u0026\u0026 !(i % 0x10)) {\n\t\t\tprintf(\"%s[%p] \", newline, buf + i);\n\t\t\tnewline = \"\\n\";\n\t\t}\n\n\t\tfor (j = i; j \u003c (i + w); j++) {\n\t\t\tif (j \u003c len)\n\t\t\t\tprintf(\"%02x%s\", buf[j], space);\n\t\t\telse\n\t\t\t\tprintf(\"   \");\n\t\t}\n\n\t\tif (strcmp(tag, \"dump\"))\n\t\t\tcontinue;\n\n\t\tfor (j = i; j \u003c (i + w); j++) {\n\t\t\tif (_isprint(buf[j])) {\n\t\t\t\tprintf(\"%c\", buf[j]);\n\t\t\t} else {\n\t\t\t\tprintf(\"%c\", '.');\n\t\t\t}\n\t\t\tif (j \u003e= len)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}","filepath":"src/iot_util.c","line_number":74,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"149889":{"score":0.75884795,"function_name":"validate_uuid_format","code":"iot_error_t validate_uuid_format(const char *str, size_t str_len)\n{\n\tchar *ptr = (char*) str;\n\n\tif (!str) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (str_len != UUID_STRING_LENGTH) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_TIME_LOW_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_TIME_LOW_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_TIME_MID_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_TIME_MID_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (*ptr \u003c '1' || *ptr \u003e '5') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(++ptr, UUID_TIME_HI_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_TIME_HI_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_CLOCK_SEQ_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_CLOCK_SEQ_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_NODE_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":121,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"150224":{"score":0.9221001,"function_name":"iot_util_convert_str_uuid","code":"iot_error_t iot_util_convert_str_uuid(const char* str, struct iot_uuid* uuid)\n{\n\tint i, j = 0, k = 1;\n\tunsigned char c = 0;\n\n\tif (!uuid || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (validate_uuid_format(str, strlen(str)) != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Invalid uuid format\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tfor (i = 0; i \u003c UUID_STRING_LENGTH; i++) {\n\t\tif (str[i] == '-') {\n\t\t\tcontinue;\n\t\t} else if (_isalpha(str[i])) {\n\t\t\tswitch (str[i]) {\n\t\t\tcase 65:\n\t\t\tcase 97:\n\t\t\t\tc |= 0x0a;\n\t\t\t\tbreak;\n\t\t\tcase 66:\n\t\t\tcase 98:\n\t\t\t\tc |= 0x0b;\n\t\t\t\tbreak;\n\t\t\tcase 67:\n\t\t\tcase 99:\n\t\t\t\tc |= 0x0c;\n\t\t\t\tbreak;\n\t\t\tcase 68:\n\t\t\tcase 100:\n\t\t\t\tc |= 0x0d;\n\t\t\t\tbreak;\n\t\t\tcase 69:\n\t\t\tcase 101:\n\t\t\t\tc |= 0x0e;\n\t\t\t\tbreak;\n\t\t\tcase 70:\n\t\t\tcase 102:\n\t\t\t\tc |= 0x0f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tc |= str[i] - 48;\n\t\t}\n\n\t\tif ((j + 1) * 2 == k) {\n\t\t\tuuid-\u003eid[j++] = c;\n\t\t\tc = 0;\n\t\t} else {\n\t\t\tc = c \u003c\u003c 4;\n\t\t}\n\n\t\tk++;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":175,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"150635":{"score":0.89315325,"function_name":"iot_util_convert_uuid_str","code":"iot_error_t iot_util_convert_uuid_str(struct iot_uuid* uuid, char* str, size_t max_sz)\n{\n\tchar* ref_id = \"42365732-c6db-4bc9-8945-2a7ca10d6f23\";\n\tint i, written = 0, wrt;\n\tchar pvt ='-';\n\tchar str_tmp[3];\n\n\tif (!uuid || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (max_sz \u003c (strlen(ref_id) + 1)) {\n\t\tIOT_ERROR(\"Invalid max_sz\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\t/* dump random uuid */\n\tfor (i = 0; i \u003c 16; i++) {\n\t\twrt = snprintf(str_tmp, sizeof(str_tmp),\n\t\t\t\t\"%02x\", (unsigned char)uuid-\u003eid[i]);\n\t\tif (wrt != 2) {\n\t\t\tIOT_ERROR(\"Can't convert id:%02x to str\",\n\t\t\t\t(unsigned char)uuid-\u003eid[i]);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\n\t\tmemcpy(\u0026str[written], str_tmp, wrt);\n\t\twritten += wrt;\n\n\t\tif (ref_id[written] == pvt) {\n\t\t\tstr[written] = pvt;\n\t\t\twritten++;\n\t\t}\n\t}\n\n\tstr[written] = '\\0';\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":237,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"151066":{"score":0.9115255,"function_name":"iot_util_convert_str_mac","code":"iot_error_t iot_util_convert_str_mac(char* str, struct iot_mac* mac)\n{\n\tchar* ref_addr = \"a1:b2:c3:d4:e5:f6\";\n\tint i, j = 0, k = 1;\n\tunsigned char c = 0;\n\n\tif (!mac || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (strlen(str) != strlen(ref_addr)) {\n\t\tIOT_ERROR(\"Input is not a mac string\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tfor (i = 0; i \u003c strlen(ref_addr); i++) {\n\t\tif ((i % 3) == 2) {\n\t\t\tif (str[i] == ':') {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t\t}\n\t\t} else if (_isalpha(str[i])) {\n\t\t\tswitch (str[i]) {\n\t\t\tcase 65:\n\t\t\tcase 97:\n\t\t\t\tc |= 0x0a;\n\t\t\t\tbreak;\n\t\t\tcase 66:\n\t\t\tcase 98:\n\t\t\t\tc |= 0x0b;\n\t\t\t\tbreak;\n\t\t\tcase 67:\n\t\t\tcase 99:\n\t\t\t\tc |= 0x0c;\n\t\t\t\tbreak;\n\t\t\tcase 68:\n\t\t\tcase 100:\n\t\t\t\tc |= 0x0d;\n\t\t\t\tbreak;\n\t\t\tcase 69:\n\t\t\tcase 101:\n\t\t\t\tc |= 0x0e;\n\t\t\t\tbreak;\n\t\t\tcase 70:\n\t\t\tcase 102:\n\t\t\t\tc |= 0x0f;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t\t}\n\t\t} else {\n\t\t\tc |= str[i] - 48;\n\t\t}\n\n\t\tif ((j + 1) * 2 == k) {\n\t\t\tmac-\u003eaddr[j++] = c;\n\t\t\tc = 0;\n\t\t} else {\n\t\t\tc = c \u003c\u003c 4;\n\t\t}\n\n\t\tk++;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":278,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"151557":{"score":0.8736094,"function_name":"iot_util_convert_mac_str","code":"iot_error_t iot_util_convert_mac_str(struct iot_mac* mac, char* str, int max_sz)\n{\n\tchar* ref_addr = \"a1:b2:c3:d4:e5:f6\";\n\tint i, written = 0, wrt;\n\tchar pvt =':';\n\tchar str_tmp[3];\n\n\tif (!mac || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (max_sz \u003c (strlen(ref_addr) + 1)) {\n\t\tIOT_ERROR(\"Invalid max_sz\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tfor (i = 0; i \u003c 6; i++) {\n\t\twrt = snprintf(str_tmp, sizeof(str_tmp),\n\t\t\t\t\"%02x\", (unsigned char)mac-\u003eaddr[i]);\n\t\tif (wrt != 2) {\n\t\t\tIOT_ERROR(\"Can't convert mac_addr:%02x to str\",\n\t\t\t\t(unsigned char)mac-\u003eaddr[i]);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\n\t\tmemcpy(\u0026str[written], str_tmp, wrt);\n\t\twritten += wrt;\n\n\t\tif (ref_addr[written] == pvt) {\n\t\t\tstr[written] = pvt;\n\t\t\twritten++;\n\t\t}\n\t}\n\n\tstr[written] = '\\0';\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":347,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"152157":{"score":0.90435994,"function_name":"iot_util_url_parse","code":"iot_error_t iot_util_url_parse(char *url, url_parse_t *output)\n{\n\tchar *p1 = NULL;\n\tchar *p2 = NULL;\n\tchar *p_domain = NULL;\n\tchar *p_port = NULL;\n\n\tif (!url || !output)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tp1 = strstr(url, \"://\");\n\tif (!p1)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tp_domain = p1 + 3;\n\tp2 = strstr(p_domain, \":\");\n\tif (!p2)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tp_port = p2 + 1;\n\toutput-\u003eprotocol = iot_os_calloc(sizeof(char), p1 - url + 1);\n\tif (!output-\u003eprotocol)\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\tstrncpy(output-\u003eprotocol, url, p1 - url);\n\n\toutput-\u003edomain = iot_os_calloc(sizeof(char), p2 - p_domain + 1);\n\tif (!output-\u003edomain) {\n\t\tfree(output-\u003eprotocol);\n\t\toutput-\u003eprotocol = NULL;\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tstrncpy(output-\u003edomain, p_domain, p2 - p_domain);\n\n\toutput-\u003eport = atoi(p_port);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":407,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"152686":{"score":0.91688395,"function_name":"case_insensitive_strcmp","code":"static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)\n{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}","filepath":"cJSON.c","line_number":104,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"152867":{"score":0.8715311,"function_name":"cJSON_strdup","code":"static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)\n{\n    size_t length = 0;\n    unsigned char *copy = NULL;\n\n    if (string == NULL)\n    {\n        return NULL;\n    }\n\n    length = strlen((const char*)string) + sizeof(\"\");\n    copy = (unsigned char*)hooks-\u003eallocate(length);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    memcpy(copy, string, length);\n\n    return copy;\n}","filepath":"cJSON.c","line_number":159,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"152992":{"score":0.8407258,"function_name":"cJSON_InitHooks","code":"CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (hooks == NULL)\n    {\n        /* Reset hooks */\n        global_hooks.allocate = malloc;\n        global_hooks.deallocate = free;\n        global_hooks.reallocate = realloc;\n        return;\n    }\n\n    global_hooks.allocate = malloc;\n    if (hooks-\u003emalloc_fn != NULL)\n    {\n        global_hooks.allocate = hooks-\u003emalloc_fn;\n    }\n\n    global_hooks.deallocate = free;\n    if (hooks-\u003efree_fn != NULL)\n    {\n        global_hooks.deallocate = hooks-\u003efree_fn;\n    }\n\n    /* use realloc only if both free and malloc are used */\n    global_hooks.reallocate = NULL;\n    if ((global_hooks.allocate == malloc) \u0026\u0026 (global_hooks.deallocate == free))\n    {\n        global_hooks.reallocate = realloc;\n    }\n}","filepath":"cJSON.c","line_number":180,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"153171":{"score":0.8144394,"function_name":"cJSON_New_Item","code":"static cJSON *cJSON_New_Item(const internal_hooks * const hooks)\n{\n    cJSON* node = (cJSON*)hooks-\u003eallocate(sizeof(cJSON));\n    if (node)\n    {\n        memset(node, '\\0', sizeof(cJSON));\n    }\n\n    return node;\n}","filepath":"cJSON.c","line_number":212,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"153239":{"score":0.8594532,"function_name":"cJSON_Delete","code":"CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item-\u003enext;\n        if (!(item-\u003etype \u0026 cJSON_IsReference) \u0026\u0026 (item-\u003echild != NULL))\n        {\n            cJSON_Delete(item-\u003echild);\n        }\n        if (!(item-\u003etype \u0026 cJSON_IsReference) \u0026\u0026 (item-\u003evaluestring != NULL))\n        {\n            global_hooks.deallocate(item-\u003evaluestring);\n        }\n        if (!(item-\u003etype \u0026 cJSON_StringIsConst) \u0026\u0026 (item-\u003estring != NULL))\n        {\n            global_hooks.deallocate(item-\u003estring);\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}","filepath":"cJSON.c","line_number":224,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"153471":{"score":0.9079222,"function_name":"parse_number","code":"static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)\n{\n    double number = 0;\n    unsigned char *after_end = NULL;\n    unsigned char number_c_string[64];\n    unsigned char decimal_point = get_decimal_point();\n    size_t i = 0;\n\n    if ((input_buffer == NULL) || (input_buffer-\u003econtent == NULL))\n    {\n        return false;\n    }\n\n    /* copy the number into a temporary buffer and replace '.' with the decimal point\n     * of the current locale (for strtod)\n     * This also takes care of '\\0' not necessarily being available for marking the end of the input */\n    for (i = 0; (i \u003c (sizeof(number_c_string) - 1)) \u0026\u0026 can_access_at_index(input_buffer, i); i++)\n    {\n        switch (buffer_at_offset(input_buffer)[i])\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case '+':\n            case '-':\n            case 'e':\n            case 'E':\n                number_c_string[i] = buffer_at_offset(input_buffer)[i];\n                break;\n\n            case '.':\n                number_c_string[i] = decimal_point;\n                break;\n\n            default:\n                goto loop_end;\n        }\n    }\nloop_end:\n    number_c_string[i] = '\\0';\n\n    number = strtod((const char*)number_c_string, (char**)\u0026after_end);\n    if (number_c_string == after_end)\n    {\n        return false; /* parse_error */\n    }\n\n    item-\u003evaluedouble = number;\n\n    /* use saturation in case of overflow */\n    if (number \u003e= INT_MAX)\n    {\n        item-\u003evalueint = INT_MAX;\n    }\n    else if (number \u003c= (double)INT_MIN)\n    {\n        item-\u003evalueint = INT_MIN;\n    }\n    else\n    {\n        item-\u003evalueint = (int)number;\n    }\n\n    item-\u003etype = cJSON_Number;\n\n    input_buffer-\u003eoffset += (size_t)(after_end - number_c_string);\n    return true;\n}","filepath":"cJSON.c","line_number":276,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"153928":{"score":0.8054744,"function_name":"cJSON_SetNumberHelper","code":"CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)\n{\n    if (number \u003e= INT_MAX)\n    {\n        object-\u003evalueint = INT_MAX;\n    }\n    else if (number \u003c= (double)INT_MIN)\n    {\n        object-\u003evalueint = INT_MIN;\n    }\n    else\n    {\n        object-\u003evalueint = (int)number;\n    }\n\n    return object-\u003evaluedouble = number;\n}","filepath":"cJSON.c","line_number":353,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"154062":{"score":0.86709803,"function_name":"ensure","code":"static unsigned char* ensure(printbuffer * const p, size_t needed)\n{\n    unsigned char *newbuffer = NULL;\n    size_t newsize = 0;\n\n    if ((p == NULL) || (p-\u003ebuffer == NULL))\n    {\n        return NULL;\n    }\n\n    if ((p-\u003elength \u003e 0) \u0026\u0026 (p-\u003eoffset \u003e= p-\u003elength))\n    {\n        /* make sure that offset is valid */\n        return NULL;\n    }\n\n    if (needed \u003e INT_MAX)\n    {\n        /* sizes bigger than INT_MAX are currently not supported */\n        return NULL;\n    }\n\n    needed += p-\u003eoffset + 1;\n    if (needed \u003c= p-\u003elength)\n    {\n        return p-\u003ebuffer + p-\u003eoffset;\n    }\n\n    if (p-\u003enoalloc) {\n        return NULL;\n    }\n\n    /* calculate new buffer size */\n    if (needed \u003e (INT_MAX / 2))\n    {\n        /* overflow of int, use INT_MAX if possible */\n        if (needed \u003c= INT_MAX)\n        {\n            newsize = INT_MAX;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        newsize = needed * 2;\n    }\n\n    if (p-\u003ehooks.reallocate != NULL)\n    {\n        /* reallocate with realloc if available */\n        newbuffer = (unsigned char*)p-\u003ehooks.reallocate(p-\u003ebuffer, newsize);\n        if (newbuffer == NULL)\n        {\n            p-\u003ehooks.deallocate(p-\u003ebuffer);\n            p-\u003elength = 0;\n            p-\u003ebuffer = NULL;\n\n            return NULL;\n        }\n    }\n    else\n    {\n        /* otherwise reallocate manually */\n        newbuffer = (unsigned char*)p-\u003ehooks.allocate(newsize);\n        if (!newbuffer)\n        {\n            p-\u003ehooks.deallocate(p-\u003ebuffer);\n            p-\u003elength = 0;\n            p-\u003ebuffer = NULL;\n\n            return NULL;\n        }\n        if (newbuffer)\n        {\n            memcpy(newbuffer, p-\u003ebuffer, p-\u003eoffset + 1);\n        }\n        p-\u003ehooks.deallocate(p-\u003ebuffer);\n    }\n    p-\u003elength = newsize;\n    p-\u003ebuffer = newbuffer;\n\n    return newbuffer + p-\u003eoffset;\n}","filepath":"cJSON.c","line_number":383,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"154537":{"score":0.89414907,"function_name":"update_offset","code":"static void update_offset(printbuffer * const buffer)\n{\n    const unsigned char *buffer_pointer = NULL;\n    if ((buffer == NULL) || (buffer-\u003ebuffer == NULL))\n    {\n        return;\n    }\n    buffer_pointer = buffer-\u003ebuffer + buffer-\u003eoffset;\n\n    buffer-\u003eoffset += strlen((const char*)buffer_pointer);\n}","filepath":"cJSON.c","line_number":471,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"154634":{"score":0.8473538,"function_name":"print_number","code":"static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    double d = item-\u003evaluedouble;\n    int length = 0;\n    size_t i = 0;\n    unsigned char number_buffer[26]; /* temporary buffer to print the number into */\n    unsigned char decimal_point = get_decimal_point();\n    double test;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* This checks for NaN and Infinity */\n    if ((d * 0) != 0)\n    {\n        length = sprintf((char*)number_buffer, \"null\");\n    }\n    else\n    {\n        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n        length = sprintf((char*)number_buffer, \"%1.15g\", d);\n\n        /* Check whether the original double can be recovered */\n        if ((sscanf((char*)number_buffer, \"%lg\", \u0026test) != 1) || ((double)test != d))\n        {\n            /* If not, print with 17 decimal places of precision */\n            length = sprintf((char*)number_buffer, \"%1.17g\", d);\n        }\n    }\n\n    /* sprintf failed or buffer overrun occurred */\n    if ((length \u003c 0) || (length \u003e (int)(sizeof(number_buffer) - 1)))\n    {\n        return false;\n    }\n\n    /* reserve appropriate space in the output */\n    output_pointer = ensure(output_buffer, (size_t)length + sizeof(\"\"));\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    /* copy the printed number to the output and replace locale\n     * dependent decimal point with '.' */\n    for (i = 0; i \u003c ((size_t)length); i++)\n    {\n        if (number_buffer[i] == decimal_point)\n        {\n            output_pointer[i] = '.';\n            continue;\n        }\n\n        output_pointer[i] = number_buffer[i];\n    }\n    output_pointer[i] = '\\0';\n\n    output_buffer-\u003eoffset += (size_t)length;\n\n    return true;\n}","filepath":"cJSON.c","line_number":484,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"155071":{"score":0.77944434,"function_name":"parse_hex4","code":"static unsigned parse_hex4(const unsigned char * const input)\n{\n    unsigned int h = 0;\n    size_t i = 0;\n\n    for (i = 0; i \u003c 4; i++)\n    {\n        /* parse digit */\n        if ((input[i] \u003e= '0') \u0026\u0026 (input[i] \u003c= '9'))\n        {\n            h += (unsigned int) input[i] - '0';\n        }\n        else if ((input[i] \u003e= 'A') \u0026\u0026 (input[i] \u003c= 'F'))\n        {\n            h += (unsigned int) 10 + input[i] - 'A';\n        }\n        else if ((input[i] \u003e= 'a') \u0026\u0026 (input[i] \u003c= 'f'))\n        {\n            h += (unsigned int) 10 + input[i] - 'a';\n        }\n        else /* invalid */\n        {\n            return 0;\n        }\n\n        if (i \u003c 3)\n        {\n            /* shift left to make place for the next nibble */\n            h = h \u003c\u003c 4;\n        }\n    }\n\n    return h;\n}","filepath":"cJSON.c","line_number":550,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"155320":{"score":0.8986313,"function_name":"utf16_literal_to_utf8","code":"static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)\n{\n    long unsigned int codepoint = 0;\n    unsigned int first_code = 0;\n    const unsigned char *first_sequence = input_pointer;\n    unsigned char utf8_length = 0;\n    unsigned char utf8_position = 0;\n    unsigned char sequence_length = 0;\n    unsigned char first_byte_mark = 0;\n\n    if ((input_end - first_sequence) \u003c 6)\n    {\n        /* input ends unexpectedly */\n        goto fail;\n    }\n\n    /* get the first utf16 sequence */\n    first_code = parse_hex4(first_sequence + 2);\n\n    /* check that the code is valid */\n    if (((first_code \u003e= 0xDC00) \u0026\u0026 (first_code \u003c= 0xDFFF)))\n    {\n        goto fail;\n    }\n\n    /* UTF16 surrogate pair */\n    if ((first_code \u003e= 0xD800) \u0026\u0026 (first_code \u003c= 0xDBFF))\n    {\n        const unsigned char *second_sequence = first_sequence + 6;\n        unsigned int second_code = 0;\n        sequence_length = 12; /* \\uXXXX\\uXXXX */\n\n        if ((input_end - second_sequence) \u003c 6)\n        {\n            /* input ends unexpectedly */\n            goto fail;\n        }\n\n        if ((second_sequence[0] != '\\\\') || (second_sequence[1] != 'u'))\n        {\n            /* missing second half of the surrogate pair */\n            goto fail;\n        }\n\n        /* get the second utf16 sequence */\n        second_code = parse_hex4(second_sequence + 2);\n        /* check that the code is valid */\n        if ((second_code \u003c 0xDC00) || (second_code \u003e 0xDFFF))\n        {\n            /* invalid second half of the surrogate pair */\n            goto fail;\n        }\n\n\n        /* calculate the unicode codepoint from the surrogate pair */\n        codepoint = 0x10000 + (((first_code \u0026 0x3FF) \u003c\u003c 10) | (second_code \u0026 0x3FF));\n    }\n    else\n    {\n        sequence_length = 6; /* \\uXXXX */\n        codepoint = first_code;\n    }\n\n    /* encode as UTF-8\n     * takes at maximum 4 bytes to encode:\n     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n    if (codepoint \u003c 0x80)\n    {\n        /* normal ascii, encoding 0xxxxxxx */\n        utf8_length = 1;\n    }\n    else if (codepoint \u003c 0x800)\n    {\n        /* two bytes, encoding 110xxxxx 10xxxxxx */\n        utf8_length = 2;\n        first_byte_mark = 0xC0; /* 11000000 */\n    }\n    else if (codepoint \u003c 0x10000)\n    {\n        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 3;\n        first_byte_mark = 0xE0; /* 11100000 */\n    }\n    else if (codepoint \u003c= 0x10FFFF)\n    {\n        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 4;\n        first_byte_mark = 0xF0; /* 11110000 */\n    }\n    else\n    {\n        /* invalid unicode codepoint */\n        goto fail;\n    }\n\n    /* encode as utf8 */\n    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position \u003e 0; utf8_position--)\n    {\n        /* 10xxxxxx */\n        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) \u0026 0xBF);\n        codepoint \u003e\u003e= 6;\n    }\n    /* encode first byte */\n    if (utf8_length \u003e 1)\n    {\n        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) \u0026 0xFF);\n    }\n    else\n    {\n        (*output_pointer)[0] = (unsigned char)(codepoint \u0026 0x7F);\n    }\n\n    *output_pointer += utf8_length;\n\n    return sequence_length;\n\nfail:\n    return 0;\n}","filepath":"cJSON.c","line_number":587,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"155823":{"score":0.87733334,"function_name":"parse_string","code":"static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)\n{\n    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;\n    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;\n    unsigned char *output_pointer = NULL;\n    unsigned char *output = NULL;\n\n    /* not a string */\n    if (buffer_at_offset(input_buffer)[0] != '\\\"')\n    {\n        goto fail;\n    }\n\n    {\n        /* calculate approximate size of the output (overestimate) */\n        size_t allocation_length = 0;\n        size_t skipped_bytes = 0;\n        while (((size_t)(input_end - input_buffer-\u003econtent) \u003c input_buffer-\u003elength) \u0026\u0026 (*input_end != '\\\"'))\n        {\n            /* is escape sequence */\n            if (input_end[0] == '\\\\')\n            {\n                if ((size_t)(input_end + 1 - input_buffer-\u003econtent) \u003e= input_buffer-\u003elength)\n                {\n                    /* prevent buffer overflow when last input character is a backslash */\n                    goto fail;\n                }\n                skipped_bytes++;\n                input_end++;\n            }\n            input_end++;\n        }\n        if (((size_t)(input_end - input_buffer-\u003econtent) \u003e= input_buffer-\u003elength) || (*input_end != '\\\"'))\n        {\n            goto fail; /* string ended unexpectedly */\n        }\n\n        /* This is at most how much we need for the output */\n        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;\n        output = (unsigned char*)input_buffer-\u003ehooks.allocate(allocation_length + sizeof(\"\"));\n        if (output == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n    }\n\n    output_pointer = output;\n    /* loop through the string literal */\n    while (input_pointer \u003c input_end)\n    {\n        if (*input_pointer != '\\\\')\n        {\n            *output_pointer++ = *input_pointer++;\n        }\n        /* escape sequence */\n        else\n        {\n            unsigned char sequence_length = 2;\n            if ((input_end - input_pointer) \u003c 1)\n            {\n                goto fail;\n            }\n\n            switch (input_pointer[1])\n            {\n                case 'b':\n                    *output_pointer++ = '\\b';\n                    break;\n                case 'f':\n                    *output_pointer++ = '\\f';\n                    break;\n                case 'n':\n                    *output_pointer++ = '\\n';\n                    break;\n                case 'r':\n                    *output_pointer++ = '\\r';\n                    break;\n                case 't':\n                    *output_pointer++ = '\\t';\n                    break;\n                case '\\\"':\n                case '\\\\':\n                case '/':\n                    *output_pointer++ = input_pointer[1];\n                    break;\n\n                /* UTF-16 literal */\n                case 'u':\n                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, \u0026output_pointer);\n                    if (sequence_length == 0)\n                    {\n                        /* failed to convert UTF16-literal to UTF-8 */\n                        goto fail;\n                    }\n                    break;\n\n                default:\n                    goto fail;\n            }\n            input_pointer += sequence_length;\n        }\n    }\n\n    /* zero terminate the output */\n    *output_pointer = '\\0';\n\n    item-\u003etype = cJSON_String;\n    item-\u003evaluestring = (char*)output;\n\n    input_buffer-\u003eoffset = (size_t) (input_end - input_buffer-\u003econtent);\n    input_buffer-\u003eoffset++;\n\n    return true;\n\nfail:\n    if (output != NULL)\n    {\n        input_buffer-\u003ehooks.deallocate(output);\n    }\n\n    if (input_pointer != NULL)\n    {\n        input_buffer-\u003eoffset = (size_t)(input_pointer - input_buffer-\u003econtent);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":708,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"156558":{"score":0.87302214,"function_name":"print_string_ptr","code":"static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)\n{\n    const unsigned char *input_pointer = NULL;\n    unsigned char *output = NULL;\n    unsigned char *output_pointer = NULL;\n    size_t output_length = 0;\n    /* numbers of additional characters needed for escaping */\n    size_t escape_characters = 0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* empty string */\n    if (input == NULL)\n    {\n        output = ensure(output_buffer, sizeof(\"\\\"\\\"\"));\n        if (output == NULL)\n        {\n            return false;\n        }\n        strcpy((char*)output, \"\\\"\\\"\");\n\n        return true;\n    }\n\n    /* set \"flag\" to 1 if something needs to be escaped */\n    for (input_pointer = input; *input_pointer; input_pointer++)\n    {\n        switch (*input_pointer)\n        {\n            case '\\\"':\n            case '\\\\':\n            case '\\b':\n            case '\\f':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                /* one character escape sequence */\n                escape_characters++;\n                break;\n            default:\n                if (*input_pointer \u003c 32)\n                {\n                    /* UTF-16 escape sequence uXXXX */\n                    escape_characters += 5;\n                }\n                break;\n        }\n    }\n    output_length = (size_t)(input_pointer - input) + escape_characters;\n\n    output = ensure(output_buffer, output_length + sizeof(\"\\\"\\\"\"));\n    if (output == NULL)\n    {\n        return false;\n    }\n\n    /* no characters have to be escaped */\n    if (escape_characters == 0)\n    {\n        output[0] = '\\\"';\n        memcpy(output + 1, input, output_length);\n        output[output_length + 1] = '\\\"';\n        output[output_length + 2] = '\\0';\n\n        return true;\n    }\n\n    output[0] = '\\\"';\n    output_pointer = output + 1;\n    /* copy the string */\n    for (input_pointer = input; *input_pointer != '\\0'; (void)input_pointer++, output_pointer++)\n    {\n        if ((*input_pointer \u003e 31) \u0026\u0026 (*input_pointer != '\\\"') \u0026\u0026 (*input_pointer != '\\\\'))\n        {\n            /* normal character, copy */\n            *output_pointer = *input_pointer;\n        }\n        else\n        {\n            /* character needs to be escaped */\n            *output_pointer++ = '\\\\';\n            switch (*input_pointer)\n            {\n                case '\\\\':\n                    *output_pointer = '\\\\';\n                    break;\n                case '\\\"':\n                    *output_pointer = '\\\"';\n                    break;\n                case '\\b':\n                    *output_pointer = 'b';\n                    break;\n                case '\\f':\n                    *output_pointer = 'f';\n                    break;\n                case '\\n':\n                    *output_pointer = 'n';\n                    break;\n                case '\\r':\n                    *output_pointer = 'r';\n                    break;\n                case '\\t':\n                    *output_pointer = 't';\n                    break;\n                default:\n                    /* escape and print as unicode codepoint */\n                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n                    output_pointer += 4;\n                    break;\n            }\n        }\n    }\n    output[output_length + 1] = '\\\"';\n    output[output_length + 2] = '\\0';\n\n    return true;\n}","filepath":"cJSON.c","line_number":837,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"157234":{"score":0.85131204,"function_name":"buffer_skip_whitespace","code":"static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer-\u003econtent == NULL))\n    {\n        return NULL;\n    }\n\n    while (can_access_at_index(buffer, 0) \u0026\u0026 (buffer_at_offset(buffer)[0] \u003c= 32))\n    {\n       buffer-\u003eoffset++;\n    }\n\n    if (buffer-\u003eoffset == buffer-\u003elength)\n    {\n        buffer-\u003eoffset--;\n    }\n\n    return buffer;\n}","filepath":"cJSON.c","line_number":973,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"157362":{"score":0.85496265,"function_name":"skip_utf8_bom","code":"static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer-\u003econtent == NULL) || (buffer-\u003eoffset != 0))\n    {\n        return NULL;\n    }\n\n    if (can_access_at_index(buffer, 4) \u0026\u0026 (strncmp((const char*)buffer_at_offset(buffer), \"\\xEF\\xBB\\xBF\", 3) == 0))\n    {\n        buffer-\u003eoffset += 3;\n    }\n\n    return buffer;\n}","filepath":"cJSON.c","line_number":994,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"157499":{"score":0.8187636,"function_name":"cJSON_ParseWithOpts","code":"CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    cJSON *item = NULL;\n\n    /* reset error position */\n    global_error.json = NULL;\n    global_error.position = 0;\n\n    if (value == NULL)\n    {\n        goto fail;\n    }\n\n    buffer.content = (const unsigned char*)value;\n    buffer.length = strlen((const char*)value) + sizeof(\"\");\n    buffer.offset = 0;\n    buffer.hooks = global_hooks;\n\n    item = cJSON_New_Item(\u0026global_hooks);\n    if (item == NULL) /* memory fail */\n    {\n        goto fail;\n    }\n\n    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(\u0026buffer))))\n    {\n        /* parse failure. ep is set. */\n        goto fail;\n    }\n\n    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n    if (require_null_terminated)\n    {\n        buffer_skip_whitespace(\u0026buffer);\n        if ((buffer.offset \u003e= buffer.length) || buffer_at_offset(\u0026buffer)[0] != '\\0')\n        {\n            goto fail;\n        }\n    }\n    if (return_parse_end)\n    {\n        *return_parse_end = (const char*)buffer_at_offset(\u0026buffer);\n    }\n\n    return item;\n\nfail:\n    if (item != NULL)\n    {\n        cJSON_Delete(item);\n    }\n\n    if (value != NULL)\n    {\n        error local_error;\n        local_error.json = (const unsigned char*)value;\n        local_error.position = 0;\n\n        if (buffer.offset \u003c buffer.length)\n        {\n            local_error.position = buffer.offset;\n        }\n        else if (buffer.length \u003e 0)\n        {\n            local_error.position = buffer.length - 1;\n        }\n\n        if (return_parse_end != NULL)\n        {\n            *return_parse_end = (const char*)local_error.json + local_error.position;\n        }\n\n        global_error = local_error;\n    }\n\n    return NULL;\n}","filepath":"cJSON.c","line_number":1010,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"157994":{"score":0.7210201,"function_name":"print","code":"static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\n{\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char *printed = NULL;\n\n    memset(buffer, 0, sizeof(buffer));\n\n    /* create buffer */\n    buffer-\u003ebuffer = (unsigned char*) hooks-\u003eallocate(default_buffer_size);\n    buffer-\u003elength = default_buffer_size;\n    buffer-\u003eformat = format;\n    buffer-\u003ehooks = *hooks;\n    if (buffer-\u003ebuffer == NULL)\n    {\n        goto fail;\n    }\n\n    /* print the value */\n    if (!print_value(item, buffer))\n    {\n        goto fail;\n    }\n    update_offset(buffer);\n\n    /* check if reallocate is available */\n    if (hooks-\u003ereallocate != NULL)\n    {\n        printed = (unsigned char*) hooks-\u003ereallocate(buffer-\u003ebuffer, buffer-\u003eoffset + 1);\n        if (printed == NULL) {\n            goto fail;\n        }\n        buffer-\u003ebuffer = NULL;\n    }\n    else /* otherwise copy the JSON over to a new buffer */\n    {\n        printed = (unsigned char*) hooks-\u003eallocate(buffer-\u003eoffset + 1);\n        if (printed == NULL)\n        {\n            goto fail;\n        }\n        memcpy(printed, buffer-\u003ebuffer, cjson_min(buffer-\u003elength, buffer-\u003eoffset + 1));\n        printed[buffer-\u003eoffset] = '\\0'; /* just to be sure */\n\n        /* free the buffer */\n        hooks-\u003edeallocate(buffer-\u003ebuffer);\n    }\n\n    return printed;\n\nfail:\n    if (buffer-\u003ebuffer != NULL)\n    {\n        hooks-\u003edeallocate(buffer-\u003ebuffer);\n    }\n\n    if (printed != NULL)\n    {\n        hooks-\u003edeallocate(printed);\n    }\n\n    return NULL;\n}","filepath":"cJSON.c","line_number":1097,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"158487":{"score":0.7251576,"function_name":"cJSON_PrintBuffered","code":"CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if (prebuffer \u003c 0)\n    {\n        return NULL;\n    }\n\n    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);\n    if (!p.buffer)\n    {\n        return NULL;\n    }\n\n    p.length = (size_t)prebuffer;\n    p.offset = 0;\n    p.noalloc = false;\n    p.format = fmt;\n    p.hooks = global_hooks;\n\n    if (!print_value(item, \u0026p))\n    {\n        global_hooks.deallocate(p.buffer);\n        return NULL;\n    }\n\n    return (char*)p.buffer;\n}","filepath":"cJSON.c","line_number":1172,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"158718":{"score":0.71838987,"function_name":"cJSON_PrintPreallocated","code":"CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if ((len \u003c 0) || (buf == NULL))\n    {\n        return false;\n    }\n\n    p.buffer = (unsigned char*)buf;\n    p.length = (size_t)len;\n    p.offset = 0;\n    p.noalloc = true;\n    p.format = fmt;\n    p.hooks = global_hooks;\n\n    return print_value(item, \u0026p);\n}","filepath":"cJSON.c","line_number":1202,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"158897":{"score":0.92332506,"function_name":"parse_value","code":"static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer-\u003econtent == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) \u0026\u0026 (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item-\u003etype = cJSON_NULL;\n        input_buffer-\u003eoffset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) \u0026\u0026 (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item-\u003etype = cJSON_False;\n        input_buffer-\u003eoffset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) \u0026\u0026 (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item-\u003etype = cJSON_True;\n        item-\u003evalueint = 1;\n        input_buffer-\u003eoffset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] \u003e= '0') \u0026\u0026 (buffer_at_offset(input_buffer)[0] \u003c= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":1222,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"159541":{"score":0.87113404,"function_name":"print_value","code":"static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item-\u003etype) \u0026 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item-\u003evaluestring == NULL)\n            {\n                return false;\n            }\n\n            raw_length = strlen(item-\u003evaluestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item-\u003evaluestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}","filepath":"cJSON.c","line_number":1277,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"160068":{"score":0.8893682,"function_name":"parse_array","code":"static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* head of the linked list */\n    cJSON *current_item = NULL;\n\n    if (input_buffer-\u003edepth \u003e= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer-\u003edepth++;\n\n    if (buffer_at_offset(input_buffer)[0] != '[')\n    {\n        /* not an array */\n        goto fail;\n    }\n\n    input_buffer-\u003eoffset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == ']'))\n    {\n        /* empty array */\n        goto success;\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer-\u003eoffset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer-\u003eoffset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(\u0026(input_buffer-\u003ehooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item-\u003enext = new_item;\n            new_item-\u003eprev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse next value */\n        input_buffer-\u003eoffset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')\n    {\n        goto fail; /* expected end of array */\n    }\n\nsuccess:\n    input_buffer-\u003edepth--;\n\n    item-\u003etype = cJSON_Array;\n    item-\u003echild = head;\n\n    input_buffer-\u003eoffset++;\n\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":1351,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"160615":{"score":0.9198282,"function_name":"print_array","code":"static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_element = item-\u003echild;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output array. */\n    /* opening square bracket */\n    output_pointer = ensure(output_buffer, 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer = '[';\n    output_buffer-\u003eoffset++;\n    output_buffer-\u003edepth++;\n\n    while (current_element != NULL)\n    {\n        if (!print_value(current_element, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n        if (current_element-\u003enext)\n        {\n            length = (size_t) (output_buffer-\u003eformat ? 2 : 1);\n            output_pointer = ensure(output_buffer, length + 1);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            *output_pointer++ = ',';\n            if(output_buffer-\u003eformat)\n            {\n                *output_pointer++ = ' ';\n            }\n            *output_pointer = '\\0';\n            output_buffer-\u003eoffset += length;\n        }\n        current_element = current_element-\u003enext;\n    }\n\n    output_pointer = ensure(output_buffer, 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    *output_pointer++ = ']';\n    *output_pointer = '\\0';\n    output_buffer-\u003edepth--;\n\n    return true;\n}","filepath":"cJSON.c","line_number":1445,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"161012":{"score":0.88390523,"function_name":"parse_object","code":"static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* linked list head */\n    cJSON *current_item = NULL;\n\n    if (input_buffer-\u003edepth \u003e= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer-\u003edepth++;\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))\n    {\n        goto fail; /* not an object */\n    }\n\n    input_buffer-\u003eoffset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '}'))\n    {\n        goto success; /* empty object */\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer-\u003eoffset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer-\u003eoffset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(\u0026(input_buffer-\u003ehooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item-\u003enext = new_item;\n            new_item-\u003eprev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse the name of the child */\n        input_buffer-\u003eoffset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_string(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse name */\n        }\n        buffer_skip_whitespace(input_buffer);\n\n        /* swap valuestring and string, because we parsed the name */\n        current_item-\u003estring = current_item-\u003evaluestring;\n        current_item-\u003evaluestring = NULL;\n\n        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))\n        {\n            goto fail; /* invalid object */\n        }\n\n        /* parse the value */\n        input_buffer-\u003eoffset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))\n    {\n        goto fail; /* expected end of object */\n    }\n\nsuccess:\n    input_buffer-\u003edepth--;\n\n    item-\u003etype = cJSON_Object;\n    item-\u003echild = head;\n\n    input_buffer-\u003eoffset++;\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":1507,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"161733":{"score":0.89245164,"function_name":"print_object","code":"static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_item = item-\u003echild;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output: */\n    length = (size_t) (output_buffer-\u003eformat ? 2 : 1); /* fmt: {\\n */\n    output_pointer = ensure(output_buffer, length + 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer++ = '{';\n    output_buffer-\u003edepth++;\n    if (output_buffer-\u003eformat)\n    {\n        *output_pointer++ = '\\n';\n    }\n    output_buffer-\u003eoffset += length;\n\n    while (current_item)\n    {\n        if (output_buffer-\u003eformat)\n        {\n            size_t i;\n            output_pointer = ensure(output_buffer, output_buffer-\u003edepth);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            for (i = 0; i \u003c output_buffer-\u003edepth; i++)\n            {\n                *output_pointer++ = '\\t';\n            }\n            output_buffer-\u003eoffset += output_buffer-\u003edepth;\n        }\n\n        /* print key */\n        if (!print_string_ptr((unsigned char*)current_item-\u003estring, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        length = (size_t) (output_buffer-\u003eformat ? 2 : 1);\n        output_pointer = ensure(output_buffer, length);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        *output_pointer++ = ':';\n        if (output_buffer-\u003eformat)\n        {\n            *output_pointer++ = '\\t';\n        }\n        output_buffer-\u003eoffset += length;\n\n        /* print value */\n        if (!print_value(current_item, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        /* print comma if not last */\n        length = ((size_t)(output_buffer-\u003eformat ? 1 : 0) + (size_t)(current_item-\u003enext ? 1 : 0));\n        output_pointer = ensure(output_buffer, length + 1);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        if (current_item-\u003enext)\n        {\n            *output_pointer++ = ',';\n        }\n\n        if (output_buffer-\u003eformat)\n        {\n            *output_pointer++ = '\\n';\n        }\n        *output_pointer = '\\0';\n        output_buffer-\u003eoffset += length;\n\n        current_item = current_item-\u003enext;\n    }\n\n    output_pointer = ensure(output_buffer, output_buffer-\u003eformat ? (output_buffer-\u003edepth + 1) : 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    if (output_buffer-\u003eformat)\n    {\n        size_t i;\n        for (i = 0; i \u003c (output_buffer-\u003edepth - 1); i++)\n        {\n            *output_pointer++ = '\\t';\n        }\n    }\n    *output_pointer++ = '}';\n    *output_pointer = '\\0';\n    output_buffer-\u003edepth--;\n\n    return true;\n}","filepath":"cJSON.c","line_number":1616,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"162554":{"score":0.9115236,"function_name":"cJSON_GetArraySize","code":"CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)\n{\n    cJSON *child = NULL;\n    size_t size = 0;\n\n    if (array == NULL)\n    {\n        return 0;\n    }\n\n    child = array-\u003echild;\n\n    while(child != NULL)\n    {\n        size++;\n        child = child-\u003enext;\n    }\n\n    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */\n\n    return (int)size;\n}","filepath":"cJSON.c","line_number":1730,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"162631":{"score":0.90228873,"function_name":"get_array_item","code":"static cJSON* get_array_item(const cJSON *array, size_t index)\n{\n    cJSON *current_child = NULL;\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    current_child = array-\u003echild;\n    while ((current_child != NULL) \u0026\u0026 (index \u003e 0))\n    {\n        index--;\n        current_child = current_child-\u003enext;\n    }\n\n    return current_child;\n}","filepath":"cJSON.c","line_number":1753,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"162707":{"score":0.8122542,"function_name":"cJSON_GetArrayItem","code":"CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)\n{\n    if (index \u003c 0)\n    {\n        return NULL;\n    }\n\n    return get_array_item(array, (size_t)index);\n}","filepath":"cJSON.c","line_number":1772,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"162750":{"score":0.919239,"function_name":"get_object_item","code":"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object-\u003echild;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) \u0026\u0026 (current_element-\u003estring != NULL) \u0026\u0026 (strcmp(name, current_element-\u003estring) != 0))\n        {\n            current_element = current_element-\u003enext;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) \u0026\u0026 (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element-\u003estring)) != 0))\n        {\n            current_element = current_element-\u003enext;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element-\u003estring == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}","filepath":"cJSON.c","line_number":1782,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"163085":{"score":0.8784143,"function_name":"create_reference","code":"static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)\n{\n    cJSON *reference = NULL;\n    if (item == NULL)\n    {\n        return NULL;\n    }\n\n    reference = cJSON_New_Item(hooks);\n    if (reference == NULL)\n    {\n        return NULL;\n    }\n\n    memcpy(reference, item, sizeof(cJSON));\n    reference-\u003estring = NULL;\n    reference-\u003etype |= cJSON_IsReference;\n    reference-\u003enext = reference-\u003eprev = NULL;\n    return reference;\n}","filepath":"cJSON.c","line_number":1837,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"163228":{"score":0.9466037,"function_name":"add_item_to_array","code":"static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)\n{\n    cJSON *child = NULL;\n\n    if ((item == NULL) || (array == NULL))\n    {\n        return false;\n    }\n\n    child = array-\u003echild;\n\n    if (child == NULL)\n    {\n        /* list is empty, start new one */\n        array-\u003echild = item;\n    }\n    else\n    {\n        /* append to the end */\n        while (child-\u003enext)\n        {\n            child = child-\u003enext;\n        }\n        suffix_object(child, item);\n    }\n\n    return true;\n}","filepath":"cJSON.c","line_number":1858,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"163382":{"score":0.85033345,"function_name":"add_item_to_object","code":"static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)\n{\n    char *new_key = NULL;\n    int new_type = cJSON_Invalid;\n\n    if ((object == NULL) || (string == NULL) || (item == NULL))\n    {\n        return false;\n    }\n\n    if (constant_key)\n    {\n        new_key = (char*)cast_away_const(string);\n        new_type = item-\u003etype | cJSON_StringIsConst;\n    }\n    else\n    {\n        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if (new_key == NULL)\n        {\n            return false;\n        }\n\n        new_type = item-\u003etype \u0026 ~cJSON_StringIsConst;\n    }\n\n    if (!(item-\u003etype \u0026 cJSON_StringIsConst) \u0026\u0026 (item-\u003estring != NULL))\n    {\n        hooks-\u003edeallocate(item-\u003estring);\n    }\n\n    item-\u003estring = new_key;\n    item-\u003etype = new_type;\n\n    return add_item_to_array(object, item);\n}","filepath":"cJSON.c","line_number":1909,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"163698":{"score":0.6744135,"function_name":"cJSON_AddItemReferenceToArray","code":"CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\n{\n    if (array == NULL)\n    {\n        return;\n    }\n\n    add_item_to_array(array, create_reference(item, \u0026global_hooks));\n}","filepath":"cJSON.c","line_number":1957,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"163761":{"score":0.7435209,"function_name":"cJSON_AddItemReferenceToObject","code":"CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)\n{\n    if ((object == NULL) || (string == NULL))\n    {\n        return;\n    }\n\n    add_item_to_object(object, string, create_reference(item, \u0026global_hooks), \u0026global_hooks, false);\n}","filepath":"cJSON.c","line_number":1967,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"163849":{"score":0.7824553,"function_name":"cJSON_AddArrayToObject","code":"CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)\n{\n    cJSON *array = cJSON_CreateArray();\n    if (add_item_to_object(object, name, array, \u0026global_hooks, false))\n    {\n        return array;\n    }\n\n    cJSON_Delete(array);\n    return NULL;\n}","filepath":"cJSON.c","line_number":2073,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"164210":{"score":0.6942172,"function_name":"cJSON_AddNumberToObject","code":"CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)\n{\n    cJSON *number_item = cJSON_CreateNumber(number);\n    if (add_item_to_object(object, name, number_item, \u0026global_hooks, false))\n    {\n        return number_item;\n    }\n\n    cJSON_Delete(number_item);\n    return NULL;\n}","filepath":"lib/sbi/openapi/external/cJSON.c","line_number":2147,"entry_url":"https://github.com/open5gs/open5gs.git","slot_name":"v2.4.6"},"164322":{"score":0.7726185,"function_name":"cJSON_AddNumberToObject","code":"CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)\n{\n    cJSON *number_item = cJSON_CreateNumber(number);\n    if (add_item_to_object(object, name, number_item, \u0026global_hooks, false))\n    {\n        return number_item;\n    }\n\n    cJSON_Delete(number_item);\n    return NULL;\n}","filepath":"cJSON.c","line_number":2025,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"164692":{"score":0.8935774,"function_name":"cJSON_DetachItemViaPointer","code":"CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)\n{\n    if ((parent == NULL) || (item == NULL))\n    {\n        return NULL;\n    }\n\n    if (item-\u003eprev != NULL)\n    {\n        /* not the first element */\n        item-\u003eprev-\u003enext = item-\u003enext;\n    }\n    if (item-\u003enext != NULL)\n    {\n        /* not the last element */\n        item-\u003enext-\u003eprev = item-\u003eprev;\n    }\n\n    if (item == parent-\u003echild)\n    {\n        /* first element */\n        parent-\u003echild = item-\u003enext;\n    }\n    /* make sure the detached item doesn't point anywhere anymore */\n    item-\u003eprev = NULL;\n    item-\u003enext = NULL;\n\n    return item;\n}","filepath":"cJSON.c","line_number":2085,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"164816":{"score":0.7854918,"function_name":"cJSON_DetachItemFromArray","code":"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)\n{\n    if (which \u003c 0)\n    {\n        return NULL;\n    }\n\n    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));\n}","filepath":"cJSON.c","line_number":2115,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165122":{"score":0.8300251,"function_name":"cJSON_InsertItemInArray","code":"CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    cJSON *after_inserted = NULL;\n\n    if (which \u003c 0)\n    {\n        return;\n    }\n\n    after_inserted = get_array_item(array, (size_t)which);\n    if (after_inserted == NULL)\n    {\n        add_item_to_array(array, newitem);\n        return;\n    }\n\n    newitem-\u003enext = after_inserted;\n    newitem-\u003eprev = after_inserted-\u003eprev;\n    after_inserted-\u003eprev = newitem;\n    if (after_inserted == array-\u003echild)\n    {\n        array-\u003echild = newitem;\n    }\n    else\n    {\n        newitem-\u003eprev-\u003enext = newitem;\n    }\n}","filepath":"cJSON.c","line_number":2155,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165258":{"score":0.9413879,"function_name":"cJSON_ReplaceItemViaPointer","code":"CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)\n{\n    if ((parent == NULL) || (replacement == NULL) || (item == NULL))\n    {\n        return false;\n    }\n\n    if (replacement == item)\n    {\n        return true;\n    }\n\n    replacement-\u003enext = item-\u003enext;\n    replacement-\u003eprev = item-\u003eprev;\n\n    if (replacement-\u003enext != NULL)\n    {\n        replacement-\u003enext-\u003eprev = replacement;\n    }\n    if (replacement-\u003eprev != NULL)\n    {\n        replacement-\u003eprev-\u003enext = replacement;\n    }\n    if (parent-\u003echild == item)\n    {\n        parent-\u003echild = replacement;\n    }\n\n    item-\u003enext = NULL;\n    item-\u003eprev = NULL;\n    cJSON_Delete(item);\n\n    return true;\n}","filepath":"cJSON.c","line_number":2184,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165440":{"score":0.7471672,"function_name":"cJSON_ReplaceItemInArray","code":"CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    if (which \u003c 0)\n    {\n        return;\n    }\n\n    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);\n}","filepath":"cJSON.c","line_number":2219,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165500":{"score":0.7909435,"function_name":"replace_item_in_object","code":"static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)\n{\n    if ((replacement == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    /* replace the name in the replacement */\n    if (!(replacement-\u003etype \u0026 cJSON_StringIsConst) \u0026\u0026 (replacement-\u003estring != NULL))\n    {\n        cJSON_free(replacement-\u003estring);\n    }\n    replacement-\u003estring = (char*)cJSON_strdup((const unsigned char*)string, \u0026global_hooks);\n    replacement-\u003etype \u0026= ~cJSON_StringIsConst;\n\n    cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);\n\n    return true;\n}","filepath":"cJSON.c","line_number":2229,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165753":{"score":0.83219266,"function_name":"cJSON_CreateArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype=cJSON_Array;\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2397,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165869":{"score":0.8130732,"function_name":"cJSON_CreateTrue","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = cJSON_True;\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2271,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165927":{"score":0.7568871,"function_name":"cJSON_CreateBool","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = b ? cJSON_True : cJSON_False;\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2293,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"165999":{"score":0.72135836,"function_name":"cJSON_CreateNumber","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = cJSON_Number;\n        item-\u003evaluedouble = num;\n\n        /* use saturation in case of overflow */\n        if (num \u003e= INT_MAX)\n        {\n            item-\u003evalueint = INT_MAX;\n        }\n        else if (num \u003c= (double)INT_MIN)\n        {\n            item-\u003evalueint = INT_MIN;\n        }\n        else\n        {\n            item-\u003evalueint = (int)num;\n        }\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2304,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"166172":{"score":0.8103857,"function_name":"cJSON_CreateString","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = cJSON_String;\n        item-\u003evaluestring = (char*)cJSON_strdup((const unsigned char*)string, \u0026global_hooks);\n        if(!item-\u003evaluestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2330,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"166295":{"score":0.66853094,"function_name":"cJSON_CreateObjectReference","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if (item != NULL) {\n        item-\u003etype = cJSON_Object | cJSON_IsReference;\n        item-\u003echild = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2359,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"166535":{"score":0.76454926,"function_name":"cJSON_CreateString","code":"cJSON *cJSON_CreateString(const char *string)\n{\n    cJSON *item = cJSON_New_Item();\n    if(item)\n    {\n        item-\u003etype = cJSON_String;\n        item-\u003evaluestring = (char*)cJSON_strdup((const unsigned char*)string);\n        if(!item-\u003evaluestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}","filepath":"lib/cJSON.c","line_number":2103,"entry_url":"https://github.com/OpenSIPS/opensips.git","slot_name":"2.3.3"},"166658":{"score":0.8010484,"function_name":"cJSON_CreateArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype=cJSON_Array;\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2093,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.5.1"},"166774":{"score":0.8236933,"function_name":"cJSON_CreateFloatArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count \u003c 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a \u0026\u0026 (i \u003c (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber((double)numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a-\u003echild = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}","filepath":"cJSON.c","line_number":2455,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"166995":{"score":0.8131335,"function_name":"cJSON_CreateFloatArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count \u003c 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a \u0026\u0026 (i \u003c (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber((double)numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a-\u003echild = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}","filepath":"libapp2sys/src/main/cpp/cjson/cJSON.c","line_number":2449,"entry_url":"https://github.com/Tencent/Hardcoder.git","slot_name":"1.0.0"},"167417":{"score":0.8100052,"function_name":"cJSON_CreateIntArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count \u003c 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n    for(i = 0; a \u0026\u0026 (i \u003c (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a-\u003echild = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}","filepath":"cJSON.c","line_number":2420,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"167622":{"score":0.8399094,"function_name":"cJSON_Duplicate","code":"CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)\n{\n    cJSON *newitem = NULL;\n    cJSON *child = NULL;\n    cJSON *next = NULL;\n    cJSON *newchild = NULL;\n\n    /* Bail on bad ptr */\n    if (!item)\n    {\n        goto fail;\n    }\n    /* Create new item */\n    newitem = cJSON_New_Item(\u0026global_hooks);\n    if (!newitem)\n    {\n        goto fail;\n    }\n    /* Copy over all vars */\n    newitem-\u003etype = item-\u003etype \u0026 (~cJSON_IsReference);\n    newitem-\u003evalueint = item-\u003evalueint;\n    newitem-\u003evaluedouble = item-\u003evaluedouble;\n    if (item-\u003evaluestring)\n    {\n        newitem-\u003evaluestring = (char*)cJSON_strdup((unsigned char*)item-\u003evaluestring, \u0026global_hooks);\n        if (!newitem-\u003evaluestring)\n        {\n            goto fail;\n        }\n    }\n    if (item-\u003estring)\n    {\n        newitem-\u003estring = (item-\u003etype\u0026cJSON_StringIsConst) ? item-\u003estring : (char*)cJSON_strdup((unsigned char*)item-\u003estring, \u0026global_hooks);\n        if (!newitem-\u003estring)\n        {\n            goto fail;\n        }\n    }\n    /* If non-recursive, then we're done! */\n    if (!recurse)\n    {\n        return newitem;\n    }\n    /* Walk the -\u003enext chain for the child. */\n    child = item-\u003echild;\n    while (child != NULL)\n    {\n        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the -\u003enext chain */\n        if (!newchild)\n        {\n            goto fail;\n        }\n        if (next != NULL)\n        {\n            /* If newitem-\u003echild already set, then crosswire -\u003eprev and -\u003enext and move on */\n            next-\u003enext = newchild;\n            newchild-\u003eprev = next;\n            next = newchild;\n        }\n        else\n        {\n            /* Set newitem-\u003echild and move to it */\n            newitem-\u003echild = newchild;\n            next = newchild;\n        }\n        child = child-\u003enext;\n    }\n\n    return newitem;\n\nfail:\n    if (newitem != NULL)\n    {\n        cJSON_Delete(newitem);\n    }\n\n    return NULL;\n}","filepath":"cJSON.c","line_number":2564,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"168039":{"score":0.8635447,"function_name":"skip_oneline_comment","code":"static void skip_oneline_comment(char **input)\n{\n    *input += static_strlen(\"//\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if ((*input)[0] == '\\n') {\n            *input += static_strlen(\"\\n\");\n            return;\n        }\n    }\n}","filepath":"cJSON.c","line_number":2643,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"168121":{"score":0.89575344,"function_name":"skip_multiline_comment","code":"static void skip_multiline_comment(char **input)\n{\n    *input += static_strlen(\"/*\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if (((*input)[0] == '*') \u0026\u0026 ((*input)[1] == '/'))\n        {\n            *input += static_strlen(\"*/\");\n            return;\n        }\n    }\n}","filepath":"cJSON.c","line_number":2656,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"168218":{"score":0.93097323,"function_name":"minify_string","code":"static void minify_string(char **input, char **output) {\n    (*output)[0] = (*input)[0];\n    *input += static_strlen(\"\\\"\");\n    *output += static_strlen(\"\\\"\");\n\n\n    for (; (*input)[0] != '\\0'; (void)++(*input), ++(*output)) {\n        (*output)[0] = (*input)[0];\n\n        if ((*input)[0] == '\\\"') {\n            (*output)[0] = '\\\"';\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n            return;\n        } else if (((*input)[0] == '\\\\') \u0026\u0026 ((*input)[1] == '\\\"')) {\n            (*output)[1] = (*input)[1];\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n        }\n    }\n}","filepath":"cJSON.c","line_number":2670,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"168456":{"score":0.9195979,"function_name":"cJSON_Minify","code":"CJSON_PUBLIC(void) cJSON_Minify(char *json)\n{\n    char *into = json;\n\n    if (json == NULL)\n    {\n        return;\n    }\n\n    while (json[0] != '\\0')\n    {\n        switch (json[0])\n        {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                json++;\n                break;\n\n            case '/':\n                if (json[1] == '/')\n                {\n                    skip_oneline_comment(\u0026json);\n                }\n                else if (json[1] == '*')\n                {\n                    skip_multiline_comment(\u0026json);\n                } else {\n                    json++;\n                }\n                break;\n\n            case '\\\"':\n                minify_string(\u0026json, (char**)\u0026into);\n                break;\n\n            default:\n                into[0] = json[0];\n                json++;\n                into++;\n        }\n    }\n\n    /* and null-terminate. */\n    *into = '\\0';\n}","filepath":"cJSON.c","line_number":2692,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"168712":{"score":0.8218732,"function_name":"cJSON_IsBool","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 (cJSON_True | cJSON_False)) != 0;\n}","filepath":"cJSON.c","line_number":2771,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"168894":{"score":0.880243,"function_name":"cJSON_IsNumber","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 0xFF) == cJSON_Number;\n}","filepath":"cJSON.c","line_number":2790,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"168940":{"score":0.879413,"function_name":"cJSON_IsArray","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 0xFF) == cJSON_Array;\n}","filepath":"cJSON.c","line_number":2810,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"169078":{"score":0.8367982,"function_name":"cJSON_IsInvalid","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 0xFF) == cJSON_Invalid;\n}","filepath":"cJSON.c","line_number":2740,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"169172":{"score":0.8380008,"function_name":"cJSON_Compare","code":"CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)\n{\n    if ((a == NULL) || (b == NULL) || ((a-\u003etype \u0026 0xFF) != (b-\u003etype \u0026 0xFF)) || cJSON_IsInvalid(a))\n    {\n        return false;\n    }\n\n    /* check if type is valid */\n    switch (a-\u003etype \u0026 0xFF)\n    {\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n        case cJSON_Number:\n        case cJSON_String:\n        case cJSON_Raw:\n        case cJSON_Array:\n        case cJSON_Object:\n            break;\n\n        default:\n            return false;\n    }\n\n    /* identical objects are equal */\n    if (a == b)\n    {\n        return true;\n    }\n\n    switch (a-\u003etype \u0026 0xFF)\n    {\n        /* in these cases and equal type is enough */\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n            return true;\n\n        case cJSON_Number:\n            if (a-\u003evaluedouble == b-\u003evaluedouble)\n            {\n                return true;\n            }\n            return false;\n\n        case cJSON_String:\n        case cJSON_Raw:\n            if ((a-\u003evaluestring == NULL) || (b-\u003evaluestring == NULL))\n            {\n                return false;\n            }\n            if (strcmp(a-\u003evaluestring, b-\u003evaluestring) == 0)\n            {\n                return true;\n            }\n\n            return false;\n\n        case cJSON_Array:\n        {\n            cJSON *a_element = a-\u003echild;\n            cJSON *b_element = b-\u003echild;\n\n            for (; (a_element != NULL) \u0026\u0026 (b_element != NULL);)\n            {\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n\n                a_element = a_element-\u003enext;\n                b_element = b_element-\u003enext;\n            }\n\n            /* one of the arrays is longer than the other */\n            if (a_element != b_element) {\n                return false;\n            }\n\n            return true;\n        }\n\n        case cJSON_Object:\n        {\n            cJSON *a_element = NULL;\n            cJSON *b_element = NULL;\n            cJSON_ArrayForEach(a_element, a)\n            {\n                /* TODO This has O(n^2) runtime, which is horrible! */\n                b_element = get_object_item(b, a_element-\u003estring, case_sensitive);\n                if (b_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            /* doing this twice, once on a and b to prevent true comparison if a subset of b\n             * TODO: Do this the proper way, this is just a fix for now */\n            cJSON_ArrayForEach(b_element, b)\n            {\n                a_element = get_object_item(a, b_element-\u003estring, case_sensitive);\n                if (a_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(b_element, a_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}","filepath":"cJSON.c","line_number":2840,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.12"},"170047":{"score":0.7885138,"function_name":"mbedtls_ctr_drbg_seed_entropy_len","code":"int mbedtls_ctr_drbg_seed_entropy_len(\n                   mbedtls_ctr_drbg_context *ctx,\n                   int (*f_entropy)(void *, unsigned char *, size_t),\n                   void *p_entropy,\n                   const unsigned char *custom,\n                   size_t len,\n                   size_t entropy_len )\n{\n    int ret;\n    unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];\n\n    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );\n\n    mbedtls_aes_init( \u0026ctx-\u003eaes_ctx );\n\n    ctx-\u003ef_entropy = f_entropy;\n    ctx-\u003ep_entropy = p_entropy;\n\n    ctx-\u003eentropy_len = entropy_len;\n    ctx-\u003ereseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;\n\n    /*\n     * Initialize with an empty key\n     */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026ctx-\u003eaes_ctx, key, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = mbedtls_ctr_drbg_reseed( ctx, custom, len ) ) != 0 )\n    {\n        return( ret );\n    }\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":81,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"170328":{"score":0.74308634,"function_name":"mbedtls_ctr_drbg_free","code":"void mbedtls_ctr_drbg_free( mbedtls_ctr_drbg_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_free( \u0026ctx-\u003emutex );\n#endif\n    mbedtls_aes_free( \u0026ctx-\u003eaes_ctx );\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ctr_drbg_context ) );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":127,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"170472":{"score":0.89816445,"function_name":"block_cipher_df","code":"static int block_cipher_df( unsigned char *output,\n                            const unsigned char *data, size_t data_len )\n{\n    unsigned char buf[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT + MBEDTLS_CTR_DRBG_BLOCKSIZE + 16];\n    unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];\n    unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];\n    unsigned char chain[MBEDTLS_CTR_DRBG_BLOCKSIZE];\n    unsigned char *p, *iv;\n    mbedtls_aes_context aes_ctx;\n    int ret = 0;\n\n    int i, j;\n    size_t buf_len, use_len;\n\n    if( data_len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )\n        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );\n\n    memset( buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT + MBEDTLS_CTR_DRBG_BLOCKSIZE + 16 );\n    mbedtls_aes_init( \u0026aes_ctx );\n\n    /*\n     * Construct IV (16 bytes) and S in buffer\n     * IV = Counter (in 32-bits) padded to 16 with zeroes\n     * S = Length input string (in 32-bits) || Length of output (in 32-bits) ||\n     *     data || 0x80\n     *     (Total is padded to a multiple of 16-bytes with zeroes)\n     */\n    p = buf + MBEDTLS_CTR_DRBG_BLOCKSIZE;\n    *p++ = ( data_len \u003e\u003e 24 ) \u0026 0xff;\n    *p++ = ( data_len \u003e\u003e 16 ) \u0026 0xff;\n    *p++ = ( data_len \u003e\u003e 8  ) \u0026 0xff;\n    *p++ = ( data_len       ) \u0026 0xff;\n    p += 3;\n    *p++ = MBEDTLS_CTR_DRBG_SEEDLEN;\n    memcpy( p, data, data_len );\n    p[data_len] = 0x80;\n\n    buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;\n\n    for( i = 0; i \u003c MBEDTLS_CTR_DRBG_KEYSIZE; i++ )\n        key[i] = i;\n\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026aes_ctx, key, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n    {\n        goto exit;\n    }\n\n    /*\n     * Reduce data to MBEDTLS_CTR_DRBG_SEEDLEN bytes of data\n     */\n    for( j = 0; j \u003c MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )\n    {\n        p = buf;\n        memset( chain, 0, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n        use_len = buf_len;\n\n        while( use_len \u003e 0 )\n        {\n            for( i = 0; i \u003c MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )\n                chain[i] ^= p[i];\n            p += MBEDTLS_CTR_DRBG_BLOCKSIZE;\n            use_len -= ( use_len \u003e= MBEDTLS_CTR_DRBG_BLOCKSIZE ) ?\n                       MBEDTLS_CTR_DRBG_BLOCKSIZE : use_len;\n\n            if( ( ret = mbedtls_aes_crypt_ecb( \u0026aes_ctx, MBEDTLS_AES_ENCRYPT, chain, chain ) ) != 0 )\n            {\n                goto exit;\n            }\n        }\n\n        memcpy( tmp + j, chain, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n\n        /*\n         * Update IV\n         */\n        buf[3]++;\n    }\n\n    /*\n     * Do final encryption with reduced data\n     */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026aes_ctx, tmp, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n    {\n        goto exit;\n    }\n    iv = tmp + MBEDTLS_CTR_DRBG_KEYSIZE;\n    p = output;\n\n    for( j = 0; j \u003c MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )\n    {\n        if( ( ret = mbedtls_aes_crypt_ecb( \u0026aes_ctx, MBEDTLS_AES_ENCRYPT, iv, iv ) ) != 0 )\n        {\n            goto exit;\n        }\n        memcpy( p, iv, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n        p += MBEDTLS_CTR_DRBG_BLOCKSIZE;\n    }\nexit:\n    mbedtls_aes_free( \u0026aes_ctx );\n    /*\n    * tidy up the stack\n    */\n    mbedtls_platform_zeroize( buf, sizeof( buf ) );\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    mbedtls_platform_zeroize( key, sizeof( key ) );\n    mbedtls_platform_zeroize( chain, sizeof( chain ) );\n    if( 0 != ret )\n    {\n        /*\n        * wipe partial seed from memory\n        */\n        mbedtls_platform_zeroize( output, MBEDTLS_CTR_DRBG_SEEDLEN );\n    }\n\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":154,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"171563":{"score":0.8036061,"function_name":"ctr_drbg_update_internal","code":"static int ctr_drbg_update_internal( mbedtls_ctr_drbg_context *ctx,\n                              const unsigned char data[MBEDTLS_CTR_DRBG_SEEDLEN] )\n{\n    unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];\n    unsigned char *p = tmp;\n    int i, j;\n    int ret = 0;\n\n    memset( tmp, 0, MBEDTLS_CTR_DRBG_SEEDLEN );\n\n    for( j = 0; j \u003c MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )\n    {\n        /*\n         * Increase counter\n         */\n        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i \u003e 0; i-- )\n            if( ++ctx-\u003ecounter[i - 1] != 0 )\n                break;\n\n        /*\n         * Crypt counter block\n         */\n        if( ( ret = mbedtls_aes_crypt_ecb( \u0026ctx-\u003eaes_ctx, MBEDTLS_AES_ENCRYPT, ctx-\u003ecounter, p ) ) != 0 )\n            goto exit;\n\n        p += MBEDTLS_CTR_DRBG_BLOCKSIZE;\n    }\n\n    for( i = 0; i \u003c MBEDTLS_CTR_DRBG_SEEDLEN; i++ )\n        tmp[i] ^= data[i];\n\n    /*\n     * Update key and counter\n     */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026ctx-\u003eaes_ctx, tmp, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n        goto exit;\n    memcpy( ctx-\u003ecounter, tmp + MBEDTLS_CTR_DRBG_KEYSIZE, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n\nexit:\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":279,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"171912":{"score":0.78714263,"function_name":"mbedtls_ctr_drbg_update_ret","code":"int mbedtls_ctr_drbg_update_ret( mbedtls_ctr_drbg_context *ctx,\n                                 const unsigned char *additional,\n                                 size_t add_len )\n{\n    unsigned char add_input[MBEDTLS_CTR_DRBG_SEEDLEN];\n    int ret;\n\n    if( add_len == 0 )\n        return( 0 );\n\n    if( ( ret = block_cipher_df( add_input, additional, add_len ) ) != 0 )\n        goto exit;\n    if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_platform_zeroize( add_input, sizeof( add_input ) );\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":334,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"172066":{"score":0.70682627,"function_name":"mbedtls_ctr_drbg_update","code":"void mbedtls_ctr_drbg_update( mbedtls_ctr_drbg_context *ctx,\n                              const unsigned char *additional,\n                              size_t add_len )\n{\n    /* MAX_INPUT would be more logical here, but we have to match\n     * block_cipher_df()'s limits since we can't propagate errors */\n    if( add_len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )\n        add_len = MBEDTLS_CTR_DRBG_MAX_SEED_INPUT;\n    (void) mbedtls_ctr_drbg_update_ret( ctx, additional, add_len );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":355,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"172121":{"score":0.9126336,"function_name":"mbedtls_ctr_drbg_reseed","code":"int mbedtls_ctr_drbg_reseed( mbedtls_ctr_drbg_context *ctx,\n                     const unsigned char *additional, size_t len )\n{\n    unsigned char seed[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT];\n    size_t seedlen = 0;\n    int ret;\n\n    if( ctx-\u003eentropy_len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT ||\n        len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx-\u003eentropy_len )\n        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );\n\n    memset( seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT );\n\n    /*\n     * Gather entropy_len bytes of entropy to seed state\n     */\n    if( 0 != ctx-\u003ef_entropy( ctx-\u003ep_entropy, seed,\n                             ctx-\u003eentropy_len ) )\n    {\n        return( MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED );\n    }\n\n    seedlen += ctx-\u003eentropy_len;\n\n    /*\n     * Add additional data\n     */\n    if( additional \u0026\u0026 len )\n    {\n        memcpy( seed + seedlen, additional, len );\n        seedlen += len;\n    }\n\n    /*\n     * Reduce to 384 bits\n     */\n    if( ( ret = block_cipher_df( seed, seed, seedlen ) ) != 0 )\n        goto exit;\n\n    /*\n     * Update state\n     */\n    if( ( ret = ctr_drbg_update_internal( ctx, seed ) ) != 0 )\n        goto exit;\n    ctx-\u003ereseed_counter = 1;\n\nexit:\n    mbedtls_platform_zeroize( seed, sizeof( seed ) );\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":379,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"172548":{"score":0.8834628,"function_name":"mbedtls_ctr_drbg_random_with_add","code":"int mbedtls_ctr_drbg_random_with_add( void *p_rng,\n                              unsigned char *output, size_t output_len,\n                              const unsigned char *additional, size_t add_len )\n{\n    int ret = 0;\n    mbedtls_ctr_drbg_context *ctx = (mbedtls_ctr_drbg_context *) p_rng;\n    unsigned char add_input[MBEDTLS_CTR_DRBG_SEEDLEN];\n    unsigned char *p = output;\n    unsigned char tmp[MBEDTLS_CTR_DRBG_BLOCKSIZE];\n    int i;\n    size_t use_len;\n\n    if( output_len \u003e MBEDTLS_CTR_DRBG_MAX_REQUEST )\n        return( MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG );\n\n    if( add_len \u003e MBEDTLS_CTR_DRBG_MAX_INPUT )\n        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );\n\n    memset( add_input, 0, MBEDTLS_CTR_DRBG_SEEDLEN );\n\n    if( ctx-\u003ereseed_counter \u003e ctx-\u003ereseed_interval ||\n        ctx-\u003eprediction_resistance )\n    {\n        if( ( ret = mbedtls_ctr_drbg_reseed( ctx, additional, add_len ) ) != 0 )\n        {\n            return( ret );\n        }\n        add_len = 0;\n    }\n\n    if( add_len \u003e 0 )\n    {\n        if( ( ret = block_cipher_df( add_input, additional, add_len ) ) != 0 )\n            goto exit;\n        if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )\n            goto exit;\n    }\n\n    while( output_len \u003e 0 )\n    {\n        /*\n         * Increase counter\n         */\n        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i \u003e 0; i-- )\n            if( ++ctx-\u003ecounter[i - 1] != 0 )\n                break;\n\n        /*\n         * Crypt counter block\n         */\n        if( ( ret = mbedtls_aes_crypt_ecb( \u0026ctx-\u003eaes_ctx, MBEDTLS_AES_ENCRYPT, ctx-\u003ecounter, tmp ) ) != 0 )\n            goto exit;\n\n        use_len = ( output_len \u003e MBEDTLS_CTR_DRBG_BLOCKSIZE ) ? MBEDTLS_CTR_DRBG_BLOCKSIZE :\n                                                       output_len;\n        /*\n         * Copy random block to destination\n         */\n        memcpy( p, tmp, use_len );\n        p += use_len;\n        output_len -= use_len;\n    }\n\n    if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )\n        goto exit;\n\n    ctx-\u003ereseed_counter++;\n\nexit:\n    mbedtls_platform_zeroize( add_input, sizeof( add_input ) );\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ctr_drbg.c","line_number":449,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"173138":{"score":0.77087474,"function_name":"mbedtls_entropy_init","code":"void mbedtls_entropy_init( mbedtls_entropy_context *ctx )\n{\n    ctx-\u003esource_count = 0;\n    memset( ctx-\u003esource, 0, sizeof( ctx-\u003esource ) );\n\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_init( \u0026ctx-\u003emutex );\n#endif\n\n    ctx-\u003eaccumulator_started = 0;\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n    mbedtls_sha512_init( \u0026ctx-\u003eaccumulator );\n#else\n    mbedtls_sha256_init( \u0026ctx-\u003eaccumulator );\n#endif\n#if defined(MBEDTLS_HAVEGE_C)\n    mbedtls_havege_init( \u0026ctx-\u003ehavege_data );\n#endif\n\n    /* Reminder: Update ENTROPY_HAVE_STRONG in the test files\n     *           when adding more strong entropy sources here. */\n\n#if defined(MBEDTLS_TEST_NULL_ENTROPY)\n    mbedtls_entropy_add_source( ctx, mbedtls_null_entropy_poll, NULL,\n                                1, MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n\n#if !defined(MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES)\n#if !defined(MBEDTLS_NO_PLATFORM_ENTROPY)\n    mbedtls_entropy_add_source( ctx, mbedtls_platform_entropy_poll, NULL,\n                                MBEDTLS_ENTROPY_MIN_PLATFORM,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n#if defined(MBEDTLS_TIMING_C)\n    mbedtls_entropy_add_source( ctx, mbedtls_hardclock_poll, NULL,\n                                MBEDTLS_ENTROPY_MIN_HARDCLOCK,\n                                MBEDTLS_ENTROPY_SOURCE_WEAK );\n#endif\n#if defined(MBEDTLS_HAVEGE_C)\n    mbedtls_entropy_add_source( ctx, mbedtls_havege_poll, \u0026ctx-\u003ehavege_data,\n                                MBEDTLS_ENTROPY_MIN_HAVEGE,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n#if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)\n    mbedtls_entropy_add_source( ctx, mbedtls_hardware_poll, NULL,\n                                MBEDTLS_ENTROPY_MIN_HARDWARE,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n#if defined(MBEDTLS_ENTROPY_NV_SEED)\n    mbedtls_entropy_add_source( ctx, mbedtls_nv_seed_poll, NULL,\n                                MBEDTLS_ENTROPY_BLOCK_SIZE,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n    ctx-\u003einitial_entropy_run = 0;\n#endif\n#endif /* MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES */\n}","filepath":"library/entropy.c","line_number":94,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.7.19"},"173256":{"score":0.74750406,"function_name":"mbedtls_entropy_free","code":"void mbedtls_entropy_free( mbedtls_entropy_context *ctx )\n{\n#if defined(MBEDTLS_HAVEGE_C)\n    mbedtls_havege_free( \u0026ctx-\u003ehavege_data );\n#endif\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_free( \u0026ctx-\u003emutex );\n#endif\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n    mbedtls_sha512_free( \u0026ctx-\u003eaccumulator );\n#else\n    mbedtls_sha256_free( \u0026ctx-\u003eaccumulator );\n#endif\n#if defined(MBEDTLS_ENTROPY_NV_SEED)\n    ctx-\u003einitial_entropy_run = 0;\n#endif\n    ctx-\u003esource_count = 0;\n    mbedtls_platform_zeroize( ctx-\u003esource, sizeof( ctx-\u003esource ) );\n    ctx-\u003eaccumulator_started = 0;\n}","filepath":"library/entropy.c","line_number":149,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"173345":{"score":0.7920846,"function_name":"mbedtls_entropy_add_source","code":"int mbedtls_entropy_add_source( mbedtls_entropy_context *ctx,\n                        mbedtls_entropy_f_source_ptr f_source, void *p_source,\n                        size_t threshold, int strong )\n{\n    int index, ret = 0;\n\n#if defined(MBEDTLS_THREADING_C)\n    if( ( ret = mbedtls_mutex_lock( \u0026ctx-\u003emutex ) ) != 0 )\n        return( ret );\n#endif\n\n    index = ctx-\u003esource_count;\n    if( index \u003e= MBEDTLS_ENTROPY_MAX_SOURCES )\n    {\n        ret = MBEDTLS_ERR_ENTROPY_MAX_SOURCES;\n        goto exit;\n    }\n\n    ctx-\u003esource[index].f_source  = f_source;\n    ctx-\u003esource[index].p_source  = p_source;\n    ctx-\u003esource[index].threshold = threshold;\n    ctx-\u003esource[index].strong    = strong;\n\n    ctx-\u003esource_count++;\n\nexit:\n#if defined(MBEDTLS_THREADING_C)\n    if( mbedtls_mutex_unlock( \u0026ctx-\u003emutex ) != 0 )\n        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );\n#endif\n\n    return( ret );\n}","filepath":"ext/mbedtls/library/entropy.c","line_number":113,"entry_url":"https://github.com/PowerDNS/pdns.git","slot_name":"dnsdist-1.0.0-alpha1"},"173540":{"score":0.76385516,"function_name":"entropy_update","code":"static int entropy_update( mbedtls_entropy_context *ctx, unsigned char source_id,\n                           const unsigned char *data, size_t len )\n{\n    unsigned char header[2];\n    unsigned char tmp[MBEDTLS_ENTROPY_BLOCK_SIZE];\n    size_t use_len = len;\n    const unsigned char *p = data;\n    int ret = 0;\n\n    if( use_len \u003e MBEDTLS_ENTROPY_BLOCK_SIZE )\n    {\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n        if( ( ret = mbedtls_sha512( data, len, tmp, 0 ) ) != 0 )\n            goto cleanup;\n#else\n        if( ( ret = mbedtls_sha256( data, len, tmp, 0 ) ) != 0 )\n            goto cleanup;\n#endif\n        p = tmp;\n        use_len = MBEDTLS_ENTROPY_BLOCK_SIZE;\n    }\n\n    header[0] = source_id;\n    header[1] = use_len \u0026 0xFF;\n\n    /*\n     * Start the accumulator if this has not already happened. Note that\n     * it is sufficient to start the accumulator here only because all calls to\n     * gather entropy eventually execute this code.\n     */\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n    if( ctx-\u003eaccumulator_started == 0 \u0026\u0026\n        ( ret = mbedtls_sha512_starts( \u0026ctx-\u003eaccumulator, 0 ) ) != 0 )\n        goto cleanup;\n    else\n        ctx-\u003eaccumulator_started = 1;\n    if( ( ret = mbedtls_sha512_update( \u0026ctx-\u003eaccumulator, header, 2 ) ) != 0 )\n        goto cleanup;\n    ret = mbedtls_sha512_update( \u0026ctx-\u003eaccumulator, p, use_len );\n#else\n    if( ctx-\u003eaccumulator_started == 0 \u0026\u0026\n        ( ret = mbedtls_sha256_starts( \u0026ctx-\u003eaccumulator, 0 ) ) != 0 )\n        goto cleanup;\n    else\n        ctx-\u003eaccumulator_started = 1;\n    if( ( ret = mbedtls_sha256_update( \u0026ctx-\u003eaccumulator, header, 2 ) ) != 0 )\n        goto cleanup;\n    ret = mbedtls_sha256_update( \u0026ctx-\u003eaccumulator, p, use_len );\n#endif\n\ncleanup:\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n\n    return( ret );\n}","filepath":"library/entropy.c","line_number":150,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"173874":{"score":0.90621567,"function_name":"entropy_gather_internal","code":"static int entropy_gather_internal( mbedtls_entropy_context *ctx )\n{\n    int ret, i, have_one_strong = 0;\n    unsigned char buf[MBEDTLS_ENTROPY_MAX_GATHER];\n    size_t olen;\n\n    if( ctx-\u003esource_count == 0 )\n        return( MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED );\n\n    /*\n     * Run through our entropy sources\n     */\n    for( i = 0; i \u003c ctx-\u003esource_count; i++ )\n    {\n        if( ctx-\u003esource[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )\n            have_one_strong = 1;\n\n        olen = 0;\n        if( ( ret = ctx-\u003esource[i].f_source( ctx-\u003esource[i].p_source,\n                        buf, MBEDTLS_ENTROPY_MAX_GATHER, \u0026olen ) ) != 0 )\n        {\n            return( ret );\n        }\n\n        /*\n         * Add if we actually gathered something\n         */\n        if( olen \u003e 0 )\n        {\n            entropy_update( ctx, (unsigned char) i, buf, olen );\n            ctx-\u003esource[i].size += olen;\n        }\n    }\n\n    if( have_one_strong == 0 )\n        return( MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE );\n\n    return( 0 );\n}","filepath":"ext/mbedtls/library/entropy.c","line_number":206,"entry_url":"https://github.com/PowerDNS/pdns.git","slot_name":"dnsdist-1.0.0-alpha1"},"174425":{"score":0.76900685,"function_name":"mbedtls_entropy_func","code":"int mbedtls_entropy_func( void *data, unsigned char *output, size_t len )\n{\n    int ret, count = 0, i, done;\n    mbedtls_entropy_context *ctx = (mbedtls_entropy_context *) data;\n    unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];\n\n    if( len \u003e MBEDTLS_ENTROPY_BLOCK_SIZE )\n        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );\n\n#if defined(MBEDTLS_THREADING_C)\n    if( ( ret = mbedtls_mutex_lock( \u0026ctx-\u003emutex ) ) != 0 )\n        return( ret );\n#endif\n\n    /*\n     * Always gather extra entropy before a call\n     */\n    do\n    {\n        if( count++ \u003e ENTROPY_MAX_LOOP )\n        {\n            ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;\n            goto exit;\n        }\n\n        if( ( ret = entropy_gather_internal( ctx ) ) != 0 )\n            goto exit;\n\n        done = 1;\n        for( i = 0; i \u003c ctx-\u003esource_count; i++ )\n            if( ctx-\u003esource[i].size \u003c ctx-\u003esource[i].threshold )\n                done = 0;\n    }\n    while( ! done );\n\n    memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );\n\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n    mbedtls_sha512_finish( \u0026ctx-\u003eaccumulator, buf );\n\n    /*\n     * Reset accumulator and counters and recycle existing entropy\n     */\n    memset( \u0026ctx-\u003eaccumulator, 0, sizeof( mbedtls_sha512_context ) );\n    mbedtls_sha512_starts( \u0026ctx-\u003eaccumulator, 0 );\n    mbedtls_sha512_update( \u0026ctx-\u003eaccumulator, buf, MBEDTLS_ENTROPY_BLOCK_SIZE );\n\n    /*\n     * Perform second SHA-512 on entropy\n     */\n    mbedtls_sha512( buf, MBEDTLS_ENTROPY_BLOCK_SIZE, buf, 0 );\n#else /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */\n    mbedtls_sha256_finish( \u0026ctx-\u003eaccumulator, buf );\n\n    /*\n     * Reset accumulator and counters and recycle existing entropy\n     */\n    memset( \u0026ctx-\u003eaccumulator, 0, sizeof( mbedtls_sha256_context ) );\n    mbedtls_sha256_starts( \u0026ctx-\u003eaccumulator, 0 );\n    mbedtls_sha256_update( \u0026ctx-\u003eaccumulator, buf, MBEDTLS_ENTROPY_BLOCK_SIZE );\n\n    /*\n     * Perform second SHA-256 on entropy\n     */\n    mbedtls_sha256( buf, MBEDTLS_ENTROPY_BLOCK_SIZE, buf, 0 );\n#endif /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */\n\n    for( i = 0; i \u003c ctx-\u003esource_count; i++ )\n        ctx-\u003esource[i].size = 0;\n\n    memcpy( output, buf, len );\n\n    ret = 0;\n\nexit:\n#if defined(MBEDTLS_THREADING_C)\n    if( mbedtls_mutex_unlock( \u0026ctx-\u003emutex ) != 0 )\n        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );\n#endif\n\n    return( ret );\n}","filepath":"ext/mbedtls/library/entropy.c","line_number":268,"entry_url":"https://github.com/PowerDNS/pdns.git","slot_name":"dnsdist-1.0.0-alpha1"},"175030":{"score":0.9011865,"function_name":"mbedtls_platform_entropy_poll","code":"int mbedtls_platform_entropy_poll( void *data,\n                           unsigned char *output, size_t len, size_t *olen )\n{\n    FILE *file;\n    size_t read_len;\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    ((void) data);\n\n#if defined(HAVE_GETRANDOM)\n    ret = getrandom_wrapper( output, len, 0 );\n    if( ret \u003e= 0 )\n    {\n        *olen = ret;\n        return( 0 );\n    }\n    else if( errno != ENOSYS )\n        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );\n    /* Fall through if the system call isn't known. */\n#else\n    ((void) ret);\n#endif /* HAVE_GETRANDOM */\n\n    *olen = 0;\n\n    file = fopen( \"/dev/urandom\", \"rb\" );\n    if( file == NULL )\n        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );\n\n    read_len = fread( output, 1, len, file );\n    if( read_len != len )\n    {\n        fclose( file );\n        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );\n    }\n\n    fclose( file );\n    *olen = len;\n\n    return( 0 );\n}","filepath":"library/entropy_poll.c","line_number":120,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.22.0"},"175318":{"score":0.9285383,"function_name":"mbedtls_net_connect","code":"int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host,\n                         const char *port, int proto )\n{\n    int ret;\n    struct addrinfo hints, *addr_list, *cur;\n\n    if( ( ret = net_prepare() ) != 0 )\n        return( ret );\n\n    /* Do name resolution with both IPv6 and IPv4 */\n    memset( \u0026hints, 0, sizeof( hints ) );\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;\n    hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;\n\n    if( getaddrinfo( host, port, \u0026hints, \u0026addr_list ) != 0 )\n        return( MBEDTLS_ERR_NET_UNKNOWN_HOST );\n\n    /* Try the sockaddrs until a connection succeeds */\n    ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;\n    for( cur = addr_list; cur != NULL; cur = cur-\u003eai_next )\n    {\n        ctx-\u003efd = (int) socket( cur-\u003eai_family, cur-\u003eai_socktype,\n                            cur-\u003eai_protocol );\n        if( ctx-\u003efd \u003c 0 )\n        {\n            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;\n            continue;\n        }\n\n        if( connect( ctx-\u003efd, cur-\u003eai_addr, MSVC_INT_CAST cur-\u003eai_addrlen ) == 0 )\n        {\n            ret = 0;\n            break;\n        }\n\n        close( ctx-\u003efd );\n        ret = MBEDTLS_ERR_NET_CONNECT_FAILED;\n    }\n\n    freeaddrinfo( addr_list );\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":141,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"175695":{"score":0.8903732,"function_name":"mbedtls_net_bind","code":"int mbedtls_net_bind( mbedtls_net_context *ctx, const char *bind_ip, const char *port, int proto )\n{\n    int n, ret;\n    struct addrinfo hints, *addr_list, *cur;\n\n    if( ( ret = net_prepare() ) != 0 )\n        return( ret );\n\n    /* Bind to IPv6 and/or IPv4, but only in the desired protocol */\n    memset( \u0026hints, 0, sizeof( hints ) );\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;\n    hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;\n    if( bind_ip == NULL )\n        hints.ai_flags = AI_PASSIVE;\n\n    if( getaddrinfo( bind_ip, port, \u0026hints, \u0026addr_list ) != 0 )\n        return( MBEDTLS_ERR_NET_UNKNOWN_HOST );\n\n    /* Try the sockaddrs until a binding succeeds */\n    ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;\n    for( cur = addr_list; cur != NULL; cur = cur-\u003eai_next )\n    {\n        ctx-\u003efd = (int) socket( cur-\u003eai_family, cur-\u003eai_socktype,\n                            cur-\u003eai_protocol );\n        if( ctx-\u003efd \u003c 0 )\n        {\n            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;\n            continue;\n        }\n\n        n = 1;\n        if( setsockopt( ctx-\u003efd, SOL_SOCKET, SO_REUSEADDR,\n                        (const char *) \u0026n, sizeof( n ) ) != 0 )\n        {\n            close( ctx-\u003efd );\n            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;\n            continue;\n        }\n\n        if( bind( ctx-\u003efd, cur-\u003eai_addr, MSVC_INT_CAST cur-\u003eai_addrlen ) != 0 )\n        {\n            close( ctx-\u003efd );\n            ret = MBEDTLS_ERR_NET_BIND_FAILED;\n            continue;\n        }\n\n        /* Listen only makes sense for TCP */\n        if( proto == MBEDTLS_NET_PROTO_TCP )\n        {\n            if( listen( ctx-\u003efd, MBEDTLS_NET_LISTEN_BACKLOG ) != 0 )\n            {\n                close( ctx-\u003efd );\n                ret = MBEDTLS_ERR_NET_LISTEN_FAILED;\n                continue;\n            }\n        }\n\n        /* Bind was successful */\n        ret = 0;\n        break;\n    }\n\n    freeaddrinfo( addr_list );\n\n    return( ret );\n\n}","filepath":"library/net_sockets.c","line_number":189,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"176209":{"score":0.8745035,"function_name":"net_would_block","code":"static int net_would_block( const mbedtls_net_context *ctx )\n{\n    int err = errno;\n\n    /*\n     * Never return 'WOULD BLOCK' on a non-blocking socket\n     */\n    if( ( fcntl( ctx-\u003efd, F_GETFL ) \u0026 O_NONBLOCK ) != O_NONBLOCK )\n    {\n        errno = err;\n        return( 0 );\n    }\n\n    switch( errno = err )\n    {\n#if defined EAGAIN\n        case EAGAIN:\n#endif\n#if defined EWOULDBLOCK \u0026\u0026 EWOULDBLOCK != EAGAIN\n        case EWOULDBLOCK:\n#endif\n            return( 1 );\n    }\n    return( 0 );\n}","filepath":"library/net_sockets.c","line_number":276,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"176321":{"score":0.90155125,"function_name":"mbedtls_net_accept","code":"int mbedtls_net_accept( mbedtls_net_context *bind_ctx,\n                        mbedtls_net_context *client_ctx,\n                        void *client_ip, size_t buf_size, size_t *ip_len )\n{\n    int ret;\n    int type;\n\n    struct sockaddr_storage client_addr;\n\n#if defined(__socklen_t_defined) || defined(_SOCKLEN_T) ||  \\\n    defined(_SOCKLEN_T_DECLARED) || defined(__DEFINED_socklen_t)\n    socklen_t n = (socklen_t) sizeof( client_addr );\n    socklen_t type_len = (socklen_t) sizeof( type );\n#else\n    int n = (int) sizeof( client_addr );\n    int type_len = (int) sizeof( type );\n#endif\n\n    /* Is this a TCP or UDP socket? */\n    if( getsockopt( bind_ctx-\u003efd, SOL_SOCKET, SO_TYPE,\n                    (void *) \u0026type, \u0026type_len ) != 0 ||\n        ( type != SOCK_STREAM \u0026\u0026 type != SOCK_DGRAM ) )\n    {\n        return( MBEDTLS_ERR_NET_ACCEPT_FAILED );\n    }\n\n    if( type == SOCK_STREAM )\n    {\n        /* TCP: actual accept() */\n        ret = client_ctx-\u003efd = (int) accept( bind_ctx-\u003efd,\n                                             (struct sockaddr *) \u0026client_addr, \u0026n );\n    }\n    else\n    {\n        /* UDP: wait for a message, but keep it in the queue */\n        char buf[1] = { 0 };\n\n        ret = (int) recvfrom( bind_ctx-\u003efd, buf, sizeof( buf ), MSG_PEEK,\n                        (struct sockaddr *) \u0026client_addr, \u0026n );\n\n#if defined(_WIN32)\n        if( ret == SOCKET_ERROR \u0026\u0026\n            WSAGetLastError() == WSAEMSGSIZE )\n        {\n            /* We know buf is too small, thanks, just peeking here */\n            ret = 0;\n        }\n#endif\n    }\n\n    if( ret \u003c 0 )\n    {\n        if( net_would_block( bind_ctx ) != 0 )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n\n        return( MBEDTLS_ERR_NET_ACCEPT_FAILED );\n    }\n\n    /* UDP: hijack the listening socket to communicate with the client,\n     * then bind a new socket to accept new connections */\n    if( type != SOCK_STREAM )\n    {\n        struct sockaddr_storage local_addr;\n        int one = 1;\n\n        if( connect( bind_ctx-\u003efd, (struct sockaddr *) \u0026client_addr, n ) != 0 )\n            return( MBEDTLS_ERR_NET_ACCEPT_FAILED );\n\n        client_ctx-\u003efd = bind_ctx-\u003efd;\n        bind_ctx-\u003efd   = -1; /* In case we exit early */\n\n        n = sizeof( struct sockaddr_storage );\n        if( getsockname( client_ctx-\u003efd,\n                         (struct sockaddr *) \u0026local_addr, \u0026n ) != 0 ||\n            ( bind_ctx-\u003efd = (int) socket( local_addr.ss_family,\n                                           SOCK_DGRAM, IPPROTO_UDP ) ) \u003c 0 ||\n            setsockopt( bind_ctx-\u003efd, SOL_SOCKET, SO_REUSEADDR,\n                        (const char *) \u0026one, sizeof( one ) ) != 0 )\n        {\n            return( MBEDTLS_ERR_NET_SOCKET_FAILED );\n        }\n\n        if( bind( bind_ctx-\u003efd, (struct sockaddr *) \u0026local_addr, n ) != 0 )\n        {\n            return( MBEDTLS_ERR_NET_BIND_FAILED );\n        }\n    }\n\n    if( client_ip != NULL )\n    {\n        if( client_addr.ss_family == AF_INET )\n        {\n            struct sockaddr_in *addr4 = (struct sockaddr_in *) \u0026client_addr;\n            *ip_len = sizeof( addr4-\u003esin_addr.s_addr );\n\n            if( buf_size \u003c *ip_len )\n                return( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );\n\n            memcpy( client_ip, \u0026addr4-\u003esin_addr.s_addr, *ip_len );\n        }\n        else\n        {\n            struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) \u0026client_addr;\n            *ip_len = sizeof( addr6-\u003esin6_addr.s6_addr );\n\n            if( buf_size \u003c *ip_len )\n                return( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );\n\n            memcpy( client_ip, \u0026addr6-\u003esin6_addr.s6_addr, *ip_len);\n        }\n    }\n\n    return( 0 );\n}","filepath":"library/net_sockets.c","line_number":306,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"177240":{"score":0.84613913,"function_name":"mbedtls_net_set_block","code":"int mbedtls_net_set_block( mbedtls_net_context *ctx )\n{\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n    u_long n = 0;\n    return( ioctlsocket( ctx-\u003efd, FIONBIO, \u0026n ) );\n#else\n    return( fcntl( ctx-\u003efd, F_SETFL, fcntl( ctx-\u003efd, F_GETFL ) \u0026 ~O_NONBLOCK ) );\n#endif\n}","filepath":"library/net_sockets.c","line_number":424,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"177307":{"score":0.8898783,"function_name":"mbedtls_net_poll","code":"int mbedtls_net_poll( mbedtls_net_context *ctx, uint32_t rw, uint32_t timeout )\n{\n    int ret;\n    struct timeval tv;\n\n    fd_set read_fds;\n    fd_set write_fds;\n\n    int fd = ctx-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n#if defined(__has_feature)\n#if __has_feature(memory_sanitizer)\n    /* Ensure that memory sanitizers consider read_fds and write_fds as\n     * initialized even on platforms such as Glibc/x86_64 where FD_ZERO\n     * is implemented in assembly. */\n    memset( \u0026read_fds, 0, sizeof( read_fds ) );\n    memset( \u0026write_fds, 0, sizeof( write_fds ) );\n#endif\n#endif\n\n    FD_ZERO( \u0026read_fds );\n    if( rw \u0026 MBEDTLS_NET_POLL_READ )\n    {\n        rw \u0026= ~MBEDTLS_NET_POLL_READ;\n        FD_SET( fd, \u0026read_fds );\n    }\n\n    FD_ZERO( \u0026write_fds );\n    if( rw \u0026 MBEDTLS_NET_POLL_WRITE )\n    {\n        rw \u0026= ~MBEDTLS_NET_POLL_WRITE;\n        FD_SET( fd, \u0026write_fds );\n    }\n\n    if( rw != 0 )\n        return( MBEDTLS_ERR_NET_BAD_INPUT_DATA );\n\n    tv.tv_sec  = timeout / 1000;\n    tv.tv_usec = ( timeout % 1000 ) * 1000;\n\n    do\n    {\n        ret = select( fd + 1, \u0026read_fds, \u0026write_fds, NULL,\n                      timeout == (uint32_t) -1 ? NULL : \u0026tv );\n    }\n    while( IS_EINTR( ret ) );\n\n    if( ret \u003c 0 )\n        return( MBEDTLS_ERR_NET_POLL_FAILED );\n\n    ret = 0;\n    if( FD_ISSET( fd, \u0026read_fds ) )\n        ret |= MBEDTLS_NET_POLL_READ;\n    if( FD_ISSET( fd, \u0026write_fds ) )\n        ret |= MBEDTLS_NET_POLL_WRITE;\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":450,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"177965":{"score":0.8525071,"function_name":"mbedtls_net_usleep","code":"void mbedtls_net_usleep( unsigned long usec )\n{\n#if defined(_WIN32)\n    Sleep( ( usec + 999 ) / 1000 );\n#else\n    struct timeval tv;\n    tv.tv_sec  = usec / 1000000;\n#if defined(__unix__) || defined(__unix) || \\\n    ( defined(__APPLE__) \u0026\u0026 defined(__MACH__) )\n    tv.tv_usec = (suseconds_t) usec % 1000000;\n#else\n    tv.tv_usec = usec % 1000000;\n#endif\n    select( 0, NULL, NULL, NULL, \u0026tv );\n#endif\n}","filepath":"library/net_sockets.c","line_number":515,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178095":{"score":0.8484653,"function_name":"mbedtls_net_recv","code":"int mbedtls_net_recv( void *ctx, unsigned char *buf, size_t len )\n{\n    int ret;\n    int fd = ((mbedtls_net_context *) ctx)-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n    ret = (int) read( fd, buf, len );\n\n    if( ret \u003c 0 )\n    {\n        if( net_would_block( ctx ) != 0 )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n        if( WSAGetLastError() == WSAECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n#else\n        if( errno == EPIPE || errno == ECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n\n        if( errno == EINTR )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n#endif\n\n        return( MBEDTLS_ERR_NET_RECV_FAILED );\n    }\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":535,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178253":{"score":0.8653766,"function_name":"mbedtls_net_recv_timeout","code":"int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf,\n                              size_t len, uint32_t timeout )\n{\n    int ret;\n    struct timeval tv;\n    fd_set read_fds;\n    int fd = ((mbedtls_net_context *) ctx)-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n    FD_ZERO( \u0026read_fds );\n    FD_SET( fd, \u0026read_fds );\n\n    tv.tv_sec  = timeout / 1000;\n    tv.tv_usec = ( timeout % 1000 ) * 1000;\n\n    ret = select( fd + 1, \u0026read_fds, NULL, NULL, timeout == 0 ? NULL : \u0026tv );\n\n    /* Zero fds ready means we timed out */\n    if( ret == 0 )\n        return( MBEDTLS_ERR_SSL_TIMEOUT );\n\n    if( ret \u003c 0 )\n    {\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n        if( WSAGetLastError() == WSAEINTR )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n#else\n        if( errno == EINTR )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n#endif\n\n        return( MBEDTLS_ERR_NET_RECV_FAILED );\n    }\n\n    /* This call will not block */\n    return( mbedtls_net_recv( ctx, buf, len ) );\n}","filepath":"library/net_sockets.c","line_number":571,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178666":{"score":0.8551046,"function_name":"mbedtls_net_send","code":"int mbedtls_net_send( void *ctx, const unsigned char *buf, size_t len )\n{\n    int ret;\n    int fd = ((mbedtls_net_context *) ctx)-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n    ret = (int) write( fd, buf, len );\n\n    if( ret \u003c 0 )\n    {\n        if( net_would_block( ctx ) != 0 )\n            return( MBEDTLS_ERR_SSL_WANT_WRITE );\n\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n        if( WSAGetLastError() == WSAECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n#else\n        if( errno == EPIPE || errno == ECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n\n        if( errno == EINTR )\n            return( MBEDTLS_ERR_SSL_WANT_WRITE );\n#endif\n\n        return( MBEDTLS_ERR_NET_SEND_FAILED );\n    }\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":615,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178824":{"score":0.8936182,"function_name":"mbedtls_net_free","code":"void mbedtls_net_free( mbedtls_net_context *ctx )\n{\n    if( ctx-\u003efd == -1 )\n        return;\n\n    shutdown( ctx-\u003efd, 2 );\n    close( ctx-\u003efd );\n\n    ctx-\u003efd = -1;\n}","filepath":"library/net_sockets.c","line_number":651,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178992":{"score":0.49001366,"function_name":"mbedtls_ssl_session_free","code":"void mbedtls_ssl_session_free( mbedtls_ssl_session *session )\n{\n    if( session == NULL )\n        return;\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    ssl_clear_peer_cert( session );\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    mbedtls_free( session-\u003eticket );\n#endif\n\n    mbedtls_platform_zeroize( session, sizeof( mbedtls_ssl_session ) );\n}","filepath":"library/ssl_tls.c","line_number":9616,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"179087":{"score":0.91398555,"function_name":"mbedtls_sha512_starts_ret","code":"int mbedtls_sha512_starts_ret( mbedtls_sha512_context *ctx, int is384 )\n{\n    ctx-\u003etotal[0] = 0;\n    ctx-\u003etotal[1] = 0;\n\n    if( is384 == 0 )\n    {\n        /* SHA-512 */\n        ctx-\u003estate[0] = UL64(0x6A09E667F3BCC908);\n        ctx-\u003estate[1] = UL64(0xBB67AE8584CAA73B);\n        ctx-\u003estate[2] = UL64(0x3C6EF372FE94F82B);\n        ctx-\u003estate[3] = UL64(0xA54FF53A5F1D36F1);\n        ctx-\u003estate[4] = UL64(0x510E527FADE682D1);\n        ctx-\u003estate[5] = UL64(0x9B05688C2B3E6C1F);\n        ctx-\u003estate[6] = UL64(0x1F83D9ABFB41BD6B);\n        ctx-\u003estate[7] = UL64(0x5BE0CD19137E2179);\n    }\n    else\n    {\n        /* SHA-384 */\n        ctx-\u003estate[0] = UL64(0xCBBB9D5DC1059ED8);\n        ctx-\u003estate[1] = UL64(0x629A292A367CD507);\n        ctx-\u003estate[2] = UL64(0x9159015A3070DD17);\n        ctx-\u003estate[3] = UL64(0x152FECD8F70E5939);\n        ctx-\u003estate[4] = UL64(0x67332667FFC00B31);\n        ctx-\u003estate[5] = UL64(0x8EB44A8768581511);\n        ctx-\u003estate[6] = UL64(0xDB0C2E0D64F98FA7);\n        ctx-\u003estate[7] = UL64(0x47B5481DBEFA4FA4);\n    }\n\n    ctx-\u003eis384 = is384;\n\n    return( 0 );\n}","filepath":"library/sha512.c","line_number":142,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.7.17"},"189829":{"score":0.6982029,"function_name":"mbedtls_sha512","code":"int mbedtls_sha512( const unsigned char *input,\n                    size_t ilen,\n                    unsigned char *output,\n                    int is384 )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_sha512_context ctx;\n\n#if defined(MBEDTLS_SHA384_C)\n    SHA512_VALIDATE_RET( is384 == 0 || is384 == 1 );\n#else\n    SHA512_VALIDATE_RET( is384 == 0 );\n#endif\n    SHA512_VALIDATE_RET( ilen == 0 || input != NULL );\n    SHA512_VALIDATE_RET( (unsigned char *)output != NULL );\n\n    mbedtls_sha512_init( \u0026ctx );\n\n    if( ( ret = mbedtls_sha512_starts( \u0026ctx, is384 ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha512_update( \u0026ctx, input, ilen ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha512_finish( \u0026ctx, output ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_sha512_free( \u0026ctx );\n\n    return( ret );\n}","filepath":"library/sha512.c","line_number":856,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-3.2.0"},"190363":{"score":0.85429454,"function_name":"safer_memcmp","code":"static inline int safer_memcmp( const void *a, const void *b, size_t n )\n{\n    size_t i;\n    const unsigned char *A = (const unsigned char *) a;\n    const unsigned char *B = (const unsigned char *) b;\n    unsigned char diff = 0;\n\n    for( i = 0; i \u003c n; i++ )\n        diff |= A[i] ^ B[i];\n\n    return( diff );\n}","filepath":"include/polarssl/ssl.h","line_number":1797,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.9"},"190555":{"score":0.5177972,"function_name":"ssl_check_timer","code":"static int ssl_check_timer( mbedtls_ssl_context *ssl )\n{\n    if( ssl-\u003ef_get_timer == NULL )\n        return( 0 );\n\n    if( ssl-\u003ef_get_timer( ssl-\u003ep_timer ) == 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"timer expired\" ) );\n        return( -1 );\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":97,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"190628":{"score":0.75720096,"function_name":"ssl_session_copy","code":"static int ssl_session_copy( mbedtls_ssl_session *dst, const mbedtls_ssl_session *src )\n{\n    mbedtls_ssl_session_free( dst );\n    memcpy( dst, src, sizeof( mbedtls_ssl_session ) );\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    dst-\u003eticket = NULL;\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    if( src-\u003epeer_cert != NULL )\n    {\n        int ret;\n\n        dst-\u003epeer_cert = mbedtls_calloc( 1, sizeof(mbedtls_x509_crt) );\n        if( dst-\u003epeer_cert == NULL )\n            return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n        mbedtls_x509_crt_init( dst-\u003epeer_cert );\n\n        if( ( ret = mbedtls_x509_crt_parse_der( dst-\u003epeer_cert, src-\u003epeer_cert-\u003eraw.p,\n                                        src-\u003epeer_cert-\u003eraw.len ) ) != 0 )\n        {\n            mbedtls_free( dst-\u003epeer_cert );\n            dst-\u003epeer_cert = NULL;\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    if( src-\u003eticket != NULL )\n    {\n        dst-\u003eticket = mbedtls_calloc( 1, src-\u003eticket_len );\n        if( dst-\u003eticket == NULL )\n            return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n        memcpy( dst-\u003eticket, src-\u003eticket, src-\u003eticket_len );\n    }\n#endif /* MBEDTLS_SSL_SESSION_TICKETS \u0026\u0026 MBEDTLS_SSL_CLI_C */\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":299,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.12"},"190844":{"score":0.770614,"function_name":"tls_prf_generic","code":"static int tls_prf_generic( mbedtls_md_type_t md_type,\n                            const unsigned char *secret, size_t slen,\n                            const char *label,\n                            const unsigned char *random, size_t rlen,\n                            unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb;\n    size_t i, j, k, md_len;\n    unsigned char tmp[128];\n    unsigned char h_i[MBEDTLS_MD_MAX_SIZE];\n    const mbedtls_md_info_t *md_info;\n    mbedtls_md_context_t md_ctx;\n    int ret;\n\n    mbedtls_md_init( \u0026md_ctx );\n\n    if( ( md_info = mbedtls_md_info_from_type( md_type ) ) == NULL )\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n\n    md_len = mbedtls_md_get_size( md_info );\n\n    if( sizeof( tmp ) \u003c md_len + strlen( label ) + rlen )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    nb = strlen( label );\n    memcpy( tmp + md_len, label, nb );\n    memcpy( tmp + md_len + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * Compute P_\u003chash\u003e(secret, label + random)[0..dlen]\n     */\n    if ( ( ret = mbedtls_md_setup( \u0026md_ctx, md_info, 1 ) ) != 0 )\n        return( ret );\n\n    mbedtls_md_hmac_starts( \u0026md_ctx, secret, slen );\n    mbedtls_md_hmac_update( \u0026md_ctx, tmp + md_len, nb );\n    mbedtls_md_hmac_finish( \u0026md_ctx, tmp );\n\n    for( i = 0; i \u003c dlen; i += md_len )\n    {\n        mbedtls_md_hmac_reset ( \u0026md_ctx );\n        mbedtls_md_hmac_update( \u0026md_ctx, tmp, md_len + nb );\n        mbedtls_md_hmac_finish( \u0026md_ctx, h_i );\n\n        mbedtls_md_hmac_reset ( \u0026md_ctx );\n        mbedtls_md_hmac_update( \u0026md_ctx, tmp, md_len );\n        mbedtls_md_hmac_finish( \u0026md_ctx, tmp );\n\n        k = ( i + md_len \u003e dlen ) ? dlen % md_len : md_len;\n\n        for( j = 0; j \u003c k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    mbedtls_md_free( \u0026md_ctx );\n\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    mbedtls_platform_zeroize( h_i, sizeof( h_i ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":588,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"191808":{"score":0.80876493,"function_name":"ssl_derive_keys","code":"int ssl_derive_keys( ssl_context *ssl )\n{\n    int ret = 0;\n    unsigned char tmp[64];\n    unsigned char keyblk[256];\n    unsigned char *key1;\n    unsigned char *key2;\n    unsigned char *mac_enc;\n    unsigned char *mac_dec;\n    size_t iv_copy_len;\n    const cipher_info_t *cipher_info;\n    const md_info_t *md_info;\n\n    ssl_session *session = ssl-\u003esession_negotiate;\n    ssl_transform *transform = ssl-\u003etransform_negotiate;\n    ssl_handshake_params *handshake = ssl-\u003ehandshake;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e derive keys\" ) );\n\n    cipher_info = cipher_info_from_type( transform-\u003eciphersuite_info-\u003ecipher );\n    if( cipher_info == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"cipher info for %d not found\",\n                            transform-\u003eciphersuite_info-\u003ecipher ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    md_info = md_info_from_type( transform-\u003eciphersuite_info-\u003emac );\n    if( md_info == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"md info for %d not found\",\n                            transform-\u003eciphersuite_info-\u003emac ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /*\n     * Set appropriate PRF function and other SSL / TLS / TLS1.2 functions\n     */\n#if defined(POLARSSL_SSL_PROTO_SSL3)\n    if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 )\n    {\n        handshake-\u003etls_prf = ssl3_prf;\n        handshake-\u003ecalc_verify = ssl_calc_verify_ssl;\n        handshake-\u003ecalc_finished = ssl_calc_finished_ssl;\n    }\n    else\n#endif\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1)\n    if( ssl-\u003eminor_ver \u003c SSL_MINOR_VERSION_3 )\n    {\n        handshake-\u003etls_prf = tls1_prf;\n        handshake-\u003ecalc_verify = ssl_calc_verify_tls;\n        handshake-\u003ecalc_finished = ssl_calc_finished_tls;\n    }\n    else\n#endif\n#if defined(POLARSSL_SSL_PROTO_TLS1_2)\n#if defined(POLARSSL_SHA512_C)\n    if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_3 \u0026\u0026\n        transform-\u003eciphersuite_info-\u003emac == POLARSSL_MD_SHA384 )\n    {\n        handshake-\u003etls_prf = tls_prf_sha384;\n        handshake-\u003ecalc_verify = ssl_calc_verify_tls_sha384;\n        handshake-\u003ecalc_finished = ssl_calc_finished_tls_sha384;\n    }\n    else\n#endif\n#if defined(POLARSSL_SHA256_C)\n    if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_3 )\n    {\n        handshake-\u003etls_prf = tls_prf_sha256;\n        handshake-\u003ecalc_verify = ssl_calc_verify_tls_sha256;\n        handshake-\u003ecalc_finished = ssl_calc_finished_tls_sha256;\n    }\n    else\n#endif\n#endif /* POLARSSL_SSL_PROTO_TLS1_2 */\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    /*\n     * SSLv3:\n     *   master =\n     *     MD5( premaster + SHA1( 'A'   + premaster + randbytes ) ) +\n     *     MD5( premaster + SHA1( 'BB'  + premaster + randbytes ) ) +\n     *     MD5( premaster + SHA1( 'CCC' + premaster + randbytes ) )\n     *\n     * TLSv1+:\n     *   master = PRF( premaster, \"master secret\", randbytes )[0..47]\n     */\n    if( handshake-\u003eresume == 0 )\n    {\n        SSL_DEBUG_BUF( 3, \"premaster secret\", handshake-\u003epremaster,\n                       handshake-\u003epmslen );\n\n        handshake-\u003etls_prf( handshake-\u003epremaster, handshake-\u003epmslen,\n                            \"master secret\",\n                            handshake-\u003erandbytes, 64, session-\u003emaster, 48 );\n\n        polarssl_zeroize( handshake-\u003epremaster, sizeof(handshake-\u003epremaster) );\n    }\n    else\n        SSL_DEBUG_MSG( 3, ( \"no premaster (session resumed)\" ) );\n\n    /*\n     * Swap the client and server random values.\n     */\n    memcpy( tmp, handshake-\u003erandbytes, 64 );\n    memcpy( handshake-\u003erandbytes, tmp + 32, 32 );\n    memcpy( handshake-\u003erandbytes + 32, tmp, 32 );\n    polarssl_zeroize( tmp, sizeof( tmp ) );\n\n    /*\n     *  SSLv3:\n     *    key block =\n     *      MD5( master + SHA1( 'A'    + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'BB'   + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'CCC'  + master + randbytes ) ) +\n     *      MD5( master + SHA1( 'DDDD' + master + randbytes ) ) +\n     *      ...\n     *\n     *  TLSv1:\n     *    key block = PRF( master, \"key expansion\", randbytes )\n     */\n    handshake-\u003etls_prf( session-\u003emaster, 48, \"key expansion\",\n                        handshake-\u003erandbytes, 64, keyblk, 256 );\n\n    SSL_DEBUG_MSG( 3, ( \"ciphersuite = %s\",\n                   ssl_get_ciphersuite_name( session-\u003eciphersuite ) ) );\n    SSL_DEBUG_BUF( 3, \"master secret\", session-\u003emaster, 48 );\n    SSL_DEBUG_BUF( 4, \"random bytes\", handshake-\u003erandbytes, 64 );\n    SSL_DEBUG_BUF( 4, \"key block\", keyblk, 256 );\n\n    polarssl_zeroize( handshake-\u003erandbytes, sizeof( handshake-\u003erandbytes ) );\n\n    /*\n     * Determine the appropriate key, IV and MAC length.\n     */\n\n    transform-\u003ekeylen = cipher_info-\u003ekey_length / 8;\n\n    if( cipher_info-\u003emode == POLARSSL_MODE_GCM ||\n        cipher_info-\u003emode == POLARSSL_MODE_CCM )\n    {\n        transform-\u003emaclen = 0;\n\n        transform-\u003eivlen = 12;\n        transform-\u003efixed_ivlen = 4;\n\n        /* Minimum length is expicit IV + tag */\n        transform-\u003eminlen = transform-\u003eivlen - transform-\u003efixed_ivlen\n                            + ( transform-\u003eciphersuite_info-\u003eflags \u0026\n                                POLARSSL_CIPHERSUITE_SHORT_TAG ? 8 : 16 );\n    }\n    else\n    {\n        int ret;\n\n        /* Initialize HMAC contexts */\n        if( ( ret = md_init_ctx( \u0026transform-\u003emd_ctx_enc, md_info ) ) != 0 ||\n            ( ret = md_init_ctx( \u0026transform-\u003emd_ctx_dec, md_info ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"md_init_ctx\", ret );\n            return( ret );\n        }\n\n        /* Get MAC length */\n        transform-\u003emaclen = md_get_size( md_info );\n\n#if defined(POLARSSL_SSL_TRUNCATED_HMAC)\n        /*\n         * If HMAC is to be truncated, we shall keep the leftmost bytes,\n         * (rfc 6066 page 13 or rfc 2104 section 4),\n         * so we only need to adjust the length here.\n         */\n        if( session-\u003etrunc_hmac == SSL_TRUNC_HMAC_ENABLED )\n            transform-\u003emaclen = SSL_TRUNCATED_HMAC_LEN;\n#endif /* POLARSSL_SSL_TRUNCATED_HMAC */\n\n        /* IV length */\n        transform-\u003eivlen = cipher_info-\u003eiv_size;\n\n        /* Minimum length */\n        if( cipher_info-\u003emode == POLARSSL_MODE_STREAM )\n            transform-\u003eminlen = transform-\u003emaclen;\n        else\n        {\n            /*\n             * GenericBlockCipher:\n             * first multiple of blocklen greater than maclen\n             * + IV except for SSL3 and TLS 1.0\n             */\n            transform-\u003eminlen = transform-\u003emaclen\n                                + cipher_info-\u003eblock_size\n                                - transform-\u003emaclen % cipher_info-\u003eblock_size;\n\n#if defined(POLARSSL_SSL_PROTO_SSL3) || defined(POLARSSL_SSL_PROTO_TLS1)\n            if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 ||\n                ssl-\u003eminor_ver == SSL_MINOR_VERSION_1 )\n                ; /* No need to adjust minlen */\n            else\n#endif\n#if defined(POLARSSL_SSL_PROTO_TLS1_1) || defined(POLARSSL_SSL_PROTO_TLS1_2)\n            if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_2 ||\n                ssl-\u003eminor_ver == SSL_MINOR_VERSION_3 )\n            {\n                transform-\u003eminlen += transform-\u003eivlen;\n            }\n            else\n#endif\n            {\n                SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n                return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n            }\n        }\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"keylen: %d, minlen: %d, ivlen: %d, maclen: %d\",\n                   transform-\u003ekeylen, transform-\u003eminlen, transform-\u003eivlen,\n                   transform-\u003emaclen ) );\n\n    /*\n     * Finally setup the cipher contexts, IVs and MAC secrets.\n     */\n    if( ssl-\u003eendpoint == SSL_IS_CLIENT )\n    {\n        key1 = keyblk + transform-\u003emaclen * 2;\n        key2 = keyblk + transform-\u003emaclen * 2 + transform-\u003ekeylen;\n\n        mac_enc = keyblk;\n        mac_dec = keyblk + transform-\u003emaclen;\n\n        /*\n         * This is not used in TLS v1.1.\n         */\n        iv_copy_len = ( transform-\u003efixed_ivlen ) ?\n                            transform-\u003efixed_ivlen : transform-\u003eivlen;\n        memcpy( transform-\u003eiv_enc, key2 + transform-\u003ekeylen,  iv_copy_len );\n        memcpy( transform-\u003eiv_dec, key2 + transform-\u003ekeylen + iv_copy_len,\n                iv_copy_len );\n    }\n    else\n    {\n        key1 = keyblk + transform-\u003emaclen * 2 + transform-\u003ekeylen;\n        key2 = keyblk + transform-\u003emaclen * 2;\n\n        mac_enc = keyblk + transform-\u003emaclen;\n        mac_dec = keyblk;\n\n        /*\n         * This is not used in TLS v1.1.\n         */\n        iv_copy_len = ( transform-\u003efixed_ivlen ) ?\n                            transform-\u003efixed_ivlen : transform-\u003eivlen;\n        memcpy( transform-\u003eiv_dec, key1 + transform-\u003ekeylen,  iv_copy_len );\n        memcpy( transform-\u003eiv_enc, key1 + transform-\u003ekeylen + iv_copy_len,\n                iv_copy_len );\n    }\n\n#if defined(POLARSSL_SSL_PROTO_SSL3)\n    if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( transform-\u003emaclen \u003e sizeof transform-\u003emac_enc )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        memcpy( transform-\u003emac_enc, mac_enc, transform-\u003emaclen );\n        memcpy( transform-\u003emac_dec, mac_dec, transform-\u003emaclen );\n    }\n    else\n#endif /* POLARSSL_SSL_PROTO_SSL3 */\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1) || \\\n    defined(POLARSSL_SSL_PROTO_TLS1_2)\n    if( ssl-\u003eminor_ver \u003e= SSL_MINOR_VERSION_1 )\n    {\n        md_hmac_starts( \u0026transform-\u003emd_ctx_enc, mac_enc, transform-\u003emaclen );\n        md_hmac_starts( \u0026transform-\u003emd_ctx_dec, mac_dec, transform-\u003emaclen );\n    }\n    else\n#endif\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_init != NULL )\n    {\n        int ret = 0;\n\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_init()\" ) );\n\n        if( ( ret = ssl_hw_record_init( ssl, key1, key2, transform-\u003ekeylen,\n                                        transform-\u003eiv_enc, transform-\u003eiv_dec,\n                                        iv_copy_len,\n                                        mac_enc, mac_dec,\n                                        transform-\u003emaclen ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_init\", ret );\n            return( POLARSSL_ERR_SSL_HW_ACCEL_FAILED );\n        }\n    }\n#endif /* POLARSSL_SSL_HW_RECORD_ACCEL */\n\n    if( ( ret = cipher_init_ctx( \u0026transform-\u003ecipher_ctx_enc,\n                                 cipher_info ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"cipher_init_ctx\", ret );\n        return( ret );\n    }\n\n    if( ( ret = cipher_init_ctx( \u0026transform-\u003ecipher_ctx_dec,\n                                 cipher_info ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"cipher_init_ctx\", ret );\n        return( ret );\n    }\n\n    if( ( ret = cipher_setkey( \u0026transform-\u003ecipher_ctx_enc, key1,\n                               cipher_info-\u003ekey_length,\n                               POLARSSL_ENCRYPT ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"cipher_setkey\", ret );\n        return( ret );\n    }\n\n    if( ( ret = cipher_setkey( \u0026transform-\u003ecipher_ctx_dec, key2,\n                               cipher_info-\u003ekey_length,\n                               POLARSSL_DECRYPT ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"cipher_setkey\", ret );\n        return( ret );\n    }\n\n#if defined(POLARSSL_CIPHER_MODE_CBC)\n    if( cipher_info-\u003emode == POLARSSL_MODE_CBC )\n    {\n        if( ( ret = cipher_set_padding_mode( \u0026transform-\u003ecipher_ctx_enc,\n                                             POLARSSL_PADDING_NONE ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_set_padding_mode\", ret );\n            return( ret );\n        }\n\n        if( ( ret = cipher_set_padding_mode( \u0026transform-\u003ecipher_ctx_dec,\n                                             POLARSSL_PADDING_NONE ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_set_padding_mode\", ret );\n            return( ret );\n        }\n    }\n#endif /* POLARSSL_CIPHER_MODE_CBC */\n\n    polarssl_zeroize( keyblk, sizeof( keyblk ) );\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    // Initialize compression\n    //\n    if( session-\u003ecompression == SSL_COMPRESS_DEFLATE )\n    {\n        if( ssl-\u003ecompress_buf == NULL )\n        {\n            SSL_DEBUG_MSG( 3, ( \"Allocating compression buffer\" ) );\n            ssl-\u003ecompress_buf = polarssl_malloc( SSL_BUFFER_LEN );\n            if( ssl-\u003ecompress_buf == NULL )\n            {\n                SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\",\n                                    SSL_BUFFER_LEN ) );\n                return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n            }\n        }\n\n        SSL_DEBUG_MSG( 3, ( \"Initializing zlib states\" ) );\n\n        memset( \u0026transform-\u003ectx_deflate, 0, sizeof( transform-\u003ectx_deflate ) );\n        memset( \u0026transform-\u003ectx_inflate, 0, sizeof( transform-\u003ectx_inflate ) );\n\n        if( deflateInit( \u0026transform-\u003ectx_deflate,\n                         Z_DEFAULT_COMPRESSION )   != Z_OK ||\n            inflateInit( \u0026transform-\u003ectx_inflate ) != Z_OK )\n        {\n            SSL_DEBUG_MSG( 1, ( \"Failed to initialize compression\" ) );\n            return( POLARSSL_ERR_SSL_COMPRESSION_FAILED );\n        }\n    }\n#endif /* POLARSSL_ZLIB_SUPPORT */\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= derive keys\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":376,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.9"},"194548":{"score":0.8822966,"function_name":"ssl_read_memory","code":"static void ssl_read_memory( unsigned char *p, size_t len )\n{\n    unsigned char acc = 0;\n    volatile unsigned char force;\n\n    for( ; len != 0; p++, len-- )\n        acc ^= *p;\n\n    force = acc;\n    (void) force;\n}","filepath":"library/ssl_tls.c","line_number":1729,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"194607":{"score":0.7113297,"function_name":"ssl_encrypt_buf","code":"static int ssl_encrypt_buf( ssl_context *ssl )\n{\n    size_t i;\n    cipher_mode_t mode;\n    int auth_done = 0;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e encrypt buf\" ) );\n\n    if( ssl-\u003esession_out == NULL || ssl-\u003etransform_out == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    mode = cipher_get_cipher_mode( \u0026ssl-\u003etransform_out-\u003ecipher_ctx_enc );\n\n    SSL_DEBUG_BUF( 4, \"before encrypt: output payload\",\n                      ssl-\u003eout_msg, ssl-\u003eout_msglen );\n\n    /*\n     * Add MAC before if needed\n     */\n#if defined(POLARSSL_SOME_MODES_USE_MAC)\n    if( mode == POLARSSL_MODE_STREAM ||\n        ( mode == POLARSSL_MODE_CBC\n#if defined(POLARSSL_SSL_ENCRYPT_THEN_MAC)\n          \u0026\u0026 ssl-\u003esession_out-\u003eencrypt_then_mac == SSL_ETM_DISABLED\n#endif\n        ) )\n    {\n#if defined(POLARSSL_SSL_PROTO_SSL3)\n        if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 )\n        {\n            ssl_mac( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc,\n                      ssl-\u003etransform_out-\u003emac_enc,\n                      ssl-\u003eout_msg, ssl-\u003eout_msglen,\n                      ssl-\u003eout_ctr, ssl-\u003eout_msgtype );\n        }\n        else\n#endif\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1) || \\\n        defined(POLARSSL_SSL_PROTO_TLS1_2)\n        if( ssl-\u003eminor_ver \u003e= SSL_MINOR_VERSION_1 )\n        {\n            md_hmac_update( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc, ssl-\u003eout_ctr, 13 );\n            md_hmac_update( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc,\n                             ssl-\u003eout_msg, ssl-\u003eout_msglen );\n            md_hmac_finish( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc,\n                             ssl-\u003eout_msg + ssl-\u003eout_msglen );\n            md_hmac_reset( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc );\n        }\n        else\n#endif\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        SSL_DEBUG_BUF( 4, \"computed mac\",\n                       ssl-\u003eout_msg + ssl-\u003eout_msglen,\n                       ssl-\u003etransform_out-\u003emaclen );\n\n        ssl-\u003eout_msglen += ssl-\u003etransform_out-\u003emaclen;\n        auth_done++;\n    }\n#endif /* AEAD not the only option */\n\n    /*\n     * Encrypt\n     */\n#if defined(POLARSSL_ARC4_C) || defined(POLARSSL_CIPHER_NULL_CIPHER)\n    if( mode == POLARSSL_MODE_STREAM )\n    {\n        int ret;\n        size_t olen = 0;\n\n        SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                            \"including %d bytes of padding\",\n                       ssl-\u003eout_msglen, 0 ) );\n\n        if( ( ret = cipher_crypt( \u0026ssl-\u003etransform_out-\u003ecipher_ctx_enc,\n                                   ssl-\u003etransform_out-\u003eiv_enc,\n                                   ssl-\u003etransform_out-\u003eivlen,\n                                   ssl-\u003eout_msg, ssl-\u003eout_msglen,\n                                   ssl-\u003eout_msg, \u0026olen ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_crypt\", ret );\n            return( ret );\n        }\n\n        if( ssl-\u003eout_msglen != olen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n    }\n    else\n#endif /* POLARSSL_ARC4_C || POLARSSL_CIPHER_NULL_CIPHER */\n#if defined(POLARSSL_GCM_C) || defined(POLARSSL_CCM_C)\n    if( mode == POLARSSL_MODE_GCM ||\n        mode == POLARSSL_MODE_CCM )\n    {\n        int ret;\n        size_t enc_msglen, olen;\n        unsigned char *enc_msg;\n        unsigned char add_data[13];\n        unsigned char taglen = ssl-\u003etransform_out-\u003eciphersuite_info-\u003eflags \u0026\n                               POLARSSL_CIPHERSUITE_SHORT_TAG ? 8 : 16;\n\n        memcpy( add_data, ssl-\u003eout_ctr, 8 );\n        add_data[8]  = ssl-\u003eout_msgtype;\n        add_data[9]  = ssl-\u003emajor_ver;\n        add_data[10] = ssl-\u003eminor_ver;\n        add_data[11] = ( ssl-\u003eout_msglen \u003e\u003e 8 ) \u0026 0xFF;\n        add_data[12] = ssl-\u003eout_msglen \u0026 0xFF;\n\n        SSL_DEBUG_BUF( 4, \"additional data used for AEAD\",\n                       add_data, 13 );\n\n        /*\n         * Generate IV\n         */\n#if defined(POLARSSL_SSL_AEAD_RANDOM_IV)\n        ret = ssl-\u003ef_rng( ssl-\u003ep_rng,\n                ssl-\u003etransform_out-\u003eiv_enc + ssl-\u003etransform_out-\u003efixed_ivlen,\n                ssl-\u003etransform_out-\u003eivlen - ssl-\u003etransform_out-\u003efixed_ivlen );\n        if( ret != 0 )\n            return( ret );\n\n        memcpy( ssl-\u003eout_iv,\n                ssl-\u003etransform_out-\u003eiv_enc + ssl-\u003etransform_out-\u003efixed_ivlen,\n                ssl-\u003etransform_out-\u003eivlen - ssl-\u003etransform_out-\u003efixed_ivlen );\n#else\n        if( ssl-\u003etransform_out-\u003eivlen - ssl-\u003etransform_out-\u003efixed_ivlen != 8 )\n        {\n            /* Reminder if we ever add an AEAD mode with a different size */\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        memcpy( ssl-\u003etransform_out-\u003eiv_enc + ssl-\u003etransform_out-\u003efixed_ivlen,\n                             ssl-\u003eout_ctr, 8 );\n        memcpy( ssl-\u003eout_iv, ssl-\u003eout_ctr, 8 );\n#endif\n\n        SSL_DEBUG_BUF( 4, \"IV used\", ssl-\u003eout_iv,\n                ssl-\u003etransform_out-\u003eivlen - ssl-\u003etransform_out-\u003efixed_ivlen );\n\n        /*\n         * Fix pointer positions and message length with added IV\n         */\n        enc_msg = ssl-\u003eout_msg;\n        enc_msglen = ssl-\u003eout_msglen;\n        ssl-\u003eout_msglen += ssl-\u003etransform_out-\u003eivlen -\n                           ssl-\u003etransform_out-\u003efixed_ivlen;\n\n        SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                            \"including %d bytes of padding\",\n                       ssl-\u003eout_msglen, 0 ) );\n\n        /*\n         * Encrypt and authenticate\n         */\n        if( ( ret = cipher_auth_encrypt( \u0026ssl-\u003etransform_out-\u003ecipher_ctx_enc,\n                                         ssl-\u003etransform_out-\u003eiv_enc,\n                                         ssl-\u003etransform_out-\u003eivlen,\n                                         add_data, 13,\n                                         enc_msg, enc_msglen,\n                                         enc_msg, \u0026olen,\n                                         enc_msg + enc_msglen, taglen ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_auth_encrypt\", ret );\n            return( ret );\n        }\n\n        if( olen != enc_msglen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        ssl-\u003eout_msglen += taglen;\n        auth_done++;\n\n        SSL_DEBUG_BUF( 4, \"after encrypt: tag\", enc_msg + enc_msglen, taglen );\n    }\n    else\n#endif /* POLARSSL_GCM_C || POLARSSL_CCM_C */\n#if defined(POLARSSL_CIPHER_MODE_CBC) \u0026\u0026                                    \\\n    ( defined(POLARSSL_AES_C) || defined(POLARSSL_CAMELLIA_C) )\n    if( mode == POLARSSL_MODE_CBC )\n    {\n        int ret;\n        unsigned char *enc_msg;\n        size_t enc_msglen, padlen, olen = 0;\n\n        padlen = ssl-\u003etransform_out-\u003eivlen - ( ssl-\u003eout_msglen + 1 ) %\n                 ssl-\u003etransform_out-\u003eivlen;\n        if( padlen == ssl-\u003etransform_out-\u003eivlen )\n            padlen = 0;\n\n        for( i = 0; i \u003c= padlen; i++ )\n            ssl-\u003eout_msg[ssl-\u003eout_msglen + i] = (unsigned char) padlen;\n\n        ssl-\u003eout_msglen += padlen + 1;\n\n        enc_msglen = ssl-\u003eout_msglen;\n        enc_msg = ssl-\u003eout_msg;\n\n#if defined(POLARSSL_SSL_PROTO_TLS1_1) || defined(POLARSSL_SSL_PROTO_TLS1_2)\n        /*\n         * Prepend per-record IV for block cipher in TLS v1.1 and up as per\n         * Method 1 (6.2.3.2. in RFC4346 and RFC5246)\n         */\n        if( ssl-\u003eminor_ver \u003e= SSL_MINOR_VERSION_2 )\n        {\n            /*\n             * Generate IV\n             */\n            int ret = ssl-\u003ef_rng( ssl-\u003ep_rng, ssl-\u003etransform_out-\u003eiv_enc,\n                                  ssl-\u003etransform_out-\u003eivlen );\n            if( ret != 0 )\n                return( ret );\n\n            memcpy( ssl-\u003eout_iv, ssl-\u003etransform_out-\u003eiv_enc,\n                    ssl-\u003etransform_out-\u003eivlen );\n\n            /*\n             * Fix pointer positions and message length with added IV\n             */\n            enc_msg = ssl-\u003eout_msg;\n            enc_msglen = ssl-\u003eout_msglen;\n            ssl-\u003eout_msglen += ssl-\u003etransform_out-\u003eivlen;\n        }\n#endif /* POLARSSL_SSL_PROTO_TLS1_1 || POLARSSL_SSL_PROTO_TLS1_2 */\n\n        SSL_DEBUG_MSG( 3, ( \"before encrypt: msglen = %d, \"\n                            \"including %d bytes of IV and %d bytes of padding\",\n                            ssl-\u003eout_msglen, ssl-\u003etransform_out-\u003eivlen,\n                            padlen + 1 ) );\n\n        if( ( ret = cipher_crypt( \u0026ssl-\u003etransform_out-\u003ecipher_ctx_enc,\n                                   ssl-\u003etransform_out-\u003eiv_enc,\n                                   ssl-\u003etransform_out-\u003eivlen,\n                                   enc_msg, enc_msglen,\n                                   enc_msg, \u0026olen ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_crypt\", ret );\n            return( ret );\n        }\n\n        if( enc_msglen != olen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n#if defined(POLARSSL_SSL_PROTO_SSL3) || defined(POLARSSL_SSL_PROTO_TLS1)\n        if( ssl-\u003eminor_ver \u003c SSL_MINOR_VERSION_2 )\n        {\n            /*\n             * Save IV in SSL3 and TLS1\n             */\n            memcpy( ssl-\u003etransform_out-\u003eiv_enc,\n                    ssl-\u003etransform_out-\u003ecipher_ctx_enc.iv,\n                    ssl-\u003etransform_out-\u003eivlen );\n        }\n#endif\n\n#if defined(POLARSSL_SSL_ENCRYPT_THEN_MAC)\n        if( auth_done == 0 )\n        {\n            /*\n             * MAC(MAC_write_key, seq_num +\n             *     TLSCipherText.type +\n             *     TLSCipherText.version +\n             *     length_of( (IV +) ENC(...) ) +\n             *     IV + // except for TLS 1.0\n             *     ENC(content + padding + padding_length));\n             */\n            unsigned char pseudo_hdr[13];\n\n            SSL_DEBUG_MSG( 3, ( \"using encrypt then mac\" ) );\n\n            memcpy( pseudo_hdr +  0, ssl-\u003eout_ctr, 8 );\n            memcpy( pseudo_hdr +  8, ssl-\u003eout_hdr, 3 );\n            pseudo_hdr[11] = (unsigned char)( ( ssl-\u003eout_msglen \u003e\u003e 8 ) \u0026 0xFF );\n            pseudo_hdr[12] = (unsigned char)( ( ssl-\u003eout_msglen      ) \u0026 0xFF );\n\n            SSL_DEBUG_BUF( 4, \"MAC'd meta-data\", pseudo_hdr, 13 );\n\n            md_hmac_update( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc, pseudo_hdr, 13 );\n            md_hmac_update( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc,\n                             ssl-\u003eout_iv, ssl-\u003eout_msglen );\n            md_hmac_finish( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc,\n                             ssl-\u003eout_iv + ssl-\u003eout_msglen );\n            md_hmac_reset( \u0026ssl-\u003etransform_out-\u003emd_ctx_enc );\n\n            ssl-\u003eout_msglen += ssl-\u003etransform_out-\u003emaclen;\n            auth_done++;\n        }\n#endif /* POLARSSL_SSL_ENCRYPT_THEN_MAC */\n    }\n    else\n#endif /* POLARSSL_CIPHER_MODE_CBC \u0026\u0026\n          ( POLARSSL_AES_C || POLARSSL_CAMELLIA_C ) */\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    /* Make extra sure authentication was performed, exactly once */\n    if( auth_done != 1 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    for( i = 8; i \u003e 0; i-- )\n        if( ++ssl-\u003eout_ctr[i - 1] != 0 )\n            break;\n\n    /* The loops goes to its end iff the counter is wrapping */\n    if( i == 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"outgoing message counter would wrap\" ) );\n        return( POLARSSL_ERR_SSL_COUNTER_WRAPPING );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= encrypt buf\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":1090,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"195498":{"score":0.67012465,"function_name":"ssl_decrypt_buf","code":"static int ssl_decrypt_buf( ssl_context *ssl )\n{\n    size_t i;\n    cipher_mode_t mode;\n    int auth_done = 0;\n#if defined(POLARSSL_SOME_MODES_USE_MAC)\n    size_t padlen = 0, correct = 1;\n#endif\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e decrypt buf\" ) );\n\n    if( ssl-\u003esession_in == NULL || ssl-\u003etransform_in == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    mode = cipher_get_cipher_mode( \u0026ssl-\u003etransform_in-\u003ecipher_ctx_dec );\n\n    if( ssl-\u003ein_msglen \u003c ssl-\u003etransform_in-\u003eminlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"in_msglen (%d) \u003c minlen (%d)\",\n                       ssl-\u003ein_msglen, ssl-\u003etransform_in-\u003eminlen ) );\n        return( POLARSSL_ERR_SSL_INVALID_MAC );\n    }\n\n#if defined(POLARSSL_ARC4_C) || defined(POLARSSL_CIPHER_NULL_CIPHER)\n    if( mode == POLARSSL_MODE_STREAM )\n    {\n        int ret;\n        size_t olen = 0;\n\n        padlen = 0;\n\n        if( ( ret = cipher_crypt( \u0026ssl-\u003etransform_in-\u003ecipher_ctx_dec,\n                                   ssl-\u003etransform_in-\u003eiv_dec,\n                                   ssl-\u003etransform_in-\u003eivlen,\n                                   ssl-\u003ein_msg, ssl-\u003ein_msglen,\n                                   ssl-\u003ein_msg, \u0026olen ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_crypt\", ret );\n            return( ret );\n        }\n\n        if( ssl-\u003ein_msglen != olen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n    }\n    else\n#endif /* POLARSSL_ARC4_C || POLARSSL_CIPHER_NULL_CIPHER */\n#if defined(POLARSSL_GCM_C) || defined(POLARSSL_CCM_C)\n    if( mode == POLARSSL_MODE_GCM ||\n        mode == POLARSSL_MODE_CCM )\n    {\n        int ret;\n        size_t dec_msglen, olen;\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        unsigned char add_data[13];\n        unsigned char taglen = ssl-\u003etransform_in-\u003eciphersuite_info-\u003eflags \u0026\n                               POLARSSL_CIPHERSUITE_SHORT_TAG ? 8 : 16;\n        size_t explicit_iv_len =  ssl-\u003etransform_in-\u003eivlen -\n                                         ssl-\u003etransform_in-\u003efixed_ivlen;\n\n        if( ssl-\u003ein_msglen \u003c (size_t) explicit_iv_len + taglen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) \u003c explicit_iv_len (%d) \"\n                                \"+ taglen (%d)\", ssl-\u003ein_msglen,\n                                explicit_iv_len, taglen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n        dec_msglen = ssl-\u003ein_msglen - explicit_iv_len - taglen;\n\n        dec_msg = ssl-\u003ein_msg;\n        dec_msg_result = ssl-\u003ein_msg;\n        ssl-\u003ein_msglen = dec_msglen;\n\n        memcpy( add_data, ssl-\u003ein_ctr, 8 );\n        add_data[8]  = ssl-\u003ein_msgtype;\n        add_data[9]  = ssl-\u003emajor_ver;\n        add_data[10] = ssl-\u003eminor_ver;\n        add_data[11] = ( ssl-\u003ein_msglen \u003e\u003e 8 ) \u0026 0xFF;\n        add_data[12] = ssl-\u003ein_msglen \u0026 0xFF;\n\n        SSL_DEBUG_BUF( 4, \"additional data used for AEAD\",\n                       add_data, 13 );\n\n        memcpy( ssl-\u003etransform_in-\u003eiv_dec + ssl-\u003etransform_in-\u003efixed_ivlen,\n                ssl-\u003ein_iv,\n                ssl-\u003etransform_in-\u003eivlen - ssl-\u003etransform_in-\u003efixed_ivlen );\n\n        SSL_DEBUG_BUF( 4, \"IV used\", ssl-\u003etransform_in-\u003eiv_dec,\n                                     ssl-\u003etransform_in-\u003eivlen );\n        SSL_DEBUG_BUF( 4, \"TAG used\", dec_msg + dec_msglen, taglen );\n\n        /*\n         * Decrypt and authenticate\n         */\n        if( ( ret = cipher_auth_decrypt( \u0026ssl-\u003etransform_in-\u003ecipher_ctx_dec,\n                                         ssl-\u003etransform_in-\u003eiv_dec,\n                                         ssl-\u003etransform_in-\u003eivlen,\n                                         add_data, 13,\n                                         dec_msg, dec_msglen,\n                                         dec_msg_result, \u0026olen,\n                                         dec_msg + dec_msglen, taglen ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_auth_decrypt\", ret );\n\n            if( ret == POLARSSL_ERR_CIPHER_AUTH_FAILED )\n                return( POLARSSL_ERR_SSL_INVALID_MAC );\n\n            return( ret );\n        }\n        auth_done++;\n\n        if( olen != dec_msglen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n    }\n    else\n#endif /* POLARSSL_GCM_C || POLARSSL_CCM_C */\n#if defined(POLARSSL_CIPHER_MODE_CBC) \u0026\u0026                                    \\\n    ( defined(POLARSSL_AES_C) || defined(POLARSSL_CAMELLIA_C) )\n    if( mode == POLARSSL_MODE_CBC )\n    {\n        /*\n         * Decrypt and check the padding\n         */\n        int ret;\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        size_t dec_msglen;\n        size_t minlen = 0;\n        size_t olen = 0;\n\n        /*\n         * Check immediate ciphertext sanity\n         */\n#if defined(POLARSSL_SSL_PROTO_TLS1_1) || defined(POLARSSL_SSL_PROTO_TLS1_2)\n        if( ssl-\u003eminor_ver \u003e= SSL_MINOR_VERSION_2 )\n            minlen += ssl-\u003etransform_in-\u003eivlen;\n#endif\n\n        if( ssl-\u003ein_msglen \u003c minlen + ssl-\u003etransform_in-\u003eivlen ||\n            ssl-\u003ein_msglen \u003c minlen + ssl-\u003etransform_in-\u003emaclen + 1 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) \u003c max( ivlen(%d), maclen (%d) \"\n                                \"+ 1 ) ( + expl IV )\", ssl-\u003ein_msglen,\n                                ssl-\u003etransform_in-\u003eivlen,\n                                ssl-\u003etransform_in-\u003emaclen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n        dec_msglen = ssl-\u003ein_msglen;\n        dec_msg = ssl-\u003ein_msg;\n        dec_msg_result = ssl-\u003ein_msg;\n\n        /*\n         * Authenticate before decrypt if enabled\n         */\n#if defined(POLARSSL_SSL_ENCRYPT_THEN_MAC)\n        if( ssl-\u003esession_in-\u003eencrypt_then_mac == SSL_ETM_ENABLED )\n        {\n            unsigned char computed_mac[POLARSSL_SSL_MAX_MAC_SIZE];\n            unsigned char pseudo_hdr[13];\n\n            SSL_DEBUG_MSG( 3, ( \"using encrypt then mac\" ) );\n\n            dec_msglen -= ssl-\u003etransform_in-\u003emaclen;\n            ssl-\u003ein_msglen -= ssl-\u003etransform_in-\u003emaclen;\n\n            memcpy( pseudo_hdr +  0, ssl-\u003ein_ctr, 8 );\n            memcpy( pseudo_hdr +  8, ssl-\u003ein_hdr, 3 );\n            pseudo_hdr[11] = (unsigned char)( ( ssl-\u003ein_msglen \u003e\u003e 8 ) \u0026 0xFF );\n            pseudo_hdr[12] = (unsigned char)( ( ssl-\u003ein_msglen      ) \u0026 0xFF );\n\n            SSL_DEBUG_BUF( 4, \"MAC'd meta-data\", pseudo_hdr, 13 );\n\n            md_hmac_update( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec, pseudo_hdr, 13 );\n            md_hmac_update( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec,\n                             ssl-\u003ein_iv, ssl-\u003ein_msglen );\n            md_hmac_finish( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec, computed_mac );\n            md_hmac_reset( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec );\n\n            SSL_DEBUG_BUF( 4, \"message  mac\", ssl-\u003ein_iv + ssl-\u003ein_msglen,\n                                              ssl-\u003etransform_in-\u003emaclen );\n            SSL_DEBUG_BUF( 4, \"computed mac\", computed_mac,\n                                              ssl-\u003etransform_in-\u003emaclen );\n\n            if( safer_memcmp( ssl-\u003ein_iv + ssl-\u003ein_msglen, computed_mac,\n                              ssl-\u003etransform_in-\u003emaclen ) != 0 )\n            {\n                SSL_DEBUG_MSG( 1, ( \"message mac does not match\" ) );\n\n                return( POLARSSL_ERR_SSL_INVALID_MAC );\n            }\n            auth_done++;\n        }\n#endif /* POLARSSL_SSL_ENCRYPT_THEN_MAC */\n\n        /*\n         * Check length sanity\n         */\n        if( ssl-\u003ein_msglen % ssl-\u003etransform_in-\u003eivlen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) %% ivlen (%d) != 0\",\n                           ssl-\u003ein_msglen, ssl-\u003etransform_in-\u003eivlen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n#if defined(POLARSSL_SSL_PROTO_TLS1_1) || defined(POLARSSL_SSL_PROTO_TLS1_2)\n        /*\n         * Initialize for prepended IV for block cipher in TLS v1.1 and up\n         */\n        if( ssl-\u003eminor_ver \u003e= SSL_MINOR_VERSION_2 )\n        {\n            dec_msglen -= ssl-\u003etransform_in-\u003eivlen;\n            ssl-\u003ein_msglen -= ssl-\u003etransform_in-\u003eivlen;\n\n            for( i = 0; i \u003c ssl-\u003etransform_in-\u003eivlen; i++ )\n                ssl-\u003etransform_in-\u003eiv_dec[i] = ssl-\u003ein_iv[i];\n        }\n#endif /* POLARSSL_SSL_PROTO_TLS1_1 || POLARSSL_SSL_PROTO_TLS1_2 */\n\n        if( ( ret = cipher_crypt( \u0026ssl-\u003etransform_in-\u003ecipher_ctx_dec,\n                                   ssl-\u003etransform_in-\u003eiv_dec,\n                                   ssl-\u003etransform_in-\u003eivlen,\n                                   dec_msg, dec_msglen,\n                                   dec_msg_result, \u0026olen ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"cipher_crypt\", ret );\n            return( ret );\n        }\n\n        if( dec_msglen != olen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n#if defined(POLARSSL_SSL_PROTO_SSL3) || defined(POLARSSL_SSL_PROTO_TLS1)\n        if( ssl-\u003eminor_ver \u003c SSL_MINOR_VERSION_2 )\n        {\n            /*\n             * Save IV in SSL3 and TLS1\n             */\n            memcpy( ssl-\u003etransform_in-\u003eiv_dec,\n                    ssl-\u003etransform_in-\u003ecipher_ctx_dec.iv,\n                    ssl-\u003etransform_in-\u003eivlen );\n        }\n#endif\n\n        padlen = 1 + ssl-\u003ein_msg[ssl-\u003ein_msglen - 1];\n\n        if( ssl-\u003ein_msglen \u003c ssl-\u003etransform_in-\u003emaclen + padlen \u0026\u0026\n            auth_done == 0 )\n        {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) \u003c maclen (%d) + padlen (%d)\",\n                        ssl-\u003ein_msglen, ssl-\u003etransform_in-\u003emaclen, padlen ) );\n#endif\n            padlen = 0;\n            correct = 0;\n        }\n\n#if defined(POLARSSL_SSL_PROTO_SSL3)\n        if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 )\n        {\n            if( padlen \u003e ssl-\u003etransform_in-\u003eivlen )\n            {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n                SSL_DEBUG_MSG( 1, ( \"bad padding length: is %d, \"\n                                    \"should be no more than %d\",\n                               padlen, ssl-\u003etransform_in-\u003eivlen ) );\n#endif\n                correct = 0;\n            }\n        }\n        else\n#endif /* POLARSSL_SSL_PROTO_SSL3 */\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1) || \\\n    defined(POLARSSL_SSL_PROTO_TLS1_2)\n        if( ssl-\u003eminor_ver \u003e SSL_MINOR_VERSION_0 )\n        {\n            /*\n             * TLSv1+: always check the padding up to the first failure\n             * and fake check up to 256 bytes of padding\n             */\n            size_t pad_count = 0, real_count = 1;\n            size_t padding_idx = ssl-\u003ein_msglen - padlen - 1;\n\n            /*\n             * Padding is guaranteed to be incorrect if:\n             *   1. padlen \u003e= ssl-\u003ein_msglen\n             *\n             *   2. padding_idx \u003e= SSL_MAX_CONTENT_LEN +\n             *                     ssl-\u003etransform_in-\u003emaclen\n             *\n             * In both cases we reset padding_idx to a safe value (0) to\n             * prevent out-of-buffer reads.\n             */\n            correct \u0026= ( ssl-\u003ein_msglen \u003e= padlen + 1 );\n            correct \u0026= ( padding_idx \u003c SSL_MAX_CONTENT_LEN +\n                                       ssl-\u003etransform_in-\u003emaclen );\n\n            padding_idx *= correct;\n\n            for( i = 1; i \u003c= 256; i++ )\n            {\n                real_count \u0026= ( i \u003c= padlen );\n                pad_count += real_count *\n                             ( ssl-\u003ein_msg[padding_idx + i] == padlen - 1 );\n            }\n\n            correct \u0026= ( pad_count == padlen ); /* Only 1 on correct padding */\n\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            if( padlen \u003e 0 \u0026\u0026 correct == 0 )\n                SSL_DEBUG_MSG( 1, ( \"bad padding byte detected\" ) );\n#endif\n            padlen \u0026= correct * 0x1FF;\n        }\n        else\n#endif /* POLARSSL_SSL_PROTO_TLS1 || POLARSSL_SSL_PROTO_TLS1_1 || \\\n          POLARSSL_SSL_PROTO_TLS1_2 */\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        ssl-\u003ein_msglen -= padlen;\n    }\n    else\n#endif /* POLARSSL_CIPHER_MODE_CBC \u0026\u0026\n          ( POLARSSL_AES_C || POLARSSL_CAMELLIA_C ) */\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    SSL_DEBUG_BUF( 4, \"raw buffer after decryption\",\n                   ssl-\u003ein_msg, ssl-\u003ein_msglen );\n\n    /*\n     * Authenticate if not done yet.\n     * Compute the MAC regardless of the padding result (RFC4346, CBCTIME).\n     */\n#if defined(POLARSSL_SOME_MODES_USE_MAC)\n    if( auth_done == 0 )\n    {\n        unsigned char tmp[POLARSSL_SSL_MAX_MAC_SIZE];\n\n        ssl-\u003ein_msglen -= ssl-\u003etransform_in-\u003emaclen;\n\n        ssl-\u003ein_hdr[3] = (unsigned char)( ssl-\u003ein_msglen \u003e\u003e 8 );\n        ssl-\u003ein_hdr[4] = (unsigned char)( ssl-\u003ein_msglen      );\n\n        memcpy( tmp, ssl-\u003ein_msg + ssl-\u003ein_msglen, ssl-\u003etransform_in-\u003emaclen );\n\n#if defined(POLARSSL_SSL_PROTO_SSL3)\n        if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 )\n        {\n            ssl_mac( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec,\n                      ssl-\u003etransform_in-\u003emac_dec,\n                      ssl-\u003ein_msg, ssl-\u003ein_msglen,\n                      ssl-\u003ein_ctr, ssl-\u003ein_msgtype );\n        }\n        else\n#endif /* POLARSSL_SSL_PROTO_SSL3 */\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1) || \\\n        defined(POLARSSL_SSL_PROTO_TLS1_2)\n        if( ssl-\u003eminor_ver \u003e SSL_MINOR_VERSION_0 )\n        {\n            /*\n             * Process MAC and always update for padlen afterwards to make\n             * total time independent of padlen\n             *\n             * extra_run compensates MAC check for padlen\n             *\n             * Known timing attacks:\n             *  - Lucky Thirteen (http://www.isg.rhul.ac.uk/tls/TLStiming.pdf)\n             *\n             * We use ( ( Lx + 8 ) / 64 ) to handle 'negative Lx' values\n             * correctly. (We round down instead of up, so -56 is the correct\n             * value for our calculations instead of -55)\n             */\n            size_t j, extra_run = 0;\n            extra_run = ( 13 + ssl-\u003ein_msglen + padlen + 8 ) / 64 -\n                        ( 13 + ssl-\u003ein_msglen          + 8 ) / 64;\n\n            extra_run \u0026= correct * 0xFF;\n\n            md_hmac_update( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec, ssl-\u003ein_ctr, 13 );\n            md_hmac_update( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec, ssl-\u003ein_msg,\n                             ssl-\u003ein_msglen );\n            md_hmac_finish( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec,\n                             ssl-\u003ein_msg + ssl-\u003ein_msglen );\n            /* Call md_process at least once due to cache attacks */\n            for( j = 0; j \u003c extra_run + 1; j++ )\n                md_process( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec, ssl-\u003ein_msg );\n\n            md_hmac_reset( \u0026ssl-\u003etransform_in-\u003emd_ctx_dec );\n        }\n        else\n#endif /* POLARSSL_SSL_PROTO_TLS1 || POLARSSL_SSL_PROTO_TLS1_1 || \\\n              POLARSSL_SSL_PROTO_TLS1_2 */\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        SSL_DEBUG_BUF( 4, \"message  mac\", tmp, ssl-\u003etransform_in-\u003emaclen );\n        SSL_DEBUG_BUF( 4, \"computed mac\", ssl-\u003ein_msg + ssl-\u003ein_msglen,\n                       ssl-\u003etransform_in-\u003emaclen );\n\n        if( safer_memcmp( tmp, ssl-\u003ein_msg + ssl-\u003ein_msglen,\n                         ssl-\u003etransform_in-\u003emaclen ) != 0 )\n        {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            SSL_DEBUG_MSG( 1, ( \"message mac does not match\" ) );\n#endif\n            correct = 0;\n        }\n        auth_done++;\n\n        /*\n         * Finally check the correct flag\n         */\n        if( correct == 0 )\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n    }\n#endif /* POLARSSL_SOME_MODES_USE_MAC */\n\n    /* Make extra sure authentication was performed, exactly once */\n    if( auth_done != 1 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( ssl-\u003ein_msglen == 0 )\n    {\n        ssl-\u003enb_zero++;\n\n        /*\n         * Three or more empty messages may be a DoS attack\n         * (excessive CPU consumption).\n         */\n        if( ssl-\u003enb_zero \u003e 3 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"received four consecutive empty \"\n                                \"messages, possible DoS attack\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n    }\n    else\n        ssl-\u003enb_zero = 0;\n\n    for( i = 8; i \u003e 0; i-- )\n        if( ++ssl-\u003ein_ctr[i - 1] != 0 )\n            break;\n\n    /* The loops goes to its end iff the counter is wrapping */\n    if( i == 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"incoming message counter would wrap\" ) );\n        return( POLARSSL_ERR_SSL_COUNTER_WRAPPING );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= decrypt buf\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":1424,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.19-rc1"},"197506":{"score":0.641764,"function_name":"ssl_fetch_input","code":"int ssl_fetch_input( ssl_context *ssl, size_t nb_want )\n{\n    int ret;\n    size_t len;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e fetch input\" ) );\n\n    if( ssl-\u003ef_recv == NULL \u0026\u0026 ssl-\u003ef_recv_timeout == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"Bad usage of ssl_set_bio() \"\n                            \"or ssl_set_bio_timeout()\" ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    if( nb_want \u003e SSL_BUFFER_LEN - (size_t)( ssl-\u003ein_hdr - ssl-\u003ein_buf ) )\n    {\n        SSL_DEBUG_MSG( 1, ( \"requesting more data than fits\" ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n#if defined(POLARSSL_SSL_PROTO_DTLS)\n    if( ssl-\u003etransport == SSL_TRANSPORT_DATAGRAM )\n    {\n        uint32_t timeout;\n\n        /*\n         * The point is, we need to always read a full datagram at once, so we\n         * sometimes read more then requested, and handle the additional data.\n         * It could be the rest of the current record (while fetching the\n         * header) and/or some other records in the same datagram.\n         */\n\n        /*\n         * Move to the next record in the already read datagram if applicable\n         */\n        if( ssl-\u003enext_record_offset != 0 )\n        {\n            if( ssl-\u003ein_left \u003c ssl-\u003enext_record_offset )\n            {\n                SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n                return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n            }\n\n            ssl-\u003ein_left -= ssl-\u003enext_record_offset;\n\n            if( ssl-\u003ein_left != 0 )\n            {\n                SSL_DEBUG_MSG( 2, ( \"next record in same datagram, offset: %d\",\n                                    ssl-\u003enext_record_offset ) );\n                memmove( ssl-\u003ein_hdr,\n                         ssl-\u003ein_hdr + ssl-\u003enext_record_offset,\n                         ssl-\u003ein_left );\n            }\n\n            ssl-\u003enext_record_offset = 0;\n        }\n\n        SSL_DEBUG_MSG( 2, ( \"in_left: %d, nb_want: %d\",\n                       ssl-\u003ein_left, nb_want ) );\n\n        /*\n         * Done if we already have enough data.\n         */\n        if( nb_want \u003c= ssl-\u003ein_left)\n        {\n            SSL_DEBUG_MSG( 2, ( \"\u003c= fetch input\" ) );\n            return( 0 );\n        }\n\n        /*\n         * A record can't be split accross datagrams. If we need to read but\n         * are not at the beginning of a new record, the caller did something\n         * wrong.\n         */\n        if( ssl-\u003ein_left != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        SSL_DEBUG_MSG( 3, ( \"current timer: %u\", ssl-\u003etime_limit ) );\n\n        /*\n         * Don't even try to read if time's out already.\n         * This avoids by-passing the timer when repeatedly receiving messages\n         * that will end up being dropped.\n         */\n        if( ssl_check_timer( ssl ) != 0 )\n            ret = POLARSSL_ERR_NET_TIMEOUT;\n        else\n        {\n            len = SSL_BUFFER_LEN - ( ssl-\u003ein_hdr - ssl-\u003ein_buf );\n\n            if( ssl-\u003estate != SSL_HANDSHAKE_OVER )\n                timeout = ssl-\u003ehandshake-\u003eretransmit_timeout;\n            else\n                timeout = ssl-\u003eread_timeout;\n\n            SSL_DEBUG_MSG( 3, ( \"f_recv_timeout: %u ms\", timeout ) );\n\n            if( ssl-\u003ef_recv_timeout != NULL \u0026\u0026 timeout != 0 )\n                ret = ssl-\u003ef_recv_timeout( ssl-\u003ep_bio, ssl-\u003ein_hdr, len,\n                                                                    timeout );\n            else\n                ret = ssl-\u003ef_recv( ssl-\u003ep_bio, ssl-\u003ein_hdr, len );\n\n            SSL_DEBUG_RET( 2, \"ssl-\u003ef_recv(_timeout)\", ret );\n\n            if( ret == 0 )\n                return( POLARSSL_ERR_SSL_CONN_EOF );\n        }\n\n        if( ret == POLARSSL_ERR_NET_TIMEOUT )\n        {\n            SSL_DEBUG_MSG( 2, ( \"timeout\" ) );\n            ssl_set_timer( ssl, 0 );\n\n            if( ssl-\u003estate != SSL_HANDSHAKE_OVER )\n            {\n                if( ssl_double_retransmit_timeout( ssl ) != 0 )\n                {\n                    SSL_DEBUG_MSG( 1, ( \"handshake timeout\" ) );\n                    return( POLARSSL_ERR_NET_TIMEOUT );\n                }\n\n                if( ( ret = ssl_resend( ssl ) ) != 0 )\n                {\n                    SSL_DEBUG_RET( 1, \"ssl_resend\", ret );\n                    return( ret );\n                }\n\n                return( POLARSSL_ERR_NET_WANT_READ );\n            }\n#if defined(POLARSSL_SSL_SRV_C) \u0026\u0026 defined(POLARSSL_SSL_RENEGOTIATION)\n            else if( ssl-\u003eendpoint == SSL_IS_SERVER \u0026\u0026\n                     ssl-\u003erenegotiation == SSL_RENEGOTIATION_PENDING )\n            {\n                if( ( ret = ssl_resend_hello_request( ssl ) ) != 0 )\n                {\n                    SSL_DEBUG_RET( 1, \"ssl_resend_hello_request\", ret );\n                    return( ret );\n                }\n\n                return( POLARSSL_ERR_NET_WANT_READ );\n            }\n#endif /* POLARSSL_SSL_SRV_C \u0026\u0026 POLARSSL_SSL_RENEGOTIATION */\n        }\n\n        if( ret \u003c 0 )\n            return( ret );\n\n        ssl-\u003ein_left = ret;\n    }\n    else\n#endif\n    {\n        SSL_DEBUG_MSG( 2, ( \"in_left: %d, nb_want: %d\",\n                       ssl-\u003ein_left, nb_want ) );\n\n        while( ssl-\u003ein_left \u003c nb_want )\n        {\n            len = nb_want - ssl-\u003ein_left;\n            ret = ssl-\u003ef_recv( ssl-\u003ep_bio, ssl-\u003ein_hdr + ssl-\u003ein_left, len );\n\n            SSL_DEBUG_MSG( 2, ( \"in_left: %d, nb_want: %d\",\n                           ssl-\u003ein_left, nb_want ) );\n            SSL_DEBUG_RET( 2, \"ssl-\u003ef_recv\", ret );\n\n            if( ret == 0 )\n                return( POLARSSL_ERR_SSL_CONN_EOF );\n\n            if( ret \u003c 0 )\n                return( ret );\n\n            ssl-\u003ein_left += ret;\n        }\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= fetch input\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":2125,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.4-dtls-preview"},"197825":{"score":0.5469459,"function_name":"ssl_flush_output","code":"int ssl_flush_output( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *buf, i;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e flush output\" ) );\n\n    if( ssl-\u003ef_send == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"Bad usage of ssl_set_bio() \"\n                            \"or ssl_set_bio_timeout()\" ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /* Avoid incrementing counter if data is flushed */\n    if( ssl-\u003eout_left == 0 )\n    {\n        SSL_DEBUG_MSG( 2, ( \"\u003c= flush output\" ) );\n        return( 0 );\n    }\n\n    while( ssl-\u003eout_left \u003e 0 )\n    {\n        SSL_DEBUG_MSG( 2, ( \"message length: %d, out_left: %d\",\n                       ssl_hdr_len( ssl ) + ssl-\u003eout_msglen, ssl-\u003eout_left ) );\n\n        buf = ssl-\u003eout_hdr + ssl_hdr_len( ssl ) +\n              ssl-\u003eout_msglen - ssl-\u003eout_left;\n        ret = ssl-\u003ef_send( ssl-\u003ep_bio, buf, ssl-\u003eout_left );\n\n        SSL_DEBUG_RET( 2, \"ssl-\u003ef_send\", ret );\n\n        if( ret \u003c= 0 )\n            return( ret );\n\n        ssl-\u003eout_left -= ret;\n    }\n\n    for( i = 8; i \u003e ssl_ep_len( ssl ); i-- )\n        if( ++ssl-\u003eout_ctr[i - 1] != 0 )\n            break;\n\n    /* The loop goes to its end iff the counter is wrapping */\n    if( i == ssl_ep_len( ssl ) )\n    {\n        SSL_DEBUG_MSG( 1, ( \"outgoing message counter would wrap\" ) );\n        return( POLARSSL_ERR_SSL_COUNTER_WRAPPING );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= flush output\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":2311,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.4-dtls-preview"},"198073":{"score":0.48440945,"function_name":"mbedtls_ssl_write_handshake_msg","code":"int mbedtls_ssl_write_handshake_msg( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const size_t hs_len = ssl-\u003eout_msglen - 4;\n    const unsigned char hs_type = ssl-\u003eout_msg[0];\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e write handshake message\" ) );\n\n    /*\n     * Sanity checks\n     */\n    if( ssl-\u003eout_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE          \u0026\u0026\n        ssl-\u003eout_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )\n    {\n        /* In SSLv3, the client might send a NoCertificate alert. */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n        if( ! ( ssl-\u003eminor_ver      == MBEDTLS_SSL_MINOR_VERSION_0 \u0026\u0026\n                ssl-\u003eout_msgtype    == MBEDTLS_SSL_MSG_ALERT       \u0026\u0026\n                ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_CLIENT ) )\n#endif /* MBEDTLS_SSL_PROTO_SSL3 \u0026\u0026 MBEDTLS_SSL_SRV_C */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n    }\n\n    /* Whenever we send anything different from a\n     * HelloRequest we should be in a handshake - double check. */\n    if( ! ( ssl-\u003eout_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE \u0026\u0026\n            hs_type          == MBEDTLS_SSL_HS_HELLO_REQUEST ) \u0026\u0026\n        ssl-\u003ehandshake == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n        ssl-\u003ehandshake != NULL \u0026\u0026\n        ssl-\u003ehandshake-\u003eretransmit_state == MBEDTLS_SSL_RETRANS_SENDING )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n#endif\n\n    /* Double-check that we did not exceed the bounds\n     * of the outgoing record buffer.\n     * This should never fail as the various message\n     * writing functions must obey the bounds of the\n     * outgoing record buffer, but better be safe.\n     *\n     * Note: We deliberately do not check for the MTU or MFL here.\n     */\n    if( ssl-\u003eout_msglen \u003e MBEDTLS_SSL_OUT_CONTENT_LEN )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"Record too large: \"\n                                    \"size %u, maximum %u\",\n                                    (unsigned) ssl-\u003eout_msglen,\n                                    (unsigned) MBEDTLS_SSL_OUT_CONTENT_LEN ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    /*\n     * Fill handshake headers\n     */\n    if( ssl-\u003eout_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        ssl-\u003eout_msg[1] = (unsigned char)( hs_len \u003e\u003e 16 );\n        ssl-\u003eout_msg[2] = (unsigned char)( hs_len \u003e\u003e  8 );\n        ssl-\u003eout_msg[3] = (unsigned char)( hs_len       );\n\n        /*\n         * DTLS has additional fields in the Handshake layer,\n         * between the length field and the actual payload:\n         *      uint16 message_seq;\n         *      uint24 fragment_offset;\n         *      uint24 fragment_length;\n         */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        {\n            /* Make room for the additional DTLS fields */\n            if( MBEDTLS_SSL_OUT_CONTENT_LEN - ssl-\u003eout_msglen \u003c 8 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"DTLS handshake message too large: \"\n                              \"size %u, maximum %u\",\n                               (unsigned) ( hs_len ),\n                               (unsigned) ( MBEDTLS_SSL_OUT_CONTENT_LEN - 12 ) ) );\n                return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n            }\n\n            memmove( ssl-\u003eout_msg + 12, ssl-\u003eout_msg + 4, hs_len );\n            ssl-\u003eout_msglen += 8;\n\n            /* Write message_seq and update it, except for HelloRequest */\n            if( hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST )\n            {\n                ssl-\u003eout_msg[4] = ( ssl-\u003ehandshake-\u003eout_msg_seq \u003e\u003e 8 ) \u0026 0xFF;\n                ssl-\u003eout_msg[5] = ( ssl-\u003ehandshake-\u003eout_msg_seq      ) \u0026 0xFF;\n                ++( ssl-\u003ehandshake-\u003eout_msg_seq );\n            }\n            else\n            {\n                ssl-\u003eout_msg[4] = 0;\n                ssl-\u003eout_msg[5] = 0;\n            }\n\n            /* Handshake hashes are computed without fragmentation,\n             * so set frag_offset = 0 and frag_len = hs_len for now */\n            memset( ssl-\u003eout_msg + 6, 0x00, 3 );\n            memcpy( ssl-\u003eout_msg + 9, ssl-\u003eout_msg + 1, 3 );\n        }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n        /* Update running hashes of handshake messages seen */\n        if( hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST )\n            ssl-\u003ehandshake-\u003eupdate_checksum( ssl, ssl-\u003eout_msg, ssl-\u003eout_msglen );\n    }\n\n    /* Either send now, or just save to be sent (and resent) later */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n        ! ( ssl-\u003eout_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE \u0026\u0026\n            hs_type          == MBEDTLS_SSL_HS_HELLO_REQUEST ) )\n    {\n        if( ( ret = ssl_flight_append( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_flight_append\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif\n    {\n        if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n            return( ret );\n        }\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= write handshake message\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":3483,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"198982":{"score":0.54042995,"function_name":"ssl_get_remaining_payload_in_datagram","code":"static int ssl_get_remaining_payload_in_datagram( mbedtls_ssl_context const *ssl )\n{\n    int ret;\n    size_t remaining, expansion;\n    size_t max_len = MBEDTLS_SSL_OUT_CONTENT_LEN;\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    const size_t mfl = mbedtls_ssl_get_max_frag_len( ssl );\n\n    if( max_len \u003e mfl )\n        max_len = mfl;\n\n    /* By the standard (RFC 6066 Sect. 4), the MFL extension\n     * only limits the maximum record payload size, so in theory\n     * we would be allowed to pack multiple records of payload size\n     * MFL into a single datagram. However, this would mean that there's\n     * no way to explicitly communicate MTU restrictions to the peer.\n     *\n     * The following reduction of max_len makes sure that we never\n     * write datagrams larger than MFL + Record Expansion Overhead.\n     */\n    if( max_len \u003c= ssl-\u003eout_left )\n        return( 0 );\n\n    max_len -= ssl-\u003eout_left;\n#endif\n\n    ret = ssl_get_remaining_space_in_datagram( ssl );\n    if( ret \u003c 0 )\n        return( ret );\n    remaining = (size_t) ret;\n\n    ret = mbedtls_ssl_get_record_expansion( ssl );\n    if( ret \u003c 0 )\n        return( ret );\n    expansion = (size_t) ret;\n\n    if( remaining \u003c= expansion )\n        return( 0 );\n\n    remaining -= expansion;\n    if( remaining \u003e= max_len )\n        remaining = max_len;\n\n    return( (int) remaining );\n}","filepath":"library/ssl_tls.c","line_number":159,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"199090":{"score":0.6599393,"function_name":"mbedtls_ssl_update_handshake_status","code":"void mbedtls_ssl_update_handshake_status( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_handshake_params * const hs = ssl-\u003ehandshake;\n\n    if( ssl-\u003estate != MBEDTLS_SSL_HANDSHAKE_OVER \u0026\u0026 hs != NULL )\n    {\n        ssl-\u003ehandshake-\u003eupdate_checksum( ssl, ssl-\u003ein_msg, ssl-\u003ein_hslen );\n    }\n\n    /* Handshake message is complete, increment counter */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n        ssl-\u003ehandshake != NULL )\n    {\n        unsigned offset;\n        mbedtls_ssl_hs_buffer *hs_buf;\n\n        /* Increment handshake sequence number */\n        hs-\u003ein_msg_seq++;\n\n        /*\n         * Clear up handshake buffering and reassembly structure.\n         */\n\n        /* Free first entry */\n        ssl_buffering_free_slot( ssl, 0 );\n\n        /* Shift all other entries */\n        for( offset = 0, hs_buf = \u0026hs-\u003ebuffering.hs[0];\n             offset + 1 \u003c MBEDTLS_SSL_MAX_BUFFERED_HS;\n             offset++, hs_buf++ )\n        {\n            *hs_buf = *(hs_buf + 1);\n        }\n\n        /* Create a fresh last entry */\n        memset( hs_buf, 0, sizeof( mbedtls_ssl_hs_buffer ) );\n    }\n#endif\n}","filepath":"library/ssl_tls.c","line_number":4010,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"199172":{"score":0.5150379,"function_name":"ssl_parse_record_header","code":"static int ssl_parse_record_header( ssl_context *ssl )\n{\n    int ret;\n    int major_ver, minor_ver;\n\n    SSL_DEBUG_BUF( 4, \"input record header\", ssl-\u003ein_hdr, ssl_hdr_len( ssl ) );\n\n    ssl-\u003ein_msgtype =  ssl-\u003ein_hdr[0];\n    ssl-\u003ein_msglen = ( ssl-\u003ein_len[0] \u003c\u003c 8 ) | ssl-\u003ein_len[1];\n    ssl_read_version( \u0026major_ver, \u0026minor_ver, ssl-\u003etransport, ssl-\u003ein_hdr + 1 );\n\n    SSL_DEBUG_MSG( 3, ( \"input record: msgtype = %d, \"\n                        \"version = [%d:%d], msglen = %d\",\n                        ssl-\u003ein_msgtype,\n                        major_ver, minor_ver, ssl-\u003ein_msglen ) );\n\n    /* Check record type */\n    if( ssl-\u003ein_msgtype != SSL_MSG_HANDSHAKE \u0026\u0026\n        ssl-\u003ein_msgtype != SSL_MSG_ALERT \u0026\u0026\n        ssl-\u003ein_msgtype != SSL_MSG_CHANGE_CIPHER_SPEC \u0026\u0026\n        ssl-\u003ein_msgtype != SSL_MSG_APPLICATION_DATA )\n    {\n        SSL_DEBUG_MSG( 1, ( \"unknown record type\" ) );\n\n        if( ( ret = ssl_send_alert_message( ssl,\n                        SSL_ALERT_LEVEL_FATAL,\n                        SSL_ALERT_MSG_UNEXPECTED_MESSAGE ) ) != 0 )\n        {\n            return( ret );\n        }\n\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n#if defined(POLARSSL_SSL_PROTO_DTLS)\n    if( ssl-\u003etransport == SSL_TRANSPORT_DATAGRAM )\n    {\n        /* Drop unexpected ChangeCipherSpec messages */\n        if( ssl-\u003ein_msgtype == SSL_MSG_CHANGE_CIPHER_SPEC \u0026\u0026\n            ssl-\u003estate != SSL_CLIENT_CHANGE_CIPHER_SPEC \u0026\u0026\n            ssl-\u003estate != SSL_SERVER_CHANGE_CIPHER_SPEC )\n        {\n            SSL_DEBUG_MSG( 1, ( \"dropping unexpected ChangeCipherSpec\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n        /* Drop unexpected ApplicationData records,\n         * except at the beginning of renegotiations */\n        if( ssl-\u003ein_msgtype == SSL_MSG_APPLICATION_DATA \u0026\u0026\n            ssl-\u003estate != SSL_HANDSHAKE_OVER \u0026\u0026\n            ! ( ssl-\u003erenegotiation == SSL_RENEGOTIATION \u0026\u0026\n                ssl-\u003estate == SSL_SERVER_HELLO ) )\n        {\n            SSL_DEBUG_MSG( 1, ( \"dropping unexpected ApplicationData\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n#endif\n\n    /* Check version */\n    if( major_ver != ssl-\u003emajor_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"major version mismatch\" ) );\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    if( minor_ver \u003e ssl-\u003emax_minor_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"minor version mismatch\" ) );\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    /* Check epoch (and sequence number) with DTLS */\n#if defined(POLARSSL_SSL_PROTO_DTLS)\n    if( ssl-\u003etransport == SSL_TRANSPORT_DATAGRAM )\n    {\n        unsigned int rec_epoch = ( ssl-\u003ein_ctr[0] \u003c\u003c 8 ) | ssl-\u003ein_ctr[1];\n\n        if( rec_epoch != ssl-\u003ein_epoch )\n        {\n            SSL_DEBUG_MSG( 1, ( \"record from another epoch: \"\n                                \"expected %d, received %d\",\n                                 ssl-\u003ein_epoch, rec_epoch ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n#if defined(POLARSSL_SSL_DTLS_ANTI_REPLAY)\n        if( ssl_dtls_replay_check( ssl ) != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"replayed record\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n#endif\n    }\n#endif /* POLARSSL_SSL_PROTO_DTLS */\n\n    /* Check length against the size of our buffer */\n    if( ssl-\u003ein_msglen \u003e SSL_BUFFER_LEN\n                         - (size_t)( ssl-\u003ein_msg - ssl-\u003ein_buf ) )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n        return( POLARSSL_ERR_SSL_INVALID_RECORD );\n    }\n\n    /* Check length against bounds of the current transform and version */\n    if( ssl-\u003etransform_in == NULL )\n    {\n        if( ssl-\u003ein_msglen \u003c 1 ||\n            ssl-\u003ein_msglen \u003e SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n    }\n    else\n    {\n        if( ssl-\u003ein_msglen \u003c ssl-\u003etransform_in-\u003eminlen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n\n#if defined(POLARSSL_SSL_PROTO_SSL3)\n        if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 \u0026\u0026\n            ssl-\u003ein_msglen \u003e ssl-\u003etransform_in-\u003eminlen + SSL_MAX_CONTENT_LEN )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n#endif\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1) || \\\n    defined(POLARSSL_SSL_PROTO_TLS1_2)\n        /*\n         * TLS encrypted messages can have up to 256 bytes of padding\n         */\n        if( ssl-\u003eminor_ver \u003e= SSL_MINOR_VERSION_1 \u0026\u0026\n            ssl-\u003ein_msglen \u003e ssl-\u003etransform_in-\u003eminlen +\n                             SSL_MAX_CONTENT_LEN + 256 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad message length\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_RECORD );\n        }\n#endif\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":3158,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.4-dtls-preview"},"199702":{"score":0.5123252,"function_name":"mbedtls_ssl_read_record","code":"int mbedtls_ssl_read_record( mbedtls_ssl_context *ssl,\n                             unsigned update_hs_digest )\n{\n    int ret;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e read record\" ) );\n\n    if( ssl-\u003ekeep_current_message == 0 )\n    {\n        do {\n\n            ret = ssl_consume_current_message( ssl );\n            if( ret != 0 )\n                return( ret );\n\n            if( ssl_record_is_in_progress( ssl ) == 0 )\n            {\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n                int have_buffered = 0;\n\n                /* We only check for buffered messages if the\n                 * current datagram is fully consumed. */\n                if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n                    ssl_next_record_is_in_datagram( ssl ) == 0 )\n                {\n                    if( ssl_load_buffered_message( ssl ) == 0 )\n                        have_buffered = 1;\n                }\n\n                if( have_buffered == 0 )\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n                {\n                    ret = ssl_get_next_record( ssl );\n                    if( ret == MBEDTLS_ERR_SSL_CONTINUE_PROCESSING )\n                        continue;\n\n                    if( ret != 0 )\n                    {\n                        MBEDTLS_SSL_DEBUG_RET( 1, ( \"ssl_get_next_record\" ), ret );\n                        return( ret );\n                    }\n                }\n            }\n\n            ret = mbedtls_ssl_handle_message_type( ssl );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n            if( ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE )\n            {\n                /* Buffer future message */\n                ret = ssl_buffer_message( ssl );\n                if( ret != 0 )\n                    return( ret );\n\n                ret = MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;\n            }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n        } while( MBEDTLS_ERR_SSL_NON_FATAL           == ret  ||\n                 MBEDTLS_ERR_SSL_CONTINUE_PROCESSING == ret );\n\n        if( 0 != ret )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ssl_handle_message_type\" ), ret );\n            return( ret );\n        }\n\n        if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE \u0026\u0026\n            update_hs_digest == 1 )\n        {\n            mbedtls_ssl_update_handshake_status( ssl );\n        }\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"reuse previously read message\" ) );\n        ssl-\u003ekeep_current_message = 0;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= read record\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":4611,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"199923":{"score":0.7381244,"function_name":"ssl_consume_current_message","code":"static int ssl_consume_current_message( mbedtls_ssl_context *ssl )\n{\n    /*\n     * Consume last content-layer message and potentially\n     * update in_msglen which keeps track of the contents'\n     * consumption state.\n     *\n     * (1) Handshake messages:\n     *     Remove last handshake message, move content\n     *     and adapt in_msglen.\n     *\n     * (2) Alert messages:\n     *     Consume whole record content, in_msglen = 0.\n     *\n     * (3) Change cipher spec:\n     *     Consume whole record content, in_msglen = 0.\n     *\n     * (4) Application data:\n     *     Don't do anything - the record layer provides\n     *     the application data as a stream transport\n     *     and consumes through mbedtls_ssl_read only.\n     *\n     */\n\n    /* Case (1): Handshake messages */\n    if( ssl-\u003ein_hslen != 0 )\n    {\n        /* Hard assertion to be sure that no application data\n         * is in flight, as corrupting ssl-\u003ein_msglen during\n         * ssl-\u003ein_offt != NULL is fatal. */\n        if( ssl-\u003ein_offt != NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        /*\n         * Get next Handshake message in the current record\n         */\n\n        /* Notes:\n         * (1) in_hslen is not necessarily the size of the\n         *     current handshake content: If DTLS handshake\n         *     fragmentation is used, that's the fragment\n         *     size instead. Using the total handshake message\n         *     size here is faulty and should be changed at\n         *     some point.\n         * (2) While it doesn't seem to cause problems, one\n         *     has to be very careful not to assume that in_hslen\n         *     is always \u003c= in_msglen in a sensible communication.\n         *     Again, it's wrong for DTLS handshake fragmentation.\n         *     The following check is therefore mandatory, and\n         *     should not be treated as a silently corrected assertion.\n         *     Additionally, ssl-\u003ein_hslen might be arbitrarily out of\n         *     bounds after handling a DTLS message with an unexpected\n         *     sequence number, see mbedtls_ssl_prepare_handshake_record.\n         */\n        if( ssl-\u003ein_hslen \u003c ssl-\u003ein_msglen )\n        {\n            ssl-\u003ein_msglen -= ssl-\u003ein_hslen;\n            memmove( ssl-\u003ein_msg, ssl-\u003ein_msg + ssl-\u003ein_hslen,\n                     ssl-\u003ein_msglen );\n\n            MBEDTLS_SSL_DEBUG_BUF( 4, \"remaining content in record\",\n                                   ssl-\u003ein_msg, ssl-\u003ein_msglen );\n        }\n        else\n        {\n            ssl-\u003ein_msglen = 0;\n        }\n\n        ssl-\u003ein_hslen   = 0;\n    }\n    /* Case (4): Application data */\n    else if( ssl-\u003ein_offt != NULL )\n    {\n        return( 0 );\n    }\n    /* Everything else (CCS \u0026 Alerts) */\n    else\n    {\n        ssl-\u003ein_msglen = 0;\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5036,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"200146":{"score":0.488949,"function_name":"ssl_get_next_record","code":"static int ssl_get_next_record( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    /* We might have buffered a future record; if so,\n     * and if the epoch matches now, load it.\n     * On success, this call will set ssl-\u003ein_left to\n     * the length of the buffered record, so that\n     * the calls to ssl_fetch_input() below will\n     * essentially be no-ops. */\n    ret = ssl_load_buffered_record( ssl );\n    if( ret != 0 )\n        return( ret );\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n    if( ( ret = mbedtls_ssl_fetch_input( ssl, mbedtls_ssl_hdr_len( ssl ) ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    if( ( ret = ssl_parse_record_header( ssl ) ) != 0 )\n    {\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n            ret != MBEDTLS_ERR_SSL_CLIENT_RECONNECT )\n        {\n            if( ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE )\n            {\n                ret = ssl_buffer_future_record( ssl );\n                if( ret != 0 )\n                    return( ret );\n\n                /* Fall through to handling of unexpected records */\n                ret = MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;\n            }\n\n            if( ret == MBEDTLS_ERR_SSL_UNEXPECTED_RECORD )\n            {\n                /* Skip unexpected record (but not whole datagram) */\n                ssl-\u003enext_record_offset = ssl-\u003ein_msglen\n                                        + mbedtls_ssl_hdr_len( ssl );\n\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"discarding unexpected record \"\n                                            \"(header)\" ) );\n            }\n            else\n            {\n                /* Skip invalid record and the rest of the datagram */\n                ssl-\u003enext_record_offset = 0;\n                ssl-\u003ein_left = 0;\n\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"discarding invalid record \"\n                                            \"(header)\" ) );\n            }\n\n            /* Get next record */\n            return( MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );\n        }\n#endif\n        return( ret );\n    }\n\n    /*\n     * Read and optionally decrypt the message contents\n     */\n    if( ( ret = mbedtls_ssl_fetch_input( ssl,\n                                 mbedtls_ssl_hdr_len( ssl ) + ssl-\u003ein_msglen ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_fetch_input\", ret );\n        return( ret );\n    }\n\n    /* Done reading this record, get ready for the next one */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        ssl-\u003enext_record_offset = ssl-\u003ein_msglen + mbedtls_ssl_hdr_len( ssl );\n        if( ssl-\u003enext_record_offset \u003c ssl-\u003ein_left )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"more than one record within datagram\" ) );\n        }\n    }\n    else\n#endif\n        ssl-\u003ein_left = 0;\n\n    if( ( ret = ssl_prepare_record_content( ssl ) ) != 0 )\n    {\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        {\n            /* Silently discard invalid records */\n            if( ret == MBEDTLS_ERR_SSL_INVALID_RECORD ||\n                ret == MBEDTLS_ERR_SSL_INVALID_MAC )\n            {\n                /* Except when waiting for Finished as a bad mac here\n                 * probably means something went wrong in the handshake\n                 * (eg wrong psk used, mitm downgrade attempt, etc.) */\n                if( ssl-\u003estate == MBEDTLS_SSL_CLIENT_FINISHED ||\n                    ssl-\u003estate == MBEDTLS_SSL_SERVER_FINISHED )\n                {\n#if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)\n                    if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )\n                    {\n                        mbedtls_ssl_send_alert_message( ssl,\n                                MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC );\n                    }\n#endif\n                    return( ret );\n                }\n\n#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)\n                if( ssl-\u003econf-\u003ebadmac_limit != 0 \u0026\u0026\n                    ++ssl-\u003ebadmac_seen \u003e= ssl-\u003econf-\u003ebadmac_limit )\n                {\n                    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"too many records with bad MAC\" ) );\n                    return( MBEDTLS_ERR_SSL_INVALID_MAC );\n                }\n#endif\n\n                /* As above, invalid records cause\n                 * dismissal of the whole datagram. */\n\n                ssl-\u003enext_record_offset = 0;\n                ssl-\u003ein_left = 0;\n\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"discarding invalid record (mac)\" ) );\n                return( MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );\n            }\n\n            return( ret );\n        }\n        else\n#endif\n        {\n            /* Error out (and send alert) on invalid records */\n#if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)\n            if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )\n            {\n                mbedtls_ssl_send_alert_message( ssl,\n                        MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                        MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC );\n            }\n#endif\n            return( ret );\n        }\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5260,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"200358":{"score":0.53362364,"function_name":"mbedtls_ssl_handle_message_type","code":"int mbedtls_ssl_handle_message_type( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    /*\n     * Handle particular types of records\n     */\n    if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        if( ( ret = mbedtls_ssl_prepare_handshake_record( ssl ) ) != 0 )\n        {\n            return( ret );\n        }\n    }\n\n    if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )\n    {\n        if( ssl-\u003ein_msglen != 1 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid CCS message, len: %d\",\n                           ssl-\u003ein_msglen ) );\n            return( MBEDTLS_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl-\u003ein_msg[0] != 1 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid CCS message, content: %02x\",\n                                        ssl-\u003ein_msg[0] ) );\n            return( MBEDTLS_ERR_SSL_INVALID_RECORD );\n        }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n            ssl-\u003estate != MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC    \u0026\u0026\n            ssl-\u003estate != MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC )\n        {\n            if( ssl-\u003ehandshake == NULL )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"dropping ChangeCipherSpec outside handshake\" ) );\n                return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );\n            }\n\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"received out-of-order ChangeCipherSpec - remember\" ) );\n            return( MBEDTLS_ERR_SSL_EARLY_MESSAGE );\n        }\n#endif\n    }\n\n    if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_ALERT )\n    {\n        if( ssl-\u003ein_msglen != 2 )\n        {\n            /* Note: Standard allows for more than one 2 byte alert\n               to be packed in a single message, but Mbed TLS doesn't\n               currently support this. */\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid alert message, len: %d\",\n                           ssl-\u003ein_msglen ) );\n            return( MBEDTLS_ERR_SSL_INVALID_RECORD );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"got an alert message, type: [%d:%d]\",\n                       ssl-\u003ein_msg[0], ssl-\u003ein_msg[1] ) );\n\n        /*\n         * Ignore non-fatal alerts, except close_notify and no_renegotiation\n         */\n        if( ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"is a fatal alert message (msg %d)\",\n                           ssl-\u003ein_msg[1] ) );\n            return( MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE );\n        }\n\n        if( ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING \u0026\u0026\n            ssl-\u003ein_msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"is a close notify message\" ) );\n            return( MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY );\n        }\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION_ENABLED)\n        if( ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING \u0026\u0026\n            ssl-\u003ein_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"is a SSLv3 no renegotiation alert\" ) );\n            /* Will be handled when trying to parse ServerHello */\n            return( 0 );\n        }\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) \u0026\u0026 defined(MBEDTLS_SSL_SRV_C)\n        if( ssl-\u003eminor_ver == MBEDTLS_SSL_MINOR_VERSION_0 \u0026\u0026\n            ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n            ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING \u0026\u0026\n            ssl-\u003ein_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_CERT )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"is a SSLv3 no_cert\" ) );\n            /* Will be handled in mbedtls_ssl_parse_certificate() */\n            return( 0 );\n        }\n#endif /* MBEDTLS_SSL_PROTO_SSL3 \u0026\u0026 MBEDTLS_SSL_SRV_C */\n\n        /* Silently ignore: fetch new message */\n        return MBEDTLS_ERR_SSL_NON_FATAL;\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n        ssl-\u003ehandshake != NULL \u0026\u0026\n        ssl-\u003estate == MBEDTLS_SSL_HANDSHAKE_OVER  )\n    {\n        ssl_handshake_wrapup_free_hs_transform( ssl );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5414,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"200603":{"score":0.6842023,"function_name":"mbedtls_ssl_send_fatal_handshake_failure","code":"int mbedtls_ssl_send_fatal_handshake_failure( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    if( ( ret = mbedtls_ssl_send_alert_message( ssl,\n                    MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                    MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5532,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"200658":{"score":0.5747467,"function_name":"mbedtls_ssl_send_alert_message","code":"int mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,\n                            unsigned char level,\n                            unsigned char message )\n{\n    int ret;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e send alert message\" ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"send alert level=%u message=%u\", level, message ));\n\n    ssl-\u003eout_msgtype = MBEDTLS_SSL_MSG_ALERT;\n    ssl-\u003eout_msglen = 2;\n    ssl-\u003eout_msg[0] = level;\n    ssl-\u003eout_msg[1] = message;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= send alert message\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5546,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"201326":{"score":0.5265146,"function_name":"ssl_parse_certificate_chain","code":"static int ssl_parse_certificate_chain( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n    uint8_t alert;\n\n#if defined(MBEDTLS_SSL_SRV_C)\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl-\u003econf-\u003eendpoint  == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        ssl-\u003eminor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        if( ssl-\u003ein_msglen  == 2                        \u0026\u0026\n            ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_ALERT            \u0026\u0026\n            ssl-\u003ein_msg[0]  == MBEDTLS_SSL_ALERT_LEVEL_WARNING  \u0026\u0026\n            ssl-\u003ein_msg[1]  == MBEDTLS_SSL_ALERT_MSG_NO_CERT )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"SSLv3 client has no certificate\" ) );\n\n            /* The client was asked for a certificate but didn't send\n               one. The client should know what's going on, so we\n               don't send an alert. */\n            ssl-\u003esession_negotiate-\u003everify_result = MBEDTLS_X509_BADCERT_MISSING;\n            return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_SSL3 */\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl-\u003econf-\u003eendpoint  == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        ssl-\u003eminor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        if( ssl-\u003ein_hslen   == 3 + mbedtls_ssl_hs_hdr_len( ssl ) \u0026\u0026\n            ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    \u0026\u0026\n            ssl-\u003ein_msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   \u0026\u0026\n            memcmp( ssl-\u003ein_msg + mbedtls_ssl_hs_hdr_len( ssl ), \"\\0\\0\\0\", 3 ) == 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"TLSv1 client has no certificate\" ) );\n\n            /* The client was asked for a certificate but didn't send\n               one. The client should know what's going on, so we\n               don't send an alert. */\n            ssl-\u003esession_negotiate-\u003everify_result = MBEDTLS_X509_BADCERT_MISSING;\n            return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n#endif /* MBEDTLS_SSL_SRV_C */\n\n    if( ssl-\u003ein_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl-\u003ein_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||\n        ssl-\u003ein_hslen \u003c mbedtls_ssl_hs_hdr_len( ssl ) + 3 + 3 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    i = mbedtls_ssl_hs_hdr_len( ssl );\n\n    /*\n     * Same message structure as in mbedtls_ssl_write_certificate()\n     */\n    n = ( ssl-\u003ein_msg[i+1] \u003c\u003c 8 ) | ssl-\u003ein_msg[i+2];\n\n    if( ssl-\u003ein_msg[i] != 0 ||\n        ssl-\u003ein_hslen != n + 3 + mbedtls_ssl_hs_hdr_len( ssl ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /* In case we tried to reuse a session but it failed */\n    if( ssl-\u003esession_negotiate-\u003epeer_cert != NULL )\n    {\n        mbedtls_x509_crt_free( ssl-\u003esession_negotiate-\u003epeer_cert );\n        mbedtls_free( ssl-\u003esession_negotiate-\u003epeer_cert );\n    }\n\n    if( ( ssl-\u003esession_negotiate-\u003epeer_cert = mbedtls_calloc( 1,\n                    sizeof( mbedtls_x509_crt ) ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc(%d bytes) failed\",\n                       sizeof( mbedtls_x509_crt ) ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    mbedtls_x509_crt_init( ssl-\u003esession_negotiate-\u003epeer_cert );\n\n    i += 3;\n\n    while( i \u003c ssl-\u003ein_hslen )\n    {\n        if ( i + 3 \u003e ssl-\u003ein_hslen ) {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                           MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n        if( ssl-\u003ein_msg[i] != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl-\u003ein_msg[i + 1] \u003c\u003c 8 )\n            | (unsigned int) ssl-\u003ein_msg[i + 2];\n        i += 3;\n\n        if( n \u003c 128 || i + n \u003e ssl-\u003ein_hslen )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = mbedtls_x509_crt_parse_der( ssl-\u003esession_negotiate-\u003epeer_cert,\n                                  ssl-\u003ein_msg + i, n );\n        switch( ret )\n        {\n        case 0: /*ok*/\n        case MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND:\n            /* Ignore certificate with an unknown algorithm: maybe a\n               prior certificate was already trusted. */\n            break;\n\n        case MBEDTLS_ERR_X509_ALLOC_FAILED:\n            alert = MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR;\n            goto crt_parse_der_failed;\n\n        case MBEDTLS_ERR_X509_UNKNOWN_VERSION:\n            alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            goto crt_parse_der_failed;\n\n        default:\n            alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;\n        crt_parse_der_failed:\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, alert );\n            MBEDTLS_SSL_DEBUG_RET( 1, \" mbedtls_x509_crt_parse_der\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    MBEDTLS_SSL_DEBUG_CRT( 3, \"peer certificate\", ssl-\u003esession_negotiate-\u003epeer_cert );\n\n    /*\n     * On client, make sure the server cert doesn't change during renego to\n     * avoid \"triple handshake\" attack: https://secure-resumption.com/\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_CLIENT \u0026\u0026\n        ssl-\u003erenego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n    {\n        if( ssl-\u003esession-\u003epeer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"new server cert during renegotiation\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        if( ssl-\u003esession-\u003epeer_cert-\u003eraw.len !=\n            ssl-\u003esession_negotiate-\u003epeer_cert-\u003eraw.len ||\n            memcmp( ssl-\u003esession-\u003epeer_cert-\u003eraw.p,\n                    ssl-\u003esession_negotiate-\u003epeer_cert-\u003eraw.p,\n                    ssl-\u003esession-\u003epeer_cert-\u003eraw.len ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server cert changed during renegotiation\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION \u0026\u0026 MBEDTLS_SSL_CLI_C */\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5722,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.12"},"202096":{"score":0.6577097,"function_name":"mbedtls_ssl_parse_certificate","code":"int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t * const ciphersuite_info =\n          ssl-\u003etransform_negotiate-\u003eciphersuite_info;\n#if defined(MBEDTLS_SSL_SRV_C) \u0026\u0026 defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    const int authmode = ssl-\u003ehandshake-\u003esni_authmode != MBEDTLS_SSL_VERIFY_UNSET\n                       ? ssl-\u003ehandshake-\u003esni_authmode\n                       : ssl-\u003econf-\u003eauthmode;\n#else\n    const int authmode = ssl-\u003econf-\u003eauthmode;\n#endif\n    void *rs_ctx = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e parse certificate\" ) );\n\n    if( ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_SSL_SRV_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        authmode == MBEDTLS_SSL_VERIFY_NONE )\n    {\n        ssl-\u003esession_negotiate-\u003everify_result = MBEDTLS_X509_BADCERT_SKIP_VERIFY;\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate\" ) );\n\n        ssl-\u003estate++;\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n    if( ssl-\u003ehandshake-\u003eecrs_enabled \u0026\u0026\n        ssl-\u003ehandshake-\u003eecrs_state == ssl_ecrs_crt_verify )\n    {\n        goto crt_verify;\n    }\n#endif\n\n    if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )\n    {\n        /* mbedtls_ssl_read_record may have sent an alert already. We\n           let it decide whether to alert. */\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ( ret = ssl_parse_certificate_chain( ssl ) ) != 0 )\n    {\n#if defined(MBEDTLS_SSL_SRV_C)\n        if( ret == MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE \u0026\u0026\n            authmode == MBEDTLS_SSL_VERIFY_OPTIONAL )\n        {\n            ret = 0;\n        }\n#endif\n\n        ssl-\u003estate++;\n        return( ret );\n    }\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n    if( ssl-\u003ehandshake-\u003eecrs_enabled)\n        ssl-\u003ehandshake-\u003eecrs_state = ssl_ecrs_crt_verify;\n\ncrt_verify:\n    if( ssl-\u003ehandshake-\u003eecrs_enabled)\n        rs_ctx = \u0026ssl-\u003ehandshake-\u003eecrs_ctx;\n#endif\n\n    if( authmode != MBEDTLS_SSL_VERIFY_NONE )\n    {\n        mbedtls_x509_crt *ca_chain;\n        mbedtls_x509_crl *ca_crl;\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n        if( ssl-\u003ehandshake-\u003esni_ca_chain != NULL )\n        {\n            ca_chain = ssl-\u003ehandshake-\u003esni_ca_chain;\n            ca_crl   = ssl-\u003ehandshake-\u003esni_ca_crl;\n        }\n        else\n#endif\n        {\n            ca_chain = ssl-\u003econf-\u003eca_chain;\n            ca_crl   = ssl-\u003econf-\u003eca_crl;\n        }\n\n        /*\n         * Main check: verify certificate\n         */\n        ret = mbedtls_x509_crt_verify_restartable(\n                                ssl-\u003esession_negotiate-\u003epeer_cert,\n                                ca_chain, ca_crl,\n                                ssl-\u003econf-\u003ecert_profile,\n                                ssl-\u003ehostname,\n                               \u0026ssl-\u003esession_negotiate-\u003everify_result,\n                                ssl-\u003econf-\u003ef_vrfy, ssl-\u003econf-\u003ep_vrfy, rs_ctx );\n\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"x509_verify_cert\", ret );\n        }\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n        if( ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n            return( MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS );\n#endif\n\n        /*\n         * Secondary checks: always done, but change 'ret' only if it was 0\n         */\n\n#if defined(MBEDTLS_ECP_C)\n        {\n            const mbedtls_pk_context *pk = \u0026ssl-\u003esession_negotiate-\u003epeer_cert-\u003epk;\n\n            /* If certificate uses an EC key, make sure the curve is OK */\n            if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECKEY ) \u0026\u0026\n                mbedtls_ssl_check_curve( ssl, mbedtls_pk_ec( *pk )-\u003egrp.id ) != 0 )\n            {\n                ssl-\u003esession_negotiate-\u003everify_result |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate (EC key curve)\" ) );\n                if( ret == 0 )\n                    ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;\n            }\n        }\n#endif /* MBEDTLS_ECP_C */\n\n        if( mbedtls_ssl_check_cert_usage( ssl-\u003esession_negotiate-\u003epeer_cert,\n                                 ciphersuite_info,\n                                 ! ssl-\u003econf-\u003eendpoint,\n                                 \u0026ssl-\u003esession_negotiate-\u003everify_result ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate (usage extensions)\" ) );\n            if( ret == 0 )\n                ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;\n        }\n\n        /* mbedtls_x509_crt_verify_with_profile is supposed to report a\n         * verification failure through MBEDTLS_ERR_X509_CERT_VERIFY_FAILED,\n         * with details encoded in the verification flags. All other kinds\n         * of error codes, including those from the user provided f_vrfy\n         * functions, are treated as fatal and lead to a failure of\n         * ssl_parse_certificate even if verification was optional. */\n        if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL \u0026\u0026\n            ( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED ||\n              ret == MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE ) )\n        {\n            ret = 0;\n        }\n\n        if( ca_chain == NULL \u0026\u0026 authmode == MBEDTLS_SSL_VERIFY_REQUIRED )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no CA chain\" ) );\n            ret = MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED;\n        }\n\n        if( ret != 0 )\n        {\n            uint8_t alert;\n\n            /* The certificate may have been rejected for several reasons.\n               Pick one and send the corresponding alert. Which alert to send\n               may be a subject of debate in some cases. */\n            if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_OTHER )\n                alert = MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_CN_MISMATCH )\n                alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_KEY_USAGE )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_EXT_KEY_USAGE )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_NS_CERT_TYPE )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_BAD_PK )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_BAD_KEY )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_EXPIRED )\n                alert = MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_REVOKED )\n                alert = MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_NOT_TRUSTED )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA;\n            else\n                alert = MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN;\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            alert );\n        }\n\n#if defined(MBEDTLS_DEBUG_C)\n        if( ssl-\u003esession_negotiate-\u003everify_result != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"! Certificate verification flags %x\",\n                                        ssl-\u003esession_negotiate-\u003everify_result ) );\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"Certificate verification flags clear\" ) );\n        }\n#endif /* MBEDTLS_DEBUG_C */\n    }\n\n    ssl-\u003estate++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= parse certificate\" ) );\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":5921,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.12"},"203286":{"score":0.6920198,"function_name":"mbedtls_ssl_optimize_checksum","code":"void mbedtls_ssl_optimize_checksum( mbedtls_ssl_context *ssl,\n                            const mbedtls_ssl_ciphersuite_t *ciphersuite_info )\n{\n    ((void) ciphersuite_info);\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n    if( ssl-\u003eminor_ver \u003c MBEDTLS_SSL_MINOR_VERSION_3 )\n        ssl-\u003ehandshake-\u003eupdate_checksum = ssl_update_checksum_md5sha1;\n    else\n#endif\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n#if defined(MBEDTLS_SHA512_C)\n    if( ciphersuite_info-\u003emac == MBEDTLS_MD_SHA384 )\n        ssl-\u003ehandshake-\u003eupdate_checksum = ssl_update_checksum_sha384;\n    else\n#endif\n#if defined(MBEDTLS_SHA256_C)\n    if( ciphersuite_info-\u003emac != MBEDTLS_MD_SHA384 )\n        ssl-\u003ehandshake-\u003eupdate_checksum = ssl_update_checksum_sha256;\n    else\n#endif\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return;\n    }\n}","filepath":"library/ssl_tls.c","line_number":6476,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"203630":{"score":0.72654116,"function_name":"ssl_calc_finished_tls","code":"static void ssl_calc_finished_tls(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    const char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n    unsigned char padbuf[36];\n\n    ssl_session *session = ssl-\u003esession_negotiate;\n    if( !session )\n        session = ssl-\u003esession;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e calc  finished tls\" ) );\n\n    memcpy( \u0026md5 , \u0026ssl-\u003ehandshake-\u003efin_md5 , sizeof(md5_context)  );\n    memcpy( \u0026sha1, \u0026ssl-\u003ehandshake-\u003efin_sha1, sizeof(sha1_context) );\n\n    /*\n     * TLSv1:\n     *   hash = PRF( master, finished_label,\n     *               MD5( handshake ) + SHA1( handshake ) )[0..11]\n     */\n\n#if !defined(POLARSSL_MD5_ALT)\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n#endif\n\n#if !defined(POLARSSL_SHA1_ALT)\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n#endif\n\n    sender = ( from == SSL_IS_CLIENT )\n             ? \"client finished\"\n             : \"server finished\";\n\n    md5_finish(  \u0026md5, padbuf );\n    sha1_finish( \u0026sha1, padbuf + 16 );\n\n    ssl-\u003ehandshake-\u003etls_prf( session-\u003emaster, 48, sender,\n                             padbuf, 36, buf, len );\n\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n\n    md5_free(  \u0026md5  );\n    sha1_free( \u0026sha1 );\n\n    polarssl_zeroize(  padbuf, sizeof(  padbuf ) );\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= calc  finished\" ) );\n}","filepath":"library/ssl_tls.c","line_number":3099,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.12"},"204262":{"score":0.47484934,"function_name":"ssl_handshake_wrapup_free_hs_transform","code":"static void ssl_handshake_wrapup_free_hs_transform( mbedtls_ssl_context *ssl )\n{\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"=\u003e handshake wrapup: final free\" ) );\n\n    /*\n     * Free our handshake params\n     */\n    mbedtls_ssl_handshake_free( ssl );\n    mbedtls_free( ssl-\u003ehandshake );\n    ssl-\u003ehandshake = NULL;\n\n    /*\n     * Free the previous transform and swith in the current one\n     */\n    if( ssl-\u003etransform )\n    {\n        mbedtls_ssl_transform_free( ssl-\u003etransform );\n        mbedtls_free( ssl-\u003etransform );\n    }\n    ssl-\u003etransform = ssl-\u003etransform_negotiate;\n    ssl-\u003etransform_negotiate = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"\u003c= handshake wrapup: final free\" ) );\n}","filepath":"library/ssl_tls.c","line_number":6891,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"204396":{"score":0.4499991,"function_name":"mbedtls_ssl_recv_flight_completed","code":"void mbedtls_ssl_recv_flight_completed( mbedtls_ssl_context *ssl )\n{\n    /* We won't need to resend that one any more */\n    ssl_flight_free( ssl-\u003ehandshake-\u003eflight );\n    ssl-\u003ehandshake-\u003eflight = NULL;\n    ssl-\u003ehandshake-\u003ecur_msg = NULL;\n\n    /* The next incoming flight will start with this msg_seq */\n    ssl-\u003ehandshake-\u003ein_flight_start_seq = ssl-\u003ehandshake-\u003ein_msg_seq;\n\n    /* We don't want to remember CCS's across flight boundaries. */\n    ssl-\u003ehandshake-\u003ebuffering.seen_ccs = 0;\n\n    /* Clear future message buffering structure. */\n    ssl_buffering_free( ssl );\n\n    /* Cancel timer */\n    ssl_set_timer( ssl, 0 );\n\n    if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE \u0026\u0026\n        ssl-\u003ein_msg[0] == MBEDTLS_SSL_HS_FINISHED )\n    {\n        ssl-\u003ehandshake-\u003eretransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;\n    }\n    else\n        ssl-\u003ehandshake-\u003eretransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;\n}","filepath":"library/ssl_tls.c","line_number":3411,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"204898":{"score":0.61655456,"function_name":"ssl_parse_finished","code":"int ssl_parse_finished( ssl_context *ssl )\n{\n    int ret;\n    unsigned int hash_len;\n    unsigned char buf[SSL_MAX_HASH_LEN];\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e parse finished\" ) );\n\n    ssl-\u003ehandshake-\u003ecalc_finished( ssl, buf, ssl-\u003eendpoint ^ 1 );\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl-\u003ein_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /* There is currently no ciphersuite using another length with TLS 1.2 */\n#if defined(POLARSSL_SSL_PROTO_SSL3)\n    if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 )\n        hash_len = 36;\n    else\n#endif\n        hash_len = 12;\n\n    if( ssl-\u003ein_msg[0] != SSL_HS_FINISHED ||\n        ssl-\u003ein_hslen  != ssl_hs_hdr_len( ssl ) + hash_len )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_FINISHED );\n    }\n\n    if( safer_memcmp( ssl-\u003ein_msg + ssl_hs_hdr_len( ssl ),\n                      buf, hash_len ) != 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad finished message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_FINISHED );\n    }\n\n#if defined(POLARSSL_SSL_RENEGOTIATION)\n    ssl-\u003everify_data_len = hash_len;\n    memcpy( ssl-\u003epeer_verify_data, buf, hash_len );\n#endif\n\n    if( ssl-\u003ehandshake-\u003eresume != 0 )\n    {\n#if defined(POLARSSL_SSL_CLI_C)\n        if( ssl-\u003eendpoint == SSL_IS_CLIENT )\n            ssl-\u003estate = SSL_CLIENT_CHANGE_CIPHER_SPEC;\n#endif\n#if defined(POLARSSL_SSL_SRV_C)\n        if( ssl-\u003eendpoint == SSL_IS_SERVER )\n            ssl-\u003estate = SSL_HANDSHAKE_WRAPUP;\n#endif\n    }\n    else\n        ssl-\u003estate++;\n\n#if defined(POLARSSL_SSL_PROTO_DTLS)\n    if( ssl-\u003etransport == SSL_TRANSPORT_DATAGRAM )\n        ssl_recv_flight_completed( ssl );\n#endif\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= parse finished\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":4663,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.4-dtls-preview"},"205286":{"score":0.77466786,"function_name":"ssl_handshake_params_init","code":"static void ssl_handshake_params_init( mbedtls_ssl_handshake_params *handshake )\n{\n    memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n     mbedtls_md5_init(   \u0026handshake-\u003efin_md5  );\n    mbedtls_sha1_init(   \u0026handshake-\u003efin_sha1 );\n     mbedtls_md5_starts_ret( \u0026handshake-\u003efin_md5  );\n    mbedtls_sha1_starts_ret( \u0026handshake-\u003efin_sha1 );\n#endif\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n#if defined(MBEDTLS_SHA256_C)\n#if defined(MBEDTLS_USE_PSA_CRYPTO)\n    handshake-\u003efin_sha256_psa = psa_hash_operation_init();\n    psa_hash_setup( \u0026handshake-\u003efin_sha256_psa, PSA_ALG_SHA_256 );\n#else\n    mbedtls_sha256_init(   \u0026handshake-\u003efin_sha256    );\n    mbedtls_sha256_starts_ret( \u0026handshake-\u003efin_sha256, 0 );\n#endif\n#endif\n#if defined(MBEDTLS_SHA512_C)\n#if defined(MBEDTLS_USE_PSA_CRYPTO)\n    handshake-\u003efin_sha384_psa = psa_hash_operation_init();\n    psa_hash_setup( \u0026handshake-\u003efin_sha384_psa, PSA_ALG_SHA_384 );\n#else\n    mbedtls_sha512_init(   \u0026handshake-\u003efin_sha512    );\n    mbedtls_sha512_starts_ret( \u0026handshake-\u003efin_sha512, 1 );\n#endif\n#endif\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n    handshake-\u003eupdate_checksum = ssl_update_checksum_start;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) \u0026\u0026 \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    mbedtls_ssl_sig_hash_set_init( \u0026handshake-\u003ehash_algs );\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n    mbedtls_dhm_init( \u0026handshake-\u003edhm_ctx );\n#endif\n#if defined(MBEDTLS_ECDH_C)\n    mbedtls_ecdh_init( \u0026handshake-\u003eecdh_ctx );\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    mbedtls_ecjpake_init( \u0026handshake-\u003eecjpake_ctx );\n#if defined(MBEDTLS_SSL_CLI_C)\n    handshake-\u003eecjpake_cache = NULL;\n    handshake-\u003eecjpake_cache_len = 0;\n#endif\n#endif\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n    mbedtls_x509_crt_restart_init( \u0026handshake-\u003eecrs_ctx );\n#endif\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    handshake-\u003esni_authmode = MBEDTLS_SSL_VERIFY_UNSET;\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C) \u0026\u0026 \\\n    !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)\n    mbedtls_pk_init( \u0026handshake-\u003epeer_pubkey );\n#endif\n}","filepath":"library/ssl_tls.c","line_number":7181,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"205476":{"score":0.7663501,"function_name":"ssl_transform_init","code":"static void ssl_transform_init( mbedtls_ssl_transform *transform )\n{\n    memset( transform, 0, sizeof(mbedtls_ssl_transform) );\n\n    mbedtls_cipher_init( \u0026transform-\u003ecipher_ctx_enc );\n    mbedtls_cipher_init( \u0026transform-\u003ecipher_ctx_dec );\n\n    mbedtls_md_init( \u0026transform-\u003emd_ctx_enc );\n    mbedtls_md_init( \u0026transform-\u003emd_ctx_dec );\n}","filepath":"library/ssl_tls.c","line_number":7248,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"205638":{"score":0.7242532,"function_name":"ssl_handshake_init","code":"static int ssl_handshake_init( mbedtls_ssl_context *ssl )\n{\n    /* Clear old handshake information if present */\n    if( ssl-\u003etransform_negotiate )\n        mbedtls_ssl_transform_free( ssl-\u003etransform_negotiate );\n    if( ssl-\u003esession_negotiate )\n        mbedtls_ssl_session_free( ssl-\u003esession_negotiate );\n    if( ssl-\u003ehandshake )\n        mbedtls_ssl_handshake_free( ssl );\n\n    /*\n     * Either the pointers are now NULL or cleared properly and can be freed.\n     * Now allocate missing structures.\n     */\n    if( ssl-\u003etransform_negotiate == NULL )\n    {\n        ssl-\u003etransform_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_transform) );\n    }\n\n    if( ssl-\u003esession_negotiate == NULL )\n    {\n        ssl-\u003esession_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_session) );\n    }\n\n    if( ssl-\u003ehandshake == NULL )\n    {\n        ssl-\u003ehandshake = mbedtls_calloc( 1, sizeof(mbedtls_ssl_handshake_params) );\n    }\n#if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)\n    /* If the buffers are too small - reallocate */\n    {\n        int modified = 0;\n        size_t written_in = 0;\n        size_t written_out = 0;\n        if( ssl-\u003ein_buf != NULL )\n        {\n            written_in = ssl-\u003ein_msg - ssl-\u003ein_buf;\n            if( ssl-\u003ein_buf_len \u003c MBEDTLS_SSL_IN_BUFFER_LEN )\n            {\n                if( resize_buffer( \u0026ssl-\u003ein_buf, MBEDTLS_SSL_IN_BUFFER_LEN,\n                                   \u0026ssl-\u003ein_buf_len ) != 0 )\n                {\n                    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"input buffer resizing failed - out of memory\" ) );\n                }\n                else\n                {\n                    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Reallocating in_buf to %d\", MBEDTLS_SSL_IN_BUFFER_LEN ) );\n                    modified = 1;\n                }\n            }\n        }\n\n        if( ssl-\u003eout_buf != NULL )\n        {\n            written_out = ssl-\u003eout_msg - ssl-\u003eout_buf;\n            if( ssl-\u003eout_buf_len \u003c MBEDTLS_SSL_OUT_BUFFER_LEN )\n            {\n                if( resize_buffer( \u0026ssl-\u003eout_buf, MBEDTLS_SSL_OUT_BUFFER_LEN,\n                                   \u0026ssl-\u003eout_buf_len ) != 0 )\n                {\n                    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"output buffer resizing failed - out of memory\" ) );\n                }\n                else\n                {\n                    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Reallocating out_buf to %d\", MBEDTLS_SSL_OUT_BUFFER_LEN ) );\n                    modified = 1;\n                }\n            }\n        }\n        if( modified )\n        {\n            /* Update pointers here to avoid doing it twice. */\n            mbedtls_ssl_reset_in_out_pointers( ssl );\n            /* Fields below might not be properly updated with record\n            * splitting, so they are manually updated here. */\n            ssl-\u003eout_msg = ssl-\u003eout_buf + written_out;\n            ssl-\u003ein_msg = ssl-\u003ein_buf + written_in;\n        }\n    }\n#endif\n\n    /* All pointers should exist and can be directly freed without issue */\n    if( ssl-\u003ehandshake == NULL ||\n        ssl-\u003etransform_negotiate == NULL ||\n        ssl-\u003esession_negotiate == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc() of ssl sub-contexts failed\" ) );\n\n        mbedtls_free( ssl-\u003ehandshake );\n        mbedtls_free( ssl-\u003etransform_negotiate );\n        mbedtls_free( ssl-\u003esession_negotiate );\n\n        ssl-\u003ehandshake = NULL;\n        ssl-\u003etransform_negotiate = NULL;\n        ssl-\u003esession_negotiate = NULL;\n\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    /* Initialize structures */\n    mbedtls_ssl_session_init( ssl-\u003esession_negotiate );\n    mbedtls_ssl_transform_init( ssl-\u003etransform_negotiate );\n    ssl_handshake_params_init( ssl-\u003ehandshake );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        ssl-\u003ehandshake-\u003ealt_transform_out = ssl-\u003etransform_out;\n\n        if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_CLIENT )\n            ssl-\u003ehandshake-\u003eretransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;\n        else\n            ssl-\u003ehandshake-\u003eretransmit_state = MBEDTLS_SSL_RETRANS_WAITING;\n\n        mbedtls_ssl_set_timer( ssl, 0 );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ssl_tls.c","line_number":3644,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.9.0-rc1"},"206178":{"score":0.79474646,"function_name":"ssl_update_in_pointers","code":"static void ssl_update_in_pointers( mbedtls_ssl_context *ssl,\n                                    mbedtls_ssl_transform *transform )\n{\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        ssl-\u003ein_ctr = ssl-\u003ein_hdr +  3;\n        ssl-\u003ein_len = ssl-\u003ein_hdr + 11;\n        ssl-\u003ein_iv  = ssl-\u003ein_hdr + 13;\n    }\n    else\n#endif\n    {\n        ssl-\u003ein_ctr = ssl-\u003ein_hdr - 8;\n        ssl-\u003ein_len = ssl-\u003ein_hdr + 3;\n        ssl-\u003ein_iv  = ssl-\u003ein_hdr + 5;\n    }\n\n    /* Offset in_msg from in_iv to allow space for explicit IV, if used. */\n    if( transform != NULL \u0026\u0026\n        ssl-\u003eminor_ver \u003e= MBEDTLS_SSL_MINOR_VERSION_2 )\n    {\n        ssl-\u003ein_msg = ssl-\u003ein_iv + transform-\u003eivlen - transform-\u003efixed_ivlen;\n    }\n    else\n        ssl-\u003ein_msg = ssl-\u003ein_iv;\n}","filepath":"library/ssl_tls.c","line_number":7406,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"206346":{"score":0.64789635,"function_name":"ssl_reset_in_out_pointers","code":"static void ssl_reset_in_out_pointers( mbedtls_ssl_context *ssl )\n{\n    /* Set the incoming and outgoing record pointers. */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        ssl-\u003eout_hdr = ssl-\u003eout_buf;\n        ssl-\u003ein_hdr  = ssl-\u003ein_buf;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n    {\n        ssl-\u003eout_hdr = ssl-\u003eout_buf + 8;\n        ssl-\u003ein_hdr  = ssl-\u003ein_buf  + 8;\n    }\n\n    /* Derive other internal pointers. */\n    ssl_update_out_pointers( ssl, NULL /* no transform enabled */ );\n    ssl_update_in_pointers ( ssl, NULL /* no transform enabled */ );\n}","filepath":"library/ssl_tls.c","line_number":7446,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"206424":{"score":0.7806528,"function_name":"mbedtls_ssl_setup","code":"int mbedtls_ssl_setup( mbedtls_ssl_context *ssl,\n                       const mbedtls_ssl_config *conf )\n{\n    int ret;\n\n    ssl-\u003econf = conf;\n\n    /*\n     * Prepare base structures\n     */\n\n    /* Set to NULL in case of an error condition */\n    ssl-\u003eout_buf = NULL;\n\n    ssl-\u003ein_buf = mbedtls_calloc( 1, MBEDTLS_SSL_IN_BUFFER_LEN );\n    if( ssl-\u003ein_buf == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc(%d bytes) failed\", MBEDTLS_SSL_IN_BUFFER_LEN) );\n        ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;\n        goto error;\n    }\n\n    ssl-\u003eout_buf = mbedtls_calloc( 1, MBEDTLS_SSL_OUT_BUFFER_LEN );\n    if( ssl-\u003eout_buf == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc(%d bytes) failed\", MBEDTLS_SSL_OUT_BUFFER_LEN) );\n        ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;\n        goto error;\n    }\n\n    ssl_reset_in_out_pointers( ssl );\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        goto error;\n\n    return( 0 );\n\nerror:\n    mbedtls_free( ssl-\u003ein_buf );\n    mbedtls_free( ssl-\u003eout_buf );\n\n    ssl-\u003econf = NULL;\n\n    ssl-\u003ein_buf = NULL;\n    ssl-\u003eout_buf = NULL;\n\n    ssl-\u003ein_hdr = NULL;\n    ssl-\u003ein_ctr = NULL;\n    ssl-\u003ein_len = NULL;\n    ssl-\u003ein_iv = NULL;\n    ssl-\u003ein_msg = NULL;\n\n    ssl-\u003eout_hdr = NULL;\n    ssl-\u003eout_ctr = NULL;\n    ssl-\u003eout_len = NULL;\n    ssl-\u003eout_iv = NULL;\n    ssl-\u003eout_msg = NULL;\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":7467,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"206801":{"score":0.7302089,"function_name":"ssl_session_reset","code":"int ssl_session_reset( ssl_context *ssl )\n{\n    int ret;\n\n    ssl-\u003estate = SSL_HELLO_REQUEST;\n    ssl-\u003erenegotiation = SSL_INITIAL_HANDSHAKE;\n    ssl-\u003esecure_renegotiation = SSL_LEGACY_RENEGOTIATION;\n\n    ssl-\u003everify_data_len = 0;\n    memset( ssl-\u003eown_verify_data, 0, 36 );\n    memset( ssl-\u003epeer_verify_data, 0, 36 );\n\n    ssl-\u003ein_offt = NULL;\n\n    ssl-\u003ein_msg = ssl-\u003ein_ctr + 13;\n    ssl-\u003ein_msgtype = 0;\n    ssl-\u003ein_msglen = 0;\n    ssl-\u003ein_left = 0;\n\n    ssl-\u003ein_hslen = 0;\n    ssl-\u003enb_zero = 0;\n    ssl-\u003erecord_read = 0;\n\n    ssl-\u003eout_msg = ssl-\u003eout_ctr + 13;\n    ssl-\u003eout_msgtype = 0;\n    ssl-\u003eout_msglen = 0;\n    ssl-\u003eout_left = 0;\n\n    ssl-\u003etransform_in = NULL;\n    ssl-\u003etransform_out = NULL;\n\n    memset( ssl-\u003eout_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl-\u003ein_ctr, 0, SSL_BUFFER_LEN );\n\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_reset != NULL)\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_reset()\" ) );\n        if( ( ret = ssl_hw_record_reset( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_hw_record_reset\", ret );\n            return( POLARSSL_ERR_SSL_HW_ACCEL_FAILED );\n        }\n    }\n#endif\n\n    if( ssl-\u003etransform )\n    {\n        ssl_transform_free( ssl-\u003etransform );\n        free( ssl-\u003etransform );\n        ssl-\u003etransform = NULL;\n    }\n\n    if( ssl-\u003esession )\n    {\n        ssl_session_free( ssl-\u003esession );\n        free( ssl-\u003esession );\n        ssl-\u003esession = NULL;\n    }\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":2799,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3-alpha1"},"207519":{"score":0.7307509,"function_name":"mbedtls_ssl_set_bio","code":"void mbedtls_ssl_set_bio( mbedtls_ssl_context *ssl,\n        void *p_bio,\n        mbedtls_ssl_send_t *f_send,\n        mbedtls_ssl_recv_t *f_recv,\n        mbedtls_ssl_recv_timeout_t *f_recv_timeout )\n{\n    ssl-\u003ep_bio          = p_bio;\n    ssl-\u003ef_send         = f_send;\n    ssl-\u003ef_recv         = f_recv;\n    ssl-\u003ef_recv_timeout = f_recv_timeout;\n}","filepath":"library/ssl_tls.c","line_number":7733,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"207596":{"score":0.8458376,"function_name":"mbedtls_ssl_set_timer_cb","code":"void mbedtls_ssl_set_timer_cb( mbedtls_ssl_context *ssl,\n                               void *p_timer,\n                               mbedtls_ssl_set_timer_t *f_set_timer,\n                               mbedtls_ssl_get_timer_t *f_get_timer )\n{\n    ssl-\u003ep_timer        = p_timer;\n    ssl-\u003ef_set_timer    = f_set_timer;\n    ssl-\u003ef_get_timer    = f_get_timer;\n\n    /* Make sure we start with no timer running */\n    ssl_set_timer( ssl, 0 );\n}","filepath":"library/ssl_tls.c","line_number":7757,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"207658":{"score":0.81699896,"function_name":"mbedtls_ssl_set_session","code":"int mbedtls_ssl_set_session( mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session )\n{\n    int ret;\n\n    if( ssl == NULL ||\n        session == NULL ||\n        ssl-\u003esession_negotiate == NULL ||\n        ssl-\u003econf-\u003eendpoint != MBEDTLS_SSL_IS_CLIENT )\n    {\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    if( ( ret = ssl_session_copy( ssl-\u003esession_negotiate, session ) ) != 0 )\n        return( ret );\n\n    ssl-\u003ehandshake-\u003eresume = 1;\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":7481,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.12"},"207777":{"score":0.7571088,"function_name":"mbedtls_ssl_conf_ciphersuites","code":"void mbedtls_ssl_conf_ciphersuites( mbedtls_ssl_config *conf,\n                                   const int *ciphersuites )\n{\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] = ciphersuites;\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] = ciphersuites;\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] = ciphersuites;\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] = ciphersuites;\n}","filepath":"library/ssl_tls.c","line_number":7805,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"207828":{"score":0.84509736,"function_name":"mbedtls_ssl_conf_ciphersuites_for_version","code":"void mbedtls_ssl_conf_ciphersuites_for_version( mbedtls_ssl_config *conf,\n                                       const int *ciphersuites,\n                                       int major, int minor )\n{\n    if( major != MBEDTLS_SSL_MAJOR_VERSION_3 )\n        return;\n\n    if( minor \u003c MBEDTLS_SSL_MINOR_VERSION_0 || minor \u003e MBEDTLS_SSL_MINOR_VERSION_3 )\n        return;\n\n    conf-\u003eciphersuite_list[minor] = ciphersuites;\n}","filepath":"library/ssl_tls.c","line_number":7814,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"207904":{"score":0.8919664,"function_name":"ssl_append_key_cert","code":"static int ssl_append_key_cert( mbedtls_ssl_key_cert **head,\n                                mbedtls_x509_crt *cert,\n                                mbedtls_pk_context *key )\n{\n    mbedtls_ssl_key_cert *new_cert;\n\n    new_cert = mbedtls_calloc( 1, sizeof( mbedtls_ssl_key_cert ) );\n    if( new_cert == NULL )\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n    new_cert-\u003ecert = cert;\n    new_cert-\u003ekey  = key;\n    new_cert-\u003enext = NULL;\n\n    /* Update head is the list was null, else add to the end */\n    if( *head == NULL )\n    {\n        *head = new_cert;\n    }\n    else\n    {\n        mbedtls_ssl_key_cert *cur = *head;\n        while( cur-\u003enext != NULL )\n            cur = cur-\u003enext;\n        cur-\u003enext = new_cert;\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":7835,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"208298":{"score":0.8625672,"function_name":"mbedtls_ssl_set_hostname","code":"int mbedtls_ssl_set_hostname( mbedtls_ssl_context *ssl, const char *hostname )\n{\n    /* Initialize to suppress unnecessary compiler warning */\n    size_t hostname_len = 0;\n\n    /* Check if new hostname is valid before\n     * making any change to current one */\n    if( hostname != NULL )\n    {\n        hostname_len = strlen( hostname );\n\n        if( hostname_len \u003e MBEDTLS_SSL_MAX_HOST_NAME_LEN )\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /* Now it's clear that we will overwrite the old hostname,\n     * so we can free it safely */\n\n    if( ssl-\u003ehostname != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ehostname, strlen( ssl-\u003ehostname ) );\n        mbedtls_free( ssl-\u003ehostname );\n    }\n\n    /* Passing NULL as hostname shall clear the old one */\n\n    if( hostname == NULL )\n    {\n        ssl-\u003ehostname = NULL;\n    }\n    else\n    {\n        ssl-\u003ehostname = mbedtls_calloc( 1, hostname_len + 1 );\n        if( ssl-\u003ehostname == NULL )\n            return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n        memcpy( ssl-\u003ehostname, hostname, hostname_len );\n\n        ssl-\u003ehostname[hostname_len] = '\\0';\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":8187,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"208820":{"score":0.4479108,"function_name":"ssl_get_current_mtu","code":"static size_t ssl_get_current_mtu( const mbedtls_ssl_context *ssl )\n{\n    /* Return unlimited mtu for client hello messages to avoid fragmentation. */\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_CLIENT \u0026\u0026\n        ( ssl-\u003estate == MBEDTLS_SSL_CLIENT_HELLO ||\n          ssl-\u003estate == MBEDTLS_SSL_SERVER_HELLO ) )\n        return ( 0 );\n\n    if( ssl-\u003ehandshake == NULL || ssl-\u003ehandshake-\u003emtu == 0 )\n        return( ssl-\u003emtu );\n\n    if( ssl-\u003emtu == 0 )\n        return( ssl-\u003ehandshake-\u003emtu );\n\n    return( ssl-\u003emtu \u003c ssl-\u003ehandshake-\u003emtu ?\n            ssl-\u003emtu : ssl-\u003ehandshake-\u003emtu );\n}","filepath":"library/ssl_tls.c","line_number":8645,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"208911":{"score":0.84183395,"function_name":"mbedtls_ssl_get_verify_result","code":"uint32_t mbedtls_ssl_get_verify_result( const mbedtls_ssl_context *ssl )\n{\n    if( ssl-\u003esession != NULL )\n        return( ssl-\u003esession-\u003everify_result );\n\n    if( ssl-\u003esession_negotiate != NULL )\n        return( ssl-\u003esession_negotiate-\u003everify_result );\n\n    return( 0xFFFFFFFF );\n}","filepath":"library/ssl_tls.c","line_number":8506,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"209041":{"score":0.86558354,"function_name":"mbedtls_ssl_get_version","code":"const char *mbedtls_ssl_get_version( const mbedtls_ssl_context *ssl )\n{\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        switch( ssl-\u003eminor_ver )\n        {\n            case MBEDTLS_SSL_MINOR_VERSION_2:\n                return( \"DTLSv1.0\" );\n\n            case MBEDTLS_SSL_MINOR_VERSION_3:\n                return( \"DTLSv1.2\" );\n\n            default:\n                return( \"unknown (DTLS)\" );\n        }\n    }\n#endif\n\n    switch( ssl-\u003eminor_ver )\n    {\n        case MBEDTLS_SSL_MINOR_VERSION_0:\n            return( \"SSLv3.0\" );\n\n        case MBEDTLS_SSL_MINOR_VERSION_1:\n            return( \"TLSv1.0\" );\n\n        case MBEDTLS_SSL_MINOR_VERSION_2:\n            return( \"TLSv1.1\" );\n\n        case MBEDTLS_SSL_MINOR_VERSION_3:\n            return( \"TLSv1.2\" );\n\n        default:\n            return( \"unknown\" );\n    }\n}","filepath":"library/ssl_tls.c","line_number":8525,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"209128":{"score":0.7490333,"function_name":"mbedtls_ssl_get_record_expansion","code":"int mbedtls_ssl_get_record_expansion( const mbedtls_ssl_context *ssl )\n{\n    size_t transform_expansion = 0;\n    const mbedtls_ssl_transform *transform = ssl-\u003etransform_out;\n    unsigned block_size;\n\n    if( transform == NULL )\n        return( (int) mbedtls_ssl_hdr_len( ssl ) );\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    if( ssl-\u003esession_out-\u003ecompression != MBEDTLS_SSL_COMPRESS_NULL )\n        return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );\n#endif\n\n    switch( mbedtls_cipher_get_cipher_mode( \u0026transform-\u003ecipher_ctx_enc ) )\n    {\n        case MBEDTLS_MODE_GCM:\n        case MBEDTLS_MODE_CCM:\n        case MBEDTLS_MODE_CHACHAPOLY:\n        case MBEDTLS_MODE_STREAM:\n            transform_expansion = transform-\u003eminlen;\n            break;\n\n        case MBEDTLS_MODE_CBC:\n\n            block_size = mbedtls_cipher_get_block_size(\n                \u0026transform-\u003ecipher_ctx_enc );\n\n            /* Expansion due to the addition of the MAC. */\n            transform_expansion += transform-\u003emaclen;\n\n            /* Expansion due to the addition of CBC padding;\n             * Theoretically up to 256 bytes, but we never use\n             * more than the block size of the underlying cipher. */\n            transform_expansion += block_size;\n\n            /* For TLS 1.1 or higher, an explicit IV is added\n             * after the record header. */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)\n            if( ssl-\u003eminor_ver \u003e= MBEDTLS_SSL_MINOR_VERSION_2 )\n                transform_expansion += block_size;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */\n\n            break;\n\n        default:\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    return( (int)( mbedtls_ssl_hdr_len( ssl ) + transform_expansion ) );\n}","filepath":"library/ssl_tls.c","line_number":8563,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"209335":{"score":0.71997505,"function_name":"mbedtls_ssl_get_peer_cert","code":"const mbedtls_x509_crt *mbedtls_ssl_get_peer_cert( const mbedtls_ssl_context *ssl )\n{\n    if( ssl == NULL || ssl-\u003esession == NULL )\n        return( NULL );\n\n#if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)\n    return( ssl-\u003esession-\u003epeer_cert );\n#else\n    return( NULL );\n#endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */\n}","filepath":"library/ssl_tls.c","line_number":8710,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"209382":{"score":0.7700509,"function_name":"mbedtls_ssl_get_session","code":"int mbedtls_ssl_get_session( const mbedtls_ssl_context *ssl, mbedtls_ssl_session *dst )\n{\n    if( ssl == NULL ||\n        dst == NULL ||\n        ssl-\u003esession == NULL ||\n        ssl-\u003econf-\u003eendpoint != MBEDTLS_SSL_IS_CLIENT )\n    {\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    return( ssl_session_copy( dst, ssl-\u003esession ) );\n}","filepath":"library/ssl_tls.c","line_number":8337,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.12"},"209466":{"score":0.66991436,"function_name":"mbedtls_ssl_handshake_step","code":"int mbedtls_ssl_handshake_step( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_SSL_CLI_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_CLIENT )\n        ret = mbedtls_ssl_handshake_client_step( ssl );\n#endif\n#if defined(MBEDTLS_SSL_SRV_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER )\n        ret = mbedtls_ssl_handshake_server_step( ssl );\n#endif\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":8742,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"209642":{"score":0.71008724,"function_name":"mbedtls_ssl_read","code":"int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t n;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e read\" ) );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )\n            return( ret );\n\n        if( ssl-\u003ehandshake != NULL \u0026\u0026\n            ssl-\u003ehandshake-\u003eretransmit_state == MBEDTLS_SSL_RETRANS_SENDING )\n        {\n            if( ( ret = mbedtls_ssl_flight_transmit( ssl ) ) != 0 )\n                return( ret );\n        }\n    }\n#endif\n\n    /*\n     * Check if renegotiation is necessary and/or handshake is\n     * in process. If yes, perform/continue, and fall through\n     * if an unexpected packet is received while the client\n     * is waiting for the ServerHello.\n     *\n     * (There is no equivalent to the last condition on\n     *  the server-side as it is not treated as within\n     *  a handshake while waiting for the ClientHello\n     *  after a renegotiation request.)\n     */\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    ret = ssl_check_ctr_renegotiate( ssl );\n    if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO \u0026\u0026\n        ret != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_check_ctr_renegotiate\", ret );\n        return( ret );\n    }\n#endif\n\n    if( mbedtls_ssl_is_handshake_over( ssl ) == 0 )\n    {\n        ret = mbedtls_ssl_handshake( ssl );\n        if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO \u0026\u0026\n            ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n\n    /* Loop as long as no application data record is available */\n    while( ssl-\u003ein_offt == NULL )\n    {\n        /* Start timer if not already running */\n        if( ssl-\u003ef_get_timer != NULL \u0026\u0026\n            ssl-\u003ef_get_timer( ssl-\u003ep_timer ) == -1 )\n        {\n            mbedtls_ssl_set_timer( ssl, ssl-\u003econf-\u003eread_timeout );\n        }\n\n        if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )\n        {\n            if( ret == MBEDTLS_ERR_SSL_CONN_EOF )\n                return( 0 );\n\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n            return( ret );\n        }\n\n        if( ssl-\u003ein_msglen  == 0 \u0026\u0026\n            ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA )\n        {\n            /*\n             * OpenSSL sends empty messages to randomize the IV\n             */\n            if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )\n            {\n                if( ret == MBEDTLS_ERR_SSL_CONN_EOF )\n                    return( 0 );\n\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n                return( ret );\n            }\n        }\n\n        if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )\n        {\n            ret = ssl_handle_hs_message_post_handshake( ssl );\n            if( ret != 0)\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_handle_hs_message_post_handshake\",\n                                          ret );\n                return( ret );\n            }\n\n            /* At this point, we don't know whether the renegotiation triggered\n             * by the post-handshake message has been completed or not. The cases\n             * to consider are the following:\n             * 1) The renegotiation is complete. In this case, no new record\n             *    has been read yet.\n             * 2) The renegotiation is incomplete because the client received\n             *    an application data record while awaiting the ServerHello.\n             * 3) The renegotiation is incomplete because the client received\n             *    a non-handshake, non-application data message while awaiting\n             *    the ServerHello.\n             *\n             * In each of these cases, looping will be the proper action:\n             * - For 1), the next iteration will read a new record and check\n             *   if it's application data.\n             * - For 2), the loop condition isn't satisfied as application data\n             *   is present, hence continue is the same as break\n             * - For 3), the loop condition is satisfied and read_record\n             *   will re-deliver the message that was held back by the client\n             *   when expecting the ServerHello.\n             */\n\n            continue;\n        }\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        else if( ssl-\u003erenego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )\n        {\n            if( ssl-\u003econf-\u003erenego_max_records \u003e= 0 )\n            {\n                if( ++ssl-\u003erenego_records_seen \u003e ssl-\u003econf-\u003erenego_max_records )\n                {\n                    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation requested, \"\n                                        \"but not honored by client\" ) );\n                    return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n                }\n            }\n        }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n        /* Fatal and closure alerts handled by mbedtls_ssl_read_record() */\n        if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_ALERT )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"ignoring non-fatal non-closure alert\" ) );\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n        }\n\n        if( ssl-\u003ein_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad application data message\" ) );\n            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        ssl-\u003ein_offt = ssl-\u003ein_msg;\n\n        /* We're going to return something now, cancel timer,\n         * except if handshake (renegotiation) is in progress */\n        if( mbedtls_ssl_is_handshake_over( ssl ) == 1 )\n            mbedtls_ssl_set_timer( ssl, 0 );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        /* If we requested renego but received AppData, resend HelloRequest.\n         * Do it now, after setting in_offt, to avoid taking this branch\n         * again if ssl_write_hello_request() returns WANT_WRITE */\n#if defined(MBEDTLS_SSL_SRV_C) \u0026\u0026 defined(MBEDTLS_SSL_RENEGOTIATION)\n        if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n            ssl-\u003erenego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )\n        {\n            if( ( ret = mbedtls_ssl_resend_hello_request( ssl ) ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_resend_hello_request\",\n                                       ret );\n                return( ret );\n            }\n        }\n#endif /* MBEDTLS_SSL_SRV_C \u0026\u0026 MBEDTLS_SSL_RENEGOTIATION */\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n    }\n\n    n = ( len \u003c ssl-\u003ein_msglen )\n        ? len : ssl-\u003ein_msglen;\n\n    memcpy( buf, ssl-\u003ein_offt, n );\n    ssl-\u003ein_msglen -= n;\n\n    /* Zeroising the plaintext buffer to erase unused application data\n       from the memory. */\n    mbedtls_platform_zeroize( ssl-\u003ein_offt, n );\n\n    if( ssl-\u003ein_msglen == 0 )\n    {\n        /* all bytes consumed */\n        ssl-\u003ein_offt = NULL;\n        ssl-\u003ekeep_current_message = 0;\n    }\n    else\n    {\n        /* more data available */\n        ssl-\u003ein_offt += n;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= read\" ) );\n\n    return( (int) n );\n}","filepath":"library/ssl_msg.c","line_number":5399,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.2.0"},"210276":{"score":0.56683695,"function_name":"ssl_write_real","code":"static int ssl_write_real( mbedtls_ssl_context *ssl,\n                           const unsigned char *buf, size_t len )\n{\n    int ret = mbedtls_ssl_get_max_out_record_payload( ssl );\n    const size_t max_len = (size_t) ret;\n\n    if( ret \u003c 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_get_max_out_record_payload\", ret );\n        return( ret );\n    }\n\n    if( len \u003e max_len )\n    {\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"fragment larger than the (negotiated) \"\n                                \"maximum fragment length: %d \u003e %d\",\n                                len, max_len ) );\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n        }\n        else\n#endif\n            len = max_len;\n    }\n\n    if( ssl-\u003eout_left != 0 )\n    {\n        /*\n         * The user has previously tried to send the data and\n         * MBEDTLS_ERR_SSL_WANT_WRITE or the message was only partially\n         * written. In this case, we expect the high-level write function\n         * (e.g. mbedtls_ssl_write()) to be called with the same parameters\n         */\n        if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_flush_output\", ret );\n            return( ret );\n        }\n    }\n    else\n    {\n        /*\n         * The user is trying to send a message the first time, so we need to\n         * copy the data into the internal buffers and setup the data structure\n         * to keep track of partial writes\n         */\n        ssl-\u003eout_msglen  = len;\n        ssl-\u003eout_msgtype = MBEDTLS_SSL_MSG_APPLICATION_DATA;\n        memcpy( ssl-\u003eout_msg, buf, len );\n\n        if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n            return( ret );\n        }\n    }\n\n    return( (int) len );\n}","filepath":"library/ssl_tls.c","line_number":9262,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"210578":{"score":0.54838485,"function_name":"mbedtls_ssl_renegotiate","code":"int mbedtls_ssl_renegotiate( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_SSL_SRV_C)\n    /* On server, just send the request */\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER )\n    {\n        if( ssl-\u003estate != MBEDTLS_SSL_HANDSHAKE_OVER )\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n        ssl-\u003erenego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;\n\n        /* Did we already try/start sending HelloRequest? */\n        if( ssl-\u003eout_left != 0 )\n            return( mbedtls_ssl_flush_output( ssl ) );\n\n        return( ssl_write_hello_request( ssl ) );\n    }\n#endif /* MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_CLI_C)\n    /*\n     * On client, either start the renegotiation process or,\n     * if already in progress, continue the handshake\n     */\n    if( ssl-\u003erenego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n    {\n        if( ssl-\u003estate != MBEDTLS_SSL_HANDSHAKE_OVER )\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n        if( ( ret = ssl_start_renegotiation( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_start_renegotiation\", ret );\n            return( ret );\n        }\n    }\n    else\n    {\n        if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_SSL_CLI_C */\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":8862,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"210695":{"score":0.6899543,"function_name":"mbedtls_ssl_transform_free","code":"void mbedtls_ssl_transform_free( mbedtls_ssl_transform *transform )\n{\n    if( transform == NULL )\n        return;\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    deflateEnd( \u0026transform-\u003ectx_deflate );\n    inflateEnd( \u0026transform-\u003ectx_inflate );\n#endif\n\n    mbedtls_cipher_free( \u0026transform-\u003ecipher_ctx_enc );\n    mbedtls_cipher_free( \u0026transform-\u003ecipher_ctx_dec );\n\n    mbedtls_md_free( \u0026transform-\u003emd_ctx_enc );\n    mbedtls_md_free( \u0026transform-\u003emd_ctx_dec );\n\n    mbedtls_platform_zeroize( transform, sizeof( mbedtls_ssl_transform ) );\n}","filepath":"library/ssl_tls.c","line_number":9433,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"210820":{"score":0.63940114,"function_name":"ssl_key_cert_free","code":"static void ssl_key_cert_free( mbedtls_ssl_key_cert *key_cert )\n{\n    mbedtls_ssl_key_cert *cur = key_cert, *next;\n\n    while( cur != NULL )\n    {\n        next = cur-\u003enext;\n        mbedtls_free( cur );\n        cur = next;\n    }\n}","filepath":"library/ssl_tls.c","line_number":9453,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"210887":{"score":0.40717685,"function_name":"ssl_buffering_free","code":"static void ssl_buffering_free( mbedtls_ssl_context *ssl )\n{\n    unsigned offset;\n    mbedtls_ssl_handshake_params * const hs = ssl-\u003ehandshake;\n\n    if( hs == NULL )\n        return;\n\n    ssl_free_buffered_record( ssl );\n\n    for( offset = 0; offset \u003c MBEDTLS_SSL_MAX_BUFFERED_HS; offset++ )\n        ssl_buffering_free_slot( ssl, offset );\n}","filepath":"library/ssl_tls.c","line_number":9468,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"211092":{"score":0.6343131,"function_name":"mbedtls_ssl_session_free","code":"void mbedtls_ssl_session_free( mbedtls_ssl_session *session )\n{\n    if( session == NULL )\n        return;\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    if( session-\u003epeer_cert != NULL )\n    {\n        mbedtls_x509_crt_free( session-\u003epeer_cert );\n        mbedtls_free( session-\u003epeer_cert );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    mbedtls_free( session-\u003eticket );\n#endif\n\n    mbedtls_platform_zeroize( session, sizeof( mbedtls_ssl_session ) );\n}","filepath":"library/ssl_tls.c","line_number":9209,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.12"},"211186":{"score":0.6720402,"function_name":"mbedtls_ssl_free","code":"void mbedtls_ssl_free( mbedtls_ssl_context *ssl )\n{\n    if( ssl == NULL )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e free\" ) );\n\n    if( ssl-\u003eout_buf != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003eout_buf, MBEDTLS_SSL_OUT_BUFFER_LEN );\n        mbedtls_free( ssl-\u003eout_buf );\n    }\n\n    if( ssl-\u003ein_buf != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ein_buf, MBEDTLS_SSL_IN_BUFFER_LEN );\n        mbedtls_free( ssl-\u003ein_buf );\n    }\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    if( ssl-\u003ecompress_buf != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ecompress_buf, MBEDTLS_SSL_COMPRESS_BUFFER_LEN );\n        mbedtls_free( ssl-\u003ecompress_buf );\n    }\n#endif\n\n    if( ssl-\u003etransform )\n    {\n        mbedtls_ssl_transform_free( ssl-\u003etransform );\n        mbedtls_free( ssl-\u003etransform );\n    }\n\n    if( ssl-\u003ehandshake )\n    {\n        mbedtls_ssl_handshake_free( ssl );\n        mbedtls_ssl_transform_free( ssl-\u003etransform_negotiate );\n        mbedtls_ssl_session_free( ssl-\u003esession_negotiate );\n\n        mbedtls_free( ssl-\u003ehandshake );\n        mbedtls_free( ssl-\u003etransform_negotiate );\n        mbedtls_free( ssl-\u003esession_negotiate );\n    }\n\n    if( ssl-\u003esession )\n    {\n        mbedtls_ssl_session_free( ssl-\u003esession );\n        mbedtls_free( ssl-\u003esession );\n    }\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    if( ssl-\u003ehostname != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ehostname, strlen( ssl-\u003ehostname ) );\n        mbedtls_free( ssl-\u003ehostname );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)\n    if( mbedtls_ssl_hw_record_finish != NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"going for mbedtls_ssl_hw_record_finish()\" ) );\n        mbedtls_ssl_hw_record_finish( ssl );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) \u0026\u0026 defined(MBEDTLS_SSL_SRV_C)\n    mbedtls_free( ssl-\u003ecli_id );\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= free\" ) );\n\n    /* Actually clear after last debug message */\n    mbedtls_platform_zeroize( ssl, sizeof( mbedtls_ssl_context ) );\n}","filepath":"library/ssl_tls.c","line_number":9635,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"211680":{"score":0.77797157,"function_name":"mbedtls_ssl_config_defaults","code":"int mbedtls_ssl_config_defaults( mbedtls_ssl_config *conf,\n                                 int endpoint, int transport, int preset )\n{\n#if defined(MBEDTLS_DHM_C) \u0026\u0026 defined(MBEDTLS_SSL_SRV_C)\n    int ret;\n#endif\n\n    /* Use the functions here so that they are covered in tests,\n     * but otherwise access member directly for efficiency */\n    mbedtls_ssl_conf_endpoint( conf, endpoint );\n    mbedtls_ssl_conf_transport( conf, transport );\n\n    /*\n     * Things that are common to all presets\n     */\n#if defined(MBEDTLS_SSL_CLI_C)\n    if( endpoint == MBEDTLS_SSL_IS_CLIENT )\n    {\n        conf-\u003eauthmode = MBEDTLS_SSL_VERIFY_REQUIRED;\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n        conf-\u003esession_tickets = MBEDTLS_SSL_SESSION_TICKETS_ENABLED;\n#endif\n    }\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n    conf-\u003earc4_disabled = MBEDTLS_SSL_ARC4_DISABLED;\n#endif\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    conf-\u003eencrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;\n#endif\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    conf-\u003eextended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;\n#endif\n\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n    conf-\u003ecbc_record_splitting = MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED;\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) \u0026\u0026 defined(MBEDTLS_SSL_SRV_C)\n    conf-\u003ef_cookie_write = ssl_cookie_write_dummy;\n    conf-\u003ef_cookie_check = ssl_cookie_check_dummy;\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)\n    conf-\u003eanti_replay = MBEDTLS_SSL_ANTI_REPLAY_ENABLED;\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    conf-\u003ehs_timeout_min = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN;\n    conf-\u003ehs_timeout_max = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX;\n#endif\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    conf-\u003erenego_max_records = MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT;\n    memset( conf-\u003erenego_period, 0xFF, 7 );\n    conf-\u003erenego_period[7] = 0x00;\n#endif\n\n#if defined(MBEDTLS_DHM_C) \u0026\u0026 defined(MBEDTLS_SSL_SRV_C)\n            if( endpoint == MBEDTLS_SSL_IS_SERVER )\n            {\n                if( ( ret = mbedtls_ssl_conf_dh_param( conf,\n                                MBEDTLS_DHM_RFC5114_MODP_2048_P,\n                                MBEDTLS_DHM_RFC5114_MODP_2048_G ) ) != 0 )\n                {\n                    return( ret );\n                }\n            }\n#endif\n\n    /*\n     * Preset-specific defaults\n     */\n    switch( preset )\n    {\n        /*\n         * NSA Suite B\n         */\n        case MBEDTLS_SSL_PRESET_SUITEB:\n            conf-\u003emin_major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;\n            conf-\u003emin_minor_ver = MBEDTLS_SSL_MINOR_VERSION_3; /* TLS 1.2 */\n            conf-\u003emax_major_ver = MBEDTLS_SSL_MAX_MAJOR_VERSION;\n            conf-\u003emax_minor_ver = MBEDTLS_SSL_MAX_MINOR_VERSION;\n\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =\n                                   ssl_preset_suiteb_ciphersuites;\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n            conf-\u003ecert_profile = \u0026mbedtls_x509_crt_profile_suiteb;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__SIGNATURE_ENABLED)\n            conf-\u003esig_hashes = ssl_preset_suiteb_hashes;\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n            conf-\u003ecurve_list = ssl_preset_suiteb_curves;\n#endif\n            break;\n\n        /*\n         * Default\n         */\n        default:\n            conf-\u003emin_major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;\n            conf-\u003emin_minor_ver = MBEDTLS_SSL_MINOR_VERSION_1; /* TLS 1.0 */\n            conf-\u003emax_major_ver = MBEDTLS_SSL_MAX_MAJOR_VERSION;\n            conf-\u003emax_minor_ver = MBEDTLS_SSL_MAX_MINOR_VERSION;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n            if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n                conf-\u003emin_minor_ver = MBEDTLS_SSL_MINOR_VERSION_2;\n#endif\n\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =\n            conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =\n                                   mbedtls_ssl_list_ciphersuites();\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n            conf-\u003ecert_profile = \u0026mbedtls_x509_crt_profile_default;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__SIGNATURE_ENABLED)\n            conf-\u003esig_hashes = mbedtls_md_list();\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n            conf-\u003ecurve_list = mbedtls_ecp_grp_id_list();\n#endif\n\n#if defined(MBEDTLS_DHM_C) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n            conf-\u003edhm_min_bitlen = 1024;\n#endif\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":6998,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.1.1"},"212119":{"score":0.58061326,"function_name":"mbedtls_ssl_sig_from_pk_alg","code":"unsigned char mbedtls_ssl_sig_from_pk_alg( mbedtls_pk_type_t type )\n{\n    switch( type ) {\n        case MBEDTLS_PK_RSA:\n            return( MBEDTLS_SSL_SIG_RSA );\n        case MBEDTLS_PK_ECDSA:\n        case MBEDTLS_PK_ECKEY:\n            return( MBEDTLS_SSL_SIG_ECDSA );\n        default:\n            return( MBEDTLS_SSL_SIG_ANON );\n    }\n}","filepath":"library/ssl_tls.c","line_number":9975,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"212216":{"score":0.78448224,"function_name":"mbedtls_ssl_sig_hash_set_find","code":"mbedtls_md_type_t mbedtls_ssl_sig_hash_set_find( mbedtls_ssl_sig_hash_set_t *set,\n                                                 mbedtls_pk_type_t sig_alg )\n{\n    switch( sig_alg )\n    {\n        case MBEDTLS_PK_RSA:\n            return( set-\u003ersa );\n        case MBEDTLS_PK_ECDSA:\n            return( set-\u003eecdsa );\n        default:\n            return( MBEDTLS_MD_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":10010,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"212266":{"score":0.8481383,"function_name":"mbedtls_ssl_sig_hash_set_add","code":"void mbedtls_ssl_sig_hash_set_add( mbedtls_ssl_sig_hash_set_t *set,\n                                   mbedtls_pk_type_t sig_alg,\n                                   mbedtls_md_type_t md_alg )\n{\n    switch( sig_alg )\n    {\n        case MBEDTLS_PK_RSA:\n            if( set-\u003ersa == MBEDTLS_MD_NONE )\n                set-\u003ersa = md_alg;\n            break;\n\n        case MBEDTLS_PK_ECDSA:\n            if( set-\u003eecdsa == MBEDTLS_MD_NONE )\n                set-\u003eecdsa = md_alg;\n            break;\n\n        default:\n            break;\n    }\n}","filepath":"library/ssl_tls.c","line_number":10025,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"212374":{"score":0.72490406,"function_name":"mbedtls_ssl_md_alg_from_hash","code":"mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash( unsigned char hash )\n{\n    switch( hash )\n    {\n#if defined(MBEDTLS_MD5_C)\n        case MBEDTLS_SSL_HASH_MD5:\n            return( MBEDTLS_MD_MD5 );\n#endif\n#if defined(MBEDTLS_SHA1_C)\n        case MBEDTLS_SSL_HASH_SHA1:\n            return( MBEDTLS_MD_SHA1 );\n#endif\n#if defined(MBEDTLS_SHA256_C)\n        case MBEDTLS_SSL_HASH_SHA224:\n            return( MBEDTLS_MD_SHA224 );\n        case MBEDTLS_SSL_HASH_SHA256:\n            return( MBEDTLS_MD_SHA256 );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n        case MBEDTLS_SSL_HASH_SHA384:\n            return( MBEDTLS_MD_SHA384 );\n        case MBEDTLS_SSL_HASH_SHA512:\n            return( MBEDTLS_MD_SHA512 );\n#endif\n        default:\n            return( MBEDTLS_MD_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":10060,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"212461":{"score":0.7335087,"function_name":"mbedtls_ssl_hash_from_md_alg","code":"unsigned char mbedtls_ssl_hash_from_md_alg( int md )\n{\n    switch( md )\n    {\n#if defined(MBEDTLS_MD5_C)\n        case MBEDTLS_MD_MD5:\n            return( MBEDTLS_SSL_HASH_MD5 );\n#endif\n#if defined(MBEDTLS_SHA1_C)\n        case MBEDTLS_MD_SHA1:\n            return( MBEDTLS_SSL_HASH_SHA1 );\n#endif\n#if defined(MBEDTLS_SHA256_C)\n        case MBEDTLS_MD_SHA224:\n            return( MBEDTLS_SSL_HASH_SHA224 );\n        case MBEDTLS_MD_SHA256:\n            return( MBEDTLS_SSL_HASH_SHA256 );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n        case MBEDTLS_MD_SHA384:\n            return( MBEDTLS_SSL_HASH_SHA384 );\n        case MBEDTLS_MD_SHA512:\n            return( MBEDTLS_SSL_HASH_SHA512 );\n#endif\n        default:\n            return( MBEDTLS_SSL_HASH_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":10092,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"212541":{"score":0.889192,"function_name":"mbedtls_ssl_check_curve","code":"int mbedtls_ssl_check_curve( const mbedtls_ssl_context *ssl, mbedtls_ecp_group_id grp_id )\n{\n    const mbedtls_ecp_group_id *gid;\n\n    if( ssl-\u003econf-\u003ecurve_list == NULL )\n        return( -1 );\n\n    for( gid = ssl-\u003econf-\u003ecurve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )\n        if( *gid == grp_id )\n            return( 0 );\n\n    return( -1 );\n}","filepath":"library/ssl_tls.c","line_number":10126,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"212825":{"score":0.71841234,"function_name":"mbedtls_ssl_set_calc_verify_md","code":"int mbedtls_ssl_set_calc_verify_md( mbedtls_ssl_context *ssl, int md )\n{\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl-\u003eminor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n        return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n\n    switch( md )\n    {\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)\n#if defined(MBEDTLS_MD5_C)\n        case MBEDTLS_SSL_HASH_MD5:\n            return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n#endif\n#if defined(MBEDTLS_SHA1_C)\n        case MBEDTLS_SSL_HASH_SHA1:\n            ssl-\u003ehandshake-\u003ecalc_verify = ssl_calc_verify_tls;\n            break;\n#endif\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SHA512_C)\n        case MBEDTLS_SSL_HASH_SHA384:\n            ssl-\u003ehandshake-\u003ecalc_verify = ssl_calc_verify_tls_sha384;\n            break;\n#endif\n#if defined(MBEDTLS_SHA256_C)\n        case MBEDTLS_SSL_HASH_SHA256:\n            ssl-\u003ehandshake-\u003ecalc_verify = ssl_calc_verify_tls_sha256;\n            break;\n#endif\n        default:\n            return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n    }\n\n    return 0;\n#else /* !MBEDTLS_SSL_PROTO_TLS1_2 */\n    (void) ssl;\n    (void) md;\n\n    return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n}","filepath":"library/ssl_tls.c","line_number":10306,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"212923":{"score":0.49954534,"function_name":"mbedtls_ssl_get_key_exchange_md_tls1_2","code":"int mbedtls_ssl_get_key_exchange_md_tls1_2( mbedtls_ssl_context *ssl,\n                                            unsigned char *hash, size_t *hashlen,\n                                            unsigned char *data, size_t data_len,\n                                            mbedtls_md_type_t md_alg )\n{\n    int ret = 0;\n    mbedtls_md_context_t ctx;\n    const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );\n    *hashlen = mbedtls_md_get_size( md_info );\n\n    mbedtls_md_init( \u0026ctx );\n\n    /*\n     * digitally-signed struct {\n     *     opaque client_random[32];\n     *     opaque server_random[32];\n     *     ServerDHParams params;\n     * };\n     */\n    if( ( ret = mbedtls_md_setup( \u0026ctx, md_info, 0 ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_setup\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_starts( \u0026ctx ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_starts\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_update( \u0026ctx, ssl-\u003ehandshake-\u003erandbytes, 64 ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_update\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_update( \u0026ctx, data, data_len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_update\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_finish( \u0026ctx, hash ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_finish\", ret );\n        goto exit;\n    }\n\nexit:\n    mbedtls_md_free( \u0026ctx );\n\n    if( ret != 0 )\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":10037,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.12"},"213277":{"score":0.5088502,"function_name":"ssl_bitmask_check","code":"static int ssl_bitmask_check( unsigned char *mask, size_t len )\n{\n    size_t i;\n\n    for( i = 0; i \u003c len / 8; i++ )\n        if( mask[i] != 0xFF )\n            return( -1 );\n\n    for( i = 0; i \u003c len % 8; i++ )\n        if( ( mask[len / 8] \u0026 ( 1 \u003c\u003c ( 7 - i ) ) ) == 0 )\n            return( -1 );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":3879,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"213347":{"score":0.8123913,"function_name":"x509_profile_check_pk_alg","code":"static int x509_profile_check_pk_alg( const mbedtls_x509_crt_profile *profile,\n                                      mbedtls_pk_type_t pk_alg )\n{\n    if( pk_alg == MBEDTLS_PK_NONE )\n        return( -1 );\n\n    if( ( profile-\u003eallowed_pks \u0026 MBEDTLS_X509_ID_FLAG( pk_alg ) ) != 0 )\n        return( 0 );\n\n    return( -1 );\n}","filepath":"library/x509_crt.c","line_number":179,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"213418":{"score":0.81057155,"function_name":"x509_profile_check_key","code":"static int x509_profile_check_key( const mbedtls_x509_crt_profile *profile,\n                                   const mbedtls_pk_context *pk )\n{\n    const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type( pk );\n\n#if defined(MBEDTLS_RSA_C)\n    if( pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS )\n    {\n        if( mbedtls_pk_get_bitlen( pk ) \u003e= profile-\u003ersa_min_bitlen )\n            return( 0 );\n\n        return( -1 );\n    }\n#endif\n\n#if defined(MBEDTLS_ECP_C)\n    if( pk_alg == MBEDTLS_PK_ECDSA ||\n        pk_alg == MBEDTLS_PK_ECKEY ||\n        pk_alg == MBEDTLS_PK_ECKEY_DH )\n    {\n        const mbedtls_ecp_group_id gid = mbedtls_pk_ec( *pk )-\u003egrp.id;\n\n        if( gid == MBEDTLS_ECP_DP_NONE )\n            return( -1 );\n\n        if( ( profile-\u003eallowed_curves \u0026 MBEDTLS_X509_ID_FLAG( gid ) ) != 0 )\n            return( 0 );\n\n        return( -1 );\n    }\n#endif\n\n    return( -1 );\n}","filepath":"library/x509_crt.c","line_number":195,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"213613":{"score":0.8506689,"function_name":"x509_memcasecmp","code":"static int x509_memcasecmp( const void *s1, const void *s2, size_t len )\n{\n    size_t i;\n    unsigned char diff;\n    const unsigned char *n1 = s1, *n2 = s2;\n\n    for( i = 0; i \u003c len; i++ )\n    {\n        diff = n1[i] ^ n2[i];\n\n        if( diff == 0 )\n            continue;\n\n        if( diff == 32 \u0026\u0026\n            ( ( n1[i] \u003e= 'a' \u0026\u0026 n1[i] \u003c= 'z' ) ||\n              ( n1[i] \u003e= 'A' \u0026\u0026 n1[i] \u003c= 'Z' ) ) )\n        {\n            continue;\n        }\n\n        return( -1 );\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":233,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"213779":{"score":0.9177053,"function_name":"x509_check_wildcard","code":"static int x509_check_wildcard( const char *cn, const mbedtls_x509_buf *name )\n{\n    size_t i;\n    size_t cn_idx = 0, cn_len = strlen( cn );\n\n    /* We can't have a match if there is no wildcard to match */\n    if( name-\u003elen \u003c 3 || name-\u003ep[0] != '*' || name-\u003ep[1] != '.' )\n        return( -1 );\n\n    for( i = 0; i \u003c cn_len; ++i )\n    {\n        if( cn[i] == '.' )\n        {\n            cn_idx = i;\n            break;\n        }\n    }\n\n    if( cn_idx == 0 )\n        return( -1 );\n\n    if( cn_len - cn_idx == name-\u003elen - 1 \u0026\u0026\n        x509_memcasecmp( name-\u003ep + 1, cn + cn_idx, name-\u003elen - 1 ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}","filepath":"library/x509_crt.c","line_number":262,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"214011":{"score":0.90525424,"function_name":"x509_string_cmp","code":"static int x509_string_cmp( const mbedtls_x509_buf *a, const mbedtls_x509_buf *b )\n{\n    if( a-\u003etag == b-\u003etag \u0026\u0026\n        a-\u003elen == b-\u003elen \u0026\u0026\n        memcmp( a-\u003ep, b-\u003ep, b-\u003elen ) == 0 )\n    {\n        return( 0 );\n    }\n\n    if( ( a-\u003etag == MBEDTLS_ASN1_UTF8_STRING || a-\u003etag == MBEDTLS_ASN1_PRINTABLE_STRING ) \u0026\u0026\n        ( b-\u003etag == MBEDTLS_ASN1_UTF8_STRING || b-\u003etag == MBEDTLS_ASN1_PRINTABLE_STRING ) \u0026\u0026\n        a-\u003elen == b-\u003elen \u0026\u0026\n        x509_memcasecmp( a-\u003ep, b-\u003ep, b-\u003elen ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}","filepath":"library/x509_crt.c","line_number":298,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"214212":{"score":0.9263316,"function_name":"x509_name_cmp","code":"static int x509_name_cmp( const mbedtls_x509_name *a, const mbedtls_x509_name *b )\n{\n    /* Avoid recursion, it might not be optimised by the compiler */\n    while( a != NULL || b != NULL )\n    {\n        if( a == NULL || b == NULL )\n            return( -1 );\n\n        /* type */\n        if( a-\u003eoid.tag != b-\u003eoid.tag ||\n            a-\u003eoid.len != b-\u003eoid.len ||\n            memcmp( a-\u003eoid.p, b-\u003eoid.p, b-\u003eoid.len ) != 0 )\n        {\n            return( -1 );\n        }\n\n        /* value */\n        if( x509_string_cmp( \u0026a-\u003eval, \u0026b-\u003eval ) != 0 )\n            return( -1 );\n\n        /* structure of the list of sets */\n        if( a-\u003enext_merged != b-\u003enext_merged )\n            return( -1 );\n\n        a = a-\u003enext;\n        b = b-\u003enext;\n    }\n\n    /* a == NULL == b */\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":328,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"214439":{"score":0.8677159,"function_name":"x509_crt_verify_chain_reset","code":"static void x509_crt_verify_chain_reset(\n    mbedtls_x509_crt_verify_chain *ver_chain )\n{\n    size_t i;\n\n    for( i = 0; i \u003c MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE; i++ )\n    {\n        ver_chain-\u003eitems[i].crt = NULL;\n        ver_chain-\u003eitems[i].flags = -1;\n    }\n\n    ver_chain-\u003elen = 0;\n}","filepath":"library/x509_crt.c","line_number":363,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"214514":{"score":0.7991174,"function_name":"x509_get_version","code":"static int x509_get_version( unsigned char **p,\n                             const unsigned char *end,\n                             int *ver )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n        {\n            *ver = 0;\n            return( 0 );\n        }\n\n        return( ret );\n    }\n\n    end = *p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( p, end, ver ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_VERSION + ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_VERSION +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":380,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"214716":{"score":0.7244131,"function_name":"x509_get_dates","code":"static int x509_get_dates( unsigned char **p,\n                           const unsigned char *end,\n                           mbedtls_x509_time *from,\n                           mbedtls_x509_time *to )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_DATE + ret );\n\n    end = *p + len;\n\n    if( ( ret = mbedtls_x509_get_time( p, end, from ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_x509_get_time( p, end, to ) ) != 0 )\n        return( ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_DATE +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":416,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"214933":{"score":0.8430798,"function_name":"x509_get_uid","code":"static int x509_get_uid( unsigned char **p,\n                         const unsigned char *end,\n                         mbedtls_x509_buf *uid, int n )\n{\n    int ret;\n\n    if( *p == end )\n        return( 0 );\n\n    uid-\u003etag = **p;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026uid-\u003elen,\n            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | n ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            return( 0 );\n\n        return( ret );\n    }\n\n    uid-\u003ep = *p;\n    *p += uid-\u003elen;\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":446,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"215081":{"score":0.83182263,"function_name":"x509_get_basic_constraints","code":"static int x509_get_basic_constraints( unsigned char **p,\n                                       const unsigned char *end,\n                                       int *ca_istrue,\n                                       int *max_pathlen )\n{\n    int ret;\n    size_t len;\n\n    /*\n     * BasicConstraints ::= SEQUENCE {\n     *      cA                      BOOLEAN DEFAULT FALSE,\n     *      pathLenConstraint       INTEGER (0..MAX) OPTIONAL }\n     */\n    *ca_istrue = 0; /* DEFAULT FALSE */\n    *max_pathlen = 0; /* endless */\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p == end )\n        return( 0 );\n\n    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            ret = mbedtls_asn1_get_int( p, end, ca_istrue );\n\n        if( ret != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        if( *ca_istrue != 0 )\n            *ca_istrue = 1;\n    }\n\n    if( *p == end )\n        return( 0 );\n\n    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    (*max_pathlen)++;\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":472,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"215419":{"score":0.7919448,"function_name":"x509_get_key_usage","code":"static int x509_get_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               unsigned char *key_usage)\n{\n    int ret;\n    x509_bitstring bs = { 0, 0, NULL };\n\n    if( ( ret = asn1_get_bitstring( p, end, \u0026bs ) ) != 0 )\n        return( POLARSSL_ERR_X509_CERT_INVALID_EXTENSIONS + ret );\n\n    if( bs.len != 1 )\n        return( POLARSSL_ERR_X509_CERT_INVALID_EXTENSIONS +\n                POLARSSL_ERR_ASN1_INVALID_LENGTH );\n\n    /* Get actual bitstring */\n    *key_usage = *bs.p;\n    return 0;\n}","filepath":"library/x509parse.c","line_number":862,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.0.0"},"215579":{"score":0.77718145,"function_name":"x509_get_key_usage","code":"static int x509_get_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               unsigned int *key_usage)\n{\n    int ret;\n    size_t i;\n    mbedtls_x509_bitstring bs = { 0, 0, NULL };\n\n    if( ( ret = mbedtls_asn1_get_bitstring( p, end, \u0026bs ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( bs.len \u003c 1 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    /* Get actual bitstring */\n    *key_usage = 0;\n    for( i = 0; i \u003c bs.len \u0026\u0026 i \u003c sizeof( unsigned int ); i++ )\n    {\n        *key_usage |= (unsigned int) bs.p[i] \u003c\u003c (8*i);\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":541,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"215801":{"score":0.7388896,"function_name":"x509_get_ext_key_usage","code":"static int x509_get_ext_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               mbedtls_x509_sequence *ext_key_usage)\n{\n    int ret;\n\n    if( ( ret = mbedtls_asn1_get_sequence_of( p, end, ext_key_usage, MBEDTLS_ASN1_OID ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    /* Sequence length must be \u003e= 1 */\n    if( ext_key_usage-\u003ebuf.p == NULL )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":571,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"215885":{"score":0.8402713,"function_name":"x509_get_subject_alt_name","code":"static int x509_get_subject_alt_name( unsigned char **p,\n                                      const unsigned char *end,\n                                      mbedtls_x509_sequence *subject_alt_name )\n{\n    int ret;\n    size_t len, tag_len;\n    mbedtls_asn1_buf *buf;\n    unsigned char tag;\n    mbedtls_asn1_sequence *cur = subject_alt_name;\n\n    /* Get main sequence tag */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( *p + len != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    while( *p \u003c end )\n    {\n        if( ( end - *p ) \u003c 1 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n        tag = **p;\n        (*p)++;\n        if( ( ret = mbedtls_asn1_get_len( p, end, \u0026tag_len ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        if( ( tag \u0026 MBEDTLS_ASN1_TAG_CLASS_MASK ) !=\n                MBEDTLS_ASN1_CONTEXT_SPECIFIC )\n        {\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n        }\n\n        /* Skip everything but DNS name */\n        if( tag != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2 ) )\n        {\n            *p += tag_len;\n            continue;\n        }\n\n        /* Allocate and assign next pointer */\n        if( cur-\u003ebuf.p != NULL )\n        {\n            if( cur-\u003enext != NULL )\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );\n\n            cur-\u003enext = mbedtls_calloc( 1, sizeof( mbedtls_asn1_sequence ) );\n\n            if( cur-\u003enext == NULL )\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                        MBEDTLS_ERR_ASN1_ALLOC_FAILED );\n\n            cur = cur-\u003enext;\n        }\n\n        buf = \u0026(cur-\u003ebuf);\n        buf-\u003etag = tag;\n        buf-\u003ep = *p;\n        buf-\u003elen = tag_len;\n        *p += buf-\u003elen;\n    }\n\n    /* Set final sequence entry's next pointer to NULL */\n    cur-\u003enext = NULL;\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":614,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"216354":{"score":0.76146924,"function_name":"x509_get_crt_ext","code":"static int x509_get_crt_ext( unsigned char **p,\n                             const unsigned char *end,\n                             mbedtls_x509_crt *crt )\n{\n    int ret;\n    size_t len;\n    unsigned char *end_ext_data, *end_ext_octet;\n\n    if( ( ret = mbedtls_x509_get_ext( p, end, \u0026crt-\u003ev3_ext, 3 ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            return( 0 );\n\n        return( ret );\n    }\n\n    while( *p \u003c end )\n    {\n        /*\n         * Extension  ::=  SEQUENCE  {\n         *      extnID      OBJECT IDENTIFIER,\n         *      critical    BOOLEAN DEFAULT FALSE,\n         *      extnValue   OCTET STRING  }\n         */\n        mbedtls_x509_buf extn_oid = {0, 0, NULL};\n        int is_critical = 0; /* DEFAULT FALSE */\n        int ext_type = 0;\n\n        if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n                MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        end_ext_data = *p + len;\n\n        /* Get extension ID */\n        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, \u0026extn_oid.len,\n                                          MBEDTLS_ASN1_OID ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        extn_oid.tag = MBEDTLS_ASN1_OID;\n        extn_oid.p = *p;\n        *p += extn_oid.len;\n\n        /* Get optional critical */\n        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data, \u0026is_critical ) ) != 0 \u0026\u0026\n            ( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        /* Data should be octet string type */\n        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, \u0026len,\n                MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n        end_ext_octet = *p + len;\n\n        if( end_ext_octet != end_ext_data )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                    MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n        /*\n         * Detect supported extensions\n         */\n        ret = mbedtls_oid_get_x509_ext_type( \u0026extn_oid, \u0026ext_type );\n\n        if( ret != 0 )\n        {\n            /* No parser found, skip extension */\n            *p = end_ext_octet;\n\n#if !defined(MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION)\n            if( is_critical )\n            {\n                /* Data is marked as critical: fail */\n                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                        MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n            }\n#endif\n            continue;\n        }\n\n        /* Forbid repeated extensions */\n        if( ( crt-\u003eext_types \u0026 ext_type ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );\n\n        crt-\u003eext_types |= ext_type;\n\n        switch( ext_type )\n        {\n        case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:\n            /* Parse basic constraints */\n            if( ( ret = x509_get_basic_constraints( p, end_ext_octet,\n                    \u0026crt-\u003eca_istrue, \u0026crt-\u003emax_pathlen ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_KEY_USAGE:\n            /* Parse key usage */\n            if( ( ret = x509_get_key_usage( p, end_ext_octet,\n                    \u0026crt-\u003ekey_usage ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:\n            /* Parse extended key usage */\n            if( ( ret = x509_get_ext_key_usage( p, end_ext_octet,\n                    \u0026crt-\u003eext_key_usage ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:\n            /* Parse subject alt name */\n            if( ( ret = x509_get_subject_alt_name( p, end_ext_octet,\n                    \u0026crt-\u003esubject_alt_names ) ) != 0 )\n                return( ret );\n            break;\n\n        case MBEDTLS_X509_EXT_NS_CERT_TYPE:\n            /* Parse netscape certificate type */\n            if( ( ret = x509_get_ns_cert_type( p, end_ext_octet,\n                    \u0026crt-\u003ens_cert_type ) ) != 0 )\n                return( ret );\n            break;\n\n        default:\n            return( MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":694,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"217219":{"score":0.869414,"function_name":"x509_crt_parse_der_core","code":"static int x509_crt_parse_der_core( mbedtls_x509_crt *crt, const unsigned char *buf,\n                                    size_t buflen )\n{\n    int ret;\n    size_t len;\n    unsigned char *p, *end, *crt_end;\n    mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;\n\n    memset( \u0026sig_params1, 0, sizeof( mbedtls_x509_buf ) );\n    memset( \u0026sig_params2, 0, sizeof( mbedtls_x509_buf ) );\n    memset( \u0026sig_oid2, 0, sizeof( mbedtls_x509_buf ) );\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    // Use the original buffer until we figure out actual length\n    p = (unsigned char*) buf;\n    len = buflen;\n    end = p + len;\n\n    /*\n     * Certificate  ::=  SEQUENCE  {\n     *      tbsCertificate       TBSCertificate,\n     *      signatureAlgorithm   AlgorithmIdentifier,\n     *      signatureValue       BIT STRING  }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT );\n    }\n\n    if( len \u003e (size_t) ( end - p ) )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n    crt_end = p + len;\n\n    // Create and populate a new buffer for the raw field\n    crt-\u003eraw.len = crt_end - buf;\n    crt-\u003eraw.p = p = mbedtls_calloc( 1, crt-\u003eraw.len );\n    if( p == NULL )\n        return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n    memcpy( p, buf, crt-\u003eraw.len );\n\n    // Direct pointers to the new buffer\n    p += crt-\u003eraw.len - len;\n    end = crt_end = p + len;\n\n    /*\n     * TBSCertificate  ::=  SEQUENCE  {\n     */\n    crt-\u003etbs.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n    crt-\u003etbs.len = end - crt-\u003etbs.p;\n\n    /*\n     * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n     *\n     * CertificateSerialNumber  ::=  INTEGER\n     *\n     * signature            AlgorithmIdentifier\n     */\n    if( ( ret = x509_get_version(  \u0026p, end, \u0026crt-\u003eversion  ) ) != 0 ||\n        ( ret = mbedtls_x509_get_serial(   \u0026p, end, \u0026crt-\u003eserial   ) ) != 0 ||\n        ( ret = mbedtls_x509_get_alg(      \u0026p, end, \u0026crt-\u003esig_oid,\n                                            \u0026sig_params1 ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    if( crt-\u003eversion \u003c 0 || crt-\u003eversion \u003e 2 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_UNKNOWN_VERSION );\n    }\n\n    crt-\u003eversion++;\n\n    if( ( ret = mbedtls_x509_get_sig_alg( \u0026crt-\u003esig_oid, \u0026sig_params1,\n                                  \u0026crt-\u003esig_md, \u0026crt-\u003esig_pk,\n                                  \u0026crt-\u003esig_opts ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     * issuer               Name\n     */\n    crt-\u003eissuer_raw.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    if( ( ret = mbedtls_x509_get_name( \u0026p, p + len, \u0026crt-\u003eissuer ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt-\u003eissuer_raw.len = p - crt-\u003eissuer_raw.p;\n\n    /*\n     * Validity ::= SEQUENCE {\n     *      notBefore      Time,\n     *      notAfter       Time }\n     *\n     */\n    if( ( ret = x509_get_dates( \u0026p, end, \u0026crt-\u003evalid_from,\n                                         \u0026crt-\u003evalid_to ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     * subject              Name\n     */\n    crt-\u003esubject_raw.p = p;\n\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );\n    }\n\n    if( len \u0026\u0026 ( ret = mbedtls_x509_get_name( \u0026p, p + len, \u0026crt-\u003esubject ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    crt-\u003esubject_raw.len = p - crt-\u003esubject_raw.p;\n\n    /*\n     * SubjectPublicKeyInfo\n     */\n    if( ( ret = mbedtls_pk_parse_subpubkey( \u0026p, end, \u0026crt-\u003epk ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    /*\n     *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  extensions      [3]  EXPLICIT Extensions OPTIONAL\n     *                       -- If present, version shall be v3\n     */\n    if( crt-\u003eversion == 2 || crt-\u003eversion == 3 )\n    {\n        ret = x509_get_uid( \u0026p, end, \u0026crt-\u003eissuer_id,  1 );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n    if( crt-\u003eversion == 2 || crt-\u003eversion == 3 )\n    {\n        ret = x509_get_uid( \u0026p, end, \u0026crt-\u003esubject_id,  2 );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n#if !defined(MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3)\n    if( crt-\u003eversion == 3 )\n#endif\n    {\n        ret = x509_get_crt_ext( \u0026p, end, crt );\n        if( ret != 0 )\n        {\n            mbedtls_x509_crt_free( crt );\n            return( ret );\n        }\n    }\n\n    if( p != end )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    end = crt_end;\n\n    /*\n     *  }\n     *  -- end of TBSCertificate\n     *\n     *  signatureAlgorithm   AlgorithmIdentifier,\n     *  signatureValue       BIT STRING\n     */\n    if( ( ret = mbedtls_x509_get_alg( \u0026p, end, \u0026sig_oid2, \u0026sig_params2 ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    if( crt-\u003esig_oid.len != sig_oid2.len ||\n        memcmp( crt-\u003esig_oid.p, sig_oid2.p, crt-\u003esig_oid.len ) != 0 ||\n        sig_params1.len != sig_params2.len ||\n        ( sig_params1.len != 0 \u0026\u0026\n          memcmp( sig_params1.p, sig_params2.p, sig_params1.len ) != 0 ) )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_SIG_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_x509_get_sig( \u0026p, end, \u0026crt-\u003esig ) ) != 0 )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( ret );\n    }\n\n    if( p != end )\n    {\n        mbedtls_x509_crt_free( crt );\n        return( MBEDTLS_ERR_X509_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":832,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"218933":{"score":0.75074995,"function_name":"mbedtls_x509_crt_parse_der","code":"int mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    while( crt-\u003eversion != 0 \u0026\u0026 crt-\u003enext != NULL )\n    {\n        prev = crt;\n        crt = crt-\u003enext;\n    }\n\n    /*\n     * Add new certificate on the end of the chain if needed.\n     */\n    if( crt-\u003eversion != 0 \u0026\u0026 crt-\u003enext == NULL )\n    {\n        crt-\u003enext = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n\n        if( crt-\u003enext == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n        prev = crt;\n        mbedtls_x509_crt_init( crt-\u003enext );\n        crt = crt-\u003enext;\n    }\n\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev-\u003enext = NULL;\n\n        if( crt != chain )\n            mbedtls_free( crt );\n\n        return( ret );\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":1089,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"219223":{"score":0.8378434,"function_name":"x509parse_crt","code":"int x509parse_crt( x509_cert *chain, const unsigned char *buf, size_t buflen )\n{\n    int ret, success = 0, first_error = 0, total_failed = 0;\n    int buf_format = X509_FORMAT_DER;\n\n    /*\n     * Check for valid input\n     */\n    if( chain == NULL || buf == NULL )\n        return( POLARSSL_ERR_X509_INVALID_INPUT );\n\n    /*\n     * Determine buffer content. Buffer contains either one DER certificate or\n     * one or more PEM certificates.\n     */\n#if defined(POLARSSL_PEM_C)\n    if( strstr( (char *) buf, \"-----BEGIN CERTIFICATE-----\" ) != NULL )\n        buf_format = X509_FORMAT_PEM;\n#endif\n\n    if( buf_format == X509_FORMAT_DER )\n        return x509parse_crt_der( chain, buf, buflen );\n\n#if defined(POLARSSL_PEM_C)\n    if( buf_format == X509_FORMAT_PEM )\n    {\n        pem_context pem;\n\n        while( buflen \u003e 0 )\n        {\n            size_t use_len;\n            pem_init( \u0026pem );\n\n            ret = pem_read_buffer( \u0026pem,\n                           \"-----BEGIN CERTIFICATE-----\",\n                           \"-----END CERTIFICATE-----\",\n                           buf, NULL, 0, \u0026use_len );\n\n            if( ret == 0 )\n            {\n                /*\n                 * Was PEM encoded\n                 */\n                buflen -= use_len;\n                buf += use_len;\n            }\n            else if( ret == POLARSSL_ERR_PEM_BAD_INPUT_DATA )\n            {\n                return( ret );\n            }\n            else if( ret != POLARSSL_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n            {\n                pem_free( \u0026pem );\n\n                /*\n                 * PEM header and footer were found\n                 */\n                buflen -= use_len;\n                buf += use_len;\n\n                if( first_error == 0 )\n                    first_error = ret;\n\n                continue;\n            }\n            else\n                break;\n\n            ret = x509parse_crt_der( chain, pem.buf, pem.buflen );\n\n            pem_free( \u0026pem );\n\n            if( ret != 0 )\n            {\n                /*\n                 * Quit parsing on a memory error\n                 */\n                if( ret == POLARSSL_ERR_X509_MALLOC_FAILED )\n                    return( ret );\n\n                if( first_error == 0 )\n                    first_error = ret;\n\n                total_failed++;\n                continue;\n            }\n\n            success = 1;\n        }\n    }\n#endif\n\n    if( success )\n        return( total_failed );\n    else if( first_error )\n        return( first_error );\n    else\n        return( POLARSSL_ERR_X509_CERT_UNKNOWN_FORMAT );\n}","filepath":"library/x509parse.c","line_number":1333,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.1.7"},"219712":{"score":0.8228074,"function_name":"x509_info_subject_alt_name","code":"static int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n\n    while( cur != NULL )\n    {\n        if( cur-\u003ebuf.len + sep_len \u003e= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n\n        n -= cur-\u003ebuf.len + sep_len;\n        for( i = 0; i \u003c sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i \u003c cur-\u003ebuf.len; i++ )\n            *p++ = cur-\u003ebuf.p[i];\n\n        sep = \", \";\n        sep_len = 2;\n\n        cur = cur-\u003enext;\n    }\n\n    *p = '\\0';\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":1396,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"219981":{"score":0.7811507,"function_name":"x509_info_cert_type","code":"static int x509_info_cert_type( char **buf, size_t *size,\n                                unsigned char ns_cert_type )\n{\n    int ret;\n    size_t n = *size;\n    char *p = *buf;\n    const char *sep = \"\";\n\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT,         \"SSL Client\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER,         \"SSL Server\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL,              \"Email\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING,     \"Object Signing\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_RESERVED,           \"Reserved\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CA,             \"SSL CA\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA,           \"Email CA\" );\n    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA,  \"Object Signing CA\" );\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":1445,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"220711":{"score":0.70661724,"function_name":"x509_info_key_usage","code":"static int x509_info_key_usage( char **buf, size_t *size,\n                                unsigned int key_usage )\n{\n    int ret;\n    size_t n = *size;\n    char *p = *buf;\n    const char *sep = \"\";\n\n    KEY_USAGE( MBEDTLS_X509_KU_DIGITAL_SIGNATURE,    \"Digital Signature\" );\n    KEY_USAGE( MBEDTLS_X509_KU_NON_REPUDIATION,      \"Non Repudiation\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_ENCIPHERMENT,     \"Key Encipherment\" );\n    KEY_USAGE( MBEDTLS_X509_KU_DATA_ENCIPHERMENT,    \"Data Encipherment\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_AGREEMENT,        \"Key Agreement\" );\n    KEY_USAGE( MBEDTLS_X509_KU_KEY_CERT_SIGN,        \"Key Cert Sign\" );\n    KEY_USAGE( MBEDTLS_X509_KU_CRL_SIGN,             \"CRL Sign\" );\n    KEY_USAGE( MBEDTLS_X509_KU_ENCIPHER_ONLY,        \"Encipher Only\" );\n    KEY_USAGE( MBEDTLS_X509_KU_DECIPHER_ONLY,        \"Decipher Only\" );\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":1472,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"221516":{"score":0.67238045,"function_name":"x509_info_ext_key_usage","code":"static int x509_info_ext_key_usage( char **buf, size_t *size,\n                                    const mbedtls_x509_sequence *extended_key_usage )\n{\n    int ret;\n    const char *desc;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = extended_key_usage;\n    const char *sep = \"\";\n\n    while( cur != NULL )\n    {\n        if( mbedtls_oid_get_extended_key_usage( \u0026cur-\u003ebuf, \u0026desc ) != 0 )\n            desc = \"???\";\n\n        ret = mbedtls_snprintf( p, n, \"%s%s\", sep, desc );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        sep = \", \";\n\n        cur = cur-\u003enext;\n    }\n\n    *size = n;\n    *buf = p;\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":1496,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"221762":{"score":0.78703976,"function_name":"mbedtls_x509_crt_info","code":"int mbedtls_x509_crt_info( char *buf, size_t size, const char *prefix,\n                   const mbedtls_x509_crt *crt )\n{\n    int ret;\n    size_t n;\n    char *p;\n    char key_size_str[BEFORE_COLON];\n\n    p = buf;\n    n = size;\n\n    if( NULL == crt )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\nCertificate is uninitialised!\\n\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        return( (int) ( size - n ) );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"%scert. version     : %d\\n\",\n                               prefix, crt-\u003eversion );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_snprintf( p, n, \"%sserial number     : \",\n                               prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_x509_serial_gets( p, n, \u0026crt-\u003eserial );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sissuer name       : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_x509_dn_gets( p, n, \u0026crt-\u003eissuer  );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%ssubject name      : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n    ret = mbedtls_x509_dn_gets( p, n, \u0026crt-\u003esubject );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sissued  on        : \" \\\n                   \"%04d-%02d-%02d %02d:%02d:%02d\", prefix,\n                   crt-\u003evalid_from.year, crt-\u003evalid_from.mon,\n                   crt-\u003evalid_from.day,  crt-\u003evalid_from.hour,\n                   crt-\u003evalid_from.min,  crt-\u003evalid_from.sec );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%sexpires on        : \" \\\n                   \"%04d-%02d-%02d %02d:%02d:%02d\", prefix,\n                   crt-\u003evalid_to.year, crt-\u003evalid_to.mon,\n                   crt-\u003evalid_to.day,  crt-\u003evalid_to.hour,\n                   crt-\u003evalid_to.min,  crt-\u003evalid_to.sec );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_snprintf( p, n, \"\\n%ssigned using      : \", prefix );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    ret = mbedtls_x509_sig_alg_gets( p, n, \u0026crt-\u003esig_oid, crt-\u003esig_pk,\n                             crt-\u003esig_md, crt-\u003esig_opts );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    /* Key size */\n    if( ( ret = mbedtls_x509_key_size_helper( key_size_str, BEFORE_COLON,\n                                      mbedtls_pk_get_name( \u0026crt-\u003epk ) ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"\\n%s%-\" BC \"s: %d bits\", prefix, key_size_str,\n                          (int) mbedtls_pk_get_bitlen( \u0026crt-\u003epk ) );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    /*\n     * Optional extensions\n     */\n\n    if( crt-\u003eext_types \u0026 MBEDTLS_X509_EXT_BASIC_CONSTRAINTS )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%sbasic constraints : CA=%s\", prefix,\n                        crt-\u003eca_istrue ? \"true\" : \"false\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( crt-\u003emax_pathlen \u003e 0 )\n        {\n            ret = mbedtls_snprintf( p, n, \", max_pathlen=%d\", crt-\u003emax_pathlen - 1 );\n            MBEDTLS_X509_SAFE_SNPRINTF;\n        }\n    }\n\n    if( crt-\u003eext_types \u0026 MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%ssubject alt name  : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_subject_alt_name( \u0026p, \u0026n,\n                                            \u0026crt-\u003esubject_alt_names ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt-\u003eext_types \u0026 MBEDTLS_X509_EXT_NS_CERT_TYPE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%scert. type        : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_cert_type( \u0026p, \u0026n, crt-\u003ens_cert_type ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt-\u003eext_types \u0026 MBEDTLS_X509_EXT_KEY_USAGE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%skey usage         : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_key_usage( \u0026p, \u0026n, crt-\u003ekey_usage ) ) != 0 )\n            return( ret );\n    }\n\n    if( crt-\u003eext_types \u0026 MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE )\n    {\n        ret = mbedtls_snprintf( p, n, \"\\n%sext key usage     : \", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        if( ( ret = x509_info_ext_key_usage( \u0026p, \u0026n,\n                                             \u0026crt-\u003eext_key_usage ) ) != 0 )\n            return( ret );\n    }\n\n    ret = mbedtls_snprintf( p, n, \"\\n\" );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    return( (int) ( size - n ) );\n}","filepath":"library/x509_crt.c","line_number":1530,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"224073":{"score":0.8412166,"function_name":"mbedtls_x509_crt_verify_info","code":"int mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n                          uint32_t flags )\n{\n    int ret;\n    const struct x509_crt_verify_string *cur;\n    char *p = buf;\n    size_t n = size;\n\n    for( cur = x509_crt_verify_strings; cur-\u003estring != NULL ; cur++ )\n    {\n        if( ( flags \u0026 cur-\u003ecode ) == 0 )\n            continue;\n\n        ret = mbedtls_snprintf( p, n, \"%s%s\\n\", prefix, cur-\u003estring );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n        flags ^= cur-\u003ecode;\n    }\n\n    if( flags != 0 )\n    {\n        ret = mbedtls_snprintf( p, n, \"%sUnknown reason \"\n                                       \"(this should not happen)\\n\", prefix );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n    }\n\n    return( (int) ( size - n ) );\n}","filepath":"library/x509_crt.c","line_number":1691,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"224298":{"score":0.7851293,"function_name":"mbedtls_x509_crt_is_revoked","code":"int mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )\n{\n    const mbedtls_x509_crl_entry *cur = \u0026crl-\u003eentry;\n\n    while( cur != NULL \u0026\u0026 cur-\u003eserial.len != 0 )\n    {\n        if( crt-\u003eserial.len == cur-\u003eserial.len \u0026\u0026\n            memcmp( crt-\u003eserial.p, cur-\u003eserial.p, crt-\u003eserial.len ) == 0 )\n        {\n            if( mbedtls_x509_time_is_past( \u0026cur-\u003erevocation_date ) )\n                return( 1 );\n        }\n\n        cur = cur-\u003enext;\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":1780,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"224445":{"score":0.7973695,"function_name":"x509_crt_verifycrl","code":"static int x509_crt_verifycrl( mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,\n                               mbedtls_x509_crl *crl_list,\n                               const mbedtls_x509_crt_profile *profile )\n{\n    int flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    const mbedtls_md_info_t *md_info;\n\n    if( ca == NULL )\n        return( flags );\n\n    while( crl_list != NULL )\n    {\n        if( crl_list-\u003eversion == 0 ||\n            x509_name_cmp( \u0026crl_list-\u003eissuer, \u0026ca-\u003esubject ) != 0 )\n        {\n            crl_list = crl_list-\u003enext;\n            continue;\n        }\n\n        /*\n         * Check if the CA is configured to sign CRLs\n         */\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n        if( mbedtls_x509_crt_check_key_usage( ca,\n                                              MBEDTLS_X509_KU_CRL_SIGN ) != 0 )\n        {\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n#endif\n\n        /*\n         * Check if CRL is correctly signed by the trusted CA\n         */\n        if( x509_profile_check_md_alg( profile, crl_list-\u003esig_md ) != 0 )\n            flags |= MBEDTLS_X509_BADCRL_BAD_MD;\n\n        if( x509_profile_check_pk_alg( profile, crl_list-\u003esig_pk ) != 0 )\n            flags |= MBEDTLS_X509_BADCRL_BAD_PK;\n\n        md_info = mbedtls_md_info_from_type( crl_list-\u003esig_md );\n        if( mbedtls_md( md_info, crl_list-\u003etbs.p, crl_list-\u003etbs.len, hash ) != 0 )\n        {\n            /* Note: this can't happen except after an internal error */\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n\n        if( x509_profile_check_key( profile, \u0026ca-\u003epk ) != 0 )\n            flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( crl_list-\u003esig_pk, crl_list-\u003esig_opts, \u0026ca-\u003epk,\n                           crl_list-\u003esig_md, hash, mbedtls_md_get_size( md_info ),\n                           crl_list-\u003esig.p, crl_list-\u003esig.len ) != 0 )\n        {\n            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;\n            break;\n        }\n\n        /*\n         * Check for validity of CRL (Do not drop out)\n         */\n        if( mbedtls_x509_time_is_past( \u0026crl_list-\u003enext_update ) )\n            flags |= MBEDTLS_X509_BADCRL_EXPIRED;\n\n        if( mbedtls_x509_time_is_future( \u0026crl_list-\u003ethis_update ) )\n            flags |= MBEDTLS_X509_BADCRL_FUTURE;\n\n        /*\n         * Check if certificate is revoked\n         */\n        if( mbedtls_x509_crt_is_revoked( crt, crl_list ) )\n        {\n            flags |= MBEDTLS_X509_BADCERT_REVOKED;\n            break;\n        }\n\n        crl_list = crl_list-\u003enext;\n    }\n\n    return( flags );\n}","filepath":"library/x509_crt.c","line_number":1803,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"225004":{"score":0.66339844,"function_name":"x509_crt_check_signature","code":"static int x509_crt_check_signature( const mbedtls_x509_crt *child,\n                                     mbedtls_x509_crt *parent,\n                                     mbedtls_x509_crt_restart_ctx *rs_ctx )\n{\n    const mbedtls_md_info_t *md_info;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n\n    md_info = mbedtls_md_info_from_type( child-\u003esig_md );\n    if( mbedtls_md( md_info, child-\u003etbs.p, child-\u003etbs.len, hash ) != 0 )\n    {\n        /* Note: this can't happen except after an internal error */\n        return( -1 );\n    }\n\n    /* Skip expensive computation on obvious mismatch */\n    if( ! mbedtls_pk_can_do( \u0026parent-\u003epk, child-\u003esig_pk ) )\n        return( -1 );\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 child-\u003esig_pk == MBEDTLS_PK_ECDSA )\n    {\n        return( mbedtls_pk_verify_restartable( \u0026parent-\u003epk,\n                    child-\u003esig_md, hash, mbedtls_md_get_size( md_info ),\n                    child-\u003esig.p, child-\u003esig.len, \u0026rs_ctx-\u003epk ) );\n    }\n#else\n    (void) rs_ctx;\n#endif\n\n    return( mbedtls_pk_verify_ext( child-\u003esig_pk, child-\u003esig_opts, \u0026parent-\u003epk,\n                child-\u003esig_md, hash, mbedtls_md_get_size( md_info ),\n                child-\u003esig.p, child-\u003esig.len ) );\n}","filepath":"library/x509_crt.c","line_number":1891,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"225292":{"score":0.82245874,"function_name":"x509_crt_check_parent","code":"static int x509_crt_check_parent( const mbedtls_x509_crt *child,\n                                  const mbedtls_x509_crt *parent,\n                                  int top )\n{\n    int need_ca_bit;\n\n    /* Parent must be the issuer */\n    if( x509_name_cmp( \u0026child-\u003eissuer, \u0026parent-\u003esubject ) != 0 )\n        return( -1 );\n\n    /* Parent must have the basicConstraints CA bit set as a general rule */\n    need_ca_bit = 1;\n\n    /* Exception: v1/v2 certificates that are locally trusted. */\n    if( top \u0026\u0026 parent-\u003eversion \u003c 3 )\n        need_ca_bit = 0;\n\n    if( need_ca_bit \u0026\u0026 ! parent-\u003eca_istrue )\n        return( -1 );\n\n#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)\n    if( need_ca_bit \u0026\u0026\n        mbedtls_x509_crt_check_key_usage( parent, MBEDTLS_X509_KU_KEY_CERT_SIGN ) != 0 )\n    {\n        return( -1 );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":1931,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"225408":{"score":0.80276644,"function_name":"x509_crt_find_parent_in","code":"static int x509_crt_find_parent_in(\n                        mbedtls_x509_crt *child,\n                        mbedtls_x509_crt *candidates,\n                        mbedtls_x509_crt **r_parent,\n                        int *r_signature_is_good,\n                        int top,\n                        unsigned path_cnt,\n                        unsigned self_cnt,\n                        mbedtls_x509_crt_restart_ctx *rs_ctx )\n{\n    int ret;\n    mbedtls_x509_crt *parent, *fallback_parent;\n    int signature_is_good, fallback_signature_is_good;\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n    /* did we have something in progress? */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003eparent != NULL )\n    {\n        /* restore saved state */\n        parent = rs_ctx-\u003eparent;\n        fallback_parent = rs_ctx-\u003efallback_parent;\n        fallback_signature_is_good = rs_ctx-\u003efallback_signature_is_good;\n\n        /* clear saved state */\n        rs_ctx-\u003eparent = NULL;\n        rs_ctx-\u003efallback_parent = NULL;\n        rs_ctx-\u003efallback_signature_is_good = 0;\n\n        /* resume where we left */\n        goto check_signature;\n    }\n#endif\n\n    fallback_parent = NULL;\n    fallback_signature_is_good = 0;\n\n    for( parent = candidates; parent != NULL; parent = parent-\u003enext )\n    {\n        /* basic parenting skills (name, CA bit, key usage) */\n        if( x509_crt_check_parent( child, parent, top ) != 0 )\n            continue;\n\n        /* +1 because stored max_pathlen is 1 higher that the actual value */\n        if( parent-\u003emax_pathlen \u003e 0 \u0026\u0026\n            (size_t) parent-\u003emax_pathlen \u003c 1 + path_cnt - self_cnt )\n        {\n            continue;\n        }\n\n        /* Signature */\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\ncheck_signature:\n#endif\n        ret = x509_crt_check_signature( child, parent, rs_ctx );\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n        if( rs_ctx != NULL \u0026\u0026 ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n        {\n            /* save state */\n            rs_ctx-\u003eparent = parent;\n            rs_ctx-\u003efallback_parent = fallback_parent;\n            rs_ctx-\u003efallback_signature_is_good = fallback_signature_is_good;\n\n            return( ret );\n        }\n#else\n        (void) ret;\n#endif\n\n        signature_is_good = ret == 0;\n        if( top \u0026\u0026 ! signature_is_good )\n            continue;\n\n        /* optional time check */\n        if( mbedtls_x509_time_is_past( \u0026parent-\u003evalid_to ) ||\n            mbedtls_x509_time_is_future( \u0026parent-\u003evalid_from ) )\n        {\n            if( fallback_parent == NULL )\n            {\n                fallback_parent = parent;\n                fallback_signature_is_good = signature_is_good;\n            }\n\n            continue;\n        }\n\n        break;\n    }\n\n    if( parent != NULL )\n    {\n        *r_parent = parent;\n        *r_signature_is_good = signature_is_good;\n    }\n    else\n    {\n        *r_parent = fallback_parent;\n        *r_signature_is_good = fallback_signature_is_good;\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":2005,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"225717":{"score":0.8490764,"function_name":"x509_crt_find_parent","code":"static int x509_crt_find_parent(\n                        mbedtls_x509_crt *child,\n                        mbedtls_x509_crt *trust_ca,\n                        mbedtls_x509_crt **parent,\n                        int *parent_is_trusted,\n                        int *signature_is_good,\n                        unsigned path_cnt,\n                        unsigned self_cnt,\n                        mbedtls_x509_crt_restart_ctx *rs_ctx )\n{\n    int ret;\n    mbedtls_x509_crt *search_list;\n\n    *parent_is_trusted = 1;\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n    /* restore then clear saved state if we have some stored */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003eparent_is_trusted != -1 )\n    {\n        *parent_is_trusted = rs_ctx-\u003eparent_is_trusted;\n        rs_ctx-\u003eparent_is_trusted = -1;\n    }\n#endif\n\n    while( 1 ) {\n        search_list = *parent_is_trusted ? trust_ca : child-\u003enext;\n\n        ret = x509_crt_find_parent_in( child, search_list,\n                                       parent, signature_is_good,\n                                       *parent_is_trusted,\n                                       path_cnt, self_cnt, rs_ctx );\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n        if( rs_ctx != NULL \u0026\u0026 ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n        {\n            /* save state */\n            rs_ctx-\u003eparent_is_trusted = *parent_is_trusted;\n            return( ret );\n        }\n#else\n        (void) ret;\n#endif\n\n        /* stop here if found or already in second iteration */\n        if( *parent != NULL || *parent_is_trusted == 0 )\n            break;\n\n        /* prepare second iteration */\n        *parent_is_trusted = 0;\n    }\n\n    /* extra precaution against mistakes in the caller */\n    if( *parent == NULL )\n    {\n        *parent_is_trusted = 0;\n        *signature_is_good = 0;\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":2130,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"225869":{"score":0.8966304,"function_name":"x509_crt_check_ee_locally_trusted","code":"static int x509_crt_check_ee_locally_trusted(\n                    mbedtls_x509_crt *crt,\n                    mbedtls_x509_crt *trust_ca )\n{\n    mbedtls_x509_crt *cur;\n\n    /* must be self-issued */\n    if( x509_name_cmp( \u0026crt-\u003eissuer, \u0026crt-\u003esubject ) != 0 )\n        return( -1 );\n\n    /* look for an exact match with trusted cert */\n    for( cur = trust_ca; cur != NULL; cur = cur-\u003enext )\n    {\n        if( crt-\u003eraw.len == cur-\u003eraw.len \u0026\u0026\n            memcmp( crt-\u003eraw.p, cur-\u003eraw.p, crt-\u003eraw.len ) == 0 )\n        {\n            return( 0 );\n        }\n    }\n\n    /* too bad */\n    return( -1 );\n}","filepath":"library/x509_crt.c","line_number":2197,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"226018":{"score":0.7327827,"function_name":"x509_crt_verify_chain","code":"static int x509_crt_verify_chain(\n                mbedtls_x509_crt *crt,\n                mbedtls_x509_crt *trust_ca,\n                mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                mbedtls_x509_crt_verify_chain *ver_chain,\n                mbedtls_x509_crt_restart_ctx *rs_ctx )\n{\n    /* Don't initialize any of those variables here, so that the compiler can\n     * catch potential issues with jumping ahead when restarting */\n    int ret;\n    uint32_t *flags;\n    mbedtls_x509_crt_verify_chain_item *cur;\n    mbedtls_x509_crt *child;\n    mbedtls_x509_crt *parent;\n    int parent_is_trusted;\n    int child_is_trusted;\n    int signature_is_good;\n    unsigned self_cnt;\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n    /* resume if we had an operation in progress */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ein_progress == x509_crt_rs_find_parent )\n    {\n        /* restore saved state */\n        *ver_chain = rs_ctx-\u003ever_chain; /* struct copy */\n        self_cnt = rs_ctx-\u003eself_cnt;\n\n        /* restore derived state */\n        cur = \u0026ver_chain-\u003eitems[ver_chain-\u003elen - 1];\n        child = cur-\u003ecrt;\n        flags = \u0026cur-\u003eflags;\n\n        goto find_parent;\n    }\n#endif /* MBEDTLS_ECDSA_C \u0026\u0026 MBEDTLS_ECP_RESTARTABLE */\n\n    child = crt;\n    self_cnt = 0;\n    parent_is_trusted = 0;\n    child_is_trusted = 0;\n\n    while( 1 ) {\n        /* Add certificate to the verification chain */\n        cur = \u0026ver_chain-\u003eitems[ver_chain-\u003elen];\n        cur-\u003ecrt = child;\n        cur-\u003eflags = 0;\n        ver_chain-\u003elen++;\n        flags = \u0026cur-\u003eflags;\n\n        /* Check time-validity (all certificates) */\n        if( mbedtls_x509_time_is_past( \u0026child-\u003evalid_to ) )\n            *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n        if( mbedtls_x509_time_is_future( \u0026child-\u003evalid_from ) )\n            *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n        /* Stop here for trusted roots (but not for trusted EE certs) */\n        if( child_is_trusted )\n            return( 0 );\n\n        /* Check signature algorithm: MD \u0026 PK algs */\n        if( x509_profile_check_md_alg( profile, child-\u003esig_md ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n        if( x509_profile_check_pk_alg( profile, child-\u003esig_pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n        /* Special case: EE certs that are locally trusted */\n        if( ver_chain-\u003elen == 1 \u0026\u0026\n            x509_crt_check_ee_locally_trusted( child, trust_ca ) == 0 )\n        {\n            return( 0 );\n        }\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\nfind_parent:\n#endif\n        /* Look for a parent in trusted CAs or up the chain */\n        ret = x509_crt_find_parent( child, trust_ca, \u0026parent,\n                                       \u0026parent_is_trusted, \u0026signature_is_good,\n                                       ver_chain-\u003elen - 1, self_cnt, rs_ctx );\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n        if( rs_ctx != NULL \u0026\u0026 ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n        {\n            /* save state */\n            rs_ctx-\u003ein_progress = x509_crt_rs_find_parent;\n            rs_ctx-\u003eself_cnt = self_cnt;\n            rs_ctx-\u003ever_chain = *ver_chain; /* struct copy */\n\n            return( ret );\n        }\n#else\n        (void) ret;\n#endif\n\n        /* No parent? We're done here */\n        if( parent == NULL )\n        {\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n            return( 0 );\n        }\n\n        /* Count intermediate self-issued (not necessarily self-signed) certs.\n         * These can occur with some strategies for key rollover, see [SIRO],\n         * and should be excluded from max_pathlen checks. */\n        if( ver_chain-\u003elen != 1 \u0026\u0026\n            x509_name_cmp( \u0026child-\u003eissuer, \u0026child-\u003esubject ) == 0 )\n        {\n            self_cnt++;\n        }\n\n        /* path_cnt is 0 for the first intermediate CA,\n         * and if parent is trusted it's not an intermediate CA */\n        if( ! parent_is_trusted \u0026\u0026\n            ver_chain-\u003elen \u003e MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n        {\n            /* return immediately to avoid overflow the chain array */\n            return( MBEDTLS_ERR_X509_FATAL_ERROR );\n        }\n\n        /* signature was checked while searching parent */\n        if( ! signature_is_good )\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n\n        /* check size of signing key */\n        if( x509_profile_check_key( profile, \u0026parent-\u003epk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n        /* Check trusted CA's CRL for the given crt */\n        *flags |= x509_crt_verifycrl( child, parent, ca_crl, profile );\n#else\n        (void) ca_crl;\n#endif\n\n        /* prepare for next iteration */\n        child = parent;\n        parent = NULL;\n        child_is_trusted = parent_is_trusted;\n        signature_is_good = 0;\n    }\n}","filepath":"library/x509_crt.c","line_number":2261,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"226698":{"score":0.7881861,"function_name":"x509_crt_check_cn","code":"static int x509_crt_check_cn( const mbedtls_x509_buf *name,\n                              const char *cn, size_t cn_len )\n{\n    /* try exact match */\n    if( name-\u003elen == cn_len \u0026\u0026\n        x509_memcasecmp( cn, name-\u003ep, cn_len ) == 0 )\n    {\n        return( 0 );\n    }\n\n    /* try wildcard match */\n    if( x509_check_wildcard( cn, name ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}","filepath":"library/x509_crt.c","line_number":2409,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"226792":{"score":0.857656,"function_name":"x509_crt_verify_name","code":"static void x509_crt_verify_name( const mbedtls_x509_crt *crt,\n                                  const char *cn,\n                                  uint32_t *flags )\n{\n    const mbedtls_x509_name *name;\n    const mbedtls_x509_sequence *cur;\n    size_t cn_len = strlen( cn );\n\n    if( crt-\u003eext_types \u0026 MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n    {\n        for( cur = \u0026crt-\u003esubject_alt_names; cur != NULL; cur = cur-\u003enext )\n        {\n            if( x509_crt_check_cn( \u0026cur-\u003ebuf, cn, cn_len ) == 0 )\n                break;\n        }\n\n        if( cur == NULL )\n            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n    }\n    else\n    {\n        for( name = \u0026crt-\u003esubject; name != NULL; name = name-\u003enext )\n        {\n            if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, \u0026name-\u003eoid ) == 0 \u0026\u0026\n                x509_crt_check_cn( \u0026name-\u003eval, cn, cn_len ) == 0 )\n            {\n                break;\n            }\n        }\n\n        if( name == NULL )\n            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n    }\n}","filepath":"library/x509_crt.c","line_number":2431,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"227076":{"score":0.9044054,"function_name":"x509_crt_merge_flags_with_cb","code":"static int x509_crt_merge_flags_with_cb(\n           uint32_t *flags,\n           const mbedtls_x509_crt_verify_chain *ver_chain,\n           int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n           void *p_vrfy )\n{\n    int ret;\n    unsigned i;\n    uint32_t cur_flags;\n    const mbedtls_x509_crt_verify_chain_item *cur;\n\n    for( i = ver_chain-\u003elen; i != 0; --i )\n    {\n        cur = \u0026ver_chain-\u003eitems[i-1];\n        cur_flags = cur-\u003eflags;\n\n        if( NULL != f_vrfy )\n            if( ( ret = f_vrfy( p_vrfy, cur-\u003ecrt, (int) i-1, \u0026cur_flags ) ) != 0 )\n                return( ret );\n\n        *flags |= cur_flags;\n    }\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":2469,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"227379":{"score":0.75711703,"function_name":"mbedtls_x509_crt_verify_restartable","code":"int mbedtls_x509_crt_verify_restartable( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy,\n                     mbedtls_x509_crt_restart_ctx *rs_ctx )\n{\n    int ret;\n    mbedtls_pk_type_t pk_type;\n    mbedtls_x509_crt_verify_chain ver_chain;\n    uint32_t ee_flags;\n\n    *flags = 0;\n    ee_flags = 0;\n    x509_crt_verify_chain_reset( \u0026ver_chain );\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    /* check name if requested */\n    if( cn != NULL )\n        x509_crt_verify_name( crt, cn, \u0026ee_flags );\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( \u0026crt-\u003epk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        ee_flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, \u0026crt-\u003epk ) != 0 )\n        ee_flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Check the chain */\n    ret = x509_crt_verify_chain( crt, trust_ca, ca_crl, profile,\n                                 \u0026ver_chain, rs_ctx );\n\n    if( ret != 0 )\n        goto exit;\n\n    /* Merge end-entity flags */\n    ver_chain.items[0].flags |= ee_flags;\n\n    /* Build final flags, calling callback on the way if any */\n    ret = x509_crt_merge_flags_with_cb( flags, \u0026ver_chain, f_vrfy, p_vrfy );\n\nexit:\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 ret != MBEDTLS_ERR_ECP_IN_PROGRESS )\n        mbedtls_x509_crt_restart_free( rs_ctx );\n#endif\n\n    /* prevent misuse of the vrfy callback - VERIFY_FAILED would be ignored by\n     * the SSL module for authmode optional, but non-zero return from the\n     * callback means a fatal error so it shouldn't be ignored */\n    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )\n        ret = MBEDTLS_ERR_X509_FATAL_ERROR;\n\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}","filepath":"library/x509_crt.c","line_number":2535,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"227894":{"score":0.7860532,"function_name":"mbedtls_x509_crt_free","code":"void mbedtls_x509_crt_free( mbedtls_x509_crt *crt )\n{\n    mbedtls_x509_crt *cert_cur = crt;\n    mbedtls_x509_crt *cert_prv;\n    mbedtls_x509_name *name_cur;\n    mbedtls_x509_name *name_prv;\n    mbedtls_x509_sequence *seq_cur;\n    mbedtls_x509_sequence *seq_prv;\n\n    if( crt == NULL )\n        return;\n\n    do\n    {\n        mbedtls_pk_free( \u0026cert_cur-\u003epk );\n\n#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)\n        mbedtls_free( cert_cur-\u003esig_opts );\n#endif\n\n        name_cur = cert_cur-\u003eissuer.next;\n        while( name_cur != NULL )\n        {\n            name_prv = name_cur;\n            name_cur = name_cur-\u003enext;\n            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );\n            mbedtls_free( name_prv );\n        }\n\n        name_cur = cert_cur-\u003esubject.next;\n        while( name_cur != NULL )\n        {\n            name_prv = name_cur;\n            name_cur = name_cur-\u003enext;\n            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );\n            mbedtls_free( name_prv );\n        }\n\n        seq_cur = cert_cur-\u003eext_key_usage.next;\n        while( seq_cur != NULL )\n        {\n            seq_prv = seq_cur;\n            seq_cur = seq_cur-\u003enext;\n            mbedtls_platform_zeroize( seq_prv,\n                                      sizeof( mbedtls_x509_sequence ) );\n            mbedtls_free( seq_prv );\n        }\n\n        seq_cur = cert_cur-\u003esubject_alt_names.next;\n        while( seq_cur != NULL )\n        {\n            seq_prv = seq_cur;\n            seq_cur = seq_cur-\u003enext;\n            mbedtls_platform_zeroize( seq_prv,\n                                      sizeof( mbedtls_x509_sequence ) );\n            mbedtls_free( seq_prv );\n        }\n\n        if( cert_cur-\u003eraw.p != NULL )\n        {\n            mbedtls_platform_zeroize( cert_cur-\u003eraw.p, cert_cur-\u003eraw.len );\n            mbedtls_free( cert_cur-\u003eraw.p );\n        }\n\n        cert_cur = cert_cur-\u003enext;\n    }\n    while( cert_cur != NULL );\n\n    cert_cur = crt;\n    do\n    {\n        cert_prv = cert_cur;\n        cert_cur = cert_cur-\u003enext;\n\n        mbedtls_platform_zeroize( cert_prv, sizeof( mbedtls_x509_crt ) );\n        if( cert_prv != crt )\n            mbedtls_free( cert_prv );\n    }\n    while( cert_cur != NULL );\n}","filepath":"library/x509_crt.c","line_number":2620,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"229001":{"score":0.8893537,"function_name":"iot_command_send","code":"iot_error_t iot_command_send(struct iot_context *ctx,\n\tenum iot_command_type new_cmd, const void *param, int param_size)\n{\n\tstruct iot_command cmd_data;\n\tint ret;\n\tiot_error_t err;\n\n\tif (param \u0026\u0026 (param_size \u003e 0)) {\n\t\tcmd_data.param = malloc(param_size);\n\t\tif (!cmd_data.param) {\n\t\t\tIOT_ERROR(\"failed to malloc for iot_command param\");\n\t\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t}\n\n\t\tmemcpy(cmd_data.param, param, param_size);\n\t} else {\n\t\tcmd_data.param = NULL;\n\t}\n\n\tcmd_data.cmd_type = new_cmd;\n\n\tret = iot_os_queue_send(ctx-\u003ecmd_queue, \u0026cmd_data, 0);\n\tif (ret != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"Cannot put the cmd into cmd_queue\");\n\t\tif (cmd_data.param)\n\t\t\tfree(cmd_data.param);\n\t\terr = IOT_ERROR_BAD_REQ;\n\t} else {\n\t\t_set_cmd_status(ctx, new_cmd);\n\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_COMMAND);\n\t\terr = IOT_ERROR_NONE;\n\t}\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":47,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"229339":{"score":0.8711265,"function_name":"iot_wifi_ctrl_request","code":"iot_error_t iot_wifi_ctrl_request(struct iot_context *ctx,\n\t\tiot_wifi_mode_t wifi_mode)\n{\n\tiot_error_t iot_err = IOT_ERROR_BAD_REQ;\n\tiot_wifi_conf wifi_conf;\n\tbool send_cmd = true;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"There is no ctx\\n\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tmemset(\u0026wifi_conf, 0, sizeof(wifi_conf));\n\twifi_conf.mode = wifi_mode;\n\n\tswitch (wifi_mode) {\n\tcase IOT_WIFI_MODE_OFF:\n\t\t/* fall through */\n\tcase IOT_WIFI_MODE_STATION:\n\t\t/* easysetup resource deinit \u0026 free for both */\n\t\tif (ctx-\u003ees_http_ready) {\n\t\t\tctx-\u003ees_http_ready = false;\n\t\t\tiot_easysetup_deinit(ctx);\n\t\t}\n\n\t\tif (ctx-\u003escan_result) {\n\t\t\tfree(ctx-\u003escan_result);\n\t\t\tctx-\u003escan_result = NULL;\n\t\t}\n\t\tctx-\u003escan_num = 0;\n\n\t\tif (wifi_mode == IOT_WIFI_MODE_STATION) {\n\t\t\tmemcpy(wifi_conf.ssid, ctx-\u003eprov_data.wifi.ssid,\n\t\t\t\tstrlen(ctx-\u003eprov_data.wifi.ssid));\n\t\t\tmemcpy(wifi_conf.pass, ctx-\u003eprov_data.wifi.password,\n\t\t\t\tstrlen(ctx-\u003eprov_data.wifi.password));\n\t\t\tif (ctx-\u003eprov_data.wifi.mac_str[0] != '\\0') {\n\t\t\t\tmemcpy(wifi_conf.bssid, ctx-\u003eprov_data.wifi.bssid.addr,\n\t\t\t\t\tIOT_WIFI_MAX_BSSID_LEN);\n\t\t\t}\n\t\t\twifi_conf.authmode = ctx-\u003eprov_data.wifi.security_type;\n\t\t} else {\t/* For IOT_WIFI_MODE_OFF case */\n\t\t\tsend_cmd = false;\n\n\t\t\tiot_err = iot_bsp_wifi_set_mode(\u0026wifi_conf);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to set wifi_set_mode for scan\\n\");\n\t\t\t\treturn iot_err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOT_WIFI_MODE_SOFTAP:\n\t\t/*wifi soft-ap mode w/ ssid E4 format*/\n\t\tiot_err = iot_easysetup_create_ssid(\u0026(ctx-\u003edevconf),\n\t\t\t\t\twifi_conf.ssid, IOT_WIFI_MAX_SSID_LEN);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't create ssid for easysetup.(%d)\", iot_err);\n\t\t\treturn iot_err;\n\t\t}\n\n\t\tsnprintf(wifi_conf.pass, sizeof(wifi_conf.pass), \"1111122222\");\n\t\twifi_conf.authmode = IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\t\tbreak;\n\n\tcase IOT_WIFI_MODE_SCAN:\n\t\tsend_cmd = false;\n\n\t\tiot_err = iot_bsp_wifi_set_mode(\u0026wifi_conf);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to set wifi_set_mode for scan\\n\");\n\t\t\treturn iot_err;\n\t\t}\n\n\t\tif (!ctx-\u003escan_result) {\n\t\t\tctx-\u003escan_result = (iot_wifi_scan_result_t *)iot_os_malloc(IOT_WIFI_MAX_SCAN_RESULT * sizeof(iot_wifi_scan_result_t));\n\t\t\tif (!ctx-\u003escan_result) {\n\t\t\t\tIOT_ERROR(\"failed to malloc for iot_wifi_scan_result_t\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset(ctx-\u003escan_result, 0x0, (IOT_WIFI_MAX_SCAN_RESULT * sizeof(iot_wifi_scan_result_t)));\n\t\t}\n\n\t\tctx-\u003escan_num = iot_bsp_wifi_get_scan_result(ctx-\u003escan_result);\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported wifi ctrl mode[%d]\\n\", wifi_mode);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (send_cmd) {\n\t\tiot_err = iot_command_send(ctx,\n\t\t\t\tIOT_COMMAND_NETWORK_MODE,\n\t\t\t\t\t\u0026wifi_conf, sizeof(wifi_conf));\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":85,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"230373":{"score":0.8815773,"function_name":"iot_easysetup_request","code":"iot_error_t iot_easysetup_request(struct iot_context *ctx,\n\t\t\t\tenum iot_easysetup_step step, const void *payload)\n{\n\tstruct iot_easysetup_payload request;\n\tint ret;\n\tiot_error_t err;\n\n\tif (payload) {\n\t\trequest.payload = (char *)payload;\n\t} else {\n\t\trequest.payload = NULL;\n\t}\n\n\trequest.step = step;\n\n\tif (ctx-\u003eeasysetup_req_queue) {\n\t\tret = iot_os_queue_send(ctx-\u003eeasysetup_req_queue, \u0026request, 0);\n\t\tif (ret != IOT_OS_TRUE) {\n\t\t\tIOT_ERROR(\"Cannot put the request into easysetup_req_queue\");\n\t\t\terr = IOT_ERROR_EASYSETUP_QUEUE_SEND_ERROR;\n\t\t} else {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\t\tIOT_EVENT_BIT_EASYSETUP_REQ);\n\t\t\terr = IOT_ERROR_NONE;\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"easysetup_req_queue is deleted\");\n\t\terr = IOT_ERROR_BAD_REQ;\n\t}\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":186,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"230641":{"score":0.83570546,"function_name":"iot_state_update","code":"iot_error_t iot_state_update(struct iot_context *ctx,\n\tiot_state_t new_state, int opt)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t err;\n\n\tif ((new_state == IOT_STATE_PROV_CONFIRM)\n\t\t\t\u0026\u0026 (opt == IOT_STATE_OPT_NEED_INTERACT)) {\n\t\tIOT_INFO(\"Trigger PROV_CONFIRM\");\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_PROV_CONFIRM);\n\t}\n\n\tstate_data.iot_state = new_state;\n\tstate_data.opt = opt;\n\n\terr = iot_command_send(ctx, IOT_COMMNAD_STATE_UPDATE,\n                           \u0026state_data, sizeof(struct iot_state_data));\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":219,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"230806":{"score":0.7313757,"function_name":"iot_state_timeout_change","code":"iot_error_t iot_state_timeout_change(struct iot_context *ctx, iot_state_t target_state,\n\tunsigned int new_timeout_ms)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t err;\n\n\tif (target_state \u003c= IOT_STATE_INITIALIZED)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tif (new_timeout_ms \u003e IOT_STATE_TIMEOUT_MAX_MS)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tstate_data.iot_state = target_state;\n\tstate_data.opt = (int)new_timeout_ms;\n\n\terr = iot_command_send(ctx, IOT_COMMAND_CHANGE_STATE_TIMEOUT,\n                           \u0026state_data, sizeof(struct iot_state_data));\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":241,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"230924":{"score":0.75490975,"function_name":"iot_api_onboarding_config_mem_free","code":"void iot_api_onboarding_config_mem_free(struct iot_devconf_prov_data *devconf)\n{\n\tif (!devconf)\n\t\treturn;\n\n\tif (devconf-\u003edevice_onboarding_id)\n\t\tiot_os_free(devconf-\u003edevice_onboarding_id);\n\tif (devconf-\u003emnid)\n\t\tiot_os_free(devconf-\u003emnid);\n\tif (devconf-\u003esetupid)\n\t\tiot_os_free(devconf-\u003esetupid);\n\tif (devconf-\u003evid)\n\t\tiot_os_free(devconf-\u003evid);\n\tif (devconf-\u003edevice_type)\n\t\tiot_os_free(devconf-\u003edevice_type);\n\tif (devconf-\u003edip)\n\t\tiot_os_free(devconf-\u003edip);\n}","filepath":"src/iot_api.c","line_number":262,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"231239":{"score":0.74788845,"function_name":"iot_api_onboarding_config_load","code":"iot_error_t iot_api_onboarding_config_load(unsigned char *onboarding_config,\n\t\tunsigned int onboarding_config_len, struct iot_devconf_prov_data *devconf)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tJSON_H *root = NULL;\n\tJSON_H *config = NULL;\n\tJSON_H *dip = NULL;\n\tJSON_H *item = NULL;\n\tchar *data = NULL;\n\tchar *device_onboarding_id = NULL;\n\tchar *mnid = NULL;\n\tchar *setupid = NULL;\n\tchar *vid = NULL;\n\tchar *devicetypeid = NULL;\n\tunsigned int ownership_validation_type = 0;\n\tiot_security_key_type_t pk_type;\n\tsize_t str_len = 0;\n\tint i;\n\tstruct iot_dip_data *new_dip = NULL;\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tchar *current_name = NULL;\n#endif\n\n\tif (!onboarding_config || !devconf || onboarding_config_len == 0)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tdata = iot_os_malloc((size_t) onboarding_config_len + 1);\n\tif (!data) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, onboarding_config, onboarding_config_len);\n\tdata[onboarding_config_len] = '\\0';\n\n\troot = JSON_PARSE((char *)data);\n\tconfig = JSON_GET_OBJECT_ITEM(root, name_onboardingConfig);\n\tif (!config) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_onboardingConfig;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* device_onboarding_id */\n\titem = JSON_GET_OBJECT_ITEM(config, name_deviceOnboardingId);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t}\n\tif(!item || str_len \u003e ONBOARDINGID_MAX_LEN) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceOnboardingId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\tdevice_onboarding_id = iot_os_malloc(str_len + 1);\n\tif (!device_onboarding_id) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(device_onboarding_id, JSON_GET_STRING_VALUE(item), str_len);\n\tdevice_onboarding_id[str_len] = '\\0';\n\n\t/* mnid */\n\titem = JSON_GET_OBJECT_ITEM(config, name_mnId);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), \"MNID\")) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_mnId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tmnid = iot_os_malloc(str_len + 1);\n\tif (!mnid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(mnid, JSON_GET_STRING_VALUE(item), str_len);\n\tmnid[str_len] = '\\0';\n\n\t/* setup_id */\n\titem = JSON_GET_OBJECT_ITEM(config, name_setupId);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_setupId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tsetupid = iot_os_malloc(str_len + 1);\n\tif (!setupid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(setupid, JSON_GET_STRING_VALUE(item), str_len);\n\tsetupid[str_len] = '\\0';\n\n\t/* vid */\n\titem = JSON_GET_OBJECT_ITEM(config, name_vid);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_vid;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tvid = iot_os_malloc(str_len + 1);\n\tif (!vid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(vid, JSON_GET_STRING_VALUE(item), str_len);\n\tvid[str_len] = '\\0';\n\n\t/* device_type_id */\n\titem = JSON_GET_OBJECT_ITEM(config, name_deviceTypeId);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), \"TYPE\")) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceTypeId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tdevicetypeid = iot_os_malloc(str_len + 1);\n\tif (!devicetypeid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(devicetypeid, JSON_GET_STRING_VALUE(item), str_len);\n\tdevicetypeid[str_len] = '\\0';\n\n\t/* ownership validation type */\n\titem = JSON_GET_OBJECT_ITEM(config, name_ownershipValidationTypes);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_ownershipValidationTypes;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tfor (i = 0; i \u003c JSON_GET_ARRAY_SIZE(item); i++) {\n\t\tJSON_H *ovf = JSON_GET_ARRAY_ITEM(item, i);\n\t\tif (ovf \u0026\u0026 JSON_IS_STRING(ovf)) {\n\t\t\tif (!strcmp(JSON_GET_STRING_VALUE(ovf), \"JUSTWORKS\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_JUSTWORKS;\n\t\t\telse if (!strcmp(JSON_GET_STRING_VALUE(ovf), \"BUTTON\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_BUTTON;\n\t\t\telse if (!strcmp(JSON_GET_STRING_VALUE(ovf), \"PIN\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_PIN;\n\t\t\telse if (!strcmp(JSON_GET_STRING_VALUE(ovf), \"QR\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_QR;\n\t\t\telse {\n\t\t\t\tIOT_ERROR(\"Unknown validation type: %s\", JSON_GET_STRING_VALUE(ovf));\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\t\t\tcurrent_name = (char *)name_ownershipValidationTypes;\n#endif\n\t\t\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\t\t\tgoto load_out;\n\t\t\t}\n\t\t}\n\t}\n\tif (ownership_validation_type == 0)\n\t{\n\t\tIOT_ERROR(\"No ownership validation type selected\");\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_ownershipValidationTypes;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* device identity */\n\titem = JSON_GET_OBJECT_ITEM(config, name_identityType);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), \"ED25519\")) {\n\t\tpk_type = IOT_SECURITY_KEY_TYPE_ED25519;\n\t} else if (!strcmp(JSON_GET_STRING_VALUE(item), \"CERTIFICATE\")) {\n\t\tpk_type = IOT_SECURITY_KEY_TYPE_RSA2048;\n\t} else {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_identityType;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* Device Integration Profile, optional */\n\tdip = JSON_GET_OBJECT_ITEM(config, name_deviceIntegrationProfileId);\n\tif (dip) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceIntegrationProfileId;\n#endif\n\t\tnew_dip = iot_os_malloc(sizeof(struct iot_dip_data));\n\t\tif (!new_dip) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tmemset(new_dip, 0, sizeof(struct iot_dip_data));\n\n\t\titem = JSON_GET_OBJECT_ITEM(dip, \"id\");\n\t\tif (!item) {\n\t\t\tIOT_ERROR(\"Can't get id (NULL)\");\n\t\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\t\tgoto load_out;\n\t\t}\n\n\t\tiot_err = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\t\t\t\u0026new_dip-\u003edip_id);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't convert uuid for dip_id(%d)\", iot_err);\n\t\t\tgoto load_out;\n\t\t}\n\n\t\titem = JSON_GET_OBJECT_ITEM(dip, \"majorVersion\");\n\t\tif (!item) {\n\t\t\tIOT_ERROR(\"Can't get majorVersion (NULL)\");\n\t\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\t\tgoto load_out;\n\t\t}\n\t\tnew_dip-\u003edip_major_version = item-\u003evalueint;\n\n\t\t/* minorVersion is optional, default 0 */\n\t\titem = JSON_GET_OBJECT_ITEM(dip, \"minorVersion\");\n\t\tif (item) {\n\t\t\tnew_dip-\u003edip_minor_version = item-\u003evalueint;\n\t\t}\n\t}\n\n\tdevconf-\u003edevice_onboarding_id = device_onboarding_id;\n\tdevconf-\u003emnid = mnid;\n\tdevconf-\u003esetupid = setupid;\n\tdevconf-\u003evid = vid;\n\tdevconf-\u003edevice_type = devicetypeid;\n\tdevconf-\u003eownership_validation_type = ownership_validation_type;\n\tdevconf-\u003epk_type = pk_type;\n\tif (new_dip) {\n\t\tdevconf-\u003edip = new_dip;\n\t}\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\n\tiot_os_free(data);\n\n\treturn iot_err;\n\nload_out:\n\tif (iot_err == IOT_ERROR_UNINITIALIZED) {\n\t\tif (item \u0026\u0026 JSON_IS_STRING(item)) {\n\t\t\tIOT_ERROR(\"[%s] wrong onboarding config value detected: %s\",\n\t\t\t\t\tcurrent_name, JSON_GET_STRING_VALUE(item));\n\t\t}\n\t\telse {\n\t\t\tIOT_ERROR(\"[%s] wrong onboarding config value detected\", current_name);\n\t\t}\n\t}\n\tif (device_onboarding_id) {\n\t\tiot_os_free(device_onboarding_id);\n\t}\n\tif (mnid) {\n\t\tiot_os_free(mnid);\n\t}\n\tif (setupid) {\n\t\tiot_os_free(setupid);\n\t}\n\tif (vid) {\n\t\tiot_os_free(vid);\n\t}\n\tif (devicetypeid) {\n\t\tiot_os_free(devicetypeid);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (data) {\n\t\tiot_os_free(data);\n\t}\n\tif (new_dip) {\n\t\tiot_os_free(new_dip);\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":291,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"234012":{"score":0.9184123,"function_name":"iot_get_time_in_sec","code":"iot_error_t iot_get_time_in_sec(char *buf, size_t buf_len)\n{\n\tstruct timeval tv_now;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buffer for time is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tgettimeofday(\u0026tv_now, NULL);\n\tsnprintf(buf, buf_len, \"%ld\", tv_now.tv_sec);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":580,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"234168":{"score":0.90851295,"function_name":"iot_get_time_in_sec_by_long","code":"iot_error_t iot_get_time_in_sec_by_long(long *sec)\n{\n\tstruct timeval tv_now;\n\n\tif (!sec) {\n\t\tIOT_ERROR(\"buffer for time is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tgettimeofday(\u0026tv_now, NULL);\n\t*sec = tv_now.tv_sec;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":595,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"234311":{"score":0.9211648,"function_name":"iot_get_time_in_ms","code":"iot_error_t iot_get_time_in_ms(char *buf, size_t buf_len)\n{\n\tstruct timeval tv_now;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buffer for time is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tgettimeofday(\u0026tv_now, NULL);\n\tsnprintf(buf, buf_len, \"%ld%03ld\",\n\t\ttv_now.tv_sec, (tv_now.tv_usec / 1000));\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":610,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"234493":{"score":0.824476,"function_name":"iot_api_device_info_mem_free","code":"void iot_api_device_info_mem_free(struct iot_device_info *device_info)\n{\n\tif (!device_info)\n\t\treturn;\n\n\tdevice_info-\u003eopt_info = 0;\n\n\tif (device_info-\u003efirmware_version) {\n\t\tiot_os_free(device_info-\u003efirmware_version);\n\t\tdevice_info-\u003efirmware_version = NULL;\n\t}\n\n\tif (device_info-\u003emodel_number) {\n\t\tiot_os_free(device_info-\u003emodel_number);\n\t\tdevice_info-\u003emodel_number = NULL;\n\t}\n\n\tif (device_info-\u003emarketing_name) {\n\t\tiot_os_free(device_info-\u003emarketing_name);\n\t\tdevice_info-\u003emarketing_name = NULL;\n\t}\n\n\tif (device_info-\u003emanufacturer_name) {\n\t\tiot_os_free(device_info-\u003emanufacturer_name);\n\t\tdevice_info-\u003emanufacturer_name = NULL;\n\t}\n\n\tif (device_info-\u003emanufacturer_code) {\n\t\tiot_os_free(device_info-\u003emanufacturer_code);\n\t\tdevice_info-\u003emanufacturer_code = NULL;\n\t}\n}","filepath":"src/iot_api.c","line_number":626,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"234801":{"score":0.79672885,"function_name":"iot_api_device_info_load","code":"iot_error_t iot_api_device_info_load(unsigned char *device_info,\n\t\tunsigned int device_info_len, struct iot_device_info *info)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tJSON_H *root = NULL;\n\tJSON_H *profile = NULL;\n\tJSON_H *item = NULL;\n\tchar *firmware_version = NULL;\n\tchar *model_number = NULL;\n\tchar *marketing_name = NULL;\n\tchar *manufacturer_name = NULL;\n\tchar *manufacturer_code = NULL;\n\tchar *data = NULL;\n\tsize_t str_len = 0;\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tchar *current_name = NULL;\n#endif\n\n\tif (!device_info || !info || device_info_len == 0)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tdata = iot_os_malloc((size_t) device_info_len + 1);\n\tif (!data) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, device_info, device_info_len);\n\tdata[device_info_len] = '\\0';\n\n\troot = JSON_PARSE((char *)data);\n\tprofile = JSON_GET_OBJECT_ITEM(root, name_deviceInfo);\n\tif (!profile) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceInfo;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* version */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_version);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_version;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tfirmware_version = iot_os_malloc(str_len + 1);\n\tif (!firmware_version) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(firmware_version, JSON_GET_STRING_VALUE(item), str_len);\n\tfirmware_version[str_len] = '\\0';\n\n\tinfo-\u003efirmware_version = firmware_version;\n\tinfo-\u003eopt_info = 0;\n\n\t/* name_model_number */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_model_number);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmodel_number = iot_os_malloc(str_len + 1);\n\t\tif (!model_number) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(model_number, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmodel_number[str_len] = '\\0';\n\t\tinfo-\u003emodel_number = model_number;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emodel_number = NULL;\n\t}\n\n\t/* name_marketing */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_marketing);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmarketing_name = iot_os_malloc(str_len + 1);\n\t\tif (!marketing_name) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(marketing_name, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmarketing_name[str_len] = '\\0';\n\n\t\tinfo-\u003emarketing_name = marketing_name;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emarketing_name = NULL;\n\t}\n\n\t/* name_manufacturer */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_manufacturer);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmanufacturer_name = iot_os_malloc(str_len + 1);\n\t\tif (!manufacturer_name) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(manufacturer_name, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmanufacturer_name[str_len] = '\\0';\n\n\t\tinfo-\u003emanufacturer_name = manufacturer_name;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emanufacturer_name = NULL;\n\t}\n\n\t/* manufacturerCode */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_manufacturer_code);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmanufacturer_code = iot_os_malloc(str_len + 1);\n\t\tif (!manufacturer_code) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(manufacturer_code, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmanufacturer_code[str_len] = '\\0';\n\n\t\tinfo-\u003emanufacturer_code = manufacturer_code;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emanufacturer_code = NULL;\n\t}\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\n\tiot_os_free(data);\n\n\t_dump_device_info(info);\n\n\treturn iot_err;\n\nload_out:\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tif (iot_err == IOT_ERROR_UNINITIALIZED) {\n\t\tIOT_ERROR(\"[%s] wrong device info value detected\", current_name);\n\t}\n#endif\n\n\tif (firmware_version)\n\t\tiot_os_free(firmware_version);\n\tif (marketing_name)\n\t\tiot_os_free(marketing_name);\n\tif (model_number)\n\t\tiot_os_free(model_number);\n\tif (manufacturer_name)\n\t\tiot_os_free(manufacturer_name);\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\tif (data)\n\t\tiot_os_free(data);\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":674,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"236204":{"score":0.79942226,"function_name":"iot_api_prov_data_mem_free","code":"void iot_api_prov_data_mem_free(struct iot_device_prov_data *prov)\n{\n\tif (!prov)\n\t\treturn;\n\n\tif (prov-\u003ecloud.broker_url)\n\t\tiot_os_free(prov-\u003ecloud.broker_url);\n\n\tif (prov-\u003ecloud.label)\n\t\tiot_os_free(prov-\u003ecloud.label);\n}","filepath":"src/iot_api.c","line_number":838,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"236298":{"score":0.8758881,"function_name":"iot_api_read_device_identity","code":"iot_error_t iot_api_read_device_identity(unsigned char* nv_prof,\n\t\tunsigned int nv_prof_len, const char* object, char** nv_data)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tJSON_H *root = NULL;\n\tJSON_H *profile = NULL;\n\tJSON_H *item = NULL;\n\tchar *data = NULL;\n\tchar *object_data = NULL;\n\tsize_t str_len = 0;\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tchar *current_name = NULL;\n#endif\n\n\tif (!nv_prof || !nv_data || nv_prof_len == 0)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tdata = iot_os_malloc((size_t) nv_prof_len + 1);\n\tif (!data) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, nv_prof, nv_prof_len);\n\tdata[nv_prof_len] = '\\0';\n\n\troot = JSON_PARSE((char *)data);\n\tprofile = JSON_GET_OBJECT_ITEM(root, name_deviceInfo);\n\tif (!profile) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char*)name_deviceInfo;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(profile, object);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), object)) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)object;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tobject_data = iot_os_malloc(str_len + 1);\n\tif (!object_data) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\n\tstrncpy(object_data, JSON_GET_STRING_VALUE(item), str_len);\n\tobject_data[str_len] = '\\0';\n\n\t*nv_data = object_data;\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\n\tiot_os_free(data);\n\n\treturn iot_err;\n\nload_out:\n\tif (iot_err == IOT_ERROR_UNINITIALIZED) {\n\t\tif (item \u0026\u0026 JSON_IS_STRING(item)) {\n\t\t\tIOT_ERROR(\"[%s] wrong nv profile value detected: %s\",\n\t\t\t\t\tcurrent_name, JSON_GET_STRING_VALUE(item));\n\t\t}\n\t\telse {\n\t\t\tIOT_ERROR(\"[%s] wrong nv profile value detected\", current_name);\n\t\t}\n\t}\n\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (data) {\n\t\tiot_os_free(data);\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":851,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"236950":{"score":0.9264966,"function_name":"iot_device_cleanup","code":"iot_error_t iot_device_cleanup(struct iot_context *ctx)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tiot_wifi_conf config;\n\n\tIOT_INFO(\"start to erase device information\");\n\n\tmemset(\u0026config, 0x0, sizeof(iot_wifi_conf));\n\n\tiot_api_prov_data_mem_free(\u0026(ctx-\u003eprov_data));\n\tmemset(\u0026(ctx-\u003eprov_data), 0x0, sizeof(ctx-\u003eprov_data));\n\n\tiot_err = iot_nv_erase_prov_data();\n\tif ((iot_err != IOT_ERROR_NONE) \u0026\u0026 (iot_err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\tIOT_ERROR(\"%s: failed to erase provisioning data: %d\", __func__, iot_err);\n\t}\n\n\tiot_err = iot_nv_erase(IOT_NVD_DEVICE_ID);\n\tif ((iot_err != IOT_ERROR_NONE) \u0026\u0026 (iot_err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\tIOT_ERROR(\"%s: failed to erase device ID: %d\", __func__, iot_err);\n\t}\n\n\t/* if there is previous connection, disconnect it first. */\n\tif (ctx-\u003eevt_mqttcli != NULL) {\n\t\tIOT_INFO(\"There is previous connecting, disconnect it first.\\n\");\n\t\tiot_err = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"%s: evt_mqtt disconnect failed %d\", __func__, iot_err);\n\t\t}\n\t}\n\n\tif (ctx-\u003ereg_mqttcli != NULL) {\n\t\tIOT_INFO(\"There is active registering, disconnect it first.\\n\");\n\t\tiot_err = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"%s: reg_mqtt disconnect failed %d\", __func__, iot_err);\n\t\t}\n\t}\n\n\tif(ctx-\u003elookup_id) {\n\t\tfree(ctx-\u003elookup_id);\n\t\tctx-\u003elookup_id = NULL;\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":936,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"237590":{"score":0.883542,"function_name":"_get_dip_from_json","code":"static iot_error_t _get_dip_from_json(JSON_H *json, struct iot_dip_data *dip)\n{\n\tstruct iot_dip_data curr_dip;\n\tJSON_H *sub_item = NULL;\n\tJSON_H *item = NULL;\n\tiot_error_t iot_err;\n\n\tsub_item = JSON_GET_OBJECT_ITEM(json, \"dip\");\n\tif (sub_item == NULL) {\n\t\tIOT_ERROR(\"There is no dip in misc_info\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(sub_item, \"id\");\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"There is no id in dip\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tiot_err = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\t\u0026curr_dip.dip_id);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", iot_err);\n\t\treturn iot_err;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(sub_item, \"maj\");\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"There is no major-version in dip\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tcurr_dip.dip_major_version = item-\u003evalueint;\n\n\titem = JSON_GET_OBJECT_ITEM(sub_item, \"min\");\n\tif (item == NULL) {\n\t\tcurr_dip.dip_minor_version = 0;\n\t} else {\n\t\tcurr_dip.dip_minor_version = item-\u003evalueint;\n\t}\n\n\tmemcpy(dip, \u0026curr_dip, sizeof(curr_dip));\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":983,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"238072":{"score":0.8974061,"function_name":"_get_location_from_json","code":"static iot_error_t _get_location_from_json(JSON_H *json, struct iot_uuid *uuid)\n{\n\tstruct iot_uuid curr_uuid;\n\tJSON_H *item = NULL;\n\tiot_error_t iot_err;\n\n\titem = JSON_GET_OBJECT_ITEM(json, \"loId\");\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"There is no locationId in misc_info\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tiot_err = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\t\u0026curr_uuid);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", iot_err);\n\t\treturn iot_err;\n\t}\n\n\tmemcpy(uuid, \u0026curr_uuid, sizeof(curr_uuid));\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":1027,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"238337":{"score":0.85632944,"function_name":"iot_misc_info_load","code":"iot_error_t iot_misc_info_load(iot_misc_info_t type, void *out_data)\n{\n\tchar *misc_info = NULL;\n\tsize_t misc_info_len = 0;\n\tJSON_H *json = NULL;\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\n\tif (!out_data) {\n\t\tiot_err = IOT_ERROR_INVALID_ARGS;\n\t\tgoto misc_info_load_out;\n\t}\n\n\tiot_err = iot_nv_get_misc_info(\u0026misc_info, \u0026misc_info_len);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't get misc_info from NV(%d)\", iot_err);\n\t\tgoto misc_info_load_out;\n\t}\n\n\tIOT_DEBUG(\"Load raw misc_info str:%s\", misc_info);\n\n\tjson = JSON_PARSE(misc_info);\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"misc_info(%s) parsing failed\", misc_info);\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tgoto misc_info_load_out;\n\t}\n\n\tswitch (type) {\n\tcase IOT_MISC_INFO_DIP:\n\t\tiot_err = _get_dip_from_json(json, (struct iot_dip_data *)out_data);\n\t\tbreak;\n\n\tcase IOT_MISC_INFO_LOCATION:\n\t\tiot_err = _get_location_from_json(json, (struct iot_uuid *)out_data);\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported type(%d)\", type);\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tbreak;\n\t}\n\nmisc_info_load_out:\n\tif (misc_info)\n\t\tiot_os_free(misc_info);\n\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":1050,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"238744":{"score":0.8299587,"function_name":"_set_dip_to_json","code":"static iot_error_t _set_dip_to_json(JSON_H *json, struct iot_dip_data *new_dip)\n{\n\tJSON_H *sub_item = NULL;\n\tJSON_H *item = NULL;\n\tiot_error_t iot_err;\n\tchar dip_id_str[40];\n\n\tsub_item = JSON_CREATE_OBJECT();\n\tif (sub_item == NULL) {\n\t\tIOT_ERROR(\"Can't make new obj for dip\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tiot_err = iot_util_convert_uuid_str(\u0026new_dip-\u003edip_id,\n\t\t\t\tdip_id_str, sizeof(dip_id_str));\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert uuid to str(%d)\", iot_err);\n\t\tJSON_DELETE(sub_item);\n\t\treturn iot_err;\n\t}\n\n\titem = JSON_CREATE_STRING(dip_id_str);\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"Can't make new string for dip's id\");\n\t\tJSON_DELETE(sub_item);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(sub_item, \"id\", item);\n\n\titem = JSON_CREATE_NUMBER(new_dip-\u003edip_major_version);\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"Can't make new item for dip's major version\");\n\t\tJSON_DELETE(sub_item);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(sub_item, \"maj\", item);\n\n\tif (new_dip-\u003edip_minor_version != 0) {\n\t\titem = JSON_CREATE_NUMBER(new_dip-\u003edip_minor_version);\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"Can't make new item for dip's minor version\");\n\t\t\tJSON_DELETE(sub_item);\n\t\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_OBJECT(sub_item, \"min\", item);\n\t}\n\n\tif (JSON_GET_OBJECT_ITEM(json, \"dip\") == NULL) {\n\t\tIOT_DEBUG(\"There is no dip in misc_info\");\n\t\tJSON_ADD_ITEM_TO_OBJECT(json, \"dip\", sub_item);\n\t} else {\n\t\tJSON_REPLACE_ITEM_IN_OBJ_CASESENS(json, \"dip\", sub_item);\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":1102,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"239426":{"score":0.8436223,"function_name":"_set_location_to_json","code":"static iot_error_t _set_location_to_json(JSON_H *json, struct iot_uuid *uuid)\n{\n\tJSON_H *item = NULL;\n\tchar location_id[IOT_REG_UUID_STR_LEN + 1];\n\tiot_error_t iot_err;\n\n\tiot_err = iot_util_convert_uuid_str(uuid,\n\t\t\t\tlocation_id, sizeof(location_id));\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert uuid to str(%d)\", iot_err);\n\t\treturn iot_err;\n\t}\n\n\titem = JSON_CREATE_STRING(location_id);\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"Can't make new string for locationId\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tif (JSON_GET_OBJECT_ITEM(json, \"loId\") == NULL) {\n\t\tIOT_DEBUG(\"There is no locatinoId in misc_info\");\n\t\tJSON_ADD_ITEM_TO_OBJECT(json, \"loId\", item);\n\t} else {\n\t\tJSON_REPLACE_ITEM_IN_OBJ_CASESENS(json, \"loId\", item);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":1159,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"239725":{"score":0.85847294,"function_name":"iot_misc_info_store","code":"iot_error_t iot_misc_info_store(iot_misc_info_t type, const void *in_data)\n{\n\tchar *old_misc_info = NULL;\n\tsize_t old_misc_info_len = 0;\n\tchar *new_misc_info = NULL;\n\tJSON_H *json = NULL;\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tunsigned char old_hash[IOT_SECURITY_SHA256_LEN] = {0,};\n\tunsigned char new_hash[IOT_SECURITY_SHA256_LEN] = {0,};\n\tbool hash_chk = false;\n\n\tif (!in_data) {\n\t\tiot_err = IOT_ERROR_INVALID_ARGS;\n\t\tgoto misc_info_store_out;\n\t}\n\n\tiot_err = iot_nv_get_misc_info(\u0026old_misc_info, \u0026old_misc_info_len);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_INFO(\"There is no old misc_info in NV\");\n\t\tjson = JSON_CREATE_OBJECT();\n\t} else {\n\t\tjson = JSON_PARSE(old_misc_info);\n\t\tif (json == NULL) {\n\t\t\tIOT_ERROR(\"old misc_info(%s) parsing failed\", old_misc_info);\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t\tgoto misc_info_store_out;\n\t\t}\n\t}\n\n\tif ((old_misc_info != NULL) \u0026\u0026 (old_misc_info_len != 0)) {\n\t\tiot_err = iot_security_sha256((const unsigned char *)old_misc_info,\n\t\t\t\told_misc_info_len, old_hash, sizeof(old_hash));\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_WARN(\"Can't make hash for old_misc_info!!\");\n\t\t} else {\n\t\t\thash_chk = true;\n\t\t}\n\t}\n\n\tiot_os_free(old_misc_info);\n\told_misc_info = NULL;\n\n\tswitch (type) {\n\tcase IOT_MISC_INFO_DIP:\n\t\tiot_err = _set_dip_to_json(json, (struct iot_dip_data *)in_data);\n\t\tbreak;\n\n\tcase IOT_MISC_INFO_LOCATION:\n\t\tiot_err = _set_location_to_json(json, (struct iot_uuid *)in_data);\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported type(%d)\", type);\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tbreak;\n\t}\n\n\tif (iot_err != IOT_ERROR_NONE)\n\t\tgoto misc_info_store_out;\n\n\tnew_misc_info = JSON_PRINT(json);\n\tIOT_DEBUG(\"Store raw msic_info str : %s\", new_misc_info);\n\n\tif (hash_chk) {\n\t\tiot_err = iot_security_sha256((const unsigned char *)new_misc_info,\n\t\t\t\tstrlen(new_misc_info), new_hash, sizeof(new_hash));\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_WARN(\"Can't make hash for new_misc_info!!\");\n\t\t} else {\n\t\t\tif (!memcmp(old_hash, new_hash, IOT_SECURITY_SHA256_LEN)) {\n\t\t\t\tIOT_DEBUG(\"Same misc_info, skip NV update\");\n\t\t\t\tgoto misc_info_store_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tiot_err = iot_nv_set_misc_info(new_misc_info);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't set new misc_info into NV : %s\", new_misc_info);\n\t}\n\nmisc_info_store_out:\n\tif (new_misc_info)\n\t\tiot_os_free(new_misc_info);\n\n\tif (old_misc_info)\n\t\tiot_os_free(old_misc_info);\n\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":1188,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"240545":{"score":0.93050534,"function_name":"iot_get_random_id_str","code":"iot_error_t iot_get_random_id_str(char *str, size_t max_sz)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_uuid uuid;\n\n\tif (str == NULL) {\n\t\tIOT_ERROR(\"There is no string arg\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\terr = iot_get_random_uuid_from_mac(\u0026uuid);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"To get uuid is failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\terr = iot_util_convert_uuid_str(\u0026uuid, str, max_sz);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to convert uuid to str (%d)\", err);\n\t}\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":1282,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"240826":{"score":0.898764,"function_name":"iot_bsp_debug","code":"void iot_bsp_debug(iot_debug_level_t level, const char* tag, const char* fmt, ...)\n{\n\tstruct timeval log_time;\n\tchar buf[BUF_SIZE] = {0,};\n\tint ret;\n\tva_list va;\n\n\tgettimeofday(\u0026log_time, NULL);\n\tva_start(va, fmt);\n\tret = vsnprintf(buf, BUF_SIZE, fmt, va);\n\tva_end(va);\n\n\tiot_bsp_dump(buf);\n\n\tif (level == IOT_DEBUG_LEVEL_ERROR) {\n\t\tprintf(COLOR_RED\"E (%ld:%ld) %s: %s\\n\"COLOR_RESET, log_time.tv_sec, log_time.tv_usec / 1000 , tag, buf);\n\t} else if (level == IOT_DEBUG_LEVEL_WARN) {\n\t\tprintf(COLOR_YELLOW\"W (%ld:%ld) %s: %s\\n\"COLOR_RESET, log_time.tv_sec, log_time.tv_usec / 1000 , tag, buf);\n\t} else if (level == IOT_DEBUG_LEVEL_INFO) {\n\t\tprintf(COLOR_GREEN\"I (%ld:%ld) %s: %s\\n\"COLOR_RESET, log_time.tv_sec, log_time.tv_usec / 1000, tag, buf);\n\t} else if (level == IOT_DEBUG_LEVEL_DEBUG) {\n\t\tprintf(\"D (%ld:%ld) %s: %s\\n\", log_time.tv_sec, log_time.tv_usec / 1000, tag, buf);\n\t} else {\n\t\tprintf(\"D (%ld:%ld) %s: %s\\n\", log_time.tv_sec, log_time.tv_usec / 1000, tag, buf);\n\t}\n}","filepath":"src/port/bsp/posix/iot_bsp_debug_posix.c","line_number":37,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"241439":{"score":0.7971601,"function_name":"iot_bsp_debug_check_heap","code":"void iot_bsp_debug_check_heap(const char* tag, const char* func, const int line, const char* fmt, ...)\n{\n\tstatic int count = 0;\n\tchar buf[BUF_SIZE] = {0,};\n\tint ret;\n\tva_list va;\n\n\tva_start(va, fmt);\n\tret = vsnprintf(buf, BUF_SIZE, fmt, va);\n\tva_end(va);\n\n\tif (count == 0) {\n\t\tiot_bsp_debug(IOT_DEBUG_LEVEL_WARN, tag, \"%s(%d) \u003e [MEMCHK][%d] Heap total size : %d\", func, line, count, _iot_bsp_debug_get_maximum_heap_size());\n\t}\n\n\tiot_bsp_debug(IOT_DEBUG_LEVEL_WARN, tag, \"%s(%d) \u003e [MEMCHK][%d][%s] CU:%d, CR:%d, PU:%d, PR:%d\", func, line, ++count, buf,\n\t\t\t_iot_bsp_debug_get_maximum_heap_size() - _iot_bsp_debug_get_free_heap_size(),\n\t\t\t_iot_bsp_debug_get_free_heap_size(),\n\t\t\t_iot_bsp_debug_get_maximum_heap_size() - _iot_bsp_debug_get_minimum_free_heap_size(),\n\t\t\t_iot_bsp_debug_get_minimum_free_heap_size());\n}","filepath":"src/port/bsp/posix/iot_bsp_debug_posix.c","line_number":79,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"241823":{"score":0.8618117,"function_name":"iot_bsp_fs_open","code":"iot_error_t iot_bsp_fs_open(const char *filename, iot_bsp_fs_open_mode_t mode, iot_bsp_fs_handle_t *handle)\n{\n\tmode_t fmode;\n\n\tif (mode == FS_READONLY) {\n\t\tfmode = O_RDONLY;\n\t} else {\n\t\tfmode = O_RDWR | O_CREAT;\n\t}\n\n\tint fd = open(filename, fmode);\n\tif (fd \u003c 0) {\n\t\treturn IOT_ERROR_FS_OPEN_FAIL;\n\t}\n\n\thandle-\u003efd = fd;\n\tsnprintf(handle-\u003efilename, sizeof(handle-\u003efilename), \"%s\", filename);\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/tizenrt/iot_bsp_fs_tizenrt.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"242101":{"score":0.54748785,"function_name":"iot_bsp_fs_read","code":"iot_error_t iot_bsp_fs_read(iot_bsp_fs_handle_t handle, char* buffer, size_t *length)\n{\n\tif (access(handle.filename, F_OK) == -1) {\n\t\tIOT_DEBUG(\"file does not exist\");\n\t\treturn IOT_ERROR_FS_NO_FILE;\n\t}\n\n\tchar* data = malloc(*length + 1);\n\tssize_t size = read(handle.fd, data, *length);\n\tif (size \u003c 0) {\n\t\tfree(data);\n\t\tIOT_DEBUG(\"read fail [%s]\", strerror(errno));\n\t\treturn IOT_ERROR_FS_READ_FAIL;\n\t}\n\n\tmemcpy(buffer, data, size);\n\tif (size \u003c *length) {\n\t\tbuffer[size] = '\\0';\n\t}\n\n\t*length = size;\n\n\tfree(data);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_fs_posix.c","line_number":74,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"242415":{"score":0.5923362,"function_name":"iot_bsp_fs_close","code":"iot_error_t iot_bsp_fs_close(iot_bsp_fs_handle_t handle)\n{\n\tint ret;\n\tif (handle.fd \u003c 0) {\n\t\treturn IOT_ERROR_FS_NO_FILE;\n\t}\n\n\tret = close(handle.fd);\n\tif (ret == -1) {\n\t\treturn IOT_ERROR_FS_CLOSE_FAIL;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/tizenrt/iot_bsp_fs_tizenrt.c","line_number":108,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"242558":{"score":0.8182261,"function_name":"iot_bsp_random","code":"unsigned int iot_bsp_random()\n{\n\tstatic int seed = 0;\n\n\tif (seed == 0) {\n\t\tsrand(time(NULL));\n\t\tseed = 1;\n\t}\n\n\tuint32_t rand1 = rand() \u003c\u003c 24;\n\tuint32_t rand2 = (rand() \u003c\u003c 16) \u0026 0x00FF0000;\n\tuint32_t rand3 = (rand() \u003c\u003c 8) \u0026 0x0000FF00;;\n\tuint32_t rand4 = rand() \u0026 0x000000FF;\n\n\treturn (rand1 | rand2 | rand3 | rand4) % UINT32_MAX;\n}","filepath":"src/port/bsp/posix/iot_bsp_random_posix.c","line_number":24,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"242811":{"score":0.8894767,"function_name":"iot_bsp_system_get_time_in_sec","code":"iot_error_t iot_bsp_system_get_time_in_sec(char* buf, unsigned int buf_len)\n{\n\tIOT_WARN_CHECK(buf == NULL, IOT_ERROR_INVALID_ARGS, \"buffer for time is NULL\");\n\n\tstruct timespec ts = {0,};\n\n\tclock_gettime(CLOCK_REALTIME, \u0026ts);\n\tsnprintf(buf, buf_len, \"%ld\", ts.tv_sec);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_system_posix.c","line_number":46,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"242978":{"score":0.9065263,"function_name":"iot_bsp_system_set_time_in_sec","code":"iot_error_t iot_bsp_system_set_time_in_sec(const char* time_in_sec)\n{\n\tIOT_WARN_CHECK(time_in_sec == NULL, IOT_ERROR_INVALID_ARGS, \"time data is NULL\");\n\n\tstruct timespec ts = {0,};\n\tint ret;\n\n\tsscanf(time_in_sec, \"%ld\", \u0026ts.tv_sec);\n\tret = clock_settime(CLOCK_REALTIME, \u0026ts);\n\tif (ret == -1)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_system_posix.c","line_number":58,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"243161":{"score":0.95540875,"function_name":"iot_bsp_system_get_uniqueid","code":"iot_error_t iot_bsp_system_get_uniqueid(unsigned char **uid, size_t *olen)\n{\n\tunsigned long hostid = gethostid();\n\tunsigned char *id;\n\n\tid = (unsigned char*) malloc(4);\n\tif (!id) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tfor (int i = 0; i \u003c 4; i++) {\n\t\tid[i] = (unsigned char) hostid;\n\t\thostid = hostid \u003e\u003e 8u;\n\t}\n\n\t*uid = id;\n\t*olen = 4;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_system_posix.c","line_number":73,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"243279":{"score":0.8180739,"function_name":"_create_socket","code":"static int _create_socket()\n{\n    int sockfd = 0;\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd == -1) {\n        IOT_ERROR(\"Can't get socket (%d, %s)\", errno, strerror(errno));\n        return -errno;\n    }\n    return sockfd;\n}","filepath":"src/port/bsp/posix/iot_bsp_wifi_posix.c","line_number":49,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"243478":{"score":0.8412014,"function_name":"iot_bsp_wifi_get_mac","code":"iot_error_t iot_bsp_wifi_get_mac(struct iot_mac *wifi_mac)\n{\n\tstruct ifreq ifr;\n\tint sockfd = 0;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\tsockfd = _create_socket();\n\tif (sockfd \u003c 0)\n\t\treturn IOT_ERROR_READ_FAIL;\n\n\tstrncpy(ifr.ifr_name, IFACE_NAME, IF_NAMESIZE);\n\tif (ioctl(sockfd, SIOCGIFHWADDR, \u0026ifr) \u003c 0) {\n\t\tIOT_ERROR(\"ioctl(%d, %s): 0x%x\", errno, strerror(errno), SIOCGIFHWADDR);\n\t\terr = IOT_ERROR_READ_FAIL;\n\t\tgoto mac_out;\n\t}\n\tmemcpy(wifi_mac-\u003eaddr, ifr.ifr_hwaddr.sa_data, sizeof(wifi_mac-\u003eaddr));\n\nmac_out:\n\tclose(sockfd);\n\treturn err;\n}","filepath":"src/port/bsp/posix/iot_bsp_wifi_posix.c","line_number":76,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"244252":{"score":0.86303043,"function_name":"st_conn_ownership_confirm","code":"void st_conn_ownership_confirm(IOT_CTX *iot_ctx, bool confirm)\n{\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (ctx-\u003ecurr_otm_feature == OVF_BIT_BUTTON) {\n\t\tif (confirm == true) {\n\t\t\tIOT_INFO(\"button confirm asserted\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_GET_OWNER_CONFIRM, 0);\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM);\n\t\t} else if (confirm == false) {\n\t\t\tIOT_INFO(\"button confirm denied\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_CONFIRM_DENIED, 0);\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM_DENY);\n\t\t}\n\t}\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"244437":{"score":0.874259,"function_name":"_es_json_parse_string","code":"STATIC_FUNCTION\nchar *_es_json_parse_string(JSON_H *json, const char *name)\n{\n\tchar *buf = NULL;\n\tJSON_H *recv = NULL;\n\tunsigned int buf_len;\n\n\tif (!json || !name) {\n\t\tIOT_ERROR(\"invalid args\");\n\t\treturn NULL;\n\t}\n\n\tif ((recv = JSON_GET_OBJECT_ITEM(json, name)) == NULL) {\n\t\tIOT_INFO(\"failed to find '%s'\", name);\n\t\treturn NULL;\n\t}\n\tbuf_len = (strlen(recv-\u003evaluestring) + 1);\n\n\tIOT_DEBUG(\"'%s' (%d): %s\",\n\t\t\tname, buf_len, recv-\u003evaluestring);\n\n\tif ((buf = (char *)iot_os_malloc(buf_len)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for buf\");\n\t\treturn NULL;\n\t}\n\tmemset(buf, 0, buf_len);\n\tmemcpy(buf, recv-\u003evaluestring, strlen(recv-\u003evaluestring));\n\n\treturn buf;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":59,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"244761":{"score":0.9116907,"function_name":"_es_crypto_cipher_gen_iv","code":"STATIC_FUNCTION\niot_error_t _es_crypto_cipher_gen_iv(iot_security_buffer_t *iv_buffer)\n{\n\tint i;\n\tunsigned char *iv;\n\tsize_t iv_len = IOT_SECURITY_IV_LEN;\n\n\tif (!iv_buffer) {\n\t\tIOT_ERROR(\"iv buffer is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif ((iv = (unsigned char *)iot_os_malloc(iv_len)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for iv\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\treturn IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t}\n\n\tfor (i = 0; i \u003c iv_len; i++) {\n\t\tiv[i] = (unsigned char)iot_bsp_random();\n\t}\n\n\tiv_buffer-\u003ep = iv;\n\tiv_buffer-\u003elen = iv_len;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"244971":{"score":0.8632958,"function_name":"_encrypt_and_encode","code":"STATIC_FUNCTION\niot_error_t _encrypt_and_encode(iot_security_context_t *security_context, unsigned char *plain_msg, size_t plain_msg_len, char **out_msg)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t msg_buf = { 0 };\n\tiot_security_buffer_t encrypt_buf = { 0 };\n\tiot_security_buffer_t encrypt_b64url_buf = { 0 };\n\tsize_t out_len;\n\n\tif (!security_context || !plain_msg || plain_msg_len == 0) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tmsg_buf.p = plain_msg;\n\tmsg_buf.len = plain_msg_len;\n\n\terr = iot_security_cipher_aes_encrypt(security_context, \u0026msg_buf, \u0026encrypt_buf);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"aes encryption error 0x%x\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_AES256_ENCRYPTION_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_AES256_ENCRYPTION_ERROR;\n\t\tgoto enc_fail;\n\t}\n\n\tencrypt_b64url_buf.len = IOT_SECURITY_B64_ENCODE_LEN(encrypt_buf.len);\n\tencrypt_b64url_buf.p = (unsigned char *)iot_os_calloc(encrypt_b64url_buf.len, sizeof(unsigned char));\n\tif (!encrypt_b64url_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for encrypt b64url\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto enc_fail;\n\t}\n\n\terr = iot_security_base64_encode_urlsafe(encrypt_buf.p, encrypt_buf.len,\n\t\t\t\tencrypt_b64url_buf.p, encrypt_b64url_buf.len, \u0026out_len);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"base64url encode error 0x%x\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_BASE64_ENCODE_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_BASE64_ENCODE_ERROR;\n\t\tgoto enc_fail;\n\t}\n\n\tiot_os_free(encrypt_buf.p);\n\t*out_msg = (char *)encrypt_b64url_buf.p;\n\treturn IOT_ERROR_NONE;\n\nenc_fail:\n\tif (encrypt_buf.p) {\n\t\tiot_os_free(encrypt_buf.p);\n\t}\n\tif (encrypt_b64url_buf.p) {\n\t\tiot_os_free(encrypt_b64url_buf.p);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":118,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"245481":{"score":0.8600342,"function_name":"_decode_and_decrypt","code":"STATIC_FUNCTION\niot_error_t _decode_and_decrypt(iot_security_context_t *security_context, unsigned char *encrypt_b64url_msg, size_t encrypt_b64url_msg_len, char **out_msg)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t decrypt_buf = {0 };\n\tiot_security_buffer_t plain_buf = { 0 };\n\tsize_t decoded_len;\n\n\tif (!security_context || !encrypt_b64url_msg || encrypt_b64url_msg_len == 0) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t// Decode\n\tdecrypt_buf.len = IOT_SECURITY_B64_DECODE_LEN(encrypt_b64url_msg_len);\n\tdecrypt_buf.p = (unsigned char*) iot_os_calloc(decrypt_buf.len, sizeof(unsigned char));\n\tif (!decrypt_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for decrypt\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\treturn IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR;\n\t}\n\n\terr = iot_security_base64_decode_urlsafe(encrypt_b64url_msg, encrypt_b64url_msg_len,\n\t\t\t\t\tdecrypt_buf.p, decrypt_buf.len, \u0026decoded_len);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"base64url decode error 0x%x\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_BASE64_DECODE_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_BASE64_DECODE_ERROR;\n\t\tgoto dec_fail;\n\t}\n\n\tdecrypt_buf.len = decoded_len;\n\n\terr = iot_security_cipher_aes_decrypt(security_context, \u0026decrypt_buf, \u0026plain_buf);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"aes decrypt error %d\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_AES256_DECRYPTION_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_AES256_DECRYPTION_ERROR;\n\t\tgoto dec_fail;\n\t}\n\n\tiot_os_free(decrypt_buf.p);\n\t*out_msg = (char *)plain_buf.p;\n\treturn IOT_ERROR_NONE;\n\ndec_fail:\n\tif (decrypt_buf.p) {\n\t\tiot_os_free(decrypt_buf.p);\n\t}\n\tif (plain_buf.p) {\n\t\tiot_os_free(plain_buf.p);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":175,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"245959":{"score":0.9421174,"function_name":"_es_time_set","code":"STATIC_FUNCTION\niot_error_t _es_time_set(unsigned char *time)\n{\n\tchar time_str[11] = {0,};\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct tm tm = { 0 };\n\ttime_t now = 0;\n\n\tif (sscanf((char *)time, \"%4d-%2d-%2dT%2d.%2d.%2d\", \u0026tm.tm_year, \u0026tm.tm_mon, \u0026tm.tm_mday, \u0026tm.tm_hour, \u0026tm.tm_min, \u0026tm.tm_sec) != 6) {\n\t\tIOT_ERROR(\"Invalid UTC time!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_TIME, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_TIME;\n\t\treturn err;\n\t}\n\n\t/*\n\tThis code is applied by the Year 2038 problem.\n\tThe Year 2038 problem relates to representing time in many digital systems\n\tas the number of seconds passed since 00:00:00 UTC on 1 January 1970 and storing it as a signed 32-bit integer.\n\tSuch implementations cannot encode times after 03:14:07 UTC on 19 January 2038.\n\tThe Year 2038 problem is caused by insufficient capacity used to represent time.\n\tIf it meet the problem, the time info will be updated by SNTP.\n\t*/\n\tif (sizeof(time_t) == 4) {\n\t\tif (tm.tm_year \u003e= 2038) {\n\t\t\tIOT_ERROR(\"Not support time by year 2038 problem(Y2038 Problem)\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_TIME, 0);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\ttm.tm_year -= 1900;\n\ttm.tm_mon -= 1;\n\n\tnow = mktime(\u0026tm);\n\tsnprintf(time_str, sizeof(time_str), \"%ld\", now);\n\n\terr = iot_bsp_system_set_time_in_sec(time_str);\n\tif (err) {\n\t\tIOT_ERROR(\"Time set error!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_TIME, err);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_TIME;\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":230,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"246382":{"score":0.7887346,"function_name":"_es_parse_input_data","code":"STATIC_FUNCTION\nchar* _es_parse_input_data(iot_security_context_t *security_context, char *input_data)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *message_value = NULL;\n\tchar *in_payload = NULL;\n\tJSON_H *root = NULL;\n\n\tif (!input_data || !security_context) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\treturn NULL;\n\t}\n\n\troot = JSON_PARSE(input_data);\n\tif (!root) {\n\t\tIOT_ERROR(\"parse error\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\tgoto out;\n\t}\n\n\tmessage_value = _es_json_parse_string(root, \"message\");\n\tif (!message_value) {\n\t\tIOT_ERROR(\"Invalid message\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\tgoto out;\n\t}\n\n\terr = _decode_and_decrypt(security_context, (unsigned char*) message_value, strlen(message_value), \u0026in_payload);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"decrypt and decode fail 0x%x\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (message_value) {\n\t\tiot_os_free(message_value);\n\t}\n\n\treturn in_payload;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":276,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"246804":{"score":0.81363386,"function_name":"_es_build_output_data","code":"STATIC_FUNCTION\nchar* _es_build_output_data(iot_security_context_t *security_context, char *out_payload)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *encrypted_message = NULL;\n\tchar *output_data = NULL;\n\tJSON_H *root = NULL;\n\n\tif (!out_payload || !security_context) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\treturn NULL;\n\t}\n\n\terr = _encrypt_and_encode(security_context, (unsigned char*) out_payload, strlen(out_payload), \u0026encrypted_message);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"encrypt and encode fail 0x%x\", err);\n\t\tgoto out;\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\tgoto out;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"message\", JSON_CREATE_STRING((char *) encrypted_message));\n\toutput_data = JSON_PRINT(root);\n\nout:\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (encrypted_message) {\n\t\tiot_os_free(encrypted_message);\n\t}\n\n\treturn output_data;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":321,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"247198":{"score":0.8716921,"function_name":"_es_deviceinfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_deviceinfo_handler(struct iot_context *ctx, char **out_payload)\n{\n\tchar *output_ptr = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_buffer_t iv_buf = { 0 };\n\tiot_security_cipher_params_t cipher_set_params = { 0 };\n\tsize_t base64_written = 0;\n\tsize_t encode_buf_len = 0;\n\tunsigned char *encode_buf = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"invalid iot_context!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\treturn err;\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\treturn err;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"protocolVersion\", JSON_CREATE_STRING(STDK_D2D_PROTOCOL_VERSION));\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"firmwareVersion\", JSON_CREATE_STRING(ctx-\u003edevice_info.firmware_version));\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"hashedSn\", JSON_CREATE_STRING((char *)ctx-\u003edevconf.hashed_sn));\n\tJSON_ADD_NUMBER_TO_OBJECT(root, \"wifiSupportFrequency\", (double) iot_bsp_wifi_get_freq());\n\n\terr = _es_crypto_cipher_gen_iv(\u0026iv_buf);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to generate cipher iv!!\");\n\t\tgoto out;\n\t}\n\n\tcipher_set_params.type = IOT_SECURITY_KEY_TYPE_AES256;\n\tcipher_set_params.iv = iv_buf;\n\n\terr = iot_security_cipher_set_params(ctx-\u003eeasysetup_security_context, \u0026cipher_set_params);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to set cipher params\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CIPHER_PARAMS_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_CIPHER_PARAMS_ERROR;\n\t\tgoto out;\n\t}\n\n\tencode_buf_len = IOT_SECURITY_B64_ENCODE_LEN(iv_buf.len);\n\tif ((encode_buf = (unsigned char *)iot_os_malloc(encode_buf_len)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for encode_buf\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto out;\n\t}\n\n\terr = iot_security_base64_encode_urlsafe(iv_buf.p, iv_buf.len,\n\t\t\t\t\tencode_buf, encode_buf_len, \u0026base64_written);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"base64 encode error!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_BASE64_ENCODE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_BASE64_ENCODE_ERROR;\n\t\tgoto out;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"iv\", JSON_CREATE_STRING((char *)encode_buf));\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\nout:\n\tif (iv_buf.p)\n\t\tfree(iv_buf.p);\n\tif (encode_buf)\n\t\tfree(encode_buf);\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":361,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"251690":{"score":0.8360742,"function_name":"_es_confirm_check_manager","code":"STATIC_FUNCTION\niot_error_t _es_confirm_check_manager(struct iot_context *ctx, enum ownership_validation_feature confirm_feature, char *sn)\n{\n\tchar *dev_sn = NULL;\n\tunsigned char curr_event = 0;\n\tunsigned char is_qr = 0;\n\tsize_t devsn_len;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM | IOT_EVENT_BIT_EASYSETUP_CONFIRM_DENY);\n\tctx-\u003ecurr_otm_feature = confirm_feature;\n\n\tIOT_REMARK(\"IOT_STATE_PROV_CONFIRMING\");\n\n\terr = iot_state_update(ctx, IOT_STATE_PROV_CONFIRM,\n\t\t\tIOT_STATE_OPT_NEED_INTERACT);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed handle cmd (%d): %d\", IOT_STATE_PROV_CONFIRM, err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\tgoto out;\n\t}\n\n\tswitch (confirm_feature)\n\t{\n\t\tcase OVF_BIT_JUSTWORKS:\n\t\t\tIOT_INFO(\"There is no confirmation request. The check is skipped\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_JUSTWORK, 0);\n\t\t\tbreak;\n\t\tcase OVF_BIT_QR:\n\t\t\tis_qr = 1;\n\t\t\t// fall through\n\t\tcase OVF_BIT_SERIAL_NUMBER:\n\t\t\tIOT_INFO(\"The %s confirmation is requested\", is_qr ? \"QR code\" : \"serial number\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_QR, is_qr);\n\t\t\tif (sn == NULL) {\n\t\t\t\tIOT_ERROR(\"null serial number transferred\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_QR, is_qr);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_QR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = iot_nv_get_serial_number(\u0026dev_sn, \u0026devsn_len);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to load serial number\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SERIAL_NOT_FOUND, err);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_SERIAL_NOT_FOUND;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!strcmp(sn, dev_sn)) {\n\t\t\t\tIOT_INFO(\"confirm\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_GET_OWNER_CONFIRM, 0);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"confirm fail\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_SERIAL_NUMBER, is_qr);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_SERIAL_NUMBER;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OVF_BIT_BUTTON:\n\t\t\tIOT_INFO(\"The button confirmation is requested\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_BUTTON, 0);\n\n\t\t\tcurr_event = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM | IOT_EVENT_BIT_EASYSETUP_CONFIRM_DENY, false, ES_CONFIRM_MAX_DELAY);\n\t\t\tIOT_DEBUG(\"curr_event = 0x%x\", curr_event);\n\n\t\t\tif (curr_event \u0026 IOT_EVENT_BIT_EASYSETUP_CONFIRM) {\n\t\t\t\tIOT_INFO(\"confirm\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_GET_OWNER_CONFIRM, 0);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"confirm failed\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CONFIRM_DENIED, 0);\n\n\t\t\t\t/* To report confirm failure to user, try to change iot-state timeout value shortly */\n\t\t\t\tif (iot_state_timeout_change(ctx, IOT_STATE_PROV_CONFIRM, ES_CONFIRM_FAIL_TIMEOUT) != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"Can't update prov_confirm state timeout\");\n\t\t\t\t}\n\n\t\t\t\terr = IOT_ERROR_EASYSETUP_CONFIRM_DENIED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OVF_BIT_PIN:\n\t\t\tIOT_INFO(\"The pin number confirmation is requested\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_PIN, 0);\n\t\t\treturn err;\n\t\tdefault:\n\t\t\tIOT_INFO(\"Not Supported confirmation type is requested\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_NOT_SUPPORTED, 0);\n\t\t\treturn err;\n\t}\n\nout:\n\tif (dev_sn)\n\t\tfree(dev_sn);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":712,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"252663":{"score":0.9073392,"function_name":"_es_confirminfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_confirminfo_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tJSON_H *recv = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *in_payload = NULL;\n\tchar *out_payload = NULL;\n\n\tif (!ctx || !input_data) {\n\t\tIOT_ERROR(\"Invalid data is reported\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\treturn err;\n\t}\n\n\tin_payload = _es_parse_input_data(ctx-\u003eeasysetup_security_context, input_data);\n\tif (!in_payload) {\n\t\tIOT_ERROR(\"Failed to get input payload\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid payload json format\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tif ((recv = JSON_GET_OBJECT_ITEM(root, \"otmSupportFeature\")) == NULL) {\n\t\tIOT_ERROR(\"no otmsupportfeature info\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tIOT_INFO(\"otmSupportFeature = %d\", recv-\u003evalueint);\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_REPORTED_OTMTYPE, recv-\u003evalueint);\n\n\tif ((recv-\u003evalueint \u003e= OVF_BIT_JUSTWORKS) \u0026\u0026 (recv-\u003evalueint \u003c= OVF_BIT_SERIAL_NUMBER)) {\n\t\tchar *sn = NULL;\n\n\t\tif (recv-\u003evalueint == OVF_BIT_QR || recv-\u003evalueint == OVF_BIT_SERIAL_NUMBER)\n\t\t\tsn = _es_json_parse_string(root, \"sn\");\n\n\t\terr = _es_confirm_check_manager(ctx, recv-\u003evalueint, sn);\n\n\t\tif (sn) {\n\t\t\tiot_os_free(sn);\n\t\t}\n\t\tif (err != IOT_ERROR_NONE)\n\t\t\tgoto out;\n\t} else {\n\t\tIOT_ERROR(\"Not supported otmsupportfeature : %d\", recv-\u003evalueint);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CONFIRM_NOT_SUPPORT, recv-\u003evalueint);\n\t\terr = IOT_ERROR_EASYSETUP_CONFIRM_NOT_SUPPORT ;\n\t\tgoto out;\n\t}\n\tJSON_DELETE(root);\n\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tiot_os_free(out_payload);\n\t}\n\tif (in_payload) {\n\t\tiot_os_free(in_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":811,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"253447":{"score":0.88746697,"function_name":"_es_confirm_handler","code":"STATIC_FUNCTION\niot_error_t _es_confirm_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tbool validation = true;\n\tchar pin[PIN_SIZE + 1];\n\tJSON_H *recv = NULL;\n\tJSON_H *root = NULL;\n\tint i;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *out_payload = NULL;\n\tchar *in_payload = NULL;\n\n\tif (!ctx || !ctx-\u003epin) {\n\t\tIOT_ERROR(\"no pin from device app\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_PIN_NOT_FOUND, 0);\n\t\terr = IOT_ERROR_EASYSETUP_PIN_NOT_FOUND;\n\t\treturn err;\n\t}\n\n\tif (ctx-\u003ecurr_otm_feature != OVF_BIT_PIN) {\n\t\tIOT_ERROR(\"otm is not pin.\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_CMD, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_CMD;\n\t\treturn err;\n\t}\n\n\tin_payload = _es_parse_input_data(ctx-\u003eeasysetup_security_context, input_data);\n\tif (!in_payload) {\n\t\tIOT_ERROR(\"Failed to get input payload\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid payload json format\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tif ((recv = JSON_GET_OBJECT_ITEM(root, \"pin\")) == NULL) {\n\t\tIOT_ERROR(\"no pin info\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tif (strlen(JSON_GET_STRING_VALUE(recv)) != PIN_SIZE) {\n\t\tIOT_ERROR(\"pin size mistmatch\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_PIN, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_PIN;\n\t\tgoto out;\n\t}\n\n\tstrncpy(pin, recv-\u003evaluestring, sizeof(pin) - 1);\n\tpin[PIN_SIZE] = '\\0';\n\tIOT_INFO(\"pin = %s\", pin);\n\tfor (i = 0; i \u003c PIN_SIZE; i++) {\n\t\tif (pin[i] \u003e '9' || pin[i] \u003c '0') {\n\t\t\tIOT_ERROR(\"invalid pin number from application\");\n\t\t\tvalidation = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!validation) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_PIN, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_PIN;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i \u003c PIN_SIZE; i++) {\n\t\tif (ctx-\u003epin-\u003epin[i] != pin[i]) {\n\t\t\tIOT_ERROR(\"the reported pin number is not matched[%d]\", i);\n\t\t\tvalidation = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!validation) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_PIN_NOT_MATCHED, 0);\n\t\terr = IOT_ERROR_EASYSETUP_PIN_NOT_MATCHED;\n\t\tgoto out;\n\t}\n\tJSON_DELETE(root);\n\n\t/*\n\t * output payload\n\t */\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tfree(out_payload);\n\t}\n\tif (in_payload) {\n\t\tfree(in_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":897,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"254517":{"score":0.8895794,"function_name":"_es_wifiscaninfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_wifiscaninfo_handler(struct iot_context *ctx, char **output_data)\n{\n\tchar wifi_bssid[WIFIINFO_BUFFER_SIZE] = {0, };\n\tJSON_H *root = NULL;\n\tJSON_H *array = NULL;\n\tJSON_H *array_obj = NULL;\n\tint i;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *out_payload = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"invalid iot_context!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\treturn err;\n\t}\n\n\t//optional : some chipsets don't support wifi scan mode during working AP mode\n\terr = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_SCAN);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_INFO(\"Can't control WIFI mode scan.(%d)\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_WIFI_SCAN_NOT_FOUND, err);\n\t}\n\n\tif (!ctx-\u003escan_num) {\n\t\tIOT_ERROR(\"wifi AP isn't found!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_WIFI_SCAN_NOT_FOUND, ctx-\u003escan_num);\n\t\terr = IOT_ERROR_EASYSETUP_WIFI_SCAN_NOT_FOUND;\n\t\treturn err;\n\t}\n\n\tarray = JSON_CREATE_ARRAY();\n\tif (!array) {\n\t\tIOT_ERROR(\"json_array create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\treturn err;\n\t}\n\n\tfor(i = 0; i \u003c ctx-\u003escan_num; i++) {\n\t\tif ((ctx-\u003escan_result[i].authmode \u003c  IOT_WIFI_AUTH_OPEN) ||\n\t\t\t(ctx-\u003escan_result[i].authmode \u003e= IOT_WIFI_AUTH_WPA2_ENTERPRISE)) {\n\t\t\tIOT_DEBUG(\"Unsupported authType %d, %s\", ctx-\u003escan_result[i].authmode,\n\t\t\t\t\t\t\t\t(char *)ctx-\u003escan_result[i].ssid);\n\t\t\tcontinue;\n\t\t}\n\t\tsnprintf(wifi_bssid, sizeof(wifi_bssid), \"%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\t\t\tctx-\u003escan_result[i].bssid[0], ctx-\u003escan_result[i].bssid[1],\n\t\t\t\t\t\tctx-\u003escan_result[i].bssid[2], ctx-\u003escan_result[i].bssid[3],\n\t\t\t\t\t\tctx-\u003escan_result[i].bssid[4], ctx-\u003escan_result[i].bssid[5]);\n\n\t\tarray_obj = JSON_CREATE_OBJECT();\n\t\tif (!array_obj) {\n\t\t\tIOT_ERROR(\"json create failed\");\n\t\t\tif (array) {\n\t\t\t\tJSON_DELETE(array);\n\t\t\t}\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_OBJECT(array_obj, \"bssid\", JSON_CREATE_STRING(wifi_bssid));\n\t\tJSON_ADD_ITEM_TO_OBJECT(array_obj, \"ssid\", JSON_CREATE_STRING((char*)ctx-\u003escan_result[i].ssid));\n\t\tJSON_ADD_NUMBER_TO_OBJECT(array_obj, \"rssi\", (double) ctx-\u003escan_result[i].rssi);\n\t\tJSON_ADD_NUMBER_TO_OBJECT(array_obj, \"frequency\", (double) ctx-\u003escan_result[i].freq);\n\t\tJSON_ADD_NUMBER_TO_OBJECT(array_obj, \"authType\", ctx-\u003escan_result[i].authmode);\n\t\tJSON_ADD_ITEM_TO_ARRAY(array, array_obj);\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tif (array) {\n\t\t\tJSON_DELETE(array);\n\t\t}\n\t\tgoto out;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"wifiScanInfo\", array);\n\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tfree(out_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1010,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"255810":{"score":0.8622879,"function_name":"_decide_wifi_auth_mode","code":"STATIC_FUNCTION\niot_wifi_auth_mode_t _decide_wifi_auth_mode(const JSON_H *item, struct iot_wifi_prov_data *wifi_prov, const struct iot_context *ctx)\n{\n\tiot_wifi_auth_mode_t auth_mode = IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\tint i;\n\n\tif (!ctx || !wifi_prov) {\n\t\treturn IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\t}\n\n\tif (item == NULL) {\n\t\tIOT_INFO(\"no authType\");\n\t\tfor (i = 0; i \u003c ctx-\u003escan_num; i++) {\n\t\t\tif (!strcmp(wifi_prov-\u003essid, (char *)ctx-\u003escan_result[i].ssid)) {\n\t\t\t\tauth_mode = ctx-\u003escan_result[i].authmode;\n\t\t\t\tIOT_DEBUG(\"%s is type %d\", wifi_prov-\u003essid, auth_mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ctx-\u003escan_num) {\n\t\t\tif (strlen(wifi_prov-\u003epassword) == 0) {\n\t\t\t\tIOT_DEBUG(\"%s doesn't exist in scan list. So assume it as Open\", wifi_prov-\u003essid);\n\t\t\t\tauth_mode = IOT_WIFI_AUTH_OPEN;\n\t\t\t} else {\n\t\t\t\tIOT_DEBUG(\"%s doesn't exist in scan list. So assume it as WPA\", wifi_prov-\u003essid);\n\t\t\t\tauth_mode = IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i \u003c ctx-\u003escan_num; i++) {\n\t\t\tif (!strcmp(wifi_prov-\u003essid, (char *)ctx-\u003escan_result[i].ssid)) {\n\t\t\t\tif (item-\u003evalueint == ctx-\u003escan_result[i].authmode) {\n\t\t\t\t\tauth_mode = item-\u003evalueint;\n\t\t\t\t} else {\n\t\t\t\t\tauth_mode = ctx-\u003escan_result[i].authmode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ctx-\u003escan_num) {\n\t\t\tauth_mode = item-\u003evalueint;\n\t\t}\n\t\tIOT_DEBUG(\"%s is type %d\", wifi_prov-\u003essid, auth_mode);\n\t}\n\n\treturn auth_mode;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1104,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"256272":{"score":0.9188435,"function_name":"_es_wifi_prov_parse","code":"STATIC_FUNCTION\niot_error_t _es_wifi_prov_parse(struct iot_context *ctx, char *in_payload)\n{\n\tstruct iot_wifi_prov_data *wifi_prov = NULL;\n\tJSON_H *item = NULL;\n\tJSON_H *root = NULL;\n\tJSON_H *wifi_credential = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tif ((wifi_credential = JSON_GET_OBJECT_ITEM(root, \"wifiCredential\")) == NULL) {\n\t\tIOT_ERROR(\"failed to find wifiCredential\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tif ((wifi_prov = (struct iot_wifi_prov_data *)malloc(sizeof(struct iot_wifi_prov_data))) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for wifi_prov_data\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tmemset(wifi_prov, 0, sizeof(struct iot_wifi_prov_data));\n\n\tif ((item = JSON_GET_OBJECT_ITEM(wifi_credential, \"ssid\")) == NULL) {\n\t\tIOT_ERROR(\"failed to find ssid\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto wifi_parse_out;\n\t}\n\tstrncpy(wifi_prov-\u003essid, JSON_GET_STRING_VALUE(item), sizeof(wifi_prov-\u003essid) - 1);\n\n\t// password is optional.\n\tif ((item = JSON_GET_OBJECT_ITEM(wifi_credential, \"password\")) == NULL)\n\t\tIOT_INFO(\"No wifi password\");\n\telse\n\t\tstrncpy(wifi_prov-\u003epassword, JSON_GET_STRING_VALUE(item), sizeof(wifi_prov-\u003epassword) - 1);\n\n\tif ((item = JSON_GET_OBJECT_ITEM(wifi_credential, \"macAddress\")) == NULL) {\n\t\tIOT_INFO(\"no macAddress\");\n\t} else {\n\t\tstrncpy(wifi_prov-\u003emac_str, JSON_GET_STRING_VALUE(item), sizeof(wifi_prov-\u003emac_str));\n\t\terr = iot_util_convert_str_mac(wifi_prov-\u003emac_str, \u0026wifi_prov-\u003ebssid);\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"Failed to convert str to mac address (error : %d) : %s\", err, wifi_prov-\u003emac_str);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_MAC, err);\n\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_MAC;\n\t\t\tgoto wifi_parse_out;\n\t\t}\n\t}\n\n\n\twifi_prov-\u003esecurity_type =\n\t\t_decide_wifi_auth_mode(JSON_GET_OBJECT_ITEM(wifi_credential, \"authType\"), wifi_prov, ctx);\n\n\terr = iot_nv_set_wifi_prov_data(wifi_prov);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to set the cloud prov data\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_WIFI_DATA_WRITE_FAIL, err);\n\t\terr = IOT_ERROR_EASYSETUP_WIFI_DATA_WRITE_FAIL;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tIOT_INFO(\"ssid: %s\", wifi_prov-\u003essid);\n\tIOT_DEBUG(\"password: %s\", wifi_prov-\u003epassword);\n\tIOT_INFO(\"mac addr: %s\", wifi_prov-\u003emac_str);\n\nwifi_parse_out:\n\tif (wifi_prov)\n\t\tfree(wifi_prov);\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1152,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"257255":{"score":0.8205823,"function_name":"_es_cloud_prov_parse","code":"STATIC_FUNCTION\niot_error_t _es_cloud_prov_parse(struct iot_context *ctx, char *in_payload)\n{\n\tstruct iot_cloud_prov_data *cloud_prov = NULL;\n\tchar *full_url = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\turl_parse_t url = { .protocol = NULL, .domain = NULL, .port = 0};\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid payload json format\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto cloud_parse_out;\n\t}\n\n\tif ((cloud_prov = (struct iot_cloud_prov_data *)malloc(sizeof(struct iot_cloud_prov_data))) == NULL) {\n\t\tIOT_ERROR(\"failed to alloc mem\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto cloud_parse_out;\n\t}\n\n\tmemset(cloud_prov, 0, sizeof(struct iot_cloud_prov_data));\n\n\tif ((full_url = _es_json_parse_string(root, \"brokerUrl\")) == NULL) {\n\t\tIOT_ERROR(\"failed to find brokerUrl\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto cloud_parse_out;\n\t}\n\n\terr = iot_util_url_parse(full_url, \u0026url);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to parse broker url\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_BROKER_URL, err);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_BROKER_URL;\n\t\tgoto cloud_parse_out;\n\t}\n\n\tif ((cloud_prov-\u003elabel = _es_json_parse_string(root, \"deviceName\")) == NULL) {\n\t\tIOT_INFO(\"No deviceName\");\n\t}\n\n\tcloud_prov-\u003ebroker_url = url.domain;\n\tcloud_prov-\u003ebroker_port = url.port;\n\n\terr = iot_nv_set_cloud_prov_data(cloud_prov);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to set the cloud prov data\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CLOUD_DATA_WRITE_FAIL, err);\n\t\tcloud_prov-\u003ebroker_port = 0;\n\t\terr = IOT_ERROR_EASYSETUP_CLOUD_DATA_WRITE_FAIL;\n\t\tgoto cloud_prov_data_fail;\n\t}\n\n\tIOT_INFO(\"brokerUrl: %s:%d\", cloud_prov-\u003ebroker_url, cloud_prov-\u003ebroker_port);\n\tIOT_INFO(\"deviceName : %s\", cloud_prov-\u003elabel);\n\ncloud_prov_data_fail:\n\tif (cloud_prov-\u003elabel) {\n\t\tiot_os_free(cloud_prov-\u003elabel);\n\t}\ncloud_parse_out:\n\tif (url.domain) {\n\t\tiot_os_free(url.domain);\n\t}\n\tif (url.protocol) {\n\t\tiot_os_free(url.protocol);\n\t}\n\tif (full_url) {\n\t\tiot_os_free(full_url);\n\t}\n\tif (cloud_prov) {\n\t\tiot_os_free(cloud_prov);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1236,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"258103":{"score":0.90894395,"function_name":"_es_wifiprovisioninginfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_wifiprovisioninginfo_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *in_payload = NULL;\n\tchar *out_payload = NULL;\n\n\tin_payload = _es_parse_input_data(ctx-\u003eeasysetup_security_context, input_data);\n\n\terr = _es_wifi_prov_parse(ctx, (char *)in_payload);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to parse wifi_prov\");\n\t\tgoto out;\n\t}\n\n\terr = _es_cloud_prov_parse(ctx, (char *)in_payload);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to parse cloud_prov\");\n\t\tgoto out;\n\t}\n\n\tif (ctx-\u003elookup_id == NULL) {\n\t\tctx-\u003elookup_id = iot_os_malloc(IOT_REG_UUID_STR_LEN + 1);\n\t}\n\n\terr = iot_get_random_id_str(ctx-\u003elookup_id,\n\t\t\t(IOT_REG_UUID_STR_LEN + 1));\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get new lookup_id(%d)\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_LOOKUPID_GENERATE_FAIL, err);\n\t\terr = IOT_ERROR_EASYSETUP_LOOKUPID_GENERATE_FAIL;\n\t\tgoto out;\n\t}\n\n\tIOT_DEBUG(\"lookupid = %s\", ctx-\u003elookup_id);\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"lookupId\", JSON_CREATE_STRING(ctx-\u003elookup_id));\n\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\n\n\t/* Now we allow D2D process reentrant and prov_data could be loaded\n\t * at the init state or previous D2D, so free it first to avoid memory-leak\n\t */\n\tiot_api_prov_data_mem_free(\u0026ctx-\u003eprov_data);\n\terr = iot_nv_get_prov_data(\u0026ctx-\u003eprov_data);\n\tif (err) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_WIFI_DATA_READ_FAIL, err);\n\t\terr = IOT_ERROR_EASYSETUP_WIFI_DATA_READ_FAIL;\n\t\tIOT_WARN(\"No provisining from nv\");\n\t} else {\n\t\tIOT_INFO(\"provisioning success\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_PROVISIONING_SUCCESS, 0);\n\t}\nout:\n\tif (in_payload) {\n\t\tiot_os_free(in_payload);\n\t}\n\tif (out_payload) {\n\t\tiot_os_free(out_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1319,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"258795":{"score":0.8650409,"function_name":"_es_setupcomplete_handler","code":"STATIC_FUNCTION\niot_error_t _es_setupcomplete_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *out_payload = NULL;\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tiot_os_free(out_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1394,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"258992":{"score":0.8509769,"function_name":"_es_log_systeminfo_handler","code":"static iot_error_t _es_log_systeminfo_handler(struct iot_context *ctx, char **out_payload)\n{\n\tchar *output_ptr = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"version\", JSON_CREATE_STRING(\"1.0\"));\n\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\n\nout:\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1421,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"259186":{"score":0.84815043,"function_name":"_es_log_create_dump_handler","code":"static iot_error_t _es_log_create_dump_handler(struct iot_context *ctx, char *in_payload, char **out_payload)\n{\n\tchar *output_ptr = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\n\nout:\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1447,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"259340":{"score":0.84194845,"function_name":"_es_log_get_dump_handler","code":"static iot_error_t _es_log_get_dump_handler(struct iot_context *ctx, char **out_payload)\n{\n\tchar *log_dump = NULL;\n\tchar *output_ptr = NULL;\n\tJSON_H *item = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n#if !defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tchar *sumo_dump = NULL;\n\tsize_t log_dump_size = 2048;\n\tsize_t sumo_dump_size = 200;\n\tsize_t written_size = 0;\n#endif\n\n\titem = JSON_CREATE_OBJECT();\n\tif (!item) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tlog_dump = iot_debug_get_log();\n#else\n\terr = st_create_log_dump((IOT_CTX *)ctx, \u0026log_dump, log_dump_size, \u0026written_size, IOT_DUMP_MODE_NEED_BASE64 | IOT_DUMP_MODE_NEED_DUMP_STATE);\n\tif (err \u003c 0) {\n\t\tIOT_ERROR(\"Fail to get log dump!\\n\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CREATE_LOGDUMP_FAIL, 0);\n\t\tgoto out;\n\t}\n\terr = st_create_log_dump((IOT_CTX *)ctx, \u0026sumo_dump, sumo_dump_size, \u0026written_size, IOT_DUMP_MODE_NEED_BASE64);\n\tif (err \u003c 0) {\n\t\tIOT_ERROR(\"Fail to get sumo dump!\\n\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CREATE_SUMODUMP_FAIL, 0);\n\t\tgoto out;\n\t}\n#endif\n\n\tJSON_ADD_NUMBER_TO_OBJECT(item, \"code\", 1);\n\tJSON_ADD_ITEM_TO_OBJECT(item, \"message\", JSON_CREATE_STRING(log_dump));\n#if !defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tJSON_ADD_ITEM_TO_OBJECT(item, \"sumomessage\", JSON_CREATE_STRING(sumo_dump));\n#endif\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tif (item) {\n\t\t\tJSON_DELETE(item);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"error\", item);\n\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\nout:\n#if !defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tif (log_dump)\n\t\tfree(log_dump);\n\tif (sumo_dump)\n\t\tfree(sumo_dump);\n#endif\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1471,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"259993":{"score":0.8583077,"function_name":"iot_easysetup_request_handler","code":"iot_error_t iot_easysetup_request_handler(struct iot_context *ctx, struct iot_easysetup_payload request)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tint ret = IOT_OS_TRUE;\n\tstruct iot_easysetup_payload response;\n\n\tif (!ctx)\n\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\n\tresponse.step = request.step;\n\tresponse.payload = NULL;\n\n\tswitch (request.step) {\n\tcase IOT_EASYSETUP_STEP_DEVICEINFO:\n\t\terr = _es_deviceinfo_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_WIFISCANINFO:\n\t\terr = _es_wifiscaninfo_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_KEYINFO:\n\t\terr = _es_keyinfo_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_CONFIRMINFO:\n\t\terr = _es_confirminfo_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_CONFIRM:\n\t\terr = _es_confirm_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO:\n\t\terr = _es_wifiprovisioninginfo_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_SETUPCOMPLETE:\n\t\terr = _es_setupcomplete_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_LOG_SYSTEMINFO:\n\t\terr = _es_log_systeminfo_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_LOG_CREATE_DUMP:\n\t\terr = _es_log_create_dump_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_LOG_GET_DUMP:\n\t\terr = _es_log_get_dump_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tdefault:\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\tbreak;\n\t}\n\tif (err) {\n\t\tIOT_ERROR(\"failed to handle step %d (%d)\", request.step, err);\n\t}\n\n\tresponse.err = err;\n\n\tif (ctx-\u003eeasysetup_resp_queue) {\n\t\tret = iot_os_queue_send(ctx-\u003eeasysetup_resp_queue, \u0026response, 0);\n\t\tif (ret != IOT_OS_TRUE) {\n\t\t\tIOT_ERROR(\"Cannot put the response into easysetup_resp_queue\");\n\t\t\terr = IOT_ERROR_EASYSETUP_QUEUE_SEND_ERROR;\n\t\t} else {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\t\tIOT_EVENT_BIT_EASYSETUP_RESP);\n\t\t\terr = IOT_ERROR_NONE;\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"easysetup_resp_queue is deleted\");\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t}\n\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1544,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"260666":{"score":0.8845985,"function_name":"iot_easysetup_create_ssid","code":"iot_error_t iot_easysetup_create_ssid(struct iot_devconf_prov_data *devconf, char *ssid, size_t ssid_len)\n{\n\tchar *serial = NULL;\n\tunsigned char hash_buffer[IOT_SECURITY_SHA256_LEN] = { 0, };\n\tunsigned char base64url_buffer[IOT_SECURITY_B64_ENCODE_LEN(IOT_SECURITY_SHA256_LEN)] = { 0, };\n\tsize_t base64_written = 0;\n\tchar ssid_build[33] = { 0, };\n\tunsigned char last_sn[HASH_SIZE + 1] = { 0,};\n\tunsigned char hashed_sn[HASH_SIZE + 1] = { 0,};\n\tsize_t length;\n\tint i, setup_type;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\tIOT_WARN_CHECK((devconf == NULL || ssid == NULL || ssid_len == 0), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\terr = iot_nv_get_serial_number(\u0026serial, \u0026length);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to get serial number (%d)\", err);\n\t\tgoto out;\n\t}\n\terr = iot_security_sha256((unsigned char*)serial, length, hash_buffer, sizeof(hash_buffer));\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed sha256 (%d)\", err);\n\t\tgoto out;\n\t}\n\terr = iot_security_base64_encode_urlsafe(hash_buffer, sizeof(hash_buffer),\n\t\t\t\t\t\t\t\t\t\t\t base64url_buffer, sizeof(base64url_buffer), \u0026base64_written);\n\tif (err != IOT_ERROR_NONE)\n\t\tgoto out;\n\n\tif (base64_written \u003e= HASH_SIZE) {\n\t\tif (devconf-\u003ehashed_sn) {\n\t\t\tiot_os_free(devconf-\u003ehashed_sn);\n\t\t\tdevconf-\u003ehashed_sn = NULL;\n\t\t}\n\n\t\tdevconf-\u003ehashed_sn = iot_os_malloc(base64_written + 1);\n\t\tif (!devconf-\u003ehashed_sn) {\n\t\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto out;\n\t\t}\n\t\tmemset(devconf-\u003ehashed_sn, '\\0', base64_written + 1);\n\t\tmemcpy(devconf-\u003ehashed_sn, base64url_buffer, base64_written);\n\t\tmemcpy(hashed_sn, base64url_buffer, HASH_SIZE);\n\t} else {\n\t\terr = IOT_ERROR_SECURITY_BASE64_URL_ENCODE;\n\t\tgoto out;\n\t}\n\thashed_sn[HASH_SIZE] = '\\0';\n\n\tfor (i = 0; i \u003c HASH_SIZE; i++) {\n\t\tif (length \u003c (HASH_SIZE - i))\n\t\t\tlast_sn[i] = 0;\n\t\telse\n\t\t\tlast_sn[i] = serial[length - (HASH_SIZE - i)];\n\t}\n\tlast_sn[HASH_SIZE] = '\\0';\n\tIOT_INFO(\"\u003e\u003e %s[%c%c%c%c] \u003c\u003c\", devconf-\u003edevice_onboarding_id,\n\t\t\t last_sn[0], last_sn[1],\n\t\t\t last_sn[2], last_sn[3]);\n\n\tsetup_type = SETUP_TYPE_HYBRID_SERIAL_NUMBER;\n\n\tif (devconf-\u003essid_version == 4) {\n\t\tsnprintf(ssid_build, sizeof(ssid_build), \"%s_E4%4s%3s%1d%4s%4s\",\n\t\t\t\t devconf-\u003edevice_onboarding_id, devconf-\u003emnid, devconf-\u003esetupid, setup_type, hashed_sn, last_sn);\n\t} else if (devconf-\u003essid_version == 5) {\n\t\tsnprintf(ssid_build, sizeof(ssid_build), \"%s_E5%4s%3s%4s%4s\",\n\t\t\t\t devconf-\u003edevice_onboarding_id, devconf-\u003emnid, devconf-\u003esetupid, hashed_sn, last_sn);\n\t} else {\n\t\terr = IOT_ERROR_INVALID_ARGS;\n\t\tgoto out;\n\t}\n\n\tmemcpy(ssid, ssid_build, ssid_len \u003c strlen(ssid_build) ? ssid_len : strlen(ssid_build));\nout:\n\tif (err \u0026\u0026 devconf-\u003ehashed_sn) {\n\t\tiot_os_free(devconf-\u003ehashed_sn);\n\t\tdevconf-\u003ehashed_sn = NULL;\n\t}\n\tif (serial) {\n\t\tiot_os_free(serial);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/discovery/ssid/iot_easysetup_discovery_ssid.c","line_number":32,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"262022":{"score":0.77488756,"function_name":"_iot_easysetup_gen_get_payload","code":"iot_error_t _iot_easysetup_gen_get_payload(struct iot_context *ctx, const char *cmd, char **out_payload)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_easysetup_payload response;\n\tint cur_step;\n\n\tif (!strcmp(cmd, IOT_ES_URI_GET_DEVICEINFO)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_DEVICEINFO;\n\t} else if (!strcmp(cmd, IOT_ES_URI_GET_WIFISCANINFO)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_WIFISCANINFO;\n\t} else if (!strcmp(cmd, IOT_ES_URI_GET_LOGS_SYSTEMINFO)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_LOG_SYSTEMINFO;\n\t} else if (!strcmp(cmd, IOT_ES_URI_GET_LOGS_DUMP)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_LOG_GET_DUMP;\n\t} else {\n\t\terr = IOT_ERROR_BAD_REQ;\n\t\tIOT_ERROR(\"Invalid command %s\", cmd);\n\t\tgoto get_exit;\n\t}\n\n\tif ((cur_step != ref_step) \u0026\u0026 (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)) {\n\t\tif ((cur_step == IOT_EASYSETUP_STEP_WIFISCANINFO) \u0026\u0026 (ref_step == IOT_EASYSETUP_STEP_CONFIRM)) {\n\t\t\tref_step = IOT_EASYSETUP_STEP_WIFISCANINFO;\n\t\t} else {\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tIOT_ERROR(\"Invalid command step %s\", cmd);\n\t\t\tgoto get_exit;\n\t\t}\n\t}\n\n\tif (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)\n\t\tref_step++;\n\n\terr = iot_easysetup_request(ctx, cur_step, NULL);\n\tif (err) {\n\t\tIOT_ERROR(\"easysetup request failed %d (%d)\", cur_step, err);\n\t\tgoto get_exit;\n\t}\n\tIOT_INFO(\"waiting.. response for [%s]\", cmd);\n\tiot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_EASYSETUP_RESP, true, false, IOT_OS_MAX_DELAY);\n\terr = iot_os_queue_receive(ctx-\u003eeasysetup_resp_queue, \u0026response, 0);\n\tif (response.step != cur_step) {\n\t\tIOT_ERROR(\"unexpected response %d:%d\", cur_step, response.step);\n\t\tif (response.payload)\n\t\t\tfree(response.payload);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_CRITICAL_ERROR;\n\t} else {\n\t\tif (!response.err) {\n\t\t\t*out_payload = response.payload;\n\t\t\tIOT_DEBUG(\"payload: %s\", *out_payload);\n\t\t}\n\t\terr = response.err;\n\t}\n\n\tif (err) {\n\t\tiot_error_t err1;\n\t\tref_step = 0;\n\t\terr1 = iot_state_update(ctx, IOT_STATE_CHANGE_FAILED, ctx-\u003ecurr_state);\n\t\tif (err1) {\n\t\t\tIOT_ERROR(\"cannot update state to failed (%d)\", err1);\n\t\t\terr = err1;\n\t\t}\n\t}\n\nget_exit:\n\treturn err;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":96,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"262958":{"score":0.7219944,"function_name":"_iot_easysetup_gen_post_payload","code":"iot_error_t _iot_easysetup_gen_post_payload(struct iot_context *ctx, const char *cmd, char *in_payload, char **out_payload)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_easysetup_payload response;\n\tint cur_step;\n\tunsigned int curr_event;\n\n\tif (!in_payload)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tif (!strcmp(cmd, IOT_ES_URI_POST_KEYINFO)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_KEYINFO;\n\t} else if (!strcmp(cmd, IOT_ES_URI_POST_CONFIRMINFO)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_CONFIRMINFO;\n\t} else if (!strcmp(cmd, IOT_ES_URI_POST_CONFIRM)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_CONFIRM;\n\t} else if (!strcmp(cmd, IOT_ES_URI_POST_WIFIPROVISIONINGINFO)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO;\n\t} else if (!strcmp(cmd, IOT_ES_URI_POST_SETUPCOMPLETE)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_SETUPCOMPLETE;\n\t} else if (!strcmp(cmd, IOT_ES_URI_POST_LOGS)) {\n\t\tcur_step = IOT_EASYSETUP_STEP_LOG_CREATE_DUMP;\n\t} else {\n\t\terr = IOT_ERROR_BAD_REQ;\n\t\tIOT_ERROR(\"Invalid command %s\", cmd);\n\t\tgoto post_exit;\n\t}\n\n\tif ((cur_step != ref_step) \u0026\u0026 (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)) {\n\t\tif (cur_step == IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO) {\n\t\t   if ((ref_step == IOT_EASYSETUP_STEP_CONFIRM) || (ref_step == IOT_EASYSETUP_STEP_CONFIRMINFO))\n\t\t\t   ref_step = IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO;\n\t\t   else {\n\t\t\t   err = IOT_ERROR_BAD_REQ;\n\t\t\t   IOT_ERROR(\"Invalid command step %s\", cmd);\n\t\t\t   goto post_exit;\n\t\t   }\n\t\t} else {\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tIOT_ERROR(\"Invalid command step %s\", cmd);\n\t\t\tgoto post_exit;\n\t\t}\n\t}\n\n\tif (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)\n\t\tref_step++;\n\n\terr = iot_easysetup_request(ctx, cur_step, in_payload);\n\tif (err) {\n\t\tIOT_ERROR(\"easysetup request failed %d (%d)\", cur_step, err);\n\t\tgoto post_exit;\n\t}\n\tIOT_INFO(\"waiting.. response for [%s]\", cmd);\n\n\tfor( ; ; ) {\n\t\tcurr_event = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\t\tIOT_EVENT_BIT_EASYSETUP_RESP, true, false, IOT_OS_MAX_DELAY);\n\t\tif (curr_event \u0026 IOT_EVENT_BIT_EASYSETUP_RESP)\n\t\t\tbreak;\n\t}\n\n\terr = iot_os_queue_receive(ctx-\u003eeasysetup_resp_queue, \u0026response, 0);\n\tif (response.step != cur_step) {\n\t\tIOT_ERROR(\"unexpected response %d:%d\", cur_step, response.step);\n\t\tif (response.payload)\n\t\t\tfree(response.payload);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_CRITICAL_ERROR;\n\t} else {\n\t\tif (!response.err) {\n\t\t\t*out_payload = response.payload;\n\t\t\tIOT_DEBUG(\"payload: %s\", *out_payload);\n\t\t}\n\t\terr = response.err;\n\t}\n\n\tif (err) {\n\t\tiot_error_t err1;\n\t\tref_step = 0;\n\t\terr1 = iot_state_update(ctx, IOT_STATE_CHANGE_FAILED, ctx-\u003ecurr_state);\n\t\tif (err1) {\n\t\t\tIOT_ERROR(\"cannot update state to failed (%d)\", err1);\n\t\t\terr = err1;\n\t\t}\n\t} else {\n\t\tiot_error_t err1;\n\t\tswitch (cur_step) {\n\t\tcase IOT_EASYSETUP_STEP_SETUPCOMPLETE:\n\t\t\terr1 = iot_state_update(ctx, IOT_STATE_PROV_DONE, 0);\n\t\t\tif (err1) {\n\t\t\t\tIOT_ERROR(\"cannot update state to prov_done (%d)\", err1);\n\t\t\t\terr = err1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IOT_EASYSETUP_STEP_CONFIRMINFO:\n\t\tcase IOT_EASYSETUP_STEP_CONFIRM:\n\t\tcase IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO:\n\t\t\tbreak;\n\t\t}\n\t}\npost_exit:\n\treturn err;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":175,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"264051":{"score":0.7577108,"function_name":"_is_400_error","code":"static inline bool _is_400_error(iot_error_t err)\n{\n\tif (err \u003c= IOT_ERROR_EASYSETUP_400_BASE\n\t\t\u0026\u0026 err \u003e IOT_ERROR_EASYSETUP_500_BASE)\n\t\treturn true;\n\telse\n\t\treturn false;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":338,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"264096":{"score":0.87612253,"function_name":"digit_count_payload","code":"unsigned int digit_count_payload (unsigned int payload_len)\n{\n\tunsigned int count = 0;\n\n\twhile (1)\n\t{\n\t\tpayload_len /= 10;\n\t\tcount++;\n\t\tif (!payload_len)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":327,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v.1.4.7"},"264155":{"score":0.41982073,"function_name":"httpd_cgi_handler","code":"void httpd_cgi_handler(const char* uri, int iNumParams, char **pcParam, char **pcValue, void *connection_state)\n{\n\tstruct fs_file *file = (struct fs_file *) connection_state;\n\tunsigned int buffer_len;\n\tchar *buffer = NULL;\n\tchar *payload = NULL;\n\tchar *ptr = NULL;\n\tcJSON *root = NULL;\n\tcJSON *item = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\tif (!file)\n\t\treturn;\n\n\tif (!strcmp(uri, IOT_ES_URI_GET_POST_RESPONSE)) {\n\t\tif (!iNumParams) {\n\t\t\tIOT_WARN(\"invalid arg %d\", iNumParams);\n\t\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_WARNING;\n\t\t} else {\n\t\t\terr = _iot_easysetup_gen_post_payload(context, pcParam[0], http_post_payload, \u0026payload);\n\t\t\tif (!err) {\n\t\t\t\tbuffer_len = strlen(payload) + strlen(http_status_200) + strlen(http_header) + 9;\n\n\t\t\t\tif ((buffer = (char *)malloc(buffer_len)) == NULL) {\n\t\t\t\t\tIOT_ERROR(\"failed to malloc for buffer\");\n\t\t\t\t\tgoto cgi_out;\n\t\t\t\t}\n\t\t\t\tsnprintf(buffer, buffer_len, \"%s%s%4d\\r\\n\\r\\n%s\",\n\t\t\t\t\t\thttp_status_200, http_header, (int)strlen(payload), payload);\n\t\t\t\tIOT_INFO(\"%s ok\", pcParam[0]);\n\t\t\t} else if (err == IOT_ERROR_BAD_REQ) {\n\t\t\t\tgoto cgi_out;\n\t\t\t} else {\n\t\t\t\tIOT_INFO(\"%s not ok\", pcParam[0]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\terr = _iot_easysetup_gen_get_payload(context, uri, \u0026payload);\n\t\tif (!err) {\n\t\t\tbuffer_len = strlen(payload) + strlen(http_status_200) + strlen(http_header) + 9;\n\n\t\t\tif ((buffer = (char *)malloc(buffer_len)) == NULL) {\n\t\t\t\tIOT_ERROR(\"failed to malloc for buffer\");\n\t\t\t\tgoto cgi_out;\n\t\t\t}\n\t\t\tsnprintf(buffer, buffer_len, \"%s%s%4d\\r\\n\\r\\n%s\",\n\t\t\t\t\t\thttp_status_200, http_header, (int)strlen(payload), payload);\n\t\t\tIOT_INFO(\"%s ok\", uri);\n\t\t} else if (err == IOT_ERROR_BAD_REQ) {\n\t\t\tgoto cgi_out;\n\t\t} else {\n\t\t\tIOT_INFO(\"%s not ok\", pcParam[0]);\n\t\t}\n\t}\n\tif (err) {\n\t\titem = cJSON_CreateObject();\n\t\tif (!item) {\n\t\t\tIOT_ERROR(\"json create failed\");\n\t\t\tgoto cgi_out;\n\t\t}\n\t\tcJSON_AddItemToObject(item, \"code\", cJSON_CreateNumber((double) err));\n\t\tcJSON_AddItemToObject(item, \"message\", cJSON_CreateString(\"\"));\n\t\troot = cJSON_CreateObject();\n\t\tif (!root) {\n\t\t\tIOT_ERROR(\"json create failed\");\n\t\t\tcJSON_Delete(item);\n\t\t\tgoto cgi_out;\n\t\t}\n\t\tcJSON_AddItemToObject(root, \"error\", (cJSON *)item);\n\n\t\tptr = cJSON_PrintUnformatted(root);\n\t\tIOT_DEBUG(\"%s\", ptr);\n\n\t\tbuffer_len = strlen(ptr) + strlen(http_status_500) + strlen(http_header) + 9;\n\n\t\tif ((buffer = (char *)malloc(buffer_len)) == NULL) {\n\t\t\tIOT_ERROR(\"failed to malloc for buffer\");\n\t\t\tgoto cgi_out;\n\t\t}\n\t\tif (_is_400_error(err)) {\n\t\t\tsnprintf(buffer, buffer_len, \"%s%s%4d\\r\\n\\r\\n%s\",\n\t\t\t\thttp_status_400, http_header, (int)strlen(ptr), ptr);\n\t\t} else {\n\t\t\tsnprintf(buffer, buffer_len, \"%s%s%4d\\r\\n\\r\\n%s\",\n\t\t\t\thttp_status_500, http_header, (int)strlen(ptr), ptr);\n\t\t}\n\t}\n\tIOT_DEBUG(\"%s\", buffer);\n\n\tfile-\u003edata = buffer;\n\tfile-\u003elen = file-\u003eindex = strlen(buffer);\n\tfile-\u003epextension = NULL;\n\tfile-\u003eflags = FS_FILE_FLAGS_HEADER_INCLUDED;\n\ncgi_out:\n\tif (root)\n\t\tcJSON_Delete(root);\n\tif (payload)\n\t\tfree(payload);\n\tif (ptr)\n\t\tfree(ptr);\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":347,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"265511":{"score":0.57150114,"function_name":"iot_easysetup_init","code":"iot_error_t iot_easysetup_init(struct iot_context *ctx)\n{\n\tENTER();\n\tif (!ctx)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tcontext = ctx;\n\n\tctx-\u003ees_httpd_handle = httpd_init();\n\n\tif (ctx-\u003ees_httpd_handle == NULL) {\n\t\tIOT_ERROR(\"httpd_init failed\");\n\t\treturn IOT_ERROR_UNINITIALIZED;\n\t} else {\n\t\tif (!http_post_payload) {\n\t\t\thttp_post_payload = malloc(LWIP_HTTPD_POST_MAX_PAYLOAD_LEN);\n\t\t\tif (!http_post_payload) {\n\t\t\t\thttpd_deinit(ctx-\u003ees_httpd_handle);\n\t\t\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t\t}\n\t\t\thttp_post_payload_len = 0;\n\t\t}\n\t}\n\tref_step = 0;\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP_LOG_SUPPORT)\n\tif ((log_buffer = (char *)malloc(CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP_LOG_SIZE)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for log buffer\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t}\n\tmemset(log_buffer, '\\0', CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP_LOG_SIZE);\n\tlog_len = 0;\n\tdump_enable= true;\n#endif\n\tIOT_INFO(\"httpd_init done\");\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":481,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"265733":{"score":0.5374267,"function_name":"iot_easysetup_deinit","code":"void iot_easysetup_deinit(struct iot_context *ctx)\n{\n\tENTER();\n\tif (!ctx || !ctx-\u003ees_httpd_handle)\n\t\treturn;\n\thttpd_deinit(ctx-\u003ees_httpd_handle);\n\tctx-\u003ees_httpd_handle = NULL;\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP_LOG_SUPPORT)\n\tdump_enable = false;\n\tfree(log_buffer);\n#endif\n\tfree(http_post_payload);\n\thttp_post_payload = NULL;\n\tIOT_INFO(\"httpd_deinit done\");\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":520,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"265962":{"score":0.9196682,"function_name":"process_accepted_connection","code":"static int process_accepted_connection(HTTP_CONN_H *handle)\n{\n\tchar rx_buffer[RX_BUFFER_MAX];\n\tiot_error_t err = IOT_ERROR_NONE;\n\tsize_t content_len = 0;\n\tchar *payload;\n\tint type, cmd;\n\tssize_t len;\n\n\thttp_try_configure_connection(handle);\n\n\twhile (1)\n\t{\n\t\tsize_t received_len = 0;\n\t\tsize_t tx_buffer_len = 0;\n\t\tsize_t http_request_header_len = 0;\n\n\t\t// start to process one http request\n\t\tmemset(rx_buffer, '\\0', sizeof(rx_buffer));\n\n\t\terr = http_packet_read(handle, rx_buffer, sizeof(rx_buffer), \u0026received_len, \u0026http_request_header_len);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tif (!is_es_http_deinit_processing() \u0026\u0026 err != IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED) {\n\t\t\t\tIOT_ERROR(\"failed to read http packet %d\", err);\n\t\t\t}\n\t\t\treturn err;\n\t\t}\n\n\t\tcontent_len = 0;\n\t\terr = es_msg_parser(rx_buffer, sizeof(rx_buffer), \u0026payload, \u0026cmd, \u0026type, \u0026content_len);\n\n\t\tif ((err == IOT_ERROR_NONE) \u0026\u0026 (type == D2D_POST)\n\t\t\t\t\u0026\u0026 payload \u0026\u0026 (content_len \u003e strlen((char *)payload)))\n\t\t{\n\t\t\tiot_error_t ret;\n\t\t\tret = http_packet_read_remaining(handle, rx_buffer, sizeof(rx_buffer), received_len, http_request_header_len + content_len);\n\t\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to read remaining http packet %d\", ret);\n\t\t\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t\tpayload = rx_buffer + http_request_header_len;\n\t\t}\n\n\t\tif(err != IOT_ERROR_NONE) {\n\t\t\thttp_msg_handler(cmd, \u0026tx_buffer, D2D_ERROR, payload);\n\t\t}\n\t\telse {\n\t\t\thttp_msg_handler(cmd, \u0026tx_buffer, type, payload);\n\t\t}\n\n\t\tif (!tx_buffer) {\n\t\t\tIOT_ERROR(\"tx_buffer is NULL\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t}\n\n\t\ttx_buffer_len = strlen((char *)tx_buffer);\n\t\ttx_buffer[tx_buffer_len] = 0;\n\n\t\tlen = http_packet_send(handle, tx_buffer, tx_buffer_len);\n\t\tfree(tx_buffer);\n\t\ttx_buffer = NULL;\n\t\tif (len \u003c 0) {\n\t\t\tIOT_ERROR(\"Error is occurred during sending: errno %d\", errno);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_SEND_FAIL, errno);\n\t\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_httpd.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"266836":{"score":0.90693355,"function_name":"es_tcp_task","code":"static void es_tcp_task(void *pvParameters)\n{\n\tiot_error_t err;\n\n\twhile (!is_es_http_deinit_processing()) {\n\t\terr = http_initialize_connection(\u0026es_http_conn_handle);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (1) {\n\t\t\terr = http_accept_connection(\u0026es_http_conn_handle);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tif (!is_es_http_deinit_processing()) {\n\t\t\t\t\tIOT_ERROR(\"Unable to accept connection: errno %d\", errno);\n\t\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_ACCEPT_FAIL, errno);\n\t\t\t\t\tIOT_ERROR(\"accept failed %d\", err);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = process_accepted_connection(\u0026es_http_conn_handle);\n\t\t\tif (!is_es_http_deinit_processing() \u0026\u0026 (err == IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED))\n\t\t\t{\n\t\t\t\thttp_cleanup_accepted_connection(\u0026es_http_conn_handle);\n\t\t\t}\n\t\t}\n\n\t\t//sock resources should be clean\n\t\tif (!is_es_http_deinit_processing()) {\n\t\t\thttp_cleanup_all_connection(\u0026es_http_conn_handle);\n\t\t}\n\t}\n\n\tif (!is_es_http_deinit_processing()) {\n\t\thttp_cleanup_all_connection(\u0026es_http_conn_handle);\n\t}\n\n\t/*set es_tcp_task_handle to null, prevent duplicate delete in es_tcp_deinit*/\n\tes_tcp_task_handle = NULL;\n\tiot_os_thread_delete(NULL);\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_httpd.c","line_number":112,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"267307":{"score":0.9057852,"function_name":"es_http_deinit","code":"void es_http_deinit(void)\n{\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_TCP_DEINIT, 0);\n\n\tes_http_deinit_processing_set(true);\n\t//sock resources should be clean\n\thttp_cleanup_all_connection(\u0026es_http_conn_handle);\n\n\tif (es_tcp_task_handle) {\n\t\tiot_os_thread_delete(es_tcp_task_handle);\n\t\tes_tcp_task_handle = NULL;\n\t}\n\n\tif (tx_buffer) {\n\t\tfree(tx_buffer);\n\t\ttx_buffer = NULL;\n\t}\n\n\tes_http_deinit_processing_set(false);\n\tIOT_INFO(\"http tcp deinit complete!\");\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_TCP_DEINIT, 1);\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_httpd.c","line_number":165,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"267983":{"score":0.8162148,"function_name":"mqtt_reg_sub_cb","code":"static void mqtt_reg_sub_cb(st_mqtt_msg *md, void *userData)\n{\n\tstruct iot_context *ctx = (struct iot_context *)userData;\n\tstruct iot_registered_data *reged_data = \u0026ctx-\u003eiot_reg_data;\n\tchar * mqtt_payload = md-\u003epayload;\n\tchar * registered_msg = NULL;\n\tJSON_H *json = NULL;\n\tJSON_H *item = NULL;\n\tJSON_H *event = NULL;\n\tJSON_H *cur_time = NULL;\n\tJSON_H *dip_key = NULL;\n\tJSON_H *dip_item = NULL;\n\tchar time_str[11] = {0,};\n\tchar *svr_did_str = NULL;\n\tenum iot_command_type iot_cmd;\n\tstruct iot_dip_data *reged_dip = NULL;\n\tstruct iot_uuid *reged_location = NULL;\n\tiot_error_t err;\n\n\t/*parsing mqtt_payload*/\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tchar *payload_json = NULL;\n\tsize_t payload_json_len = 0;\n\n\terr = iot_serialize_cbor2json((uint8_t *)mqtt_payload,\n\t\t\t(size_t)md-\u003epayloadlen,\n\t\t\t\u0026payload_json, \u0026payload_json_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_serialize_cbor2json = %d\", err);\n\t\tgoto reg_sub_out;\n\t}\n\n\tif ((payload_json == NULL) || (payload_json_len == 0)) {\n\t\tIOT_ERROR(\"cbor2json failed (json buffer is null)\");\n\t\tgoto reg_sub_out;\n\t}\n\n\tjson = JSON_PARSE(payload_json);\n\tfree(payload_json);\n#else\n\tjson = JSON_PARSE(mqtt_payload);\n#endif\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"mqtt_payload(%s) parsing failed\", mqtt_payload);\n\t\tgoto reg_sub_out;\n\t}\n\n\tregistered_msg = JSON_PRINT(json);\n\tif (registered_msg == NULL) {\n\t\tIOT_ERROR(\"There are no registered msg, payload : %s\", mqtt_payload);\n\t\tgoto reg_sub_out;\n\t}\n\tIOT_INFO(\"Registered MSG : %s\", registered_msg);\n\n\tevent = JSON_GET_OBJECT_ITEM(json, \"event\");\n\tif (event != NULL) {\n\t\tif (!strncmp(event-\u003evaluestring, \"expired.jwt\", 11)) {\n\t\t\tcur_time = JSON_GET_OBJECT_ITEM(json, \"currentTime\");\n\t\t\tif (cur_time == NULL) {\n\t\t\t\tIOT_ERROR(\"%s : there is no currentTime in json, mqtt_payload : \\n%s\",\n\t\t\t\t\t__func__, mqtt_payload);\n\t\t\t\tgoto reg_sub_out;\n\t\t\t}\n\n\t\t\tsnprintf(time_str, sizeof(time_str), \"%d\", cur_time-\u003evalueint);\n\t\t\tIOT_INFO(\"Set SNTP with current time %s\", time_str);\n\t\t\tiot_bsp_system_set_time_in_sec(time_str);\n\n\t\t\tiot_cmd = IOT_COMMAND_CLOUD_REGISTERING;\n\t\t\tif (iot_command_send(ctx, iot_cmd, NULL, 0) != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Cannot send cloud registering cmd!!\");\n\t\t\t}\n\t\t} else if (!strncmp(event-\u003evaluestring, \"error\", 5)) {\n\t\t\tbool reboot;\n\t\t\treboot = true;\n\t\t\tiot_command_send(ctx, IOT_COMMAND_SELF_CLEANUP, \u0026reboot, sizeof(bool));\n\t\t\tgoto reg_sub_out;\n\t\t} else {\n\t\t\tIOT_ERROR(\"event type %s is not defined\", event-\u003evaluestring);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t}\n\n\t/* dip_key is optional values */\n\tdip_key =JSON_GET_OBJECT_ITEM(json, \"deviceIntegrationProfileKey\");\n\tif (dip_key != NULL) {\n\t\treged_dip = iot_os_malloc(sizeof(struct iot_dip_data));\n\t\tif (!reged_dip) {\n\t\t\tIOT_ERROR(\"Can't alloc iot_dip_data!!\");\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t\tmemset(reged_dip, 0, sizeof(struct iot_dip_data));\n\n\t\tdip_item = JSON_GET_OBJECT_ITEM(dip_key, \"id\");\n\t\tif (!dip_item) {\n\t\t\tIOT_ERROR(\"Can't find id for dip_key!!\");\n\t\t\tiot_os_free(reged_dip);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\terr = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(dip_item),\n\t\t\t\t\u0026reged_dip-\u003edip_id);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", err);\n\t\t\tiot_os_free(reged_dip);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\tdip_item = JSON_GET_OBJECT_ITEM(dip_key, \"majorVersion\");\n\t\tif (!dip_item) {\n\t\t\tIOT_ERROR(\"Can't find majorVersion for dip_key!!\");\n\t\t\tiot_os_free(reged_dip);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t\treged_dip-\u003edip_major_version = dip_item-\u003evalueint;\n\n\t\t/* minorVersion is optional, default 0 */\n\t\tdip_item = JSON_GET_OBJECT_ITEM(dip_key, \"minorVersion\");\n\t\tif (dip_item) {\n\t\t\treged_dip-\u003edip_minor_version = dip_item-\u003evalueint;\n\t\t}\n\n\t\tif (reged_data-\u003edip)\n\t\t\tiot_os_free(reged_data-\u003edip);\n\n\t\treged_data-\u003edip = reged_dip;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(json, \"locationId\");\n\tif (item != NULL) {\n\t\treged_location = iot_os_malloc(sizeof(struct iot_uuid));\n\t\tif (!reged_location) {\n\t\t\tIOT_ERROR(\"Can't alloc iot_uuid for location!!\");\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t\tmemset(reged_location, 0, sizeof(struct iot_uuid));\n\n\t\terr = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\treged_location);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", err);\n\t\t\tiot_os_free(reged_location);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\tif (reged_data-\u003elocationId)\n\t\t\tiot_os_free(reged_data-\u003elocationId);\n\n\t\treged_data-\u003elocationId = reged_location;\n\t} else {\n\t\tIOT_WARN(\"Server does not send locationId!!\");\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(json, \"deviceId\");\n\tif (item != NULL \u0026\u0026 !reged_data-\u003eupdated) {\n\t\tsvr_did_str = JSON_PRINT(item);\n\t\tif (svr_did_str == NULL) {\n\t\t\tIOT_ERROR(\"Can't print server's did str!!\");\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\tmemset(reged_data-\u003edeviceId, 0, IOT_REG_UUID_STR_LEN + 1);\n\t\t/* svr_did_str has/included [\"] also - \"xxxxx-xxxx-xxx\" */\n\t\tmemcpy(reged_data-\u003edeviceId, (svr_did_str + 1), IOT_REG_UUID_STR_LEN);\n\n\t\treged_data-\u003eupdated = true;\n\t\treged_data-\u003enew_reged = false;\n\n\t\tiot_cmd = IOT_COMMAND_CLOUD_REGISTERED;\n\t\tif (iot_command_send(ctx, iot_cmd, NULL, 0) != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Cannot send cloud registered cmd!!\");\n\t\t}\n\t}\n\nreg_sub_out:\n\tif (svr_did_str != NULL)\n\t\tfree(svr_did_str);\n\n\tif (registered_msg != NULL)\n\t\tfree(registered_msg);\n\n\tif (json != NULL)\n\t\tJSON_DELETE(json);\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":40,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"269845":{"score":0.8647829,"function_name":"_iot_mqtt_registration_client_callback","code":"STATIC_FUNCTION\nvoid _iot_mqtt_registration_client_callback(st_mqtt_event event, void *event_data, void *user_data)\n{\n\tswitch (event) {\n\t\tcase ST_MQTT_EVENT_MSG_DELIVERED:\n\t\t\t{\n\t\t\t\tst_mqtt_msg *md = event_data;\n\t\t\t\tif (!strncmp(md-\u003etopic, IOT_SUB_TOPIC_REGISTRATION_PREFIX, IOT_SUB_TOPIC_REGISTRATION_PREFIX_SIZE)) {\n\t\t\t\t\tmqtt_reg_sub_cb(md, user_data);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"No msg delivery handler for %s\", md-\u003etopic);\n\t\t\t\t}\n\t\t\t\tIOT_DEBUG(\"raw msg (len:%d) : %s\", md-\u003epayloadlen, md-\u003epayload);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tIOT_WARN(\"No MQTT event handler for %d\", event);\n\t\t\tbreak;\n\t}\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":225,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"270022":{"score":0.81890774,"function_name":"_iot_parse_sequence_num","code":"STATIC_FUNCTION\nint _iot_parse_sequence_num(char *payload)\n{\n\tJSON_H *json = NULL;\n\tJSON_H *device_events = NULL;\n\tJSON_H *first_event = NULL;\n\tJSON_H *provider_data = NULL;\n\tJSON_H *sequence_number = NULL;\n\tint seq_num = 0;\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tchar *payload_json = NULL;\n\tsize_t payload_json_len = 0;\n\n\tif (iot_serialize_cbor2json((uint8_t *)payload, strlen(payload), \u0026payload_json, \u0026payload_json_len)) {\n\t\tIOT_ERROR(\"cbor2json failed\");\n\t\treturn 0;\n\t}\n\n\tif ((payload_json == NULL) || (payload_json_len == 0)) {\n\t\tIOT_ERROR(\"json buffer is null\");\n\t\treturn 0;\n\t}\n\n\tjson = JSON_PARSE(payload_json);\n\tfree(payload_json);\n#else\n\tjson = JSON_PARSE(payload);\n#endif\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"Cannot parse by json\");\n\t\treturn 0;\n\t}\n\n\tdevice_events = JSON_GET_OBJECT_ITEM(json, \"deviceEvents\");\n\tif (device_events == NULL) {\n\t\tIOT_ERROR(\"there is no events in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tfirst_event = JSON_GET_CHILD_ITEM(device_events);\n\tif (first_event == NULL) {\n\t\tIOT_ERROR(\"there is no event in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tprovider_data = JSON_GET_OBJECT_ITEM(first_event, \"providerData\");\n\tif (provider_data == NULL) {\n\t\tIOT_ERROR(\"there is no provider_data in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tsequence_number = JSON_GET_OBJECT_ITEM(provider_data, \"sequenceNumber\");\n\tif (sequence_number == NULL) {\n\t\tIOT_ERROR(\"there is no sequence number in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tseq_num = JSON_GET_NUMBER_VALUE(sequence_number);\nout:\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn seq_num;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":246,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"270502":{"score":0.9004894,"function_name":"_iot_mqtt_signin_client_callback","code":"STATIC_FUNCTION\nvoid _iot_mqtt_signin_client_callback(st_mqtt_event event, void *event_data, void *user_data)\n{\n\tstruct iot_context *ctx = (struct iot_context *)user_data;\n\n\tswitch (event) {\n\t\tcase ST_MQTT_EVENT_MSG_DELIVERED:\n\t\t\t{\n\t\t\t\tst_mqtt_msg *md = event_data;\n\t\t\t\tchar *mqtt_payload = md-\u003epayload;\n\t\t\t\tif (!strncmp(md-\u003etopic, IOT_SUB_TOPIC_COMMAND_PREFIX, IOT_SUB_TOPIC_COMMAND_PREFIX_SIZE)) {\n\t\t\t\t\tiot_cap_sub_cb(ctx-\u003ecap_handle_list, mqtt_payload);\n\t\t\t\t} else if (!strncmp(md-\u003etopic, IOT_SUB_TOPIC_NOTIFICATION_PREFIX, IOT_SUB_TOPIC_NOTIFICATION_PREFIX_SIZE)) {\n\t\t\t\t\tiot_noti_sub_cb(ctx, mqtt_payload);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"No msg delivery handler for %s\", md-\u003etopic);\n\t\t\t\t}\n\t\t\t\tIOT_DEBUG(\"raw msg (len:%d) : %s\", md-\u003epayloadlen, mqtt_payload);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_MQTT_EVENT_PUBLISH_FAILED:\n\t\t\t{\n\t\t\t\tst_mqtt_msg *md = event_data;\n\t\t\t\tchar *mqtt_payload = md-\u003epayload;\n\t\t\t\tiot_noti_data_t noti_data;\n\n\t\t\t\tnoti_data.type = IOT_NOTI_TYPE_SEND_FAILED;\n\t\t\t\tnoti_data.raw.send_fail.failed_sequence_num = _iot_parse_sequence_num(mqtt_payload);\n\n\t\t\t\tif (noti_data.raw.send_fail.failed_sequence_num \u003c 0) {\n\t\t\t\t\tIOT_ERROR(\"No sequence number\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiot_command_send(ctx, IOT_COMMAND_NOTIFICATION_RECEIVED,\n\t\t\t\t\t\u0026noti_data, sizeof(noti_data));\n\t\t\t\tIOT_DEBUG(\"raw msg (len:%d) : %s\", md-\u003epayloadlen, mqtt_payload);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIOT_WARN(\"No MQTT event handler for %d\", event);\n\t\t\tbreak;\n\t}\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":311,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"270926":{"score":0.88716024,"function_name":"_iot_es_mqtt_registration_json","code":"STATIC_FUNCTION\nvoid *_iot_es_mqtt_registration_json(struct iot_context *ctx,\n\t\t\tchar *dip_id, size_t *msglen, bool self_reged)\n{\n\tstruct iot_devconf_prov_data *devconf;\n\tstruct iot_device_info *dev_info;\n\tstruct timeval tv = {0,};\n\tJSON_H *root = NULL;\n\tJSON_H *dip_key = NULL;\n\tchar *payload = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"ctx is null\");\n\t\treturn NULL;\n\t}\n\tdev_info = \u0026(ctx-\u003edevice_info);\n\n\tdevconf = \u0026ctx-\u003edevconf;\n\tif ((self_reged == false) \u0026\u0026 !devconf-\u003ehashed_sn) {\n\t\tIOT_ERROR(\"There are no hashed_sn\");\n\t\treturn NULL;\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"failed to create json\");\n\t\treturn NULL;\n\t}\n\n\t/* location id is optional value */\n\tif (ctx-\u003eprov_data.cloud.location) {\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"locationId\",\n\t\tJSON_CREATE_STRING(ctx-\u003eprov_data.cloud.location));\n\t} else if (self_reged == true) {\n\t\t/* But location is mandatory for self-registration */\n\t\tIOT_ERROR(\"There is no location for self-registration!!\");\n\t\tJSON_DELETE(root);\n\t\treturn NULL;\n\t}\n\n\t/* label is optional value */\n\tif (ctx-\u003eprov_data.cloud.label) {\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"label\",\n\t\t\tJSON_CREATE_STRING(ctx-\u003eprov_data.cloud.label));\n\t} else {\n\t\tIOT_WARN(\"There is no label for registration\");\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"mnId\",\n\t\tJSON_CREATE_STRING(devconf-\u003emnid));\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"vid\",\n\t\tJSON_CREATE_STRING(devconf-\u003evid));\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"deviceTypeId\",\n\t\tJSON_CREATE_STRING(devconf-\u003edevice_type));\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"lookupId\",\n\t\tJSON_CREATE_STRING(ctx-\u003elookup_id));\n\n\tif (ctx-\u003eprov_data.cloud.room \u0026\u0026 (self_reged == false)) {\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"roomId\",\n\t\t\tJSON_CREATE_STRING(ctx-\u003eprov_data.cloud.room));\n\t} else if (self_reged == false) {\n\t\t/* Do not send serialHash \u0026 provisioningTs for self-registration */\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"serialHash\",\n\t\t\tJSON_CREATE_STRING(devconf-\u003ehashed_sn));\n\n\t\tgettimeofday(\u0026tv, NULL);\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"provisioningTs\",\n\t\t\tJSON_CREATE_NUMBER(tv.tv_sec));\n\t}\n\n\t/* Add optional information if it available */\n\tif (dev_info-\u003eopt_info) {\n\t\t/* firmwareVersion is mandatory on the device_info */\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"firmwareVersion\",\n\t\t\tJSON_CREATE_STRING(dev_info-\u003efirmware_version));\n\n\t\tif (dev_info-\u003emodel_number) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"modelNumber\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emodel_number));\n\t\t}\n\n\t\tif (dev_info-\u003emarketing_name) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"marketingName\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emarketing_name));\n\t\t}\n\n\t\tif (dev_info-\u003emanufacturer_name) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"manufacturerName\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emanufacturer_name));\n\t\t}\n\n\t\tif (dev_info-\u003emanufacturer_code) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"manufacturerCode\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emanufacturer_code));\n\t\t}\n\n\t\tif (iot_os_get_os_name()) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"osType\",\n\t\t\t\tJSON_CREATE_STRING(iot_os_get_os_name()));\n\t\t}\n\n\t\tif (iot_os_get_os_version_string()) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"osVersion\",\n\t\t\t\tJSON_CREATE_STRING(iot_os_get_os_version_string()));\n\t\t}\n\n\t\t/* STDK release version */\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"stdkVersion\",\n\t\t\tJSON_CREATE_STRING(STDK_VERSION_STRING));\n\t}\n\n\t/* dip is optional values */\n\tif (dip_id) {\n\t\tdip_key = JSON_CREATE_OBJECT();\n\t\tif (!dip_key) {\n\t\t\tIOT_WARN(\"Can't create dip_key obj\");\n\t\t\tgoto exit_json_making;\n\t\t}\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(dip_key, \"id\",\n\t\t\tJSON_CREATE_STRING(dip_id));\n\n\t\tJSON_ADD_NUMBER_TO_OBJECT(dip_key,\n\t\t\t\"majorVersion\", devconf-\u003edip-\u003edip_major_version);\n\n\t\tJSON_ADD_NUMBER_TO_OBJECT(dip_key,\n\t\t\t\"minorVersion\", devconf-\u003edip-\u003edip_minor_version);\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(root,\n\t\t\t\"deviceIntegrationProfileKey\", dip_key);\n\t}\n\nexit_json_making:\n\tpayload = JSON_PRINT(root);\n\n\t*msglen = strlen(payload);\n\n\tJSON_DELETE(root);\n\n\n\treturn (void *)payload;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":532,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"272501":{"score":0.8909947,"function_name":"_iot_es_mqtt_registration","code":"iot_error_t _iot_es_mqtt_registration(struct iot_context *ctx, st_mqtt_client mqtt_ctx)\n{\n\tint ret;\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tst_mqtt_msg msg;\n\tsize_t str_id_len = 40;\n\tchar *dip_id = NULL;\n\tsize_t msglen = 0;\n\n\tif (!mqtt_ctx) {\n\t\tIOT_ERROR(\"There is no iot_mqtt_ctx!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\t/* Step 2. Publish target's registration info to server */\n\tctx-\u003eiot_reg_data.updated = false;\n\n\t/* dip id is optional value */\n\tif (ctx-\u003edevconf.dip) {\n\t\tdip_id = (char *)malloc(str_id_len);\n\t\tif (!dip_id) {\n\t\t\tIOT_ERROR(\"malloc failed for DIP id\");\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto failed_regist;\n\t\t}\n\t\tmemset(dip_id, 0, str_id_len);\n\n\t\tiot_err = iot_util_convert_uuid_str(\u0026ctx-\u003edevconf.dip-\u003edip_id,\n\t\t\t\t\tdip_id, str_id_len);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"%s error DIP_id convt (%d)\", __func__, iot_err);\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t\tgoto failed_regist;\n\t\t}\n\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tmsg.payload = _iot_es_mqtt_registration_cbor(ctx, dip_id, \u0026msglen,\n\t\t\t\t\tctx-\u003eiot_reg_data.self_reged);\n#else\n\tmsg.payload = _iot_es_mqtt_registration_json(ctx, dip_id, \u0026msglen,\n\t\t\t\t\tctx-\u003eiot_reg_data.self_reged);\n#endif\n\tif (!msg.payload) {\n\t\tIOT_ERROR(\"Failed to make payload for MQTTpub\");\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t} else {\n\t\tIOT_DEBUG(\"publish resource payload : \\n%s\", msg.payload);\n\n\t\tmsg.qos = st_mqtt_qos1;\n\t\tmsg.retained = false;\n\t\tmsg.payloadlen = (int)msglen;\n\t\tmsg.topic = IOT_PUB_TOPIC_REGISTRATION;\n\n\t\tret = st_mqtt_publish(mqtt_ctx, \u0026msg);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"error MQTTpub(%d)\", ret);\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\t\tfree(msg.payload);\n#else\n\t\tJSON_FREE(msg.payload);\n#endif\n\t}\n\nfailed_regist:\n\tif (dip_id)\n\t\tfree(dip_id);\n\n\treturn iot_err;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":680,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"273094":{"score":0.85427487,"function_name":"_iot_es_mqtt_disconnect","code":"void _iot_es_mqtt_disconnect(struct iot_context *ctx, st_mqtt_client target_cli)\n{\n\tint ret;\n\n#if defined(STDK_MQTT_TASK)\n\tst_mqtt_endtask(target_cli);\n#endif\n\n\t/* Internal MQTT connection was disconnected,\n\t * even if it returns errors\n\t */\n\tret = st_mqtt_disconnect(target_cli);\n\tif (ret) {\n\t\tIOT_WARN(\"Disconnect error(%d)\", ret);\n\t}\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":754,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"273183":{"score":0.8912056,"function_name":"_iot_es_mqtt_connect","code":"iot_error_t _iot_es_mqtt_connect(struct iot_context *ctx, st_mqtt_client target_cli,\n\t\tchar *username, char *sign_data)\n{\n\tst_mqtt_connect_data conn_data = st_mqtt_connect_data_initializer;\n\tst_mqtt_broker_info_t broker_info;\n\tint ret;\n\tiot_error_t iot_ret = IOT_ERROR_NONE;\n\tbool reboot;\n\tchar client_id[IOT_REG_UUID_STR_LEN + 1] = {0, };\n\tstruct iot_cloud_prov_data *cloud_prov;\n\tchar *root_cert = NULL;\n\tsize_t root_cert_len;\n\n\t/* Use mac based random client_id for GreatGate */\n\tiot_ret = iot_get_random_id_str(client_id, sizeof(client_id));\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Cannot get random_id for client_id\");\n\t\treturn iot_ret;\n\t}\n\n\tcloud_prov = \u0026ctx-\u003eprov_data.cloud;\n\tif (!cloud_prov-\u003ebroker_url) {\n\t\tIOT_ERROR(\"cloud_prov_data url does not exist!\");\n\t\tiot_ret = IOT_ERROR_INVALID_ARGS;\n\t\tgoto done_mqtt_connect;\n\t}\n\n\tiot_ret = iot_nv_get_certificate(IOT_SECURITY_CERT_ID_ROOT_CA, \u0026root_cert, \u0026root_cert_len);\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get root cert\");\n\t\tgoto done_mqtt_connect;\n\t}\n\n\tbroker_info.url = cloud_prov-\u003ebroker_url;\n\tbroker_info.port = cloud_prov-\u003ebroker_port;\n\tbroker_info.ca_cert = (const unsigned char *)root_cert;\n\tbroker_info.ca_cert_len = root_cert_len;\n\tbroker_info.ssl = 1;\n\n\tIOT_INFO(\"url: %s, port: %d\", cloud_prov-\u003ebroker_url, cloud_prov-\u003ebroker_port);\n\n\tconn_data.clientid  = client_id;\n\tconn_data.username  = username;\n\tconn_data.password  = sign_data;\n\n\tIOT_INFO(\"mqtt connect,\\nid : %s\\nusername : %s\\npassword : %s\",\n\t\t conn_data.clientid,\n\t\t conn_data.username,\n\t\t conn_data.password);\n\n\tret = st_mqtt_connect(target_cli, \u0026broker_info, \u0026conn_data);\n\tif (ret) {\n\t\tIOT_ERROR(\"%s error(%d)\", __func__, ret);\n\t\tswitch (ret) {\n\t\tcase E_ST_MQTT_UNNACCEPTABLE_PROTOCOL:\n\t\t\t/* fall through */\n\t\tcase E_ST_MQTT_SERVER_UNAVAILABLE:\n\t\t\t/* This case means Server can't start service for MQTT Things\n\t\t\t * This case is totally server-side issue, so we just report it to Apps\n\t\t\t */\n\t\t\tctx-\u003emqtt_connect_critical_reject_count = 0;\n\t\t\tiot_ret = IOT_ERROR_MQTT_SERVER_UNAVAIL;\n\t\t\tbreak;\n\n\t\tcase E_ST_MQTT_CLIENTID_REJECTED:\n\t\t\t/* fall through */\n\t\tcase E_ST_MQTT_BAD_USERNAME_OR_PASSWORD:\n\t\t\t/* fall through */\n\t\tcase E_ST_MQTT_NOT_AUTHORIZED:\n\t\t\t/* These cases are related to device's clientID, serialNumber, deviceId \u0026 web token\n\t\t\t * So we try to cleanup all data \u0026 reboot\n\t\t\t */\n\t\t\tif (ctx-\u003emqtt_connect_critical_reject_count++ \u003c IOT_MQTT_CONNECT_CRITICAL_REJECT_MAX) {\n\t\t\t\tIOT_WARN(\"MQTT critical reject retry %d\", ctx-\u003emqtt_connect_critical_reject_count);\n\t\t\t\tiot_ret = IOT_ERROR_MQTT_CONNECT_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tIOT_WARN(\"Rejected by Server!! cleanup all \u0026 reboot\");\n\n\t\t\treboot = true;\n\t\t\tiot_command_send(ctx, IOT_COMMAND_SELF_CLEANUP, \u0026reboot, sizeof(bool));\n\t\t\tiot_ret = IOT_ERROR_MQTT_REJECT_CONNECT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* On the others, we can't narrow down the causes. Some cases are related to\n\t\t\t * network conditions (outside of the device) or, related to WIFI conditions\n\t\t\t * (inside of the device). So we try to do re-connecting limitedly\n\t\t\t */\n\t\t\tctx-\u003emqtt_connect_critical_reject_count = 0;\n\t\t\tiot_ret = IOT_ERROR_MQTT_CONNECT_FAIL;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tctx-\u003emqtt_connect_critical_reject_count = 0;\n\t}\n\n#if defined(STDK_MQTT_TASK)\n\tif ((ret = st_mqtt_starttask(target_cli)) \u003c 0) {\n\t\tIOT_ERROR(\"Returned code from start tasks is %d\", ret);\n\t\tst_mqtt_disconnect(target_cli);\n\t\tiot_ret = IOT_ERROR_MQTT_CONNECT_FAIL;\n\t\tgoto done_mqtt_connect;\n\t} else {\n\t\tIOT_INFO(\"Use MQTTStartTask\");\n\t}\n#endif\n\ndone_mqtt_connect:\n\tif (root_cert)\n\t\tfree((void *)root_cert);\n\n\treturn iot_ret;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":771,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"274192":{"score":0.8707485,"function_name":"iot_es_connect","code":"iot_error_t iot_es_connect(struct iot_context *ctx, int conn_type)\n{\n\tiot_security_buffer_t token_buf = { 0 };\n\tiot_wt_params_t wt_params = { 0 };\n\tst_mqtt_client mqtt_cli = NULL;\n\tchar *topicfilter = NULL;\n\tiot_error_t iot_ret;\n\tint ret;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (ctx-\u003erate_limit) {\n\t\tif (!(iot_os_timer_isexpired(ctx-\u003erate_limit_timeout))) {\n\t\t\tunsigned int remaining_time = iot_os_timer_left_ms(ctx-\u003erate_limit_timeout);\n\t\t\tIOT_WARN(\"Server rate limit break times.. please wait %d seconds to connect\", remaining_time/1000);\n\t\t\tiot_os_delay(remaining_time);\n\t\t}\n\t}\n\tctx-\u003erate_limit = false;\n\n\tiot_ret = iot_nv_get_serial_number((char **)\u0026wt_params.sn, \u0026wt_params.sn_len);\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get serial num\");\n\t\tgoto out;\n\t}\n\n\twt_params.mnid = iot_os_strdup(ctx-\u003edevconf.mnid);\n\tif (!wt_params.mnid) {\n\t\tIOT_ERROR(\"failed to strdup for mnid\");\n\t\tgoto out;\n\t} else {\n\t\twt_params.mnid_len = strlen(wt_params.mnid);\n\t}\n\n\tiot_ret = iot_wt_create((const iot_wt_params_t *)\u0026wt_params, \u0026token_buf);\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to make wt-token\");\n\t\tgoto out;\n\t}\n\n\ttopicfilter = malloc(IOT_TOPIC_SIZE);\n\tif (!topicfilter) {\n\t\tIOT_ERROR(\"failed to malloc topicfilter\");\n\t\tiot_ret = IOT_ERROR_MEM_ALLOC;\n\t\tgoto out;\n\t}\n\tif (conn_type == IOT_CONNECT_TYPE_COMMUNICATION) {\n\t\tIOT_INFO(\"connect_type: log-in\");\n\t\t/* Using for new MQTT PUB/SUB connection after registration */\n\t\tif (!ctx-\u003eiot_reg_data.updated) {\n\t\t\tIOT_ERROR(\"failed to get user id\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = st_mqtt_create(\u0026mqtt_cli, _iot_mqtt_signin_client_callback, ctx);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"Cannot create mqtt client\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx-\u003emqtt_connection_try_count++;\n\t\tiot_ret = _iot_es_mqtt_connect(ctx, mqtt_cli, (char *)ctx-\u003eiot_reg_data.deviceId, (char *)token_buf.p);\n\t\tif (iot_ret != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to connect\");\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tctx-\u003emqtt_connection_success_count++;\n\t\t\tIOT_INFO(\"MQTT connect success sucess/try : %d/%d\", ctx-\u003emqtt_connection_success_count, ctx-\u003emqtt_connection_try_count);\n\t\t}\n\n\t\tsnprintf(topicfilter, IOT_TOPIC_SIZE, IOT_SUB_TOPIC_NOTIFICATION, ctx-\u003eiot_reg_data.deviceId);\n\t\tIOT_DEBUG(\"noti subscribe topic : %s\", topicfilter);\n\t\tret = st_mqtt_subscribe(mqtt_cli, topicfilter, st_mqtt_qos1);\n\t\tif (ret) {\n\t\t\tIOT_WARN(\"subscribe error(%d)\", ret);\n\t\t\tiot_ret = IOT_ERROR_BAD_REQ;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsnprintf(topicfilter, IOT_TOPIC_SIZE, IOT_SUB_TOPIC_COMMAND, ctx-\u003eiot_reg_data.deviceId);\n\t\tIOT_DEBUG(\"cmd subscribe topic : %s\", topicfilter);\n\t\tret = st_mqtt_subscribe(mqtt_cli, topicfilter, st_mqtt_qos1);\n\t\tif (ret) {\n\t\t\tIOT_WARN(\"failed cmd sub registration(%d)\", ret);\n\t\t\tiot_ret = IOT_ERROR_BAD_REQ;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx-\u003emqtt_event_topic = malloc(IOT_TOPIC_SIZE);\n\t\tif (!ctx-\u003emqtt_event_topic) {\n\t\t\tIOT_ERROR(\"failed to malloc for mqtt_event_topic\");\n\t\t\tiot_ret = IOT_ERROR_MEM_ALLOC;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\t\tsnprintf(ctx-\u003emqtt_event_topic, IOT_TOPIC_SIZE, IOT_PUB_TOPIC_EVENT, ctx-\u003eiot_reg_data.deviceId);\n\n\t\tctx-\u003eevt_mqttcli = mqtt_cli;\n\t} else {\n\t\tIOT_INFO(\"connect_type: registration\");\n\n\t\tret = st_mqtt_create(\u0026mqtt_cli, _iot_mqtt_registration_client_callback, ctx);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"Cannot create mqtt client\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tiot_ret = _iot_es_mqtt_connect(ctx, mqtt_cli, wt_params.sn, (char *)token_buf.p);\n\t\tif (iot_ret != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to connect\");\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tIOT_INFO(\"MQTT connect success\");\n\t\t}\n\n\t\t/* register notification subscribe for registration */\n\t\tsnprintf(topicfilter, IOT_TOPIC_SIZE, IOT_SUB_TOPIC_REGISTRATION, wt_params.sn);\n\t\tIOT_DEBUG(\"noti subscribe topic : %s\", topicfilter);\n\t\tret = st_mqtt_subscribe(mqtt_cli, topicfilter, st_mqtt_qos1);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"%s error MQTTsub(%d)\", __func__, ret);\n\t\t\tiot_ret = IOT_ERROR_BAD_REQ;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tiot_ret = _iot_es_mqtt_registration(ctx, mqtt_cli);\n\t\tif (iot_ret != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to register\");\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx-\u003ereg_mqttcli = mqtt_cli;\n\t}\n\nout:\n\tif (wt_params.sn)\n\t\tiot_os_free((void *)wt_params.sn);\n\n\tif (wt_params.mnid)\n\t\tiot_os_free((void *)wt_params.mnid);\n\n\tif (token_buf.p)\n\t\tfree(token_buf.p);\n\n\tif (topicfilter)\n\t\tfree(topicfilter);\n\n\tif (iot_ret)\n\t\tst_mqtt_destroy(mqtt_cli);\n\n\treturn iot_ret;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":886,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"276289":{"score":0.8610763,"function_name":"iot_es_disconnect","code":"iot_error_t iot_es_disconnect(struct iot_context *ctx, int conn_type)\n{\n\tst_mqtt_client target_cli = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"There is no ctx!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (conn_type == IOT_CONNECT_TYPE_COMMUNICATION) {\n\t\ttarget_cli = ctx-\u003eevt_mqttcli;\n\t\tif (ctx-\u003emqtt_event_topic)\n\t\t\tfree(ctx-\u003emqtt_event_topic);\n\t\tctx-\u003emqtt_event_topic = NULL;\n\t\tctx-\u003eevt_mqttcli = NULL;\n\t} else {\n\t\ttarget_cli = ctx-\u003ereg_mqttcli;\n\t\tctx-\u003ereg_mqttcli = NULL;\n\t}\n\n\tif (!target_cli) {\n\t\tIOT_ERROR(\"There is no mqtt_ctx!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tIOT_DEBUG(\"disconnect type %s\",\n\t\t(conn_type == IOT_CONNECT_TYPE_REGISTRATION) ?\n\t\t\t\"registration\" : \"communication\");\n\n\t_iot_es_mqtt_disconnect(ctx, target_cli);\n\n\tst_mqtt_destroy(target_cli);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":1046,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"276584":{"score":0.8614374,"function_name":"_iot_security_be_check_context_and_params_is_valid","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_check_context_and_params_is_valid(iot_security_context_t *context, iot_security_sub_system_t sub_system)\n{\n\tif (!context) {\n\t\tIOT_ERROR(\"context is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_PK) {\n\t\tif (!context-\u003epk_params) {\n\t\t\tIOT_ERROR(\"pk params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(PK_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_CIPHER) {\n\t\tif (!context-\u003ecipher_params) {\n\t\t\tIOT_ERROR(\"cipher params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_ECDH) {\n\t\tif (!context-\u003eecdh_params) {\n\t\t\tIOT_ERROR(\"ecdh params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(ECDH_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_STORAGE) {\n\t\tif (!context-\u003estorage_params) {\n\t\t\tIOT_ERROR(\"storage params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":34,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"276931":{"score":0.8387109,"function_name":"_iot_security_be_software_buffer_free","code":"static inline void _iot_security_be_software_buffer_free(iot_security_buffer_t *buffer)\n{\n\tif (buffer) {\n\t\tif (buffer-\u003ep \u0026\u0026 buffer-\u003elen) {\n\t\t\tmemset(buffer-\u003ep, 0, buffer-\u003elen);\n\t\t\tiot_os_free(buffer-\u003ep);\n\t\t}\n\t\tmemset(buffer, 0, sizeof(iot_security_buffer_t));\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":73,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277042":{"score":0.9022094,"function_name":"_iot_security_be_software_buffer_wipe","code":"static inline void _iot_security_be_software_buffer_wipe(const iot_security_buffer_t *input_buf, size_t wiped_len)\n{\n\tif (input_buf \u0026\u0026 (input_buf-\u003elen \u003c wiped_len)) {\n\t\tint i;\n\t\tfor (i = input_buf-\u003elen; i \u003c wiped_len; i++) {\n\t\t\tinput_buf-\u003ep[i] = 0;\n\t\t}\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":84,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277113":{"score":0.8645747,"function_name":"_iot_security_be_software_id_key2storage","code":"static inline iot_security_storage_id_t _iot_security_be_software_id_key2storage(iot_security_key_id_t key_id)\n{\n\tiot_security_storage_id_t storage_id;\n\tconst iot_security_be_key2storage_id_map_t *k2s_id_map_list = key2storage_id_map;\n\tint c2s_id_map_list_len = sizeof(key2storage_id_map) / sizeof(key2storage_id_map[0]);\n\tint i;\n\n\tIOT_DEBUG(\"key id = %d\", key_id);\n\n\tfor (i = 0; i \u003c c2s_id_map_list_len; i++) {\n\t\tif (key_id == k2s_id_map_list[i].key_id) {\n\t\t\tstorage_id = k2s_id_map_list[i].storage_id;\n\t\t\tIOT_DEBUG(\"storage id = %d\", storage_id);\n\t\t\treturn storage_id;\n\t\t}\n\t}\n\n\tIOT_ERROR(\"'%d' is not a supported key id\", key_id);\n\n\treturn IOT_NVD_UNKNOWN;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":105,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277266":{"score":0.84427977,"function_name":"_iot_security_be_software_id_cert2storage","code":"static inline iot_security_storage_id_t _iot_security_be_software_id_cert2storage(iot_security_cert_id_t cert_id)\n{\n\tiot_security_storage_id_t storage_id;\n\tconst iot_security_be_cert2storage_id_map_t *c2s_id_map_list = cert2storage_id_map;\n\tint c2s_id_map_list_len = sizeof(cert2storage_id_map) / sizeof(cert2storage_id_map[0]);\n\tint i;\n\n\tIOT_DEBUG(\"cert id = %d\", cert_id);\n\n\tfor (i = 0; i \u003c c2s_id_map_list_len; i++) {\n\t\tif (cert_id == c2s_id_map_list[i].cert_id) {\n\t\t\tstorage_id = c2s_id_map_list[i].storage_id;\n\t\t\tIOT_DEBUG(\"storage id = %d\", storage_id);\n\t\t\treturn storage_id;\n\t\t}\n\t}\n\n\tIOT_ERROR(\"'%d' is not a supported cert id\", cert_id);\n\n\treturn IOT_NVD_UNKNOWN;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":138,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277422":{"score":0.79249996,"function_name":"_iot_security_be_software_id_check_permission","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_id_check_permission(iot_security_storage_id_t id)\n{\n\tint no_exposed_list_len = sizeof(no_exposed_storage_id_list) / sizeof(no_exposed_storage_id_list[0]);\n\tint i;\n\n\tfor (i = 0; i \u003c no_exposed_list_len; i++) {\n\t\tif (id == no_exposed_storage_id_list[i]) {\n\t\t\tIOT_ERROR(\"'%d' cannot be exposed to apps\", id);\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_NO_PERMISSION, id);\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":164,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277538":{"score":0.64128953,"function_name":"_iot_security_be_software_bsp_fs_load","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_bsp_fs_load(iot_security_context_t *context, iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tconst iot_security_be_bsp_funcs_t *bsp_fn;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (!context-\u003ebe_context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_CONTEXT_NULL, 0);\n\t}\n\n\tbsp_fn = context-\u003ebe_context-\u003ebsp_fn;\n\n\tif (!bsp_fn || !bsp_fn-\u003ebsp_fs_load) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BSP_FN_LOAD_NULL, 0);\n\t}\n\n\terr = bsp_fn-\u003ebsp_fs_load(context-\u003ebe_context, storage_id, output_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":180,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277665":{"score":0.8823143,"function_name":"_iot_security_be_software_pk_load_ed25519_key","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_load_ed25519_key(iot_security_context_t *context, iot_security_key_id_t key_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\tiot_security_buffer_t key_b64_buf = { 0 };\n\tiot_security_buffer_t key_buf = { 0 };\n\tsize_t olen;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_PK);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tstorage_id = _iot_security_be_software_id_key2storage(key_id);\n\tif (storage_id == IOT_NVD_UNKNOWN) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_INVALID_ID, 0);\n\t}\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, \u0026key_b64_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tkey_buf.len = IOT_SECURITY_ED25519_LEN;\n\tkey_buf.p = (unsigned char *) iot_os_malloc(key_buf.len);\n\tif (!key_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for key_buf\");\n\t\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\t/* remove null character for base64 decoding */\n\tif (strlen((char *)key_b64_buf.p) == (key_b64_buf.len - 1)) {\n\t\tkey_b64_buf.len -= 1;\n\t}\n\n\terr = iot_security_base64_decode(key_b64_buf.p, key_b64_buf.len, key_buf.p, key_buf.len, \u0026olen);\n\tif (err) {\n\t\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\t\t_iot_security_be_software_buffer_free(\u0026key_buf);\n\t\treturn err;\n\t}\n\n\tif (olen != key_buf.len) {\n\t\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\t\t_iot_security_be_software_buffer_free(\u0026key_buf);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_KEY_LEN, 0);\n\t}\n\n\t*output_buf = key_buf;\n\n\tIOT_DEBUG(\"key '%d' is loaded %d@%p\", key_id, (int)output_buf-\u003elen, output_buf-\u003ep);\n\n\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":209,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"278206":{"score":0.6799078,"function_name":"_iot_security_be_software_pk_load_ed25519","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_load_ed25519(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t seckey = { 0 };\n\tiot_security_buffer_t pubkey = { 0 };\n\n\terr = _iot_security_be_software_pk_load_ed25519_key(context, IOT_SECURITY_KEY_ID_DEVICE_PRIVATE, \u0026seckey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_pk_load_ed25519_key(context, IOT_SECURITY_KEY_ID_DEVICE_PUBLIC, \u0026pubkey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tcontext-\u003epk_params-\u003etype = IOT_SECURITY_KEY_TYPE_ED25519;\n\tcontext-\u003epk_params-\u003eseckey = seckey;\n\tcontext-\u003epk_params-\u003epubkey = pubkey;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":273,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"278621":{"score":0.6411097,"function_name":"_iot_security_be_software_pk_get_key_type","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_get_key_type(iot_security_context_t *context, iot_security_key_type_t *key_type)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_PK);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t*key_type = context-\u003epk_params-\u003etype;\n\n\tIOT_DEBUG(\"type = %d\", *key_type);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":444,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"278687":{"score":0.667475,"function_name":"_iot_security_be_software_pk_verify_ecdsa","code":"static iot_error_t _iot_security_be_software_pk_verify_ecdsa(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *sig_buf)\n{\n\tiot_error_t err;\n\tiot_security_pk_params_t *pk_params;\n\tmbedtls_x509_crt mbed_x509_crt;\n\tmbedtls_pk_context mbed_pk_context;\n\tmbedtls_md_type_t mbed_md_type;\n\tint ret;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_PK);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buffer is invalid\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!sig_buf || !sig_buf-\u003ep || (sig_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"sig buffer is invalid\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tpk_params = context-\u003epk_params;\n\n\tif (!pk_params-\u003epubkey.p || (pk_params-\u003epubkey.len == 0)) {\n\t\tIOT_ERROR(\"pubkey is invalid\");\n\t\treturn IOT_ERROR_SECURITY_PK_INVALID_PUBKEY;\n\t}\n\n\tIOT_DEBUG(\"input:  %3d@%p\", (int)input-\u003elen, input-\u003ep);\n\tIOT_DEBUG(\"sig:    %3d@%p\", (int)sig-\u003elen, sig-\u003ep);\n\tIOT_DEBUG(\"pubkey: %3d@%p\", (int)pk_params-\u003epubkey.len, pk_params-\u003epubkey);\n\n\tmbed_md_type = MBEDTLS_MD_SHA256;\n\n\tmbedtls_x509_crt_init(\u0026mbed_x509_crt);\n\n\tret = mbedtls_x509_crt_parse(\u0026mbed_x509_crt, (const unsigned char *)pk_params-\u003epubkey.p, pk_params-\u003epubkey.len + 1);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_pk_parse_key = -0x%04X\\n\", -ret);\n\t\terr = IOT_ERROR_SECURITY_PK_PARSEKEY;\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_pk_verify(\u0026mbed_x509_crt.pk, mbed_md_type, input_buf-\u003ep, input_buf-\u003elen, sig_buf-\u003ep, sig_buf-\u003elen);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_pk_verify = -0x%04X\\n\", -ret);\n\t\terr = IOT_ERROR_SECURITY_PK_VERIFY;\n\t\tgoto exit;\n\t}\n\n\tIOT_DEBUG(\"sign verify success\");\n\n\terr = IOT_ERROR_NONE;\nexit:\n\tmbedtls_x509_crt_free(\u0026mbed_x509_crt);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":803,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"279563":{"score":0.7904021,"function_name":"_iot_security_be_software_cipher_deinit","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_cipher_params_t *cipher_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tcipher_params = context-\u003ecipher_params;\n\n\tif (cipher_params-\u003ekey.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026cipher_params-\u003ekey);\n\t}\n\n\tif (cipher_params-\u003eiv.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026cipher_params-\u003eiv);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":899,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"279681":{"score":0.8333868,"function_name":"_iot_security_be_software_cipher_copy_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_copy_params(iot_security_buffer_t *src, iot_security_buffer_t *dst)\n{\n\tif (src-\u003ep) {\n\t\tif (src-\u003elen == 0) {\n\t\t\tIOT_ERROR(\"length of src is zero\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t\t}\n\n\t\tif (dst-\u003ep) {\n\t\t\t_iot_security_be_software_buffer_free(dst);\n\t\t}\n\n\t\tdst-\u003ep = (unsigned char *)iot_os_malloc(src-\u003elen);\n\t\tif (!dst-\u003ep) {\n\t\t\tIOT_ERROR(\"failed to malloc for dst params\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t\t}\n\n\t\tmemcpy(dst-\u003ep, src-\u003ep, src-\u003elen);\n\t\tdst-\u003elen = src-\u003elen;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":923,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"279927":{"score":0.91309315,"function_name":"_iot_security_be_software_cipher_set_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_set_params(iot_security_context_t *context, iot_security_cipher_params_t *cipher_set_params)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!cipher_set_params) {\n\t\tIOT_ERROR(\"cipher set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif ((cipher_set_params-\u003etype \u003e IOT_SECURITY_KEY_TYPE_UNKNOWN) \u0026\u0026\n\t\t(cipher_set_params-\u003etype \u003c IOT_SECURITY_KEY_TYPE_MAX)) {\n\t\tcontext-\u003ecipher_params-\u003etype = cipher_set_params-\u003etype;\n\t}\n\n\terr = _iot_security_be_software_cipher_copy_params(\u0026cipher_set_params-\u003ekey, \u0026context-\u003ecipher_params-\u003ekey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_cipher_copy_params(\u0026cipher_set_params-\u003eiv, \u0026context-\u003ecipher_params-\u003eiv);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":949,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"280154":{"score":0.84515464,"function_name":"_iot_security_be_software_cipher_aes_check_info","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_aes_check_info(iot_security_cipher_params_t *cipher_params, const mbedtls_cipher_info_t *mbed_cipher_info)\n{\n\tif (!cipher_params || !mbed_cipher_info) {\n\t\tIOT_ERROR(\"parameters are null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (cipher_params-\u003ekey.len != (mbed_cipher_info-\u003ekey_bitlen / 8)) {\n\t\tIOT_ERROR(\"key len mismatch, %d != %d\", cipher_params-\u003ekey.len, (mbed_cipher_info-\u003ekey_bitlen / 8));\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_KEY_LEN, (int)cipher_params-\u003ekey.len);\n\t}\n\n\tif (cipher_params-\u003eiv.len != mbed_cipher_info-\u003eiv_size) {\n\t\tIOT_ERROR(\"iv len mismatch, %d != %d\", cipher_params-\u003eiv.len, mbed_cipher_info-\u003eiv_size);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_IV_LEN, (int)cipher_params-\u003eiv.len);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":982,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"280408":{"score":0.809296,"function_name":"_iot_security_be_software_cipher_aes","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_aes(iot_security_context_t *context, iot_security_cipher_mode_t cipher_mode, iot_security_buffer_t *input_buf, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_security_cipher_params_t *cipher_params;\n\tconst mbedtls_cipher_info_t *mbed_cipher_info;\n\tmbedtls_cipher_type_t mbed_cipher_alg;\n\tmbedtls_cipher_context_t mbed_cipher_ctx;\n\tmbedtls_operation_t mbed_op_mode;\n\tsize_t required_len;\n\tsize_t expected_key_len;\n\tint ret;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (cipher_mode == IOT_SECURITY_CIPHER_ENCRYPT) {\n\t\tmbed_op_mode = MBEDTLS_ENCRYPT;\n\t} else if (cipher_mode == IOT_SECURITY_CIPHER_DECRYPT) {\n\t\tmbed_op_mode = MBEDTLS_DECRYPT;\n\t} else {\n\t\tIOT_ERROR(\"'%d' is not a supported cipher mode\", cipher_mode);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_MODE, cipher_mode);\n\t}\n\n\tcipher_params = context-\u003ecipher_params;\n\n\tif (cipher_params-\u003etype == IOT_SECURITY_KEY_TYPE_AES256) {\n\t\tmbed_cipher_alg = MBEDTLS_CIPHER_AES_256_CBC;\n\t\texpected_key_len = IOT_SECURITY_SECRET_LEN;\n\t} else {\n\t\tIOT_ERROR(\"'%d' is not a supported cipher algorithm\", cipher_params-\u003etype);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_ALGO, cipher_params-\u003etype);\n\t}\n\n\tif (!cipher_params-\u003ekey.p || (cipher_params-\u003ekey.len != expected_key_len)) {\n\t\tIOT_ERROR(\"key is invalid %d@%p\", (int)cipher_params-\u003ekey.len, cipher_params-\u003ekey.p);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_KEY, (int)cipher_params-\u003ekey.len);\n\t}\n\n\tif (!cipher_params-\u003eiv.p || (cipher_params-\u003eiv.len != IOT_SECURITY_IV_LEN)) {\n\t\tIOT_ERROR(\"iv is invalid %d@%p\", (int)cipher_params-\u003eiv.len, cipher_params-\u003eiv.p);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_IV, (int)cipher_params-\u003eiv.len);\n\t}\n\n\tIOT_DEBUG(\"input: %3d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\tIOT_DEBUG(\"key:   %3d@%p\", (int)cipher_params-\u003ekey.len, cipher_params-\u003ekey.p);\n\tIOT_DEBUG(\"iv:    %3d@%p\", (int)cipher_params-\u003eiv.len, cipher_params-\u003eiv.p);\n\n\tmbed_cipher_info = mbedtls_cipher_info_from_type(mbed_cipher_alg);\n\tif (!mbed_cipher_info) {\n\t\tIOT_ERROR(\"mbedtls_cipher_info_from_type returned null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_ALGO, 0);\n\t}\n\n\terr = _iot_security_be_software_cipher_aes_check_info(cipher_params, mbed_cipher_info);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tmbedtls_cipher_init(\u0026mbed_cipher_ctx);\n\n\tif (cipher_mode == IOT_SECURITY_CIPHER_ENCRYPT) {\n\t\trequired_len = iot_security_cipher_get_align_size(cipher_params-\u003etype, input_buf-\u003elen);\n\t} else {\n\t\trequired_len = input_buf-\u003elen;\n\t}\n\n\toutput_buf-\u003ep = (unsigned char *)iot_os_malloc(required_len);\n\tif (!output_buf-\u003ep) {\n\t\tIOT_ERROR(\"failed to malloc for output buffer\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tmemset(output_buf-\u003ep, 0, required_len);\n\n\tret = mbedtls_cipher_setup(\u0026mbed_cipher_ctx, mbed_cipher_info);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_setup = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\tret = mbedtls_cipher_setkey(\u0026mbed_cipher_ctx, cipher_params-\u003ekey.p, mbed_cipher_info-\u003ekey_bitlen, mbed_op_mode);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_setup = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\tret = mbedtls_cipher_crypt(\u0026mbed_cipher_ctx, cipher_params-\u003eiv.p, cipher_params-\u003eiv.len,\n\t\t\t\t   (const unsigned char *)input_buf-\u003ep, input_buf-\u003elen, output_buf-\u003ep, \u0026output_buf-\u003elen);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_crypt = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\tif (output_buf-\u003elen \u003e required_len) {\n\t\tIOT_ERROR(\"buffer overflow in cipher '%d' (%d \u003e %d)\", cipher_mode, (int)output_buf-\u003elen, (int)required_len);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_BUF_OVERFLOW;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\t_iot_security_be_software_buffer_wipe(output_buf, required_len);\n\n\tIOT_DEBUG(\"key:   %3d@%p\", (int)cipher_params-\u003ekey.len, cipher_params-\u003ekey.p);\n\n\terr = IOT_ERROR_NONE;\n\tgoto exit;\n\nexit_free_output_buf:\n\t_iot_security_be_software_buffer_free(output_buf);\nexit:\n\tmbedtls_cipher_free(\u0026mbed_cipher_ctx);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1003,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"281846":{"score":0.90126103,"function_name":"_iot_security_be_software_manager_set_key","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_manager_set_key(iot_security_context_t *context, iot_security_key_params_t *key_params)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!key_params) {\n\t\tIOT_ERROR(\"key params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (key_params-\u003ekey_id == IOT_SECURITY_KEY_ID_SHARED_SECRET) {\n\t\tiot_security_cipher_params_t *cipher_params = context-\u003ecipher_params;\n\t\tiot_security_cipher_params_t *cipher_set_params = \u0026key_params-\u003eparams.cipher;\n\n\t\tif (cipher_set_params-\u003ekey.p \u0026\u0026 cipher_set_params-\u003ekey.len) {\n\t\t\tcipher_params-\u003ekey = cipher_set_params-\u003ekey;\n\t\t}\n\n\t\tif (cipher_set_params-\u003eiv.p \u0026\u0026 cipher_set_params-\u003eiv.len) {\n\t\t\tcipher_params-\u003eiv = cipher_set_params-\u003eiv;\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"cannot set key for key index '%d'\", key_params-\u003ekey_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_INVALID_ID, 0);\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1154,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"282118":{"score":0.89948267,"function_name":"_iot_security_be_software_manager_get_key","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_manager_get_key(iot_security_context_t *context, iot_security_key_id_t key_id, iot_security_buffer_t *key_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_NONE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_id = _iot_security_be_software_id_key2storage(key_id);\n\n\terr = _iot_security_be_software_id_check_permission(storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (key_id == IOT_SECURITY_KEY_ID_SHARED_SECRET) {\n\t\tif (!context-\u003ecipher_params) {\n\t\t\tIOT_ERROR(\"cipher params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t\t}\n\n\t\tif (!context-\u003ecipher_params-\u003ekey.p || (context-\u003ecipher_params-\u003ekey.len == 0)) {\n\t\t\tIOT_ERROR(\"shared secret not yet set\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_NOT_FOUND, 0);\n\t\t}\n\n\t\tkey_buf-\u003elen = context-\u003ecipher_params-\u003ekey.len;\n\t\tkey_buf-\u003ep = (unsigned char *)iot_os_malloc(key_buf-\u003elen);\n\t\tif (!key_buf-\u003ep) {\n\t\t\tIOT_ERROR(\"failed to malloc for getting key\");\n\t\t\tkey_buf-\u003elen = 0;\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t\t}\n\t\tmemcpy(key_buf-\u003ep, context-\u003ecipher_params-\u003ekey.p, key_buf-\u003elen);\n\t} else {\n\t\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, key_buf);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1188,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"282543":{"score":0.57181525,"function_name":"_iot_security_be_software_manager_get_certificate","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_manager_get_certificate(iot_security_context_t *context, iot_security_cert_id_t cert_id, iot_security_buffer_t *cert_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_NONE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_id = _iot_security_be_software_id_cert2storage(cert_id);\n\tif (storage_id == IOT_NVD_UNKNOWN) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CERT_INVALID_ID, cert_id);\n\t}\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, cert_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1235,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"282658":{"score":0.8782784,"function_name":"_iot_security_be_software_ecdh_load_ed25519","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_load_ed25519(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\tiot_security_ecdh_params_t *ecdh_params;\n\tiot_security_buffer_t seckey_b64_buf = { 0 };\n\tiot_security_buffer_t seckey_buf = { 0 };\n\tunsigned char *seckey_curve = NULL;\n\tsize_t olen;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_id = IOT_NVD_PRIVATE_KEY;\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, \u0026seckey_b64_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tseckey_buf.len = IOT_SECURITY_ED25519_LEN;\n\tseckey_buf.p = (unsigned char *)iot_os_malloc(seckey_buf.len);\n\tif (!seckey_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for seckey_buf\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_seckey_b64;\n\t}\n\n\t/* remove null character for base64 decoding */\n\tif (strlen((char *)seckey_b64_buf.p) == (seckey_b64_buf.len - 1)) {\n\t\tseckey_b64_buf.len -= 1;\n\t}\n\n\terr = iot_security_base64_decode(seckey_b64_buf.p, seckey_b64_buf.len, seckey_buf.p, seckey_buf.len, \u0026olen);\n\tif (err) {\n\t\tgoto exit_free_seckey;\n\t}\n\n\tif (olen != seckey_buf.len) {\n\t\tIOT_ERROR(\"seckey_len '%d' is not '%d'\", (int)olen, (int)seckey_buf.len);\n\t\terr = IOT_ERROR_SECURITY_PK_KEY_LEN;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_seckey;\n\t}\n\n\tseckey_curve = (unsigned char *)iot_os_malloc(seckey_buf.len);\n\tif (!seckey_curve) {\n\t\tIOT_ERROR(\"failed to malloc for seckey_buf curve\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_seckey;\n\t}\n\n\terr = iot_security_ed25519_convert_seckey(seckey_buf.p, seckey_curve);\n\tif (err) {\n\t\tgoto exit_free_seckey_curve;\n\t}\n\n\tecdh_params = context-\u003eecdh_params;\n\n\tecdh_params-\u003et_seckey.p = seckey_curve;\n\tecdh_params-\u003et_seckey.len = seckey_buf.len;\n\n\terr = IOT_ERROR_NONE;\n\tgoto exit_free_seckey;\n\nexit_free_seckey_curve:\n\tiot_os_free(seckey_curve);\nexit_free_seckey:\n\t_iot_security_be_software_buffer_free(\u0026seckey_buf);\nexit_free_seckey_b64:\n\t_iot_security_be_software_buffer_free(\u0026seckey_b64_buf);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1260,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283284":{"score":0.61921084,"function_name":"_iot_security_be_software_ecdh_init","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_ecdh_load(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1351,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283365":{"score":0.7614151,"function_name":"_iot_security_be_software_ecdh_deinit","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_ecdh_params_t *ecdh_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tecdh_params = context-\u003eecdh_params;\n\n\tif (ecdh_params-\u003et_seckey.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026ecdh_params-\u003et_seckey);\n\t}\n\n\tif (ecdh_params-\u003ec_pubkey.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026ecdh_params-\u003ec_pubkey);\n\t}\n\n\tif (ecdh_params-\u003esalt.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026ecdh_params-\u003esalt);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1369,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283508":{"score":0.79976416,"function_name":"_iot_security_be_software_swap_secret","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_swap_secret(iot_security_buffer_t *src, iot_security_buffer_t *dst)\n{\n\tunsigned char *p;\n\tsize_t len;\n\tint i;\n\n\tif (!src || !src-\u003ep || (src-\u003elen == 0) || !dst) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tlen = src-\u003elen;\n\tp = (unsigned char *)iot_os_malloc(len);\n\n\tif (!p) {\n\t\tIOT_ERROR(\"failed to malloc for swap\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tfor (i = 0; i \u003c len; i++) {\n\t\tp[(len - 1) - i] = src-\u003ep[i];\n\t}\n\n\tdst-\u003ep = p;\n\tdst-\u003elen = len;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1397,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283726":{"score":0.900825,"function_name":"_iot_security_be_software_ecdh_compute_premaster_secret","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_compute_premaster_secret(\n\t\t\tiot_security_buffer_t *t_seckey_buf,\n\t\t\tiot_security_buffer_t *c_pubkey_buf,\n\t\t\tiot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tmbedtls_ecdh_context mbed_ecdh;\n\tmbedtls_ctr_drbg_context mbed_ctr_drbg;\n\tmbedtls_entropy_context mbed_entropy;\n\tmbedtls_ecp_group_id mbed_ecp_grp_id = MBEDTLS_ECP_DP_CURVE25519;\n\tconst char *pers = \"iot_security_ecdh\";\n\tiot_security_buffer_t pmsecret_buf = { 0 };\n\tiot_security_buffer_t swap_buf = { 0 };\n\tsize_t key_len;\n\tsize_t secret_len;\n\tint ret;\n\n\tif (!t_seckey_buf || !c_pubkey_buf || !output_buf) {\n\t\tIOT_ERROR(\"parameters is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tkey_len = IOT_SECURITY_ED25519_LEN;\n\tsecret_len = IOT_SECURITY_SECRET_LEN;\n\n\tif (t_seckey_buf-\u003elen \u003e key_len) {\n\t\tIOT_ERROR(\"things seckey is too large\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(ECDH_INVALID_SECKEY, t_seckey_buf-\u003elen);\n\t}\n\n\tif (c_pubkey_buf-\u003elen \u003e key_len) {\n\t\tIOT_ERROR(\"cloud pubkey is too large\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(ECDH_INVALID_PUBKEY, c_pubkey_buf-\u003elen);\n\t}\n\n\tpmsecret_buf.len = secret_len;\n\tpmsecret_buf.p = (unsigned char *)iot_os_malloc(pmsecret_buf.len);\n\tif (!pmsecret_buf.p) {\n\t\tIOT_ERROR(\"malloc failed for pre master secret\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmbedtls_ecdh_init(\u0026mbed_ecdh);\n\tmbedtls_ctr_drbg_init(\u0026mbed_ctr_drbg);\n\tmbedtls_entropy_init(\u0026mbed_entropy);\n\n\tret = mbedtls_ctr_drbg_seed(\u0026mbed_ctr_drbg, mbedtls_entropy_func, \u0026mbed_entropy,\n\t\t\t\t\t\t\t\t(const unsigned char *)pers, strlen(pers));\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ctr_drbg_seed = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ecp_group_load(\u0026mbed_ecdh.grp, mbed_ecp_grp_id);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ecp_group_load = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\terr = _iot_security_be_software_swap_secret(t_seckey_buf, \u0026swap_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_mpi_read_binary(\u0026mbed_ecdh.d, swap_buf.p, swap_buf.len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_read_binary = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\t\tgoto exit;\n\t}\n\n\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\n\terr = _iot_security_be_software_swap_secret(c_pubkey_buf, \u0026swap_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_mpi_read_binary(\u0026mbed_ecdh.Qp.X, swap_buf.p, swap_buf.len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_read_binary = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\t\tgoto exit;\n\t}\n\n\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\n\tret = mbedtls_mpi_lset(\u0026mbed_ecdh.Qp.Z, 1);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_lset = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ecdh_compute_shared(\u0026mbed_ecdh.grp, \u0026mbed_ecdh.z, \u0026mbed_ecdh.Qp, \u0026mbed_ecdh.d, mbedtls_ctr_drbg_random, \u0026mbed_ctr_drbg);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ecdh_compute_shared = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_mpi_write_binary(\u0026mbed_ecdh.z, pmsecret_buf.p, pmsecret_buf.len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_write_binary = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\terr = _iot_security_be_software_swap_secret(\u0026pmsecret_buf, \u0026swap_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\toutput_buf-\u003ep = swap_buf.p;\n\toutput_buf-\u003elen = swap_buf.len;\n\terr = IOT_ERROR_NONE;\n\nexit:\n\t_iot_security_be_software_buffer_free(\u0026pmsecret_buf);\n\tmbedtls_ecdh_free(\u0026mbed_ecdh);\n\tmbedtls_ctr_drbg_free(\u0026mbed_ctr_drbg);\n\tmbedtls_entropy_free(\u0026mbed_entropy);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1426,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"285391":{"score":0.844179,"function_name":"_iot_security_be_software_ecdh_copy_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_copy_params(iot_security_buffer_t *src, iot_security_buffer_t *dst)\n{\n\tif (src-\u003ep) {\n\t\tif (src-\u003elen == 0) {\n\t\t\tIOT_ERROR(\"length of src is zero\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t\t}\n\n\t\tif (dst-\u003ep) {\n\t\t\t_iot_security_be_software_buffer_free(dst);\n\t\t}\n\n\t\tdst-\u003ep = (unsigned char *)iot_os_malloc(src-\u003elen);\n\t\tif (!dst-\u003ep) {\n\t\t\tIOT_ERROR(\"failed to malloc for dst params\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t\t}\n\n\t\tmemcpy(dst-\u003ep, src-\u003ep, src-\u003elen);\n\t\tdst-\u003elen = src-\u003elen;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1564,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"285637":{"score":0.91410697,"function_name":"_iot_security_be_software_ecdh_set_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_set_params(iot_security_context_t *context, iot_security_ecdh_params_t *ecdh_set_params)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!ecdh_set_params) {\n\t\tIOT_ERROR(\"ecdh set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\terr = _iot_security_be_software_ecdh_copy_params(\u0026ecdh_set_params-\u003et_seckey, \u0026context-\u003eecdh_params-\u003et_seckey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_ecdh_copy_params(\u0026ecdh_set_params-\u003ec_pubkey, \u0026context-\u003eecdh_params-\u003ec_pubkey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_ecdh_copy_params(\u0026ecdh_set_params-\u003esalt, \u0026context-\u003eecdh_params-\u003esalt);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1590,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"285870":{"score":0.8575244,"function_name":"_iot_security_be_software_ecdh_compute_shared_secret","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_compute_shared_secret(iot_security_context_t *context, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_security_ecdh_params_t *ecdh_params;\n\tiot_security_buffer_t pmsecret_buf = { 0 };\n\tiot_security_buffer_t secret_buf = { 0 };\n\tiot_security_buffer_t shared_secret_buf = { 0 };\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tecdh_params = context-\u003eecdh_params;\n\n\terr = _iot_security_be_software_ecdh_compute_premaster_secret(\u0026ecdh_params-\u003et_seckey, \u0026ecdh_params-\u003ec_pubkey, \u0026pmsecret_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\tsecret_buf.len = pmsecret_buf.len + ecdh_params-\u003esalt.len;\n\tsecret_buf.p = (unsigned char *)iot_os_malloc(secret_buf.len);\n\tif (!secret_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for secret\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_pmsecret;\n\t}\n\n\tmemcpy(secret_buf.p, pmsecret_buf.p, pmsecret_buf.len);\n\tmemcpy(secret_buf.p + pmsecret_buf.len, ecdh_params-\u003esalt.p, ecdh_params-\u003esalt.len);\n\n\tshared_secret_buf.len = IOT_SECURITY_SHA256_LEN;\n\tshared_secret_buf.p = (unsigned char *)iot_os_malloc(shared_secret_buf.len);\n\tif (!shared_secret_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for shared secret\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_secret;\n\t}\n\n\terr = iot_security_sha256(secret_buf.p, secret_buf.len, shared_secret_buf.p, shared_secret_buf.len);\n\tif (err) {\n\t\tgoto exit_free_shared_secret;\n\t}\n\n\tif (context-\u003esub_system \u0026 IOT_SECURITY_SUB_CIPHER) {\n\t\tiot_security_key_params_t shared_key_params = { 0 };\n\t\tshared_key_params.key_id = IOT_SECURITY_KEY_ID_SHARED_SECRET;\n\t\tshared_key_params.params.cipher.key = shared_secret_buf;\n\t\terr = _iot_security_be_software_manager_set_key(context, \u0026shared_key_params);\n\t\tif (err) {\n\t\t\tgoto exit_free_shared_secret;\n\t\t}\n\t}\n\n\tif (output_buf) {\n\t\t*output_buf = shared_secret_buf;\n\t}\n\n\terr = IOT_ERROR_NONE;\n\tgoto exit_free_secret;\n\nexit_free_shared_secret:\n\t_iot_security_be_software_buffer_free(\u0026shared_secret_buf);\nexit_free_secret:\n\t_iot_security_be_software_buffer_free(\u0026secret_buf);\nexit_free_pmsecret:\n\t_iot_security_be_software_buffer_free(\u0026pmsecret_buf);\nexit:\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1623,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286496":{"score":0.74644303,"function_name":"_iot_security_be_software_storage_read","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_storage_read(iot_security_context_t *context, iot_security_buffer_t *data_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_STORAGE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_params = context-\u003estorage_params;\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_params-\u003estorage_id, data_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1697,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286595":{"score":0.7359526,"function_name":"_iot_security_be_software_storage_write","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_storage_write(iot_security_context_t *context, iot_security_buffer_t *data_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_STORAGE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_params = context-\u003estorage_params;\n\n\tif (!context-\u003ebe_context-\u003ebsp_fn ||\n\t\t!context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_store) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BSP_FN_STORE_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_store(context-\u003ebe_context, storage_params-\u003estorage_id, data_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1718,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286743":{"score":0.74488527,"function_name":"_iot_security_be_software_storage_remove","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_storage_remove(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_STORAGE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_params = context-\u003estorage_params;\n\n\tif (!context-\u003ebe_context-\u003ebsp_fn ||\n\t\t!context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_remove) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BSP_FN_REMOVE_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_remove(context-\u003ebe_context, storage_params-\u003estorage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1744,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286888":{"score":0.9211914,"function_name":"iot_security_be_init","code":"iot_security_be_context_t *iot_security_be_init(external_nv_callback external_nv_cb)\n{\n\tiot_error_t err;\n\tiot_security_be_context_t *be_context;\n\n\tbe_context = (iot_security_be_context_t *)iot_os_malloc(sizeof(iot_security_be_context_t));\n\tif (!be_context) {\n\t\tIOT_ERROR(\"failed to malloc for context\");\n\t\treturn NULL;\n\t}\n\n\tmemset(be_context, 0, sizeof(iot_security_be_context_t));\n\n\tbe_context-\u003ename = \"software\";\n\tbe_context-\u003efn = \u0026iot_security_be_software_funcs;\n\tbe_context-\u003eexternal_device_info_cb = external_nv_cb;\n\n\terr = iot_security_be_bsp_init(be_context);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_be_bsp_init = %d\", err);\n\t\tiot_os_free(be_context);\n\t\treturn NULL;\n\t}\n\n\tIOT_DEBUG(\"security backend is '%s'\", be_context-\u003ename);\n\n\treturn be_context;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1806,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287121":{"score":0.88187206,"function_name":"iot_security_be_deinit","code":"iot_error_t iot_security_be_deinit(iot_security_be_context_t *be_context)\n{\n\tif (!be_context) {\n\t\tIOT_ERROR(\"backend context is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(be_context, 0, sizeof(iot_security_be_context_t));\n\n\tiot_os_free(be_context);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1835,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287272":{"score":0.65526754,"function_name":"_iot_security_be_software_pk_init","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\terr = _iot_security_be_software_pk_load_key(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":403,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287788":{"score":0.88322014,"function_name":"iot_security_pk_get_key_type","code":"iot_error_t iot_security_pk_get_key_type(iot_security_context_t *context, iot_security_key_type_t *key_type)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!key_type) {\n\t\tIOT_ERROR(\"key type is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003epk_get_key_type) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003epk_get_key_type is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003epk_get_key_type(context, key_type);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"type = %d\", *key_type);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":107,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287995":{"score":0.86306286,"function_name":"iot_security_pk_sign","code":"iot_error_t iot_security_pk_sign(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *sig_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!sig_buf) {\n\t\tIOT_ERROR(\"sig buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"input = %d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\n\tif (!context-\u003ebe_context-\u003efn-\u003epk_sign) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003epk_sign is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003epk_sign(context, input_buf, sig_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"sig = %d@%p\", (int)sig_buf-\u003elen, sig_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":136,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"288285":{"score":0.8891401,"function_name":"iot_security_pk_verify","code":"iot_error_t iot_security_pk_verify(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *sig_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!sig_buf || !sig_buf-\u003ep || (sig_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"sig buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"input = %d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\tIOT_DEBUG(\"sig = %d@%p\", (int)sig_buf-\u003elen, sig_buf-\u003ep);\n\n\tif (!context-\u003ebe_context-\u003efn-\u003epk_verify) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003epk_verify is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003epk_verify(context, input_buf, sig_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":172,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"288594":{"score":0.9216276,"function_name":"iot_security_cipher_init","code":"iot_error_t iot_security_cipher_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_cipher_params_t *cipher_params;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tcipher_params = (iot_security_cipher_params_t *)iot_os_malloc(sizeof(iot_security_cipher_params_t));\n\tif (!cipher_params) {\n\t\tIOT_ERROR(\"failed to malloc for cipher info\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemset(cipher_params, 0, sizeof(iot_security_cipher_params_t));\n\n\tcontext-\u003ecipher_params = cipher_params;\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003ecipher_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003ecipher_init(context);\n\t\tif (err) {\n\t\t\tiot_os_free(context-\u003ecipher_params);\n\t\t\tcontext-\u003ecipher_params = NULL;\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INIT, 0);\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_CIPHER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":207,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"288859":{"score":0.7740824,"function_name":"iot_security_cipher_deinit","code":"iot_error_t iot_security_cipher_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003ecipher_deinit) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003ecipher_deinit(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (context-\u003ecipher_params) {\n\t\tmemset(context-\u003ecipher_params, 0, sizeof(iot_security_cipher_params_t));\n\t\tiot_os_free(context-\u003ecipher_params);\n\t\tcontext-\u003ecipher_params = NULL;\n\t}\n\n\tcontext-\u003esub_system \u0026= ~IOT_SECURITY_SUB_CIPHER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":242,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"289056":{"score":0.91114575,"function_name":"iot_security_cipher_get_align_size","code":"size_t iot_security_cipher_get_align_size(iot_security_key_type_t key_type, size_t data_size)\n{\n\tconst mbedtls_cipher_info_t *cipher_info;\n\tmbedtls_cipher_context_t cipher_ctx;\n\tmbedtls_cipher_type_t cipher_alg;\n\tunsigned int block_size;\n\tint ret;\n\n\tIOT_DEBUG(\"data size = %d, type = %d\", (int)data_size, key_type);\n\n\tif (key_type == IOT_SECURITY_KEY_TYPE_AES256) {\n\t\tcipher_alg = MBEDTLS_CIPHER_AES_256_CBC;\n\t} else {\n\t\tIOT_ERROR(\"'%d' is not supported cipher algorithm\", key_type);\n\t\treturn 0;\n\t}\n\n\tif (!data_size) {\n\t\tIOT_ERROR(\"input size is zero\");\n\t\treturn 0;\n\t}\n\n\tcipher_info = mbedtls_cipher_info_from_type(cipher_alg);\n\tif (!cipher_info) {\n\t\tIOT_ERROR(\"mbedtls_cipher_info_from_type returned null\");\n\t\treturn 0;\n\t}\n\n\tmbedtls_cipher_init(\u0026cipher_ctx);\n\n\tret = mbedtls_cipher_setup(\u0026cipher_ctx, cipher_info);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_setup = -0x%04X\", -ret);\n\t\tmbedtls_cipher_free(\u0026cipher_ctx);\n\t\treturn 0;\n\t}\n\n\tblock_size = mbedtls_cipher_get_block_size(\u0026cipher_ctx);\n\tif (block_size == 0) {\n\t\tIOT_ERROR(\"mbedtls_cipher_get_block_size returned zero\");\n\t\tmbedtls_cipher_free(\u0026cipher_ctx);\n\t\treturn 0;\n\t}\n\n\tdata_size = data_size + (block_size - (data_size % block_size));\n\n\tmbedtls_cipher_free(\u0026cipher_ctx);\n\n\tIOT_DEBUG(\"align size = %d\", (int)data_size);\n\n\treturn data_size;\n}","filepath":"src/security/iot_security_crypto.c","line_number":270,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"289532":{"score":0.9159417,"function_name":"iot_security_cipher_set_params","code":"iot_error_t iot_security_cipher_set_params(iot_security_context_t *context, iot_security_cipher_params_t *cipher_set_params)\n\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!cipher_set_params) {\n\t\tIOT_ERROR(\"cipher set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003ecipher_set_params) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003ecipher_set_params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003ecipher_set_params(context, cipher_set_params);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":323,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"290056":{"score":0.92744195,"function_name":"iot_security_cipher_aes_encrypt","code":"iot_error_t iot_security_cipher_aes_encrypt(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"input = %d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tif (!context-\u003ebe_context-\u003efn-\u003ecipher_aes_encrypt) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003ecipher_aes_encrypt is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003ecipher_aes_encrypt(context, input_buf, output_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"output = %d@%p\", (int)output_buf-\u003elen, output_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":351,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"290367":{"score":0.9438614,"function_name":"iot_security_ecdh_init","code":"iot_error_t iot_security_ecdh_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_ecdh_params_t *ecdh_params;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tecdh_params = (iot_security_ecdh_params_t *)iot_os_malloc(sizeof(iot_security_ecdh_params_t));\n\tif (!ecdh_params) {\n\t\tIOT_ERROR(\"failed to malloc for ecdh params\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemset((void *)ecdh_params, 0, sizeof(iot_security_ecdh_params_t));\n\n\tcontext-\u003eecdh_params = ecdh_params;\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003eecdh_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003eecdh_init(context);\n\t\tif (err) {\n\t\t\tiot_os_free(context-\u003eecdh_params);\n\t\t\tcontext-\u003eecdh_params = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_ECDH;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_ecdh.c","line_number":26,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"290627":{"score":0.74596846,"function_name":"iot_security_ecdh_deinit","code":"iot_error_t iot_security_ecdh_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003eecdh_deinit) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003eecdh_deinit(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (context-\u003eecdh_params) {\n\t\tmemset((void *)context-\u003eecdh_params, 0, sizeof(iot_security_ecdh_params_t));\n\t\tiot_os_free((void *)context-\u003eecdh_params);\n\t\tcontext-\u003eecdh_params = NULL;\n\t}\n\n\tcontext-\u003esub_system \u0026= ~IOT_SECURITY_SUB_ECDH;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_ecdh.c","line_number":61,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"290824":{"score":0.9304583,"function_name":"iot_security_ecdh_set_params","code":"iot_error_t iot_security_ecdh_set_params(iot_security_context_t *context, iot_security_ecdh_params_t *ecdh_set_params)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!ecdh_set_params) {\n\t\tIOT_ERROR(\"ecdh set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003eecdh_set_params) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003eecdh_set_params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003eecdh_set_params(context, ecdh_set_params);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_ecdh.c","line_number":89,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291031":{"score":0.9095699,"function_name":"iot_security_ecdh_compute_shared_secret","code":"iot_error_t iot_security_ecdh_compute_shared_secret(iot_security_context_t *context, iot_security_buffer_t *secret_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/*\n\t * secret_buf can be null\n\t */\n\n\tif (!context-\u003ebe_context-\u003efn-\u003eecdh_compute_shared_secret) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003eecdh_compute_shared_secret is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003eecdh_compute_shared_secret(context, secret_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_ecdh.c","line_number":116,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291189":{"score":0.8589194,"function_name":"iot_security_ed25519_convert_pubkey","code":"iot_error_t iot_security_ed25519_convert_pubkey(unsigned char *ed25519_key, unsigned char *curve25519_key)\n{\n\tint ret;\n\n\tif (!ed25519_key || !curve25519_key) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tret = crypto_sign_ed25519_pk_to_curve25519(curve25519_key, ed25519_key);\n\tif (ret) {\n\t\tIOT_ERROR(\"crypto_sign_ed25519_pk_to_curve25519 = %d\", ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_CONVERT, ret);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/libsodium/iot_security_helper_libsodium.c","line_number":25,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291308":{"score":0.8454234,"function_name":"iot_security_ed25519_convert_seckey","code":"iot_error_t iot_security_ed25519_convert_seckey(unsigned char *ed25519_key, unsigned char *curve25519_key)\n{\n\tint ret;\n\n\tif (!ed25519_key || !curve25519_key) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tret = crypto_sign_ed25519_sk_to_curve25519(curve25519_key, ed25519_key);\n\tif (ret) {\n\t\tIOT_ERROR(\"crypto_sign_ed25519_sk_to_curve25519 = %d\", ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_CONVERT, ret);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/libsodium/iot_security_helper_libsodium.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291427":{"score":0.83612597,"function_name":"_iot_security_url_encode","code":"static iot_error_t _iot_security_url_encode(char *buf, size_t buf_len)\n{\n\tsize_t i;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!buf_len) {\n\t\tIOT_ERROR(\"length is zero\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tfor (i = 0; i \u003c buf_len; i++) {\n\t\tswitch (buf[i]) {\n\t\tcase '+':\n\t\t\tbuf[i] = '-';\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tbuf[i] = '_';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":29,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291631":{"score":0.8357629,"function_name":"_iot_security_url_decode","code":"static iot_error_t _iot_security_url_decode(char *buf, size_t buf_len)\n{\n\tsize_t i;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!buf_len) {\n\t\tIOT_ERROR(\"length is zero\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tfor (i = 0; i \u003c buf_len; i++) {\n\t\tswitch (buf[i]) {\n\t\tcase '-':\n\t\t\tbuf[i] = '+';\n\t\t\tbreak;\n\t\tcase '_':\n\t\t\tbuf[i] = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":59,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291835":{"score":0.85802007,"function_name":"iot_security_base64_encode","code":"iot_error_t iot_security_base64_encode(const unsigned char *src, size_t src_len,\n                                       unsigned char *dst, size_t dst_len,\n                                       size_t *out_len)\n{\n\tint ret;\n\n\tif (!src || (src_len == 0)) {\n\t\tIOT_ERROR(\"invalid src with %d@%p\", (int)src_len, src);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!dst || (dst_len == 0)) {\n\t\tIOT_ERROR(\"invalid dst with %d@%p\", (int)dst_len, dst);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!out_len) {\n\t\tIOT_ERROR(\"length output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"src: %d@%p, dst: %d@%p\", (int)src_len, src, (int)dst_len, dst);\n\n\tret = mbedtls_base64_encode(dst, dst_len, out_len, src, src_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_base64_encode = -0x%04X\", -ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_ENCODE, -ret);\n\t}\n\n\tIOT_DEBUG(\"done: %d@%p\", (int)*out_len, dst);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":89,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"292126":{"score":0.8538764,"function_name":"iot_security_base64_decode","code":"iot_error_t iot_security_base64_decode(const unsigned char *src, size_t src_len,\n                                       unsigned char *dst, size_t dst_len,\n                                       size_t *out_len)\n{\n\tint ret;\n\n\tif (!src || (src_len == 0)) {\n\t\tIOT_ERROR(\"invalid src with %d@%p\", (int)src_len, src);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!dst || (dst_len == 0)) {\n\t\tIOT_ERROR(\"invalid dst with %d@%p\", (int)dst_len, dst);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!out_len) {\n\t\tIOT_ERROR(\"length output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"src: %d@%p, dst: %d@%p\", (int)src_len, src, (int)dst_len, dst);\n\n\tret = mbedtls_base64_decode(dst, dst_len, out_len, src, src_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_base64_decode = -0x%04X\", -ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_DECODE, -ret);\n\t}\n\n\tIOT_DEBUG(\"done: %d@%p\", (int)*out_len, dst);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":123,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"292429":{"score":0.8819965,"function_name":"iot_security_base64_encode_urlsafe","code":"iot_error_t iot_security_base64_encode_urlsafe(const unsigned char *src, size_t src_len,\n                                               unsigned char *dst, size_t dst_len,\n                                               size_t *out_len)\n{\n\tint ret;\n\n\tif (!src || (src_len == 0)) {\n\t\tIOT_ERROR(\"invalid src with %d@%p\", (int)src_len, src);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!dst || (dst_len == 0)) {\n\t\tIOT_ERROR(\"invalid dst with %d@%p\", (int)dst_len, dst);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!out_len) {\n\t\tIOT_ERROR(\"length output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"src: %d@%p, dst: %d@%p\", (int)src_len, src, (int)dst_len, dst);\n\n\tret = mbedtls_base64_encode(dst, dst_len, out_len, src, src_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_base64_encode = -0x%04X\", -ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_ENCODE, -ret);\n\t}\n\n\tret = _iot_security_url_encode((char *)dst, *out_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"_iot_security_url_encode = %d\", ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_ENCODE, ret);\n\t}\n\n\tIOT_DEBUG(\"done: %d@%p\", (int)*out_len, dst);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":157,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"292813":{"score":0.83539927,"function_name":"iot_security_base64_decode_urlsafe","code":"iot_error_t iot_security_base64_decode_urlsafe(const unsigned char *src, size_t src_len,\n                                             unsigned char *dst, size_t dst_len,\n                                             size_t *out_len)\n{\n\tunsigned char *src_dup = NULL;\n\tsize_t align_len;\n\tsize_t i;\n\tint ret;\n\n\tif (!src || (src_len == 0)) {\n\t\tIOT_ERROR(\"invalid src with %d@%p\", (int)src_len, src);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!dst || (dst_len == 0)) {\n\t\tIOT_ERROR(\"invalid dst with %d@%p\", (int)dst_len, dst);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!out_len) {\n\t\tIOT_ERROR(\"length output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"src: %d@%p, dst: %d@%p\", (int)src_len, src, (int)dst_len, dst);\n\n\talign_len = IOT_SECURITY_B64_ALIGN_LEN(src_len);\n\tsrc_dup = (unsigned char *)iot_os_malloc(align_len + 1);\n\tif (src_dup == NULL) {\n\t\tIOT_ERROR(\"malloc failed for align buffer\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemcpy(src_dup, src, src_len);\n\t/* consider '=' removed from tail */\n\tfor (i = src_len; i \u003c align_len; i++) {\n\t\tsrc_dup[i] = '=';\n\t}\n\tsrc_dup[align_len] = '\\0';\n\n\tret = _iot_security_url_decode((char *)src_dup, align_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"_iot_security_url_decode = %d\", ret);\n\t\tiot_os_free(src_dup);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_DECODE, ret);\n\t}\n\n\tret = mbedtls_base64_decode(dst, dst_len, out_len, (const unsigned char *)src_dup, align_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_base64_decode = -0x%04X\", -ret);\n\t\tiot_os_free(src_dup);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_DECODE, -ret);\n\t}\n\n\tiot_os_free(src_dup);\n\tIOT_DEBUG(\"done: %d@%p\", (int)*out_len, dst);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":197,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"293393":{"score":0.88606566,"function_name":"iot_security_sha256","code":"iot_error_t iot_security_sha256(const unsigned char *input, size_t input_len, unsigned char *output, size_t output_len)\n{\n\tint ret;\n\n\tif (!input || (input_len == 0)) {\n\t\tIOT_ERROR(\"invalid input with %d@%p\", (int)input_len, input);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!output || (output_len \u003c IOT_SECURITY_SHA256_LEN)) {\n\t\tIOT_ERROR(\"invalid output with %d@%p\", (int)output_len, output);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tret = mbedtls_sha256_ret(input, input_len, output, 0);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_sha256_ret = -0x%04X\", -ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(SHA256, -ret);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":257,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"293634":{"score":0.9086083,"function_name":"iot_get_random_uuid_from_mac","code":"iot_error_t iot_get_random_uuid_from_mac(struct iot_uuid *uuid)\n{\n\tiot_error_t err;\n\tstruct timeval tv;\n\tstruct iot_mac mac;\n\tunsigned char hash[IOT_SECURITY_SHA256_LEN];\n\tunsigned char *buf;\n\tsize_t buf_len;\n\tint ret;\n\n\tif (!uuid) {\n\t\tIOT_ERROR(\"UUID ptr is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\terr = iot_bsp_wifi_get_mac(\u0026mac);\n\tif(err) {\n\t\tIOT_ERROR(\"iot_bsp_wifi_get_mac failed, ret = %d\", err);\n\t\treturn err;\n\t}\n\n\tret = gettimeofday(\u0026tv, NULL);\n\tif (ret) {\n\t\tIOT_ERROR(\"gettimeofday failed, ret = %d\", ret);\n\t\treturn IOT_ERROR_UUID_FAIL;\n\t}\n\n\tbuf_len = sizeof(mac) + sizeof(tv);\n\n\tbuf = (unsigned char *)iot_os_malloc(buf_len);\n\tif (!buf) {\n\t\tIOT_ERROR(\"malloc failed for buf\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemset(buf, 0, buf_len);\n\tmemcpy(buf, \u0026mac, sizeof(mac));\n\tmemcpy(buf + sizeof(mac), \u0026tv, sizeof(tv));\n\n\t/*\n\t * uuid = first16byte(sha256(mac + usec))\n\t */\n\terr = iot_security_sha256(buf, buf_len, hash, sizeof(hash));\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_sha256 failed, ret = %d\", err);\n\t\tfree((void *)buf);\n\t\treturn err;\n\t}\n\n\tmemcpy((void *)uuid, hash, sizeof(struct iot_uuid));\n\n\t/* From RFC 4122\n\t * Set the two most significant bits of the\n\t * clock_seq_hi_and_reserved (8th octect) to\n\t * zero and one, respectively.\n\t */\n\tuuid-\u003eid[8] \u0026= 0x3f;\n\tuuid-\u003eid[8] |= 0x80;\n\n\t/* From RFC 4122\n\t * Set the four most significant bits of the\n\t * time_hi_and_version field (6th octect) to the\n\t * 4-bit version number from (0 1 0 0 =\u003e type 4)\n\t * Section 4.1.3.\n\t */\n\tuuid-\u003eid[6] \u0026= 0x0f;\n\tuuid-\u003eid[6] |= 0x40;\n\n\tfree((void *)buf);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_uuid.c","line_number":28,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"294215":{"score":0.90318054,"function_name":"iot_get_uuid_from_mac","code":"iot_error_t iot_get_uuid_from_mac(struct iot_uuid *uuid)\n{\n\tiot_error_t err;\n\tstruct iot_mac mac;\n\tunsigned char hash[IOT_SECURITY_SHA256_LEN];\n\tunsigned char *buf;\n\tsize_t buf_len;\n\n\tif (!uuid) {\n\t\tIOT_ERROR(\"UUID ptr is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\terr = iot_bsp_wifi_get_mac(\u0026mac);\n\tif(err) {\n\t\tIOT_ERROR(\"iot_bsp_wifi_get_mac failed, ret = %d\", err);\n\t\treturn err;\n\t}\n\n\tbuf_len = sizeof(mac);\n\n\tbuf = (unsigned char *)iot_os_malloc(buf_len);\n\tif (!buf) {\n\t\tIOT_ERROR(\"malloc failed for buf\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemset(buf, 0, buf_len);\n\tmemcpy(buf, \u0026mac, buf_len);\n\n\t/*\n\t * uuid = first16byte(sha256(mac))\n\t */\n\terr = iot_security_sha256(buf, buf_len, hash, sizeof(hash));\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_sha256 failed, err = %d\", err);\n\t\tfree((void *)buf);\n\t\treturn err;\n\t}\n\n\tmemcpy((void *)uuid, hash, sizeof(struct iot_uuid));\n\n\t/* From RFC 4122\n\t * Set the two most significant bits of the\n\t * clock_seq_hi_and_reserved (8th octect) to\n\t * zero and one, respectively.\n\t */\n\tuuid-\u003eid[8] \u0026= 0x3f;\n\tuuid-\u003eid[8] |= 0x80;\n\n\t/* From RFC 4122\n\t * Set the four most significant bits of the\n\t * time_hi_and_version field (6th octect) to the\n\t * 4-bit version number from (0 1 0 0 =\u003e type 4)\n\t * Section 4.1.3.\n\t */\n\tuuid-\u003eid[6] \u0026= 0x0f;\n\tuuid-\u003eid[6] |= 0x40;\n\n\tfree((void *)buf);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_uuid.c","line_number":101,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"294712":{"score":0.86233884,"function_name":"iot_get_random_uuid","code":"iot_error_t iot_get_random_uuid(struct iot_uuid* uuid)\n{\n\tunsigned char* p;\n\tint i;\n\n\tif (!uuid) {\n\t\tIOT_ERROR(\"invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tp = (unsigned char *)uuid-\u003eid;\n\n\tfor (i = 0; i \u003c 4; i++) {\n\t\tunsigned int rand_value = iot_bsp_random();\n\n\t\tmemcpy(\u0026p[i * 4], (unsigned char*)\u0026rand_value, sizeof(unsigned int));\n\t}\n\n\t/* From RFC 4122\n\t * Set the two most significant bits of the\n\t * clock_seq_hi_and_reserved (8th octect) to\n\t * zero and one, respectively.\n\t */\n\tp[8] \u0026= 0x3f;\n\tp[8] |= 0x80;\n\n\t/* From RFC 4122\n\t * Set the four most significant bits of the\n\t * time_hi_and_version field (6th octect) to the\n\t * 4-bit version number from (0 1 0 0 =\u003e type 4)\n\t * Section 4.1.3.\n\t */\n\tp[6] \u0026= 0x0f;\n\tp[6] |= 0x40;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_uuid.c","line_number":165,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"295149":{"score":0.8839939,"function_name":"_iot_wt_alloc_b64_buffer","code":"static iot_security_buffer_t *_iot_wt_alloc_b64_buffer(size_t plain_len)\n{\n\tiot_security_buffer_t *b64_buf;\n\tunsigned char *buf;\n\tsize_t len;\n\n\tb64_buf = (iot_security_buffer_t *)iot_os_malloc(sizeof(iot_security_buffer_t));\n\tif (!b64_buf) {\n\t\tIOT_ERROR(\"failed to malloc for b64 buffer\");\n\t\treturn NULL;\n\t}\n\n\tmemset(b64_buf, 0, sizeof(iot_security_buffer_t));\n\n\tlen = IOT_SECURITY_B64_ENCODE_LEN(plain_len);\n\tbuf = (unsigned char *)iot_os_malloc(len);\n\tif (!buf) {\n\t\tIOT_ERROR(\"failed to malloc for b64\");\n\t\tiot_os_free(b64_buf);\n\t\treturn NULL;\n\t}\n\n\tb64_buf-\u003ep = buf;\n\tb64_buf-\u003elen = len;\n\n\treturn b64_buf;\n}","filepath":"src/iot_wt.c","line_number":32,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"295384":{"score":0.90767676,"function_name":"_iot_jwt_header_rs256","code":"static char * _iot_jwt_header_rs256(const iot_wt_params_t *wt_params)\n{\n\tJSON_H *object;\n\tchar *object_str;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003esn) {\n\t\tIOT_ERROR(\"sn in params is null\");\n\t\treturn NULL;\n\t}\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"alg\", JSON_CREATE_STRING(\"RS256\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kty\", JSON_CREATE_STRING(\"RSA\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"crv\", JSON_CREATE_STRING(\"\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"typ\", JSON_CREATE_STRING(\"JWT\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"ver\", JSON_CREATE_STRING(\"0.0.1\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kid\", JSON_CREATE_STRING(wt_params-\u003esn));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":569,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"295922":{"score":0.9089414,"function_name":"_iot_jwt_header_ed25519","code":"static char * _iot_jwt_header_ed25519(const iot_wt_params_t *wt_params)\n{\n\tJSON_H *object;\n\tchar *object_str;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003esn) {\n\t\tIOT_ERROR(\"sn in params is null\");\n\t\treturn NULL;\n\t}\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"alg\", JSON_CREATE_STRING(\"EdDSA\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kty\", JSON_CREATE_STRING(\"OKP\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"crv\", JSON_CREATE_STRING(\"Ed25519\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"typ\", JSON_CREATE_STRING(\"JWT\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"ver\", JSON_CREATE_STRING(\"0.0.1\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kid\", JSON_CREATE_STRING(wt_params-\u003esn));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":609,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"296460":{"score":0.91658384,"function_name":"_iot_jwt_header_eccp256","code":"static char * _iot_jwt_header_eccp256(const iot_wt_params_t *wt_params)\n{\n\tJSON_H *object;\n\tchar *object_str;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003esn) {\n\t\tIOT_ERROR(\"sn in params is null\");\n\t\treturn NULL;\n\t}\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"alg\", JSON_CREATE_STRING(\"ES256\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kty\", JSON_CREATE_STRING(\"EC\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"crv\", JSON_CREATE_STRING(\"P256\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"typ\", JSON_CREATE_STRING(\"JWT\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"ver\", JSON_CREATE_STRING(\"0.0.1\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kid\", JSON_CREATE_STRING(wt_params-\u003esn));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":649,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"296998":{"score":0.8795129,"function_name":"_iot_jwt_create_header","code":"static char * _iot_jwt_create_header(const iot_wt_params_t *wt_params, iot_security_key_type_t key_type)\n{\n\tchar *object_str;\n\n\tswitch(key_type) {\n\tcase IOT_SECURITY_KEY_TYPE_RSA2048:\n\t\tobject_str = _iot_jwt_header_rs256(wt_params);\n\t\tbreak;\n\tcase IOT_SECURITY_KEY_TYPE_ED25519:\n\t\tobject_str = _iot_jwt_header_ed25519(wt_params);\n\t\tbreak;\n\tcase IOT_SECURITY_KEY_TYPE_ECCP256:\n\t\tobject_str = _iot_jwt_header_eccp256(wt_params);\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"pubkey type (%d) is not supported\", key_type);\n\t\tobject_str = NULL;\n\t\tbreak;\n\t}\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":689,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"297152":{"score":0.8439659,"function_name":"_iot_jwt_create_b64h","code":"static iot_error_t _iot_jwt_create_b64h(const iot_wt_params_t *wt_params,\n\t\t\t\t\tiot_security_key_type_t key_type,\n\t\t\t\t\tiot_security_buffer_t *b64h_buf)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_buffer_t *b64_buf;\n\tchar *hdr;\n\tsize_t hdr_len;\n\tsize_t out_len;\n\n\tif (!wt_params || !b64h_buf) {\n\t\tIOT_ERROR(\"params is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\thdr = _iot_jwt_create_header(wt_params, key_type);\n\tif (!hdr) {\n\t\tIOT_ERROR(\"_iot_jwt_create_header returned NULL\");\n\t\terr = IOT_ERROR_WEBTOKEN_FAIL;\n\t\tgoto exit;\n\t}\n\n\thdr_len = strlen(hdr);\n\n\tb64_buf = _iot_wt_alloc_b64_buffer(hdr_len);\n\tif (!b64_buf) {\n\t\tgoto exit_hdr;\n\t}\n\n\terr = iot_security_base64_encode((unsigned char *)hdr, hdr_len, b64_buf-\u003ep, b64_buf-\u003elen, \u0026out_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_base64_encode = %d\", err);\n\t\tgoto exit_b64_buf_p;\n\t}\n\n\tb64h_buf-\u003ep = b64_buf-\u003ep;\n\tb64h_buf-\u003elen = out_len;\n\tgoto exit_b64_buf;\n\nexit_b64_buf_p:\n\tiot_os_free(b64_buf-\u003ep);\nexit_b64_buf:\n\tiot_os_free(b64_buf);\nexit_hdr:\n\tfree(hdr);\nexit:\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":712,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"297565":{"score":0.8678737,"function_name":"_iot_jwt_create_payload","code":"static char * _iot_jwt_create_payload(const iot_wt_params_t *wt_params)\n{\n\tiot_error_t err;\n\tJSON_H *object;\n\tchar *object_str;\n\tchar time_in_sec[16]; /* 1559347200 is '2019-06-01 00:00:00 UTC' */\n\tchar uuid_str[40];    /* 4066c24f-cd48-4e92-a538-362e74337c7f */\n\tstruct iot_uuid uuid;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003emnid) {\n\t\tIOT_ERROR(\"mnid in params is null\");\n\t\treturn NULL;\n\t}\n\n\terr = iot_get_time_in_sec(time_in_sec, sizeof(time_in_sec));\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_get_time_in_sec returned error : %d\", err);\n\t\treturn NULL;\n\t}\n\n\terr = iot_get_random_uuid(\u0026uuid);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_get_random_uuid returned error : %d\", err);\n\t\treturn NULL;\n\t}\n\n\terr = iot_util_convert_uuid_str(\u0026uuid, uuid_str, sizeof(uuid_str));\n\tif (err) {\n\t\tIOT_ERROR(\"iot_util_convert_uuid_str returned error : %d\", err);\n\t\treturn NULL;\n\t}\n\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"iat\", JSON_CREATE_STRING(time_in_sec));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"jti\", JSON_CREATE_STRING(uuid_str));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"mnId\", JSON_CREATE_STRING(wt_params-\u003emnid));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":761,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"298249":{"score":0.87552893,"function_name":"_iot_jwt_create_b64p","code":"static iot_error_t _iot_jwt_create_b64p(const iot_wt_params_t *wt_params,\n\t\t\tiot_security_buffer_t *b64p_buf)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_buffer_t *b64_buf;\n\tchar *payload;\n\tsize_t payload_len;\n\tsize_t out_len;\n\n\tif (!wt_params || !b64p_buf) {\n\t\tIOT_ERROR(\"params is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tpayload = _iot_jwt_create_payload(wt_params);\n\tif (!payload) {\n\t\tIOT_ERROR(\"_iot_jwt_create_payload returned NULL\");\n\t\terr = IOT_ERROR_WEBTOKEN_FAIL;\n\t\tgoto exit;\n\t}\n\n\tpayload_len = strlen(payload);\n\n\tb64_buf = _iot_wt_alloc_b64_buffer(payload_len);\n\tif (!b64_buf) {\n\t\tgoto exit_payload;\n\t}\n\n\terr = iot_security_base64_encode((unsigned char *)payload, payload_len, b64_buf-\u003ep, b64_buf-\u003elen, \u0026out_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_base64_encode returned error : %d\", err);\n\t\tgoto exit_b64_buf_p;\n\t}\n\n\tb64p_buf-\u003ep = b64_buf-\u003ep;\n\tb64p_buf-\u003elen = out_len;\n\tgoto exit_b64_buf;\n\nexit_b64_buf_p:\n\tiot_os_free(b64_buf-\u003ep);\nexit_b64_buf:\n\tiot_os_free(b64_buf);\nexit_payload:\n\tfree(payload);\nexit:\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":821,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"298659":{"score":0.8512962,"function_name":"_iot_jwt_create_b64s","code":"static iot_error_t _iot_jwt_create_b64s(iot_security_context_t *security_context,\n                                        unsigned char *b64hp, size_t hp_len,\n                                        iot_security_buffer_t *b64s_buf)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t hp_buf = {0 };\n\tiot_security_buffer_t sig_buf = { 0 };\n\tiot_security_buffer_t *sig_b64_buf;\n\tiot_security_key_type_t key_type;\n\tunsigned char hash[IOT_SECURITY_SHA256_LEN] = { 0 };\n\tsize_t out_len;\n\n\terr = iot_security_pk_get_key_type(security_context, \u0026key_type);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_pk_get_key_type returned error : %d\", err);\n\t\tgoto exit;\n\t}\n\n\tswitch (key_type) {\n\tcase IOT_SECURITY_KEY_TYPE_ED25519:\n\t\thp_buf.p = b64hp;\n\t\thp_buf.len = hp_len;\n\t\terr = iot_security_pk_sign(security_context, \u0026hp_buf, \u0026sig_buf);\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"iot_security_pk_sign returned error : %d\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = iot_security_sha256(b64hp, hp_len, hash, sizeof(hash));\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"iot_security_sha256 returned error : %d\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\thp_buf.p = hash;\n\t\thp_buf.len = sizeof(hash);\n\t\terr = iot_security_pk_sign(security_context, \u0026hp_buf, \u0026sig_buf);\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"iot_security_pk_sign returned error : %d\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\t}\n\n\tsig_b64_buf = _iot_wt_alloc_b64_buffer(sig_buf.len);\n\tif (!sig_b64_buf) {\n\t\tgoto exit_sig;\n\t}\n\n\terr = iot_security_base64_encode(sig_buf.p, sig_buf.len, sig_b64_buf-\u003ep, sig_b64_buf-\u003elen, \u0026out_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_base64_encode returned error : %d\", err);\n\t\tgoto exit_b64_buf_p;\n\t}\n\n\tb64s_buf-\u003ep = sig_b64_buf-\u003ep;\n\tb64s_buf-\u003elen = out_len;\n\tgoto exit_b64_buf;\n\nexit_b64_buf_p:\n\tiot_os_free(sig_b64_buf-\u003ep);\nexit_b64_buf:\n\tiot_os_free(sig_b64_buf);\nexit_sig:\n\tiot_os_free(sig_buf.p);\nexit:\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":869,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"299331":{"score":0.83898616,"function_name":"_iot_jwt_create","code":"static iot_error_t _iot_jwt_create(const iot_wt_params_t *wt_params, iot_security_buffer_t *token_buf)\n{\n\tiot_error_t err;\n\tiot_security_context_t *security_context;\n\tiot_security_key_type_t key_type;\n\tiot_security_buffer_t b64h_buf = { 0 };\n\tiot_security_buffer_t b64p_buf = { 0 };\n\tiot_security_buffer_t b64s_buf = { 0 };\n\tunsigned char *tmp;\n\tsize_t sig_len;\n\tsize_t token_len;\n\tsize_t written = 0;\n\n\tif (!wt_params || !token_buf) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tsecurity_context = iot_security_init();\n\tif (!security_context) {\n\t\treturn IOT_ERROR_SECURITY_INIT;\n\t}\n\n\terr = iot_security_pk_init(security_context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_security_pk_get_key_type(security_context, \u0026key_type);\n\tif (err) {\n\t\tgoto exit_payload;\n\t}\n\n\t/* b64h = b64(header) */\n\n\terr = _iot_jwt_create_b64h(wt_params, key_type, \u0026b64h_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_jwt_create_b64h = %d\", err);\n\t\tgoto exit;\n\t}\n\n\t/* b64p = b64(payload) */\n\n\terr = _iot_jwt_create_b64p(wt_params, \u0026b64p_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_jwt_create_b64p returned error : %d\", err);\n\t\tgoto exit_header;\n\t}\n\n\t/* b64h.b64 */\n\n\tsig_len = iot_security_pk_get_signature_len(key_type);\n\n\ttoken_len = b64h_buf.len + b64p_buf.len + IOT_SECURITY_B64_ENCODE_LEN(sig_len) + 3;\n\n\ttmp = (unsigned char *)iot_os_malloc(token_len);\n\tif (tmp == NULL) {\n\t\tIOT_ERROR(\"malloc returned NULL\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tgoto exit_payload;\n\t}\n\n\tmemcpy(tmp, b64h_buf.p, b64h_buf.len);\n\twritten += b64h_buf.len;\n\n\ttmp[written++] = '.';\n\n\tmemcpy(tmp + written, b64p_buf.p, b64p_buf.len);\n\twritten += b64p_buf.len;\n\n\t/* b64s = b64(sign(sha256(b64h.b64p))) */\n\n\terr = _iot_jwt_create_b64s(security_context, tmp, written, \u0026b64s_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_jwt_create_b64s returned error : %d\", err);\n\t\tiot_os_free(tmp);\n\t\tgoto exit_payload;\n\t}\n\n\t/* token = b64h.b64p.b64s */\n\n\ttmp[written++] = '.';\n\n\tmemcpy(tmp + written, b64s_buf.p, b64s_buf.len);\n\twritten += b64s_buf.len;\n\n\ttmp[written] = '\\0';\n\n\tIOT_DEBUG(\"token: %s (%d)\", tmp, written);\n\n\ttoken_buf-\u003ep = tmp;\n\ttoken_buf-\u003elen = written;\n\terr = IOT_ERROR_NONE;\n\tgoto exit_signature;\n\nexit_signature:\n\tiot_os_free(b64s_buf.p);\nexit_payload:\n\tiot_os_free(b64p_buf.p);\nexit_header:\n\tiot_os_free(b64h_buf.p);\nexit:\n\t(void)iot_security_pk_deinit(security_context);\n\t(void)iot_security_deinit(security_context);\n\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":939,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"300936":{"score":0.7576921,"function_name":"fe25519_add","code":"static inline void\nfe25519_add(fe25519 h, const fe25519 f, const fe25519 g)\n{\n    uint64_t h0 = f[0] + g[0];\n    uint64_t h1 = f[1] + g[1];\n    uint64_t h2 = f[2] + g[2];\n    uint64_t h3 = f[3] + g[3];\n    uint64_t h4 = f[4] + g[4];\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_51.h","line_number":32,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"301266":{"score":0.63042605,"function_name":"fe25519_sub","code":"static void\nfe25519_sub(fe25519 h, const fe25519 f, const fe25519 g)\n{\n    const uint64_t mask = 0x7ffffffffffffULL;\n    uint64_t h0, h1, h2, h3, h4;\n\n    h0 = g[0];\n    h1 = g[1];\n    h2 = g[2];\n    h3 = g[3];\n    h4 = g[4];\n\n    h1 += h0 \u003e\u003e 51;\n    h0 \u0026= mask;\n    h2 += h1 \u003e\u003e 51;\n    h1 \u0026= mask;\n    h3 += h2 \u003e\u003e 51;\n    h2 \u0026= mask;\n    h4 += h3 \u003e\u003e 51;\n    h3 \u0026= mask;\n    h0 += 19ULL * (h4 \u003e\u003e 51);\n    h4 \u0026= mask;\n\n    h0 = (f[0] + 0xfffffffffffdaULL) - h0;\n    h1 = (f[1] + 0xffffffffffffeULL) - h1;\n    h2 = (f[2] + 0xffffffffffffeULL) - h2;\n    h3 = (f[3] + 0xffffffffffffeULL) - h3;\n    h4 = (f[4] + 0xffffffffffffeULL) - h4;\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_51.h","line_number":52,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"301616":{"score":0.861398,"function_name":"fe25519_cmov","code":"static void\nfe25519_cmov(fe25519 f, const fe25519 g, unsigned int b)\n{\n    const uint64_t mask = (uint64_t) (-(int64_t) b);\n\n    uint64_t f0 = f[0];\n    uint64_t f1 = f[1];\n    uint64_t f2 = f[2];\n    uint64_t f3 = f[3];\n    uint64_t f4 = f[4];\n\n    uint64_t x0 = f0 ^ g[0];\n    uint64_t x1 = f1 ^ g[1];\n    uint64_t x2 = f2 ^ g[2];\n    uint64_t x3 = f3 ^ g[3];\n    uint64_t x4 = f4 ^ g[4];\n\n    x0 \u0026= mask;\n    x1 \u0026= mask;\n    x2 \u0026= mask;\n    x3 \u0026= mask;\n    x4 \u0026= mask;\n\n    f[0] = f0 ^ x0;\n    f[1] = f1 ^ x1;\n    f[2] = f2 ^ x2;\n    f[3] = f3 ^ x3;\n    f[4] = f4 ^ x4;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_51.h","line_number":108,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"302761":{"score":0.8089302,"function_name":"fe_mul","code":"void\nfe_mul(fe h, const fe f, const fe g)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t g0 = g[0];\n    int32_t g1 = g[1];\n    int32_t g2 = g[2];\n    int32_t g3 = g[3];\n    int32_t g4 = g[4];\n    int32_t g5 = g[5];\n    int32_t g6 = g[6];\n    int32_t g7 = g[7];\n    int32_t g8 = g[8];\n    int32_t g9 = g[9];\n\n    int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */\n    int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */\n    int32_t g3_19 = 19 * g3;\n    int32_t g4_19 = 19 * g4;\n    int32_t g5_19 = 19 * g5;\n    int32_t g6_19 = 19 * g6;\n    int32_t g7_19 = 19 * g7;\n    int32_t g8_19 = 19 * g8;\n    int32_t g9_19 = 19 * g9;\n    int32_t f1_2  = 2 * f1;\n    int32_t f3_2  = 2 * f3;\n    int32_t f5_2  = 2 * f5;\n    int32_t f7_2  = 2 * f7;\n    int32_t f9_2  = 2 * f9;\n\n    int64_t f0g0    = f0 * (int64_t) g0;\n    int64_t f0g1    = f0 * (int64_t) g1;\n    int64_t f0g2    = f0 * (int64_t) g2;\n    int64_t f0g3    = f0 * (int64_t) g3;\n    int64_t f0g4    = f0 * (int64_t) g4;\n    int64_t f0g5    = f0 * (int64_t) g5;\n    int64_t f0g6    = f0 * (int64_t) g6;\n    int64_t f0g7    = f0 * (int64_t) g7;\n    int64_t f0g8    = f0 * (int64_t) g8;\n    int64_t f0g9    = f0 * (int64_t) g9;\n    int64_t f1g0    = f1 * (int64_t) g0;\n    int64_t f1g1_2  = f1_2 * (int64_t) g1;\n    int64_t f1g2    = f1 * (int64_t) g2;\n    int64_t f1g3_2  = f1_2 * (int64_t) g3;\n    int64_t f1g4    = f1 * (int64_t) g4;\n    int64_t f1g5_2  = f1_2 * (int64_t) g5;\n    int64_t f1g6    = f1 * (int64_t) g6;\n    int64_t f1g7_2  = f1_2 * (int64_t) g7;\n    int64_t f1g8    = f1 * (int64_t) g8;\n    int64_t f1g9_38 = f1_2 * (int64_t) g9_19;\n    int64_t f2g0    = f2 * (int64_t) g0;\n    int64_t f2g1    = f2 * (int64_t) g1;\n    int64_t f2g2    = f2 * (int64_t) g2;\n    int64_t f2g3    = f2 * (int64_t) g3;\n    int64_t f2g4    = f2 * (int64_t) g4;\n    int64_t f2g5    = f2 * (int64_t) g5;\n    int64_t f2g6    = f2 * (int64_t) g6;\n    int64_t f2g7    = f2 * (int64_t) g7;\n    int64_t f2g8_19 = f2 * (int64_t) g8_19;\n    int64_t f2g9_19 = f2 * (int64_t) g9_19;\n    int64_t f3g0    = f3 * (int64_t) g0;\n    int64_t f3g1_2  = f3_2 * (int64_t) g1;\n    int64_t f3g2    = f3 * (int64_t) g2;\n    int64_t f3g3_2  = f3_2 * (int64_t) g3;\n    int64_t f3g4    = f3 * (int64_t) g4;\n    int64_t f3g5_2  = f3_2 * (int64_t) g5;\n    int64_t f3g6    = f3 * (int64_t) g6;\n    int64_t f3g7_38 = f3_2 * (int64_t) g7_19;\n    int64_t f3g8_19 = f3 * (int64_t) g8_19;\n    int64_t f3g9_38 = f3_2 * (int64_t) g9_19;\n    int64_t f4g0    = f4 * (int64_t) g0;\n    int64_t f4g1    = f4 * (int64_t) g1;\n    int64_t f4g2    = f4 * (int64_t) g2;\n    int64_t f4g3    = f4 * (int64_t) g3;\n    int64_t f4g4    = f4 * (int64_t) g4;\n    int64_t f4g5    = f4 * (int64_t) g5;\n    int64_t f4g6_19 = f4 * (int64_t) g6_19;\n    int64_t f4g7_19 = f4 * (int64_t) g7_19;\n    int64_t f4g8_19 = f4 * (int64_t) g8_19;\n    int64_t f4g9_19 = f4 * (int64_t) g9_19;\n    int64_t f5g0    = f5 * (int64_t) g0;\n    int64_t f5g1_2  = f5_2 * (int64_t) g1;\n    int64_t f5g2    = f5 * (int64_t) g2;\n    int64_t f5g3_2  = f5_2 * (int64_t) g3;\n    int64_t f5g4    = f5 * (int64_t) g4;\n    int64_t f5g5_38 = f5_2 * (int64_t) g5_19;\n    int64_t f5g6_19 = f5 * (int64_t) g6_19;\n    int64_t f5g7_38 = f5_2 * (int64_t) g7_19;\n    int64_t f5g8_19 = f5 * (int64_t) g8_19;\n    int64_t f5g9_38 = f5_2 * (int64_t) g9_19;\n    int64_t f6g0    = f6 * (int64_t) g0;\n    int64_t f6g1    = f6 * (int64_t) g1;\n    int64_t f6g2    = f6 * (int64_t) g2;\n    int64_t f6g3    = f6 * (int64_t) g3;\n    int64_t f6g4_19 = f6 * (int64_t) g4_19;\n    int64_t f6g5_19 = f6 * (int64_t) g5_19;\n    int64_t f6g6_19 = f6 * (int64_t) g6_19;\n    int64_t f6g7_19 = f6 * (int64_t) g7_19;\n    int64_t f6g8_19 = f6 * (int64_t) g8_19;\n    int64_t f6g9_19 = f6 * (int64_t) g9_19;\n    int64_t f7g0    = f7 * (int64_t) g0;\n    int64_t f7g1_2  = f7_2 * (int64_t) g1;\n    int64_t f7g2    = f7 * (int64_t) g2;\n    int64_t f7g3_38 = f7_2 * (int64_t) g3_19;\n    int64_t f7g4_19 = f7 * (int64_t) g4_19;\n    int64_t f7g5_38 = f7_2 * (int64_t) g5_19;\n    int64_t f7g6_19 = f7 * (int64_t) g6_19;\n    int64_t f7g7_38 = f7_2 * (int64_t) g7_19;\n    int64_t f7g8_19 = f7 * (int64_t) g8_19;\n    int64_t f7g9_38 = f7_2 * (int64_t) g9_19;\n    int64_t f8g0    = f8 * (int64_t) g0;\n    int64_t f8g1    = f8 * (int64_t) g1;\n    int64_t f8g2_19 = f8 * (int64_t) g2_19;\n    int64_t f8g3_19 = f8 * (int64_t) g3_19;\n    int64_t f8g4_19 = f8 * (int64_t) g4_19;\n    int64_t f8g5_19 = f8 * (int64_t) g5_19;\n    int64_t f8g6_19 = f8 * (int64_t) g6_19;\n    int64_t f8g7_19 = f8 * (int64_t) g7_19;\n    int64_t f8g8_19 = f8 * (int64_t) g8_19;\n    int64_t f8g9_19 = f8 * (int64_t) g9_19;\n    int64_t f9g0    = f9 * (int64_t) g0;\n    int64_t f9g1_38 = f9_2 * (int64_t) g1_19;\n    int64_t f9g2_19 = f9 * (int64_t) g2_19;\n    int64_t f9g3_38 = f9_2 * (int64_t) g3_19;\n    int64_t f9g4_19 = f9 * (int64_t) g4_19;\n    int64_t f9g5_38 = f9_2 * (int64_t) g5_19;\n    int64_t f9g6_19 = f9 * (int64_t) g6_19;\n    int64_t f9g7_38 = f9_2 * (int64_t) g7_19;\n    int64_t f9g8_19 = f9 * (int64_t) g8_19;\n    int64_t f9g9_38 = f9_2 * (int64_t) g9_19;\n\n    int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 +\n                 f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;\n    int64_t h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 +\n                 f7g4_19 + f8g3_19 + f9g2_19;\n    int64_t h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 +\n                 f7g5_38 + f8g4_19 + f9g3_38;\n    int64_t h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 +\n                 f7g6_19 + f8g5_19 + f9g4_19;\n    int64_t h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 +\n                 f7g7_38 + f8g6_19 + f9g5_38;\n    int64_t h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 +\n                 f8g7_19 + f9g6_19;\n    int64_t h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 +\n                 f7g9_38 + f8g8_19 + f9g7_38;\n    int64_t h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 +\n                 f8g9_19 + f9g8_19;\n    int64_t h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 +\n                 f8g0 + f9g9_38;\n    int64_t h9 =\n        f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    /*\n     |h0| \u003c= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))\n     i.e. |h0| \u003c= 1.4*2^60; narrower ranges for h2, h4, h6, h8\n     |h1| \u003c= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))\n     i.e. |h1| \u003c= 1.7*2^59; narrower ranges for h3, h5, h7, h9\n     */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25 */\n    /* |h4| \u003c= 2^25 */\n    /* |h1| \u003c= 1.71*2^59 */\n    /* |h5| \u003c= 1.71*2^59 */\n\n    carry1 = (h1 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h1| \u003c= 2^24; from now on fits into int32 */\n    /* |h5| \u003c= 2^24; from now on fits into int32 */\n    /* |h2| \u003c= 1.41*2^60 */\n    /* |h6| \u003c= 1.41*2^60 */\n\n    carry2 = (h2 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h2| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h6| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h3| \u003c= 1.71*2^59 */\n    /* |h7| \u003c= 1.71*2^59 */\n\n    carry3 = (h3 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h3| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h7| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h4| \u003c= 1.72*2^34 */\n    /* |h8| \u003c= 1.41*2^60 */\n\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h4| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h8| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h5| \u003c= 1.01*2^24 */\n    /* |h9| \u003c= 1.71*2^59 */\n\n    carry9 = (h9 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h0 += carry9 * 19;\n    h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h9| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h0| \u003c= 1.1*2^39 */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h1| \u003c= 1.01*2^24 */\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":493,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.13"},"325110":{"score":0.7408307,"function_name":"fe25519_mul","code":"static void\nfe25519_mul(fe25519 h, const fe25519 f, const fe25519 g)\n{\n    const uint64_t mask = 0x7ffffffffffffULL;\n    uint128_t r0, r1, r2, r3, r4, carry;\n    uint64_t  f0, f1, f2, f3, f4;\n    uint64_t  f1_19, f2_19, f3_19, f4_19;\n    uint64_t  g0, g1, g2, g3, g4;\n    uint64_t  r00, r01, r02, r03, r04;\n\n    f0 = f[0];\n    f1 = f[1];\n    f2 = f[2];\n    f3 = f[3];\n    f4 = f[4];\n\n    g0 = g[0];\n    g1 = g[1];\n    g2 = g[2];\n    g3 = g[3];\n    g4 = g[4];\n\n    f1_19 = 19ULL * f1;\n    f2_19 = 19ULL * f2;\n    f3_19 = 19ULL * f3;\n    f4_19 = 19ULL * f4;\n\n    r0  = ((uint128_t) f0   ) * ((uint128_t) g0);\n    r0 += ((uint128_t) f1_19) * ((uint128_t) g4);\n    r0 += ((uint128_t) f2_19) * ((uint128_t) g3);\n    r0 += ((uint128_t) f3_19) * ((uint128_t) g2);\n    r0 += ((uint128_t) f4_19) * ((uint128_t) g1);\n\n    r1  = ((uint128_t) f0   ) * ((uint128_t) g1);\n    r1 += ((uint128_t) f1   ) * ((uint128_t) g0);\n    r1 += ((uint128_t) f2_19) * ((uint128_t) g4);\n    r1 += ((uint128_t) f3_19) * ((uint128_t) g3);\n    r1 += ((uint128_t) f4_19) * ((uint128_t) g2);\n\n    r2  = ((uint128_t) f0   ) * ((uint128_t) g2);\n    r2 += ((uint128_t) f1   ) * ((uint128_t) g1);\n    r2 += ((uint128_t) f2   ) * ((uint128_t) g0);\n    r2 += ((uint128_t) f3_19) * ((uint128_t) g4);\n    r2 += ((uint128_t) f4_19) * ((uint128_t) g3);\n\n    r3  = ((uint128_t) f0   ) * ((uint128_t) g3);\n    r3 += ((uint128_t) f1   ) * ((uint128_t) g2);\n    r3 += ((uint128_t) f2   ) * ((uint128_t) g1);\n    r3 += ((uint128_t) f3   ) * ((uint128_t) g0);\n    r3 += ((uint128_t) f4_19) * ((uint128_t) g4);\n\n    r4  = ((uint128_t) f0   ) * ((uint128_t) g4);\n    r4 += ((uint128_t) f1   ) * ((uint128_t) g3);\n    r4 += ((uint128_t) f2   ) * ((uint128_t) g2);\n    r4 += ((uint128_t) f3   ) * ((uint128_t) g1);\n    r4 += ((uint128_t) f4   ) * ((uint128_t) g0);\n\n    r00    = ((uint64_t) r0) \u0026 mask;\n    carry  = r0 \u003e\u003e 51;\n    r1    += carry;\n    r01    = ((uint64_t) r1) \u0026 mask;\n    carry  = r1 \u003e\u003e 51;\n    r2    += carry;\n    r02    = ((uint64_t) r2) \u0026 mask;\n    carry  = r2 \u003e\u003e 51;\n    r3    += carry;\n    r03    = ((uint64_t) r3) \u0026 mask;\n    carry  = r3 \u003e\u003e 51;\n    r4    += carry;\n    r04    = ((uint64_t) r4) \u0026 mask;\n    carry  = r4 \u003e\u003e 51;\n    r00   += 19ULL * (uint64_t) carry;\n    carry  = r00 \u003e\u003e 51;\n    r00   \u0026= mask;\n    r01   += (uint64_t) carry;\n    carry  = r01 \u003e\u003e 51;\n    r01   \u0026= mask;\n    r02   += (uint64_t) carry;\n\n    h[0] = r00;\n    h[1] = r01;\n    h[2] = r02;\n    h[3] = r03;\n    h[4] = r04;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_51.h","line_number":242,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"326781":{"score":0.86710703,"function_name":"crypto_sign_ed25519_seed_keypair","code":"int\ncrypto_sign_ed25519_seed_keypair(unsigned char *pk, unsigned char *sk,\n                                 const unsigned char *seed)\n{\n    ge25519_p3 A;\n\n    crypto_hash_sha512(sk, seed, 32);\n    sk[0] \u0026= 248;\n    sk[31] \u0026= 127;\n    sk[31] |= 64;\n\n    ge25519_scalarmult_base(\u0026A, sk);\n    ge25519_p3_tobytes(pk, \u0026A);\n\n    memmove(sk, seed, 32);\n    memmove(sk + 32, pk, 32);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":12,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"327067":{"score":0.6451664,"function_name":"crypto_sign_ed25519_keypair","code":"int\ncrypto_sign_ed25519_keypair(unsigned char *pk, unsigned char *sk)\n{\n    unsigned char seed[32];\n    int           ret;\n\n    randombytes_buf(seed, sizeof seed);\n    ret = crypto_sign_ed25519_seed_keypair(pk, sk, seed);\n    sodium_memzero(seed, sizeof seed);\n\n    return ret;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":32,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"327191":{"score":0.7969331,"function_name":"crypto_sign_ed25519_pk_to_curve25519","code":"int\ncrypto_sign_ed25519_pk_to_curve25519(unsigned char *curve25519_pk,\n                                     const unsigned char *ed25519_pk)\n{\n    ge25519_p3 A;\n    fe25519    x;\n    fe25519    one_minus_y;\n\n    if (ge25519_has_small_order(ed25519_pk) != 0 ||\n        ge25519_frombytes_negate_vartime(\u0026A, ed25519_pk) != 0 ||\n        ge25519_is_on_main_subgroup(\u0026A) == 0) {\n        return -1;\n    }\n    fe25519_1(one_minus_y);\n    fe25519_sub(one_minus_y, one_minus_y, A.Y);\n    fe25519_1(x);\n    fe25519_add(x, x, A.Y);\n    fe25519_invert(one_minus_y, one_minus_y);\n    fe25519_mul(x, x, one_minus_y);\n    fe25519_tobytes(curve25519_pk, x);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":45,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"327536":{"score":0.8097168,"function_name":"crypto_sign_ed25519_sk_to_curve25519","code":"int\ncrypto_sign_ed25519_sk_to_curve25519(unsigned char *curve25519_sk,\n                                     const unsigned char *ed25519_sk)\n{\n    unsigned char h[crypto_hash_sha512_BYTES];\n\n    crypto_hash_sha512(h, ed25519_sk, 32);\n    h[0] \u0026= 248;\n    h[31] \u0026= 127;\n    h[31] |= 64;\n    memcpy(curve25519_sk, h, crypto_scalarmult_curve25519_BYTES);\n    sodium_memzero(h, sizeof h);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":69,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"353205":{"score":0.74640346,"function_name":"_crypto_sign_ed25519_verify_detached","code":"int\n_crypto_sign_ed25519_verify_detached(const unsigned char *sig,\n                                     const unsigned char *m,\n                                     unsigned long long   mlen,\n                                     const unsigned char *pk,\n                                     int prehashed)\n{\n    crypto_hash_sha512_state hs;\n    unsigned char            h[64];\n    unsigned char            rcheck[32];\n    ge25519_p3               A;\n    ge25519_p2               R;\n\n#ifdef ED25519_COMPAT\n    if (sig[63] \u0026 224) {\n        return -1;\n    }\n#else\n    if (sc25519_is_canonical(sig + 32) == 0 ||\n        ge25519_has_small_order(sig) != 0) {\n        return -1;\n    }\n    if (ge25519_is_canonical(pk) == 0 ||\n        ge25519_has_small_order(pk) != 0) {\n        return -1;\n    }\n#endif\n    if (ge25519_frombytes_negate_vartime(\u0026A, pk) != 0) {\n        return -1;\n    }\n    _crypto_sign_ed25519_ref10_hinit(\u0026hs, prehashed);\n    crypto_hash_sha512_update(\u0026hs, sig, 32);\n    crypto_hash_sha512_update(\u0026hs, pk, 32);\n    crypto_hash_sha512_update(\u0026hs, m, mlen);\n    crypto_hash_sha512_final(\u0026hs, h);\n    sc25519_reduce(h);\n\n    ge25519_double_scalarmult_vartime(\u0026R, h, \u0026A, sig + 32);\n    ge25519_tobytes(rcheck, \u0026R);\n\n    return crypto_verify_32(rcheck, sig) | (-(rcheck == sig)) |\n           sodium_memcmp(sig, rcheck, 32);\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/open.c","line_number":13,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"353779":{"score":0.8168343,"function_name":"crypto_sign_ed25519_open","code":"int\ncrypto_sign_ed25519_open(unsigned char *m, unsigned long long *mlen_p,\n                         const unsigned char *sm, unsigned long long smlen,\n                         const unsigned char *pk)\n{\n    unsigned long long mlen;\n\n    if (smlen \u003c 64 || smlen - 64 \u003e crypto_sign_ed25519_MESSAGEBYTES_MAX) {\n        goto badsig;\n    }\n    mlen = smlen - 64;\n    if (crypto_sign_ed25519_verify_detached(sm, sm + 64, mlen, pk) != 0) {\n        if (m != NULL) {\n            memset(m, 0, mlen);\n        }\n        goto badsig;\n    }\n    if (mlen_p != NULL) {\n        *mlen_p = mlen;\n    }\n    if (m != NULL) {\n        memmove(m, sm + 64, mlen);\n    }\n    return 0;\n\nbadsig:\n    if (mlen_p != NULL) {\n        *mlen_p = 0;\n    }\n    return -1;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/open.c","line_number":66,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354041":{"score":0.6857035,"function_name":"randombytes_init_if_needed","code":"static void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}","filepath":"src/libsodium/randombytes/randombytes.c","line_number":44,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354195":{"score":0.7484598,"function_name":"randombytes_stir","code":"void\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation-\u003estir != NULL) {\n        implementation-\u003estir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = 'object' === typeof window ? window : self;\n                var crypto_ = typeof window_.crypto !== 'undefined' ? window_.crypto : window_.msCrypto;\n                var randomValuesStandard = function() {\n                    var buf = new Uint32Array(1);\n                    crypto_.getRandomValues(buf);\n                    return buf[0] \u003e\u003e\u003e 0;\n                };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto');\n                    var randomValueNodeJS = function() {\n                        var buf = crypto['randomBytes'](4);\n                        return (buf[0] \u003c\u003c 24 | buf[1] \u003c\u003c 16 | buf[2] \u003c\u003c 8 | buf[3]) \u003e\u003e\u003e 0;\n                    };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }","filepath":"src/libsodium/randombytes/randombytes.c","line_number":85,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354249":{"score":0.6783646,"function_name":"randombytes_uniform","code":"uint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation-\u003euniform != NULL) {\n        return implementation-\u003euniform(upper_bound);\n    }\n#endif\n    if (upper_bound \u003c 2) {\n        return 0;\n    }","filepath":"src/libsodium/randombytes/randombytes.c","line_number":124,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354370":{"score":0.6941642,"function_name":"randombytes_buf","code":"void\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size \u003e (size_t) 0U) {\n        implementation-\u003ebuf(buf, size);\n    }\n#else\n    unsigned char *p = (unsigned char *) buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i \u003c size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}","filepath":"src/libsodium/randombytes/randombytes.c","line_number":149,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354508":{"score":0.8792351,"function_name":"randombytes_close","code":"int\nrandombytes_close(void)\n{\n    if (implementation != NULL \u0026\u0026 implementation-\u003eclose != NULL) {\n        return implementation-\u003eclose();\n    }\n    return 0;\n}","filepath":"src/libsodium/randombytes/randombytes.c","line_number":192,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354567":{"score":0.64134645,"function_name":"randombytes_buf_deterministic","code":"void\nrandombytes_buf_deterministic(void * const buf, const size_t size,\n                              const unsigned char seed[randombytes_SEEDBYTES])\n{\n    static const unsigned char nonce[crypto_stream_chacha20_ietf_NONCEBYTES] = {\n        'L', 'i', 'b', 's', 'o', 'd', 'i', 'u', 'm', 'D', 'R', 'G'\n    };\n\n    COMPILER_ASSERT(randombytes_SEEDBYTES == crypto_stream_chacha20_ietf_KEYBYTES);\n#if SIZE_MAX \u003e 0x4000000000ULL\n    COMPILER_ASSERT(randombytes_BYTES_MAX \u003c= 0x4000000000ULL);\n    if (size \u003e 0x4000000000ULL) {\n        sodium_misuse();\n    }\n#endif\n    crypto_stream_chacha20_ietf((unsigned char *) buf, (unsigned long long) size,\n                                nonce, seed);\n}","filepath":"src/libsodium/randombytes/randombytes.c","line_number":167,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354663":{"score":0.77689517,"function_name":"safe_read","code":"static ssize_t\nsafe_read(const int fd, void * const buf_, size_t size)\n{\n    unsigned char *buf = (unsigned char *) buf_;\n    ssize_t        readnb;\n\n    assert(size \u003e (size_t) 0U);\n    assert(size \u003c= SSIZE_MAX);\n    do {\n        while ((readnb = read(fd, buf, size)) \u003c (ssize_t) 0 \u0026\u0026\n               (errno == EINTR || errno == EAGAIN)); /* LCOV_EXCL_LINE */\n        if (readnb \u003c (ssize_t) 0) {\n            return readnb; /* LCOV_EXCL_LINE */\n        }\n        if (readnb == (ssize_t) 0) {\n            break; /* LCOV_EXCL_LINE */\n        }\n        size -= (size_t) readnb;\n        buf += readnb;\n    } while (size \u003e (ssize_t) 0);\n\n    return (ssize_t) (buf - (unsigned char *) buf_);\n}","filepath":"libs/libsodium/src/randombytes/salsa20/randombytes_salsa20_random.c","line_number":156,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.9"},"354868":{"score":0.917499,"function_name":"randombytes_block_on_dev_random","code":"static int\nrandombytes_block_on_dev_random(void)\n{\n    struct pollfd pfd;\n    int           fd;\n    int           pret;\n\n    fd = open(\"/dev/random\", O_RDONLY);\n    if (fd == -1) {\n        return 0;\n    }\n    pfd.fd = fd;\n    pfd.events = POLLIN;\n    pfd.revents = 0;\n    do {\n        pret = poll(\u0026pfd, 1, -1);\n    } while (pret \u003c 0 \u0026\u0026 (errno == EINTR || errno == EAGAIN));\n    if (pret != 1) {\n        (void) close(fd);\n        errno = EIO;\n        return -1;\n    }\n    return close(fd);\n}","filepath":"libs/libsodium/src/randombytes/salsa20/randombytes_salsa20_random.c","line_number":181,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.9"},"355077":{"score":0.86209345,"function_name":"randombytes_salsa20_random_random_dev_open","code":"static int\nrandombytes_salsa20_random_random_dev_open(void)\n{\n/* LCOV_EXCL_START */\n    struct stat       st;\n    static const char *devices[] = {\n#  ifndef USE_BLOCKING_RANDOM\n        \"/dev/urandom\",\n#  endif\n        \"/dev/random\", NULL\n    };\n    const char      **device = devices;\n    int               fd;\n\n# if defined(__linux__) \u0026\u0026 !defined(USE_BLOCKING_RANDOM) \u0026\u0026 !defined(NO_BLOCKING_RANDOM_POLL)\n    if (randombytes_block_on_dev_random() != 0) {\n        return -1;\n    }\n# endif\n    do {\n        fd = open(*device, O_RDONLY);\n        if (fd != -1) {\n            if (fstat(fd, \u0026st) == 0 \u0026\u0026 (S_ISNAM(st.st_mode) || S_ISCHR(st.st_mode))) {\n#  if defined(F_SETFD) \u0026\u0026 defined(FD_CLOEXEC)\n                (void) fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n#  endif\n                return fd;\n            }\n            (void) close(fd);\n        } else if (errno == EINTR) {\n            continue;\n        }\n        device++;\n    } while (*device != NULL);\n\n    errno = EIO;\n    return -1;\n/* LCOV_EXCL_STOP */\n}","filepath":"libs/libsodium/src/randombytes/salsa20/randombytes_salsa20_random.c","line_number":208,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.9"},"355326":{"score":0.8659104,"function_name":"_randombytes_linux_getrandom","code":"static int\n_randombytes_linux_getrandom(void * const buf, const size_t size)\n{\n    int readnb;\n\n    assert(size \u003c= 256U);\n    do {\n#  ifdef __dietlibc__\n        readnb = getrandom(buf, size, 0);\n#  else\n        readnb = syscall(SYS_getrandom, buf, (int) size, 0);\n#  endif\n    } while (readnb \u003c 0 \u0026\u0026 (errno == EINTR || errno == EAGAIN));\n\n    return (readnb == (int) size) - 1;\n}","filepath":"libs/libsodium/src/randombytes/salsa20/randombytes_salsa20_random.c","line_number":250,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.9"},"355464":{"score":0.91882503,"function_name":"randombytes_linux_getrandom","code":"static int\nrandombytes_linux_getrandom(void * const buf_, size_t size)\n{\n    unsigned char *buf = (unsigned char *) buf_;\n    size_t         chunk_size = 256U;\n\n    do {\n        if (size \u003c chunk_size) {\n            chunk_size = size;\n            assert(chunk_size \u003e (size_t) 0U);\n        }\n        if (_randombytes_linux_getrandom(buf, chunk_size) != 0) {\n            return -1;\n        }\n        size -= chunk_size;\n        buf += chunk_size;\n    } while (size \u003e (size_t) 0U);\n\n    return 0;\n}","filepath":"libs/libsodium/src/randombytes/salsa20/randombytes_salsa20_random.c","line_number":267,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.9"},"355602":{"score":0.7231121,"function_name":"randombytes_sysrandom_init","code":"static void\nrandombytes_sysrandom_init(void)\n{\n    const int     errno_save = errno;\n\n#  ifdef HAVE_LINUX_COMPATIBLE_GETRANDOM\n    {\n        unsigned char fodder[16];\n\n        if (randombytes_linux_getrandom(fodder, sizeof fodder) == 0) {\n            stream.getrandom_available = 1;\n            errno = errno_save;\n            return;\n        }\n        stream.getrandom_available = 0;\n    }\n#  endif\n\n    if ((stream.random_data_source_fd =\n         randombytes_sysrandom_random_dev_open()) == -1) {\n        sodium_misuse(); /* LCOV_EXCL_LINE */\n    }\n    errno = errno_save;\n}","filepath":"src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c","line_number":258,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"355757":{"score":0.6497827,"function_name":"randombytes_sysrandom_stir","code":"static void\nrandombytes_sysrandom_stir(void)\n{\n    if (stream.initialized == 0) {\n        randombytes_sysrandom_init();\n        stream.initialized = 1;\n    }\n}","filepath":"src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c","line_number":291,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"355841":{"score":0.81940585,"function_name":"randombytes_sysrandom_close","code":"static int\nrandombytes_sysrandom_close(void)\n{\n    int ret = -1;\n\n# ifndef _WIN32\n    if (stream.random_data_source_fd != -1 \u0026\u0026\n        close(stream.random_data_source_fd) == 0) {\n        stream.random_data_source_fd = -1;\n        stream.initialized = 0;\n        ret = 0;\n    }\n#  ifdef HAVE_LINUX_COMPATIBLE_GETRANDOM\n    if (stream.getrandom_available != 0) {\n        ret = 0;\n    }\n#  endif\n# else /* _WIN32 */\n    if (stream.initialized != 0) {\n        stream.initialized = 0;\n        ret = 0;\n    }","filepath":"src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c","line_number":308,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"355951":{"score":0.70734227,"function_name":"randombytes_sysrandom_buf","code":"static void\nrandombytes_sysrandom_buf(void * const buf, const size_t size)\n{\n    randombytes_sysrandom_stir_if_needed();\n# if defined(ULLONG_MAX) \u0026\u0026 defined(SIZE_MAX)\n#  if SIZE_MAX \u003e ULLONG_MAX\n    /* coverity[result_independent_of_operands] */\n    assert(size \u003c= ULLONG_MAX);\n#  endif\n# endif\n# ifndef _WIN32\n#  ifdef HAVE_LINUX_COMPATIBLE_GETRANDOM\n    if (stream.getrandom_available != 0) {\n        if (randombytes_linux_getrandom(buf, size) != 0) {\n            sodium_misuse(); /* LCOV_EXCL_LINE */\n        }\n        return;\n    }\n#  endif\n    if (stream.random_data_source_fd == -1 ||\n        safe_read(stream.random_data_source_fd, buf, size) != (ssize_t) size) {\n        sodium_misuse(); /* LCOV_EXCL_LINE */\n    }\n# else /* _WIN32 */\n    COMPILER_ASSERT(randombytes_BYTES_MAX \u003c= 0xffffffffUL);\n    if (size \u003e (size_t) 0xffffffffUL) {\n        sodium_misuse(); /* LCOV_EXCL_LINE */\n    }\n    if (! RtlGenRandom((PVOID) buf, (ULONG) size)) {\n        sodium_misuse(); /* LCOV_EXCL_LINE */\n    }\n# endif /* _WIN32 */\n}","filepath":"src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c","line_number":334,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"356065":{"score":0.422305,"function_name":"_unprotected_ptr_from_user_ptr","code":"static unsigned char *\n_unprotected_ptr_from_user_ptr(void *const ptr)\n{\n    uintptr_t      unprotected_ptr_u;\n    unsigned char *canary_ptr;\n    size_t         page_mask;\n\n    canary_ptr = ((unsigned char *) ptr) - sizeof canary;\n    page_mask = page_size - 1U;\n    unprotected_ptr_u = ((uintptr_t) canary_ptr \u0026 (uintptr_t) ~page_mask);\n    if (unprotected_ptr_u \u003c= page_size * 2U) {\n        sodium_misuse(); /* LCOV_EXCL_LINE */\n    }\n    return (unsigned char *) unprotected_ptr_u;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":558,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"381667":{"score":0.7019187,"function_name":"_crypto_sign_ed25519_ref10_hinit","code":"void\n_crypto_sign_ed25519_ref10_hinit(crypto_hash_sha512_state *hs, int prehashed)\n{\n    static const unsigned char DOM2PREFIX[32 + 2] = {\n        'S', 'i', 'g', 'E', 'd', '2', '5', '5', '1', '9', ' ',\n        'n', 'o', ' ',\n        'E', 'd', '2', '5', '5', '1', '9', ' ',\n        'c', 'o', 'l', 'l', 'i', 's', 'i', 'o', 'n', 's', 1, 0\n    };\n\n    crypto_hash_sha512_init(hs);\n    if (prehashed) {\n        crypto_hash_sha512_update(hs, DOM2PREFIX, sizeof DOM2PREFIX);\n    }\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/sign.c","line_number":11,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"381805":{"score":0.85659605,"function_name":"_crypto_sign_ed25519_detached","code":"int\n_crypto_sign_ed25519_detached(unsigned char *sig, unsigned long long *siglen_p,\n                              const unsigned char *m, unsigned long long mlen,\n                              const unsigned char *sk, int prehashed)\n{\n    crypto_hash_sha512_state hs;\n    unsigned char            az[64];\n    unsigned char            nonce[64];\n    unsigned char            hram[64];\n    ge25519_p3               R;\n\n    _crypto_sign_ed25519_ref10_hinit(\u0026hs, prehashed);\n\n#ifdef ED25519_NONDETERMINISTIC\n    memcpy(az, sk, 32);\n    _crypto_sign_ed25519_synthetic_r_hv(\u0026hs, nonce, az);\n#else\n    crypto_hash_sha512(az, sk, 32);\n    crypto_hash_sha512_update(\u0026hs, az + 32, 32);\n#endif\n\n    crypto_hash_sha512_update(\u0026hs, m, mlen);\n    crypto_hash_sha512_final(\u0026hs, nonce);\n\n    memmove(sig + 32, sk + 32, 32);\n\n    sc25519_reduce(nonce);\n    ge25519_scalarmult_base(\u0026R, nonce);\n    ge25519_p3_tobytes(sig, \u0026R);\n\n    _crypto_sign_ed25519_ref10_hinit(\u0026hs, prehashed);\n    crypto_hash_sha512_update(\u0026hs, sig, 64);\n    crypto_hash_sha512_update(\u0026hs, m, mlen);\n    crypto_hash_sha512_final(\u0026hs, hram);\n\n    sc25519_reduce(hram);\n    _crypto_sign_ed25519_clamp(az);\n    sc25519_muladd(sig + 32, hram, az, nonce);\n\n    sodium_memzero(az, sizeof az);\n    sodium_memzero(nonce, sizeof nonce);\n\n    if (siglen_p != NULL) {\n        *siglen_p = 64U;\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/sign.c","line_number":64,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"383041":{"score":0.69128007,"function_name":"crypto_sign_ed25519ph_final_create","code":"int\ncrypto_sign_ed25519ph_final_create(crypto_sign_ed25519ph_state *state,\n                                   unsigned char               *sig,\n                                   unsigned long long          *siglen_p,\n                                   const unsigned char         *sk)\n{\n    unsigned char ph[crypto_hash_sha512_BYTES];\n\n    crypto_hash_sha512_final(\u0026state-\u003ehs, ph);\n\n    return _crypto_sign_ed25519_detached(sig, siglen_p, ph, sizeof ph, sk, 1);\n}","filepath":"src/libsodium/crypto_sign/ed25519/sign_ed25519.c","line_number":74,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"383165":{"score":0.76516855,"function_name":"crypto_sign_ed25519ph_final_verify","code":"int\ncrypto_sign_ed25519ph_final_verify(crypto_sign_ed25519ph_state *state,\n                                   unsigned char               *sig,\n                                   const unsigned char         *pk)\n{\n    unsigned char ph[crypto_hash_sha512_BYTES];\n\n    crypto_hash_sha512_final(\u0026state-\u003ehs, ph);\n\n    return _crypto_sign_ed25519_verify_detached(sig, ph, sizeof ph, pk, 1);\n}","filepath":"src/libsodium/crypto_sign/ed25519/sign_ed25519.c","line_number":87,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"383400":{"score":0.5274012,"function_name":"crypto_stream_chacha20_xor","code":"int\ncrypto_stream_chacha20_xor(unsigned char *c, const unsigned char *m,\n                           unsigned long long mlen, const unsigned char *n,\n                           const unsigned char *k)\n{\n    if (mlen \u003e crypto_stream_chacha20_MESSAGEBYTES_MAX) {\n        sodium_misuse();\n    }\n    return implementation-\u003estream_xor_ic(c, m, mlen, n, 0U, k);\n}","filepath":"libs/libsodium/src/crypto_stream/chacha20/stream_chacha20.c","line_number":75,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.10"},"383906":{"score":0.46212125,"function_name":"crypto_secretbox_easy","code":"int\ncrypto_secretbox_easy(unsigned char *c, const unsigned char *m,\n                      unsigned long long mlen, const unsigned char *n,\n                      const unsigned char *k)\n{\n    if (mlen \u003e crypto_secretbox_MESSAGEBYTES_MAX) {\n        sodium_misuse();\n    }\n    return crypto_secretbox_detached(c + crypto_secretbox_MACBYTES,\n                                     c, m, mlen, n, k);\n}","filepath":"src/libsodium/src/libsodium/crypto_secretbox/crypto_secretbox_easy.c","line_number":70,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"383979":{"score":0.5130043,"function_name":"crypto_stream_chacha20_ietf_xor_ic","code":"int\ncrypto_stream_chacha20_ietf_xor_ic(unsigned char *c, const unsigned char *m,\n                                   unsigned long long mlen,\n                                   const unsigned char *n, uint32_t ic,\n                                   const unsigned char *k)\n{\n    if ((unsigned long long) ic \u003e\n        (64ULL * (1ULL \u003c\u003c 32)) / 64ULL - (mlen + 63ULL) / 64ULL) {\n        sodium_misuse();\n    }\n    return crypto_stream_chacha20_ietf_ext_xor_ic(c, m, mlen, n, ic, k);\n}","filepath":"libs/libsodium/src/crypto_stream/chacha20/stream_chacha20.c","line_number":129,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.10"},"384336":{"score":0.8253719,"function_name":"sodium_memzero","code":"void\nsodium_memzero(void * const pnt, const size_t len)\n{\n#ifdef _WIN32\n    SecureZeroMemory(pnt, len);\n#elif defined(HAVE_MEMSET_S)\n    if (len \u003e 0U \u0026\u0026 memset_s(pnt, (rsize_t) len, 0, (rsize_t) len) != 0) {\n        sodium_misuse(); /* LCOV_EXCL_LINE */\n    }\n#elif defined(HAVE_EXPLICIT_BZERO)\n    explicit_bzero(pnt, len);\n#elif defined(HAVE_EXPLICIT_MEMSET)\n    explicit_memset(pnt, 0, len);\n#elif HAVE_WEAK_SYMBOLS\n    if (len \u003e 0U) {\n        memset(pnt, 0, len);\n        _sodium_dummy_symbol_to_prevent_memzero_lto(pnt, len);\n    }\n# ifdef HAVE_INLINE_ASM\n    __asm__ __volatile__ (\"\" : : \"r\"(pnt) : \"memory\");\n# endif\n#else\n    volatile unsigned char *volatile pnt_ =\n        (volatile unsigned char *volatile) pnt;\n    size_t i = (size_t) 0U;\n\n    while (i \u003c len) {\n        pnt_[i++] = 0U;\n    }\n#endif\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":117,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384435":{"score":0.8488639,"function_name":"sodium_memcmp","code":"int\nsodium_memcmp(const void *const b1_, const void *const b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = (const unsigned char *) b1_;\n    const unsigned char *b2 = (const unsigned char *) b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char *volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char *volatile) b2_;\n#endif\n    size_t                 i;\n    volatile unsigned char d = 0U;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_memcmp_lto(b1, b2, len);\n#endif\n    for (i = 0U; i \u003c len; i++) {\n        d |= b1[i] ^ b2[i];\n    }\n    return (1 \u0026 ((d - 1) \u003e\u003e 8)) - 1;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":176,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384580":{"score":0.7822082,"function_name":"sodium_compare","code":"int\nsodium_compare(const unsigned char *b1_, const unsigned char *b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = b1_;\n    const unsigned char *b2 = b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char *volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char *volatile) b2_;\n#endif\n    size_t                 i;\n    volatile unsigned char gt = 0U;\n    volatile unsigned char eq = 1U;\n    uint16_t               x1, x2;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_compare_lto(b1, b2, len);\n#endif\n    i = len;\n    while (i != 0U) {\n        i--;\n        x1 = b1[i];\n        x2 = b2[i];\n        gt |= ((x2 - x1) \u003e\u003e 8) \u0026 eq;\n        eq \u0026= ((x2 ^ x1) - 1) \u003e\u003e 8;\n    }\n    return (int) (gt + gt + eq) - 1;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":216,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384785":{"score":0.8546696,"function_name":"sodium_is_zero","code":"int\nsodium_is_zero(const unsigned char *n, const size_t nlen)\n{\n    size_t                 i;\n    volatile unsigned char d = 0U;\n\n    for (i = 0U; i \u003c nlen; i++) {\n        d |= n[i];\n    }\n    return 1 \u0026 ((d - 1) \u003e\u003e 8);\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":247,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384864":{"score":0.77081364,"function_name":"sodium_increment","code":"void\nsodium_increment(unsigned char *n, const size_t nlen)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 1U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64, t64_2;\n    uint32_t t32;\n\n    if (nlen == 12U) {\n        __asm__ __volatile__(\n            \"xorq %[t64], %[t64] \\n\"\n            \"xorl %[t32], %[t32] \\n\"\n            \"stc \\n\"\n            \"adcq %[t64], (%[out]) \\n\"\n            \"adcl %[t32], 8(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t32] \"=\u0026r\"(t32)\n            : [out] \"D\"(n)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 24U) {\n        __asm__ __volatile__(\n            \"movq $1, %[t64] \\n\"\n            \"xorq %[t64_2], %[t64_2] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcq %[t64_2], 8(%[out]) \\n\"\n            \"adcq %[t64_2], 16(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t64_2] \"=\u0026r\"(t64_2)\n            : [out] \"D\"(n)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 8U) {\n        __asm__ __volatile__(\"incq (%[out]) \\n\"\n                             :\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i \u003c nlen; i++) {\n        c += (uint_fast16_t) n[i];\n        n[i] = (unsigned char) c;\n        c \u003e\u003e= 8;\n    }\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":259,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384945":{"score":0.6963277,"function_name":"sodium_add","code":"void\nsodium_add(unsigned char *a, const unsigned char *b, const size_t len)\n{\n    size_t        i;\n    uint_fast16_t c = 0U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64, t64_2, t64_3;\n    uint32_t t32;\n\n    if (len == 12U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"movl 8(%[in]), %[t32] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcl %[t32], 8(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t32] \"=\u0026r\"(t32)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 24U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"movq 8(%[in]), %[t64_2] \\n\"\n            \"movq 16(%[in]), %[t64_3] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcq %[t64_2], 8(%[out]) \\n\"\n            \"adcq %[t64_3], 16(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t64_2] \"=\u0026r\"(t64_2), [t64_3] \"=\u0026r\"(t64_3)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 8U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (i = 0U; i \u003c len; i++) {\n        c += (uint_fast16_t) a[i] + (uint_fast16_t) b[i];\n        a[i] = (unsigned char) c;\n        c \u003e\u003e= 8;\n    }\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":306,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385042":{"score":0.71681285,"function_name":"sodium_sub","code":"void\nsodium_sub(unsigned char *a, const unsigned char *b, const size_t len)\n{\n    uint_fast16_t c = 0U;\n    size_t        i;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64_1, t64_2, t64_3, t64_4;\n    uint64_t t64_5, t64_6, t64_7, t64_8;\n    uint32_t t32;\n\n    if (len == 64U) {\n        __asm__ __volatile__(\n            \"movq   (%[in]), %[t64_1] \\n\"\n            \"movq  8(%[in]), %[t64_2] \\n\"\n            \"movq 16(%[in]), %[t64_3] \\n\"\n            \"movq 24(%[in]), %[t64_4] \\n\"\n            \"movq 32(%[in]), %[t64_5] \\n\"\n            \"movq 40(%[in]), %[t64_6] \\n\"\n            \"movq 48(%[in]), %[t64_7] \\n\"\n            \"movq 56(%[in]), %[t64_8] \\n\"\n            \"subq %[t64_1],   (%[out]) \\n\"\n            \"sbbq %[t64_2],  8(%[out]) \\n\"\n            \"sbbq %[t64_3], 16(%[out]) \\n\"\n            \"sbbq %[t64_4], 24(%[out]) \\n\"\n            \"sbbq %[t64_5], 32(%[out]) \\n\"\n            \"sbbq %[t64_6], 40(%[out]) \\n\"\n            \"sbbq %[t64_7], 48(%[out]) \\n\"\n            \"sbbq %[t64_8], 56(%[out]) \\n\"\n            : [t64_1] \"=\u0026r\"(t64_1), [t64_2] \"=\u0026r\"(t64_2), [t64_3] \"=\u0026r\"(t64_3), [t64_4] \"=\u0026r\"(t64_4),\n              [t64_5] \"=\u0026r\"(t64_5), [t64_6] \"=\u0026r\"(t64_6), [t64_7] \"=\u0026r\"(t64_7), [t64_8] \"=\u0026r\"(t64_8)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (i = 0U; i \u003c len; i++) {\n        c = (uint_fast16_t) a[i] - (uint_fast16_t) b[i] - c;\n        a[i] = (unsigned char) c;\n        c = (c \u003e\u003e 8) \u0026 1U;\n    }\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":355,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385242":{"score":0.7223728,"function_name":"_sodium_mprotect","code":"static int\n_sodium_mprotect(void *ptr, int (*cb)(void *ptr, size_t size))\n{\n    (void) ptr;\n    (void) cb;\n    errno = ENOSYS;\n    return -1;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":689,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385474":{"score":0.8082293,"function_name":"sodium_malloc","code":"__attribute__((malloc)) void *\nsodium_malloc(const size_t size)\n{\n    void *ptr;\n\n    if ((ptr = _sodium_malloc(size)) == NULL) {\n        return NULL;\n    }\n    memset(ptr, (int) GARBAGE_VALUE, size);\n\n    return ptr;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":626,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385552":{"score":0.886334,"function_name":"sodium_allocarray","code":"__attribute__((malloc)) void *\nsodium_allocarray(size_t count, size_t size)\n{\n    if (count \u003e (size_t) 0U \u0026\u0026 size \u003e= (size_t) SIZE_MAX / count) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    return sodium_malloc(count * size);\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":639,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385835":{"score":0.8800096,"function_name":"sodium_pad","code":"int\nsodium_pad(size_t *padded_buflen_p, unsigned char *buf,\n           size_t unpadded_buflen, size_t blocksize, size_t max_buflen)\n{\n    unsigned char          *tail;\n    size_t                  i;\n    size_t                  xpadlen;\n    size_t                  xpadded_len;\n    volatile unsigned char  mask;\n    unsigned char           barrier_mask;\n\n    if (blocksize \u003c= 0U) {\n        return -1;\n    }\n    xpadlen = blocksize - 1U;\n    if ((blocksize \u0026 (blocksize - 1U)) == 0U) {\n        xpadlen -= unpadded_buflen \u0026 (blocksize - 1U);\n    } else {\n        xpadlen -= unpadded_buflen % blocksize;\n    }\n    if ((size_t) SIZE_MAX - unpadded_buflen \u003c= xpadlen) {\n        sodium_misuse();\n    }\n    xpadded_len = unpadded_buflen + xpadlen;\n    if (xpadded_len \u003e= max_buflen) {\n        return -1;\n    }\n    tail = \u0026buf[xpadded_len];\n    if (padded_buflen_p != NULL) {\n        *padded_buflen_p = xpadded_len + 1U;\n    }\n    mask = 0U;\n    for (i = 0; i \u003c blocksize; i++) {\n        barrier_mask = (unsigned char) (((i ^ xpadlen) - 1U)\n           \u003e\u003e ((sizeof(size_t) - 1) * CHAR_BIT));\n        *(tail - i) = ((*(tail - i)) \u0026 mask) | (0x80 \u0026 barrier_mask);\n        mask |= barrier_mask;\n    }\n    return 0;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":731,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"386106":{"score":0.88531685,"function_name":"sodium_unpad","code":"int\nsodium_unpad(size_t *unpadded_buflen_p, const unsigned char *buf,\n             size_t padded_buflen, size_t blocksize)\n{\n    const unsigned char *tail;\n    unsigned char        acc = 0U;\n    unsigned char        c;\n    unsigned char        valid = 0U;\n    volatile size_t      pad_len = 0U;\n    size_t               i;\n    size_t               is_barrier;\n\n    if (padded_buflen \u003c blocksize || blocksize \u003c= 0U) {\n        return -1;\n    }\n    tail = \u0026buf[padded_buflen - 1U];\n\n    for (i = 0U; i \u003c blocksize; i++) {\n        c = *(tail - i);\n        is_barrier =\n            (( (acc - 1U) \u0026 (pad_len - 1U) \u0026 ((c ^ 0x80) - 1U) ) \u003e\u003e 8) \u0026 1U;\n        acc |= c;\n        pad_len |= i \u0026 (1U + ~is_barrier);\n        valid |= (unsigned char) is_barrier;\n    }\n    *unpadded_buflen_p = padded_buflen - 1U - pad_len;\n\n    return (int) (valid - 1U);\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":772,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"386574":{"score":0.8763672,"function_name":"aes_gen_tables","code":"static void aes_gen_tables( void )\n{\n    int i, x, y, z;\n    int pow[256];\n    int log[256];\n\n    /*\n     * compute pow and log tables over GF(2^8)\n     */\n    for( i = 0, x = 1; i \u003c 256; i++ )\n    {\n        pow[i] = x;\n        log[x] = i;\n        x = ( x ^ XTIME( x ) ) \u0026 0xFF;\n    }\n\n    /*\n     * calculate the round constants\n     */\n    for( i = 0, x = 1; i \u003c 10; i++ )\n    {\n        RCON[i] = (uint32_t) x;\n        x = XTIME( x ) \u0026 0xFF;\n    }\n\n    /*\n     * generate the forward and reverse S-boxes\n     */\n    FSb[0x00] = 0x63;\n    RSb[0x63] = 0x00;\n\n    for( i = 1; i \u003c 256; i++ )\n    {\n        x = pow[255 - log[i]];\n\n        y  = x; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y ^ 0x63;\n\n        FSb[i] = (unsigned char) x;\n        RSb[x] = (unsigned char) i;\n    }\n\n    /*\n     * generate the forward and reverse tables\n     */\n    for( i = 0; i \u003c 256; i++ )\n    {\n        x = FSb[i];\n        y = XTIME( x ) \u0026 0xFF;\n        z =  ( y ^ x ) \u0026 0xFF;\n\n        FT0[i] = ( (uint32_t) y       ) ^\n                 ( (uint32_t) x \u003c\u003c  8 ) ^\n                 ( (uint32_t) x \u003c\u003c 16 ) ^\n                 ( (uint32_t) z \u003c\u003c 24 );\n\n        FT1[i] = ROTL8( FT0[i] );\n        FT2[i] = ROTL8( FT1[i] );\n        FT3[i] = ROTL8( FT2[i] );\n\n        x = RSb[i];\n\n        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^\n                 ( (uint32_t) MUL( 0x09, x ) \u003c\u003c  8 ) ^\n                 ( (uint32_t) MUL( 0x0D, x ) \u003c\u003c 16 ) ^\n                 ( (uint32_t) MUL( 0x0B, x ) \u003c\u003c 24 );\n\n        RT1[i] = ROTL8( RT0[i] );\n        RT2[i] = ROTL8( RT1[i] );\n        RT3[i] = ROTL8( RT2[i] );\n    }\n}","filepath":"library/aes.c","line_number":389,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.5.0-rc1"},"388057":{"score":0.88358945,"function_name":"mbedtls_aes_setkey_enc","code":"int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    unsigned int i;\n    uint32_t *RK;\n\n    AES_VALIDATE_RET( ctx != NULL );\n    AES_VALIDATE_RET( key != NULL );\n\n    switch( keybits )\n    {\n        case 128: ctx-\u003enr = 10; break;\n        case 192: ctx-\u003enr = 12; break;\n        case 256: ctx-\u003enr = 14; break;\n        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );\n    }\n\n#if !defined(MBEDTLS_AES_ROM_TABLES)\n    if( aes_init_done == 0 )\n    {\n        aes_gen_tables();\n        aes_init_done = 1;\n    }\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C) \u0026\u0026 defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx-\u003erk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx-\u003ebuf );\n    else\n#endif\n    ctx-\u003erk = RK = ctx-\u003ebuf;\n\n#if defined(MBEDTLS_AESNI_C) \u0026\u0026 defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx-\u003erk, key, keybits ) );\n#endif\n\n    for( i = 0; i \u003c ( keybits \u003e\u003e 5 ); i++ )\n    {\n        GET_UINT32_LE( RK[i], key, i \u003c\u003c 2 );\n    }\n\n    switch( ctx-\u003enr )\n    {\n        case 10:\n\n            for( i = 0; i \u003c 10; i++, RK += 4 )\n            {\n                RK[4]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[3] \u003e\u003e  8 ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[3] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[3] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[3]       ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[5]  = RK[1] ^ RK[4];\n                RK[6]  = RK[2] ^ RK[5];\n                RK[7]  = RK[3] ^ RK[6];\n            }\n            break;\n\n        case 12:\n\n            for( i = 0; i \u003c 8; i++, RK += 6 )\n            {\n                RK[6]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[5] \u003e\u003e  8 ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[5] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[5] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[5]       ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[7]  = RK[1] ^ RK[6];\n                RK[8]  = RK[2] ^ RK[7];\n                RK[9]  = RK[3] ^ RK[8];\n                RK[10] = RK[4] ^ RK[9];\n                RK[11] = RK[5] ^ RK[10];\n            }\n            break;\n\n        case 14:\n\n            for( i = 0; i \u003c 7; i++, RK += 8 )\n            {\n                RK[8]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[7] \u003e\u003e  8 ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[7] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[7] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[7]       ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[9]  = RK[1] ^ RK[8];\n                RK[10] = RK[2] ^ RK[9];\n                RK[11] = RK[3] ^ RK[10];\n\n                RK[12] = RK[4] ^\n                ( (uint32_t) FSb[ ( RK[11]       ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[11] \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[11] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[11] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[13] = RK[5] ^ RK[12];\n                RK[14] = RK[6] ^ RK[13];\n                RK[15] = RK[7] ^ RK[14];\n            }\n            break;\n    }\n\n    return( 0 );\n}","filepath":"library/aes.c","line_number":581,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.8"},"389391":{"score":0.73359454,"function_name":"mbedtls_aes_setkey_dec","code":"int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    int i, j, ret;\n    mbedtls_aes_context cty;\n    uint32_t *RK;\n    uint32_t *SK;\n\n    mbedtls_aes_init( \u0026cty );\n\n#if defined(MBEDTLS_PADLOCK_C) \u0026\u0026 defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx-\u003erk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx-\u003ebuf );\n    else\n#endif\n    ctx-\u003erk = RK = ctx-\u003ebuf;\n\n    /* Also checks keybits */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026cty, key, keybits ) ) != 0 )\n        goto exit;\n\n    ctx-\u003enr = cty.nr;\n\n#if defined(MBEDTLS_AESNI_C) \u0026\u0026 defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n    {\n        mbedtls_aesni_inverse_key( (unsigned char *) ctx-\u003erk,\n                           (const unsigned char *) cty.rk, ctx-\u003enr );\n        goto exit;\n    }\n#endif\n\n    SK = cty.rk + cty.nr * 4;\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\n    for( i = ctx-\u003enr - 1, SK -= 8; i \u003e 0; i--, SK -= 8 )\n    {\n        for( j = 0; j \u003c 4; j++, SK++ )\n        {\n            *RK++ = RT0[ FSb[ ( *SK       ) \u0026 0xFF ] ] ^\n                    RT1[ FSb[ ( *SK \u003e\u003e  8 ) \u0026 0xFF ] ] ^\n                    RT2[ FSb[ ( *SK \u003e\u003e 16 ) \u0026 0xFF ] ] ^\n                    RT3[ FSb[ ( *SK \u003e\u003e 24 ) \u0026 0xFF ] ];\n        }\n    }\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\nexit:\n    mbedtls_aes_free( \u0026cty );\n\n    return( ret );\n}","filepath":"library/aes.c","line_number":598,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.5.0-rc1"},"390143":{"score":0.8858328,"function_name":"mbedtls_internal_aes_decrypt","code":"int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,\n                                  const unsigned char input[16],\n                                  unsigned char output[16] )\n{\n    int i;\n    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n    RK = ctx-\u003erk;\n\n    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    for( i = ( ctx-\u003enr \u003e\u003e 1 ) - 1; i \u003e 0; i-- )\n    {\n        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n    }\n\n    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n    X0 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y0       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y3 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y2 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y1 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    X1 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y1       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y0 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y3 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y2 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    X2 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y2       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y1 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y0 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y3 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    X3 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y3       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y2 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y1 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y0 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    PUT_UINT32_LE( X0, output,  0 );\n    PUT_UINT32_LE( X1, output,  4 );\n    PUT_UINT32_LE( X2, output,  8 );\n    PUT_UINT32_LE( X3, output, 12 );\n\n    return( 0 );\n}","filepath":"library/aes.c","line_number":772,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.5.0-rc1"},"394641":{"score":0.8663802,"function_name":"asn1_get_len","code":"int asn1_get_len( unsigned char **p,\n                  const unsigned char *end,\n                  size_t *len )\n{\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    if( ( **p \u0026 0x80 ) == 0 )\n        *len = *(*p)++;\n    else\n    {\n        switch( **p \u0026 0x7F )\n        {\n        case 1:\n            if( ( end - *p ) \u003c 2 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = (*p)[1];\n            (*p) += 2;\n            break;\n\n        case 2:\n            if( ( end - *p ) \u003c 3 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = ( (size_t)(*p)[1] \u003c\u003c 8 ) | (*p)[2];\n            (*p) += 3;\n            break;\n\n        case 3:\n            if( ( end - *p ) \u003c 4 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = ( (size_t)(*p)[1] \u003c\u003c 16 ) |\n                   ( (size_t)(*p)[2] \u003c\u003c 8  ) | (*p)[3];\n            (*p) += 4;\n            break;\n\n        case 4:\n            if( ( end - *p ) \u003c 5 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = ( (size_t)(*p)[1] \u003c\u003c 24 ) | ( (size_t)(*p)[2] \u003c\u003c 16 ) |\n                   ( (size_t)(*p)[3] \u003c\u003c 8  ) |           (*p)[4];\n            (*p) += 5;\n            break;\n\n        default:\n            return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n        }\n    }\n\n    if( *len \u003e (size_t) ( end - *p ) )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":55,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"395190":{"score":0.8397801,"function_name":"asn1_get_tag","code":"int asn1_get_tag( unsigned char **p,\n                  const unsigned char *end,\n                  size_t *len, int tag )\n{\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    if( **p != tag )\n        return( POLARSSL_ERR_ASN1_UNEXPECTED_TAG );\n\n    (*p)++;\n\n    return( asn1_get_len( p, end, len ) );\n}","filepath":"library/asn1parse.c","line_number":113,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"395281":{"score":0.8455606,"function_name":"asn1_get_bool","code":"int asn1_get_bool( unsigned char **p,\n                   const unsigned char *end,\n                   int *val )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len, ASN1_BOOLEAN ) ) != 0 )\n        return( ret );\n\n    if( len != 1 )\n        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n\n    *val = ( **p != 0 ) ? 1 : 0;\n    (*p)++;\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":128,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"395433":{"score":0.88004804,"function_name":"asn1_get_int","code":"int asn1_get_int( unsigned char **p,\n                  const unsigned char *end,\n                  int *val )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len, ASN1_INTEGER ) ) != 0 )\n        return( ret );\n\n    if( len == 0 || len \u003e sizeof( int ) || ( **p \u0026 0x80 ) != 0 )\n        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n\n    *val = 0;\n\n    while( len-- \u003e 0 )\n    {\n        *val = ( *val \u003c\u003c 8 ) | **p;\n        (*p)++;\n    }\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":147,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"395635":{"score":0.82090724,"function_name":"asn1_get_mpi","code":"int asn1_get_mpi( unsigned char **p,\n                  const unsigned char *end,\n                  mpi *X )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len, ASN1_INTEGER ) ) != 0 )\n        return( ret );\n\n    ret = mpi_read_binary( X, *p, len );\n\n    *p += len;\n\n    return( ret );\n}","filepath":"library/asn1parse.c","line_number":172,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"395783":{"score":0.8764039,"function_name":"asn1_get_bitstring","code":"int asn1_get_bitstring( unsigned char **p, const unsigned char *end,\n                        asn1_bitstring *bs)\n{\n    int ret;\n\n    /* Certificate type is a single byte bitstring */\n    if( ( ret = asn1_get_tag( p, end, \u0026bs-\u003elen, ASN1_BIT_STRING ) ) != 0 )\n        return( ret );\n\n    /* Check length, subtract one for actual bit string length */\n    if( bs-\u003elen \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n    bs-\u003elen -= 1;\n\n    /* Get number of unused bits, ensure unused bits \u003c= 7 */\n    bs-\u003eunused_bits = **p;\n    if( bs-\u003eunused_bits \u003e 7 )\n        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n    (*p)++;\n\n    /* Get actual bitstring */\n    bs-\u003ep = *p;\n    *p += bs-\u003elen;\n\n    if( *p != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":190,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"395959":{"score":0.8996192,"function_name":"asn1_get_bitstring_null","code":"int asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,\n                             size_t *len )\n{\n    int ret;\n\n    if( ( ret = asn1_get_tag( p, end, len, ASN1_BIT_STRING ) ) != 0 )\n        return( ret );\n\n    if( (*len)-- \u003c 2 || *(*p)++ != 0 )\n        return( POLARSSL_ERR_ASN1_INVALID_DATA );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":223,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"396060":{"score":0.88157296,"function_name":"asn1_get_sequence_of","code":"int asn1_get_sequence_of( unsigned char **p,\n                          const unsigned char *end,\n                          asn1_sequence *cur,\n                          int tag)\n{\n    int ret;\n    size_t len;\n    asn1_buf *buf;\n\n    /* Get main sequence tag */\n    if( ( ret = asn1_get_tag( p, end, \u0026len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n        return( ret );\n\n    if( *p + len != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    while( *p \u003c end )\n    {\n        buf = \u0026(cur-\u003ebuf);\n        buf-\u003etag = **p;\n\n        if( ( ret = asn1_get_tag( p, end, \u0026buf-\u003elen, tag ) ) != 0 )\n            return( ret );\n\n        buf-\u003ep = *p;\n        *p += buf-\u003elen;\n\n        /* Allocate and assign next pointer */\n        if( *p \u003c end )\n        {\n            cur-\u003enext = polarssl_malloc( sizeof( asn1_sequence ) );\n\n            if( cur-\u003enext == NULL )\n                return( POLARSSL_ERR_ASN1_MALLOC_FAILED );\n\n            memset( cur-\u003enext, 0, sizeof( asn1_sequence ) );\n\n            cur = cur-\u003enext;\n        }\n    }\n\n    /* Set final sequence entry's next pointer to NULL */\n    cur-\u003enext = NULL;\n\n    if( *p != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":242,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"396392":{"score":0.905897,"function_name":"asn1_get_alg","code":"int asn1_get_alg( unsigned char **p,\n                  const unsigned char *end,\n                  asn1_buf *alg, asn1_buf *params )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n        return( ret );\n\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    alg-\u003etag = **p;\n    end = *p + len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026alg-\u003elen, ASN1_OID ) ) != 0 )\n        return( ret );\n\n    alg-\u003ep = *p;\n    *p += alg-\u003elen;\n\n    if( *p == end )\n    {\n        polarssl_zeroize( params, sizeof(asn1_buf) );\n        return( 0 );\n    }\n\n    params-\u003etag = **p;\n    (*p)++;\n\n    if( ( ret = asn1_get_len( p, end, \u0026params-\u003elen ) ) != 0 )\n        return( ret );\n\n    params-\u003ep = *p;\n    *p += params-\u003elen;\n\n    if( *p != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":293,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"396779":{"score":0.86124843,"function_name":"asn1_get_alg_null","code":"int asn1_get_alg_null( unsigned char **p,\n                       const unsigned char *end,\n                       asn1_buf *alg )\n{\n    int ret;\n    asn1_buf params;\n\n    memset( \u0026params, 0, sizeof(asn1_buf) );\n\n    if( ( ret = asn1_get_alg( p, end, alg, \u0026params ) ) != 0 )\n        return( ret );\n\n    if( ( params.tag != ASN1_NULL \u0026\u0026 params.tag != 0 ) || params.len != 0 )\n        return( POLARSSL_ERR_ASN1_INVALID_DATA );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":337,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"396938":{"score":0.8088929,"function_name":"asn1_free_named_data","code":"void asn1_free_named_data( asn1_named_data *cur )\n{\n    if( cur == NULL )\n        return;\n\n    polarssl_free( cur-\u003eoid.p );\n    polarssl_free( cur-\u003eval.p );\n\n    polarssl_zeroize( cur, sizeof( asn1_named_data ) );\n}","filepath":"library/asn1parse.c","line_number":355,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"397022":{"score":0.8646832,"function_name":"asn1_free_named_data_list","code":"void asn1_free_named_data_list( asn1_named_data **head )\n{\n    asn1_named_data *cur;\n\n    while( ( cur = *head ) != NULL )\n    {\n        *head = cur-\u003enext;\n        asn1_free_named_data( cur );\n        polarssl_free( cur );\n    }\n}","filepath":"library/asn1parse.c","line_number":366,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"397101":{"score":0.9255292,"function_name":"asn1_find_named_data","code":"asn1_named_data *asn1_find_named_data( asn1_named_data *list,\n                                       const char *oid, size_t len )\n{\n    while( list != NULL )\n    {\n        if( list-\u003eoid.len == len \u0026\u0026\n            memcmp( list-\u003eoid.p, oid, len ) == 0 )\n        {\n            break;\n        }\n\n        list = list-\u003enext;\n    }\n\n    return( list );\n}","filepath":"library/asn1parse.c","line_number":378,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.18"},"397186":{"score":0.8898867,"function_name":"mbedtls_base64_encode","code":"int mbedtls_base64_encode( unsigned char *dst, size_t dlen, size_t *olen,\n                   const unsigned char *src, size_t slen )\n{\n    size_t i, n;\n    int C1, C2, C3;\n    unsigned char *p;\n\n    if( slen == 0 )\n    {\n        *olen = 0;\n        return( 0 );\n    }\n\n    n = slen / 3 + ( slen % 3 != 0 );\n\n    if( n \u003e ( BASE64_SIZE_T_MAX - 1 ) / 4 )\n    {\n        *olen = BASE64_SIZE_T_MAX;\n        return( MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL );\n    }\n\n    n *= 4;\n\n    if( dlen \u003c n + 1 )\n    {\n        *olen = n + 1;\n        return( MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL );\n    }\n\n    n = ( slen / 3 ) * 3;\n\n    for( i = 0, p = dst; i \u003c n; i += 3 )\n    {\n        C1 = *src++;\n        C2 = *src++;\n        C3 = *src++;\n\n        *p++ = base64_enc_map[(C1 \u003e\u003e 2) \u0026 0x3F];\n        *p++ = base64_enc_map[(((C1 \u0026  3) \u003c\u003c 4) + (C2 \u003e\u003e 4)) \u0026 0x3F];\n        *p++ = base64_enc_map[(((C2 \u0026 15) \u003c\u003c 2) + (C3 \u003e\u003e 6)) \u0026 0x3F];\n        *p++ = base64_enc_map[C3 \u0026 0x3F];\n    }\n\n    if( i \u003c slen )\n    {\n        C1 = *src++;\n        C2 = ( ( i + 1 ) \u003c slen ) ? *src++ : 0;\n\n        *p++ = base64_enc_map[(C1 \u003e\u003e 2) \u0026 0x3F];\n        *p++ = base64_enc_map[(((C1 \u0026 3) \u003c\u003c 4) + (C2 \u003e\u003e 4)) \u0026 0x3F];\n\n        if( ( i + 1 ) \u003c slen )\n             *p++ = base64_enc_map[((C2 \u0026 15) \u003c\u003c 2) \u0026 0x3F];\n        else *p++ = '=';\n\n        *p++ = '=';\n    }\n\n    *olen = p - dst;\n    *p = 0;\n\n    return( 0 );\n}","filepath":"library/base64.c","line_number":77,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.1.7-rc1"},"397846":{"score":0.8916703,"function_name":"mbedtls_base64_decode","code":"int mbedtls_base64_decode( unsigned char *dst, size_t dlen, size_t *olen,\n                   const unsigned char *src, size_t slen )\n{\n    size_t i, n;\n    uint32_t j, x;\n    unsigned char *p;\n\n    /* First pass: check for validity and get output length */\n    for( i = n = j = 0; i \u003c slen; i++ )\n    {\n        /* Skip spaces before checking for EOL */\n        x = 0;\n        while( i \u003c slen \u0026\u0026 src[i] == ' ' )\n        {\n            ++i;\n            ++x;\n        }\n\n        /* Spaces at end of buffer are OK */\n        if( i == slen )\n            break;\n\n        if( ( slen - i ) \u003e= 2 \u0026\u0026\n            src[i] == '\\r' \u0026\u0026 src[i + 1] == '\\n' )\n            continue;\n\n        if( src[i] == '\\n' )\n            continue;\n\n        /* Space inside a line is an error */\n        if( x != 0 )\n            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );\n\n        if( src[i] == '=' \u0026\u0026 ++j \u003e 2 )\n            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );\n\n        if( src[i] \u003e 127 || base64_dec_map[src[i]] == 127 )\n            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );\n\n        if( base64_dec_map[src[i]] \u003c 64 \u0026\u0026 j != 0 )\n            return( MBEDTLS_ERR_BASE64_INVALID_CHARACTER );\n\n        n++;\n    }\n\n    if( n == 0 )\n    {\n        *olen = 0;\n        return( 0 );\n    }\n\n    /* The following expression is to calculate the following formula without\n     * risk of integer overflow in n:\n     *     n = ( ( n * 6 ) + 7 ) \u003e\u003e 3;\n     */\n    n = ( 6 * ( n \u003e\u003e 3 ) ) + ( ( 6 * ( n \u0026 0x7 ) + 7 ) \u003e\u003e 3 );\n    n -= j;\n\n    if( dst == NULL || dlen \u003c n )\n    {\n        *olen = n;\n        return( MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL );\n    }\n\n   for( j = 3, n = x = 0, p = dst; i \u003e 0; i--, src++ )\n   {\n        if( *src == '\\r' || *src == '\\n' || *src == ' ' )\n            continue;\n\n        j -= ( base64_dec_map[*src] == 64 );\n        x  = ( x \u003c\u003c 6 ) | ( base64_dec_map[*src] \u0026 0x3F );\n\n        if( ++n == 4 )\n        {\n            n = 0;\n            if( j \u003e 0 ) *p++ = (unsigned char)( x \u003e\u003e 16 );\n            if( j \u003e 1 ) *p++ = (unsigned char)( x \u003e\u003e  8 );\n            if( j \u003e 2 ) *p++ = (unsigned char)( x       );\n        }\n    }\n\n    *olen = p - dst;\n\n    return( 0 );\n}","filepath":"library/base64.c","line_number":144,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.1.7-rc1"},"398656":{"score":0.8427242,"function_name":"mbedtls_mpi_free","code":"void mbedtls_mpi_free( mbedtls_mpi *X )\n{\n    if( X == NULL )\n        return;\n\n    if( X-\u003ep != NULL )\n    {\n        mbedtls_mpi_zeroize( X-\u003ep, X-\u003en );\n        mbedtls_free( X-\u003ep );\n    }\n\n    X-\u003es = 1;\n    X-\u003en = 0;\n    X-\u003ep = NULL;\n}","filepath":"lib/mbedtls-2.28.0/library/bignum.c","line_number":98,"entry_url":"https://github.com/fluent/fluent-bit.git","slot_name":"v1.8.12"},"398770":{"score":0.88536084,"function_name":"mbedtls_mpi_grow","code":"int mbedtls_mpi_grow( mbedtls_mpi *X, size_t nblimbs )\n{\n    mbedtls_mpi_uint *p;\n    MPI_VALIDATE_RET( X != NULL );\n\n    if( nblimbs \u003e MBEDTLS_MPI_MAX_LIMBS )\n        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n\n    if( X-\u003en \u003c nblimbs )\n    {\n        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )\n            return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n\n        if( X-\u003ep != NULL )\n        {\n            memcpy( p, X-\u003ep, X-\u003en * ciL );\n            mbedtls_mpi_zeroize( X-\u003ep, X-\u003en );\n            mbedtls_free( X-\u003ep );\n        }\n\n        X-\u003en = nblimbs;\n        X-\u003ep = p;\n    }\n\n    return( 0 );\n}","filepath":"lib/mbedtls-2.28.0/library/bignum.c","line_number":117,"entry_url":"https://github.com/fluent/fluent-bit.git","slot_name":"v1.8.12"},"398970":{"score":0.83721215,"function_name":"mbedtls_mpi_shrink","code":"int mbedtls_mpi_shrink( mbedtls_mpi *X, size_t nblimbs )\n{\n    mbedtls_mpi_uint *p;\n    size_t i;\n    MPI_VALIDATE_RET( X != NULL );\n\n    if( nblimbs \u003e MBEDTLS_MPI_MAX_LIMBS )\n        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n\n    /* Actually resize up if there are currently fewer than nblimbs limbs. */\n    if( X-\u003en \u003c= nblimbs )\n        return( mbedtls_mpi_grow( X, nblimbs ) );\n    /* After this point, then X-\u003en \u003e nblimbs and in particular X-\u003en \u003e 0. */\n\n    for( i = X-\u003en - 1; i \u003e 0; i-- )\n        if( X-\u003ep[i] != 0 )\n            break;\n    i++;\n\n    if( i \u003c nblimbs )\n        i = nblimbs;\n\n    if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( i, ciL ) ) == NULL )\n        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n\n    if( X-\u003ep != NULL )\n    {\n        memcpy( p, X-\u003ep, i * ciL );\n        mbedtls_mpi_zeroize( X-\u003ep, X-\u003en );\n        mbedtls_free( X-\u003ep );\n    }\n\n    X-\u003en = i;\n    X-\u003ep = p;\n\n    return( 0 );\n}","filepath":"lib/mbedtls-2.28.0/library/bignum.c","line_number":148,"entry_url":"https://github.com/fluent/fluent-bit.git","slot_name":"v1.8.12"},"399250":{"score":0.8768082,"function_name":"mbedtls_mpi_copy","code":"int mbedtls_mpi_copy( mbedtls_mpi *X, const mbedtls_mpi *Y )\n{\n    int ret = 0;\n    size_t i;\n\n    if( X == Y )\n        return( 0 );\n\n    if( Y-\u003ep == NULL )\n    {\n        mbedtls_mpi_free( X );\n        return( 0 );\n    }\n\n    for( i = Y-\u003en - 1; i \u003e 0; i-- )\n        if( Y-\u003ep[i] != 0 )\n            break;\n    i++;\n\n    X-\u003es = Y-\u003es;\n\n    if( X-\u003en \u003c i )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );\n    }\n    else\n    {\n        memset( X-\u003ep + i, 0, ( X-\u003en - i ) * ciL );\n    }\n\n    memcpy( X-\u003ep, Y-\u003ep, i * ciL );\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":182,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"399639":{"score":0.83663666,"function_name":"mbedtls_mpi_safe_cond_assign","code":"int mbedtls_mpi_safe_cond_assign( mbedtls_mpi *X, const mbedtls_mpi *Y, unsigned char assign )\n{\n    int ret = 0;\n    size_t i;\n\n    /* make sure assign is 0 or 1 in a time-constant manner */\n    assign = (assign | (unsigned char)-assign) \u003e\u003e 7;\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y-\u003en ) );\n\n    X-\u003es = X-\u003es * ( 1 - assign ) + Y-\u003es * assign;\n\n    for( i = 0; i \u003c Y-\u003en; i++ )\n        X-\u003ep[i] = X-\u003ep[i] * ( 1 - assign ) + Y-\u003ep[i] * assign;\n\n    for( ; i \u003c X-\u003en; i++ )\n        X-\u003ep[i] *= ( 1 - assign );\n\ncleanup:\n    return( ret );\n}","filepath":"src/ref-impl/tls/library/bignum.c","line_number":216,"entry_url":"https://github.com/aliyun/iotkit-embedded.git","slot_name":"RELEASED_V2.30"},"399937":{"score":0.8703143,"function_name":"mbedtls_mpi_safe_cond_swap","code":"int mbedtls_mpi_safe_cond_swap( mbedtls_mpi *X, mbedtls_mpi *Y, unsigned char swap )\n{\n    int ret, s;\n    size_t i;\n    mbedtls_mpi_uint tmp;\n\n    if( X == Y )\n        return( 0 );\n\n    /* make sure swap is 0 or 1 in a time-constant manner */\n    swap = (swap | (unsigned char)-swap) \u003e\u003e 7;\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y-\u003en ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( Y, X-\u003en ) );\n\n    s = X-\u003es;\n    X-\u003es = X-\u003es * ( 1 - swap ) + Y-\u003es * swap;\n    Y-\u003es = Y-\u003es * ( 1 - swap ) +    s * swap;\n\n\n    for( i = 0; i \u003c X-\u003en; i++ )\n    {\n        tmp = X-\u003ep[i];\n        X-\u003ep[i] = X-\u003ep[i] * ( 1 - swap ) + Y-\u003ep[i] * swap;\n        Y-\u003ep[i] = Y-\u003ep[i] * ( 1 - swap ) +     tmp * swap;\n    }\n\ncleanup:\n    return( ret );\n}","filepath":"src/ref-impl/tls/library/bignum.c","line_number":244,"entry_url":"https://github.com/aliyun/iotkit-embedded.git","slot_name":"RELEASED_V2.30"},"400346":{"score":0.74760306,"function_name":"mpi_lset","code":"int mpi_lset( mpi *X, t_sint z )\n{\n    int ret;\n\n    MPI_CHK( mpi_grow( X, 1 ) );\n    memset( X-\u003ep, 0, X-\u003en * ciL );\n\n    X-\u003ep[0] = ( z \u003c 0 ) ? -z : z;\n    X-\u003es    = ( z \u003c 0 ) ? -1 : 1;\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":158,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"400546":{"score":0.8728001,"function_name":"mbedtls_mpi_set_bit","code":"int mbedtls_mpi_set_bit( mbedtls_mpi *X, size_t pos, unsigned char val )\n{\n    int ret = 0;\n    size_t off = pos / biL;\n    size_t idx = pos % biL;\n    MPI_VALIDATE_RET( X != NULL );\n\n    if( val != 0 \u0026\u0026 val != 1 )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    if( X-\u003en * biL \u003c= pos )\n    {\n        if( val == 0 )\n            return( 0 );\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, off + 1 ) );\n    }\n\n    X-\u003ep[off] \u0026= ~( (mbedtls_mpi_uint) 0x01 \u003c\u003c idx );\n    X-\u003ep[off] |= (mbedtls_mpi_uint) val \u003c\u003c idx;\n\ncleanup:\n\n    return( ret );\n}","filepath":"lib/mbedtls-2.28.0/library/bignum.c","line_number":312,"entry_url":"https://github.com/fluent/fluent-bit.git","slot_name":"v1.8.12"},"400784":{"score":0.8819132,"function_name":"mpi_lsb","code":"size_t mpi_lsb( const mpi *X )\n{\n    size_t i, j, count = 0;\n\n    for( i = 0; i \u003c X-\u003en; i++ )\n        for( j = 0; j \u003c biL; j++, count++ )\n            if( ( ( X-\u003ep[i] \u003e\u003e j ) \u0026 1 ) != 0 )\n                return( count );\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":214,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"400898":{"score":0.8020052,"function_name":"int_clz","code":"static size_t int_clz( const t_uint x )\n{\n    size_t j;\n    t_uint mask = (t_uint) 1 \u003c\u003c (biL - 1);\n\n    for( j = 0; j \u003c biL; j++ )\n    {\n        if( x \u0026 mask ) break;\n\n        mask \u003e\u003e= 1;\n    }\n\n    return j;\n}","filepath":"library/bignum.c","line_number":367,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"400961":{"score":0.8337346,"function_name":"mpi_msb","code":"size_t mpi_msb( const mpi *X )\n{\n    size_t i, j;\n\n    for( i = X-\u003en - 1; i \u003e 0; i-- )\n        if( X-\u003ep[i] != 0 )\n            break;\n\n    j = biL - int_clz( X-\u003ep[i] );\n\n    return( ( i * biL ) + j );\n}","filepath":"library/bignum.c","line_number":261,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.19"},"401125":{"score":0.92221576,"function_name":"mpi_get_digit","code":"static int mpi_get_digit( t_uint *d, int radix, char c )\n{\n    *d = 255;\n\n    if( c \u003e= 0x30 \u0026\u0026 c \u003c= 0x39 ) *d = c - 0x30;\n    if( c \u003e= 0x41 \u0026\u0026 c \u003c= 0x46 ) *d = c - 0x37;\n    if( c \u003e= 0x61 \u0026\u0026 c \u003c= 0x66 ) *d = c - 0x57;\n\n    if( *d \u003e= (t_uint) radix )\n        return( POLARSSL_ERR_MPI_INVALID_CHARACTER );\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":255,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"401260":{"score":0.81813693,"function_name":"mpi_read_string","code":"int mpi_read_string( mpi *X, int radix, const char *s )\n{\n    int ret;\n    size_t i, j, slen, n;\n    t_uint d;\n    mpi T;\n\n    if( radix \u003c 2 || radix \u003e 16 )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    mpi_init( \u0026T );\n\n    slen = strlen( s );\n\n    if( radix == 16 )\n    {\n        if( slen \u003e MPI_SIZE_T_MAX \u003e\u003e 2 )\n            return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n        n = BITS_TO_LIMBS( slen \u003c\u003c 2 );\n\n        MPI_CHK( mpi_grow( X, n ) );\n        MPI_CHK( mpi_lset( X, 0 ) );\n\n        for( i = slen, j = 0; i \u003e 0; i--, j++ )\n        {\n            if( i == 1 \u0026\u0026 s[i - 1] == '-' )\n            {\n                X-\u003es = -1;\n                break;\n            }\n\n            MPI_CHK( mpi_get_digit( \u0026d, radix, s[i - 1] ) );\n            X-\u003ep[j / ( 2 * ciL )] |= d \u003c\u003c ( ( j % ( 2 * ciL ) ) \u003c\u003c 2 );\n        }\n    }\n    else\n    {\n        MPI_CHK( mpi_lset( X, 0 ) );\n\n        for( i = 0; i \u003c slen; i++ )\n        {\n            if( i == 0 \u0026\u0026 s[i] == '-' )\n            {\n                X-\u003es = -1;\n                continue;\n            }\n\n            MPI_CHK( mpi_get_digit( \u0026d, radix, s[i] ) );\n            MPI_CHK( mpi_mul_int( \u0026T, X, radix ) );\n\n            if( X-\u003es == 1 )\n            {\n                MPI_CHK( mpi_add_int( X, \u0026T, d ) );\n            }\n            else\n            {\n                MPI_CHK( mpi_sub_int( X, \u0026T, d ) );\n            }\n        }\n    }\n\ncleanup:\n\n    mpi_free( \u0026T );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":429,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"401966":{"score":0.84842837,"function_name":"mpi_write_hlp","code":"static int mpi_write_hlp( mbedtls_mpi *X, int radix, char **p )\n{\n    int ret;\n    mbedtls_mpi_uint r;\n\n    if( radix \u003c 2 || radix \u003e 16 )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( \u0026r, X, radix ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_div_int( X, NULL, X, radix ) );\n\n    if( mbedtls_mpi_cmp_int( X, 0 ) != 0 )\n        MBEDTLS_MPI_CHK( mpi_write_hlp( X, radix, p ) );\n\n    if( r \u003c 10 )\n        *(*p)++ = (char)( r + 0x30 );\n    else\n        *(*p)++ = (char)( r + 0x37 );\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":508,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.14.1"},"402229":{"score":0.84900135,"function_name":"mbedtls_mpi_write_string","code":"int mbedtls_mpi_write_string( const mbedtls_mpi *X, int radix,\n                              char *buf, size_t buflen, size_t *olen )\n{\n    int ret = 0;\n    size_t n;\n    char *p;\n    mbedtls_mpi T;\n\n    if( radix \u003c 2 || radix \u003e 16 )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    n = mbedtls_mpi_bitlen( X ); /* Number of bits necessary to present `n`. */\n    if( radix \u003e=  4 ) n \u003e\u003e= 1;   /* Number of 4-adic digits necessary to present\n                                  * `n`. If radix \u003e 4, this might be a strict\n                                  * overapproximation of the number of\n                                  * radix-adic digits needed to present `n`. */\n    if( radix \u003e= 16 ) n \u003e\u003e= 1;   /* Number of hexadecimal digits necessary to\n                                  * present `n`. */\n\n    n += 1; /* Terminating null byte */\n    n += 1; /* Compensate for the divisions above, which round down `n`\n             * in case it's not even. */\n    n += 1; /* Potential '-'-sign. */\n    n += ( n \u0026 1 ); /* Make n even to have enough space for hexadecimal writing,\n                     * which always uses an even number of hex-digits. */\n\n    if( buflen \u003c n )\n    {\n        *olen = n;\n        return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );\n    }\n\n    p = buf;\n    mbedtls_mpi_init( \u0026T );\n\n    if( X-\u003es == -1 )\n    {\n        *p++ = '-';\n        buflen--;\n    }\n\n    if( radix == 16 )\n    {\n        int c;\n        size_t i, j, k;\n\n        for( i = X-\u003en, k = 0; i \u003e 0; i-- )\n        {\n            for( j = ciL; j \u003e 0; j-- )\n            {\n                c = ( X-\u003ep[i - 1] \u003e\u003e ( ( j - 1 ) \u003c\u003c 3) ) \u0026 0xFF;\n\n                if( c == 0 \u0026\u0026 k == 0 \u0026\u0026 ( i + j ) != 2 )\n                    continue;\n\n                *(p++) = \"0123456789ABCDEF\" [c / 16];\n                *(p++) = \"0123456789ABCDEF\" [c % 16];\n                k = 1;\n            }\n        }\n    }\n    else\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026T, X ) );\n\n        if( T.s == -1 )\n            T.s = 1;\n\n        MBEDTLS_MPI_CHK( mpi_write_hlp( \u0026T, radix, \u0026p, buflen ) );\n    }\n\n    *p++ = '\\0';\n    *olen = p - buf;\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026T );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":544,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.12"},"402798":{"score":0.8075259,"function_name":"mpi_read_binary","code":"int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen )\n{\n    int ret;\n    size_t i, j;\n    size_t const limbs = CHARS_TO_LIMBS( buflen );\n\n    /* Ensure that target MPI has exactly the necessary number of limbs */\n    if( X-\u003en != limbs )\n    {\n        mpi_free( X );\n        mpi_init( X );\n        MPI_CHK( mpi_grow( X, limbs ) );\n    }\n\n    MPI_CHK( mpi_lset( X, 0 ) );\n\n    for( i = buflen, j = 0; i \u003e 0; i--, j++ )\n        X-\u003ep[j / ciL] |= ((t_uint) buf[i - 1]) \u003c\u003c ((j % ciL) \u003c\u003c 3);\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":678,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"403039":{"score":0.85667294,"function_name":"mbedtls_mpi_write_binary","code":"int mbedtls_mpi_write_binary( const mbedtls_mpi *X,\n                              unsigned char *buf, size_t buflen )\n{\n    size_t stored_bytes = X-\u003en * ciL;\n    size_t bytes_to_copy;\n    unsigned char *p;\n    size_t i;\n\n    if( stored_bytes \u003c buflen )\n    {\n        /* There is enough space in the output buffer. Write initial\n         * null bytes and record the position at which to start\n         * writing the significant bytes. In this case, the execution\n         * trace of this function does not depend on the value of the\n         * number. */\n        bytes_to_copy = stored_bytes;\n        p = buf + buflen - stored_bytes;\n        memset( buf, 0, buflen - stored_bytes );\n    }\n    else\n    {\n        /* The output buffer is smaller than the allocated size of X.\n         * However X may fit if its leading bytes are zero. */\n        bytes_to_copy = buflen;\n        p = buf;\n        for( i = bytes_to_copy; i \u003c stored_bytes; i++ )\n        {\n            if( GET_BYTE( X, i ) != 0 )\n                return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );\n        }\n    }\n\n    for( i = 0; i \u003c bytes_to_copy; i++ )\n        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":769,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.19"},"403278":{"score":0.8778147,"function_name":"mpi_shift_l","code":"int mpi_shift_l( mpi *X, size_t count )\n{\n    int ret;\n    size_t i, v0, t1;\n    t_uint r0 = 0, r1;\n\n    v0 = count / (biL    );\n    t1 = count \u0026 (biL - 1);\n\n    i = mpi_msb( X ) + count;\n\n    if( X-\u003en * biL \u003c i )\n        MPI_CHK( mpi_grow( X, BITS_TO_LIMBS( i ) ) );\n\n    ret = 0;\n\n    /*\n     * shift by count / limb_size\n     */\n    if( v0 \u003e 0 )\n    {\n        for( i = X-\u003en; i \u003e v0; i-- )\n            X-\u003ep[i - 1] = X-\u003ep[i - v0 - 1];\n\n        for( ; i \u003e 0; i-- )\n            X-\u003ep[i - 1] = 0;\n    }\n\n    /*\n     * shift by count % limb_size\n     */\n    if( t1 \u003e 0 )\n    {\n        for( i = v0; i \u003c X-\u003en; i++ )\n        {\n            r1 = X-\u003ep[i] \u003e\u003e (biL - t1);\n            X-\u003ep[i] \u003c\u003c= t1;\n            X-\u003ep[i] |= r0;\n            r0 = r1;\n        }\n    }\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":556,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"403694":{"score":0.8770627,"function_name":"mpi_shift_r","code":"int mpi_shift_r( mpi *X, size_t count )\n{\n    size_t i, v0, v1;\n    t_uint r0 = 0, r1;\n\n    v0 = count /  biL;\n    v1 = count \u0026 (biL - 1);\n\n    if( v0 \u003e X-\u003en || ( v0 == X-\u003en \u0026\u0026 v1 \u003e 0 ) )\n        return mpi_lset( X, 0 );\n\n    /*\n     * shift by count / limb_size\n     */\n    if( v0 \u003e 0 )\n    {\n        for( i = 0; i \u003c X-\u003en - v0; i++ )\n            X-\u003ep[i] = X-\u003ep[i + v0];\n\n        for( ; i \u003c X-\u003en; i++ )\n            X-\u003ep[i] = 0;\n    }\n\n    /*\n     * shift by count % limb_size\n     */\n    if( v1 \u003e 0 )\n    {\n        for( i = X-\u003en; i \u003e 0; i-- )\n        {\n            r1 = X-\u003ep[i - 1] \u003c\u003c (biL - v1);\n            X-\u003ep[i - 1] \u003e\u003e= v1;\n            X-\u003ep[i - 1] |= r0;\n            r0 = r1;\n        }\n    }\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":606,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"404086":{"score":0.9272784,"function_name":"mpi_cmp_abs","code":"int mpi_cmp_abs( const mpi *X, const mpi *Y )\n{\n    size_t i, j;\n\n    for( i = X-\u003en; i \u003e 0; i-- )\n        if( X-\u003ep[i - 1] != 0 )\n            break;\n\n    for( j = Y-\u003en; j \u003e 0; j-- )\n        if( Y-\u003ep[j - 1] != 0 )\n            break;\n\n    if( i == 0 \u0026\u0026 j == 0 )\n        return( 0 );\n\n    if( i \u003e j ) return(  1 );\n    if( j \u003e i ) return( -1 );\n\n    for( ; i \u003e 0; i-- )\n    {\n        if( X-\u003ep[i - 1] \u003e Y-\u003ep[i - 1] ) return(  1 );\n        if( X-\u003ep[i - 1] \u003c Y-\u003ep[i - 1] ) return( -1 );\n    }\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":649,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"404384":{"score":0.92944324,"function_name":"mpi_cmp_mpi","code":"int mpi_cmp_mpi( const mpi *X, const mpi *Y )\n{\n    size_t i, j;\n\n    for( i = X-\u003en; i \u003e 0; i-- )\n        if( X-\u003ep[i - 1] != 0 )\n            break;\n\n    for( j = Y-\u003en; j \u003e 0; j-- )\n        if( Y-\u003ep[j - 1] != 0 )\n            break;\n\n    if( i == 0 \u0026\u0026 j == 0 )\n        return( 0 );\n\n    if( i \u003e j ) return(  X-\u003es );\n    if( j \u003e i ) return( -X-\u003es );\n\n    if( X-\u003es \u003e 0 \u0026\u0026 Y-\u003es \u003c 0 ) return(  1 );\n    if( Y-\u003es \u003e 0 \u0026\u0026 X-\u003es \u003c 0 ) return( -1 );\n\n    for( ; i \u003e 0; i-- )\n    {\n        if( X-\u003ep[i - 1] \u003e Y-\u003ep[i - 1] ) return(  X-\u003es );\n        if( X-\u003ep[i - 1] \u003c Y-\u003ep[i - 1] ) return( -X-\u003es );\n    }\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":674,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.1.0-rc1"},"404746":{"score":0.81149423,"function_name":"mpi_cmp_int","code":"int mpi_cmp_int( const mpi *X, t_sint z )\n{\n    mpi Y;\n    t_uint p[1];\n\n    *p  = ( z \u003c 0 ) ? -z : z;\n    Y.s = ( z \u003c 0 ) ? -1 : 1;\n    Y.n = 1;\n    Y.p = p;\n\n    return( mpi_cmp_mpi( X, \u0026Y ) );\n}","filepath":"library/bignum.c","line_number":712,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"404861":{"score":0.9113504,"function_name":"mbedtls_mpi_add_abs","code":"int mbedtls_mpi_add_abs( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )\n{\n    int ret;\n    size_t i, j;\n    mbedtls_mpi_uint *o, *p, c;\n\n    if( X == B )\n    {\n        const mbedtls_mpi *T = A; A = X; B = T;\n    }\n\n    if( X != A )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );\n\n    /*\n     * X should always be positive as a result of unsigned additions.\n     */\n    X-\u003es = 1;\n\n    for( j = B-\u003en; j \u003e 0; j-- )\n        if( B-\u003ep[j - 1] != 0 )\n            break;\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );\n\n    o = B-\u003ep; p = X-\u003ep; c = 0;\n\n    for( i = 0; i \u003c j; i++, o++, p++ )\n    {\n        *p +=  c; c  = ( *p \u003c  c );\n        *p += *o; c += ( *p \u003c *o );\n    }\n\n    while( c != 0 )\n    {\n        if( i \u003e= X-\u003en )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );\n            p = X-\u003ep + i;\n        }\n\n        *p += c; c = ( *p \u003c c ); i++; p++;\n    }\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":882,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.2.1"},"405276":{"score":0.92679894,"function_name":"mpi_sub_hlp","code":"static void mpi_sub_hlp( size_t n, t_uint *s, t_uint *d )\n{\n    size_t i;\n    t_uint c, z;\n\n    for( i = c = 0; i \u003c n; i++, s++, d++ )\n    {\n        z = ( *d \u003c  c );     *d -=  c;\n        c = ( *d \u003c *s ) + z; *d -= *s;\n    }\n\n    while( c != 0 )\n    {\n        z = ( *d \u003c c ); *d -= c;\n        c = z; i++; d++;\n    }\n}","filepath":"library/bignum.c","line_number":780,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"405455":{"score":0.8497546,"function_name":"mpi_sub_abs","code":"int mpi_sub_abs( mpi *X, const mpi *A, const mpi *B )\n{\n    mpi TB;\n    int ret;\n    size_t n;\n\n    if( mpi_cmp_abs( A, B ) \u003c 0 )\n        return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );\n\n    mpi_init( \u0026TB );\n\n    if( X == B )\n    {\n        MPI_CHK( mpi_copy( \u0026TB, B ) );\n        B = \u0026TB;\n    }\n\n    if( X != A )\n        MPI_CHK( mpi_copy( X, A ) );\n\n    /*\n     * X should always be positive as a result of unsigned subtractions.\n     */\n    X-\u003es = 1;\n\n    ret = 0;\n\n    for( n = B-\u003en; n \u003e 0; n-- )\n        if( B-\u003ep[n - 1] != 0 )\n            break;\n\n    mpi_sub_hlp( n, B-\u003ep, X-\u003ep );\n\ncleanup:\n\n    mpi_free( \u0026TB );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":961,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"405756":{"score":0.8638394,"function_name":"mbedtls_mpi_add_mpi","code":"int mbedtls_mpi_add_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )\n{\n    int ret, s = A-\u003es;\n\n    if( A-\u003es * B-\u003es \u003c 0 )\n    {\n        if( mbedtls_mpi_cmp_abs( A, B ) \u003e= 0 )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );\n            X-\u003es =  s;\n        }\n        else\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );\n            X-\u003es = -s;\n        }\n    }\n    else\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );\n        X-\u003es = s;\n    }\n\ncleanup:\n\n    return( ret );\n}","filepath":"src/ref-impl/tls/library/bignum.c","line_number":995,"entry_url":"https://github.com/aliyun/iotkit-embedded.git","slot_name":"RELEASED_V2.30"},"405948":{"score":0.87508446,"function_name":"mbedtls_mpi_sub_mpi","code":"int mbedtls_mpi_sub_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )\n{\n    int ret, s = A-\u003es;\n\n    if( A-\u003es * B-\u003es \u003e 0 )\n    {\n        if( mbedtls_mpi_cmp_abs( A, B ) \u003e= 0 )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );\n            X-\u003es =  s;\n        }\n        else\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );\n            X-\u003es = -s;\n        }\n    }\n    else\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );\n        X-\u003es = s;\n    }\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1075,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.14.1"},"406140":{"score":0.77906966,"function_name":"mpi_sub_int","code":"int mpi_sub_int( mpi *X, const mpi *A, t_sint b )\n{\n    mpi _B;\n    t_uint p[1];\n\n    p[0] = ( b \u003c 0 ) ? -b : b;\n    _B.s = ( b \u003c 0 ) ? -1 : 1;\n    _B.n = 1;\n    _B.p = p;\n\n    return( mpi_sub_mpi( X, A, \u0026_B ) );\n}","filepath":"library/bignum.c","line_number":922,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"406267":{"score":0.76224196,"function_name":"mpi_sub_int","code":"int mpi_sub_int( mpi *X, const mpi *A, int b )\n{\n    mpi _B;\n    t_int p[1];\n\n    p[0] = ( b \u003c 0 ) ? -b : b;\n    _B.s = ( b \u003c 0 ) ? -1 : 1;\n    _B.n = 1;\n    _B.p = p;\n\n    return( mpi_sub_mpi( X, A, \u0026_B ) );\n}","filepath":"src/src/pdkim/bignum.c","line_number":871,"entry_url":"https://github.com/Exim/exim.git","slot_name":"list_safety_merge_proposal"},"406394":{"score":0.65880466,"function_name":"mpi_mul_hlp","code":"static void mpi_mul_hlp( size_t i, t_uint *s, t_uint *d, t_uint b )\n{\n    t_uint c = 0, t = 0;\n\n#if defined(MULADDC_HUIT)\n    for( ; i \u003e= 8; i -= 8 )\n    {\n        MULADDC_INIT\n        MULADDC_HUIT\n        MULADDC_STOP\n    }\n\n    for( ; i \u003e 0; i-- )\n    {\n        MULADDC_INIT\n        MULADDC_CORE\n        MULADDC_STOP\n    }\n#else\n    for( ; i \u003e= 16; i -= 16 )\n    {\n        MULADDC_INIT\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_STOP\n    }\n\n    for( ; i \u003e= 8; i -= 8 )\n    {\n        MULADDC_INIT\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_CORE   MULADDC_CORE\n        MULADDC_STOP\n    }\n\n    for( ; i \u003e 0; i-- )\n    {\n        MULADDC_INIT\n        MULADDC_CORE\n        MULADDC_STOP\n    }\n#endif\n\n    t++;\n\n    do {\n        *d += c; c = ( *d \u003c c ); d++;\n    }\n    while( c != 0 );\n}","filepath":"library/bignum.c","line_number":933,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.1.2"},"411634":{"score":0.8036532,"function_name":"mbedtls_mpi_mul_mpi","code":"int mbedtls_mpi_mul_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )\n{\n    int ret;\n    size_t i, j;\n    mbedtls_mpi TA, TB;\n\n    mbedtls_mpi_init( \u0026TA ); mbedtls_mpi_init( \u0026TB );\n\n    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026TA, A ) ); A = \u0026TA; }\n    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026TB, B ) ); B = \u0026TB; }\n\n    for( i = A-\u003en; i \u003e 0; i-- )\n        if( A-\u003ep[i - 1] != 0 )\n            break;\n\n    for( j = B-\u003en; j \u003e 0; j-- )\n        if( B-\u003ep[j - 1] != 0 )\n            break;\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );\n\n    for( ; j \u003e 0; j-- )\n        mpi_mul_hlp( i, A-\u003ep, X-\u003ep + j - 1, B-\u003ep[j - 1] );\n\n    X-\u003es = A-\u003es * B-\u003es;\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026TB ); mbedtls_mpi_free( \u0026TA );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1185,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"412106":{"score":0.77283245,"function_name":"mpi_mul_int","code":"int mpi_mul_int( mpi *X, mpi *A, t_int b )\n{\n    mpi _B;\n    t_int p[1];\n\n    _B.s = 1;\n    _B.n = 1;\n    _B.p = p;\n    p[0] = b;\n\n    return( mpi_mul_mpi( X, A, \u0026_B ) );\n}","filepath":"src/src/pdkim/bignum.c","line_number":986,"entry_url":"https://github.com/Exim/exim.git","slot_name":"exim-4_72_RC1"},"412211":{"score":0.8298392,"function_name":"int_div_int","code":"static t_uint int_div_int( t_uint u1, t_uint u0, t_uint d, t_uint *r )\n{\n#if defined(POLARSSL_HAVE_UDBL)\n    t_udbl dividend, quotient;\n#else\n    const t_uint radix = (t_uint) 1 \u003c\u003c biH;\n    const t_uint uint_halfword_mask = ( (t_uint) 1 \u003c\u003c biH ) - 1;\n    t_uint d0, d1, q0, q1, rAX, r0, quotient;\n    t_uint u0_msw, u0_lsw;\n    size_t s;\n#endif\n\n    /*\n     * Check for overflow\n     */\n    if( 0 == d || u1 \u003e= d )\n    {\n        if ( r != NULL ) *r = ~0;\n\n        return ( ~0 );\n    }\n\n#if defined(POLARSSL_HAVE_UDBL)\n    dividend  = (t_udbl) u1 \u003c\u003c biL;\n    dividend |= (t_udbl) u0;\n    quotient = dividend / d;\n    if( quotient \u003e ( (t_udbl) 1 \u003c\u003c biL ) - 1 )\n        quotient = ( (t_udbl) 1 \u003c\u003c biL ) - 1;\n\n    if( r != NULL )\n        *r = (t_uint)( dividend - (quotient * d ) );\n\n    return (t_uint) quotient;\n#else\n\n    /*\n     * Algorithm D, Section 4.3.1 - The Art of Computer Programming\n     *   Vol. 2 - Seminumerical Algorithms, Knuth\n     */\n\n    /*\n     * Normalize the divisor, d, and dividend, u0, u1\n     */\n    s = int_clz( d );\n    d = d \u003c\u003c s;\n\n    u1 = u1 \u003c\u003c s;\n    u1 |= ( u0 \u003e\u003e ( biL - s ) ) \u0026 ( -(t_sint)s \u003e\u003e ( biL - 1 ) );\n    u0 =  u0 \u003c\u003c s;\n\n    d1 = d \u003e\u003e biH;\n    d0 = d \u0026 uint_halfword_mask;\n\n    u0_msw = u0 \u003e\u003e biH;\n    u0_lsw = u0 \u0026 uint_halfword_mask;\n\n    /*\n     * Find the first quotient and remainder\n     */\n    q1 = u1 / d1;\n    r0 = u1 - d1 * q1;\n\n    while( q1 \u003e= radix || ( q1 * d0 \u003e radix * r0 + u0_msw ) )\n    {\n        q1 -= 1;\n        r0 += d1;\n\n        if ( r0 \u003e= radix ) break;\n    }\n\n    rAX = ( u1 * radix ) + ( u0_msw - q1 * d );\n    q0 = rAX / d1;\n    r0 = rAX - q0 * d1;\n\n    while( q0 \u003e= radix || ( q0 * d0 \u003e radix * r0 + u0_lsw ) )\n    {\n        q0 -= 1;\n        r0 += d1;\n\n        if ( r0 \u003e= radix ) break;\n    }\n\n    if (r != NULL)\n        *r = ( rAX * radix + u0_lsw - q0 * d ) \u003e\u003e s;\n\n    quotient = q1 * radix + q0;\n\n    return quotient;\n#endif\n}","filepath":"library/bignum.c","line_number":1224,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"412649":{"score":0.8636253,"function_name":"mpi_div_mpi","code":"int mpi_div_mpi( mpi *Q, mpi *R, const mpi *A, const mpi *B )\n{\n    int ret;\n    size_t i, n, t, k;\n    mpi X, Y, Z, T1, T2;\n\n    if( mpi_cmp_int( B, 0 ) == 0 )\n        return( POLARSSL_ERR_MPI_DIVISION_BY_ZERO );\n\n    mpi_init( \u0026X ); mpi_init( \u0026Y ); mpi_init( \u0026Z );\n    mpi_init( \u0026T1 ); mpi_init( \u0026T2 );\n\n    if( mpi_cmp_abs( A, B ) \u003c 0 )\n    {\n        if( Q != NULL ) MPI_CHK( mpi_lset( Q, 0 ) );\n        if( R != NULL ) MPI_CHK( mpi_copy( R, A ) );\n        return( 0 );\n    }\n\n    MPI_CHK( mpi_copy( \u0026X, A ) );\n    MPI_CHK( mpi_copy( \u0026Y, B ) );\n    X.s = Y.s = 1;\n\n    MPI_CHK( mpi_grow( \u0026Z, A-\u003en + 2 ) );\n    MPI_CHK( mpi_lset( \u0026Z,  0 ) );\n    MPI_CHK( mpi_grow( \u0026T1, 2 ) );\n    MPI_CHK( mpi_grow( \u0026T2, 3 ) );\n\n    k = mpi_msb( \u0026Y ) % biL;\n    if( k \u003c biL - 1 )\n    {\n        k = biL - 1 - k;\n        MPI_CHK( mpi_shift_l( \u0026X, k ) );\n        MPI_CHK( mpi_shift_l( \u0026Y, k ) );\n    }\n    else k = 0;\n\n    n = X.n - 1;\n    t = Y.n - 1;\n    MPI_CHK( mpi_shift_l( \u0026Y, biL * ( n - t ) ) );\n\n    while( mpi_cmp_mpi( \u0026X, \u0026Y ) \u003e= 0 )\n    {\n        Z.p[n - t]++;\n        MPI_CHK( mpi_sub_mpi( \u0026X, \u0026X, \u0026Y ) );\n    }\n    MPI_CHK( mpi_shift_r( \u0026Y, biL * ( n - t ) ) );\n\n    for( i = n; i \u003e t ; i-- )\n    {\n        if( X.p[i] \u003e= Y.p[t] )\n            Z.p[i - t - 1] = ~0;\n        else\n        {\n            Z.p[i - t - 1] = int_div_int( X.p[i], X.p[i - 1], Y.p[t], NULL);\n        }\n\n        Z.p[i - t - 1]++;\n        do\n        {\n            Z.p[i - t - 1]--;\n\n            MPI_CHK( mpi_lset( \u0026T1, 0 ) );\n            T1.p[0] = ( t \u003c 1 ) ? 0 : Y.p[t - 1];\n            T1.p[1] = Y.p[t];\n            MPI_CHK( mpi_mul_int( \u0026T1, \u0026T1, Z.p[i - t - 1] ) );\n\n            MPI_CHK( mpi_lset( \u0026T2, 0 ) );\n            T2.p[0] = ( i \u003c 2 ) ? 0 : X.p[i - 2];\n            T2.p[1] = ( i \u003c 1 ) ? 0 : X.p[i - 1];\n            T2.p[2] = X.p[i];\n        }\n        while( mpi_cmp_mpi( \u0026T1, \u0026T2 ) \u003e 0 );\n\n        MPI_CHK( mpi_mul_int( \u0026T1, \u0026Y, Z.p[i - t - 1] ) );\n        MPI_CHK( mpi_shift_l( \u0026T1,  biL * ( i - t - 1 ) ) );\n        MPI_CHK( mpi_sub_mpi( \u0026X, \u0026X, \u0026T1 ) );\n\n        if( mpi_cmp_int( \u0026X, 0 ) \u003c 0 )\n        {\n            MPI_CHK( mpi_copy( \u0026T1, \u0026Y ) );\n            MPI_CHK( mpi_shift_l( \u0026T1, biL * ( i - t - 1 ) ) );\n            MPI_CHK( mpi_add_mpi( \u0026X, \u0026X, \u0026T1 ) );\n            Z.p[i - t - 1]--;\n        }\n    }\n\n    if( Q != NULL )\n    {\n        MPI_CHK( mpi_copy( Q, \u0026Z ) );\n        Q-\u003es = A-\u003es * B-\u003es;\n    }\n\n    if( R != NULL )\n    {\n        MPI_CHK( mpi_shift_r( \u0026X, k ) );\n        X.s = A-\u003es;\n        MPI_CHK( mpi_copy( R, \u0026X ) );\n\n        if( mpi_cmp_int( R, 0 ) == 0 )\n            R-\u003es = 1;\n    }\n\ncleanup:\n\n    mpi_free( \u0026X ); mpi_free( \u0026Y ); mpi_free( \u0026Z );\n    mpi_free( \u0026T1 ); mpi_free( \u0026T2 );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1318,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"414541":{"score":0.8334029,"function_name":"mpi_div_int","code":"int mpi_div_int( mpi *Q, mpi *R, mpi *A, int b )\n{\n    mpi _B;\n    t_int p[1];\n\n    p[0] = ( b \u003c 0 ) ? -b : b;\n    _B.s = ( b \u003c 0 ) ? -1 : 1;\n    _B.n = 1;\n    _B.p = p;\n\n    return( mpi_div_mpi( Q, R, A, \u0026_B ) );\n}","filepath":"library/bignum.c","line_number":1168,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-0.12.0"},"414674":{"score":0.8355092,"function_name":"mbedtls_mpi_mod_mpi","code":"int mbedtls_mpi_mod_mpi( mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B )\n{\n    int ret;\n\n    if( mbedtls_mpi_cmp_int( B, 0 ) \u003c 0 )\n        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );\n\n    while( mbedtls_mpi_cmp_int( R, 0 ) \u003c 0 )\n      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );\n\n    while( mbedtls_mpi_cmp_mpi( R, B ) \u003e= 0 )\n      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );\n\ncleanup:\n\n    return( ret );\n}","filepath":"src/ref-impl/tls/library/bignum.c","line_number":1441,"entry_url":"https://github.com/aliyun/iotkit-embedded.git","slot_name":"RELEASED_V2.30"},"414865":{"score":0.89399225,"function_name":"mbedtls_mpi_mod_int","code":"int mbedtls_mpi_mod_int( mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b )\n{\n    size_t i;\n    mbedtls_mpi_uint x, y, z;\n\n    if( b == 0 )\n        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );\n\n    if( b \u003c 0 )\n        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );\n\n    /*\n     * handle trivial cases\n     */\n    if( b == 1 )\n    {\n        *r = 0;\n        return( 0 );\n    }\n\n    if( b == 2 )\n    {\n        *r = A-\u003ep[0] \u0026 1;\n        return( 0 );\n    }\n\n    /*\n     * general case\n     */\n    for( i = A-\u003en, y = 0; i \u003e 0; i-- )\n    {\n        x  = A-\u003ep[i - 1];\n        y  = ( y \u003c\u003c biH ) | ( x \u003e\u003e biH );\n        z  = y / b;\n        y -= z * b;\n\n        x \u003c\u003c= biH;\n        y  = ( y \u003c\u003c biH ) | ( x \u003e\u003e biH );\n        z  = y / b;\n        y -= z * b;\n    }\n\n    /*\n     * If A is negative, then the current y represents a negative value.\n     * Flipping it to the positive side.\n     */\n    if( A-\u003es \u003c 0 \u0026\u0026 y != 0 )\n        y = b - y;\n\n    *r = y;\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":1513,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.14.1"},"415162":{"score":0.8668767,"function_name":"mpi_montg_init","code":"static void mpi_montg_init( t_uint *mm, const mpi *N )\n{\n    t_uint x, m0 = N-\u003ep[0];\n    unsigned int i;\n\n    x  = m0;\n    x += ( ( m0 + 2 ) \u0026 4 ) \u003c\u003c 1;\n\n    for( i = biL; i \u003e= 8; i /= 2 )\n        x *= ( 2 - ( m0 * x ) );\n\n    *mm = ~x + 1;\n}","filepath":"library/bignum.c","line_number":1451,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.5"},"415270":{"score":0.8652607,"function_name":"mpi_montmul","code":"static int mpi_montmul( mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,\n                         const mbedtls_mpi *T )\n{\n    size_t i, n, m;\n    mbedtls_mpi_uint u0, u1, *d;\n\n    if( T-\u003en \u003c N-\u003en + 1 || T-\u003ep == NULL )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    memset( T-\u003ep, 0, T-\u003en * ciL );\n\n    d = T-\u003ep;\n    n = N-\u003en;\n    m = ( B-\u003en \u003c n ) ? B-\u003en : n;\n\n    for( i = 0; i \u003c n; i++ )\n    {\n        /*\n         * T = (T + u0*B + u1*N) / 2^biL\n         */\n        u0 = A-\u003ep[i];\n        u1 = ( d[0] + u0 * B-\u003ep[0] ) * mm;\n\n        mpi_mul_hlp( m, B-\u003ep, d, u0 );\n        mpi_mul_hlp( n, N-\u003ep, d, u1 );\n\n        *d++ = u0; d[n + 1] = 0;\n    }\n\n    memcpy( A-\u003ep, d, ( n + 1 ) * ciL );\n\n    if( mbedtls_mpi_cmp_abs( A, N ) \u003e= 0 )\n        mpi_sub_hlp( n, N-\u003ep, A-\u003ep );\n    else\n        /* prevent timing attacks */\n        mpi_sub_hlp( n, A-\u003ep, T-\u003ep );\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":1587,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.14.1"},"415680":{"score":0.7982709,"function_name":"mpi_montred","code":"static void mpi_montred( mpi *A, mpi *N, t_int mm, mpi *T )\n{\n    t_int z = 1;\n    mpi U;\n\n    U.n = U.s = z;\n    U.p = \u0026z;\n\n    mpi_montmul( A, \u0026U, N, mm, T );\n}","filepath":"library/bignum.c","line_number":1319,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-0.12.0"},"415796":{"score":0.7883349,"function_name":"mpi_exp_mod","code":"int mpi_exp_mod( mpi *X, const mpi *A, const mpi *E, const mpi *N, mpi *_RR )\n{\n    int ret;\n    size_t wbits, wsize, one = 1;\n    size_t i, j, nblimbs;\n    size_t bufsize, nbits;\n    t_uint ei, mm, state;\n    mpi RR, T, W[ 2 \u003c\u003c POLARSSL_MPI_WINDOW_SIZE ], Apos;\n    int neg;\n\n    if( mpi_cmp_int( N, 0 ) \u003c 0 || ( N-\u003ep[0] \u0026 1 ) == 0 )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    if( mpi_cmp_int( E, 0 ) \u003c 0 )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    /*\n     * Init temps and window size\n     */\n    mpi_montg_init( \u0026mm, N );\n    mpi_init( \u0026RR ); mpi_init( \u0026T );\n    mpi_init( \u0026Apos );\n    memset( W, 0, sizeof( W ) );\n\n    i = mpi_msb( E );\n\n    wsize = ( i \u003e 671 ) ? 6 : ( i \u003e 239 ) ? 5 :\n            ( i \u003e  79 ) ? 4 : ( i \u003e  23 ) ? 3 : 1;\n\n    if( wsize \u003e POLARSSL_MPI_WINDOW_SIZE )\n        wsize = POLARSSL_MPI_WINDOW_SIZE;\n\n    j = N-\u003en + 1;\n    MPI_CHK( mpi_grow( X, j ) );\n    MPI_CHK( mpi_grow( \u0026W[1],  j ) );\n    MPI_CHK( mpi_grow( \u0026T, j * 2 ) );\n\n    /*\n     * Compensate for negative A (and correct at the end)\n     */\n    neg = ( A-\u003es == -1 );\n    if( neg )\n    {\n        MPI_CHK( mpi_copy( \u0026Apos, A ) );\n        Apos.s = 1;\n        A = \u0026Apos;\n    }\n\n    /*\n     * If 1st call, pre-compute R^2 mod N\n     */\n    if( _RR == NULL || _RR-\u003ep == NULL )\n    {\n        MPI_CHK( mpi_lset( \u0026RR, 1 ) );\n        MPI_CHK( mpi_shift_l( \u0026RR, N-\u003en * 2 * biL ) );\n        MPI_CHK( mpi_mod_mpi( \u0026RR, \u0026RR, N ) );\n\n        if( _RR != NULL )\n            memcpy( _RR, \u0026RR, sizeof( mpi ) );\n    }\n    else\n        memcpy( \u0026RR, _RR, sizeof( mpi ) );\n\n    /*\n     * W[1] = A * R^2 * R^-1 mod N = A * R mod N\n     */\n    if( mpi_cmp_mpi( A, N ) \u003e= 0 )\n    {\n        MPI_CHK( mpi_mod_mpi( \u0026W[1], A, N ) );\n    }\n    else\n        MPI_CHK( mpi_copy( \u0026W[1], A ) );\n\n    mpi_montmul( \u0026W[1], \u0026RR, N, mm, \u0026T );\n\n    /*\n     * X = R^2 * R^-1 mod N = R mod N\n     */\n    MPI_CHK( mpi_copy( X, \u0026RR ) );\n    mpi_montred( X, N, mm, \u0026T );\n\n    if( wsize \u003e 1 )\n    {\n        /*\n         * W[1 \u003c\u003c (wsize - 1)] = W[1] ^ (wsize - 1)\n         */\n        j =  one \u003c\u003c (wsize - 1);\n\n        MPI_CHK( mpi_grow( \u0026W[j], N-\u003en + 1 ) );\n        MPI_CHK( mpi_copy( \u0026W[j], \u0026W[1]    ) );\n\n        for( i = 0; i \u003c wsize - 1; i++ )\n            mpi_montmul( \u0026W[j], \u0026W[j], N, mm, \u0026T );\n\n        /*\n         * W[i] = W[i - 1] * W[1]\n         */\n        for( i = j + 1; i \u003c (one \u003c\u003c wsize); i++ )\n        {\n            MPI_CHK( mpi_grow( \u0026W[i], N-\u003en + 1 ) );\n            MPI_CHK( mpi_copy( \u0026W[i], \u0026W[i - 1] ) );\n\n            mpi_montmul( \u0026W[i], \u0026W[1], N, mm, \u0026T );\n        }\n    }\n\n    nblimbs = E-\u003en;\n    bufsize = 0;\n    nbits   = 0;\n    wbits   = 0;\n    state   = 0;\n\n    while( 1 )\n    {\n        if( bufsize == 0 )\n        {\n            if( nblimbs == 0 )\n                break;\n\n            nblimbs--;\n\n            bufsize = sizeof( t_uint ) \u003c\u003c 3;\n        }\n\n        bufsize--;\n\n        ei = (E-\u003ep[nblimbs] \u003e\u003e bufsize) \u0026 1;\n\n        /*\n         * skip leading 0s\n         */\n        if( ei == 0 \u0026\u0026 state == 0 )\n            continue;\n\n        if( ei == 0 \u0026\u0026 state == 1 )\n        {\n            /*\n             * out of window, square X\n             */\n            mpi_montmul( X, X, N, mm, \u0026T );\n            continue;\n        }\n\n        /*\n         * add ei to current window\n         */\n        state = 2;\n\n        nbits++;\n        wbits |= (ei \u003c\u003c (wsize - nbits));\n\n        if( nbits == wsize )\n        {\n            /*\n             * X = X^wsize R^-1 mod N\n             */\n            for( i = 0; i \u003c wsize; i++ )\n                mpi_montmul( X, X, N, mm, \u0026T );\n\n            /*\n             * X = X * W[wbits] R^-1 mod N\n             */\n            mpi_montmul( X, \u0026W[wbits], N, mm, \u0026T );\n\n            state--;\n            nbits = 0;\n            wbits = 0;\n        }\n    }\n\n    /*\n     * process the remaining bits\n     */\n    for( i = 0; i \u003c nbits; i++ )\n    {\n        mpi_montmul( X, X, N, mm, \u0026T );\n\n        wbits \u003c\u003c= 1;\n\n        if( (wbits \u0026 (one \u003c\u003c wsize)) != 0 )\n            mpi_montmul( X, \u0026W[1], N, mm, \u0026T );\n    }\n\n    /*\n     * X = A^E * R * R^-1 mod N = A^E mod N\n     */\n    mpi_montred( X, N, mm, \u0026T );\n\n    if( neg )\n    {\n        X-\u003es = -1;\n        MPI_CHK( mpi_add_mpi( X, N, X ) );\n    }\n\ncleanup:\n\n    for( i = (one \u003c\u003c (wsize - 1)); i \u003c (one \u003c\u003c wsize); i++ )\n        mpi_free( \u0026W[i] );\n\n    mpi_free( \u0026W[1] ); mpi_free( \u0026T ); mpi_free( \u0026Apos );\n\n    if( _RR == NULL || _RR-\u003ep == NULL )\n        mpi_free( \u0026RR );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1468,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.19"},"418743":{"score":0.79816484,"function_name":"mpi_gcd","code":"int mpi_gcd( mpi *G, const mpi *A, const mpi *B )\n{\n    int ret;\n    size_t lz, lzt;\n    mpi TG, TA, TB;\n\n    mpi_init( \u0026TG ); mpi_init( \u0026TA ); mpi_init( \u0026TB );\n\n    MPI_CHK( mpi_copy( \u0026TA, A ) );\n    MPI_CHK( mpi_copy( \u0026TB, B ) );\n\n    lz = mpi_lsb( \u0026TA );\n    lzt = mpi_lsb( \u0026TB );\n\n    if ( lzt \u003c lz )\n        lz = lzt;\n\n    MPI_CHK( mpi_shift_r( \u0026TA, lz ) );\n    MPI_CHK( mpi_shift_r( \u0026TB, lz ) );\n\n    TA.s = TB.s = 1;\n\n    while( mpi_cmp_int( \u0026TA, 0 ) != 0 )\n    {\n        MPI_CHK( mpi_shift_r( \u0026TA, mpi_lsb( \u0026TA ) ) );\n        MPI_CHK( mpi_shift_r( \u0026TB, mpi_lsb( \u0026TB ) ) );\n\n        if( mpi_cmp_mpi( \u0026TA, \u0026TB ) \u003e= 0 )\n        {\n            MPI_CHK( mpi_sub_abs( \u0026TA, \u0026TA, \u0026TB ) );\n            MPI_CHK( mpi_shift_r( \u0026TA, 1 ) );\n        }\n        else\n        {\n            MPI_CHK( mpi_sub_abs( \u0026TB, \u0026TB, \u0026TA ) );\n            MPI_CHK( mpi_shift_r( \u0026TB, 1 ) );\n        }\n    }\n\n    MPI_CHK( mpi_shift_l( \u0026TB, lz ) );\n    MPI_CHK( mpi_copy( G, \u0026TB ) );\n\ncleanup:\n\n    mpi_free( \u0026TG ); mpi_free( \u0026TA ); mpi_free( \u0026TB );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1590,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.6"},"419426":{"score":0.6664813,"function_name":"ecp_drbg_seed","code":"static int ecp_drbg_seed( ecp_drbg_context *ctx,\n                   const mbedtls_mpi *secret, size_t secret_len )\n{\n    int ret;\n    unsigned char secret_bytes[MBEDTLS_ECP_MAX_BYTES];\n\n    if( secret_len \u003e MBEDTLS_ECP_MAX_BYTES )\n    {\n        ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;\n        goto cleanup;\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( secret,\n                                               secret_bytes, secret_len ) );\n\n    ret = mbedtls_ctr_drbg_seed( ctx, ecp_ctr_drbg_null_entropy, NULL,\n                                 secret_bytes, secret_len );\n\ncleanup:\n    mbedtls_platform_zeroize( secret_bytes, secret_len );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":237,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"419640":{"score":0.8476347,"function_name":"mbedtls_mpi_inv_mod","code":"int mbedtls_mpi_inv_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;\n    MPI_VALIDATE_RET( X != NULL );\n    MPI_VALIDATE_RET( A != NULL );\n    MPI_VALIDATE_RET( N != NULL );\n\n    if( mbedtls_mpi_cmp_int( N, 1 ) \u003c= 0 )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    mbedtls_mpi_init( \u0026TA ); mbedtls_mpi_init( \u0026TU ); mbedtls_mpi_init( \u0026U1 ); mbedtls_mpi_init( \u0026U2 );\n    mbedtls_mpi_init( \u0026G ); mbedtls_mpi_init( \u0026TB ); mbedtls_mpi_init( \u0026TV );\n    mbedtls_mpi_init( \u0026V1 ); mbedtls_mpi_init( \u0026V2 );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( \u0026G, A, N ) );\n\n    if( mbedtls_mpi_cmp_int( \u0026G, 1 ) != 0 )\n    {\n        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;\n        goto cleanup;\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026TA, A, N ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026TU, \u0026TA ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026TB, N ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026TV, N ) );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026U1, 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026U2, 0 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026V1, 0 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026V2, 1 ) );\n\n    do\n    {\n        while( ( TU.p[0] \u0026 1 ) == 0 )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026TU, 1 ) );\n\n            if( ( U1.p[0] \u0026 1 ) != 0 || ( U2.p[0] \u0026 1 ) != 0 )\n            {\n                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026U1, \u0026U1, \u0026TB ) );\n                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026U2, \u0026U2, \u0026TA ) );\n            }\n\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026U1, 1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026U2, 1 ) );\n        }\n\n        while( ( TV.p[0] \u0026 1 ) == 0 )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026TV, 1 ) );\n\n            if( ( V1.p[0] \u0026 1 ) != 0 || ( V2.p[0] \u0026 1 ) != 0 )\n            {\n                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026V1, \u0026V1, \u0026TB ) );\n                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026V2, \u0026V2, \u0026TA ) );\n            }\n\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026V1, 1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026V2, 1 ) );\n        }\n\n        if( mbedtls_mpi_cmp_mpi( \u0026TU, \u0026TV ) \u003e= 0 )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026TU, \u0026TU, \u0026TV ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026U1, \u0026U1, \u0026V1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026U2, \u0026U2, \u0026V2 ) );\n        }\n        else\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026TV, \u0026TV, \u0026TU ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026V1, \u0026V1, \u0026U1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026V2, \u0026V2, \u0026U2 ) );\n        }\n    }\n    while( mbedtls_mpi_cmp_int( \u0026TU, 0 ) != 0 );\n\n    while( mbedtls_mpi_cmp_int( \u0026V1, 0 ) \u003c 0 )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026V1, \u0026V1, N ) );\n\n    while( mbedtls_mpi_cmp_mpi( \u0026V1, N ) \u003e= 0 )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026V1, \u0026V1, N ) );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, \u0026V1 ) );\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026TA ); mbedtls_mpi_free( \u0026TU ); mbedtls_mpi_free( \u0026U1 ); mbedtls_mpi_free( \u0026U2 );\n    mbedtls_mpi_free( \u0026G ); mbedtls_mpi_free( \u0026TB ); mbedtls_mpi_free( \u0026TV );\n    mbedtls_mpi_free( \u0026V1 ); mbedtls_mpi_free( \u0026V2 );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":2488,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.28.0"},"421266":{"score":0.6451506,"function_name":"mbedtls_cipher_get_block_size","code":"static inline unsigned int mbedtls_cipher_get_block_size(\n    const mbedtls_cipher_context_t *ctx )\n{\n    MBEDTLS_INTERNAL_VALIDATE_RET( ctx != NULL, 0 );\n    if( ctx-\u003ecipher_info == NULL )\n        return 0;\n\n    return ctx-\u003ecipher_info-\u003eblock_size;\n}","filepath":"include/mbedtls/cipher.h","line_number":471,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.17.0"},"421305":{"score":0.7553125,"function_name":"mbedtls_cipher_get_iv_size","code":"static inline int mbedtls_cipher_get_iv_size(\n    const mbedtls_cipher_context_t *ctx )\n{\n    MBEDTLS_INTERNAL_VALIDATE_RET( ctx != NULL, 0 );\n    if( ctx-\u003ecipher_info == NULL )\n        return 0;\n\n    if( ctx-\u003eiv_size != 0 )\n        return (int) ctx-\u003eiv_size;\n\n    return (int) ctx-\u003ecipher_info-\u003eiv_size;\n}","filepath":"third_party/mbedtls/cipher.h","line_number":445,"entry_url":"https://github.com/jart/cosmopolitan.git","slot_name":"redbean-2.0.2"},"421786":{"score":0.8582357,"function_name":"mbedtls_cipher_free","code":"void mbedtls_cipher_free( mbedtls_cipher_context_t *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n    if( ctx-\u003ecipher_ctx )\n        ctx-\u003ecipher_info-\u003ebase-\u003ectx_free_func( ctx-\u003ecipher_ctx );\n\n    mbedtls_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );\n}","filepath":"library/cipher.c","line_number":126,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"beta-oob-2"},"421870":{"score":0.82096034,"function_name":"mbedtls_cipher_setup","code":"int mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    if( cipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );\n\n    if( NULL == ( ctx-\u003ecipher_ctx = cipher_info-\u003ebase-\u003ectx_alloc_func() ) )\n        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );\n\n    ctx-\u003ecipher_info = cipher_info;\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n    /*\n     * Ignore possible errors caused by a cipher mode that doesn't use padding\n     */\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );\n#else\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );\n#endif\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":209,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"421990":{"score":0.89340633,"function_name":"mbedtls_cipher_setkey","code":"int mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx,\n                           const unsigned char *key,\n                           int key_bitlen,\n                           const mbedtls_operation_t operation )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( key != NULL );\n    CIPHER_VALIDATE_RET( operation == MBEDTLS_ENCRYPT ||\n                         operation == MBEDTLS_DECRYPT );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003ecipher_info-\u003eflags \u0026 MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 \u0026\u0026\n        (int) ctx-\u003ecipher_info-\u003ekey_bitlen != key_bitlen )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    ctx-\u003ekey_bitlen = key_bitlen;\n    ctx-\u003eoperation = operation;\n\n    /*\n     * For OFB, CFB and CTR mode always use the encryption key schedule\n     */\n    if( MBEDTLS_ENCRYPT == operation ||\n        MBEDTLS_MODE_CFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_OFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_CTR == ctx-\u003ecipher_info-\u003emode )\n    {\n        return( ctx-\u003ecipher_info-\u003ebase-\u003esetkey_enc_func( ctx-\u003ecipher_ctx, key,\n                                                         ctx-\u003ekey_bitlen ) );\n    }\n\n    if( MBEDTLS_DECRYPT == operation )\n        return( ctx-\u003ecipher_info-\u003ebase-\u003esetkey_dec_func( ctx-\u003ecipher_ctx, key,\n                                                         ctx-\u003ekey_bitlen ) );\n\n    return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n}","filepath":"library/cipher.c","line_number":236,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"422219":{"score":0.8129275,"function_name":"mbedtls_cipher_set_iv","code":"int mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,\n                           const unsigned char *iv,\n                           size_t iv_len )\n{\n    size_t actual_iv_size;\n\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( iv_len == 0 || iv != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    /* avoid buffer overflow in ctx-\u003eiv */\n    if( iv_len \u003e MBEDTLS_MAX_IV_LENGTH )\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n\n    if( ( ctx-\u003ecipher_info-\u003eflags \u0026 MBEDTLS_CIPHER_VARIABLE_IV_LEN ) != 0 )\n        actual_iv_size = iv_len;\n    else\n    {\n        actual_iv_size = ctx-\u003ecipher_info-\u003eiv_size;\n\n        /* avoid reading past the end of input buffer */\n        if( actual_iv_size \u003e iv_len )\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_CHACHA20_C)\n    if ( ctx-\u003ecipher_info-\u003etype == MBEDTLS_CIPHER_CHACHA20 )\n    {\n        if ( 0 != mbedtls_chacha20_starts( (mbedtls_chacha20_context*)ctx-\u003ecipher_ctx,\n                                           iv,\n                                           0U ) ) /* Initial counter value */\n        {\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n        }\n    }\n#endif\n\n    if ( actual_iv_size != 0 )\n    {\n        memcpy( ctx-\u003eiv, iv, actual_iv_size );\n        ctx-\u003eiv_size = actual_iv_size;\n    }\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":276,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"422365":{"score":0.88013536,"function_name":"mbedtls_cipher_reset","code":"int mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    ctx-\u003eunprocessed_len = 0;\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":323,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"422411":{"score":0.8753619,"function_name":"mbedtls_cipher_update","code":"int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,\n                   size_t ilen, unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t block_size;\n\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( ilen == 0 || input != NULL );\n    CIPHER_VALIDATE_RET( output != NULL );\n    CIPHER_VALIDATE_RET( olen != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *olen = 0;\n    block_size = mbedtls_cipher_get_block_size( ctx );\n    if ( 0 == block_size )\n    {\n        return( MBEDTLS_ERR_CIPHER_INVALID_CONTEXT );\n    }\n\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_ECB )\n    {\n        if( ilen != block_size )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        *olen = ilen;\n\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003eecb_func( ctx-\u003ecipher_ctx,\n                    ctx-\u003eoperation, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_GCM_C)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_GCM )\n    {\n        *olen = ilen;\n        return( mbedtls_gcm_update( (mbedtls_gcm_context *) ctx-\u003ecipher_ctx, ilen, input,\n                                    output ) );\n    }\n#endif\n\n#if defined(MBEDTLS_CHACHAPOLY_C)\n    if ( ctx-\u003ecipher_info-\u003etype == MBEDTLS_CIPHER_CHACHA20_POLY1305 )\n    {\n        *olen = ilen;\n        return( mbedtls_chachapoly_update( (mbedtls_chachapoly_context*) ctx-\u003ecipher_ctx,\n                                           ilen, input, output ) );\n    }\n#endif\n\n    if( input == output \u0026\u0026\n       ( ctx-\u003eunprocessed_len != 0 || ilen % block_size ) )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_CBC )\n    {\n        size_t copy_len = 0;\n\n        /*\n         * If there is not enough data for a full block, cache it.\n         */\n        if( ( ctx-\u003eoperation == MBEDTLS_DECRYPT \u0026\u0026 NULL != ctx-\u003eadd_padding \u0026\u0026\n                ilen \u003c= block_size - ctx-\u003eunprocessed_len ) ||\n            ( ctx-\u003eoperation == MBEDTLS_DECRYPT \u0026\u0026 NULL == ctx-\u003eadd_padding \u0026\u0026\n                ilen \u003c block_size - ctx-\u003eunprocessed_len ) ||\n             ( ctx-\u003eoperation == MBEDTLS_ENCRYPT \u0026\u0026\n                ilen \u003c block_size - ctx-\u003eunprocessed_len ) )\n        {\n            memcpy( \u0026( ctx-\u003eunprocessed_data[ctx-\u003eunprocessed_len] ), input,\n                    ilen );\n\n            ctx-\u003eunprocessed_len += ilen;\n            return( 0 );\n        }\n\n        /*\n         * Process cached data first\n         */\n        if( 0 != ctx-\u003eunprocessed_len )\n        {\n            copy_len = block_size - ctx-\u003eunprocessed_len;\n\n            memcpy( \u0026( ctx-\u003eunprocessed_data[ctx-\u003eunprocessed_len] ), input,\n                    copy_len );\n\n            if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecbc_func( ctx-\u003ecipher_ctx,\n                    ctx-\u003eoperation, block_size, ctx-\u003eiv,\n                    ctx-\u003eunprocessed_data, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += block_size;\n            output += block_size;\n            ctx-\u003eunprocessed_len = 0;\n\n            input += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Cache final, incomplete block\n         */\n        if( 0 != ilen )\n        {\n            /* Encryption: only cache partial blocks\n             * Decryption w/ padding: always keep at least one whole block\n             * Decryption w/o padding: only cache partial blocks\n             */\n            copy_len = ilen % block_size;\n            if( copy_len == 0 \u0026\u0026\n                ctx-\u003eoperation == MBEDTLS_DECRYPT \u0026\u0026\n                NULL != ctx-\u003eadd_padding)\n            {\n                copy_len = block_size;\n            }\n\n            memcpy( ctx-\u003eunprocessed_data, \u0026( input[ilen - copy_len] ),\n                    copy_len );\n\n            ctx-\u003eunprocessed_len += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Process remaining full blocks\n         */\n        if( ilen )\n        {\n            if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecbc_func( ctx-\u003ecipher_ctx,\n                    ctx-\u003eoperation, ilen, ctx-\u003eiv, input, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += ilen;\n        }\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_CFB )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecfb_func( ctx-\u003ecipher_ctx,\n                ctx-\u003eoperation, ilen, \u0026ctx-\u003eunprocessed_len, ctx-\u003eiv,\n                input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_OFB)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_OFB )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003eofb_func( ctx-\u003ecipher_ctx,\n                ilen, \u0026ctx-\u003eunprocessed_len, ctx-\u003eiv, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_OFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_CTR )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ectr_func( ctx-\u003ecipher_ctx,\n                ilen, \u0026ctx-\u003eunprocessed_len, ctx-\u003eiv,\n                ctx-\u003eunprocessed_data, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_CIPHER_MODE_XTS)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_XTS )\n    {\n        if( ctx-\u003eunprocessed_len \u003e 0 ) {\n            /* We can only process an entire data unit at a time. */\n            return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n        }\n\n        ret = ctx-\u003ecipher_info-\u003ebase-\u003exts_func( ctx-\u003ecipher_ctx,\n                ctx-\u003eoperation, ilen, ctx-\u003eiv, input, output );\n        if( ret != 0 )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_XTS */\n\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_STREAM )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003estream_func( ctx-\u003ecipher_ctx,\n                                                    ilen, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_STREAM */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}","filepath":"library/cipher.c","line_number":376,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"423567":{"score":0.84163237,"function_name":"mbedtls_cipher_finish","code":"int mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,\n                   unsigned char *output, size_t *olen )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( output != NULL );\n    CIPHER_VALIDATE_RET( olen != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *olen = 0;\n\n    if( MBEDTLS_MODE_CFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_OFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_CTR == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_GCM == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_XTS == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_STREAM == ctx-\u003ecipher_info-\u003emode )\n    {\n        return( 0 );\n    }\n\n    if ( ( MBEDTLS_CIPHER_CHACHA20          == ctx-\u003ecipher_info-\u003etype ) ||\n         ( MBEDTLS_CIPHER_CHACHA20_POLY1305 == ctx-\u003ecipher_info-\u003etype ) )\n    {\n        return( 0 );\n    }\n\n    if( MBEDTLS_MODE_ECB == ctx-\u003ecipher_info-\u003emode )\n    {\n        if( ctx-\u003eunprocessed_len != 0 )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( MBEDTLS_MODE_CBC == ctx-\u003ecipher_info-\u003emode )\n    {\n        int ret = 0;\n\n        if( MBEDTLS_ENCRYPT == ctx-\u003eoperation )\n        {\n            /* check for 'no padding' mode */\n            if( NULL == ctx-\u003eadd_padding )\n            {\n                if( 0 != ctx-\u003eunprocessed_len )\n                    return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n                return( 0 );\n            }\n\n            ctx-\u003eadd_padding( ctx-\u003eunprocessed_data, mbedtls_cipher_get_iv_size( ctx ),\n                    ctx-\u003eunprocessed_len );\n        }\n        else if( mbedtls_cipher_get_block_size( ctx ) != ctx-\u003eunprocessed_len )\n        {\n            /*\n             * For decrypt operations, expect a full block,\n             * or an empty block if no padding\n             */\n            if( NULL == ctx-\u003eadd_padding \u0026\u0026 0 == ctx-\u003eunprocessed_len )\n                return( 0 );\n\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n        }\n\n        /* cipher block */\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecbc_func( ctx-\u003ecipher_ctx,\n                ctx-\u003eoperation, mbedtls_cipher_get_block_size( ctx ), ctx-\u003eiv,\n                ctx-\u003eunprocessed_data, output ) ) )\n        {\n            return( ret );\n        }\n\n        /* Set output size for decryption */\n        if( MBEDTLS_DECRYPT == ctx-\u003eoperation )\n            return( ctx-\u003eget_padding( output, mbedtls_cipher_get_block_size( ctx ),\n                                      olen ) );\n\n        /* Set output size for encryption */\n        *olen = mbedtls_cipher_get_block_size( ctx );\n        return( 0 );\n    }\n#else\n    ((void) output);\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}","filepath":"library/cipher.c","line_number":783,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"424133":{"score":0.7985194,"function_name":"mbedtls_cipher_set_padding_mode","code":"int mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx,\n                                     mbedtls_cipher_padding_t mode )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n\n    if( NULL == ctx-\u003ecipher_info || MBEDTLS_MODE_CBC != ctx-\u003ecipher_info-\u003emode )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    switch( mode )\n    {\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    case MBEDTLS_PADDING_PKCS7:\n        ctx-\u003eadd_padding = add_pkcs_padding;\n        ctx-\u003eget_padding = get_pkcs_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)\n    case MBEDTLS_PADDING_ONE_AND_ZEROS:\n        ctx-\u003eadd_padding = add_one_and_zeros_padding;\n        ctx-\u003eget_padding = get_one_and_zeros_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)\n    case MBEDTLS_PADDING_ZEROS_AND_LEN:\n        ctx-\u003eadd_padding = add_zeros_and_len_padding;\n        ctx-\u003eget_padding = get_zeros_and_len_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS)\n    case MBEDTLS_PADDING_ZEROS:\n        ctx-\u003eadd_padding = add_zeros_padding;\n        ctx-\u003eget_padding = get_zeros_padding;\n        break;\n#endif\n    case MBEDTLS_PADDING_NONE:\n        ctx-\u003eadd_padding = NULL;\n        ctx-\u003eget_padding = get_no_padding;\n        break;\n\n    default:\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n    }\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":874,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"424253":{"score":0.8088976,"function_name":"mbedtls_cipher_crypt","code":"int mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,\n                  const unsigned char *iv, size_t iv_len,\n                  const unsigned char *input, size_t ilen,\n                  unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t finish_olen;\n\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( iv_len == 0 || iv != NULL );\n    CIPHER_VALIDATE_RET( ilen == 0 || input != NULL );\n    CIPHER_VALIDATE_RET( output != NULL );\n    CIPHER_VALIDATE_RET( olen != NULL );\n\n    if( ( ret = mbedtls_cipher_set_iv( ctx, iv, iv_len ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_reset( ctx ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_update( ctx, input, ilen, output, olen ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_finish( ctx, output + *olen, \u0026finish_olen ) ) != 0 )\n        return( ret );\n\n    *olen += finish_olen;\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":1021,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.7"},"424808":{"score":0.61551625,"function_name":"ecdh_gen_public_restartable","code":"static int ecdh_gen_public_restartable( mbedtls_ecp_group *grp,\n                    mbedtls_mpi *d, mbedtls_ecp_point *Q,\n                    int (*f_rng)(void *, unsigned char *, size_t),\n                    void *p_rng,\n                    mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n\n    /* If multiplication is in progress, we already generated a privkey */\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx == NULL || rs_ctx-\u003ersm == NULL )\n#endif\n        MBEDTLS_MPI_CHK( mbedtls_ecp_gen_privkey( grp, d, f_rng, p_rng ) );\n\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_restartable( grp, Q, d, \u0026grp-\u003eG,\n                                                  f_rng, p_rng, rs_ctx ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecdh.c","line_number":49,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.14.0"},"424955":{"score":0.71198195,"function_name":"ecdh_compute_shared_restartable","code":"static int ecdh_compute_shared_restartable( mbedtls_ecp_group *grp,\n                         mbedtls_mpi *z,\n                         const mbedtls_ecp_point *Q, const mbedtls_mpi *d,\n                         int (*f_rng)(void *, unsigned char *, size_t),\n                         void *p_rng,\n                         mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n    mbedtls_ecp_point P;\n\n    mbedtls_ecp_point_init( \u0026P );\n\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_restartable( grp, \u0026P, d, Q,\n                                                  f_rng, p_rng, rs_ctx ) );\n\n    if( mbedtls_ecp_is_zero( \u0026P ) )\n    {\n        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( z, \u0026P.X ) );\n\ncleanup:\n    mbedtls_ecp_point_free( \u0026P );\n\n    return( ret );\n}","filepath":"library/ecdh.c","line_number":85,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.14.0"},"425345":{"score":0.65399903,"function_name":"mbedtls_ecdh_init","code":"void mbedtls_ecdh_init( mbedtls_ecdh_context *ctx )\n{\n    ECDH_VALIDATE( ctx != NULL );\n\n#if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)\n    ecdh_init_internal( ctx );\n    mbedtls_ecp_point_init( \u0026ctx-\u003eVi  );\n    mbedtls_ecp_point_init( \u0026ctx-\u003eVf  );\n    mbedtls_mpi_init( \u0026ctx-\u003e_d );\n#else\n    memset( ctx, 0, sizeof( mbedtls_ecdh_context ) );\n\n    ctx-\u003evar = MBEDTLS_ECDH_VARIANT_NONE;\n#endif\n    ctx-\u003epoint_format = MBEDTLS_ECP_PF_UNCOMPRESSED;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    ctx-\u003erestart_enabled = 0;\n#endif\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":180,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.9.0-rc1"},"425456":{"score":0.7163259,"function_name":"ecdh_setup_internal","code":"static int ecdh_setup_internal( mbedtls_ecdh_context_mbed *ctx,\n                                mbedtls_ecp_group_id grp_id )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    ret = mbedtls_ecp_group_load( \u0026ctx-\u003egrp, grp_id );\n    if( ret != 0 )\n    {\n        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );\n    }\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":200,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.9.0-rc1"},"425671":{"score":0.7577674,"function_name":"mbedtls_ecdh_free","code":"void mbedtls_ecdh_free( mbedtls_ecdh_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n#if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)\n    mbedtls_ecp_point_free( \u0026ctx-\u003eVi );\n    mbedtls_ecp_point_free( \u0026ctx-\u003eVf );\n    mbedtls_mpi_free( \u0026ctx-\u003e_d );\n    ecdh_free_internal( ctx );\n#else\n    switch( ctx-\u003evar )\n    {\n        case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:\n            ecdh_free_internal( \u0026ctx-\u003ectx.mbed_ecdh );\n            break;\n        default:\n            break;\n    }\n\n    ctx-\u003epoint_format = MBEDTLS_ECP_PF_UNCOMPRESSED;\n    ctx-\u003evar = MBEDTLS_ECDH_VARIANT_NONE;\n    ctx-\u003egrp_id = MBEDTLS_ECP_DP_NONE;\n#endif\n}","filepath":"library/ecdh.c","line_number":256,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.18.0"},"425777":{"score":0.8399166,"function_name":"ecdh_make_params_internal","code":"static int ecdh_make_params_internal( mbedtls_ecdh_context_mbed *ctx,\n                                      size_t *olen, int point_format,\n                                      unsigned char *buf, size_t blen,\n                                      int (*f_rng)(void *,\n                                                   unsigned char *,\n                                                   size_t),\n                                      void *p_rng,\n                                      int restart_enabled )\n{\n    int ret;\n    size_t grp_len, pt_len;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    mbedtls_ecp_restart_ctx *rs_ctx = NULL;\n#endif\n\n    if( ctx-\u003egrp.pbits == 0 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( restart_enabled )\n        rs_ctx = \u0026ctx-\u003ers;\n#else\n    (void) restart_enabled;\n#endif\n\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ( ret = ecdh_gen_public_restartable( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                             f_rng, p_rng, rs_ctx ) ) != 0 )\n        return( ret );\n#else\n    if( ( ret = mbedtls_ecdh_gen_public( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                         f_rng, p_rng ) ) != 0 )\n        return( ret );\n#endif /* MBEDTLS_ECP_RESTARTABLE */\n\n    if( ( ret = mbedtls_ecp_tls_write_group( \u0026ctx-\u003egrp, \u0026grp_len, buf,\n                                             blen ) ) != 0 )\n        return( ret );\n\n    buf += grp_len;\n    blen -= grp_len;\n\n    if( ( ret = mbedtls_ecp_tls_write_point( \u0026ctx-\u003egrp, \u0026ctx-\u003eQ, point_format,\n                                             \u0026pt_len, buf, blen ) ) != 0 )\n        return( ret );\n\n    *olen = grp_len + pt_len;\n    return( 0 );\n}","filepath":"library/ecdh.c","line_number":282,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.18.0"},"426176":{"score":0.7610754,"function_name":"mbedtls_ecdh_read_params","code":"int mbedtls_ecdh_read_params( mbedtls_ecdh_context *ctx,\n                              const unsigned char **buf,\n                              const unsigned char *end )\n{\n    int ret;\n    mbedtls_ecp_group_id grp_id;\n    ECDH_VALIDATE_RET( ctx != NULL );\n    ECDH_VALIDATE_RET( buf != NULL );\n    ECDH_VALIDATE_RET( *buf != NULL );\n    ECDH_VALIDATE_RET( end != NULL );\n\n    if( ( ret = mbedtls_ecp_tls_read_group_id( \u0026grp_id, buf, end - *buf ) )\n            != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_ecdh_setup( ctx, grp_id ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)\n    return( ecdh_read_params_internal( ctx, buf, end ) );\n#else\n    switch( ctx-\u003evar )\n    {\n        case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:\n            return( ecdh_read_params_internal( \u0026ctx-\u003ectx.mbed_ecdh,\n                                               buf, end ) );\n        default:\n            return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n    }\n#endif\n}","filepath":"library/ecdh.c","line_number":389,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.18.0"},"426344":{"score":0.77665895,"function_name":"ecdh_get_params_internal","code":"static int ecdh_get_params_internal( mbedtls_ecdh_context_mbed *ctx,\n                                     const mbedtls_ecp_keypair *key,\n                                     mbedtls_ecdh_side side )\n{\n    int ret;\n\n    /* If it's not our key, just import the public part as Qp */\n    if( side == MBEDTLS_ECDH_THEIRS )\n        return( mbedtls_ecp_copy( \u0026ctx-\u003eQp, \u0026key-\u003eQ ) );\n\n    /* Our key: import public (as Q) and private parts */\n    if( side != MBEDTLS_ECDH_OURS )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    if( ( ret = mbedtls_ecp_copy( \u0026ctx-\u003eQ, \u0026key-\u003eQ ) ) != 0 ||\n        ( ret = mbedtls_mpi_copy( \u0026ctx-\u003ed, \u0026key-\u003ed ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}","filepath":"library/ecdh.c","line_number":421,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.18.0"},"426501":{"score":0.58543074,"function_name":"mbedtls_mpi_shift_l_mod","code":"static inline int mbedtls_mpi_shift_l_mod( const mbedtls_ecp_group *grp,\n                                           mbedtls_mpi *X,\n                                           size_t count )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( X, count ) );\n    MOD_ADD( *X );\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1294,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"426573":{"score":0.8240332,"function_name":"ecdh_make_public_internal","code":"static int ecdh_make_public_internal( mbedtls_ecdh_context_mbed *ctx,\n                                      size_t *olen, int point_format,\n                                      unsigned char *buf, size_t blen,\n                                      int (*f_rng)(void *,\n                                                   unsigned char *,\n                                                   size_t),\n                                      void *p_rng,\n                                      int restart_enabled )\n{\n    int ret;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    mbedtls_ecp_restart_ctx *rs_ctx = NULL;\n#endif\n\n    if( ctx-\u003egrp.pbits == 0 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( restart_enabled )\n        rs_ctx = \u0026ctx-\u003ers;\n#else\n    (void) restart_enabled;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ( ret = ecdh_gen_public_restartable( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                             f_rng, p_rng, rs_ctx ) ) != 0 )\n        return( ret );\n#else\n    if( ( ret = mbedtls_ecdh_gen_public( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                         f_rng, p_rng ) ) != 0 )\n        return( ret );\n#endif /* MBEDTLS_ECP_RESTARTABLE */\n\n    return mbedtls_ecp_tls_write_point( \u0026ctx-\u003egrp, \u0026ctx-\u003eQ, point_format, olen,\n                                        buf, blen );\n}","filepath":"library/ecdh.c","line_number":485,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.18.0"},"426766":{"score":0.85435283,"function_name":"ecdh_read_public_internal","code":"static int ecdh_read_public_internal( mbedtls_ecdh_context_mbed *ctx,\n                                      const unsigned char *buf, size_t blen )\n{\n    int ret;\n    const unsigned char *p = buf;\n\n    if( ( ret = mbedtls_ecp_tls_read_point( \u0026ctx-\u003egrp, \u0026ctx-\u003eQp, \u0026p,\n                                            blen ) ) != 0 )\n        return( ret );\n\n    if( (size_t)( p - buf ) != blen )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    return( 0 );\n}","filepath":"library/ecdh.c","line_number":558,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.18.0"},"426947":{"score":0.81770545,"function_name":"mbedtls_ecdh_calc_secret","code":"int mbedtls_ecdh_calc_secret( mbedtls_ecdh_context *ctx, size_t *olen,\n                      unsigned char *buf, size_t blen,\n                      int (*f_rng)(void *, unsigned char *, size_t),\n                      void *p_rng )\n{\n    int ret;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    mbedtls_ecp_restart_ctx *rs_ctx = NULL;\n#endif\n\n    if( ctx == NULL || ctx-\u003egrp.pbits == 0 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ctx-\u003erestart_enabled )\n        rs_ctx = \u0026ctx-\u003ers;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ( ret = ecdh_compute_shared_restartable( \u0026ctx-\u003egrp,\n                    \u0026ctx-\u003ez, \u0026ctx-\u003eQp, \u0026ctx-\u003ed, f_rng, p_rng, rs_ctx ) ) != 0 )\n    {\n        return( ret );\n    }\n#else\n    if( ( ret = mbedtls_ecdh_compute_shared( \u0026ctx-\u003egrp, \u0026ctx-\u003ez, \u0026ctx-\u003eQp,\n                                             \u0026ctx-\u003ed, f_rng, p_rng ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_ECP_RESTARTABLE */\n\n    if( mbedtls_mpi_size( \u0026ctx-\u003ez ) \u003e blen )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    *olen = ctx-\u003egrp.pbits / 8 + ( ( ctx-\u003egrp.pbits % 8 ) != 0 );\n    return mbedtls_mpi_write_binary( \u0026ctx-\u003ez, buf, *olen );\n}","filepath":"library/ecdh.c","line_number":339,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.14.0"},"427236":{"score":0.81603396,"function_name":"mbedtls_ecp_grp_id_list","code":"const mbedtls_ecp_group_id *mbedtls_ecp_grp_id_list( void )\n{\n    static int init_done = 0;\n\n    if( ! init_done )\n    {\n        size_t i = 0;\n        const mbedtls_ecp_curve_info *curve_info;\n\n        for( curve_info = mbedtls_ecp_curve_list();\n             curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n             curve_info++ )\n        {\n            ecp_supported_grp_id[i++] = curve_info-\u003egrp_id;\n        }\n        ecp_supported_grp_id[i] = MBEDTLS_ECP_DP_NONE;\n\n        init_done = 1;\n    }\n\n    return( ecp_supported_grp_id );\n}","filepath":"library/ecp.c","line_number":577,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"427351":{"score":0.69373,"function_name":"mbedtls_ecp_curve_info_from_grp_id","code":"const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_grp_id( mbedtls_ecp_group_id grp_id )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    for( curve_info = mbedtls_ecp_curve_list();\n         curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n         curve_info++ )\n    {\n        if( curve_info-\u003egrp_id == grp_id )\n            return( curve_info );\n    }\n\n    return( NULL );\n}","filepath":"library/ecp.c","line_number":603,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"427412":{"score":0.75947577,"function_name":"mbedtls_ecp_curve_info_from_tls_id","code":"const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_tls_id( uint16_t tls_id )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    for( curve_info = mbedtls_ecp_curve_list();\n         curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n         curve_info++ )\n    {\n        if( curve_info-\u003etls_id == tls_id )\n            return( curve_info );\n    }\n\n    return( NULL );\n}","filepath":"library/ecp.c","line_number":621,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"427483":{"score":0.81673825,"function_name":"mbedtls_ecp_curve_info_from_name","code":"const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name( const char *name )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    if( name == NULL )\n        return( NULL );\n\n    for( curve_info = mbedtls_ecp_curve_list();\n         curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n         curve_info++ )\n    {\n        if( strcmp( curve_info-\u003ename, name ) == 0 )\n            return( curve_info );\n    }\n\n    return( NULL );\n}","filepath":"library/ecp.c","line_number":639,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"427577":{"score":0.70901895,"function_name":"mbedtls_ecp_get_type","code":"mbedtls_ecp_curve_type mbedtls_ecp_get_type( const mbedtls_ecp_group *grp )\n{\n    if( grp-\u003eG.X.p == NULL )\n        return( MBEDTLS_ECP_TYPE_NONE );\n\n    if( grp-\u003eG.Y.p == NULL )\n        return( MBEDTLS_ECP_TYPE_MONTGOMERY );\n    else\n        return( MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS );\n}","filepath":"library/ecp.c","line_number":660,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"427706":{"score":0.71967566,"function_name":"mbedtls_ecp_group_init","code":"void mbedtls_ecp_group_init( mbedtls_ecp_group *grp )\n{\n    ECP_VALIDATE( grp != NULL );\n\n    grp-\u003eid = MBEDTLS_ECP_DP_NONE;\n    mbedtls_mpi_init( \u0026grp-\u003eP );\n    mbedtls_mpi_init( \u0026grp-\u003eA );\n    mbedtls_mpi_init( \u0026grp-\u003eB );\n    mbedtls_ecp_point_init( \u0026grp-\u003eG );\n    mbedtls_mpi_init( \u0026grp-\u003eN );\n    grp-\u003epbits = 0;\n    grp-\u003enbits = 0;\n    grp-\u003eh = 0;\n    grp-\u003emodp = NULL;\n    grp-\u003et_pre = NULL;\n    grp-\u003et_post = NULL;\n    grp-\u003et_data = NULL;\n    grp-\u003eT = NULL;\n    grp-\u003eT_size = 0;\n}","filepath":"library/ecp.c","line_number":686,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"427996":{"score":0.77761626,"function_name":"mbedtls_ecp_point_free","code":"void mbedtls_ecp_point_free( mbedtls_ecp_point *pt )\n{\n    if( pt == NULL )\n        return;\n\n    mbedtls_mpi_free( \u0026( pt-\u003eX ) );\n    mbedtls_mpi_free( \u0026( pt-\u003eY ) );\n    mbedtls_mpi_free( \u0026( pt-\u003eZ ) );\n}","filepath":"library/ecp.c","line_number":722,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"428079":{"score":0.7944422,"function_name":"mbedtls_ecp_group_free","code":"void mbedtls_ecp_group_free( mbedtls_ecp_group *grp )\n{\n    size_t i;\n\n    if( grp == NULL )\n        return;\n\n    if( grp-\u003eh != 1 )\n    {\n        mbedtls_mpi_free( \u0026grp-\u003eP );\n        mbedtls_mpi_free( \u0026grp-\u003eA );\n        mbedtls_mpi_free( \u0026grp-\u003eB );\n        mbedtls_ecp_point_free( \u0026grp-\u003eG );\n        mbedtls_mpi_free( \u0026grp-\u003eN );\n    }\n\n    if( grp-\u003eT != NULL )\n    {\n        for( i = 0; i \u003c grp-\u003eT_size; i++ )\n            mbedtls_ecp_point_free( \u0026grp-\u003eT[i] );\n        mbedtls_free( grp-\u003eT );\n    }\n\n    mbedtls_platform_zeroize( grp, sizeof( mbedtls_ecp_group ) );\n}","filepath":"library/ecp.c","line_number":735,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"428317":{"score":0.77398825,"function_name":"mbedtls_ecp_keypair_free","code":"void mbedtls_ecp_keypair_free( mbedtls_ecp_keypair *key )\n{\n    if( key == NULL )\n        return;\n\n    mbedtls_ecp_group_free( \u0026key-\u003egrp );\n    mbedtls_mpi_free( \u0026key-\u003ed );\n    mbedtls_ecp_point_free( \u0026key-\u003eQ );\n}","filepath":"library/ecp.c","line_number":764,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"428402":{"score":0.7532375,"function_name":"mbedtls_ecp_copy","code":"int mbedtls_ecp_copy( mbedtls_ecp_point *P, const mbedtls_ecp_point *Q )\n{\n    int ret;\n    ECP_VALIDATE_RET( P != NULL );\n    ECP_VALIDATE_RET( Q != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026P-\u003eX, \u0026Q-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026P-\u003eY, \u0026Q-\u003eY ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026P-\u003eZ, \u0026Q-\u003eZ ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":632,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.18.0"},"428572":{"score":0.7734876,"function_name":"mbedtls_ecp_set_zero","code":"int mbedtls_ecp_set_zero( mbedtls_ecp_point *pt )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    ECP_VALIDATE_RET( pt != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eX , 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eY , 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eZ , 0 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":805,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"428738":{"score":0.89206195,"function_name":"mbedtls_ecp_point_cmp","code":"int mbedtls_ecp_point_cmp( const mbedtls_ecp_point *P,\n                           const mbedtls_ecp_point *Q )\n{\n    ECP_VALIDATE_RET( P != NULL );\n    ECP_VALIDATE_RET( Q != NULL );\n\n    if( mbedtls_mpi_cmp_mpi( \u0026P-\u003eX, \u0026Q-\u003eX ) == 0 \u0026\u0026\n        mbedtls_mpi_cmp_mpi( \u0026P-\u003eY, \u0026Q-\u003eY ) == 0 \u0026\u0026\n        mbedtls_mpi_cmp_mpi( \u0026P-\u003eZ, \u0026Q-\u003eZ ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n}","filepath":"library/ecp.c","line_number":831,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"428854":{"score":0.7443218,"function_name":"mbedtls_ecp_point_read_string","code":"int mbedtls_ecp_point_read_string( mbedtls_ecp_point *P, int radix,\n                           const char *x, const char *y )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    ECP_VALIDATE_RET( P != NULL );\n    ECP_VALIDATE_RET( x != NULL );\n    ECP_VALIDATE_RET( y != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( \u0026P-\u003eX, radix, x ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( \u0026P-\u003eY, radix, y ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026P-\u003eZ, 1 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":850,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"428976":{"score":0.6878667,"function_name":"mbedtls_ecp_point_write_binary","code":"int mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp,\n                                    const mbedtls_ecp_point *P,\n                                    int format, size_t *olen,\n                                    unsigned char *buf, size_t buflen )\n{\n    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;\n    size_t plen;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( P    != NULL );\n    ECP_VALIDATE_RET( olen != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( format == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n                      format == MBEDTLS_ECP_PF_COMPRESSED );\n\n    plen = mbedtls_mpi_size( \u0026grp-\u003eP );\n\n#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)\n    (void) format; /* Montgomery curves always use the same point format */\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n    {\n        *olen = plen;\n        if( buflen \u003c *olen )\n            return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( \u0026P-\u003eX, buf, plen ) );\n    }\n#endif\n#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n    {\n        /*\n         * Common case: P == 0\n         */\n        if( mbedtls_mpi_cmp_int( \u0026P-\u003eZ, 0 ) == 0 )\n        {\n            if( buflen \u003c 1 )\n                return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n            buf[0] = 0x00;\n            *olen = 1;\n\n            return( 0 );\n        }\n\n        if( format == MBEDTLS_ECP_PF_UNCOMPRESSED )\n        {\n            *olen = 2 * plen + 1;\n\n            if( buflen \u003c *olen )\n                return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n            buf[0] = 0x04;\n            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026P-\u003eX, buf + 1, plen ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026P-\u003eY, buf + 1 + plen, plen ) );\n        }\n        else if( format == MBEDTLS_ECP_PF_COMPRESSED )\n        {\n            *olen = plen + 1;\n\n            if( buflen \u003c *olen )\n                return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n            buf[0] = 0x02 + mbedtls_mpi_get_bit( \u0026P-\u003eY, 0 );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026P-\u003eX, buf + 1, plen ) );\n        }\n    }\n#endif\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":869,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"429320":{"score":0.7440818,"function_name":"mbedtls_ecp_point_read_binary","code":"int mbedtls_ecp_point_read_binary( const mbedtls_ecp_group *grp,\n                                   mbedtls_ecp_point *pt,\n                                   const unsigned char *buf, size_t ilen )\n{\n    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;\n    size_t plen;\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( pt  != NULL );\n    ECP_VALIDATE_RET( buf != NULL );\n\n    if( ilen \u003c 1 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    plen = mbedtls_mpi_size( \u0026grp-\u003eP );\n\n#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n    {\n        if( plen != ilen )\n            return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( \u0026pt-\u003eX, buf, plen ) );\n        mbedtls_mpi_free( \u0026pt-\u003eY );\n\n        if( grp-\u003eid == MBEDTLS_ECP_DP_CURVE25519 )\n            /* Set most significant bit to 0 as prescribed in RFC7748 §5 */\n            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( \u0026pt-\u003eX, plen * 8 - 1, 0 ) );\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eZ, 1 ) );\n    }\n#endif\n#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n    {\n        if( buf[0] == 0x00 )\n        {\n            if( ilen == 1 )\n                return( mbedtls_ecp_set_zero( pt ) );\n            else\n                return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n        }\n\n        if( buf[0] != 0x04 )\n            return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );\n\n        if( ilen != 2 * plen + 1 )\n            return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026pt-\u003eX, buf + 1, plen ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026pt-\u003eY,\n                                                  buf + 1 + plen, plen ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eZ, 1 ) );\n    }\n#endif\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":944,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"429577":{"score":0.8803996,"function_name":"mbedtls_ecp_tls_read_point","code":"int mbedtls_ecp_tls_read_point( const mbedtls_ecp_group *grp,\n                                mbedtls_ecp_point *pt,\n                                const unsigned char **buf, size_t buf_len )\n{\n    unsigned char data_len;\n    const unsigned char *buf_start;\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( pt  != NULL );\n    ECP_VALIDATE_RET( buf != NULL );\n    ECP_VALIDATE_RET( *buf != NULL );\n\n    /*\n     * We must have at least two bytes (1 for length, at least one for data)\n     */\n    if( buf_len \u003c 2 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    data_len = *(*buf)++;\n    if( data_len \u003c 1 || data_len \u003e buf_len - 1 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * Save buffer start for read_binary and update buf\n     */\n    buf_start = *buf;\n    *buf += data_len;\n\n    return( mbedtls_ecp_point_read_binary( grp, pt, buf_start, data_len ) );\n}","filepath":"library/ecp.c","line_number":1009,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"429700":{"score":0.86270446,"function_name":"mbedtls_ecp_tls_write_point","code":"int mbedtls_ecp_tls_write_point( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt,\n                         int format, size_t *olen,\n                         unsigned char *buf, size_t blen )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( pt   != NULL );\n    ECP_VALIDATE_RET( olen != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( format == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n                      format == MBEDTLS_ECP_PF_COMPRESSED );\n\n    /*\n     * buffer length must be at least one, for our length byte\n     */\n    if( blen \u003c 1 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    if( ( ret = mbedtls_ecp_point_write_binary( grp, pt, format,\n                    olen, buf + 1, blen - 1) ) != 0 )\n        return( ret );\n\n    /*\n     * write length to the first byte and update total length\n     */\n    buf[0] = (unsigned char) *olen;\n    ++*olen;\n\n    return( 0 );\n}","filepath":"library/ecp.c","line_number":1045,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"429812":{"score":0.7593637,"function_name":"mbedtls_ecp_tls_read_group","code":"int mbedtls_ecp_tls_read_group( mbedtls_ecp_group *grp,\n                                const unsigned char **buf, size_t len )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_ecp_group_id grp_id;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( *buf != NULL );\n\n    if( ( ret = mbedtls_ecp_tls_read_group_id( \u0026grp_id, buf, len ) ) != 0 )\n        return( ret );\n\n    return( mbedtls_ecp_group_load( grp, grp_id ) );\n}","filepath":"library/ecp.c","line_number":1079,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"429928":{"score":0.8744812,"function_name":"mbedtls_ecp_tls_read_group_id","code":"int mbedtls_ecp_tls_read_group_id( mbedtls_ecp_group_id *grp,\n                                   const unsigned char **buf, size_t len )\n{\n    uint16_t tls_id;\n    const mbedtls_ecp_curve_info *curve_info;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( *buf != NULL );\n\n    /*\n     * We expect at least three bytes (see below)\n     */\n    if( len \u003c 3 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * First byte is curve_type; only named_curve is handled\n     */\n    if( *(*buf)++ != MBEDTLS_ECP_TLS_NAMED_CURVE )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * Next two bytes are the namedcurve value\n     */\n    tls_id = *(*buf)++;\n    tls_id \u003c\u003c= 8;\n    tls_id |= *(*buf)++;\n\n    if( ( curve_info = mbedtls_ecp_curve_info_from_tls_id( tls_id ) ) == NULL )\n        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );\n\n    *grp = curve_info-\u003egrp_id;\n\n    return( 0 );\n}","filepath":"library/ecp.c","line_number":1098,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"430081":{"score":0.853789,"function_name":"mbedtls_ecp_tls_write_group","code":"int mbedtls_ecp_tls_write_group( const mbedtls_ecp_group *grp, size_t *olen,\n                         unsigned char *buf, size_t blen )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( olen != NULL );\n\n    if( ( curve_info = mbedtls_ecp_curve_info_from_grp_id( grp-\u003eid ) ) == NULL )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * We are going to write 3 bytes (see below)\n     */\n    *olen = 3;\n    if( blen \u003c *olen )\n        return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n    /*\n     * First byte is curve_type, always named_curve\n     */\n    *buf++ = MBEDTLS_ECP_TLS_NAMED_CURVE;\n\n    /*\n     * Next two bytes are the namedcurve value\n     */\n    buf[0] = curve_info-\u003etls_id \u003e\u003e 8;\n    buf[1] = curve_info-\u003etls_id \u0026 0xFF;\n\n    return( 0 );\n}","filepath":"library/ecp.c","line_number":1137,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"430205":{"score":0.86153805,"function_name":"ecp_modp","code":"static int ecp_modp( mbedtls_mpi *N, const mbedtls_ecp_group *grp )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    if( grp-\u003emodp == NULL )\n        return( mbedtls_mpi_mod_mpi( N, N, \u0026grp-\u003eP ) );\n\n    /* N-\u003es \u003c 0 is a much faster test, which fails only if N is 0 */\n    if( ( N-\u003es \u003c 0 \u0026\u0026 mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||\n        mbedtls_mpi_bitlen( N ) \u003e 2 * grp-\u003epbits )\n    {\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n    }\n\n    MBEDTLS_MPI_CHK( grp-\u003emodp( N ) );\n\n    /* N-\u003es \u003c 0 is a much faster test, which fails only if N is 0 */\n    while( N-\u003es \u003c 0 \u0026\u0026 mbedtls_mpi_cmp_int( N, 0 ) != 0 )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, \u0026grp-\u003eP ) );\n\n    while( mbedtls_mpi_cmp_mpi( N, \u0026grp-\u003eP ) \u003e= 0 )\n        /* we known P, N and the result are positive */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, \u0026grp-\u003eP ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1175,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"430496":{"score":0.76823413,"function_name":"ecp_normalize_jac","code":"static int ecp_normalize_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_mpi Zi, ZZi;\n\n    if( mbedtls_mpi_cmp_int( \u0026pt-\u003eZ, 0 ) == 0 )\n        return( 0 );\n\n#if defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_normalize_jac( grp, pt ) );\n#endif /* MBEDTLS_ECP_NORMALIZE_JAC_ALT */\n\n    mbedtls_mpi_init( \u0026Zi ); mbedtls_mpi_init( \u0026ZZi );\n\n    /*\n     * X = X / Z^2  mod p\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( \u0026Zi,      \u0026pt-\u003eZ,     \u0026grp-\u003eP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026ZZi,     \u0026Zi,        \u0026Zi     ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026pt-\u003eX,   \u0026pt-\u003eX,     \u0026ZZi    ) );\n\n    /*\n     * Y = Y / Z^3  mod p\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026pt-\u003eY,   \u0026pt-\u003eY,     \u0026ZZi    ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026pt-\u003eY,   \u0026pt-\u003eY,     \u0026Zi     ) );\n\n    /*\n     * Z = 1\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eZ, 1 ) );\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026Zi ); mbedtls_mpi_free( \u0026ZZi );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1303,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.25.0"},"431026":{"score":0.80886614,"function_name":"ecp_normalize_jac_many","code":"static int ecp_normalize_jac_many( const ecp_group *grp,\n                                   ecp_point *T[], size_t t_len )\n{\n    int ret;\n    size_t i;\n    mpi *c, u, Zi, ZZi;\n\n    if( t_len \u003c 2 )\n        return( ecp_normalize_jac( grp, *T ) );\n\n    if( ( c = (mpi *) polarssl_malloc( t_len * sizeof( mpi ) ) ) == NULL )\n        return( POLARSSL_ERR_ECP_MALLOC_FAILED );\n\n    mpi_init( \u0026u ); mpi_init( \u0026Zi ); mpi_init( \u0026ZZi );\n    for( i = 0; i \u003c t_len; i++ )\n        mpi_init( \u0026c[i] );\n\n    /*\n     * c[i] = Z_0 * ... * Z_i\n     */\n    MPI_CHK( mpi_copy( \u0026c[0], \u0026T[0]-\u003eZ ) );\n    for( i = 1; i \u003c t_len; i++ )\n    {\n        MPI_CHK( mpi_mul_mpi( \u0026c[i], \u0026c[i-1], \u0026T[i]-\u003eZ ) );\n        MOD_MUL( c[i] );\n    }\n\n    /*\n     * u = 1 / (Z_0 * ... * Z_n) mod P\n     */\n    MPI_CHK( mpi_inv_mod( \u0026u, \u0026c[t_len-1], \u0026grp-\u003eP ) );\n\n    for( i = t_len - 1; ; i-- )\n    {\n        /*\n         * Zi = 1 / Z_i mod p\n         * u = 1 / (Z_0 * ... * Z_i) mod P\n         */\n        if( i == 0 ) {\n            MPI_CHK( mpi_copy( \u0026Zi, \u0026u ) );\n        }\n        else\n        {\n            MPI_CHK( mpi_mul_mpi( \u0026Zi, \u0026u, \u0026c[i-1]  ) ); MOD_MUL( Zi );\n            MPI_CHK( mpi_mul_mpi( \u0026u,  \u0026u, \u0026T[i]-\u003eZ ) ); MOD_MUL( u );\n        }\n\n        /*\n         * proceed as in normalize()\n         */\n        MPI_CHK( mpi_mul_mpi( \u0026ZZi,     \u0026Zi,      \u0026Zi  ) ); MOD_MUL( ZZi );\n        MPI_CHK( mpi_mul_mpi( \u0026T[i]-\u003eX, \u0026T[i]-\u003eX, \u0026ZZi ) ); MOD_MUL( T[i]-\u003eX );\n        MPI_CHK( mpi_mul_mpi( \u0026T[i]-\u003eY, \u0026T[i]-\u003eY, \u0026ZZi ) ); MOD_MUL( T[i]-\u003eY );\n        MPI_CHK( mpi_mul_mpi( \u0026T[i]-\u003eY, \u0026T[i]-\u003eY, \u0026Zi  ) ); MOD_MUL( T[i]-\u003eY );\n\n        /*\n         * Post-precessing: reclaim some memory by shrinking coordinates\n         * - not storing Z (always 1)\n         * - shrinking other coordinates, but still keeping the same number of\n         *   limbs as P, as otherwise it will too likely be regrown too fast.\n         */\n        MPI_CHK( mpi_shrink( \u0026T[i]-\u003eX, grp-\u003eP.n ) );\n        MPI_CHK( mpi_shrink( \u0026T[i]-\u003eY, grp-\u003eP.n ) );\n        mpi_free( \u0026T[i]-\u003eZ );\n\n        if( i == 0 )\n            break;\n    }\n\ncleanup:\n\n    mpi_free( \u0026u ); mpi_free( \u0026Zi ); mpi_free( \u0026ZZi );\n    for( i = 0; i \u003c t_len; i++ )\n        mpi_free( \u0026c[i] );\n    polarssl_free( c );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":808,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.9"},"432458":{"score":0.7161373,"function_name":"ecp_safe_invert_jac","code":"static int ecp_safe_invert_jac( const mbedtls_ecp_group *grp,\n                            mbedtls_ecp_point *Q,\n                            unsigned char inv )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char nonzero;\n    mbedtls_mpi mQY;\n\n    mbedtls_mpi_init( \u0026mQY );\n\n    /* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026mQY, \u0026grp-\u003eP, \u0026Q-\u003eY ) );\n    nonzero = mbedtls_mpi_cmp_int( \u0026Q-\u003eY, 0 ) != 0;\n    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026Q-\u003eY, \u0026mQY, inv \u0026 nonzero ) );\n\ncleanup:\n    mbedtls_mpi_free( \u0026mQY );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1465,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"432671":{"score":0.6382036,"function_name":"ecp_double_jac","code":"static int ecp_double_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                           const mbedtls_ecp_point *P )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_mpi M, S, T, U;\n\n#if defined(MBEDTLS_SELF_TEST)\n    dbl_count++;\n#endif\n\n#if defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_double_jac( grp, R, P ) );\n#endif /* MBEDTLS_ECP_DOUBLE_JAC_ALT */\n\n    mbedtls_mpi_init( \u0026M ); mbedtls_mpi_init( \u0026S ); mbedtls_mpi_init( \u0026T ); mbedtls_mpi_init( \u0026U );\n\n    /* Special case for A = -3 */\n    if( grp-\u003eA.p == NULL )\n    {\n        /* M = 3(X + Z^2)(X - Z^2) */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S,  \u0026P-\u003eZ,  \u0026P-\u003eZ   ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026T,  \u0026P-\u003eX,  \u0026S      ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026U,  \u0026P-\u003eX,  \u0026S      ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S,  \u0026T,     \u0026U      ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( \u0026M,  \u0026S,     3       ) ); MOD_ADD( M );\n    }\n    else\n    {\n        /* M = 3.X^2 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S,  \u0026P-\u003eX,  \u0026P-\u003eX   ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( \u0026M,  \u0026S,     3       ) ); MOD_ADD( M );\n\n        /* Optimize away for \"koblitz\" curves with A = 0 */\n        if( mbedtls_mpi_cmp_int( \u0026grp-\u003eA, 0 ) != 0 )\n        {\n            /* M += A.Z^4 */\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S,  \u0026P-\u003eZ,  \u0026P-\u003eZ   ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T,  \u0026S,     \u0026S      ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S,  \u0026T,     \u0026grp-\u003eA ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026M,  \u0026M,     \u0026S      ) );\n        }\n    }\n\n    /* S = 4.X.Y^2 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T,  \u0026P-\u003eY,  \u0026P-\u003eY   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l_mod( grp, \u0026T,  1               ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S,  \u0026P-\u003eX,  \u0026T      ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l_mod( grp, \u0026S,  1               ) );\n\n    /* U = 8.Y^4 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026U,  \u0026T,     \u0026T      ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l_mod( grp, \u0026U,  1               ) );\n\n    /* T = M^2 - 2.S */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T,  \u0026M,     \u0026M      ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026T,  \u0026T,     \u0026S      ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026T,  \u0026T,     \u0026S      ) );\n\n    /* S = M(S - T) - U */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026S,  \u0026S,     \u0026T      ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S,  \u0026S,     \u0026M      ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026S,  \u0026S,     \u0026U      ) );\n\n    /* U = 2.Y.Z */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026U,  \u0026P-\u003eY,  \u0026P-\u003eZ   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l_mod( grp, \u0026U,  1               ) );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eX, \u0026T ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eY, \u0026S ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eZ, \u0026U ) );\n\ncleanup:\n    mbedtls_mpi_free( \u0026M ); mbedtls_mpi_free( \u0026S ); mbedtls_mpi_free( \u0026T ); mbedtls_mpi_free( \u0026U );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1477,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.25.0"},"435341":{"score":0.6667504,"function_name":"ecp_add_mixed","code":"static int ecp_add_mixed( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                          const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_mpi T1, T2, T3, T4, X, Y, Z;\n\n#if defined(MBEDTLS_SELF_TEST)\n    add_count++;\n#endif\n\n#if defined(MBEDTLS_ECP_ADD_MIXED_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_add_mixed( grp, R, P, Q ) );\n#endif /* MBEDTLS_ECP_ADD_MIXED_ALT */\n\n    /*\n     * Trivial cases: P == 0 or Q == 0 (case 1)\n     */\n    if( mbedtls_mpi_cmp_int( \u0026P-\u003eZ, 0 ) == 0 )\n        return( mbedtls_ecp_copy( R, Q ) );\n\n    if( Q-\u003eZ.p != NULL \u0026\u0026 mbedtls_mpi_cmp_int( \u0026Q-\u003eZ, 0 ) == 0 )\n        return( mbedtls_ecp_copy( R, P ) );\n\n    /*\n     * Make sure Q coordinates are normalized\n     */\n    if( Q-\u003eZ.p != NULL \u0026\u0026 mbedtls_mpi_cmp_int( \u0026Q-\u003eZ, 1 ) != 0 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    mbedtls_mpi_init( \u0026T1 ); mbedtls_mpi_init( \u0026T2 ); mbedtls_mpi_init( \u0026T3 ); mbedtls_mpi_init( \u0026T4 );\n    mbedtls_mpi_init( \u0026X ); mbedtls_mpi_init( \u0026Y ); mbedtls_mpi_init( \u0026Z );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T1,  \u0026P-\u003eZ,  \u0026P-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T2,  \u0026T1,    \u0026P-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T1,  \u0026T1,    \u0026Q-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T2,  \u0026T2,    \u0026Q-\u003eY ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026T1,  \u0026T1,    \u0026P-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026T2,  \u0026T2,    \u0026P-\u003eY ) );\n\n    /* Special cases (2) and (3) */\n    if( mbedtls_mpi_cmp_int( \u0026T1, 0 ) == 0 )\n    {\n        if( mbedtls_mpi_cmp_int( \u0026T2, 0 ) == 0 )\n        {\n            ret = ecp_double_jac( grp, R, P );\n            goto cleanup;\n        }\n        else\n        {\n            ret = mbedtls_ecp_set_zero( R );\n            goto cleanup;\n        }\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026Z,   \u0026P-\u003eZ,  \u0026T1   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T3,  \u0026T1,    \u0026T1   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T4,  \u0026T3,    \u0026T1   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T3,  \u0026T3,    \u0026P-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026T1, \u0026T3 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l_mod( grp, \u0026T1,  1     ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026X,   \u0026T2,    \u0026T2   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026X,   \u0026X,     \u0026T1   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026X,   \u0026X,     \u0026T4   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026T3,  \u0026T3,    \u0026X    ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T3,  \u0026T3,    \u0026T2   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026T4,  \u0026T4,    \u0026P-\u003eY ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026Y,   \u0026T3,    \u0026T4   ) );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eX, \u0026X ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eY, \u0026Y ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eZ, \u0026Z ) );\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026T1 ); mbedtls_mpi_free( \u0026T2 ); mbedtls_mpi_free( \u0026T3 ); mbedtls_mpi_free( \u0026T4 );\n    mbedtls_mpi_free( \u0026X ); mbedtls_mpi_free( \u0026Y ); mbedtls_mpi_free( \u0026Z );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1573,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.25.0"},"437566":{"score":0.7998693,"function_name":"ecp_randomize_jac","code":"static int ecp_randomize_jac( const ecp_group *grp, ecp_point *pt,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    int ret;\n    mpi l, ll;\n    size_t p_size = ( grp-\u003epbits + 7 ) / 8;\n    int count = 0;\n\n    mpi_init( \u0026l ); mpi_init( \u0026ll );\n\n    /* Generate l such that 1 \u003c l \u003c p */\n    do\n    {\n        MPI_CHK( mpi_fill_random( \u0026l, p_size, f_rng, p_rng ) );\n\n        while( mpi_cmp_mpi( \u0026l, \u0026grp-\u003eP ) \u003e= 0 )\n            MPI_CHK( mpi_shift_r( \u0026l, 1 ) );\n\n        if( count++ \u003e 10 )\n            return( POLARSSL_ERR_ECP_RANDOM_FAILED );\n    }\n    while( mpi_cmp_int( \u0026l, 1 ) \u003c= 0 );\n\n    /* Z = l * Z */\n    MPI_CHK( mpi_mul_mpi( \u0026pt-\u003eZ,   \u0026pt-\u003eZ,     \u0026l  ) ); MOD_MUL( pt-\u003eZ );\n\n    /* X = l^2 * X */\n    MPI_CHK( mpi_mul_mpi( \u0026ll,      \u0026l,         \u0026l  ) ); MOD_MUL( ll );\n    MPI_CHK( mpi_mul_mpi( \u0026pt-\u003eX,   \u0026pt-\u003eX,     \u0026ll ) ); MOD_MUL( pt-\u003eX );\n\n    /* Y = l^3 * Y */\n    MPI_CHK( mpi_mul_mpi( \u0026ll,      \u0026ll,        \u0026l  ) ); MOD_MUL( ll );\n    MPI_CHK( mpi_mul_mpi( \u0026pt-\u003eY,   \u0026pt-\u003eY,     \u0026ll ) ); MOD_MUL( pt-\u003eY );\n\ncleanup:\n    mpi_free( \u0026l ); mpi_free( \u0026ll );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1141,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"438235":{"score":0.9159519,"function_name":"ecp_comb_recode_core","code":"static void ecp_comb_recode_core( unsigned char x[], size_t d,\n                                  unsigned char w, const mbedtls_mpi *m )\n{\n    size_t i, j;\n    unsigned char c, cc, adjust;\n\n    memset( x, 0, d+1 );\n\n    /* First get the classical comb values (except for x_d = 0) */\n    for( i = 0; i \u003c d; i++ )\n        for( j = 0; j \u003c w; j++ )\n            x[i] |= mbedtls_mpi_get_bit( m, i + d * j ) \u003c\u003c j;\n\n    /* Now make sure x_1 .. x_d are odd */\n    c = 0;\n    for( i = 1; i \u003c= d; i++ )\n    {\n        /* Add carry and update it */\n        cc   = x[i] \u0026 c;\n        x[i] = x[i] ^ c;\n        c = cc;\n\n        /* Adjust if needed, avoiding branches */\n        adjust = 1 - ( x[i] \u0026 0x01 );\n        c   |= x[i] \u0026 ( x[i-1] * adjust );\n        x[i] = x[i] ^ ( x[i-1] * adjust );\n        x[i-1] |= adjust \u003c\u003c 7;\n    }\n}","filepath":"library/ecp.c","line_number":1791,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"438636":{"score":0.67399514,"function_name":"ecp_precompute_comb","code":"static int ecp_precompute_comb( const mbedtls_ecp_group *grp,\n                                mbedtls_ecp_point T[], const mbedtls_ecp_point *P,\n                                unsigned char w, size_t d,\n                                mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char i;\n    size_t j = 0;\n    const unsigned char T_size = 1U \u003c\u003c ( w - 1 );\n    mbedtls_ecp_point *cur, *TT[COMB_MAX_PRE - 1];\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n    {\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_dbl )\n            goto dbl;\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_norm_dbl )\n            goto norm_dbl;\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_add )\n            goto add;\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_norm_add )\n            goto norm_add;\n    }\n#else\n    (void) rs_ctx;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n    {\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_dbl;\n\n        /* initial state for the loop */\n        rs_ctx-\u003ersm-\u003ei = 0;\n    }\n\ndbl:\n#endif\n    /*\n     * Set T[0] = P and\n     * T[2^{l-1}] = 2^{dl} P for l = 1 .. w-1 (this is not the final value)\n     */\n    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( \u0026T[0], P ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 rs_ctx-\u003ersm-\u003ei != 0 )\n        j = rs_ctx-\u003ersm-\u003ei;\n    else\n#endif\n        j = 0;\n\n    for( ; j \u003c d * ( w - 1 ); j++ )\n    {\n        MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_DBL );\n\n        i = 1U \u003c\u003c ( j / d );\n        cur = T + i;\n\n        if( j % d == 0 )\n            MBEDTLS_MPI_CHK( mbedtls_ecp_copy( cur, T + ( i \u003e\u003e 1 ) ) );\n\n        MBEDTLS_MPI_CHK( ecp_double_jac( grp, cur, cur ) );\n    }\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_norm_dbl;\n\nnorm_dbl:\n#endif\n    /*\n     * Normalize current elements in T. As T has holes,\n     * use an auxiliary array of pointers to elements in T.\n     */\n    j = 0;\n    for( i = 1; i \u003c T_size; i \u003c\u003c= 1 )\n        TT[j++] = T + i;\n\n    MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_INV + 6 * j - 2 );\n\n    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, j ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_add;\n\nadd:\n#endif\n    /*\n     * Compute the remaining ones using the minimal number of additions\n     * Be careful to update T[2^l] only after using it!\n     */\n    MBEDTLS_ECP_BUDGET( ( T_size - 1 ) * MBEDTLS_ECP_OPS_ADD );\n\n    for( i = 1; i \u003c T_size; i \u003c\u003c= 1 )\n    {\n        j = i;\n        while( j-- )\n            MBEDTLS_MPI_CHK( ecp_add_mixed( grp, \u0026T[i + j], \u0026T[j], \u0026T[i] ) );\n    }\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_norm_add;\n\nnorm_add:\n#endif\n    /*\n     * Normalize final elements in T. Even though there are no holes now, we\n     * still need the auxiliary array for homogeneity with the previous\n     * call. Also, skip T[0] which is already normalised, being a copy of P.\n     */\n    for( j = 0; j + 1 \u003c T_size; j++ )\n        TT[j] = T + j + 1;\n\n    MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_INV + 6 * j - 2 );\n\n    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, j ) );\n\ncleanup:\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026\n        ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n    {\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_dbl )\n            rs_ctx-\u003ersm-\u003ei = j;\n    }\n#endif\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1855,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"439548":{"score":0.76837856,"function_name":"ecp_select_comb","code":"static int ecp_select_comb( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                            const mbedtls_ecp_point T[], unsigned char T_size,\n                            unsigned char i )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char ii, j;\n\n    /* Ignore the \"sign\" bit and scale down */\n    ii =  ( i \u0026 0x7Fu ) \u003e\u003e 1;\n\n    /* Read the whole table to thwart cache-based timing attacks */\n    for( j = 0; j \u003c T_size; j++ )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026R-\u003eX, \u0026T[j].X, j == ii ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026R-\u003eY, \u0026T[j].Y, j == ii ) );\n    }\n\n    /* Safely invert result if i is \"negative\" */\n    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, R, i \u003e\u003e 7 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1992,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"439799":{"score":0.70031416,"function_name":"ecp_mul_comb_core","code":"static int ecp_mul_comb_core( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                              const mbedtls_ecp_point T[], unsigned char T_size,\n                              const unsigned char x[], size_t d,\n                              int (*f_rng)(void *, unsigned char *, size_t),\n                              void *p_rng,\n                              mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_ecp_point Txi;\n    size_t i;\n\n    mbedtls_ecp_point_init( \u0026Txi );\n\n#if !defined(MBEDTLS_ECP_RESTARTABLE)\n    (void) rs_ctx;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026\n        rs_ctx-\u003ersm-\u003estate != ecp_rsm_comb_core )\n    {\n        rs_ctx-\u003ersm-\u003ei = 0;\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_comb_core;\n    }\n\n    /* new 'if' instead of nested for the sake of the 'else' branch */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 rs_ctx-\u003ersm-\u003ei != 0 )\n    {\n        /* restore current index (R already pointing to rs_ctx-\u003ersm-\u003eR) */\n        i = rs_ctx-\u003ersm-\u003ei;\n    }\n    else\n#endif\n    {\n        /* Start with a non-zero point and randomize its coordinates */\n        i = d;\n        MBEDTLS_MPI_CHK( ecp_select_comb( grp, R, T, T_size, x[i] ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026R-\u003eZ, 1 ) );\n#if defined(MBEDTLS_ECP_NO_INTERNAL_RNG)\n        if( f_rng != 0 )\n#endif\n            MBEDTLS_MPI_CHK( ecp_randomize_jac( grp, R, f_rng, p_rng ) );\n    }\n\n    while( i != 0 )\n    {\n        MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD );\n        --i;\n\n        MBEDTLS_MPI_CHK( ecp_double_jac( grp, R, R ) );\n        MBEDTLS_MPI_CHK( ecp_select_comb( grp, \u0026Txi, T, T_size, x[i] ) );\n        MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, R, \u0026Txi ) );\n    }\n\ncleanup:\n\n    mbedtls_ecp_point_free( \u0026Txi );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026\n        ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n    {\n        rs_ctx-\u003ersm-\u003ei = i;\n        /* no need to save R, already pointing to rs_ctx-\u003ersm-\u003eR */\n    }\n#endif\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2022,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"440207":{"score":0.7859901,"function_name":"ecp_comb_recode_scalar","code":"static int ecp_comb_recode_scalar( const mbedtls_ecp_group *grp,\n                                   const mbedtls_mpi *m,\n                                   unsigned char k[COMB_MAX_D + 1],\n                                   size_t d,\n                                   unsigned char w,\n                                   unsigned char *parity_trick )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_mpi M, mm;\n\n    mbedtls_mpi_init( \u0026M );\n    mbedtls_mpi_init( \u0026mm );\n\n    /* N is always odd (see above), just make extra sure */\n    if( mbedtls_mpi_get_bit( \u0026grp-\u003eN, 0 ) != 1 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /* do we need the parity trick? */\n    *parity_trick = ( mbedtls_mpi_get_bit( m, 0 ) == 0 );\n\n    /* execute parity fix in constant time */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026M, m ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026mm, \u0026grp-\u003eN, m ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026M, \u0026mm, *parity_trick ) );\n\n    /* actual scalar recoding */\n    ecp_comb_recode_core( k, d, w, \u0026M );\n\ncleanup:\n    mbedtls_mpi_free( \u0026mm );\n    mbedtls_mpi_free( \u0026M );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2104,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"440547":{"score":0.6703229,"function_name":"ecp_mul_comb_after_precomp","code":"static int ecp_mul_comb_after_precomp( const mbedtls_ecp_group *grp,\n                                mbedtls_ecp_point *R,\n                                const mbedtls_mpi *m,\n                                const mbedtls_ecp_point *T,\n                                unsigned char T_size,\n                                unsigned char w,\n                                size_t d,\n                                int (*f_rng)(void *, unsigned char *, size_t),\n                                void *p_rng,\n                                mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char parity_trick;\n    unsigned char k[COMB_MAX_D + 1];\n    mbedtls_ecp_point *RR = R;\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n    {\n        RR = \u0026rs_ctx-\u003ersm-\u003eR;\n\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_final_norm )\n            goto final_norm;\n    }\n#endif\n\n    MBEDTLS_MPI_CHK( ecp_comb_recode_scalar( grp, m, k, d, w,\n                                            \u0026parity_trick ) );\n    MBEDTLS_MPI_CHK( ecp_mul_comb_core( grp, RR, T, T_size, k, d,\n                                        f_rng, p_rng, rs_ctx ) );\n    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, RR, parity_trick ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_final_norm;\n\nfinal_norm:\n    MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_INV );\n#endif\n    /*\n     * Knowledge of the jacobian coordinates may leak the last few bits of the\n     * scalar [1], and since our MPI implementation isn't constant-flow,\n     * inversion (used for coordinate normalization) may leak the full value\n     * of its input via side-channels [2].\n     *\n     * [1] https://eprint.iacr.org/2003/191\n     * [2] https://eprint.iacr.org/2020/055\n     *\n     * Avoid the leak by randomizing coordinates before we normalize them.\n     */\n#if defined(MBEDTLS_ECP_NO_INTERNAL_RNG)\n    if( f_rng != 0 )\n#endif\n        MBEDTLS_MPI_CHK( ecp_randomize_jac( grp, RR, f_rng, p_rng ) );\n\n    MBEDTLS_MPI_CHK( ecp_normalize_jac( grp, RR ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, RR ) );\n#endif\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2146,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"440940":{"score":0.9027461,"function_name":"ecp_pick_window_size","code":"static unsigned char ecp_pick_window_size( const mbedtls_ecp_group *grp,\n                                           unsigned char p_eq_g )\n{\n    unsigned char w;\n\n    /*\n     * Minimize the number of multiplications, that is minimize\n     * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil( nbits / w )\n     * (see costs of the various parts, with 1S = 1M)\n     */\n    w = grp-\u003enbits \u003e= 384 ? 5 : 4;\n\n    /*\n     * If P == G, pre-compute a bit more, since this may be re-used later.\n     * Just adding one avoids upping the cost of the first mul too much,\n     * and the memory cost too.\n     */\n    if( p_eq_g )\n        w++;\n\n    /*\n     * Make sure w is within bounds.\n     * (The last test is useful only for very small curves in the test suite.)\n     */\n#if( MBEDTLS_ECP_WINDOW_SIZE \u003c 6 )\n    if( w \u003e MBEDTLS_ECP_WINDOW_SIZE )\n        w = MBEDTLS_ECP_WINDOW_SIZE;\n#endif\n    if( w \u003e= grp-\u003enbits )\n        w = 2;\n\n    return( w );\n}","filepath":"library/ecp.c","line_number":2215,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"441040":{"score":0.5689985,"function_name":"ecp_mul_comb","code":"static int ecp_mul_comb( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                         const mbedtls_mpi *m, const mbedtls_ecp_point *P,\n                         int (*f_rng)(void *, unsigned char *, size_t),\n                         void *p_rng,\n                         mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char w, p_eq_g, i;\n    size_t d;\n    unsigned char T_size = 0, T_ok = 0;\n    mbedtls_ecp_point *T = NULL;\n#if !defined(MBEDTLS_ECP_NO_INTERNAL_RNG)\n    ecp_drbg_context drbg_ctx;\n\n    ecp_drbg_init( \u0026drbg_ctx );\n#endif\n\n    ECP_RS_ENTER( rsm );\n\n#if !defined(MBEDTLS_ECP_NO_INTERNAL_RNG)\n    if( f_rng == NULL )\n    {\n        /* Adjust pointers */\n        f_rng = \u0026ecp_drbg_random;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n        if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n            p_rng = \u0026rs_ctx-\u003ersm-\u003edrbg_ctx;\n        else\n#endif\n            p_rng = \u0026drbg_ctx;\n\n        /* Initialize internal DRBG if necessary */\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n        if( rs_ctx == NULL || rs_ctx-\u003ersm == NULL ||\n            rs_ctx-\u003ersm-\u003edrbg_seeded == 0 )\n#endif\n        {\n            const size_t m_len = ( grp-\u003enbits + 7 ) / 8;\n            MBEDTLS_MPI_CHK( ecp_drbg_seed( p_rng, m, m_len ) );\n        }\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n        if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n            rs_ctx-\u003ersm-\u003edrbg_seeded = 1;\n#endif\n    }\n#endif /* !MBEDTLS_ECP_NO_INTERNAL_RNG */\n\n    /* Is P the base point ? */\n#if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1\n    p_eq_g = ( mbedtls_mpi_cmp_mpi( \u0026P-\u003eY, \u0026grp-\u003eG.Y ) == 0 \u0026\u0026\n               mbedtls_mpi_cmp_mpi( \u0026P-\u003eX, \u0026grp-\u003eG.X ) == 0 );\n#else\n    p_eq_g = 0;\n#endif\n\n    /* Pick window size and deduce related sizes */\n    w = ecp_pick_window_size( grp, p_eq_g );\n    T_size = 1U \u003c\u003c ( w - 1 );\n    d = ( grp-\u003enbits + w - 1 ) / w;\n\n    /* Pre-computed table: do we have it already for the base point? */\n    if( p_eq_g \u0026\u0026 grp-\u003eT != NULL )\n    {\n        /* second pointer to the same table, will be deleted on exit */\n        T = grp-\u003eT;\n        T_ok = 1;\n    }\n    else\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    /* Pre-computed table: do we have one in progress? complete? */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 rs_ctx-\u003ersm-\u003eT != NULL )\n    {\n        /* transfer ownership of T from rsm to local function */\n        T = rs_ctx-\u003ersm-\u003eT;\n        rs_ctx-\u003ersm-\u003eT = NULL;\n        rs_ctx-\u003ersm-\u003eT_size = 0;\n\n        /* This effectively jumps to the call to mul_comb_after_precomp() */\n        T_ok = rs_ctx-\u003ersm-\u003estate \u003e= ecp_rsm_comb_core;\n    }\n    else\n#endif\n    /* Allocate table if we didn't have any */\n    {\n        T = mbedtls_calloc( T_size, sizeof( mbedtls_ecp_point ) );\n        if( T == NULL )\n        {\n            ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;\n            goto cleanup;\n        }\n\n        for( i = 0; i \u003c T_size; i++ )\n            mbedtls_ecp_point_init( \u0026T[i] );\n\n        T_ok = 0;\n    }\n\n    /* Compute table (or finish computing it) if not done already */\n    if( !T_ok )\n    {\n        MBEDTLS_MPI_CHK( ecp_precompute_comb( grp, T, P, w, d, rs_ctx ) );\n\n        if( p_eq_g )\n        {\n            /* almost transfer ownership of T to the group, but keep a copy of\n             * the pointer to use for calling the next function more easily */\n            grp-\u003eT = T;\n            grp-\u003eT_size = T_size;\n        }\n    }\n\n    /* Actual comb multiplication using precomputed points */\n    MBEDTLS_MPI_CHK( ecp_mul_comb_after_precomp( grp, R, m,\n                                                 T, T_size, w, d,\n                                                 f_rng, p_rng, rs_ctx ) );\n\ncleanup:\n\n#if !defined(MBEDTLS_ECP_NO_INTERNAL_RNG)\n    ecp_drbg_free( \u0026drbg_ctx );\n#endif\n\n    /* does T belong to the group? */\n    if( T == grp-\u003eT )\n        T = NULL;\n\n    /* does T belong to the restart context? */\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 ret == MBEDTLS_ERR_ECP_IN_PROGRESS \u0026\u0026 T != NULL )\n    {\n        /* transfer ownership of T from local function to rsm */\n        rs_ctx-\u003ersm-\u003eT_size = T_size;\n        rs_ctx-\u003ersm-\u003eT = T;\n        T = NULL;\n    }\n#endif\n\n    /* did T belong to us? then let's destroy it! */\n    if( T != NULL )\n    {\n        for( i = 0; i \u003c T_size; i++ )\n            mbedtls_ecp_point_free( \u0026T[i] );\n        mbedtls_free( T );\n    }\n\n    /* don't free R while in progress in case R == P */\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ret != MBEDTLS_ERR_ECP_IN_PROGRESS )\n#endif\n    /* prevent caller from using invalid value */\n    if( ret != 0 )\n        mbedtls_ecp_point_free( R );\n\n    ECP_RS_LEAVE( rsm );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2262,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"441582":{"score":0.7065454,"function_name":"ecp_normalize_mxz","code":"static int ecp_normalize_mxz( const mbedtls_ecp_group *grp, mbedtls_ecp_point *P )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n#if defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_normalize_mxz( grp, P ) );\n#endif /* MBEDTLS_ECP_NORMALIZE_MXZ_ALT */\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( \u0026P-\u003eZ, \u0026P-\u003eZ, \u0026grp-\u003eP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026P-\u003eX, \u0026P-\u003eX, \u0026P-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026P-\u003eZ, 1 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2414,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.25.0"},"441747":{"score":0.76209015,"function_name":"ecp_randomize_mxz","code":"static int ecp_randomize_mxz( const mbedtls_ecp_group *grp, mbedtls_ecp_point *P,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    int ret;\n    mbedtls_mpi l;\n    size_t p_size = ( grp-\u003epbits + 7 ) / 8;\n    int count = 0;\n\n    mbedtls_mpi_init( \u0026l );\n\n    /* Generate l such that 1 \u003c l \u003c p */\n    do\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( \u0026l, p_size, f_rng, p_rng ) );\n\n        while( mbedtls_mpi_cmp_mpi( \u0026l, \u0026grp-\u003eP ) \u003e= 0 )\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026l, 1 ) );\n\n        if( count++ \u003e 10 )\n            return( MBEDTLS_ERR_ECP_RANDOM_FAILED );\n    }\n    while( mbedtls_mpi_cmp_int( \u0026l, 1 ) \u003c= 0 );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026P-\u003eX, \u0026P-\u003eX, \u0026l ) ); MOD_MUL( P-\u003eX );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026P-\u003eZ, \u0026P-\u003eZ, \u0026l ) ); MOD_MUL( P-\u003eZ );\n\ncleanup:\n    mbedtls_mpi_free( \u0026l );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":1444,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.1.9-rc1"},"442158":{"score":0.6296338,"function_name":"ecp_double_add_mxz","code":"static int ecp_double_add_mxz( const mbedtls_ecp_group *grp,\n                               mbedtls_ecp_point *R, mbedtls_ecp_point *S,\n                               const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q,\n                               const mbedtls_mpi *d )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_mpi A, AA, B, BB, E, C, D, DA, CB;\n\n#if defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_double_add_mxz( grp, R, S, P, Q, d ) );\n#endif /* MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT */\n\n    mbedtls_mpi_init( \u0026A ); mbedtls_mpi_init( \u0026AA ); mbedtls_mpi_init( \u0026B );\n    mbedtls_mpi_init( \u0026BB ); mbedtls_mpi_init( \u0026E ); mbedtls_mpi_init( \u0026C );\n    mbedtls_mpi_init( \u0026D ); mbedtls_mpi_init( \u0026DA ); mbedtls_mpi_init( \u0026CB );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026A,    \u0026P-\u003eX,   \u0026P-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026AA,   \u0026A,      \u0026A    ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026B,    \u0026P-\u003eX,   \u0026P-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026BB,   \u0026B,      \u0026B    ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026E,    \u0026AA,     \u0026BB   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026C,    \u0026Q-\u003eX,   \u0026Q-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026D,    \u0026Q-\u003eX,   \u0026Q-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026DA,   \u0026D,      \u0026A    ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026CB,   \u0026C,      \u0026B    ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026S-\u003eX, \u0026DA,     \u0026CB   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S-\u003eX, \u0026S-\u003eX,   \u0026S-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, \u0026S-\u003eZ, \u0026DA,     \u0026CB   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S-\u003eZ, \u0026S-\u003eZ,   \u0026S-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026S-\u003eZ, d,       \u0026S-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026R-\u003eX, \u0026AA,     \u0026BB   ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026R-\u003eZ, \u0026grp-\u003eA, \u0026E    ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026R-\u003eZ, \u0026BB,     \u0026R-\u003eZ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026R-\u003eZ, \u0026E,      \u0026R-\u003eZ ) );\n\ncleanup:\n    mbedtls_mpi_free( \u0026A ); mbedtls_mpi_free( \u0026AA ); mbedtls_mpi_free( \u0026B );\n    mbedtls_mpi_free( \u0026BB ); mbedtls_mpi_free( \u0026E ); mbedtls_mpi_free( \u0026C );\n    mbedtls_mpi_free( \u0026D ); mbedtls_mpi_free( \u0026DA ); mbedtls_mpi_free( \u0026CB );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2495,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.25.0"},"444367":{"score":0.7182548,"function_name":"ecp_mul_mxz","code":"static int ecp_mul_mxz( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                        const mbedtls_mpi *m, const mbedtls_ecp_point *P,\n                        int (*f_rng)(void *, unsigned char *, size_t),\n                        void *p_rng )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t i;\n    unsigned char b;\n    mbedtls_ecp_point RP;\n    mbedtls_mpi PX;\n\n    mbedtls_ecp_point_init( \u0026RP ); mbedtls_mpi_init( \u0026PX );\n\n    /* Save PX and read from P before writing to R, in case P == R */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026PX, \u0026P-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( \u0026RP, P ) );\n\n    /* Set R to zero in modified x/z coordinates */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026R-\u003eX, 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026R-\u003eZ, 0 ) );\n    mbedtls_mpi_free( \u0026R-\u003eY );\n\n    /* RP.X might be sligtly larger than P, so reduce it */\n    MOD_ADD( RP.X );\n\n    /* Randomize coordinates of the starting point */\n    if( f_rng != NULL )\n        MBEDTLS_MPI_CHK( ecp_randomize_mxz( grp, \u0026RP, f_rng, p_rng ) );\n\n    /* Loop invariant: R = result so far, RP = R + P */\n    i = mbedtls_mpi_bitlen( m ); /* one past the (zero-based) most significant bit */\n    while( i-- \u003e 0 )\n    {\n        b = mbedtls_mpi_get_bit( m, i );\n        /*\n         *  if (b) R = 2R + P else R = 2R,\n         * which is:\n         *  if (b) double_add( RP, R, RP, R )\n         *  else   double_add( R, RP, R, RP )\n         * but using safe conditional swaps to avoid leaks\n         */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eX, \u0026RP.X, b ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eZ, \u0026RP.Z, b ) );\n        MBEDTLS_MPI_CHK( ecp_double_add_mxz( grp, R, \u0026RP, R, \u0026RP, \u0026PX ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eX, \u0026RP.X, b ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eZ, \u0026RP.Z, b ) );\n    }\n\n    /*\n     * Knowledge of the projective coordinates may leak the last few bits of the\n     * scalar [1], and since our MPI implementation isn't constant-flow,\n     * inversion (used for coordinate normalization) may leak the full value\n     * of its input via side-channels [2].\n     *\n     * [1] https://eprint.iacr.org/2003/191\n     * [2] https://eprint.iacr.org/2020/055\n     *\n     * Avoid the leak by randomizing coordinates before we normalize them.\n     */\n    if( f_rng != NULL )\n        MBEDTLS_MPI_CHK( ecp_randomize_mxz( grp, R, f_rng, p_rng ) );\n\n    MBEDTLS_MPI_CHK( ecp_normalize_mxz( grp, R ) );\n\ncleanup:\n    mbedtls_ecp_point_free( \u0026RP ); mbedtls_mpi_free( \u0026PX );\n\n    return( ret );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/ecp.c","line_number":2357,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"445081":{"score":0.6329557,"function_name":"mbedtls_ecp_mul_restartable","code":"int mbedtls_ecp_mul_restartable( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n             const mbedtls_mpi *m, const mbedtls_ecp_point *P,\n             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,\n             mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n#if defined(MBEDTLS_ECP_INTERNAL_ALT)\n    char is_grp_capable = 0;\n#endif\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( R   != NULL );\n    ECP_VALIDATE_RET( m   != NULL );\n    ECP_VALIDATE_RET( P   != NULL );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    /* reset ops count for this call if top-level */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003edepth++ == 0 )\n        rs_ctx-\u003eops_done = 0;\n#else\n    (void) rs_ctx;\n#endif\n\n#if defined(MBEDTLS_ECP_INTERNAL_ALT)\n    if( ( is_grp_capable = mbedtls_internal_ecp_grp_capable( grp ) ) )\n        MBEDTLS_MPI_CHK( mbedtls_internal_ecp_init( grp ) );\n#endif /* MBEDTLS_ECP_INTERNAL_ALT */\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    /* skip argument check when restarting */\n    if( rs_ctx == NULL || rs_ctx-\u003ersm == NULL )\n#endif\n    {\n        /* check_privkey is free */\n        MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_CHK );\n\n        /* Common sanity checks */\n        MBEDTLS_MPI_CHK( mbedtls_ecp_check_privkey( grp, m ) );\n        MBEDTLS_MPI_CHK( mbedtls_ecp_check_pubkey( grp, P ) );\n    }\n\n    ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n        MBEDTLS_MPI_CHK( ecp_mul_mxz( grp, R, m, P, f_rng, p_rng ) );\n#endif\n#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n        MBEDTLS_MPI_CHK( ecp_mul_comb( grp, R, m, P, f_rng, p_rng, rs_ctx ) );\n#endif\n\ncleanup:\n\n#if defined(MBEDTLS_ECP_INTERNAL_ALT)\n    if( is_grp_capable )\n        mbedtls_internal_ecp_free( grp );\n#endif /* MBEDTLS_ECP_INTERNAL_ALT */\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL )\n        rs_ctx-\u003edepth--;\n#endif\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2657,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"445348":{"score":0.7661074,"function_name":"ecp_check_pubkey_sw","code":"static int ecp_check_pubkey_sw( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_mpi YY, RHS;\n\n    /* pt coordinates must be normalized for our checks */\n    if( mbedtls_mpi_cmp_int( \u0026pt-\u003eX, 0 ) \u003c 0 ||\n        mbedtls_mpi_cmp_int( \u0026pt-\u003eY, 0 ) \u003c 0 ||\n        mbedtls_mpi_cmp_mpi( \u0026pt-\u003eX, \u0026grp-\u003eP ) \u003e= 0 ||\n        mbedtls_mpi_cmp_mpi( \u0026pt-\u003eY, \u0026grp-\u003eP ) \u003e= 0 )\n        return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n    mbedtls_mpi_init( \u0026YY ); mbedtls_mpi_init( \u0026RHS );\n\n    /*\n     * YY = Y^2\n     * RHS = X (X^2 + A) + B = X^3 + A X + B\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026YY,  \u0026pt-\u003eY,   \u0026pt-\u003eY  ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026RHS, \u0026pt-\u003eX,   \u0026pt-\u003eX  ) );\n\n    /* Special case for A = -3 */\n    if( grp-\u003eA.p == NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026RHS, \u0026RHS, 3       ) );  MOD_SUB( RHS );\n    }\n    else\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026RHS, \u0026RHS, \u0026grp-\u003eA ) );\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, \u0026RHS, \u0026RHS,     \u0026pt-\u003eX  ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, \u0026RHS, \u0026RHS,     \u0026grp-\u003eB ) );\n\n    if( mbedtls_mpi_cmp_mpi( \u0026YY, \u0026RHS ) != 0 )\n        ret = MBEDTLS_ERR_ECP_INVALID_KEY;\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026YY ); mbedtls_mpi_free( \u0026RHS );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2741,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"446183":{"score":0.77539515,"function_name":"mbedtls_ecp_mul_shortcuts","code":"static int mbedtls_ecp_mul_shortcuts( mbedtls_ecp_group *grp,\n                                      mbedtls_ecp_point *R,\n                                      const mbedtls_mpi *m,\n                                      const mbedtls_ecp_point *P,\n                                      mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    if( mbedtls_mpi_cmp_int( m, 1 ) == 0 )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );\n    }\n    else if( mbedtls_mpi_cmp_int( m, -1 ) == 0 )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );\n        if( mbedtls_mpi_cmp_int( \u0026R-\u003eY, 0 ) != 0 )\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026R-\u003eY, \u0026grp-\u003eP, \u0026R-\u003eY ) );\n    }\n    else\n    {\n        MBEDTLS_MPI_CHK( mbedtls_ecp_mul_restartable( grp, R, m, P,\n                                                      NULL, NULL, rs_ctx ) );\n    }\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":2774,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.25.0"},"446409":{"score":0.7795026,"function_name":"mbedtls_ecp_muladd","code":"int mbedtls_ecp_muladd( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n             const mbedtls_mpi *m, const mbedtls_ecp_point *P,\n             const mbedtls_mpi *n, const mbedtls_ecp_point *Q )\n{\n    int ret;\n    mbedtls_ecp_point mP;\n\n    if( ecp_get_type( grp ) != ECP_TYPE_SHORT_WEIERSTRASS )\n        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );\n\n    mbedtls_ecp_point_init( \u0026mP );\n\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_shortcuts( grp, \u0026mP, m, P ) );\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_shortcuts( grp, R,   n, Q ) );\n\n    MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, \u0026mP, R ) );\n    MBEDTLS_MPI_CHK( ecp_normalize_jac( grp, R ) );\n\ncleanup:\n    mbedtls_ecp_point_free( \u0026mP );\n\n    return( ret );\n}","filepath":"source/Libraries/AES/mbedtls/ecp.c","line_number":1720,"entry_url":"https://github.com/andreas-mausch/whatsapp-viewer.git","slot_name":"v1.13"},"446818":{"score":0.81018037,"function_name":"mbedtls_ecp_check_pubkey","code":"int mbedtls_ecp_check_pubkey( const mbedtls_ecp_group *grp,\n                              const mbedtls_ecp_point *pt )\n{\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( pt  != NULL );\n\n    /* Must use affine coordinates */\n    if( mbedtls_mpi_cmp_int( \u0026pt-\u003eZ, 1 ) != 0 )\n        return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n        return( ecp_check_pubkey_mx( grp, pt ) );\n#endif\n#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n        return( ecp_check_pubkey_sw( grp, pt ) );\n#endif\n    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n}","filepath":"library/ecp.c","line_number":3054,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"446954":{"score":0.8344491,"function_name":"mbedtls_ecp_check_privkey","code":"int mbedtls_ecp_check_privkey( const mbedtls_ecp_group *grp,\n                               const mbedtls_mpi *d )\n{\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( d   != NULL );\n\n#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n    {\n        /* see RFC 7748 sec. 5 para. 5 */\n        if( mbedtls_mpi_get_bit( d, 0 ) != 0 ||\n            mbedtls_mpi_get_bit( d, 1 ) != 0 ||\n            mbedtls_mpi_bitlen( d ) - 1 != grp-\u003enbits ) /* mbedtls_mpi_bitlen is one-based! */\n            return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n        /* see [Curve25519] page 5 */\n        if( grp-\u003enbits == 254 \u0026\u0026 mbedtls_mpi_get_bit( d, 2 ) != 0 )\n            return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */\n#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n    {\n        /* see SEC1 3.2 */\n        if( mbedtls_mpi_cmp_int( d, 1 ) \u003c 0 ||\n            mbedtls_mpi_cmp_mpi( d, \u0026grp-\u003eN ) \u003e= 0 )\n            return( MBEDTLS_ERR_ECP_INVALID_KEY );\n        else\n            return( 0 );\n    }\n#endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */\n\n    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n}","filepath":"library/ecp.c","line_number":3078,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"447200":{"score":0.83700323,"function_name":"mbedtls_ecp_gen_privkey","code":"int mbedtls_ecp_gen_privkey( const mbedtls_ecp_group *grp,\n                     mbedtls_mpi *d,\n                     int (*f_rng)(void *, unsigned char *, size_t),\n                     void *p_rng )\n{\n    int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n    size_t n_size;\n\n    ECP_VALIDATE_RET( grp   != NULL );\n    ECP_VALIDATE_RET( d     != NULL );\n    ECP_VALIDATE_RET( f_rng != NULL );\n\n    n_size = ( grp-\u003enbits + 7 ) / 8;\n\n#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n    {\n        /* [M225] page 5 */\n        size_t b;\n\n        do {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );\n        } while( mbedtls_mpi_bitlen( d ) == 0);\n\n        /* Make sure the most significant bit is nbits */\n        b = mbedtls_mpi_bitlen( d ) - 1; /* mbedtls_mpi_bitlen is one-based */\n        if( b \u003e grp-\u003enbits )\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, b - grp-\u003enbits ) );\n        else\n            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, grp-\u003enbits, 1 ) );\n\n        /* Make sure the last two bits are unset for Curve448, three bits for\n           Curve25519 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 0, 0 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 1, 0 ) );\n        if( grp-\u003enbits == 254 )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 2, 0 ) );\n        }\n    }\n#endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */\n\n#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n    {\n        /* SEC1 3.2.1: Generate d such that 1 \u003c= n \u003c N */\n        int count = 0;\n        unsigned cmp = 0;\n\n        /*\n         * Match the procedure given in RFC 6979 (deterministic ECDSA):\n         * - use the same byte ordering;\n         * - keep the leftmost nbits bits of the generated octet string;\n         * - try until result is in the desired range.\n         * This also avoids any biais, which is especially important for ECDSA.\n         */\n        do\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, 8 * n_size - grp-\u003enbits ) );\n\n            /*\n             * Each try has at worst a probability 1/2 of failing (the msb has\n             * a probability 1/2 of being 0, and then the result will be \u003c N),\n             * so after 30 tries failure probability is a most 2**(-30).\n             *\n             * For most curves, 1 try is enough with overwhelming probability,\n             * since N starts with a lot of 1s in binary, but some curves\n             * such as secp224k1 are actually very close to the worst case.\n             */\n            if( ++count \u003e 30 )\n            {\n                ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;\n                goto cleanup;\n            }\n\n            ret = mbedtls_mpi_lt_mpi_ct( d, \u0026grp-\u003eN, \u0026cmp );\n            if( ret != 0 )\n            {\n                goto cleanup;\n            }\n        }\n        while( mbedtls_mpi_cmp_int( d, 1 ) \u003c 0 || cmp != 1 );\n    }\n#endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":3000,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.25.0"},"447731":{"score":0.67322516,"function_name":"mbedtls_ecp_gen_keypair_base","code":"int mbedtls_ecp_gen_keypair_base( mbedtls_ecp_group *grp,\n                     const mbedtls_ecp_point *G,\n                     mbedtls_mpi *d, mbedtls_ecp_point *Q,\n                     int (*f_rng)(void *, unsigned char *, size_t),\n                     void *p_rng )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    ECP_VALIDATE_RET( grp   != NULL );\n    ECP_VALIDATE_RET( d     != NULL );\n    ECP_VALIDATE_RET( G     != NULL );\n    ECP_VALIDATE_RET( Q     != NULL );\n    ECP_VALIDATE_RET( f_rng != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_ecp_gen_privkey( grp, d, f_rng, p_rng ) );\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( grp, Q, d, G, f_rng, p_rng ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp.c","line_number":3193,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"447871":{"score":0.75680864,"function_name":"mbedtls_ecp_gen_key","code":"int mbedtls_ecp_gen_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    ECP_VALIDATE_RET( key   != NULL );\n    ECP_VALIDATE_RET( f_rng != NULL );\n\n    if( ( ret = mbedtls_ecp_group_load( \u0026key-\u003egrp, grp_id ) ) != 0 )\n        return( ret );\n\n    return( mbedtls_ecp_gen_keypair( \u0026key-\u003egrp, \u0026key-\u003ed, \u0026key-\u003eQ, f_rng, p_rng ) );\n}","filepath":"library/ecp.c","line_number":3232,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"447965":{"score":0.9041483,"function_name":"mbedtls_ecp_check_pub_priv","code":"int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_ecp_point Q;\n    mbedtls_ecp_group grp;\n    ECP_VALIDATE_RET( pub != NULL );\n    ECP_VALIDATE_RET( prv != NULL );\n\n    if( pub-\u003egrp.id == MBEDTLS_ECP_DP_NONE ||\n        pub-\u003egrp.id != prv-\u003egrp.id ||\n        mbedtls_mpi_cmp_mpi( \u0026pub-\u003eQ.X, \u0026prv-\u003eQ.X ) ||\n        mbedtls_mpi_cmp_mpi( \u0026pub-\u003eQ.Y, \u0026prv-\u003eQ.Y ) ||\n        mbedtls_mpi_cmp_mpi( \u0026pub-\u003eQ.Z, \u0026prv-\u003eQ.Z ) )\n    {\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n    }\n\n    mbedtls_ecp_point_init( \u0026Q );\n    mbedtls_ecp_group_init( \u0026grp );\n\n    /* mbedtls_ecp_mul() needs a non-const group... */\n    mbedtls_ecp_group_copy( \u0026grp, \u0026prv-\u003egrp );\n\n    /* Also checks d is valid */\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( \u0026grp, \u0026Q, \u0026prv-\u003ed, \u0026prv-\u003egrp.G, NULL, NULL ) );\n\n    if( mbedtls_mpi_cmp_mpi( \u0026Q.X, \u0026prv-\u003eQ.X ) ||\n        mbedtls_mpi_cmp_mpi( \u0026Q.Y, \u0026prv-\u003eQ.Y ) ||\n        mbedtls_mpi_cmp_mpi( \u0026Q.Z, \u0026prv-\u003eQ.Z ) )\n    {\n        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\ncleanup:\n    mbedtls_ecp_point_free( \u0026Q );\n    mbedtls_ecp_group_free( \u0026grp );\n\n    return( ret );\n}","filepath":"library/ecp.c","line_number":3356,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.27.0"},"448590":{"score":0.90692157,"function_name":"ecp_group_load","code":"static int ecp_group_load( ecp_group *grp,\n                           const t_uint *p,  size_t plen,\n                           const t_uint *a,  size_t alen,\n                           const t_uint *b,  size_t blen,\n                           const t_uint *gx, size_t gxlen,\n                           const t_uint *gy, size_t gylen,\n                           const t_uint *n,  size_t nlen)\n{\n    ecp_mpi_load( \u0026grp-\u003eP, p, plen );\n    if( a != NULL )\n        ecp_mpi_load( \u0026grp-\u003eA, a, alen );\n    ecp_mpi_load( \u0026grp-\u003eB, b, blen );\n    ecp_mpi_load( \u0026grp-\u003eN, n, nlen );\n\n    ecp_mpi_load( \u0026grp-\u003eG.X, gx, gxlen );\n    ecp_mpi_load( \u0026grp-\u003eG.Y, gy, gylen );\n    ecp_mpi_set1( \u0026grp-\u003eG.Z );\n\n    grp-\u003epbits = mpi_msb( \u0026grp-\u003eP );\n    grp-\u003enbits = mpi_msb( \u0026grp-\u003eN );\n\n    grp-\u003eh = 1;\n\n    return( 0 );\n}","filepath":"library/ecp_curves.c","line_number":603,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.14"},"448827":{"score":0.68621224,"function_name":"ecp_use_curve25519","code":"static int ecp_use_curve25519( ecp_group *grp )\n{\n    int ret;\n\n    /* Actually ( A + 2 ) / 4 */\n    MPI_CHK( mpi_read_string( \u0026grp-\u003eA, 16, \"01DB42\" ) );\n\n    /* P = 2^255 - 19 */\n    MPI_CHK( mpi_lset( \u0026grp-\u003eP, 1 ) );\n    MPI_CHK( mpi_shift_l( \u0026grp-\u003eP, 255 ) );\n    MPI_CHK( mpi_sub_int( \u0026grp-\u003eP, \u0026grp-\u003eP, 19 ) );\n    grp-\u003epbits = mpi_msb( \u0026grp-\u003eP );\n\n    /* Y intentionaly not set, since we use x/z coordinates.\n     * This is used as a marker to identify Montgomery curves! */\n    MPI_CHK( mpi_lset( \u0026grp-\u003eG.X, 9 ) );\n    MPI_CHK( mpi_lset( \u0026grp-\u003eG.Z, 1 ) );\n    mpi_free( \u0026grp-\u003eG.Y );\n\n    /* Actually, the required msb for private keys */\n    grp-\u003enbits = 254;\n\ncleanup:\n    if( ret != 0 )\n        ecp_group_free( grp );\n\n    return( ret );\n}","filepath":"library/ecp_curves.c","line_number":686,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.14"},"449232":{"score":0.6491604,"function_name":"ecp_use_known_dp","code":"int ecp_use_known_dp( ecp_group *grp, ecp_group_id id )\n{\n    ecp_group_free( grp );\n\n    grp-\u003eid = id;\n\n    switch( id )\n    {\n#if defined(POLARSSL_ECP_DP_SECP192R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP192R1:\n            NIST_MODP( p192 );\n            return( LOAD_GROUP( secp192r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP192R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP224R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP224R1:\n            NIST_MODP( p224 );\n            return( LOAD_GROUP( secp224r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP224R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP256R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP256R1:\n            NIST_MODP( p256 );\n            return( LOAD_GROUP( secp256r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP256R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP384R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP384R1:\n            NIST_MODP( p384 );\n            return( LOAD_GROUP( secp384r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP384R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP521R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP521R1:\n            NIST_MODP( p521 );\n            return( LOAD_GROUP( secp521r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP521R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP192K1_ENABLED)\n        case POLARSSL_ECP_DP_SECP192K1:\n            grp-\u003emodp = ecp_mod_p192k1;\n            return( LOAD_GROUP_A( secp192k1 ) );\n#endif /* POLARSSL_ECP_DP_SECP192K1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP224K1_ENABLED)\n        case POLARSSL_ECP_DP_SECP224K1:\n            grp-\u003emodp = ecp_mod_p224k1;\n            return( LOAD_GROUP_A( secp224k1 ) );\n#endif /* POLARSSL_ECP_DP_SECP224K1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP256K1_ENABLED)\n        case POLARSSL_ECP_DP_SECP256K1:\n            grp-\u003emodp = ecp_mod_p256k1;\n            return( LOAD_GROUP_A( secp256k1 ) );\n#endif /* POLARSSL_ECP_DP_SECP256K1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_BP256R1_ENABLED)\n        case POLARSSL_ECP_DP_BP256R1:\n            return( LOAD_GROUP_A( brainpoolP256r1 ) );\n#endif /* POLARSSL_ECP_DP_BP256R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_BP384R1_ENABLED)\n        case POLARSSL_ECP_DP_BP384R1:\n            return( LOAD_GROUP_A( brainpoolP384r1 ) );\n#endif /* POLARSSL_ECP_DP_BP384R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_BP512R1_ENABLED)\n        case POLARSSL_ECP_DP_BP512R1:\n            return( LOAD_GROUP_A( brainpoolP512r1 ) );\n#endif /* POLARSSL_ECP_DP_BP512R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_M255_ENABLED)\n        case POLARSSL_ECP_DP_M255:\n            grp-\u003emodp = ecp_mod_p255;\n            return( ecp_use_curve25519( grp ) );\n#endif /* POLARSSL_ECP_DP_M255_ENABLED */\n\n        default:\n            ecp_group_free( grp );\n            return( POLARSSL_ERR_ECP_FEATURE_UNAVAILABLE );\n    }\n}","filepath":"library/ecp_curves.c","line_number":719,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.14"},"449404":{"score":0.78931594,"function_name":"ecp_mod_p255","code":"static int ecp_mod_p255( mpi *N )\n{\n    int ret;\n    size_t i;\n    mpi M;\n    t_uint Mp[P255_WIDTH + 2];\n\n    if( N-\u003en \u003c P255_WIDTH )\n        return( 0 );\n\n    /* M = A1 */\n    M.s = 1;\n    M.n = N-\u003en - ( P255_WIDTH - 1 );\n    if( M.n \u003e P255_WIDTH + 1 )\n        M.n = P255_WIDTH + 1;\n    M.p = Mp;\n    memset( Mp, 0, sizeof Mp );\n    memcpy( Mp, N-\u003ep + P255_WIDTH - 1, M.n * sizeof( t_uint ) );\n    MPI_CHK( mpi_shift_r( \u0026M, 255 % ( 8 * sizeof( t_uint ) ) ) );\n    M.n++; /* Make room for multiplication by 19 */\n\n    /* N = A0 */\n    MPI_CHK( mpi_set_bit( N, 255, 0 ) );\n    for( i = P255_WIDTH; i \u003c N-\u003en; i++ )\n        N-\u003ep[i] = 0;\n\n    /* N = A0 + 19 * A1 */\n    MPI_CHK( mpi_mul_int( \u0026M, \u0026M, 19 ) );\n    MPI_CHK( mpi_add_abs( N, N, \u0026M ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp_curves.c","line_number":1214,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.14"},"449784":{"score":0.7407669,"function_name":"mbedtls_md_info_from_string","code":"const mbedtls_md_info_t *mbedtls_md_info_from_string( const char *md_name )\n{\n    if( NULL == md_name )\n        return( NULL );\n\n    /* Get the appropriate digest information */\n#if defined(MBEDTLS_MD2_C)\n    if( !strcmp( \"MD2\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_MD2 );\n#endif\n#if defined(MBEDTLS_MD4_C)\n    if( !strcmp( \"MD4\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_MD4 );\n#endif\n#if defined(MBEDTLS_MD5_C)\n    if( !strcmp( \"MD5\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_MD5 );\n#endif\n#if defined(MBEDTLS_RIPEMD160_C)\n    if( !strcmp( \"RIPEMD160\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_RIPEMD160 );\n#endif\n#if defined(MBEDTLS_SHA1_C)\n    if( !strcmp( \"SHA1\", md_name ) || !strcmp( \"SHA\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA1 );\n#endif\n#if defined(MBEDTLS_SHA256_C)\n    if( !strcmp( \"SHA224\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA224 );\n    if( !strcmp( \"SHA256\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n    if( !strcmp( \"SHA384\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA384 );\n    if( !strcmp( \"SHA512\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA512 );\n#endif\n    return( NULL );\n}","filepath":"library/md.c","line_number":122,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"450056":{"score":0.64285314,"function_name":"mbedtls_md_info_from_type","code":"const mbedtls_md_info_t *mbedtls_md_info_from_type( mbedtls_md_type_t md_type )\n{\n    switch( md_type )\n    {\n#if defined(MBEDTLS_MD2_C)\n        case MBEDTLS_MD_MD2:\n            return( \u0026mbedtls_md2_info );\n#endif\n#if defined(MBEDTLS_MD4_C)\n        case MBEDTLS_MD_MD4:\n            return( \u0026mbedtls_md4_info );\n#endif\n#if defined(MBEDTLS_MD5_C)\n        case MBEDTLS_MD_MD5:\n            return( \u0026mbedtls_md5_info );\n#endif\n#if defined(MBEDTLS_RIPEMD160_C)\n        case MBEDTLS_MD_RIPEMD160:\n            return( \u0026mbedtls_ripemd160_info );\n#endif\n#if defined(MBEDTLS_SHA1_C)\n        case MBEDTLS_MD_SHA1:\n            return( \u0026mbedtls_sha1_info );\n#endif\n#if defined(MBEDTLS_SHA256_C)\n        case MBEDTLS_MD_SHA224:\n            return( \u0026mbedtls_sha224_info );\n        case MBEDTLS_MD_SHA256:\n            return( \u0026mbedtls_sha256_info );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n#if !defined(MBEDTLS_SHA512_NO_SHA384)\n        case MBEDTLS_MD_SHA384:\n            return( \u0026mbedtls_sha384_info );\n#endif\n        case MBEDTLS_MD_SHA512:\n            return( \u0026mbedtls_sha512_info );\n#endif\n        default:\n            return( NULL );\n    }\n}","filepath":"library/md.c","line_number":222,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.26.0"},"450184":{"score":0.80055076,"function_name":"mbedtls_md_free","code":"void mbedtls_md_free( mbedtls_md_context_t *ctx )\n{\n    if( ctx == NULL || ctx-\u003emd_info == NULL )\n        return;\n\n    if( ctx-\u003emd_ctx != NULL )\n        ctx-\u003emd_info-\u003ectx_free_func( ctx-\u003emd_ctx );\n\n    if( ctx-\u003ehmac_ctx != NULL )\n    {\n        mbedtls_platform_zeroize( ctx-\u003ehmac_ctx,\n                                  2 * ctx-\u003emd_info-\u003eblock_size );\n        mbedtls_free( ctx-\u003ehmac_ctx );\n    }\n\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );\n}","filepath":"library/md.c","line_number":209,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"450333":{"score":0.8967918,"function_name":"mbedtls_md_clone","code":"int mbedtls_md_clone( mbedtls_md_context_t *dst,\n                      const mbedtls_md_context_t *src )\n{\n    if( dst == NULL || dst-\u003emd_info == NULL ||\n        src == NULL || src-\u003emd_info == NULL ||\n        dst-\u003emd_info != src-\u003emd_info )\n    {\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n    }\n\n    dst-\u003emd_info-\u003eclone_func( dst-\u003emd_ctx, src-\u003emd_ctx );\n\n    return( 0 );\n}","filepath":"library/md.c","line_number":227,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"450474":{"score":0.8918258,"function_name":"mbedtls_md_setup","code":"int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac )\n{\n    if( md_info == NULL || ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003emd_ctx = md_info-\u003ectx_alloc_func() ) == NULL )\n        return( MBEDTLS_ERR_MD_ALLOC_FAILED );\n\n    if( hmac != 0 )\n    {\n        ctx-\u003ehmac_ctx = mbedtls_calloc( 2, md_info-\u003eblock_size );\n        if( ctx-\u003ehmac_ctx == NULL )\n        {\n            md_info-\u003ectx_free_func( ctx-\u003emd_ctx );\n            return( MBEDTLS_ERR_MD_ALLOC_FAILED );\n        }\n    }\n\n    ctx-\u003emd_info = md_info;\n\n    return( 0 );\n}","filepath":"library/md.c","line_number":249,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"450832":{"score":0.80812776,"function_name":"mbedtls_md","code":"int mbedtls_md( const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen,\n            unsigned char *output )\n{\n    if( md_info == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    md_info-\u003edigest_func( input, ilen, output );\n\n    return( 0 );\n}","filepath":"source/Libraries/AES/mbedtls/md.c","line_number":278,"entry_url":"https://github.com/andreas-mausch/whatsapp-viewer.git","slot_name":"v1.13"},"450886":{"score":0.8409526,"function_name":"mbedtls_md_hmac_starts","code":"int mbedtls_md_hmac_starts( mbedtls_md_context_t *ctx, const unsigned char *key, size_t keylen )\n{\n    int ret;\n    unsigned char sum[MBEDTLS_MD_MAX_SIZE];\n    unsigned char *ipad, *opad;\n    size_t i;\n\n    if( ctx == NULL || ctx-\u003emd_info == NULL || ctx-\u003ehmac_ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    if( keylen \u003e (size_t) ctx-\u003emd_info-\u003eblock_size )\n    {\n        if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n            goto cleanup;\n        if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, key, keylen ) ) != 0 )\n            goto cleanup;\n        if( ( ret = ctx-\u003emd_info-\u003efinish_func( ctx-\u003emd_ctx, sum ) ) != 0 )\n            goto cleanup;\n\n        keylen = ctx-\u003emd_info-\u003esize;\n        key = sum;\n    }\n\n    ipad = (unsigned char *) ctx-\u003ehmac_ctx;\n    opad = (unsigned char *) ctx-\u003ehmac_ctx + ctx-\u003emd_info-\u003eblock_size;\n\n    memset( ipad, 0x36, ctx-\u003emd_info-\u003eblock_size );\n    memset( opad, 0x5C, ctx-\u003emd_info-\u003eblock_size );\n\n    for( i = 0; i \u003c keylen; i++ )\n    {\n        ipad[i] = (unsigned char)( ipad[i] ^ key[i] );\n        opad[i] = (unsigned char)( opad[i] ^ key[i] );\n    }\n\n    if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n        goto cleanup;\n    if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, ipad,\n                                           ctx-\u003emd_info-\u003eblock_size ) ) != 0 )\n        goto cleanup;\n\ncleanup:\n    mbedtls_platform_zeroize( sum, sizeof( sum ) );\n\n    return( ret );\n}","filepath":"library/md.c","line_number":346,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"451504":{"score":0.81043655,"function_name":"mbedtls_md_hmac_finish","code":"int mbedtls_md_hmac_finish( mbedtls_md_context_t *ctx, unsigned char *output )\n{\n    int ret;\n    unsigned char tmp[MBEDTLS_MD_MAX_SIZE];\n    unsigned char *opad;\n\n    if( ctx == NULL || ctx-\u003emd_info == NULL || ctx-\u003ehmac_ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    opad = (unsigned char *) ctx-\u003ehmac_ctx + ctx-\u003emd_info-\u003eblock_size;\n\n    if( ( ret = ctx-\u003emd_info-\u003efinish_func( ctx-\u003emd_ctx, tmp ) ) != 0 )\n        return( ret );\n    if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n        return( ret );\n    if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, opad,\n                                           ctx-\u003emd_info-\u003eblock_size ) ) != 0 )\n        return( ret );\n    if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, tmp,\n                                           ctx-\u003emd_info-\u003esize ) ) != 0 )\n        return( ret );\n    return( ctx-\u003emd_info-\u003efinish_func( ctx-\u003emd_ctx, output ) );\n}","filepath":"library/md.c","line_number":401,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"451829":{"score":0.8855377,"function_name":"mbedtls_md_hmac_reset","code":"int mbedtls_md_hmac_reset( mbedtls_md_context_t *ctx )\n{\n    int ret;\n    unsigned char *ipad;\n\n    if( ctx == NULL || ctx-\u003emd_info == NULL || ctx-\u003ehmac_ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    ipad = (unsigned char *) ctx-\u003ehmac_ctx;\n\n    if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n        return( ret );\n    return( ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, ipad,\n                                       ctx-\u003emd_info-\u003eblock_size ) );\n}","filepath":"library/md.c","line_number":425,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"451962":{"score":0.75648826,"function_name":"mbedtls_md_hmac","code":"int mbedtls_md_hmac( const mbedtls_md_info_t *md_info,\n                     const unsigned char *key, size_t keylen,\n                     const unsigned char *input, size_t ilen,\n                     unsigned char *output )\n{\n    mbedtls_md_context_t ctx;\n    int ret;\n\n    if( md_info == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    mbedtls_md_init( \u0026ctx );\n\n    if( ( ret = mbedtls_md_setup( \u0026ctx, md_info, 1 ) ) != 0 )\n        goto cleanup;\n\n    if( ( ret = mbedtls_md_hmac_starts( \u0026ctx, key, keylen ) ) != 0 )\n        goto cleanup;\n    if( ( ret = mbedtls_md_hmac_update( \u0026ctx, input, ilen ) ) != 0 )\n        goto cleanup;\n    if( ( ret = mbedtls_md_hmac_finish( \u0026ctx, output ) ) != 0 )\n        goto cleanup;\n\ncleanup:\n    mbedtls_md_free( \u0026ctx );\n\n    return( ret );\n}","filepath":"library/md.c","line_number":441,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"453934":{"score":0.91891825,"function_name":"oid_get_x509_ext_type","code":"int oid_get_x509_ext_type( const asn1_buf *oid, int *ext_type )\n{\n    const oid_x509_ext_t *data = oid_x509_ext_from_asn1( oid );\n\n    if( data == NULL )\n        return( POLARSSL_ERR_OID_NOT_FOUND );\n\n    *ext_type = data-\u003eext_type;\n\n    return( 0 );\n}","filepath":"library/oid.c","line_number":409,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3-alpha1"},"454135":{"score":0.6990708,"function_name":"oid_get_oid_by_md","code":"int oid_get_oid_by_md( md_type_t md_alg,\n                       const char **oid_str )\n{\n    const oid_md_alg_t *cur = oid_md_alg;\n\n    while( cur-\u003edescriptor.asn1 != NULL )\n    {\n        if( cur-\u003emd_alg == md_alg )\n        {\n            *oid_str = cur-\u003edescriptor.asn1;\n            return( 0 );\n        }\n\n        cur++;\n    }\n\n    return( POLARSSL_ERR_OID_NOT_FOUND );\n}","filepath":"library/oid.c","line_number":538,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3-alpha1"},"454400":{"score":0.9154174,"function_name":"oid_get_sig_alg","code":"int oid_get_sig_alg( const asn1_buf *oid,\n                     md_type_t *md_alg, pk_type_t *pk_alg )\n{\n    const oid_sig_alg_t *data = oid_sig_alg_from_asn1( oid );\n\n    if( data == NULL )\n        return( POLARSSL_ERR_OID_NOT_FOUND );\n\n    *md_alg = data-\u003emd_alg;\n    *pk_alg = data-\u003epk_alg;\n\n    return( 0 );\n}","filepath":"library/oid.c","line_number":491,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3-alpha1"},"454475":{"score":0.6945014,"function_name":"oid_get_oid_by_sig_alg","code":"int oid_get_oid_by_sig_alg( pk_type_t pk_alg, md_type_t md_alg,\n                            const char **oid_str )\n{\n    const oid_sig_alg_t *cur = oid_sig_alg;\n\n    while( cur-\u003edescriptor.asn1 != NULL )\n    {\n        if( cur-\u003epk_alg == pk_alg \u0026\u0026\n            cur-\u003emd_alg == md_alg )\n        {\n            *oid_str = cur-\u003edescriptor.asn1;\n            return( 0 );\n        }\n\n        cur++;\n    }\n\n    return( POLARSSL_ERR_OID_NOT_FOUND );\n}","filepath":"library/oid.c","line_number":505,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3-alpha1"},"455835":{"score":0.8643737,"function_name":"oid_get_numeric_string","code":"int oid_get_numeric_string( char *buf, size_t size,\n                            const asn1_buf *oid )\n{\n    int ret;\n    size_t i, n;\n    unsigned int value;\n    char *p;\n\n    p = buf;\n    n = size;\n\n    /* First byte contains first two dots */\n    if( oid-\u003elen \u003e 0 )\n    {\n        ret = snprintf( p, n, \"%d.%d\", oid-\u003ep[0] / 40, oid-\u003ep[0] % 40 );\n        SAFE_SNPRINTF();\n    }\n\n    value = 0;\n    for( i = 1; i \u003c oid-\u003elen; i++ )\n    {\n        /* Prevent overflow in value. */\n        if ( ( ( value \u003c\u003c 7 ) \u003e\u003e 7 ) != value )\n            return( POLARSSL_ERR_OID_BUF_TOO_SMALL );\n\n        value \u003c\u003c= 7;\n        value += oid-\u003ep[i] \u0026 0x7F;\n\n        if( !( oid-\u003ep[i] \u0026 0x80 ) )\n        {\n            /* Last byte */\n            ret = snprintf( p, n, \".%d\", value );\n            SAFE_SNPRINTF();\n            value = 0;\n        }\n    }\n\n    return( (int) ( size - n ) );\n}","filepath":"library/oid.c","line_number":644,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"456273":{"score":0.83070076,"function_name":"pem_read_buffer","code":"int pem_read_buffer( pem_context *ctx, const char *header, const char *footer,\n                     const unsigned char *data, const unsigned char *pwd,\n                     size_t pwdlen, size_t *use_len )\n{\n    int ret, enc;\n    size_t len;\n    unsigned char *buf;\n    const unsigned char *s1, *s2, *end;\n#if defined(POLARSSL_MD5_C) \u0026\u0026 defined(POLARSSL_CIPHER_MODE_CBC) \u0026\u0026         \\\n    ( defined(POLARSSL_DES_C) || defined(POLARSSL_AES_C) )\n    unsigned char pem_iv[16];\n    cipher_type_t enc_alg = POLARSSL_CIPHER_NONE;\n#else\n    ((void) pwd);\n    ((void) pwdlen);\n#endif /* POLARSSL_MD5_C \u0026\u0026 POLARSSL_CIPHER_MODE_CBC \u0026\u0026\n          ( POLARSSL_AES_C || POLARSSL_DES_C ) */\n\n    if( ctx == NULL )\n        return( POLARSSL_ERR_PEM_BAD_INPUT_DATA );\n\n    s1 = (unsigned char *) strstr( (const char *) data, header );\n\n    if( s1 == NULL )\n        return( POLARSSL_ERR_PEM_NO_HEADER_FOOTER_PRESENT );\n\n    s2 = (unsigned char *) strstr( (const char *) data, footer );\n\n    if( s2 == NULL || s2 \u003c= s1 )\n        return( POLARSSL_ERR_PEM_NO_HEADER_FOOTER_PRESENT );\n\n    s1 += strlen( header );\n    if( *s1 == '\\r' ) s1++;\n    if( *s1 == '\\n' ) s1++;\n    else return( POLARSSL_ERR_PEM_NO_HEADER_FOOTER_PRESENT );\n\n    end = s2;\n    end += strlen( footer );\n    if( *end == '\\r' ) end++;\n    if( *end == '\\n' ) end++;\n    *use_len = end - data;\n\n    enc = 0;\n\n    if( memcmp( s1, \"Proc-Type: 4,ENCRYPTED\", 22 ) == 0 )\n    {\n#if defined(POLARSSL_MD5_C) \u0026\u0026 defined(POLARSSL_CIPHER_MODE_CBC) \u0026\u0026         \\\n    ( defined(POLARSSL_DES_C) || defined(POLARSSL_AES_C) )\n        enc++;\n\n        s1 += 22;\n        if( *s1 == '\\r' ) s1++;\n        if( *s1 == '\\n' ) s1++;\n        else return( POLARSSL_ERR_PEM_INVALID_DATA );\n\n\n#if defined(POLARSSL_DES_C)\n        if( memcmp( s1, \"DEK-Info: DES-EDE3-CBC,\", 23 ) == 0 )\n        {\n            enc_alg = POLARSSL_CIPHER_DES_EDE3_CBC;\n\n            s1 += 23;\n            if( pem_get_iv( s1, pem_iv, 8 ) != 0 )\n                return( POLARSSL_ERR_PEM_INVALID_ENC_IV );\n\n            s1 += 16;\n        }\n        else if( memcmp( s1, \"DEK-Info: DES-CBC,\", 18 ) == 0 )\n        {\n            enc_alg = POLARSSL_CIPHER_DES_CBC;\n\n            s1 += 18;\n            if( pem_get_iv( s1, pem_iv, 8) != 0 )\n                return( POLARSSL_ERR_PEM_INVALID_ENC_IV );\n\n            s1 += 16;\n        }\n#endif /* POLARSSL_DES_C */\n\n#if defined(POLARSSL_AES_C)\n        if( memcmp( s1, \"DEK-Info: AES-\", 14 ) == 0 )\n        {\n            if( memcmp( s1, \"DEK-Info: AES-128-CBC,\", 22 ) == 0 )\n                enc_alg = POLARSSL_CIPHER_AES_128_CBC;\n            else if( memcmp( s1, \"DEK-Info: AES-192-CBC,\", 22 ) == 0 )\n                enc_alg = POLARSSL_CIPHER_AES_192_CBC;\n            else if( memcmp( s1, \"DEK-Info: AES-256-CBC,\", 22 ) == 0 )\n                enc_alg = POLARSSL_CIPHER_AES_256_CBC;\n            else\n                return( POLARSSL_ERR_PEM_UNKNOWN_ENC_ALG );\n\n            s1 += 22;\n            if( pem_get_iv( s1, pem_iv, 16 ) != 0 )\n                return( POLARSSL_ERR_PEM_INVALID_ENC_IV );\n\n            s1 += 32;\n        }\n#endif /* POLARSSL_AES_C */\n\n        if( enc_alg == POLARSSL_CIPHER_NONE )\n            return( POLARSSL_ERR_PEM_UNKNOWN_ENC_ALG );\n\n        if( *s1 == '\\r' ) s1++;\n        if( *s1 == '\\n' ) s1++;\n        else return( POLARSSL_ERR_PEM_INVALID_DATA );\n#else\n        return( POLARSSL_ERR_PEM_FEATURE_UNAVAILABLE );\n#endif /* POLARSSL_MD5_C \u0026\u0026 POLARSSL_CIPHER_MODE_CBC \u0026\u0026\n          ( POLARSSL_AES_C || POLARSSL_DES_C ) */\n    }\n\n    len = 0;\n    ret = base64_decode( NULL, \u0026len, s1, s2 - s1 );\n\n    if( ret == POLARSSL_ERR_BASE64_INVALID_CHARACTER )\n        return( POLARSSL_ERR_PEM_INVALID_DATA + ret );\n\n    if( ( buf = polarssl_malloc( len ) ) == NULL )\n        return( POLARSSL_ERR_PEM_MALLOC_FAILED );\n\n    if( ( ret = base64_decode( buf, \u0026len, s1, s2 - s1 ) ) != 0 )\n    {\n        polarssl_free( buf );\n        return( POLARSSL_ERR_PEM_INVALID_DATA + ret );\n    }\n\n    if( enc != 0 )\n    {\n#if defined(POLARSSL_MD5_C) \u0026\u0026 defined(POLARSSL_CIPHER_MODE_CBC) \u0026\u0026         \\\n    ( defined(POLARSSL_DES_C) || defined(POLARSSL_AES_C) )\n        if( pwd == NULL )\n        {\n            polarssl_free( buf );\n            return( POLARSSL_ERR_PEM_PASSWORD_REQUIRED );\n        }\n\n#if defined(POLARSSL_DES_C)\n        if( enc_alg == POLARSSL_CIPHER_DES_EDE3_CBC )\n            pem_des3_decrypt( pem_iv, buf, len, pwd, pwdlen );\n        else if( enc_alg == POLARSSL_CIPHER_DES_CBC )\n            pem_des_decrypt( pem_iv, buf, len, pwd, pwdlen );\n#endif /* POLARSSL_DES_C */\n\n#if defined(POLARSSL_AES_C)\n        if( enc_alg == POLARSSL_CIPHER_AES_128_CBC )\n            pem_aes_decrypt( pem_iv, 16, buf, len, pwd, pwdlen );\n        else if( enc_alg == POLARSSL_CIPHER_AES_192_CBC )\n            pem_aes_decrypt( pem_iv, 24, buf, len, pwd, pwdlen );\n        else if( enc_alg == POLARSSL_CIPHER_AES_256_CBC )\n            pem_aes_decrypt( pem_iv, 32, buf, len, pwd, pwdlen );\n#endif /* POLARSSL_AES_C */\n\n        /*\n         * The result will be ASN.1 starting with a SEQUENCE tag, with 1 to 3\n         * length bytes (allow 4 to be sure) in all known use cases.\n         *\n         * Use that as heurisitic to try detecting password mismatchs.\n         */\n        if( len \u003c= 2 || buf[0] != 0x30 || buf[1] \u003e 0x83 )\n        {\n            polarssl_free( buf );\n            return( POLARSSL_ERR_PEM_PASSWORD_MISMATCH );\n        }\n#else\n        polarssl_free( buf );\n        return( POLARSSL_ERR_PEM_FEATURE_UNAVAILABLE );\n#endif /* POLARSSL_MD5_C \u0026\u0026 POLARSSL_CIPHER_MODE_CBC \u0026\u0026\n          ( POLARSSL_AES_C || POLARSSL_DES_C ) */\n    }\n\n    ctx-\u003ebuf = buf;\n    ctx-\u003ebuflen = len;\n\n    return( 0 );\n}","filepath":"library/pem.c","line_number":207,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.11"},"456933":{"score":0.6959781,"function_name":"mbedtls_pem_free","code":"void mbedtls_pem_free( mbedtls_pem_context *ctx )\n{\n    if( ctx-\u003ebuf != NULL )\n        mbedtls_zeroize( ctx-\u003ebuf, ctx-\u003ebuflen );\n    mbedtls_free( ctx-\u003ebuf );\n    mbedtls_free( ctx-\u003einfo );\n\n    mbedtls_zeroize( ctx, sizeof( mbedtls_pem_context ) );\n}","filepath":"library/pem.c","line_number":428,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.0-rc1"},"457041":{"score":0.8328901,"function_name":"mbedtls_pem_write_buffer","code":"int mbedtls_pem_write_buffer( const char *header, const char *footer,\n                      const unsigned char *der_data, size_t der_len,\n                      unsigned char *buf, size_t buf_len, size_t *olen )\n{\n    int ret;\n    unsigned char *encode_buf, *c, *p = buf;\n    size_t len = 0, use_len, add_len = 0;\n\n    mbedtls_base64_encode( NULL, 0, \u0026use_len, der_data, der_len );\n    add_len = strlen( header ) + strlen( footer ) + ( use_len / 64 ) + 1;\n\n    if( use_len + add_len \u003e buf_len )\n    {\n        *olen = use_len + add_len;\n        return( MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL );\n    }\n\n    if( ( encode_buf = mbedtls_calloc( 1, use_len ) ) == NULL )\n        return( MBEDTLS_ERR_PEM_ALLOC_FAILED );\n\n    if( ( ret = mbedtls_base64_encode( encode_buf, use_len, \u0026use_len, der_data,\n                               der_len ) ) != 0 )\n    {\n        mbedtls_free( encode_buf );\n        return( ret );\n    }\n\n    memcpy( p, header, strlen( header ) );\n    p += strlen( header );\n    c = encode_buf;\n\n    while( use_len )\n    {\n        len = ( use_len \u003e 64 ) ? 64 : use_len;\n        memcpy( p, c, len );\n        use_len -= len;\n        p += len;\n        c += len;\n        *p++ = '\\n';\n    }\n\n    memcpy( p, footer, strlen( footer ) );\n    p += strlen( footer );\n\n    *p++ = '\\0';\n    *olen = p - buf;\n\n    mbedtls_free( encode_buf );\n    return( 0 );\n}","filepath":"library/pem.c","line_number":440,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.0-rc1"},"457628":{"score":0.85257494,"function_name":"mbedtls_pk_free","code":"void mbedtls_pk_free( mbedtls_pk_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n    if ( ctx-\u003epk_info != NULL )\n        ctx-\u003epk_info-\u003ectx_free_func( ctx-\u003epk_ctx );\n\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pk_context ) );\n}","filepath":"library/pk.c","line_number":66,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"457708":{"score":0.7222773,"function_name":"mbedtls_pk_info_from_type","code":"const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )\n{\n    switch( pk_type ) {\n#if defined(MBEDTLS_RSA_C)\n        case MBEDTLS_PK_RSA:\n            return( \u0026mbedtls_rsa_info );\n#endif\n#if defined(MBEDTLS_ECP_C)\n        case MBEDTLS_PK_ECKEY:\n            return( \u0026mbedtls_eckey_info );\n        case MBEDTLS_PK_ECKEY_DH:\n            return( \u0026mbedtls_eckeydh_info );\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n        case MBEDTLS_PK_ECDSA:\n            return( \u0026mbedtls_ecdsa_info );\n#endif\n        /* MBEDTLS_PK_RSA_ALT omitted on purpose */\n        default:\n            return( NULL );\n    }\n}","filepath":"library/pk.c","line_number":109,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"457770":{"score":0.82763654,"function_name":"mbedtls_pk_setup","code":"int mbedtls_pk_setup( mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    if( info == NULL || ctx-\u003epk_info != NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003epk_ctx = info-\u003ectx_alloc_func() ) == NULL )\n        return( MBEDTLS_ERR_PK_ALLOC_FAILED );\n\n    ctx-\u003epk_info = info;\n\n    return( 0 );\n}","filepath":"library/pk.c","line_number":135,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"457856":{"score":0.766863,"function_name":"mbedtls_pk_setup_rsa_alt","code":"int mbedtls_pk_setup_rsa_alt( mbedtls_pk_context *ctx, void * key,\n                         mbedtls_pk_rsa_alt_decrypt_func decrypt_func,\n                         mbedtls_pk_rsa_alt_sign_func sign_func,\n                         mbedtls_pk_rsa_alt_key_len_func key_len_func )\n{\n    mbedtls_rsa_alt_context *rsa_alt;\n    const mbedtls_pk_info_t *info = \u0026mbedtls_rsa_alt_info;\n\n    PK_VALIDATE_RET( ctx != NULL );\n    if( ctx-\u003epk_info != NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003epk_ctx = info-\u003ectx_alloc_func() ) == NULL )\n        return( MBEDTLS_ERR_PK_ALLOC_FAILED );\n\n    ctx-\u003epk_info = info;\n\n    rsa_alt = (mbedtls_rsa_alt_context *) ctx-\u003epk_ctx;\n\n    rsa_alt-\u003ekey = key;\n    rsa_alt-\u003edecrypt_func = decrypt_func;\n    rsa_alt-\u003esign_func = sign_func;\n    rsa_alt-\u003ekey_len_func = key_len_func;\n\n    return( 0 );\n}","filepath":"library/pk.c","line_number":189,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"458048":{"score":0.8271554,"function_name":"pk_hashlen_helper","code":"static inline int pk_hashlen_helper( mbedtls_md_type_t md_alg, size_t *hash_len )\n{\n    const mbedtls_md_info_t *md_info;\n\n    if( *hash_len != 0 )\n        return( 0 );\n\n    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )\n        return( -1 );\n\n    *hash_len = mbedtls_md_get_size( md_info );\n    return( 0 );\n}","filepath":"library/pk.c","line_number":234,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"458144":{"score":0.77742696,"function_name":"pk_verify","code":"int pk_verify( pk_context *ctx, md_type_t md_alg,\n               const unsigned char *hash, size_t hash_len,\n               const unsigned char *sig, size_t sig_len )\n{\n    if( ctx == NULL || ctx-\u003epk_info == NULL ||\n        pk_hashlen_helper( md_alg, \u0026hash_len ) != 0 )\n        return( POLARSSL_ERR_PK_BAD_INPUT_DATA );\n\n    if( ctx-\u003epk_info-\u003everify_func == NULL )\n        return( POLARSSL_ERR_PK_TYPE_MISMATCH );\n\n    return( ctx-\u003epk_info-\u003everify_func( ctx-\u003epk_ctx, md_alg, hash, hash_len,\n                                       sig, sig_len ) );\n}","filepath":"library/pk.c","line_number":177,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"458307":{"score":0.8445869,"function_name":"mbedtls_pk_verify_ext","code":"int mbedtls_pk_verify_ext( mbedtls_pk_type_t type, const void *options,\n                   mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,\n                   const unsigned char *hash, size_t hash_len,\n                   const unsigned char *sig, size_t sig_len )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    PK_VALIDATE_RET( ( md_alg == MBEDTLS_MD_NONE \u0026\u0026 hash_len == 0 ) ||\n                     hash != NULL );\n    PK_VALIDATE_RET( sig != NULL );\n\n    if( ctx-\u003epk_info == NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ! mbedtls_pk_can_do( ctx, type ) )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    if( type == MBEDTLS_PK_RSASSA_PSS )\n    {\n#if defined(MBEDTLS_RSA_C) \u0026\u0026 defined(MBEDTLS_PKCS1_V21)\n        int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n        const mbedtls_pk_rsassa_pss_options *pss_opts;\n\n#if SIZE_MAX \u003e UINT_MAX\n        if( md_alg == MBEDTLS_MD_NONE \u0026\u0026 UINT_MAX \u003c hash_len )\n            return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n#endif /* SIZE_MAX \u003e UINT_MAX */\n\n        if( options == NULL )\n            return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n        pss_opts = (const mbedtls_pk_rsassa_pss_options *) options;\n\n        if( sig_len \u003c mbedtls_pk_get_len( ctx ) )\n            return( MBEDTLS_ERR_RSA_VERIFY_FAILED );\n\n        ret = mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_pk_rsa( *ctx ),\n                                                 md_alg, (unsigned int) hash_len, hash,\n                                                 pss_opts-\u003emgf1_hash_id,\n                                                 pss_opts-\u003eexpected_salt_len,\n                                                 sig );\n        if( ret != 0 )\n            return( ret );\n\n        if( sig_len \u003e mbedtls_pk_get_len( ctx ) )\n            return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );\n\n        return( 0 );\n#else\n        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );\n#endif /* MBEDTLS_RSA_C \u0026\u0026 MBEDTLS_PKCS1_V21 */\n    }\n\n    /* General case: no options */\n    if( options != NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    return( mbedtls_pk_verify( ctx, md_alg, hash, hash_len, sig, sig_len ) );\n}","filepath":"library/pk.c","line_number":334,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"458424":{"score":0.84100807,"function_name":"mbedtls_pk_verify_restartable","code":"int mbedtls_pk_verify_restartable( mbedtls_pk_context *ctx,\n               mbedtls_md_type_t md_alg,\n               const unsigned char *hash, size_t hash_len,\n               const unsigned char *sig, size_t sig_len,\n               mbedtls_pk_restart_ctx *rs_ctx )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    PK_VALIDATE_RET( ( md_alg == MBEDTLS_MD_NONE \u0026\u0026 hash_len == 0 ) ||\n                     hash != NULL );\n    PK_VALIDATE_RET( sig != NULL );\n\n    if( ctx-\u003epk_info == NULL ||\n        pk_hashlen_helper( md_alg, \u0026hash_len ) != 0 )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n    /* optimization: use non-restartable version if restart disabled */\n    if( rs_ctx != NULL \u0026\u0026\n        mbedtls_ecp_restart_is_enabled() \u0026\u0026\n        ctx-\u003epk_info-\u003everify_rs_func != NULL )\n    {\n        int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n        if( ( ret = pk_restart_setup( rs_ctx, ctx-\u003epk_info ) ) != 0 )\n            return( ret );\n\n        ret = ctx-\u003epk_info-\u003everify_rs_func( ctx-\u003epk_ctx,\n                   md_alg, hash, hash_len, sig, sig_len, rs_ctx-\u003ers_ctx );\n\n        if( ret != MBEDTLS_ERR_ECP_IN_PROGRESS )\n            mbedtls_pk_restart_free( rs_ctx );\n\n        return( ret );\n    }\n#else /* MBEDTLS_ECDSA_C \u0026\u0026 MBEDTLS_ECP_RESTARTABLE */\n    (void) rs_ctx;\n#endif /* MBEDTLS_ECDSA_C \u0026\u0026 MBEDTLS_ECP_RESTARTABLE */\n\n    if( ctx-\u003epk_info-\u003everify_func == NULL )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    return( ctx-\u003epk_info-\u003everify_func( ctx-\u003epk_ctx, md_alg, hash, hash_len,\n                                       sig, sig_len ) );\n}","filepath":"library/pk.c","line_number":275,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"458596":{"score":0.9028782,"function_name":"mbedtls_pk_encrypt","code":"int mbedtls_pk_encrypt( mbedtls_pk_context *ctx,\n                const unsigned char *input, size_t ilen,\n                unsigned char *output, size_t *olen, size_t osize,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    PK_VALIDATE_RET( input != NULL || ilen == 0 );\n    PK_VALIDATE_RET( output != NULL || osize == 0 );\n    PK_VALIDATE_RET( olen != NULL );\n\n    if( ctx-\u003epk_info == NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ctx-\u003epk_info-\u003eencrypt_func == NULL )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    return( ctx-\u003epk_info-\u003eencrypt_func( ctx-\u003epk_ctx, input, ilen,\n                output, olen, osize, f_rng, p_rng ) );\n}","filepath":"library/pk.c","line_number":485,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"458690":{"score":0.8179023,"function_name":"pk_encrypt","code":"int pk_encrypt( pk_context *ctx,\n                const unsigned char *input, size_t ilen,\n                unsigned char *output, size_t *olen, size_t osize,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    if( ctx == NULL || ctx-\u003epk_info == NULL )\n        return( POLARSSL_ERR_PK_BAD_INPUT_DATA );\n\n    if( ctx-\u003epk_info-\u003eencrypt_func == NULL )\n        return( POLARSSL_ERR_PK_TYPE_MISMATCH );\n\n    return( ctx-\u003epk_info-\u003eencrypt_func( ctx-\u003epk_ctx, input, ilen,\n                output, olen, osize, f_rng, p_rng ) );\n}","filepath":"library/pk.c","line_number":285,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"458784":{"score":0.70626473,"function_name":"mbedtls_pk_check_pair","code":"int mbedtls_pk_check_pair( const mbedtls_pk_context *pub,\n                           const mbedtls_pk_context *prv,\n                           int (*f_rng)(void *, unsigned char *, size_t),\n                           void *p_rng )\n{\n    PK_VALIDATE_RET( pub != NULL );\n    PK_VALIDATE_RET( prv != NULL );\n\n    if( pub-\u003epk_info == NULL ||\n        prv-\u003epk_info == NULL )\n    {\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n    }\n\n    if( f_rng == NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( prv-\u003epk_info-\u003echeck_pair_func == NULL )\n        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );\n\n    if( prv-\u003epk_info-\u003etype == MBEDTLS_PK_RSA_ALT )\n    {\n        if( pub-\u003epk_info-\u003etype != MBEDTLS_PK_RSA )\n            return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n    }\n    else\n    {\n        if( pub-\u003epk_info != prv-\u003epk_info )\n            return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n    }\n\n    return( prv-\u003epk_info-\u003echeck_pair_func( pub-\u003epk_ctx, prv-\u003epk_ctx, f_rng, p_rng ) );\n}","filepath":"library/pk.c","line_number":508,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"458984":{"score":0.87161595,"function_name":"mbedtls_pk_debug","code":"int mbedtls_pk_debug( const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    if( ctx-\u003epk_info == NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ctx-\u003epk_info-\u003edebug_func == NULL )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    ctx-\u003epk_info-\u003edebug_func( ctx-\u003epk_ctx, items );\n    return( 0 );\n}","filepath":"library/pk.c","line_number":558,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"459244":{"score":0.8043988,"function_name":"rsa_verify_wrap","code":"static int rsa_verify_wrap( void *ctx, md_type_t md_alg,\n                   const unsigned char *hash, size_t hash_len,\n                   const unsigned char *sig, size_t sig_len )\n{\n    int ret;\n\n    if( sig_len \u003c ((rsa_context *) ctx)-\u003elen )\n        return( POLARSSL_ERR_RSA_VERIFY_FAILED );\n\n    if( ( ret = rsa_pkcs1_verify( (rsa_context *) ctx, NULL, NULL,\n                                  RSA_PUBLIC, md_alg,\n                                  (unsigned int) hash_len, hash, sig ) ) != 0 )\n        return( ret );\n\n    if( sig_len \u003e ((rsa_context *) ctx)-\u003elen )\n        return( POLARSSL_ERR_PK_SIG_LEN_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/pk_wrap.c","line_number":69,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"459449":{"score":0.8407671,"function_name":"rsa_decrypt_wrap","code":"static int rsa_decrypt_wrap( void *ctx,\n                    const unsigned char *input, size_t ilen,\n                    unsigned char *output, size_t *olen, size_t osize,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    if( ilen != ((rsa_context *) ctx)-\u003elen )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    return( rsa_pkcs1_decrypt( (rsa_context *) ctx, f_rng, p_rng,\n                RSA_PRIVATE, olen, input, output, osize ) );\n}","filepath":"library/pk_wrap.c","line_number":100,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"459535":{"score":0.7528653,"function_name":"rsa_encrypt_wrap","code":"static int rsa_encrypt_wrap( void *ctx,\n                    const unsigned char *input, size_t ilen,\n                    unsigned char *output, size_t *olen, size_t osize,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    *olen = ((rsa_context *) ctx)-\u003elen;\n\n    if( *olen \u003e osize )\n        return( POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE );\n\n    return( rsa_pkcs1_encrypt( (rsa_context *) ctx,\n                f_rng, p_rng, RSA_PUBLIC, ilen, input, output ) );\n}","filepath":"library/pk_wrap.c","line_number":112,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"459797":{"score":0.8970959,"function_name":"rsa_debug","code":"static void rsa_debug( const void *ctx, pk_debug_item *items )\n{\n    items-\u003etype = POLARSSL_PK_DEBUG_MPI;\n    items-\u003ename = \"rsa.N\";\n    items-\u003evalue = \u0026( ((rsa_context *) ctx)-\u003eN );\n\n    items++;\n\n    items-\u003etype = POLARSSL_PK_DEBUG_MPI;\n    items-\u003ename = \"rsa.E\";\n    items-\u003evalue = \u0026( ((rsa_context *) ctx)-\u003eE );\n}","filepath":"library/pk_wrap.c","line_number":148,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"460273":{"score":0.86045206,"function_name":"rsa_alt_sign_wrap","code":"static int rsa_alt_sign_wrap( void *ctx, md_type_t md_alg,\n                   const unsigned char *hash, size_t hash_len,\n                   unsigned char *sig, size_t *sig_len,\n                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    rsa_alt_context *rsa_alt = (rsa_alt_context *) ctx;\n\n    *sig_len = rsa_alt-\u003ekey_len_func( rsa_alt-\u003ekey );\n\n    return( rsa_alt-\u003esign_func( rsa_alt-\u003ekey, f_rng, p_rng, RSA_PRIVATE,\n                md_alg, (unsigned int) hash_len, hash, sig ) );\n}","filepath":"library/pk_wrap.c","line_number":406,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"460361":{"score":0.76610065,"function_name":"rsa_alt_decrypt_wrap","code":"static int rsa_alt_decrypt_wrap( void *ctx,\n                    const unsigned char *input, size_t ilen,\n                    unsigned char *output, size_t *olen, size_t osize,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    rsa_alt_context *rsa_alt = (rsa_alt_context *) ctx;\n\n    ((void) f_rng);\n    ((void) p_rng);\n\n    if( ilen != rsa_alt-\u003ekey_len_func( rsa_alt-\u003ekey ) )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    return( rsa_alt-\u003edecrypt_func( rsa_alt-\u003ekey,\n                RSA_PRIVATE, olen, input, output, osize ) );\n}","filepath":"library/pk_wrap.c","line_number":419,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"460451":{"score":0.8771241,"function_name":"rsa_alt_check_pair","code":"static int rsa_alt_check_pair( const void *pub, const void *prv )\n{\n    unsigned char sig[POLARSSL_MPI_MAX_SIZE];\n    unsigned char hash[32];\n    size_t sig_len = 0;\n    int ret;\n\n    if( rsa_alt_get_size( prv ) != rsa_get_size( pub ) )\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n\n    memset( hash, 0x2a, sizeof( hash ) );\n\n    if( ( ret = rsa_alt_sign_wrap( (void *) prv, POLARSSL_MD_NONE,\n                                   hash, sizeof( hash ),\n                                   sig, \u0026sig_len, NULL, NULL ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( rsa_verify_wrap( (void *) pub, POLARSSL_MD_NONE,\n                         hash, sizeof( hash ), sig, sig_len ) != 0 )\n    {\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    return( 0 );\n}","filepath":"library/pk_wrap.c","line_number":437,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"461070":{"score":0.8368689,"function_name":"pk_use_ecparams","code":"static int pk_use_ecparams( const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp )\n{\n    int ret;\n    mbedtls_ecp_group_id grp_id;\n\n    if( params-\u003etag == MBEDTLS_ASN1_OID )\n    {\n        if( mbedtls_oid_get_ec_grp( params, \u0026grp_id ) != 0 )\n            return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );\n    }\n    else\n    {\n#if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)\n        if( ( ret = pk_group_id_from_specified( params, \u0026grp_id ) ) != 0 )\n            return( ret );\n#else\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n#endif\n    }\n\n    /*\n     * grp may already be initilialized; if so, make sure IDs match\n     */\n    if( grp-\u003eid != MBEDTLS_ECP_DP_NONE \u0026\u0026 grp-\u003eid != grp_id )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n\n    if( ( ret = mbedtls_ecp_group_load( grp, grp_id ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":461,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"461244":{"score":0.8166456,"function_name":"pk_get_ecpubkey","code":"static int pk_get_ecpubkey( unsigned char **p, const unsigned char *end,\n                            mbedtls_ecp_keypair *key )\n{\n    int ret;\n\n    if( ( ret = mbedtls_ecp_point_read_binary( \u0026key-\u003egrp, \u0026key-\u003eQ,\n                    (const unsigned char *) *p, end - *p ) ) == 0 )\n    {\n        ret = mbedtls_ecp_check_pubkey( \u0026key-\u003egrp, \u0026key-\u003eQ );\n    }\n\n    /*\n     * We know mbedtls_ecp_point_read_binary consumed all bytes or failed\n     */\n    *p = (unsigned char *) end;\n\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":500,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"461361":{"score":0.7991952,"function_name":"pk_get_rsapubkey","code":"static int pk_get_rsapubkey( unsigned char **p,\n                             const unsigned char *end,\n                             mbedtls_rsa_context *rsa )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( *p + len != end )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    /* Import N */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len, MBEDTLS_ASN1_INTEGER ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( ( ret = mbedtls_rsa_import_raw( rsa, *p, len, NULL, 0, NULL, 0,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );\n\n    *p += len;\n\n    /* Import E */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len, MBEDTLS_ASN1_INTEGER ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,\n                                        NULL, 0, *p, len ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );\n\n    *p += len;\n\n    if( mbedtls_rsa_complete( rsa ) != 0 ||\n        mbedtls_rsa_check_pubkey( rsa ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );\n    }\n\n    if( *p != end )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":527,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"461791":{"score":0.86673117,"function_name":"pk_get_pk_alg","code":"static int pk_get_pk_alg( unsigned char **p,\n                          const unsigned char *end,\n                          mbedtls_pk_type_t *pk_alg, mbedtls_asn1_buf *params )\n{\n    int ret;\n    mbedtls_asn1_buf alg_oid;\n\n    memset( params, 0, sizeof(mbedtls_asn1_buf) );\n\n    if( ( ret = mbedtls_asn1_get_alg( p, end, \u0026alg_oid, params ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_ALG + ret );\n\n    if( mbedtls_oid_get_pk_alg( \u0026alg_oid, pk_alg ) != 0 )\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    /*\n     * No parameters with RSA (only for EC)\n     */\n    if( *pk_alg == MBEDTLS_PK_RSA \u0026\u0026\n            ( ( params-\u003etag != MBEDTLS_ASN1_NULL \u0026\u0026 params-\u003etag != 0 ) ||\n                params-\u003elen != 0 ) )\n    {\n        return( MBEDTLS_ERR_PK_INVALID_ALG );\n    }\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":582,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"462004":{"score":0.779385,"function_name":"mbedtls_pk_parse_subpubkey","code":"int mbedtls_pk_parse_subpubkey( unsigned char **p, const unsigned char *end,\n                        mbedtls_pk_context *pk )\n{\n    int ret;\n    size_t len;\n    mbedtls_asn1_buf alg_params;\n    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n    const mbedtls_pk_info_t *pk_info;\n\n    PK_VALIDATE_RET( p != NULL );\n    PK_VALIDATE_RET( *p != NULL );\n    PK_VALIDATE_RET( end != NULL );\n    PK_VALIDATE_RET( pk != NULL );\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n                    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    end = *p + len;\n\n    if( ( ret = pk_get_pk_alg( p, end, \u0026pk_alg, \u0026alg_params ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, \u0026len ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( *p + len != end )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_RSA_C)\n    if( pk_alg == MBEDTLS_PK_RSA )\n    {\n        ret = pk_get_rsapubkey( p, end, mbedtls_pk_rsa( *pk ) );\n    } else\n#endif /* MBEDTLS_RSA_C */\n#if defined(MBEDTLS_ECP_C)\n    if( pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY )\n    {\n        ret = pk_use_ecparams( \u0026alg_params, \u0026mbedtls_pk_ec( *pk )-\u003egrp );\n        if( ret == 0 )\n            ret = pk_get_ecpubkey( p, end, mbedtls_pk_ec( *pk ) );\n    } else\n#endif /* MBEDTLS_ECP_C */\n        ret = MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;\n\n    if( ret == 0 \u0026\u0026 *p != end )\n        ret = MBEDTLS_ERR_PK_INVALID_PUBKEY\n              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;\n\n    if( ret != 0 )\n        mbedtls_pk_free( pk );\n\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":615,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"462515":{"score":0.8282187,"function_name":"pk_parse_key_pkcs1_der","code":"static int pk_parse_key_pkcs1_der( mbedtls_rsa_context *rsa,\n                                   const unsigned char *key,\n                                   size_t keylen )\n{\n    int ret, version;\n    size_t len;\n    unsigned char *p, *end;\n\n    mbedtls_mpi T;\n    mbedtls_mpi_init( \u0026T );\n\n    p = (unsigned char *) key;\n    end = p + keylen;\n\n    /*\n     * This function parses the RSAPrivateKey (PKCS#1)\n     *\n     *  RSAPrivateKey ::= SEQUENCE {\n     *      version           Version,\n     *      modulus           INTEGER,  -- n\n     *      publicExponent    INTEGER,  -- e\n     *      privateExponent   INTEGER,  -- d\n     *      prime1            INTEGER,  -- p\n     *      prime2            INTEGER,  -- q\n     *      exponent1         INTEGER,  -- d mod (p-1)\n     *      exponent2         INTEGER,  -- d mod (q-1)\n     *      coefficient       INTEGER,  -- (inverse of q) mod p\n     *      otherPrimeInfos   OtherPrimeInfos OPTIONAL\n     *  }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( \u0026p, end, \u0026version ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    if( version != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );\n    }\n\n    /* Import N */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, p, len, NULL, 0, NULL, 0,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import E */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,\n                                        NULL, 0, p, len ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import D */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,\n                                        p, len, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import P */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, p, len, NULL, 0,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import Q */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, p, len,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Complete the RSA private key */\n    if( ( ret = mbedtls_rsa_complete( rsa ) ) != 0 )\n        goto cleanup;\n\n    /* Check optional parameters */\n    if( ( ret = mbedtls_asn1_get_mpi( \u0026p, end, \u0026T ) ) != 0 ||\n        ( ret = mbedtls_asn1_get_mpi( \u0026p, end, \u0026T ) ) != 0 ||\n        ( ret = mbedtls_asn1_get_mpi( \u0026p, end, \u0026T ) ) != 0 )\n        goto cleanup;\n\n    if( p != end )\n    {\n        ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +\n              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH ;\n    }\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026T );\n\n    if( ret != 0 )\n    {\n        /* Wrap error code if it's coming from a lower level */\n        if( ( ret \u0026 0xff80 ) == 0 )\n            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret;\n        else\n            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;\n\n        mbedtls_rsa_free( rsa );\n    }\n\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":683,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"463408":{"score":0.8076393,"function_name":"pk_parse_key_sec1_der","code":"static int pk_parse_key_sec1_der( mbedtls_ecp_keypair *eck,\n                                  const unsigned char *key,\n                                  size_t keylen )\n{\n    int ret;\n    int version, pubkey_done;\n    size_t len;\n    mbedtls_asn1_buf params;\n    unsigned char *p = (unsigned char *) key;\n    unsigned char *end = p + keylen;\n    unsigned char *end2;\n\n    /*\n     * RFC 5915, or SEC1 Appendix C.4\n     *\n     * ECPrivateKey ::= SEQUENCE {\n     *      version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),\n     *      privateKey     OCTET STRING,\n     *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,\n     *      publicKey  [1] BIT STRING OPTIONAL\n     *    }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( \u0026p, end, \u0026version ) ) != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n    if( version != 1 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );\n\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n    if( ( ret = mbedtls_mpi_read_binary( \u0026eck-\u003ed, p, len ) ) != 0 )\n    {\n        mbedtls_ecp_keypair_free( eck );\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    p += len;\n\n    pubkey_done = 0;\n    if( p != end )\n    {\n        /*\n         * Is 'parameters' present?\n         */\n        if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) == 0 )\n        {\n            if( ( ret = pk_get_ecparams( \u0026p, p + len, \u0026params) ) != 0 ||\n                ( ret = pk_use_ecparams( \u0026params, \u0026eck-\u003egrp )  ) != 0 )\n            {\n                mbedtls_ecp_keypair_free( eck );\n                return( ret );\n            }\n        }\n        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n        {\n            mbedtls_ecp_keypair_free( eck );\n            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n        }\n    }\n\n    if( p != end )\n    {\n        /*\n         * Is 'publickey' present? If not, or if we can't read it (eg because it\n         * is compressed), create it from the private key.\n         */\n        if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 1 ) ) == 0 )\n        {\n            end2 = p + len;\n\n            if( ( ret = mbedtls_asn1_get_bitstring_null( \u0026p, end2, \u0026len ) ) != 0 )\n                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n            if( p + len != end2 )\n                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +\n                        MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n            if( ( ret = pk_get_ecpubkey( \u0026p, end2, eck ) ) == 0 )\n                pubkey_done = 1;\n            else\n            {\n                /*\n                 * The only acceptable failure mode of pk_get_ecpubkey() above\n                 * is if the point format is not recognized.\n                 */\n                if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE )\n                    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n            }\n        }\n        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n        {\n            mbedtls_ecp_keypair_free( eck );\n            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n        }\n    }\n\n    if( ! pubkey_done \u0026\u0026\n        ( ret = mbedtls_ecp_mul( \u0026eck-\u003egrp, \u0026eck-\u003eQ, \u0026eck-\u003ed, \u0026eck-\u003egrp.G,\n                                                      NULL, NULL ) ) != 0 )\n    {\n        mbedtls_ecp_keypair_free( eck );\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    if( ( ret = mbedtls_ecp_check_privkey( \u0026eck-\u003egrp, \u0026eck-\u003ed ) ) != 0 )\n    {\n        mbedtls_ecp_keypair_free( eck );\n        return( ret );\n    }\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":810,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"464250":{"score":0.78514385,"function_name":"pk_parse_key_pkcs8_unencrypted_der","code":"static int pk_parse_key_pkcs8_unencrypted_der(\n                                    mbedtls_pk_context *pk,\n                                    const unsigned char* key,\n                                    size_t keylen )\n{\n    int ret, version;\n    size_t len;\n    mbedtls_asn1_buf params;\n    unsigned char *p = (unsigned char *) key;\n    unsigned char *end = p + keylen;\n    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n    const mbedtls_pk_info_t *pk_info;\n\n    /*\n     * This function parses the PrivateKeyInfo object (PKCS#8 v1.2 = RFC 5208)\n     *\n     *    PrivateKeyInfo ::= SEQUENCE {\n     *      version                   Version,\n     *      privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,\n     *      privateKey                PrivateKey,\n     *      attributes           [0]  IMPLICIT Attributes OPTIONAL }\n     *\n     *    Version ::= INTEGER\n     *    PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\n     *    PrivateKey ::= OCTET STRING\n     *\n     *  The PrivateKey OCTET STRING is a SEC1 ECPrivateKey\n     */\n\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( \u0026p, end, \u0026version ) ) != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n    if( version != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION + ret );\n\n    if( ( ret = pk_get_pk_alg( \u0026p, end, \u0026pk_alg, \u0026params ) ) != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n    if( len \u003c 1 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +\n                MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_RSA_C)\n    if( pk_alg == MBEDTLS_PK_RSA )\n    {\n        if( ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), p, len ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n            return( ret );\n        }\n    } else\n#endif /* MBEDTLS_RSA_C */\n#if defined(MBEDTLS_ECP_C)\n    if( pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH )\n    {\n        if( ( ret = pk_use_ecparams( \u0026params, \u0026mbedtls_pk_ec( *pk )-\u003egrp ) ) != 0 ||\n            ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ), p, len )  ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n            return( ret );\n        }\n    } else\n#endif /* MBEDTLS_ECP_C */\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":948,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"464855":{"score":0.67745495,"function_name":"mbedtls_pk_parse_key","code":"int mbedtls_pk_parse_key( mbedtls_pk_context *pk,\n                  const unsigned char *key, size_t keylen,\n                  const unsigned char *pwd, size_t pwdlen )\n{\n    int ret;\n    const mbedtls_pk_info_t *pk_info;\n#if defined(MBEDTLS_PEM_PARSE_C)\n    size_t len;\n    mbedtls_pem_context pem;\n#endif\n\n    PK_VALIDATE_RET( pk != NULL );\n    if( keylen == 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n    PK_VALIDATE_RET( key != NULL );\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n   mbedtls_pem_init( \u0026pem );\n\n#if defined(MBEDTLS_RSA_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN RSA PRIVATE KEY-----\",\n                               \"-----END RSA PRIVATE KEY-----\",\n                               key, pwd, pwdlen, \u0026len );\n\n    if( ret == 0 )\n    {\n        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );\n        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||\n            ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ),\n                                            pem.buf, pem.buflen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )\n        return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )\n        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n#endif /* MBEDTLS_RSA_C */\n\n#if defined(MBEDTLS_ECP_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN EC PRIVATE KEY-----\",\n                               \"-----END EC PRIVATE KEY-----\",\n                               key, pwd, pwdlen, \u0026len );\n    if( ret == 0 )\n    {\n        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );\n\n        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||\n            ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),\n                                           pem.buf, pem.buflen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )\n        return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )\n        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n#endif /* MBEDTLS_ECP_C */\n\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN PRIVATE KEY-----\",\n                               \"-----END PRIVATE KEY-----\",\n                               key, NULL, 0, \u0026len );\n    if( ret == 0 )\n    {\n        if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk,\n                                                pem.buf, pem.buflen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n\n#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN ENCRYPTED PRIVATE KEY-----\",\n                               \"-----END ENCRYPTED PRIVATE KEY-----\",\n                               key, NULL, 0, \u0026len );\n    if( ret == 0 )\n    {\n        if( ( ret = pk_parse_key_pkcs8_encrypted_der( pk,\n                                                      pem.buf, pem.buflen,\n                                                      pwd, pwdlen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */\n#else\n    ((void) pwd);\n    ((void) pwdlen);\n#endif /* MBEDTLS_PEM_PARSE_C */\n\n    /*\n     * At this point we only know it's not a PEM formatted key. Could be any\n     * of the known DER encoded private key formats\n     *\n     * We try the different DER format parsers to see if one passes without\n     * error\n     */\n#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)\n    {\n        unsigned char *key_copy;\n\n        if( ( key_copy = mbedtls_calloc( 1, keylen ) ) == NULL )\n            return( MBEDTLS_ERR_PK_ALLOC_FAILED );\n\n        memcpy( key_copy, key, keylen );\n\n        ret = pk_parse_key_pkcs8_encrypted_der( pk, key_copy, keylen,\n                                                pwd, pwdlen );\n\n        mbedtls_platform_zeroize( key_copy, keylen );\n        mbedtls_free( key_copy );\n    }\n\n    if( ret == 0 )\n        return( 0 );\n\n    mbedtls_pk_free( pk );\n    mbedtls_pk_init( pk );\n\n    if( ret == MBEDTLS_ERR_PK_PASSWORD_MISMATCH )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */\n\n    if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk, key, keylen ) ) == 0 )\n        return( 0 );\n\n    mbedtls_pk_free( pk );\n    mbedtls_pk_init( pk );\n\n#if defined(MBEDTLS_RSA_C)\n\n    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );\n    if( mbedtls_pk_setup( pk, pk_info ) == 0 \u0026\u0026\n        pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), key, keylen ) == 0 )\n    {\n        return( 0 );\n    }\n\n    mbedtls_pk_free( pk );\n    mbedtls_pk_init( pk );\n#endif /* MBEDTLS_RSA_C */\n\n#if defined(MBEDTLS_ECP_C)\n    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );\n    if( mbedtls_pk_setup( pk, pk_info ) == 0 \u0026\u0026\n        pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),\n                               key, keylen ) == 0 )\n    {\n        return( 0 );\n    }\n    mbedtls_pk_free( pk );\n#endif /* MBEDTLS_ECP_C */\n\n    /* If MBEDTLS_RSA_C is defined but MBEDTLS_ECP_C isn't,\n     * it is ok to leave the PK context initialized but not\n     * freed: It is the caller's responsibility to call pk_init()\n     * before calling this function, and to call pk_free()\n     * when it fails. If MBEDTLS_ECP_C is defined but MBEDTLS_RSA_C\n     * isn't, this leads to mbedtls_pk_free() being called\n     * twice, once here and once by the caller, but this is\n     * also ok and in line with the mbedtls_pk_free() calls\n     * on failed PEM parsing attempts. */\n\n    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":1163,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"465928":{"score":0.7529571,"function_name":"mbedtls_pk_parse_public_key","code":"int mbedtls_pk_parse_public_key( mbedtls_pk_context *ctx,\n                         const unsigned char *key, size_t keylen )\n{\n    int ret;\n    unsigned char *p;\n#if defined(MBEDTLS_RSA_C)\n    const mbedtls_pk_info_t *pk_info;\n#endif\n#if defined(MBEDTLS_PEM_PARSE_C)\n    size_t len;\n    mbedtls_pem_context pem;\n#endif\n\n    PK_VALIDATE_RET( ctx != NULL );\n    if( keylen == 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n    PK_VALIDATE_RET( key != NULL || keylen == 0 );\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n    mbedtls_pem_init( \u0026pem );\n#if defined(MBEDTLS_RSA_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN RSA PUBLIC KEY-----\",\n                               \"-----END RSA PUBLIC KEY-----\",\n                               key, NULL, 0, \u0026len );\n\n    if( ret == 0 )\n    {\n        p = pem.buf;\n        if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )\n            return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n        if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )\n            return( ret );\n\n        if ( ( ret = pk_get_rsapubkey( \u0026p, p + pem.buflen, mbedtls_pk_rsa( *ctx ) ) ) != 0 )\n            mbedtls_pk_free( ctx );\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n    {\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n#endif /* MBEDTLS_RSA_C */\n\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                \"-----BEGIN PUBLIC KEY-----\",\n                \"-----END PUBLIC KEY-----\",\n                key, NULL, 0, \u0026len );\n\n    if( ret == 0 )\n    {\n        /*\n         * Was PEM encoded\n         */\n        p = pem.buf;\n\n        ret = mbedtls_pk_parse_subpubkey( \u0026p,  p + pem.buflen, ctx );\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n    {\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    mbedtls_pem_free( \u0026pem );\n#endif /* MBEDTLS_PEM_PARSE_C */\n\n#if defined(MBEDTLS_RSA_C)\n    if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )\n        return( ret );\n\n    p = (unsigned char *)key;\n    ret = pk_get_rsapubkey( \u0026p, p + keylen, mbedtls_pk_rsa( *ctx ) );\n    if( ret == 0 )\n    {\n        return( ret );\n    }\n    mbedtls_pk_free( ctx );\n    if( ret != ( MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_RSA_C */\n    p = (unsigned char *) key;\n\n    ret = mbedtls_pk_parse_subpubkey( \u0026p, p + keylen, ctx );\n\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/pkparse.c","line_number":1376,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"466679":{"score":0.8479453,"function_name":"mbedtls_safer_memcmp","code":"static inline int mbedtls_safer_memcmp( const void *a, const void *b, size_t n )\n{\n    size_t i;\n    const unsigned char *A = (const unsigned char *) a;\n    const unsigned char *B = (const unsigned char *) b;\n    unsigned char diff = 0;\n\n    for( i = 0; i \u003c n; i++ )\n        diff |= A[i] ^ B[i];\n\n    return( diff );\n}","filepath":"library/rsa.c","line_number":82,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"466765":{"score":0.77940464,"function_name":"mbedtls_rsa_import","code":"int mbedtls_rsa_import( mbedtls_rsa_context *ctx,\n                        const mbedtls_mpi *N,\n                        const mbedtls_mpi *P, const mbedtls_mpi *Q,\n                        const mbedtls_mpi *D, const mbedtls_mpi *E )\n{\n    int ret;\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    if( ( N != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eN, N ) ) != 0 ) ||\n        ( P != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eP, P ) ) != 0 ) ||\n        ( Q != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eQ, Q ) ) != 0 ) ||\n        ( D != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eD, D ) ) != 0 ) ||\n        ( E != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eE, E ) ) != 0 ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n    }\n\n    if( N != NULL )\n        ctx-\u003elen = mbedtls_mpi_size( \u0026ctx-\u003eN );\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":96,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"467019":{"score":0.721372,"function_name":"mbedtls_rsa_import_raw","code":"int mbedtls_rsa_import_raw( mbedtls_rsa_context *ctx,\n                            unsigned char const *N, size_t N_len,\n                            unsigned char const *P, size_t P_len,\n                            unsigned char const *Q, size_t Q_len,\n                            unsigned char const *D, size_t D_len,\n                            unsigned char const *E, size_t E_len )\n{\n    int ret = 0;\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    if( N != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eN, N, N_len ) );\n        ctx-\u003elen = mbedtls_mpi_size( \u0026ctx-\u003eN );\n    }\n\n    if( P != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eP, P, P_len ) );\n\n    if( Q != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eQ, Q, Q_len ) );\n\n    if( D != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eD, D, D_len ) );\n\n    if( E != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eE, E, E_len ) );\n\ncleanup:\n\n    if( ret != 0 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":119,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"467308":{"score":0.7420171,"function_name":"rsa_check_context","code":"static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,\n                              int blinding_needed )\n{\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    /* blinding_needed is only used for NO_CRT to decide whether\n     * P,Q need to be present or not. */\n    ((void) blinding_needed);\n#endif\n\n    if( ctx-\u003elen != mbedtls_mpi_size( \u0026ctx-\u003eN ) ||\n        ctx-\u003elen \u003e MBEDTLS_MPI_MAX_SIZE )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n\n    /*\n     * 1. Modular exponentiation needs positive, odd moduli.\n     */\n\n    /* Modular exponentiation wrt. N is always used for\n     * RSA public key operations. */\n    if( mbedtls_mpi_cmp_int( \u0026ctx-\u003eN, 0 ) \u003c= 0 ||\n        mbedtls_mpi_get_bit( \u0026ctx-\u003eN, 0 ) == 0  )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    /* Modular exponentiation for P and Q is only\n     * used for private key operations and if CRT\n     * is used. */\n    if( is_priv \u0026\u0026\n        ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) \u003c= 0 ||\n          mbedtls_mpi_get_bit( \u0026ctx-\u003eP, 0 ) == 0 ||\n          mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) \u003c= 0 ||\n          mbedtls_mpi_get_bit( \u0026ctx-\u003eQ, 0 ) == 0  ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif /* !MBEDTLS_RSA_NO_CRT */\n\n    /*\n     * 2. Exponents must be positive\n     */\n\n    /* Always need E for public key operations */\n    if( mbedtls_mpi_cmp_int( \u0026ctx-\u003eE, 0 ) \u003c= 0 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_RSA_NO_CRT)\n    /* For private key operations, use D or DP \u0026 DQ\n     * as (unblinded) exponents. */\n    if( is_priv \u0026\u0026 mbedtls_mpi_cmp_int( \u0026ctx-\u003eD, 0 ) \u003c= 0 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n#else\n    if( is_priv \u0026\u0026\n        ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eDP, 0 ) \u003c= 0 ||\n          mbedtls_mpi_cmp_int( \u0026ctx-\u003eDQ, 0 ) \u003c= 0  ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif /* MBEDTLS_RSA_NO_CRT */\n\n    /* Blinding shouldn't make exponents negative either,\n     * so check that P, Q \u003e= 1 if that hasn't yet been\n     * done as part of 1. */\n#if defined(MBEDTLS_RSA_NO_CRT)\n    if( is_priv \u0026\u0026 blinding_needed \u0026\u0026\n        ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) \u003c= 0 ||\n          mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) \u003c= 0 ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif\n\n    /* It wouldn't lead to an error if it wasn't satisfied,\n     * but check for QP \u003e= 1 nonetheless. */\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    if( is_priv \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eQP, 0 ) \u003c= 0 )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":160,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"467686":{"score":0.8621108,"function_name":"mbedtls_rsa_complete","code":"int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )\n{\n    int ret = 0;\n    int have_N, have_P, have_Q, have_D, have_E;\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    int have_DP, have_DQ, have_QP;\n#endif\n    int n_missing, pq_missing, d_missing, is_pub, is_priv;\n\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    have_N = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eN, 0 ) != 0 );\n    have_P = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) != 0 );\n    have_Q = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) != 0 );\n    have_D = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eD, 0 ) != 0 );\n    have_E = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eE, 0 ) != 0 );\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    have_DP = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eDP, 0 ) != 0 );\n    have_DQ = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eDQ, 0 ) != 0 );\n    have_QP = ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eQP, 0 ) != 0 );\n#endif\n\n    /*\n     * Check whether provided parameters are enough\n     * to deduce all others. The following incomplete\n     * parameter sets for private keys are supported:\n     *\n     * (1) P, Q missing.\n     * (2) D and potentially N missing.\n     *\n     */\n\n    n_missing  =              have_P \u0026\u0026  have_Q \u0026\u0026  have_D \u0026\u0026 have_E;\n    pq_missing =   have_N \u0026\u0026 !have_P \u0026\u0026 !have_Q \u0026\u0026  have_D \u0026\u0026 have_E;\n    d_missing  =              have_P \u0026\u0026  have_Q \u0026\u0026 !have_D \u0026\u0026 have_E;\n    is_pub     =   have_N \u0026\u0026 !have_P \u0026\u0026 !have_Q \u0026\u0026 !have_D \u0026\u0026 have_E;\n\n    /* These three alternatives are mutually exclusive */\n    is_priv = n_missing || pq_missing || d_missing;\n\n    if( !is_priv \u0026\u0026 !is_pub )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    /*\n     * Step 1: Deduce N if P, Q are provided.\n     */\n\n    if( !have_N \u0026\u0026 have_P \u0026\u0026 have_Q )\n    {\n        if( ( ret = mbedtls_mpi_mul_mpi( \u0026ctx-\u003eN, \u0026ctx-\u003eP,\n                                         \u0026ctx-\u003eQ ) ) != 0 )\n        {\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n        }\n\n        ctx-\u003elen = mbedtls_mpi_size( \u0026ctx-\u003eN );\n    }\n\n    /*\n     * Step 2: Deduce and verify all remaining core parameters.\n     */\n\n    if( pq_missing )\n    {\n        ret = mbedtls_rsa_deduce_primes( \u0026ctx-\u003eN, \u0026ctx-\u003eE, \u0026ctx-\u003eD,\n                                         \u0026ctx-\u003eP, \u0026ctx-\u003eQ );\n        if( ret != 0 )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n\n    }\n    else if( d_missing )\n    {\n        if( ( ret = mbedtls_rsa_deduce_private_exponent( \u0026ctx-\u003eP,\n                                                         \u0026ctx-\u003eQ,\n                                                         \u0026ctx-\u003eE,\n                                                         \u0026ctx-\u003eD ) ) != 0 )\n        {\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n        }\n    }\n\n    /*\n     * Step 3: Deduce all additional parameters specific\n     *         to our current RSA implementation.\n     */\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    if( is_priv \u0026\u0026 ! ( have_DP \u0026\u0026 have_DQ \u0026\u0026 have_QP ) )\n    {\n        ret = mbedtls_rsa_deduce_crt( \u0026ctx-\u003eP,  \u0026ctx-\u003eQ,  \u0026ctx-\u003eD,\n                                      \u0026ctx-\u003eDP, \u0026ctx-\u003eDQ, \u0026ctx-\u003eQP );\n        if( ret != 0 )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n    }\n#endif /* MBEDTLS_RSA_NO_CRT */\n\n    /*\n     * Step 3: Basic sanity checks\n     */\n\n    return( rsa_check_context( ctx, is_priv, 1 ) );\n}","filepath":"library/rsa.c","line_number":248,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"468434":{"score":0.8662044,"function_name":"mbedtls_rsa_export_raw","code":"int mbedtls_rsa_export_raw( const mbedtls_rsa_context *ctx,\n                            unsigned char *N, size_t N_len,\n                            unsigned char *P, size_t P_len,\n                            unsigned char *Q, size_t Q_len,\n                            unsigned char *D, size_t D_len,\n                            unsigned char *E, size_t E_len )\n{\n    int ret = 0;\n    int is_priv;\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    /* Check if key is private or public */\n    is_priv =\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eN, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eD, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eE, 0 ) != 0;\n\n    if( !is_priv )\n    {\n        /* If we're trying to export private parameters for a public key,\n         * something must be wrong. */\n        if( P != NULL || Q != NULL || D != NULL )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    }\n\n    if( N != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026ctx-\u003eN, N, N_len ) );\n\n    if( P != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026ctx-\u003eP, P, P_len ) );\n\n    if( Q != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026ctx-\u003eQ, Q, Q_len ) );\n\n    if( D != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026ctx-\u003eD, D, D_len ) );\n\n    if( E != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026ctx-\u003eE, E, E_len ) );\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/rsa.c","line_number":352,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"468848":{"score":0.86215377,"function_name":"mbedtls_rsa_export","code":"int mbedtls_rsa_export( const mbedtls_rsa_context *ctx,\n                        mbedtls_mpi *N, mbedtls_mpi *P, mbedtls_mpi *Q,\n                        mbedtls_mpi *D, mbedtls_mpi *E )\n{\n    int ret;\n    int is_priv;\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    /* Check if key is private or public */\n    is_priv =\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eN, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eD, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eE, 0 ) != 0;\n\n    if( !is_priv )\n    {\n        /* If we're trying to export private parameters for a public key,\n         * something must be wrong. */\n        if( P != NULL || Q != NULL || D != NULL )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    }\n\n    /* Export all requested core parameters. */\n\n    if( ( N != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( N, \u0026ctx-\u003eN ) ) != 0 ) ||\n        ( P != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( P, \u0026ctx-\u003eP ) ) != 0 ) ||\n        ( Q != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( Q, \u0026ctx-\u003eQ ) ) != 0 ) ||\n        ( D != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( D, \u0026ctx-\u003eD ) ) != 0 ) ||\n        ( E != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( E, \u0026ctx-\u003eE ) ) != 0 ) )\n    {\n        return( ret );\n    }\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":400,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"469234":{"score":0.742731,"function_name":"mbedtls_rsa_export_crt","code":"int mbedtls_rsa_export_crt( const mbedtls_rsa_context *ctx,\n                            mbedtls_mpi *DP, mbedtls_mpi *DQ, mbedtls_mpi *QP )\n{\n    int ret;\n    int is_priv;\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    /* Check if key is private or public */\n    is_priv =\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eN, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eD, 0 ) != 0 \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eE, 0 ) != 0;\n\n    if( !is_priv )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    /* Export all requested blinding parameters. */\n    if( ( DP != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( DP, \u0026ctx-\u003eDP ) ) != 0 ) ||\n        ( DQ != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( DQ, \u0026ctx-\u003eDQ ) ) != 0 ) ||\n        ( QP != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( QP, \u0026ctx-\u003eQP ) ) != 0 ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n    }\n#else\n    if( ( ret = mbedtls_rsa_deduce_crt( \u0026ctx-\u003eP, \u0026ctx-\u003eQ, \u0026ctx-\u003eD,\n                                        DP, DQ, QP ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":445,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"469528":{"score":0.7288312,"function_name":"mbedtls_rsa_init","code":"void mbedtls_rsa_init( mbedtls_rsa_context *ctx,\n               int padding,\n               int hash_id )\n{\n    RSA_VALIDATE( ctx != NULL );\n    RSA_VALIDATE( padding == MBEDTLS_RSA_PKCS_V15 ||\n                  padding == MBEDTLS_RSA_PKCS_V21 );\n\n    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );\n\n    mbedtls_rsa_set_padding( ctx, padding, hash_id );\n\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_init( \u0026ctx-\u003emutex );\n#endif\n}","filepath":"library/rsa.c","line_number":485,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"469655":{"score":0.7609917,"function_name":"mbedtls_rsa_check_pubkey","code":"int mbedtls_rsa_check_pubkey( const mbedtls_rsa_context *ctx )\n{\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n\n    if( mbedtls_mpi_bitlen( \u0026ctx-\u003eN ) \u003c 128 )\n    {\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    if( mbedtls_mpi_get_bit( \u0026ctx-\u003eE, 0 ) == 0 ||\n        mbedtls_mpi_bitlen( \u0026ctx-\u003eE )     \u003c 2  ||\n        mbedtls_mpi_cmp_mpi( \u0026ctx-\u003eE, \u0026ctx-\u003eN ) \u003e= 0 )\n    {\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":648,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"469825":{"score":0.8084286,"function_name":"mbedtls_rsa_check_privkey","code":"int mbedtls_rsa_check_privkey( const mbedtls_rsa_context *ctx )\n{\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||\n        rsa_check_context( ctx, 1 /* private */, 1 /* blinding */ ) != 0 )\n    {\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    if( mbedtls_rsa_validate_params( \u0026ctx-\u003eN, \u0026ctx-\u003eP, \u0026ctx-\u003eQ,\n                                     \u0026ctx-\u003eD, \u0026ctx-\u003eE, NULL, NULL ) != 0 )\n    {\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    else if( mbedtls_rsa_validate_crt( \u0026ctx-\u003eP, \u0026ctx-\u003eQ, \u0026ctx-\u003eD,\n                                       \u0026ctx-\u003eDP, \u0026ctx-\u003eDQ, \u0026ctx-\u003eQP ) != 0 )\n    {\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":673,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"470042":{"score":0.8644343,"function_name":"mbedtls_rsa_check_pub_priv","code":"int mbedtls_rsa_check_pub_priv( const mbedtls_rsa_context *pub,\n                                const mbedtls_rsa_context *prv )\n{\n    RSA_VALIDATE_RET( pub != NULL );\n    RSA_VALIDATE_RET( prv != NULL );\n\n    if( mbedtls_rsa_check_pubkey( pub )  != 0 ||\n        mbedtls_rsa_check_privkey( prv ) != 0 )\n    {\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    if( mbedtls_mpi_cmp_mpi( \u0026pub-\u003eN, \u0026prv-\u003eN ) != 0 ||\n        mbedtls_mpi_cmp_mpi( \u0026pub-\u003eE, \u0026prv-\u003eE ) != 0 )\n    {\n        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":703,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"470178":{"score":0.7301537,"function_name":"mbedtls_rsa_public","code":"int mbedtls_rsa_public( mbedtls_rsa_context *ctx,\n                const unsigned char *input,\n                unsigned char *output )\n{\n    int ret;\n    size_t olen;\n    mbedtls_mpi T;\n    RSA_VALIDATE_RET( ctx != NULL );\n    RSA_VALIDATE_RET( input != NULL );\n    RSA_VALIDATE_RET( output != NULL );\n\n    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    mbedtls_mpi_init( \u0026T );\n\n#if defined(MBEDTLS_THREADING_C)\n    if( ( ret = mbedtls_mutex_lock( \u0026ctx-\u003emutex ) ) != 0 )\n        return( ret );\n#endif\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026T, input, ctx-\u003elen ) );\n\n    if( mbedtls_mpi_cmp_mpi( \u0026T, \u0026ctx-\u003eN ) \u003e= 0 )\n    {\n        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    olen = ctx-\u003elen;\n    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026T, \u0026T, \u0026ctx-\u003eE, \u0026ctx-\u003eN, \u0026ctx-\u003eRN ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026T, output, olen ) );\n\ncleanup:\n#if defined(MBEDTLS_THREADING_C)\n    if( mbedtls_mutex_unlock( \u0026ctx-\u003emutex ) != 0 )\n        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );\n#endif\n\n    mbedtls_mpi_free( \u0026T );\n\n    if( ret != 0 )\n        return( MBEDTLS_ERR_RSA_PUBLIC_FAILED + ret );\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":727,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"470491":{"score":0.77755165,"function_name":"rsa_prepare_blinding","code":"static int rsa_prepare_blinding( mbedtls_rsa_context *ctx,\n                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    int ret, count = 0;\n\n    if( ctx-\u003eVf.p != NULL )\n    {\n        /* We already have blinding values, just update them by squaring */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026ctx-\u003eVi, \u0026ctx-\u003eVi, \u0026ctx-\u003eVi ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026ctx-\u003eVi, \u0026ctx-\u003eVi, \u0026ctx-\u003eN ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026ctx-\u003eVf, \u0026ctx-\u003eVf, \u0026ctx-\u003eVf ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026ctx-\u003eVf, \u0026ctx-\u003eVf, \u0026ctx-\u003eN ) );\n\n        goto cleanup;\n    }\n\n    /* Unblinding value: Vf = random number, invertible mod N */\n    do {\n        if( count++ \u003e 10 )\n            return( MBEDTLS_ERR_RSA_RNG_FAILED );\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( \u0026ctx-\u003eVf, ctx-\u003elen - 1, f_rng, p_rng ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( \u0026ctx-\u003eVi, \u0026ctx-\u003eVf, \u0026ctx-\u003eN ) );\n    } while( mbedtls_mpi_cmp_int( \u0026ctx-\u003eVi, 1 ) != 0 );\n\n    /* Blinding value: Vi =  Vf^(-e) mod N */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( \u0026ctx-\u003eVi, \u0026ctx-\u003eVf, \u0026ctx-\u003eN ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026ctx-\u003eVi, \u0026ctx-\u003eVi, \u0026ctx-\u003eE, \u0026ctx-\u003eN, \u0026ctx-\u003eRN ) );\n\n\ncleanup:\n    return( ret );\n}","filepath":"library/rsa.c","line_number":780,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"471023":{"score":0.71063936,"function_name":"mbedtls_rsa_private","code":"int mbedtls_rsa_private( mbedtls_rsa_context *ctx,\n                 int (*f_rng)(void *, unsigned char *, size_t),\n                 void *p_rng,\n                 const unsigned char *input,\n                 unsigned char *output )\n{\n    int ret;\n    size_t olen;\n\n    /* Temporary holding the result */\n    mbedtls_mpi T;\n\n    /* Temporaries holding P-1, Q-1 and the\n     * exponent blinding factor, respectively. */\n    mbedtls_mpi P1, Q1, R;\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    /* Temporaries holding the results mod p resp. mod q. */\n    mbedtls_mpi TP, TQ;\n\n    /* Temporaries holding the blinded exponents for\n     * the mod p resp. mod q computation (if used). */\n    mbedtls_mpi DP_blind, DQ_blind;\n\n    /* Pointers to actual exponents to be used - either the unblinded\n     * or the blinded ones, depending on the presence of a PRNG. */\n    mbedtls_mpi *DP = \u0026ctx-\u003eDP;\n    mbedtls_mpi *DQ = \u0026ctx-\u003eDQ;\n#else\n    /* Temporary holding the blinded exponent (if used). */\n    mbedtls_mpi D_blind;\n\n    /* Pointer to actual exponent to be used - either the unblinded\n     * or the blinded one, depending on the presence of a PRNG. */\n    mbedtls_mpi *D = \u0026ctx-\u003eD;\n#endif /* MBEDTLS_RSA_NO_CRT */\n\n    /* Temporaries holding the initial input and the double\n     * checked result; should be the same in the end. */\n    mbedtls_mpi I, C;\n\n    RSA_VALIDATE_RET( ctx != NULL );\n    RSA_VALIDATE_RET( input  != NULL );\n    RSA_VALIDATE_RET( output != NULL );\n\n    if( rsa_check_context( ctx, 1             /* private key checks */,\n                                f_rng != NULL /* blinding y/n       */ ) != 0 )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_THREADING_C)\n    if( ( ret = mbedtls_mutex_lock( \u0026ctx-\u003emutex ) ) != 0 )\n        return( ret );\n#endif\n\n    /* MPI Initialization */\n    mbedtls_mpi_init( \u0026T );\n\n    mbedtls_mpi_init( \u0026P1 );\n    mbedtls_mpi_init( \u0026Q1 );\n    mbedtls_mpi_init( \u0026R );\n\n    if( f_rng != NULL )\n    {\n#if defined(MBEDTLS_RSA_NO_CRT)\n        mbedtls_mpi_init( \u0026D_blind );\n#else\n        mbedtls_mpi_init( \u0026DP_blind );\n        mbedtls_mpi_init( \u0026DQ_blind );\n#endif\n    }\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    mbedtls_mpi_init( \u0026TP ); mbedtls_mpi_init( \u0026TQ );\n#endif\n\n    mbedtls_mpi_init( \u0026I );\n    mbedtls_mpi_init( \u0026C );\n\n    /* End of MPI initialization */\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026T, input, ctx-\u003elen ) );\n    if( mbedtls_mpi_cmp_mpi( \u0026T, \u0026ctx-\u003eN ) \u003e= 0 )\n    {\n        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026I, \u0026T ) );\n\n    if( f_rng != NULL )\n    {\n        /*\n         * Blinding\n         * T = T * Vi mod N\n         */\n        MBEDTLS_MPI_CHK( rsa_prepare_blinding( ctx, f_rng, p_rng ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026T, \u0026T, \u0026ctx-\u003eVi ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026T, \u0026T, \u0026ctx-\u003eN ) );\n\n        /*\n         * Exponent blinding\n         */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026P1, \u0026ctx-\u003eP, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026Q1, \u0026ctx-\u003eQ, 1 ) );\n\n#if defined(MBEDTLS_RSA_NO_CRT)\n        /*\n         * D_blind = ( P - 1 ) * ( Q - 1 ) * R + D\n         */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( \u0026R, RSA_EXPONENT_BLINDING,\n                         f_rng, p_rng ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026D_blind, \u0026P1, \u0026Q1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026D_blind, \u0026D_blind, \u0026R ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026D_blind, \u0026D_blind, \u0026ctx-\u003eD ) );\n\n        D = \u0026D_blind;\n#else\n        /*\n         * DP_blind = ( P - 1 ) * R + DP\n         */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( \u0026R, RSA_EXPONENT_BLINDING,\n                         f_rng, p_rng ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026DP_blind, \u0026P1, \u0026R ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026DP_blind, \u0026DP_blind,\n                    \u0026ctx-\u003eDP ) );\n\n        DP = \u0026DP_blind;\n\n        /*\n         * DQ_blind = ( Q - 1 ) * R + DQ\n         */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( \u0026R, RSA_EXPONENT_BLINDING,\n                         f_rng, p_rng ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026DQ_blind, \u0026Q1, \u0026R ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026DQ_blind, \u0026DQ_blind,\n                    \u0026ctx-\u003eDQ ) );\n\n        DQ = \u0026DQ_blind;\n#endif /* MBEDTLS_RSA_NO_CRT */\n    }\n\n#if defined(MBEDTLS_RSA_NO_CRT)\n    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026T, \u0026T, D, \u0026ctx-\u003eN, \u0026ctx-\u003eRN ) );\n#else\n    /*\n     * Faster decryption using the CRT\n     *\n     * TP = input ^ dP mod P\n     * TQ = input ^ dQ mod Q\n     */\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026TP, \u0026T, DP, \u0026ctx-\u003eP, \u0026ctx-\u003eRP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026TQ, \u0026T, DQ, \u0026ctx-\u003eQ, \u0026ctx-\u003eRQ ) );\n\n    /*\n     * T = (TP - TQ) * (Q^-1 mod P) mod P\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026T, \u0026TP, \u0026TQ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026TP, \u0026T, \u0026ctx-\u003eQP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026T, \u0026TP, \u0026ctx-\u003eP ) );\n\n    /*\n     * T = TQ + T * Q\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026TP, \u0026T, \u0026ctx-\u003eQ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026T, \u0026TQ, \u0026TP ) );\n#endif /* MBEDTLS_RSA_NO_CRT */\n\n    if( f_rng != NULL )\n    {\n        /*\n         * Unblind\n         * T = T * Vf mod N\n         */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026T, \u0026T, \u0026ctx-\u003eVf ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026T, \u0026T, \u0026ctx-\u003eN ) );\n    }\n\n    /* Verify the result to prevent glitching attacks. */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026C, \u0026T, \u0026ctx-\u003eE,\n                                          \u0026ctx-\u003eN, \u0026ctx-\u003eRN ) );\n    if( mbedtls_mpi_cmp_mpi( \u0026C, \u0026I ) != 0 )\n    {\n        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;\n        goto cleanup;\n    }\n\n    olen = ctx-\u003elen;\n    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026T, output, olen ) );\n\ncleanup:\n#if defined(MBEDTLS_THREADING_C)\n    if( mbedtls_mutex_unlock( \u0026ctx-\u003emutex ) != 0 )\n        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );\n#endif\n\n    mbedtls_mpi_free( \u0026P1 );\n    mbedtls_mpi_free( \u0026Q1 );\n    mbedtls_mpi_free( \u0026R );\n\n    if( f_rng != NULL )\n    {\n#if defined(MBEDTLS_RSA_NO_CRT)\n        mbedtls_mpi_free( \u0026D_blind );\n#else\n        mbedtls_mpi_free( \u0026DP_blind );\n        mbedtls_mpi_free( \u0026DQ_blind );\n#endif\n    }\n\n    mbedtls_mpi_free( \u0026T );\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    mbedtls_mpi_free( \u0026TP ); mbedtls_mpi_free( \u0026TQ );\n#endif\n\n    mbedtls_mpi_free( \u0026C );\n    mbedtls_mpi_free( \u0026I );\n\n    if( ret != 0 )\n        return( MBEDTLS_ERR_RSA_PRIVATE_FAILED + ret );\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":838,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"472974":{"score":0.8245071,"function_name":"mbedtls_rsa_rsaes_pkcs1_v15_encrypt","code":"int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,\n                                 int (*f_rng)(void *, unsigned char *, size_t),\n                                 void *p_rng,\n                                 int mode, size_t ilen,\n                                 const unsigned char *input,\n                                 unsigned char *output )\n{\n    size_t nb_pad, olen;\n    int ret;\n    unsigned char *p = output;\n\n    if( mode == MBEDTLS_RSA_PRIVATE \u0026\u0026 ctx-\u003epadding != MBEDTLS_RSA_PKCS_V15 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    if( f_rng == NULL )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    olen = ctx-\u003elen;\n\n    if( olen \u003c ilen + 11 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    nb_pad = olen - 3 - ilen;\n\n    *p++ = 0;\n    if( mode == MBEDTLS_RSA_PUBLIC )\n    {\n        *p++ = MBEDTLS_RSA_CRYPT;\n\n        while( nb_pad-- \u003e 0 )\n        {\n            int rng_dl = 100;\n\n            do {\n                ret = f_rng( p_rng, p, 1 );\n            } while( *p == 0 \u0026\u0026 --rng_dl \u0026\u0026 ret == 0 );\n\n            // Check if RNG failed to generate data\n            //\n            if( rng_dl == 0 || ret != 0 )\n                return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );\n\n            p++;\n        }\n    }\n    else\n    {\n        *p++ = MBEDTLS_RSA_SIGN;\n\n        while( nb_pad-- \u003e 0 )\n            *p++ = 0xFF;\n    }\n\n    *p++ = 0;\n    memcpy( p, input, ilen );\n\n    return( ( mode == MBEDTLS_RSA_PUBLIC )\n            ? mbedtls_rsa_public(  ctx, output, output )\n            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );\n}","filepath":"library/rsa.c","line_number":601,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"beta-oob-2"},"473526":{"score":0.87325656,"function_name":"mem_move_to_left","code":"static void mem_move_to_left( void *start,\n                              size_t total,\n                              size_t offset )\n{\n    volatile unsigned char *buf = start;\n    size_t i, n;\n    if( total == 0 )\n        return;\n    for( i = 0; i \u003c total; i++ )\n    {\n        unsigned no_op = size_greater_than( total - offset, i );\n        /* The first `total - offset` passes are a no-op. The last\n         * `offset` passes shift the data one byte to the left and\n         * zero out the last byte. */\n        for( n = 0; n \u003c total - 1; n++ )\n        {\n            unsigned char current = buf[n];\n            unsigned char next = buf[n+1];\n            buf[n] = if_int( no_op, current, next );\n        }\n        buf[total-1] = if_int( no_op, buf[total-1], 0 );\n    }\n}","filepath":"library/rsa.c","line_number":1532,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"473750":{"score":0.8355886,"function_name":"mbedtls_rsa_rsaes_pkcs1_v15_decrypt","code":"int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,\n                                 int (*f_rng)(void *, unsigned char *, size_t),\n                                 void *p_rng,\n                                 int mode, size_t *olen,\n                                 const unsigned char *input,\n                                 unsigned char *output,\n                                 size_t output_max_len )\n{\n    int ret;\n    size_t ilen, i, plaintext_max_size;\n    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];\n    /* The following variables take sensitive values: their value must\n     * not leak into the observable behavior of the function other than\n     * the designated outputs (output, olen, return value). Otherwise\n     * this would open the execution of the function to\n     * side-channel-based variants of the Bleichenbacher padding oracle\n     * attack. Potential side channels include overall timing, memory\n     * access patterns (especially visible to an adversary who has access\n     * to a shared memory cache), and branches (especially visible to\n     * an adversary who has access to a shared code cache or to a shared\n     * branch predictor). */\n    size_t pad_count = 0;\n    unsigned bad = 0;\n    unsigned char pad_done = 0;\n    size_t plaintext_size = 0;\n    unsigned output_too_large;\n\n    RSA_VALIDATE_RET( ctx != NULL );\n    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||\n                      mode == MBEDTLS_RSA_PUBLIC );\n    RSA_VALIDATE_RET( output_max_len == 0 || output != NULL );\n    RSA_VALIDATE_RET( input != NULL );\n    RSA_VALIDATE_RET( olen != NULL );\n\n    ilen = ctx-\u003elen;\n    plaintext_max_size = ( output_max_len \u003e ilen - 11 ?\n                           ilen - 11 :\n                           output_max_len );\n\n    if( mode == MBEDTLS_RSA_PRIVATE \u0026\u0026 ctx-\u003epadding != MBEDTLS_RSA_PKCS_V15 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    if( ilen \u003c 16 || ilen \u003e sizeof( buf ) )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    ret = ( mode == MBEDTLS_RSA_PUBLIC )\n          ? mbedtls_rsa_public(  ctx, input, buf )\n          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );\n\n    if( ret != 0 )\n        goto cleanup;\n\n    /* Check and get padding length in constant time and constant\n     * memory trace. The first byte must be 0. */\n    bad |= buf[0];\n\n    if( mode == MBEDTLS_RSA_PRIVATE )\n    {\n        /* Decode EME-PKCS1-v1_5 padding: 0x00 || 0x02 || PS || 0x00\n         * where PS must be at least 8 nonzero bytes. */\n        bad |= buf[1] ^ MBEDTLS_RSA_CRYPT;\n\n        /* Read the whole buffer. Set pad_done to nonzero if we find\n         * the 0x00 byte and remember the padding length in pad_count. */\n        for( i = 2; i \u003c ilen; i++ )\n        {\n            pad_done  |= ((buf[i] | (unsigned char)-buf[i]) \u003e\u003e 7) ^ 1;\n            pad_count += ((pad_done | (unsigned char)-pad_done) \u003e\u003e 7) ^ 1;\n        }\n    }\n    else\n    {\n        /* Decode EMSA-PKCS1-v1_5 padding: 0x00 || 0x01 || PS || 0x00\n         * where PS must be at least 8 bytes with the value 0xFF. */\n        bad |= buf[1] ^ MBEDTLS_RSA_SIGN;\n\n        /* Read the whole buffer. Set pad_done to nonzero if we find\n         * the 0x00 byte and remember the padding length in pad_count.\n         * If there's a non-0xff byte in the padding, the padding is bad. */\n        for( i = 2; i \u003c ilen; i++ )\n        {\n            pad_done |= if_int( buf[i], 0, 1 );\n            pad_count += if_int( pad_done, 0, 1 );\n            bad |= if_int( pad_done, 0, buf[i] ^ 0xFF );\n        }\n    }\n\n    /* If pad_done is still zero, there's no data, only unfinished padding. */\n    bad |= if_int( pad_done, 0, 1 );\n\n    /* There must be at least 8 bytes of padding. */\n    bad |= size_greater_than( 8, pad_count );\n\n    /* If the padding is valid, set plaintext_size to the number of\n     * remaining bytes after stripping the padding. If the padding\n     * is invalid, avoid leaking this fact through the size of the\n     * output: use the maximum message size that fits in the output\n     * buffer. Do it without branches to avoid leaking the padding\n     * validity through timing. RSA keys are small enough that all the\n     * size_t values involved fit in unsigned int. */\n    plaintext_size = if_int( bad,\n                             (unsigned) plaintext_max_size,\n                             (unsigned) ( ilen - pad_count - 3 ) );\n\n    /* Set output_too_large to 0 if the plaintext fits in the output\n     * buffer and to 1 otherwise. */\n    output_too_large = size_greater_than( plaintext_size,\n                                          plaintext_max_size );\n\n    /* Set ret without branches to avoid timing attacks. Return:\n     * - INVALID_PADDING if the padding is bad (bad != 0).\n     * - OUTPUT_TOO_LARGE if the padding is good but the decrypted\n     *   plaintext does not fit in the output buffer.\n     * - 0 if the padding is correct. */\n    ret = - (int) if_int( bad, - MBEDTLS_ERR_RSA_INVALID_PADDING,\n                  if_int( output_too_large, - MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE,\n                          0 ) );\n\n    /* If the padding is bad or the plaintext is too large, zero the\n     * data that we're about to copy to the output buffer.\n     * We need to copy the same amount of data\n     * from the same buffer whether the padding is good or not to\n     * avoid leaking the padding validity through overall timing or\n     * through memory or cache access patterns. */\n    bad = all_or_nothing_int( bad | output_too_large );\n    for( i = 11; i \u003c ilen; i++ )\n        buf[i] \u0026= ~bad;\n\n    /* If the plaintext is too large, truncate it to the buffer size.\n     * Copy anyway to avoid revealing the length through timing, because\n     * revealing the length is as bad as revealing the padding validity\n     * for a Bleichenbacher attack. */\n    plaintext_size = if_int( output_too_large,\n                             (unsigned) plaintext_max_size,\n                             (unsigned) plaintext_size );\n\n    /* Move the plaintext to the leftmost position where it can start in\n     * the working buffer, i.e. make it start plaintext_max_size from\n     * the end of the buffer. Do this with a memory access trace that\n     * does not depend on the plaintext size. After this move, the\n     * starting location of the plaintext is no longer sensitive\n     * information. */\n    mem_move_to_left( buf + ilen - plaintext_max_size,\n                      plaintext_max_size,\n                      plaintext_max_size - plaintext_size );\n\n    /* Finally copy the decrypted plaintext plus trailing zeros\n     * into the output buffer. */\n    memcpy( output, buf + ilen - plaintext_max_size, plaintext_max_size );\n\n    /* Report the amount of data we copied to the output buffer. In case\n     * of errors (bad padding or output too large), the value of *olen\n     * when this function returns is not specified. Making it equivalent\n     * to the good case limits the risks of leaking the padding validity. */\n    *olen = plaintext_size;\n\ncleanup:\n    mbedtls_platform_zeroize( buf, sizeof( buf ) );\n\n    return( ret );\n}","filepath":"library/rsa.c","line_number":1559,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"474972":{"score":0.7230735,"function_name":"rsa_rsassa_pkcs1_v15_encode","code":"static int rsa_rsassa_pkcs1_v15_encode( mbedtls_md_type_t md_alg,\n                                        unsigned int hashlen,\n                                        const unsigned char *hash,\n                                        size_t dst_len,\n                                        unsigned char *dst )\n{\n    size_t oid_size  = 0;\n    size_t nb_pad    = dst_len;\n    unsigned char *p = dst;\n    const char *oid  = NULL;\n\n    /* Are we signing hashed or raw data? */\n    if( md_alg != MBEDTLS_MD_NONE )\n    {\n        const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );\n        if( md_info == NULL )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n        if( mbedtls_oid_get_oid_by_md( md_alg, \u0026oid, \u0026oid_size ) != 0 )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n        hashlen = mbedtls_md_get_size( md_info );\n\n        /* Double-check that 8 + hashlen + oid_size can be used as a\n         * 1-byte ASN.1 length encoding and that there's no overflow. */\n        if( 8 + hashlen + oid_size  \u003e= 0x80         ||\n            10 + hashlen            \u003c  hashlen      ||\n            10 + hashlen + oid_size \u003c  10 + hashlen )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n        /*\n         * Static bounds check:\n         * - Need 10 bytes for five tag-length pairs.\n         *   (Insist on 1-byte length encodings to protect against variants of\n         *    Bleichenbacher's forgery attack against lax PKCS#1v1.5 verification)\n         * - Need hashlen bytes for hash\n         * - Need oid_size bytes for hash alg OID.\n         */\n        if( nb_pad \u003c 10 + hashlen + oid_size )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n        nb_pad -= 10 + hashlen + oid_size;\n    }\n    else\n    {\n        if( nb_pad \u003c hashlen )\n            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n        nb_pad -= hashlen;\n    }\n\n    /* Need space for signature header and padding delimiter (3 bytes),\n     * and 8 bytes for the minimal padding */\n    if( nb_pad \u003c 3 + 8 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    nb_pad -= 3;\n\n    /* Now nb_pad is the amount of memory to be filled\n     * with padding, and at least 8 bytes long. */\n\n    /* Write signature header and padding */\n    *p++ = 0;\n    *p++ = MBEDTLS_RSA_SIGN;\n    memset( p, 0xFF, nb_pad );\n    p += nb_pad;\n    *p++ = 0;\n\n    /* Are we signing raw data? */\n    if( md_alg == MBEDTLS_MD_NONE )\n    {\n        memcpy( p, hash, hashlen );\n        return( 0 );\n    }\n\n    /* Signing hashed data, add corresponding ASN.1 structure\n     *\n     * DigestInfo ::= SEQUENCE {\n     *   digestAlgorithm DigestAlgorithmIdentifier,\n     *   digest Digest }\n     * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n     * Digest ::= OCTET STRING\n     *\n     * Schematic:\n     * TAG-SEQ + LEN [ TAG-SEQ + LEN [ TAG-OID  + LEN [ OID  ]\n     *                                 TAG-NULL + LEN [ NULL ] ]\n     *                 TAG-OCTET + LEN [ HASH ] ]\n     */\n    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;\n    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );\n    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;\n    *p++ = (unsigned char)( 0x04 + oid_size );\n    *p++ = MBEDTLS_ASN1_OID;\n    *p++ = (unsigned char) oid_size;\n    memcpy( p, oid, oid_size );\n    p += oid_size;\n    *p++ = MBEDTLS_ASN1_NULL;\n    *p++ = 0x00;\n    *p++ = MBEDTLS_ASN1_OCTET_STRING;\n    *p++ = (unsigned char) hashlen;\n    memcpy( p, hash, hashlen );\n    p += hashlen;\n\n    /* Just a sanity-check, should be automatic\n     * after the initial bounds check. */\n    if( p != dst + dst_len )\n    {\n        mbedtls_platform_zeroize( dst, dst_len );\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":1908,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"475646":{"score":0.7467537,"function_name":"mbedtls_rsa_rsassa_pkcs1_v15_sign","code":"int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,\n                               int (*f_rng)(void *, unsigned char *, size_t),\n                               void *p_rng,\n                               int mode,\n                               mbedtls_md_type_t md_alg,\n                               unsigned int hashlen,\n                               const unsigned char *hash,\n                               unsigned char *sig )\n{\n    int ret;\n    unsigned char *sig_try = NULL, *verif = NULL;\n\n    if( mode == MBEDTLS_RSA_PRIVATE \u0026\u0026 ctx-\u003epadding != MBEDTLS_RSA_PKCS_V15 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    /*\n     * Prepare PKCS1-v1.5 encoding (padding and hash identifier)\n     */\n\n    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash,\n                                             ctx-\u003elen, sig ) ) != 0 )\n        return( ret );\n\n    /*\n     * Call respective RSA primitive\n     */\n\n    if( mode == MBEDTLS_RSA_PUBLIC )\n    {\n        /* Skip verification on a public key operation */\n        return( mbedtls_rsa_public( ctx, sig, sig ) );\n    }\n\n    /* Private key operation\n     *\n     * In order to prevent Lenstra's attack, make the signature in a\n     * temporary buffer and check it before returning it.\n     */\n\n    sig_try = mbedtls_calloc( 1, ctx-\u003elen );\n    if( sig_try == NULL )\n        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n\n    verif = mbedtls_calloc( 1, ctx-\u003elen );\n    if( verif == NULL )\n    {\n        mbedtls_free( sig_try );\n        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );\n    MBEDTLS_MPI_CHK( mbedtls_rsa_public( ctx, sig_try, verif ) );\n\n    if( mbedtls_safer_memcmp( verif, sig, ctx-\u003elen ) != 0 )\n    {\n        ret = MBEDTLS_ERR_RSA_PRIVATE_FAILED;\n        goto cleanup;\n    }\n\n    memcpy( sig, sig_try, ctx-\u003elen );\n\ncleanup:\n    mbedtls_free( sig_try );\n    mbedtls_free( verif );\n\n    return( ret );\n}","filepath":"library/rsa.c","line_number":1949,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.7.18"},"476114":{"score":0.7447858,"function_name":"mbedtls_rsa_rsassa_pkcs1_v15_sign","code":"int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,\n                               int (*f_rng)(void *, unsigned char *, size_t),\n                               void *p_rng,\n                               int mode,\n                               mbedtls_md_type_t md_alg,\n                               unsigned int hashlen,\n                               const unsigned char *hash,\n                               unsigned char *sig )\n{\n    int ret;\n    unsigned char *sig_try = NULL, *verif = NULL;\n\n    RSA_VALIDATE_RET( ctx != NULL );\n    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||\n                      mode == MBEDTLS_RSA_PUBLIC );\n    RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE \u0026\u0026\n                        hashlen == 0 ) ||\n                      hash != NULL );\n    RSA_VALIDATE_RET( sig != NULL );\n\n    if( mode == MBEDTLS_RSA_PRIVATE \u0026\u0026 ctx-\u003epadding != MBEDTLS_RSA_PKCS_V15 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n    /*\n     * Prepare PKCS1-v1.5 encoding (padding and hash identifier)\n     */\n\n    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash,\n                                             ctx-\u003elen, sig ) ) != 0 )\n        return( ret );\n\n    /*\n     * Call respective RSA primitive\n     */\n\n    if( mode == MBEDTLS_RSA_PUBLIC )\n    {\n        /* Skip verification on a public key operation */\n        return( mbedtls_rsa_public( ctx, sig, sig ) );\n    }\n\n    /* Private key operation\n     *\n     * In order to prevent Lenstra's attack, make the signature in a\n     * temporary buffer and check it before returning it.\n     */\n\n    sig_try = mbedtls_calloc( 1, ctx-\u003elen );\n    if( sig_try == NULL )\n        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n\n    verif = mbedtls_calloc( 1, ctx-\u003elen );\n    if( verif == NULL )\n    {\n        mbedtls_free( sig_try );\n        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );\n    MBEDTLS_MPI_CHK( mbedtls_rsa_public( ctx, sig_try, verif ) );\n\n    if( mbedtls_safer_memcmp( verif, sig, ctx-\u003elen ) != 0 )\n    {\n        ret = MBEDTLS_ERR_RSA_PRIVATE_FAILED;\n        goto cleanup;\n    }\n\n    memcpy( sig, sig_try, ctx-\u003elen );\n\ncleanup:\n    mbedtls_free( sig_try );\n    mbedtls_free( verif );\n\n    return( ret );\n}","filepath":"library/rsa.c","line_number":2023,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"476548":{"score":0.88243026,"function_name":"mbedtls_rsa_copy","code":"int mbedtls_rsa_copy( mbedtls_rsa_context *dst, const mbedtls_rsa_context *src )\n{\n    int ret;\n    RSA_VALIDATE_RET( dst != NULL );\n    RSA_VALIDATE_RET( src != NULL );\n\n    dst-\u003ever = src-\u003ever;\n    dst-\u003elen = src-\u003elen;\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eN, \u0026src-\u003eN ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eE, \u0026src-\u003eE ) );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eD, \u0026src-\u003eD ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eP, \u0026src-\u003eP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eQ, \u0026src-\u003eQ ) );\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eDP, \u0026src-\u003eDP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eDQ, \u0026src-\u003eDQ ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eQP, \u0026src-\u003eQP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eRP, \u0026src-\u003eRP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eRQ, \u0026src-\u003eRQ ) );\n#endif\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eRN, \u0026src-\u003eRN ) );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eVi, \u0026src-\u003eVi ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026dst-\u003eVf, \u0026src-\u003eVf ) );\n\n    dst-\u003epadding = src-\u003epadding;\n    dst-\u003ehash_id = src-\u003ehash_id;\n\ncleanup:\n    if( ret != 0 )\n        mbedtls_rsa_free( dst );\n\n    return( ret );\n}","filepath":"library/rsa.c","line_number":2449,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"477190":{"score":0.80860794,"function_name":"mbedtls_rsa_free","code":"void mbedtls_rsa_free( mbedtls_rsa_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n    mbedtls_mpi_free( \u0026ctx-\u003eVi );\n    mbedtls_mpi_free( \u0026ctx-\u003eVf );\n    mbedtls_mpi_free( \u0026ctx-\u003eRN );\n    mbedtls_mpi_free( \u0026ctx-\u003eD  );\n    mbedtls_mpi_free( \u0026ctx-\u003eQ  );\n    mbedtls_mpi_free( \u0026ctx-\u003eP  );\n    mbedtls_mpi_free( \u0026ctx-\u003eE  );\n    mbedtls_mpi_free( \u0026ctx-\u003eN  );\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    mbedtls_mpi_free( \u0026ctx-\u003eRQ );\n    mbedtls_mpi_free( \u0026ctx-\u003eRP );\n    mbedtls_mpi_free( \u0026ctx-\u003eQP );\n    mbedtls_mpi_free( \u0026ctx-\u003eDQ );\n    mbedtls_mpi_free( \u0026ctx-\u003eDP );\n#endif /* MBEDTLS_RSA_NO_CRT */\n\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_free( \u0026ctx-\u003emutex );\n#endif\n}","filepath":"library/rsa.c","line_number":2491,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.5"},"477468":{"score":0.7916211,"function_name":"mbedtls_rsa_deduce_primes","code":"int mbedtls_rsa_deduce_primes( mbedtls_mpi const *N,\n                     mbedtls_mpi const *E, mbedtls_mpi const *D,\n                     mbedtls_mpi *P, mbedtls_mpi *Q )\n{\n    int ret = 0;\n\n    uint16_t attempt;  /* Number of current attempt  */\n    uint16_t iter;     /* Number of squares computed in the current attempt */\n\n    uint16_t order;    /* Order of 2 in DE - 1 */\n\n    mbedtls_mpi T;  /* Holds largest odd divisor of DE - 1     */\n    mbedtls_mpi K;  /* Temporary holding the current candidate */\n\n    const unsigned char primes[] = { 2,\n           3,    5,    7,   11,   13,   17,   19,   23,\n          29,   31,   37,   41,   43,   47,   53,   59,\n          61,   67,   71,   73,   79,   83,   89,   97,\n         101,  103,  107,  109,  113,  127,  131,  137,\n         139,  149,  151,  157,  163,  167,  173,  179,\n         181,  191,  193,  197,  199,  211,  223,  227,\n         229,  233,  239,  241,  251\n    };\n\n    const size_t num_primes = sizeof( primes ) / sizeof( *primes );\n\n    if( P == NULL || Q == NULL || P-\u003ep != NULL || Q-\u003ep != NULL )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    if( mbedtls_mpi_cmp_int( N, 0 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_int( D, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_mpi( D, N ) \u003e= 0 ||\n        mbedtls_mpi_cmp_int( E, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_mpi( E, N ) \u003e= 0 )\n    {\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n    }\n\n    /*\n     * Initializations and temporary changes\n     */\n\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026T );\n\n    /* T := DE - 1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026T, D,  E ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026T, \u0026T, 1 ) );\n\n    if( ( order = (uint16_t) mbedtls_mpi_lsb( \u0026T ) ) == 0 )\n    {\n        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    /* After this operation, T holds the largest odd divisor of DE - 1. */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026T, order ) );\n\n    /*\n     * Actual work\n     */\n\n    /* Skip trying 2 if N == 1 mod 8 */\n    attempt = 0;\n    if( N-\u003ep[0] % 8 == 1 )\n        attempt = 1;\n\n    for( ; attempt \u003c num_primes; ++attempt )\n    {\n        mbedtls_mpi_lset( \u0026K, primes[attempt] );\n\n        /* Check if gcd(K,N) = 1 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, \u0026K, N ) );\n        if( mbedtls_mpi_cmp_int( P, 1 ) != 0 )\n            continue;\n\n        /* Go through K^T + 1, K^(2T) + 1, K^(4T) + 1, ...\n         * and check whether they have nontrivial GCD with N. */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026K, \u0026K, \u0026T, N,\n                             Q /* temporarily use Q for storing Montgomery\n                                * multiplication helper values */ ) );\n\n        for( iter = 1; iter \u003c= order; ++iter )\n        {\n            /* If we reach 1 prematurely, there's no point\n             * in continuing to square K */\n            if( mbedtls_mpi_cmp_int( \u0026K, 1 ) == 0 )\n                break;\n\n            MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( \u0026K, \u0026K, 1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, \u0026K, N ) );\n\n            if( mbedtls_mpi_cmp_int( P, 1 ) ==  1 \u0026\u0026\n                mbedtls_mpi_cmp_mpi( P, N ) == -1 )\n            {\n                /*\n                 * Have found a nontrivial divisor P of N.\n                 * Set Q := N / P.\n                 */\n\n                MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( Q, NULL, N, P ) );\n                goto cleanup;\n            }\n\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, \u0026K, \u0026K ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, N ) );\n        }\n\n        /*\n         * If we get here, then either we prematurely aborted the loop because\n         * we reached 1, or K holds primes[attempt]^(DE - 1) mod N, which must\n         * be 1 if D,E,N were consistent.\n         * Check if that's the case and abort if not, to avoid very long,\n         * yet eventually failing, computations if N,D,E were not sane.\n         */\n        if( mbedtls_mpi_cmp_int( \u0026K, 1 ) != 0 )\n        {\n            break;\n        }\n    }\n\n    ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026T );\n    return( ret );\n}","filepath":"library/rsa_alt_helpers.c","line_number":62,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"478740":{"score":0.785951,"function_name":"mbedtls_rsa_deduce_private_exponent","code":"int mbedtls_rsa_deduce_private_exponent( mbedtls_mpi const *P,\n                                         mbedtls_mpi const *Q,\n                                         mbedtls_mpi const *E,\n                                         mbedtls_mpi *D )\n{\n    int ret = 0;\n    mbedtls_mpi K, L;\n\n    if( D == NULL || mbedtls_mpi_cmp_int( D, 0 ) != 0 )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    if( mbedtls_mpi_cmp_int( P, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_int( Q, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_int( E, 0 ) == 0 )\n    {\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n    }\n\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026L );\n\n    /* Temporarily put K := P-1 and L := Q-1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, P, 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026L, Q, 1 ) );\n\n    /* Temporarily put D := gcd(P-1, Q-1) */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( D, \u0026K, \u0026L ) );\n\n    /* K := LCM(P-1, Q-1) */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, \u0026K, \u0026L ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( \u0026K, NULL, \u0026K, D ) );\n\n    /* Compute modular inverse of E in LCM(P-1, Q-1) */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( D, E, \u0026K ) );\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026L );\n\n    return( ret );\n}","filepath":"library/rsa_alt_helpers.c","line_number":197,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"479189":{"score":0.794031,"function_name":"mbedtls_rsa_validate_crt","code":"int mbedtls_rsa_validate_crt( const mbedtls_mpi *P,  const mbedtls_mpi *Q,\n                              const mbedtls_mpi *D,  const mbedtls_mpi *DP,\n                              const mbedtls_mpi *DQ, const mbedtls_mpi *QP )\n{\n    int ret = 0;\n\n    mbedtls_mpi K, L;\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026L );\n\n    /* Check that DP - D == 0 mod P - 1 */\n    if( DP != NULL )\n    {\n        if( P == NULL )\n        {\n            ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;\n            goto cleanup;\n        }\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, P, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026L, DP, D ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026L, \u0026L, \u0026K ) );\n\n        if( mbedtls_mpi_cmp_int( \u0026L, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /* Check that DQ - D == 0 mod Q - 1 */\n    if( DQ != NULL )\n    {\n        if( Q == NULL )\n        {\n            ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;\n            goto cleanup;\n        }\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, Q, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026L, DQ, D ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026L, \u0026L, \u0026K ) );\n\n        if( mbedtls_mpi_cmp_int( \u0026L, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /* Check that QP * Q - 1 == 0 mod P */\n    if( QP != NULL )\n    {\n        if( P == NULL || Q == NULL )\n        {\n            ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;\n            goto cleanup;\n        }\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, QP, Q ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, P ) );\n        if( mbedtls_mpi_cmp_int( \u0026K, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\ncleanup:\n\n    /* Wrap MPI error codes by RSA check failure error code */\n    if( ret != 0 \u0026\u0026\n        ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED \u0026\u0026\n        ret != MBEDTLS_ERR_RSA_BAD_INPUT_DATA )\n    {\n        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n    }\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026L );\n\n    return( ret );\n}","filepath":"library/rsa_alt_helpers.c","line_number":401,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"479888":{"score":0.7891478,"function_name":"mbedtls_rsa_validate_params","code":"int mbedtls_rsa_validate_params( const mbedtls_mpi *N, const mbedtls_mpi *P,\n                                 const mbedtls_mpi *Q, const mbedtls_mpi *D,\n                                 const mbedtls_mpi *E,\n                                 int (*f_rng)(void *, unsigned char *, size_t),\n                                 void *p_rng )\n{\n    int ret = 0;\n    mbedtls_mpi K, L;\n\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026L );\n\n    /*\n     * Step 1: If PRNG provided, check that P and Q are prime\n     */\n\n#if defined(MBEDTLS_GENPRIME)\n    /*\n     * When generating keys, the strongest security we support aims for an error\n     * rate of at most 2^-100 and we are aiming for the same certainty here as\n     * well.\n     */\n    if( f_rng != NULL \u0026\u0026 P != NULL \u0026\u0026\n        ( ret = mbedtls_mpi_is_prime_ext( P, 50, f_rng, p_rng ) ) != 0 )\n    {\n        ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n        goto cleanup;\n    }\n\n    if( f_rng != NULL \u0026\u0026 Q != NULL \u0026\u0026\n        ( ret = mbedtls_mpi_is_prime_ext( Q, 50, f_rng, p_rng ) ) != 0 )\n    {\n        ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n        goto cleanup;\n    }\n#else\n    ((void) f_rng);\n    ((void) p_rng);\n#endif /* MBEDTLS_GENPRIME */\n\n    /*\n     * Step 2: Check that 1 \u003c N = P * Q\n     */\n\n    if( P != NULL \u0026\u0026 Q != NULL \u0026\u0026 N != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, P, Q ) );\n        if( mbedtls_mpi_cmp_int( N, 1 )  \u003c= 0 ||\n            mbedtls_mpi_cmp_mpi( \u0026K, N ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /*\n     * Step 3: Check and 1 \u003c D, E \u003c N if present.\n     */\n\n    if( N != NULL \u0026\u0026 D != NULL \u0026\u0026 E != NULL )\n    {\n        if ( mbedtls_mpi_cmp_int( D, 1 ) \u003c= 0 ||\n             mbedtls_mpi_cmp_int( E, 1 ) \u003c= 0 ||\n             mbedtls_mpi_cmp_mpi( D, N ) \u003e= 0 ||\n             mbedtls_mpi_cmp_mpi( E, N ) \u003e= 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /*\n     * Step 4: Check that D, E are inverse modulo P-1 and Q-1\n     */\n\n    if( P != NULL \u0026\u0026 Q != NULL \u0026\u0026 D != NULL \u0026\u0026 E != NULL )\n    {\n        if( mbedtls_mpi_cmp_int( P, 1 ) \u003c= 0 ||\n            mbedtls_mpi_cmp_int( Q, 1 ) \u003c= 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n\n        /* Compute DE-1 mod P-1 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, D, E ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026L, P, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, \u0026L ) );\n        if( mbedtls_mpi_cmp_int( \u0026K, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n\n        /* Compute DE-1 mod Q-1 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, D, E ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026L, Q, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, \u0026L ) );\n        if( mbedtls_mpi_cmp_int( \u0026K, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026L );\n\n    /* Wrap MPI error codes by RSA check failure error code */\n    if( ret != 0 \u0026\u0026 ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED )\n    {\n        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n    }\n\n    return( ret );\n}","filepath":"library/rsa_alt_helpers.c","line_number":277,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"480736":{"score":0.732367,"function_name":"mbedtls_rsa_deduce_crt","code":"int mbedtls_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *Q,\n                            const mbedtls_mpi *D, mbedtls_mpi *DP,\n                            mbedtls_mpi *DQ, mbedtls_mpi *QP )\n{\n    int ret = 0;\n    mbedtls_mpi K;\n    mbedtls_mpi_init( \u0026K );\n\n    /* DP = D mod P-1 */\n    if( DP != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, P, 1  ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, \u0026K ) );\n    }\n\n    /* DQ = D mod Q-1 */\n    if( DQ != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, Q, 1  ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, \u0026K ) );\n    }\n\n    /* QP = Q^{-1} mod P */\n    if( QP != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );\n    }\n\ncleanup:\n    mbedtls_mpi_free( \u0026K );\n\n    return( ret );\n}","filepath":"library/rsa_alt_helpers.c","line_number":240,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v3.0.0"},"481180":{"score":0.89327073,"function_name":"mbedtls_sha1_starts_ret","code":"int mbedtls_sha1_starts_ret( mbedtls_sha1_context *ctx )\n{\n    ctx-\u003etotal[0] = 0;\n    ctx-\u003etotal[1] = 0;\n\n    ctx-\u003estate[0] = 0x67452301;\n    ctx-\u003estate[1] = 0xEFCDAB89;\n    ctx-\u003estate[2] = 0x98BADCFE;\n    ctx-\u003estate[3] = 0x10325476;\n    ctx-\u003estate[4] = 0xC3D2E1F0;\n\n    return( 0 );\n}","filepath":"dll/3rdparty/mbedtls/sha1.c","line_number":102,"entry_url":"https://github.com/reactos/reactos.git","slot_name":"0.4.13-dev"},"487706":{"score":0.89464456,"function_name":"mbedtls_sha1_update_ret","code":"int mbedtls_sha1_update_ret( mbedtls_sha1_context *ctx,\n                             const unsigned char *input,\n                             size_t ilen )\n{\n    int ret;\n    size_t fill;\n    uint32_t left;\n\n    if( ilen == 0 )\n        return( 0 );\n\n    left = ctx-\u003etotal[0] \u0026 0x3F;\n    fill = 64 - left;\n\n    ctx-\u003etotal[0] += (uint32_t) ilen;\n    ctx-\u003etotal[0] \u0026= 0xFFFFFFFF;\n\n    if( ctx-\u003etotal[0] \u003c (uint32_t) ilen )\n        ctx-\u003etotal[1]++;\n\n    if( left \u0026\u0026 ilen \u003e= fill )\n    {\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, fill );\n\n        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n            return( ret );\n\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen \u003e= 64 )\n    {\n        if( ( ret = mbedtls_internal_sha1_process( ctx, input ) ) != 0 )\n            return( ret );\n\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen \u003e 0 )\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, ilen );\n\n    return( 0 );\n}","filepath":"dll/3rdparty/mbedtls/sha1.c","line_number":295,"entry_url":"https://github.com/reactos/reactos.git","slot_name":"0.4.13-dev"},"488803":{"score":0.6383553,"function_name":"mbedtls_sha1_ret","code":"int mbedtls_sha1_ret( const unsigned char *input,\n                      size_t ilen,\n                      unsigned char output[20] )\n{\n    int ret;\n    mbedtls_sha1_context ctx;\n\n    mbedtls_sha1_init( \u0026ctx );\n\n    if( ( ret = mbedtls_sha1_starts_ret( \u0026ctx ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha1_update_ret( \u0026ctx, input, ilen ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha1_finish_ret( \u0026ctx, output ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_sha1_free( \u0026ctx );\n\n    return( ret );\n}","filepath":"dll/3rdparty/mbedtls/sha1.c","line_number":422,"entry_url":"https://github.com/reactos/reactos.git","slot_name":"0.4.13-dev"},"489156":{"score":0.8760815,"function_name":"mbedtls_sha512_starts_ret","code":"int mbedtls_sha512_starts_ret( mbedtls_sha512_context *ctx, int is384 )\n{\n    SHA512_VALIDATE_RET( ctx != NULL );\n#if !defined(MBEDTLS_SHA512_NO_SHA384)\n    SHA512_VALIDATE_RET( is384 == 0 || is384 == 1 );\n#else\n    SHA512_VALIDATE_RET( is384 == 0 );\n#endif\n\n    ctx-\u003etotal[0] = 0;\n    ctx-\u003etotal[1] = 0;\n\n    if( is384 == 0 )\n    {\n        /* SHA-512 */\n        ctx-\u003estate[0] = UL64(0x6A09E667F3BCC908);\n        ctx-\u003estate[1] = UL64(0xBB67AE8584CAA73B);\n        ctx-\u003estate[2] = UL64(0x3C6EF372FE94F82B);\n        ctx-\u003estate[3] = UL64(0xA54FF53A5F1D36F1);\n        ctx-\u003estate[4] = UL64(0x510E527FADE682D1);\n        ctx-\u003estate[5] = UL64(0x9B05688C2B3E6C1F);\n        ctx-\u003estate[6] = UL64(0x1F83D9ABFB41BD6B);\n        ctx-\u003estate[7] = UL64(0x5BE0CD19137E2179);\n    }\n    else\n    {\n#if defined(MBEDTLS_SHA512_NO_SHA384)\n        return( MBEDTLS_ERR_SHA512_BAD_INPUT_DATA );\n#else\n        /* SHA-384 */\n        ctx-\u003estate[0] = UL64(0xCBBB9D5DC1059ED8);\n        ctx-\u003estate[1] = UL64(0x629A292A367CD507);\n        ctx-\u003estate[2] = UL64(0x9159015A3070DD17);\n        ctx-\u003estate[3] = UL64(0x152FECD8F70E5939);\n        ctx-\u003estate[4] = UL64(0x67332667FFC00B31);\n        ctx-\u003estate[5] = UL64(0x8EB44A8768581511);\n        ctx-\u003estate[6] = UL64(0xDB0C2E0D64F98FA7);\n        ctx-\u003estate[7] = UL64(0x47B5481DBEFA4FA4);\n#endif /* MBEDTLS_SHA512_NO_SHA384 */\n    }\n\n#if !defined(MBEDTLS_SHA512_NO_SHA384)\n    ctx-\u003eis384 = is384;\n#endif\n\n    return( 0 );\n}","filepath":"library/sha512.c","line_number":126,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.25.0"},"489402":{"score":0.79790956,"function_name":"mbedtls_internal_sha512_process","code":"int mbedtls_internal_sha512_process( mbedtls_sha512_context *ctx,\n                                     const unsigned char data[128] )\n{\n    int i;\n    struct\n    {\n        uint64_t temp1, temp2, W[80];\n        uint64_t A[8];\n    } local;\n\n    SHA512_VALIDATE_RET( ctx != NULL );\n    SHA512_VALIDATE_RET( (const unsigned char *)data != NULL );\n\n#define  SHR(x,n) ((x) \u003e\u003e (n))\n#define ROTR(x,n) (SHR((x),(n)) | ((x) \u003c\u003c (64 - (n))))\n\n#define S0(x) (ROTR(x, 1) ^ ROTR(x, 8) ^  SHR(x, 7))\n#define S1(x) (ROTR(x,19) ^ ROTR(x,61) ^  SHR(x, 6))\n\n#define S2(x) (ROTR(x,28) ^ ROTR(x,34) ^ ROTR(x,39))\n#define S3(x) (ROTR(x,14) ^ ROTR(x,18) ^ ROTR(x,41))\n\n#define F0(x,y,z) (((x) \u0026 (y)) | ((z) \u0026 ((x) | (y))))\n#define F1(x,y,z) ((z) ^ ((x) \u0026 ((y) ^ (z))))\n\n#define P(a,b,c,d,e,f,g,h,x,K)                                      \\\n    do                                                              \\\n    {                                                               \\\n        local.temp1 = (h) + S3(e) + F1((e),(f),(g)) + (K) + (x);    \\\n        local.temp2 = S2(a) + F0((a),(b),(c));                      \\\n        (d) += local.temp1; (h) = local.temp1 + local.temp2;        \\\n    } while( 0 )\n\n    for( i = 0; i \u003c 8; i++ )\n        local.A[i] = ctx-\u003estate[i];\n\n#if defined(MBEDTLS_SHA512_SMALLER)\n    for( i = 0; i \u003c 80; i++ )\n    {\n        if( i \u003c 16 )\n        {\n            GET_UINT64_BE( local.W[i], data, i \u003c\u003c 3 );\n        }\n        else\n        {\n            local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +\n                   S0(local.W[i - 15]) + local.W[i - 16];\n        }\n\n        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],\n           local.A[5], local.A[6], local.A[7], local.W[i], K[i] );\n\n        local.temp1 = local.A[7]; local.A[7] = local.A[6];\n        local.A[6] = local.A[5]; local.A[5] = local.A[4];\n        local.A[4] = local.A[3]; local.A[3] = local.A[2];\n        local.A[2] = local.A[1]; local.A[1] = local.A[0];\n        local.A[0] = local.temp1;\n    }\n#else /* MBEDTLS_SHA512_SMALLER */\n    for( i = 0; i \u003c 16; i++ )\n    {\n        GET_UINT64_BE( local.W[i], data, i \u003c\u003c 3 );\n    }\n\n    for( ; i \u003c 80; i++ )\n    {\n        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +\n               S0(local.W[i - 15]) + local.W[i - 16];\n    }\n\n    i = 0;\n    do\n    {\n        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],\n           local.A[5], local.A[6], local.A[7], local.W[i], K[i] ); i++;\n        P( local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],\n           local.A[4], local.A[5], local.A[6], local.W[i], K[i] ); i++;\n        P( local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],\n           local.A[3], local.A[4], local.A[5], local.W[i], K[i] ); i++;\n        P( local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],\n           local.A[2], local.A[3], local.A[4], local.W[i], K[i] ); i++;\n        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],\n           local.A[1], local.A[2], local.A[3], local.W[i], K[i] ); i++;\n        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],\n           local.A[0], local.A[1], local.A[2], local.W[i], K[i] ); i++;\n        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],\n           local.A[7], local.A[0], local.A[1], local.W[i], K[i] ); i++;\n        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],\n           local.A[6], local.A[7], local.A[0], local.W[i], K[i] ); i++;\n    }\n    while( i \u003c 80 );\n#endif /* MBEDTLS_SHA512_SMALLER */\n\n    for( i = 0; i \u003c 8; i++ )\n        ctx-\u003estate[i] += local.A[i];\n\n    /* Zeroise buffers and variables to clear sensitive data from memory. */\n    mbedtls_platform_zeroize( \u0026local, sizeof( local ) );\n\n    return( 0 );\n}","filepath":"library/sha512.c","line_number":231,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.25.0"},"495439":{"score":0.88380337,"function_name":"mbedtls_sha512_finish_ret","code":"int mbedtls_sha512_finish_ret( mbedtls_sha512_context *ctx,\n                               unsigned char output[64] )\n{\n    int ret;\n    unsigned used;\n    uint64_t high, low;\n\n    /*\n     * Add padding: 0x80 then 0x00 until 16 bytes remain for the length\n     */\n    used = ctx-\u003etotal[0] \u0026 0x7F;\n\n    ctx-\u003ebuffer[used++] = 0x80;\n\n    if( used \u003c= 112 )\n    {\n        /* Enough room for padding + length in current block */\n        memset( ctx-\u003ebuffer + used, 0, 112 - used );\n    }\n    else\n    {\n        /* We'll need an extra block */\n        memset( ctx-\u003ebuffer + used, 0, 128 - used );\n\n        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n            return( ret );\n\n        memset( ctx-\u003ebuffer, 0, 112 );\n    }\n\n    /*\n     * Add message length\n     */\n    high = ( ctx-\u003etotal[0] \u003e\u003e 61 )\n         | ( ctx-\u003etotal[1] \u003c\u003c  3 );\n    low  = ( ctx-\u003etotal[0] \u003c\u003c  3 );\n\n    PUT_UINT64_BE( high, ctx-\u003ebuffer, 112 );\n    PUT_UINT64_BE( low,  ctx-\u003ebuffer, 120 );\n\n    if( ( ret = mbedtls_internal_sha512_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n        return( ret );\n\n    /*\n     * Output final state\n     */\n    PUT_UINT64_BE( ctx-\u003estate[0], output,  0 );\n    PUT_UINT64_BE( ctx-\u003estate[1], output,  8 );\n    PUT_UINT64_BE( ctx-\u003estate[2], output, 16 );\n    PUT_UINT64_BE( ctx-\u003estate[3], output, 24 );\n    PUT_UINT64_BE( ctx-\u003estate[4], output, 32 );\n    PUT_UINT64_BE( ctx-\u003estate[5], output, 40 );\n\n    if( ctx-\u003eis384 == 0 )\n    {\n        PUT_UINT64_BE( ctx-\u003estate[6], output, 48 );\n        PUT_UINT64_BE( ctx-\u003estate[7], output, 56 );\n    }\n\n    return( 0 );\n}","filepath":"library/sha512.c","line_number":376,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.7.17"},"496421":{"score":0.6339798,"function_name":"mbedtls_sha512_ret","code":"int mbedtls_sha512_ret( const unsigned char *input,\n                    size_t ilen,\n                    unsigned char output[64],\n                    int is384 )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_sha512_context ctx;\n\n#if !defined(MBEDTLS_SHA512_NO_SHA384)\n    SHA512_VALIDATE_RET( is384 == 0 || is384 == 1 );\n#else\n    SHA512_VALIDATE_RET( is384 == 0 );\n#endif\n    SHA512_VALIDATE_RET( ilen == 0 || input != NULL );\n    SHA512_VALIDATE_RET( (unsigned char *)output != NULL );\n\n    mbedtls_sha512_init( \u0026ctx );\n\n    if( ( ret = mbedtls_sha512_starts_ret( \u0026ctx, is384 ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha512_update_ret( \u0026ctx, input, ilen ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha512_finish_ret( \u0026ctx, output ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_sha512_free( \u0026ctx );\n\n    return( ret );\n}","filepath":"library/sha512.c","line_number":486,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.25.0"},"496654":{"score":0.8471141,"function_name":"ssl_list_ciphersuites","code":"const int *ssl_list_ciphersuites( void )\n{\n    /*\n     * On initial call filter out all ciphersuites not supported by current\n     * build based on presence in the ciphersuite_definitions.\n     */\n    if( supported_init == 0 )\n    {\n        const int *p;\n        int *q;\n\n        for( p = ciphersuite_preference, q = supported_ciphersuites;\n             *p != 0 \u0026\u0026 q \u003c supported_ciphersuites + MAX_CIPHERSUITES - 1;\n             p++ )\n        {\n#if defined(POLARSSL_REMOVE_ARC4_CIPHERSUITES)\n            const ssl_ciphersuite_t *cs_info;\n            if( ( cs_info = ssl_ciphersuite_from_id( *p ) ) != NULL \u0026\u0026\n                cs_info-\u003ecipher != POLARSSL_CIPHER_ARC4_128 )\n#else\n            if( ssl_ciphersuite_from_id( *p ) != NULL )\n#endif\n                *(q++) = *p;\n        }\n        *q = 0;\n\n        supported_init = 1;\n    }\n\n    return( supported_ciphersuites );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1693,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"496793":{"score":0.8147995,"function_name":"ssl_ciphersuite_from_string","code":"const ssl_ciphersuite_t *ssl_ciphersuite_from_string(\n                                                const char *ciphersuite_name )\n{\n    const ssl_ciphersuite_t *cur = ciphersuite_definitions;\n\n    if( NULL == ciphersuite_name )\n        return( NULL );\n\n    while( cur-\u003eid != 0 )\n    {\n        if( 0 == strcasecmp( cur-\u003ename, ciphersuite_name ) )\n            return( cur );\n\n        cur++;\n    }\n\n    return( NULL );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1726,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"496886":{"score":0.7227784,"function_name":"ssl_ciphersuite_from_id","code":"const ssl_ciphersuite_t *ssl_ciphersuite_from_id( int ciphersuite )\n{\n    const ssl_ciphersuite_t *cur = ciphersuite_definitions;\n\n    while( cur-\u003eid != 0 )\n    {\n        if( cur-\u003eid == ciphersuite )\n            return( cur );\n\n        cur++;\n    }\n\n    return( NULL );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1745,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"496948":{"score":0.7867866,"function_name":"ssl_get_ciphersuite_name","code":"const char *ssl_get_ciphersuite_name( const int ciphersuite_id )\n{\n    const ssl_ciphersuite_t *cur;\n\n    cur = ssl_ciphersuite_from_id( ciphersuite_id );\n\n    if( cur == NULL )\n        return( \"unknown\" );\n\n    return( cur-\u003ename );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1760,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497005":{"score":0.76449907,"function_name":"ssl_get_ciphersuite_id","code":"int ssl_get_ciphersuite_id( const char *ciphersuite_name )\n{\n    const ssl_ciphersuite_t *cur;\n\n    cur = ssl_ciphersuite_from_string( ciphersuite_name );\n\n    if( cur == NULL )\n        return( 0 );\n\n    return( cur-\u003eid );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1772,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497058":{"score":0.7811317,"function_name":"ssl_get_ciphersuite_sig_pk_alg","code":"pk_type_t ssl_get_ciphersuite_sig_pk_alg( const ssl_ciphersuite_t *info )\n{\n    switch( info-\u003ekey_exchange )\n    {\n        case POLARSSL_KEY_EXCHANGE_RSA:\n        case POLARSSL_KEY_EXCHANGE_DHE_RSA:\n        case POLARSSL_KEY_EXCHANGE_ECDHE_RSA:\n        case POLARSSL_KEY_EXCHANGE_RSA_PSK:\n            return( POLARSSL_PK_RSA );\n\n        case POLARSSL_KEY_EXCHANGE_ECDHE_ECDSA:\n            return( POLARSSL_PK_ECDSA );\n\n        case POLARSSL_KEY_EXCHANGE_ECDH_RSA:\n        case POLARSSL_KEY_EXCHANGE_ECDH_ECDSA:\n            return( POLARSSL_PK_ECKEY );\n\n        default:\n            return( POLARSSL_PK_NONE );\n    }\n}","filepath":"library/ssl_ciphersuites.c","line_number":1785,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497124":{"score":0.66618645,"function_name":"ssl_get_ciphersuite_sig_alg","code":"pk_type_t ssl_get_ciphersuite_sig_alg( const ssl_ciphersuite_t *info )\n{\n    switch( info-\u003ekey_exchange )\n    {\n        case POLARSSL_KEY_EXCHANGE_RSA:\n        case POLARSSL_KEY_EXCHANGE_DHE_RSA:\n        case POLARSSL_KEY_EXCHANGE_ECDHE_RSA:\n            return( POLARSSL_PK_RSA );\n\n        case POLARSSL_KEY_EXCHANGE_ECDHE_ECDSA:\n            return( POLARSSL_PK_ECDSA );\n\n        default:\n            return( POLARSSL_PK_NONE );\n    }\n}","filepath":"library/ssl_ciphersuites.c","line_number":1807,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497181":{"score":0.8354452,"function_name":"ssl_ciphersuite_uses_psk","code":"int ssl_ciphersuite_uses_psk( const ssl_ciphersuite_t *info )\n{\n    switch( info-\u003ekey_exchange )\n    {\n        case POLARSSL_KEY_EXCHANGE_PSK:\n        case POLARSSL_KEY_EXCHANGE_RSA_PSK:\n        case POLARSSL_KEY_EXCHANGE_DHE_PSK:\n        case POLARSSL_KEY_EXCHANGE_ECDHE_PSK:\n            return( 1 );\n\n        default:\n            return( 0 );\n    }\n}","filepath":"library/ssl_ciphersuites.c","line_number":1845,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497484":{"score":0.66096175,"function_name":"ssl_write_session_ticket_ext","code":"static void ssl_write_session_ticket_ext( ssl_context *ssl,\n                                          unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n    size_t tlen = ssl-\u003esession_negotiate-\u003eticket_len;\n\n    *olen = 0;\n\n    if( ssl-\u003esession_tickets == SSL_SESSION_TICKETS_DISABLED )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding session ticket extension\" ) );\n\n    if( end \u003c p || (size_t)( end - p ) \u003c 4 + tlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( TLS_EXT_SESSION_TICKET \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SESSION_TICKET      ) \u0026 0xFF );\n\n    *p++ = (unsigned char)( ( tlen \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( tlen      ) \u0026 0xFF );\n\n    *olen = 4;\n\n    if( ssl-\u003esession_negotiate-\u003eticket == NULL ||\n        ssl-\u003esession_negotiate-\u003eticket_len == 0 )\n    {\n        return;\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"sending session ticket of length %d\", tlen ) );\n\n    memcpy( p, ssl-\u003esession_negotiate-\u003eticket, tlen );\n\n    *olen += tlen;\n}","filepath":"library/ssl_cli.c","line_number":539,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497819":{"score":0.55463636,"function_name":"ssl_write_signature_algorithms_ext","code":"static void ssl_write_signature_algorithms_ext( mbedtls_ssl_context *ssl,\n                                                unsigned char *buf,\n                                                size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;\n    size_t sig_alg_len = 0;\n    const int *md;\n#if defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C)\n    unsigned char *sig_alg_list = buf + 6;\n#endif\n\n    *olen = 0;\n\n    if( ssl-\u003econf-\u003emax_minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding signature_algorithms extension\" ) );\n\n    for( md = ssl-\u003econf-\u003esig_hashes; *md != MBEDTLS_MD_NONE; md++ )\n    {\n#if defined(MBEDTLS_ECDSA_C)\n        sig_alg_len += 2;\n#endif\n#if defined(MBEDTLS_RSA_C)\n        sig_alg_len += 2;\n#endif\n    }\n\n    if( end \u003c p || (size_t)( end - p ) \u003c sig_alg_len + 6 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Prepare signature_algorithms extension (TLS 1.2)\n     */\n    sig_alg_len = 0;\n\n    for( md = ssl-\u003econf-\u003esig_hashes; *md != MBEDTLS_MD_NONE; md++ )\n    {\n#if defined(MBEDTLS_ECDSA_C)\n        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );\n        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_ECDSA;\n#endif\n#if defined(MBEDTLS_RSA_C)\n        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );\n        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_RSA;\n#endif\n    }\n\n    /*\n     * enum {\n     *     none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n     *     sha512(6), (255)\n     * } HashAlgorithm;\n     *\n     * enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }\n     *   SignatureAlgorithm;\n     *\n     * struct {\n     *     HashAlgorithm hash;\n     *     SignatureAlgorithm signature;\n     * } SignatureAndHashAlgorithm;\n     *\n     * SignatureAndHashAlgorithm\n     *   supported_signature_algorithms\u003c2..2^16-2\u003e;\n     */\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG      ) \u0026 0xFF );\n\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 ) \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 )      ) \u0026 0xFF );\n\n    *p++ = (unsigned char)( ( sig_alg_len \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( sig_alg_len      ) \u0026 0xFF );\n\n    *olen = 6 + sig_alg_len;\n}","filepath":"library/ssl_cli.c","line_number":169,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.13.0"},"498181":{"score":0.44418883,"function_name":"ssl_write_session_ticket_ext","code":"static void ssl_write_session_ticket_ext( ssl_context *ssl,\n                                          unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n    size_t tlen = ssl-\u003esession_negotiate-\u003eticket_len;\n\n    *olen = 0;\n\n    if( ssl-\u003esession_tickets == SSL_SESSION_TICKETS_DISABLED )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding session ticket extension\" ) );\n\n    if( end \u003c p || (size_t)( end - p ) \u003c 4 + tlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( TLS_EXT_SESSION_TICKET \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SESSION_TICKET      ) \u0026 0xFF );\n\n    *p++ = (unsigned char)( ( tlen \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( tlen      ) \u0026 0xFF );\n\n    *olen = 4;\n\n    if( ssl-\u003esession_negotiate-\u003eticket == NULL ||\n        ssl-\u003esession_negotiate-\u003eticket_len == 0 )\n    {\n        return;\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"sending session ticket of length %d\", tlen ) );\n\n    memcpy( p, ssl-\u003esession_negotiate-\u003eticket, tlen );\n\n    *olen += tlen;\n}","filepath":"library/ssl_cli.c","line_number":534,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"498587":{"score":0.5294543,"function_name":"ssl_write_signature_algorithms_ext","code":"static void ssl_write_signature_algorithms_ext( ssl_context *ssl,\n                                                unsigned char *buf,\n                                                size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n    size_t sig_alg_len = 0;\n#if defined(POLARSSL_RSA_C) || defined(POLARSSL_ECDSA_C)\n    unsigned char *sig_alg_list = buf + 6;\n#endif\n\n    *olen = 0;\n\n    if( ssl-\u003emax_minor_ver != SSL_MINOR_VERSION_3 )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding signature_algorithms extension\" ) );\n\n#if defined(POLARSSL_RSA_C)\n#if defined(POLARSSL_SHA512_C)\n    /* SHA512 + RSA signature, SHA384 + RSA signature */\n    sig_alg_len += 4;\n#endif\n#if defined(POLARSSL_SHA256_C)\n    /* SHA256 + RSA signature, SHA224 + RSA signature */\n    sig_alg_len += 4;\n#endif\n#if defined(POLARSSL_SHA1_C)\n    /* SHA1 + RSA signature */\n    sig_alg_len += 2;\n#endif\n#if defined(POLARSSL_MD5_C) \u0026\u0026 defined(POLARSSL_SSL_ENABLE_MD5_SIGNATURES)\n    /* MD5 + RSA signature */\n    sig_alg_len += 2;\n#endif\n#endif /* POLARSSL_RSA_C */\n#if defined(POLARSSL_ECDSA_C)\n#if defined(POLARSSL_SHA512_C)\n    /* SHA512 + ECDSA signature, SHA384 + ECDSA signature */\n    sig_alg_len += 4;\n#endif\n#if defined(POLARSSL_SHA256_C)\n    /* SHA256 + ECDSA signature, SHA224 + ECDSA signature */\n    sig_alg_len += 4;\n#endif\n#if defined(POLARSSL_SHA1_C)\n    /* SHA1 + ECDSA signature */\n    sig_alg_len += 2;\n#endif\n#if defined(POLARSSL_MD5_C) \u0026\u0026 defined(POLARSSL_SSL_ENABLE_MD5_SIGNATURES)\n    /* MD5 + ECDSA signature */\n    sig_alg_len += 2;\n#endif\n#endif /* POLARSSL_ECDSA_C */\n\n    if( end \u003c p || (size_t)( end - p ) \u003c sig_alg_len + 6 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Prepare signature_algorithms extension (TLS 1.2)\n     */\n    sig_alg_len = 0;\n\n#if defined(POLARSSL_RSA_C)\n#if defined(POLARSSL_SHA512_C)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA512;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_RSA;\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA384;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_RSA;\n#endif\n#if defined(POLARSSL_SHA256_C)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA256;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_RSA;\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA224;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_RSA;\n#endif\n#if defined(POLARSSL_SHA1_C)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA1;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_RSA;\n#endif\n#if defined(POLARSSL_MD5_C) \u0026\u0026 defined(POLARSSL_SSL_ENABLE_MD5_SIGNATURES)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_MD5;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_RSA;\n#endif\n#endif /* POLARSSL_RSA_C */\n#if defined(POLARSSL_ECDSA_C)\n#if defined(POLARSSL_SHA512_C)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA512;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_ECDSA;\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA384;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_ECDSA;\n#endif\n#if defined(POLARSSL_SHA256_C)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA256;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_ECDSA;\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA224;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_ECDSA;\n#endif\n#if defined(POLARSSL_SHA1_C)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_SHA1;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_ECDSA;\n#endif\n#if defined(POLARSSL_MD5_C) \u0026\u0026 defined(POLARSSL_SSL_ENABLE_MD5_SIGNATURES)\n    sig_alg_list[sig_alg_len++] = SSL_HASH_MD5;\n    sig_alg_list[sig_alg_len++] = SSL_SIG_ECDSA;\n#endif\n#endif /* POLARSSL_ECDSA_C */\n\n    /*\n     * enum {\n     *     none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n     *     sha512(6), (255)\n     * } HashAlgorithm;\n     *\n     * enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }\n     *   SignatureAlgorithm;\n     *\n     * struct {\n     *     HashAlgorithm hash;\n     *     SignatureAlgorithm signature;\n     * } SignatureAndHashAlgorithm;\n     *\n     * SignatureAndHashAlgorithm\n     *   supported_signature_algorithms\u003c2..2^16-2\u003e;\n     */\n    *p++ = (unsigned char)( ( TLS_EXT_SIG_ALG \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SIG_ALG      ) \u0026 0xFF );\n\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 ) \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 )      ) \u0026 0xFF );\n\n    *p++ = (unsigned char)( ( sig_alg_len \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( sig_alg_len      ) \u0026 0xFF );\n\n    *olen = 6 + sig_alg_len;\n}","filepath":"library/ssl_cli.c","line_number":163,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"498744":{"score":0.57589,"function_name":"ssl_write_max_fragment_length_ext","code":"static void ssl_write_max_fragment_length_ext( ssl_context *ssl,\n                                               unsigned char *buf,\n                                               size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl-\u003emfl_code == SSL_MAX_FRAG_LEN_NONE )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding max_fragment_length extension\" ) );\n\n    if( end \u003c p || (size_t)( end - p ) \u003c 5 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( TLS_EXT_MAX_FRAGMENT_LENGTH \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_MAX_FRAGMENT_LENGTH      ) \u0026 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 1;\n\n    *p++ = ssl-\u003emfl_code;\n\n    *olen = 5;\n}","filepath":"library/ssl_cli.c","line_number":408,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"499152":{"score":0.47435302,"function_name":"ssl_write_client_hello","code":"static int ssl_write_client_hello( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n, olen, ext_len = 0;\n    unsigned char *buf;\n    unsigned char *p;\n    time_t t;\n    const int *ciphersuites;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e write client hello\" ) );\n\n    if( ssl-\u003erenegotiation == SSL_INITIAL_HANDSHAKE )\n    {\n        ssl-\u003emajor_ver = ssl-\u003emin_major_ver;\n        ssl-\u003eminor_ver = ssl-\u003emin_minor_ver;\n    }\n\n    if( ssl-\u003emax_major_ver == 0 \u0026\u0026 ssl-\u003emax_minor_ver == 0 )\n    {\n        ssl-\u003emax_major_ver = SSL_MAJOR_VERSION_3;\n        ssl-\u003emax_minor_ver = SSL_MINOR_VERSION_3;\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   highest version supported\n     *     6  .   9   current UNIX time\n     *    10  .  37   random bytes\n     */\n    buf = ssl-\u003eout_msg;\n    p = buf + 4;\n\n    *p++ = (unsigned char) ssl-\u003emax_major_ver;\n    *p++ = (unsigned char) ssl-\u003emax_minor_ver;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, max version: [%d:%d]\",\n                   buf[4], buf[5] ) );\n\n    t = time( NULL );\n    *p++ = (unsigned char)( t \u003e\u003e 24 );\n    *p++ = (unsigned char)( t \u003e\u003e 16 );\n    *p++ = (unsigned char)( t \u003e\u003e  8 );\n    *p++ = (unsigned char)( t       );\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, current time: %lu\", t ) );\n\n    if( ( ret = ssl-\u003ef_rng( ssl-\u003ep_rng, p, 28 ) ) != 0 )\n        return( ret );\n\n    p += 28;\n\n    memcpy( ssl-\u003ehandshake-\u003erandbytes, buf + 6, 32 );\n\n    SSL_DEBUG_BUF( 3, \"client hello, random bytes\", buf + 6, 32 );\n\n    /*\n     *    38  .  38   session id length\n     *    39  . 39+n  session id\n     *   40+n . 41+n  ciphersuitelist length\n     *   42+n . ..    ciphersuitelist\n     *   ..   . ..    compression methods length\n     *   ..   . ..    compression methods\n     *   ..   . ..    extensions length\n     *   ..   . ..    extensions\n     */\n    n = ssl-\u003esession_negotiate-\u003elength;\n\n    if( ssl-\u003erenegotiation != SSL_INITIAL_HANDSHAKE || n \u003c 16 || n \u003e 32 ||\n        ssl-\u003ehandshake-\u003eresume == 0 )\n        n = 0;\n\n    *p++ = (unsigned char) n;\n\n    for( i = 0; i \u003c n; i++ )\n        *p++ = ssl-\u003esession_negotiate-\u003eid[i];\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, session id len.: %d\", n ) );\n    SSL_DEBUG_BUF( 3,   \"client hello, session id\", buf + 39, n );\n\n    ciphersuites = ssl-\u003eciphersuite_list[ssl-\u003eminor_ver];\n    for( n = 0; ciphersuites[n] != 0; n++ );\n    if( ssl-\u003erenegotiation == SSL_INITIAL_HANDSHAKE ) n++;\n    *p++ = (unsigned char)( n \u003e\u003e 7 );\n    *p++ = (unsigned char)( n \u003c\u003c 1 );\n\n    /*\n     * Add TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n     */\n    if( ssl-\u003erenegotiation == SSL_INITIAL_HANDSHAKE )\n    {\n        *p++ = (unsigned char)( SSL_EMPTY_RENEGOTIATION_INFO \u003e\u003e 8 );\n        *p++ = (unsigned char)( SSL_EMPTY_RENEGOTIATION_INFO      );\n        n--;\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, got %d ciphersuites\", n ) );\n\n    for( i = 0; i \u003c n; i++ )\n    {\n        SSL_DEBUG_MSG( 3, ( \"client hello, add ciphersuite: %2d\",\n                       ciphersuites[i] ) );\n\n        *p++ = (unsigned char)( ciphersuites[i] \u003e\u003e 8 );\n        *p++ = (unsigned char)( ciphersuites[i]      );\n    }\n\n#if defined(POLARSSL_ZLIB_SUPPORT)\n    SSL_DEBUG_MSG( 3, ( \"client hello, compress len.: %d\", 2 ) );\n    SSL_DEBUG_MSG( 3, ( \"client hello, compress alg.: %d %d\",\n                        SSL_COMPRESS_DEFLATE, SSL_COMPRESS_NULL ) );\n\n    *p++ = 2;\n    *p++ = SSL_COMPRESS_DEFLATE;\n    *p++ = SSL_COMPRESS_NULL;\n#else\n    SSL_DEBUG_MSG( 3, ( \"client hello, compress len.: %d\", 1 ) );\n    SSL_DEBUG_MSG( 3, ( \"client hello, compress alg.: %d\", SSL_COMPRESS_NULL ) );\n\n    *p++ = 1;\n    *p++ = SSL_COMPRESS_NULL;\n#endif\n\n    // First write extensions, then the total length\n    //\n    ssl_write_hostname_ext( ssl, p + 2 + ext_len, \u0026olen );\n    ext_len += olen;\n\n    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, \u0026olen );\n    ext_len += olen;\n\n    ssl_write_signature_algorithms_ext( ssl, p + 2 + ext_len, \u0026olen );\n    ext_len += olen;\n\n#if defined(POLARSSL_ECDH_C)\n    ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len, \u0026olen );\n    ext_len += olen;\n\n    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, \u0026olen );\n    ext_len += olen;\n#endif\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, total extension length: %d\",\n                   ext_len ) );\n\n    *p++ = (unsigned char)( ( ext_len \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( ext_len      ) \u0026 0xFF );\n    p += ext_len;\n\n    ssl-\u003eout_msglen  = p - buf;\n    ssl-\u003eout_msgtype = SSL_MSG_HANDSHAKE;\n    ssl-\u003eout_msg[0]  = SSL_HS_CLIENT_HELLO;\n\n    ssl-\u003estate++;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= write client hello\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":251,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3-alpha1"},"500264":{"score":0.5262901,"function_name":"ssl_parse_renegotiation_info","code":"static int ssl_parse_renegotiation_info( ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    int ret;\n\n#if defined(POLARSSL_SSL_RENEGOTIATION)\n    if( ssl-\u003erenegotiation != SSL_INITIAL_HANDSHAKE )\n    {\n        /* Check verify-data in constant-time. The length OTOH is no secret */\n        if( len    != 1 + ssl-\u003everify_data_len * 2 ||\n            buf[0] !=     ssl-\u003everify_data_len * 2 ||\n            safer_memcmp( buf + 1,\n                          ssl-\u003eown_verify_data, ssl-\u003everify_data_len ) != 0 ||\n            safer_memcmp( buf + 1 + ssl-\u003everify_data_len,\n                          ssl-\u003epeer_verify_data, ssl-\u003everify_data_len ) != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"non-matching renegotiation info\" ) );\n\n            if( ( ret = ssl_send_fatal_handshake_failure( ssl ) ) != 0 )\n                return( ret );\n\n            return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n    else\n#endif /* POLARSSL_SSL_RENEGOTIATION */\n    {\n        if( len != 1 || buf[0] != 0x00 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"non-zero length renegotiation info\" ) );\n\n            if( ( ret = ssl_send_fatal_handshake_failure( ssl ) ) != 0 )\n                return( ret );\n\n            return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n\n        ssl-\u003esecure_renegotiation = SSL_SECURE_RENEGOTIATION;\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":925,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"500347":{"score":0.7152269,"function_name":"ssl_parse_session_ticket_ext","code":"static int ssl_parse_session_ticket_ext( ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl-\u003esession_tickets == SSL_SESSION_TICKETS_DISABLED ||\n        len != 0 )\n    {\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl-\u003ehandshake-\u003enew_session_ticket = 1;\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":1049,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"500449":{"score":0.6552992,"function_name":"ssl_parse_supported_point_formats_ext","code":"static int ssl_parse_supported_point_formats_ext( ssl_context *ssl,\n                                                  const unsigned char *buf,\n                                                  size_t len )\n{\n    size_t list_size;\n    const unsigned char *p;\n\n    list_size = buf[0];\n    if( list_size + 1 != len )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    p = buf + 1;\n    while( list_size \u003e 0 )\n    {\n        if( p[0] == POLARSSL_ECP_PF_UNCOMPRESSED ||\n            p[0] == POLARSSL_ECP_PF_COMPRESSED )\n        {\n            ssl-\u003ehandshake-\u003eecdh_ctx.point_format = p[0];\n            SSL_DEBUG_MSG( 4, ( \"point format selected: %d\", p[0] ) );\n            return( 0 );\n        }\n\n        list_size--;\n        p++;\n    }\n\n    SSL_DEBUG_MSG( 1, ( \"no point format in common\" ) );\n    return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n}","filepath":"library/ssl_cli.c","line_number":1068,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"500632":{"score":0.5753479,"function_name":"ssl_parse_server_hello","code":"static int ssl_parse_server_hello( ssl_context *ssl )\n{\n    int ret, i, comp;\n    size_t n;\n    size_t ext_len;\n    unsigned char *buf, *ext;\n#if defined(POLARSSL_SSL_RENEGOTIATION)\n    int renegotiation_info_seen = 0;\n#endif\n    int handshake_failure = 0;\n    const ssl_ciphersuite_t *suite_info;\n#if defined(POLARSSL_DEBUG_C)\n    uint32_t t;\n#endif\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e parse server hello\" ) );\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   protocol version\n     *     6  .   9   UNIX time()\n     *    10  .  37   random bytes\n     */\n    buf = ssl-\u003ein_msg;\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl-\u003ein_msgtype != SSL_MSG_HANDSHAKE )\n    {\n#if defined(POLARSSL_SSL_RENEGOTIATION)\n        if( ssl-\u003erenegotiation == SSL_RENEGOTIATION )\n        {\n            ssl-\u003erenego_records_seen++;\n\n            if( ssl-\u003erenego_max_records \u003e= 0 \u0026\u0026\n                ssl-\u003erenego_records_seen \u003e ssl-\u003erenego_max_records )\n            {\n                SSL_DEBUG_MSG( 1, ( \"renegotiation requested, \"\n                                    \"but not honored by server\" ) );\n                return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n            }\n\n            SSL_DEBUG_MSG( 1, ( \"non-handshake message during renego\" ) );\n\n            ssl-\u003ekeep_current_message = 1;\n            return( POLARSSL_ERR_SSL_WAITING_SERVER_HELLO_RENEGO );\n        }\n#endif /* POLARSSL_SSL_RENEGOTIATION */\n\n        SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"server hello, chosen version: [%d:%d]\",\n                   buf[4], buf[5] ) );\n\n    if( ssl-\u003ein_hslen \u003c 42 ||\n        buf[0] != SSL_HS_SERVER_HELLO ||\n        buf[4] != SSL_MAJOR_VERSION_3 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    if( buf[5] \u003e ssl-\u003emax_minor_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ssl-\u003eminor_ver = buf[5];\n\n    if( ssl-\u003eminor_ver \u003c ssl-\u003emin_minor_ver )\n    {\n        SSL_DEBUG_MSG( 1, ( \"server only supports ssl smaller than minimum\"\n                            \" [%d:%d] \u003c [%d:%d]\", ssl-\u003emajor_ver,\n                            ssl-\u003eminor_ver, buf[4], buf[5] ) );\n\n        ssl_send_alert_message( ssl, SSL_ALERT_LEVEL_FATAL,\n                                     SSL_ALERT_MSG_PROTOCOL_VERSION );\n\n        return( POLARSSL_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n#if defined(POLARSSL_DEBUG_C)\n    t = ( (uint32_t) buf[6] \u003c\u003c 24 )\n      | ( (uint32_t) buf[7] \u003c\u003c 16 )\n      | ( (uint32_t) buf[8] \u003c\u003c  8 )\n      | ( (uint32_t) buf[9]       );\n    SSL_DEBUG_MSG( 3, ( \"server hello, current time: %lu\", t ) );\n#endif\n\n    memcpy( ssl-\u003ehandshake-\u003erandbytes + 32, buf + 6, 32 );\n\n    n = buf[38];\n\n    SSL_DEBUG_BUF( 3,   \"server hello, random bytes\", buf + 6, 32 );\n\n    if( n \u003e 32 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /*\n     *    38  .  38   session id length\n     *    39  . 38+n  session id\n     *   39+n . 40+n  chosen ciphersuite\n     *   41+n . 41+n  chosen compression alg.\n     *   42+n . 43+n  extensions length\n     *   44+n . 44+n+m extensions\n     */\n    if( ssl-\u003ein_hslen \u003e 43 + n )\n    {\n        ext_len = ( ( buf[42 + n] \u003c\u003c  8 )\n                  | ( buf[43 + n]       ) );\n\n        if( ( ext_len \u003e 0 \u0026\u0026 ext_len \u003c 4 ) ||\n            ssl-\u003ein_hslen != 44 + n + ext_len )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n    else if( ssl-\u003ein_hslen == 42 + n )\n    {\n        ext_len = 0;\n    }\n    else\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    i = ( buf[39 + n] \u003c\u003c 8 ) | buf[40 + n];\n    comp = buf[41 + n];\n\n    /*\n     * Initialize update checksum functions\n     */\n    ssl-\u003etransform_negotiate-\u003eciphersuite_info = ssl_ciphersuite_from_id( i );\n\n    if( ssl-\u003etransform_negotiate-\u003eciphersuite_info == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"ciphersuite info for %04x not found\", i ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    ssl_optimize_checksum( ssl, ssl-\u003etransform_negotiate-\u003eciphersuite_info );\n\n    SSL_DEBUG_MSG( 3, ( \"server hello, session id len.: %d\", n ) );\n    SSL_DEBUG_BUF( 3,   \"server hello, session id\", buf + 39, n );\n\n    /*\n     * Check if the session can be resumed\n     */\n    if( ssl-\u003ehandshake-\u003eresume == 0 || n == 0 ||\n#if defined(POLARSSL_SSL_RENEGOTIATION)\n        ssl-\u003erenegotiation != SSL_INITIAL_HANDSHAKE ||\n#endif\n        ssl-\u003esession_negotiate-\u003eciphersuite != i ||\n        ssl-\u003esession_negotiate-\u003ecompression != comp ||\n        ssl-\u003esession_negotiate-\u003elength != n ||\n        memcmp( ssl-\u003esession_negotiate-\u003eid, buf + 39, n ) != 0 )\n    {\n        ssl-\u003estate++;\n        ssl-\u003ehandshake-\u003eresume = 0;\n#if defined(POLARSSL_HAVE_TIME)\n        ssl-\u003esession_negotiate-\u003estart = time( NULL );\n#endif\n        ssl-\u003esession_negotiate-\u003eciphersuite = i;\n        ssl-\u003esession_negotiate-\u003ecompression = comp;\n        ssl-\u003esession_negotiate-\u003elength = n;\n        memcpy( ssl-\u003esession_negotiate-\u003eid, buf + 39, n );\n    }","filepath":"library/ssl_cli.c","line_number":1150,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"502402":{"score":0.6979885,"function_name":"ssl_write_encrypted_pms","code":"static int ssl_write_encrypted_pms( ssl_context *ssl,\n                                    size_t offset, size_t *olen,\n                                    size_t pms_offset )\n{\n    int ret;\n    size_t len_bytes = ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 ? 0 : 2;\n    unsigned char *p = ssl-\u003ehandshake-\u003epremaster + pms_offset;\n\n    if( offset + len_bytes \u003e SSL_MAX_CONTENT_LEN )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small for encrypted pms\" ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /*\n     * Generate (part of) the pre-master as\n     *  struct {\n     *      ProtocolVersion client_version;\n     *      opaque random[46];\n     *  } PreMasterSecret;\n     */\n    p[0] = (unsigned char) ssl-\u003emax_major_ver;\n    p[1] = (unsigned char) ssl-\u003emax_minor_ver;\n\n    if( ( ret = ssl-\u003ef_rng( ssl-\u003ep_rng, p + 2, 46 ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"f_rng\", ret );\n        return( ret );\n    }\n\n    ssl-\u003ehandshake-\u003epmslen = 48;\n\n    if( ssl-\u003esession_negotiate-\u003epeer_cert == NULL )\n    {\n        SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * Now write it out, encrypted\n     */\n    if( ! pk_can_do( \u0026ssl-\u003esession_negotiate-\u003epeer_cert-\u003epk,\n                POLARSSL_PK_RSA ) )\n    {\n        SSL_DEBUG_MSG( 1, ( \"certificate key type mismatch\" ) );\n        return( POLARSSL_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    if( ( ret = pk_encrypt( \u0026ssl-\u003esession_negotiate-\u003epeer_cert-\u003epk,\n                            p, ssl-\u003ehandshake-\u003epmslen,\n                            ssl-\u003eout_msg + offset + len_bytes, olen,\n                            SSL_MAX_CONTENT_LEN - offset - len_bytes,\n                            ssl-\u003ef_rng, ssl-\u003ep_rng ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"rsa_pkcs1_encrypt\", ret );\n        return( ret );\n    }\n\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1) || \\\n    defined(POLARSSL_SSL_PROTO_TLS1_2)\n    if( len_bytes == 2 )\n    {\n        ssl-\u003eout_msg[offset+0] = (unsigned char)( *olen \u003e\u003e 8 );\n        ssl-\u003eout_msg[offset+1] = (unsigned char)( *olen      );\n        *olen += 2;\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":1711,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"503176":{"score":0.52747464,"function_name":"ssl_parse_certificate_request","code":"static int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char *buf;\n    size_t n = 0;\n    size_t cert_type_len = 0, dn_len = 0;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl-\u003ehandshake-\u003eciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e parse certificate request\" ) );\n\n    if( ! mbedtls_ssl_ciphersuite_cert_req_allowed( ciphersuite_info ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate request\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n    if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl-\u003ein_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message(\n            ssl,\n            MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n            MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    ssl-\u003estate++;\n    ssl-\u003eclient_auth = ( ssl-\u003ein_msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"got %s certificate request\",\n                        ssl-\u003eclient_auth ? \"a\" : \"no\" ) );\n\n    if( ssl-\u003eclient_auth == 0 )\n    {\n        /* Current message is probably the ServerHelloDone */\n        ssl-\u003ekeep_current_message = 1;\n        goto exit;\n    }\n\n    /*\n     *  struct {\n     *      ClientCertificateType certificate_types\u003c1..2^8-1\u003e;\n     *      SignatureAndHashAlgorithm\n     *        supported_signature_algorithms\u003c2^16-1\u003e; -- TLS 1.2 only\n     *      DistinguishedName certificate_authorities\u003c0..2^16-1\u003e;\n     *  } CertificateRequest;\n     *\n     *  Since we only support a single certificate on clients, let's just\n     *  ignore all the information that's supposed to help us pick a\n     *  certificate.\n     *\n     *  We could check that our certificate matches the request, and bail out\n     *  if it doesn't, but it's simpler to just send the certificate anyway,\n     *  and give the server the opportunity to decide if it should terminate\n     *  the connection when it doesn't like our certificate.\n     *\n     *  Same goes for the hash in TLS 1.2's signature_algorithms: at this\n     *  point we only have one hash available (see comments in\n     *  write_certificate_verify), so let's just use what we have.\n     *\n     *  However, we still minimally parse the message to check it is at least\n     *  superficially sane.\n     */\n    buf = ssl-\u003ein_msg;\n\n    /* certificate_types */\n    if( ssl-\u003ein_hslen \u003c= mbedtls_ssl_hs_hdr_len( ssl ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n    cert_type_len = buf[mbedtls_ssl_hs_hdr_len( ssl )];\n    n = cert_type_len;\n\n    /*\n     * In the subsequent code there are two paths that read from buf:\n     *     * the length of the signature algorithms field (if minor version of\n     *       SSL is 3),\n     *     * distinguished name length otherwise.\n     * Both reach at most the index:\n     *    ...hdr_len + 2 + n,\n     * therefore the buffer length at this point must be greater than that\n     * regardless of the actual code path.\n     */\n    if( ssl-\u003ein_hslen \u003c= mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\n    /* supported_signature_algorithms */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl-\u003eminor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        size_t sig_alg_len =\n            ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] \u003c\u003c  8 )\n              | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]   ) );\n#if defined(MBEDTLS_DEBUG_C)\n        unsigned char* sig_alg;\n        size_t i;\n#endif\n\n        /*\n         * The furthest access in buf is in the loop few lines below:\n         *     sig_alg[i + 1],\n         * where:\n         *     sig_alg = buf + ...hdr_len + 3 + n,\n         *     max(i) = sig_alg_len - 1.\n         * Therefore the furthest access is:\n         *     buf[...hdr_len + 3 + n + sig_alg_len - 1 + 1],\n         * which reduces to:\n         *     buf[...hdr_len + 3 + n + sig_alg_len],\n         * which is one less than we need the buf to be.\n         */\n        if( ssl-\u003ein_hslen \u003c= mbedtls_ssl_hs_hdr_len( ssl )\n                                + 3 + n + sig_alg_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n            mbedtls_ssl_send_alert_message(\n                ssl,\n                MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n        }\n\n#if defined(MBEDTLS_DEBUG_C)\n        sig_alg = buf + mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n;\n        for( i = 0; i \u003c sig_alg_len; i += 2 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3,\n                ( \"Supported Signature Algorithm found: %d,%d\",\n                  sig_alg[i], sig_alg[i + 1]  ) );\n        }\n#endif\n\n        n += 2 + sig_alg_len;\n    }\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n    /* certificate_authorities */\n    dn_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] \u003c\u003c  8 )\n             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );\n\n    n += dn_len;\n    if( ssl-\u003ein_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\nexit:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= parse certificate request\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":3207,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.24.0"},"504277":{"score":0.6442026,"function_name":"ssl_write_certificate_verify","code":"static int ssl_write_certificate_verify( ssl_context *ssl )\n{\n    int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n    const ssl_ciphersuite_t *ciphersuite_info = ssl-\u003etransform_negotiate-\u003eciphersuite_info;\n    size_t n = 0, offset = 0;\n    unsigned char hash[48];\n    unsigned char *hash_start = hash;\n    md_type_t md_alg = POLARSSL_MD_NONE;\n    unsigned int hashlen;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e write certificate verify\" ) );\n\n    if( ( ret = ssl_derive_keys( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_derive_keys\", ret );\n        return( ret );\n    }\n\n    if( ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_DHE_PSK )\n    {\n        SSL_DEBUG_MSG( 2, ( \"\u003c= skip write certificate verify\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n    if( ssl-\u003eclient_auth == 0 || ssl_own_cert( ssl ) == NULL )\n    {\n        SSL_DEBUG_MSG( 2, ( \"\u003c= skip write certificate verify\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n    if( ssl_own_key( ssl ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"got no private key\" ) );\n        return( POLARSSL_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Make an RSA signature of the handshake digests\n     */\n    ssl-\u003ehandshake-\u003ecalc_verify( ssl, hash );\n\n#if defined(POLARSSL_SSL_PROTO_SSL3) || defined(POLARSSL_SSL_PROTO_TLS1) || \\\n    defined(POLARSSL_SSL_PROTO_TLS1_1)\n    if( ssl-\u003eminor_ver != SSL_MINOR_VERSION_3 )\n    {\n        /*\n         * digitally-signed struct {\n         *     opaque md5_hash[16];\n         *     opaque sha_hash[20];\n         * };\n         *\n         * md5_hash\n         *     MD5(handshake_messages);\n         *\n         * sha_hash\n         *     SHA(handshake_messages);\n         */\n        hashlen = 36;\n        md_alg = POLARSSL_MD_NONE;\n\n        /*\n         * For ECDSA, default hash is SHA-1 only\n         */\n        if( pk_can_do( ssl_own_key( ssl ), POLARSSL_PK_ECDSA ) )\n        {\n            hash_start += 16;\n            hashlen -= 16;\n            md_alg = POLARSSL_MD_SHA1;\n        }\n    }\n    else\n#endif /* POLARSSL_SSL_PROTO_SSL3 || POLARSSL_SSL_PROTO_TLS1 || \\\n          POLARSSL_SSL_PROTO_TLS1_1 */\n#if defined(POLARSSL_SSL_PROTO_TLS1_2)\n    if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_3 )\n    {\n        /*\n         * digitally-signed struct {\n         *     opaque handshake_messages[handshake_messages_length];\n         * };\n         *\n         * Taking shortcut here. We assume that the server always allows the\n         * PRF Hash function and has sent it in the allowed signature\n         * algorithms list received in the Certificate Request message.\n         *\n         * Until we encounter a server that does not, we will take this\n         * shortcut.\n         *\n         * Reason: Otherwise we should have running hashes for SHA512 and SHA224\n         *         in order to satisfy 'weird' needs from the server side.\n         */\n        if( ssl-\u003etransform_negotiate-\u003eciphersuite_info-\u003emac ==\n            POLARSSL_MD_SHA384 )\n        {\n            md_alg = POLARSSL_MD_SHA384;\n            ssl-\u003eout_msg[4] = SSL_HASH_SHA384;\n        }\n        else\n        {\n            md_alg = POLARSSL_MD_SHA256;\n            ssl-\u003eout_msg[4] = SSL_HASH_SHA256;\n        }\n        ssl-\u003eout_msg[5] = ssl_sig_from_pk( ssl_own_key( ssl ) );\n\n        /* Info from md_alg will be used instead */\n        hashlen = 0;\n        offset = 2;\n    }\n    else\n#endif /* POLARSSL_SSL_PROTO_TLS1_2 */\n    {\n        SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( POLARSSL_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( ( ret = pk_sign( ssl_own_key( ssl ), md_alg, hash_start, hashlen,\n                         ssl-\u003eout_msg + 6 + offset, \u0026n,\n                         ssl-\u003ef_rng, ssl-\u003ep_rng ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"pk_sign\", ret );\n        return( ret );\n    }\n\n    ssl-\u003eout_msg[4 + offset] = (unsigned char)( n \u003e\u003e 8 );\n    ssl-\u003eout_msg[5 + offset] = (unsigned char)( n      );\n\n    ssl-\u003eout_msglen  = 6 + n + offset;\n    ssl-\u003eout_msgtype = SSL_MSG_HANDSHAKE;\n    ssl-\u003eout_msg[0]  = SSL_HS_CERTIFICATE_VERIFY;\n\n    ssl-\u003estate++;\n\n    if( ( ret = ssl_write_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_write_record\", ret );\n        return( ret );\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"\u003c= write certificate verify\" ) );\n\n    return( ret );\n}","filepath":"library/ssl_cli.c","line_number":2676,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"505002":{"score":0.60772115,"function_name":"ssl_handshake_server_step","code":"int ssl_handshake_server_step( ssl_context *ssl )\n{\n    int ret = 0;\n\n    if( ssl-\u003estate == SSL_HANDSHAKE_OVER )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    SSL_DEBUG_MSG( 2, ( \"server state: %d\", ssl-\u003estate ) );\n\n    if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n        return( ret );\n\n#if defined(POLARSSL_SSL_PROTO_DTLS)\n    if( ssl-\u003etransport == SSL_TRANSPORT_DATAGRAM \u0026\u0026\n        ssl-\u003ehandshake != NULL \u0026\u0026\n        ssl-\u003ehandshake-\u003eretransmit_state == SSL_RETRANS_SENDING )\n    {\n        if( ( ret = ssl_resend( ssl ) ) != 0 )\n            return( ret );\n    }\n#endif\n\n    switch( ssl-\u003estate )\n    {\n        case SSL_HELLO_REQUEST:\n            ssl-\u003estate = SSL_CLIENT_HELLO;\n            break;\n\n        /*\n         *  \u003c==   ClientHello\n         */\n        case SSL_CLIENT_HELLO:\n            ret = ssl_parse_client_hello( ssl );\n            break;\n\n#if defined(POLARSSL_SSL_PROTO_DTLS)\n        case SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:\n            return( POLARSSL_ERR_SSL_HELLO_VERIFY_REQUIRED );\n#endif\n\n        /*\n         *  ==\u003e   ServerHello\n         *        Certificate\n         *      ( ServerKeyExchange  )\n         *      ( CertificateRequest )\n         *        ServerHelloDone\n         */\n        case SSL_SERVER_HELLO:\n            ret = ssl_write_server_hello( ssl );\n            break;\n\n        case SSL_SERVER_CERTIFICATE:\n            ret = ssl_write_certificate( ssl );\n            break;\n\n        case SSL_SERVER_KEY_EXCHANGE:\n            ret = ssl_write_server_key_exchange( ssl );\n            break;\n\n        case SSL_CERTIFICATE_REQUEST:\n            ret = ssl_write_certificate_request( ssl );\n            break;\n\n        case SSL_SERVER_HELLO_DONE:\n            ret = ssl_write_server_hello_done( ssl );\n            break;\n\n        /*\n         *  \u003c== ( Certificate/Alert  )\n         *        ClientKeyExchange\n         *      ( CertificateVerify  )\n         *        ChangeCipherSpec\n         *        Finished\n         */\n        case SSL_CLIENT_CERTIFICATE:\n            ret = ssl_parse_certificate( ssl );\n            break;\n\n        case SSL_CLIENT_KEY_EXCHANGE:\n            ret = ssl_parse_client_key_exchange( ssl );\n            break;\n\n        case SSL_CERTIFICATE_VERIFY:\n            ret = ssl_parse_certificate_verify( ssl );\n            break;\n\n        case SSL_CLIENT_CHANGE_CIPHER_SPEC:\n            ret = ssl_parse_change_cipher_spec( ssl );\n            break;\n\n        case SSL_CLIENT_FINISHED:\n            ret = ssl_parse_finished( ssl );\n            break;\n\n        /*\n         *  ==\u003e ( NewSessionTicket )\n         *        ChangeCipherSpec\n         *        Finished\n         */\n        case SSL_SERVER_CHANGE_CIPHER_SPEC:\n#if defined(POLARSSL_SSL_SESSION_TICKETS)\n            if( ssl-\u003ehandshake-\u003enew_session_ticket != 0 )\n                ret = ssl_write_new_session_ticket( ssl );\n            else\n#endif\n                ret = ssl_write_change_cipher_spec( ssl );\n            break;\n\n        case SSL_SERVER_FINISHED:\n            ret = ssl_write_finished( ssl );\n            break;\n\n        case SSL_FLUSH_BUFFERS:\n            SSL_DEBUG_MSG( 2, ( \"handshake: done\" ) );\n            ssl-\u003estate = SSL_HANDSHAKE_WRAPUP;\n            break;\n\n        case SSL_HANDSHAKE_WRAPUP:\n            ssl_handshake_wrapup( ssl );\n            break;\n\n        default:\n            SSL_DEBUG_MSG( 1, ( \"invalid state %d\", ssl-\u003estate ) );\n            return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    return( ret );\n}","filepath":"library/ssl_srv.c","line_number":3840,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.4-dtls-preview"},"505447":{"score":0.8537574,"function_name":"mbedtls_x509_get_serial","code":"int mbedtls_x509_get_serial( unsigned char **p, const unsigned char *end,\n                     mbedtls_x509_buf *serial )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    if( ( end - *p ) \u003c 1 )\n        return( MBEDTLS_ERR_X509_INVALID_SERIAL +\n                MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n    if( **p != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_PRIMITIVE | 2 ) \u0026\u0026\n        **p !=   MBEDTLS_ASN1_INTEGER )\n        return( MBEDTLS_ERR_X509_INVALID_SERIAL +\n                MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n\n    serial-\u003etag = *(*p)++;\n\n    if( ( ret = mbedtls_asn1_get_len( p, end, \u0026serial-\u003elen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_SERIAL + ret );\n\n    serial-\u003ep = *p;\n    *p += serial-\u003elen;\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":84,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"505630":{"score":0.50523865,"function_name":"mbedtls_x509_get_alg_null","code":"int mbedtls_x509_get_alg_null( unsigned char **p, const unsigned char *end,\n                       mbedtls_x509_buf *alg )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    if( ( ret = mbedtls_asn1_get_alg_null( p, end, alg ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_ALG + ret );\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":115,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"505698":{"score":0.51806927,"function_name":"mbedtls_x509_get_alg","code":"int mbedtls_x509_get_alg( unsigned char **p, const unsigned char *end,\n                  mbedtls_x509_buf *alg, mbedtls_x509_buf *params )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    if( ( ret = mbedtls_asn1_get_alg( p, end, alg, params ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_ALG + ret );\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":129,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"505766":{"score":0.83362424,"function_name":"x509_get_attr_type_value","code":"static int x509_get_attr_type_value( unsigned char **p,\n                                     const unsigned char *end,\n                                     mbedtls_x509_name *cur )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t len;\n    mbedtls_x509_buf *oid;\n    mbedtls_x509_buf *val;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_NAME + ret );\n\n    end = *p + len;\n\n    if( ( end - *p ) \u003c 1 )\n        return( MBEDTLS_ERR_X509_INVALID_NAME +\n                MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n    oid = \u0026cur-\u003eoid;\n    oid-\u003etag = **p;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026oid-\u003elen, MBEDTLS_ASN1_OID ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_NAME + ret );\n\n    oid-\u003ep = *p;\n    *p += oid-\u003elen;\n\n    if( ( end - *p ) \u003c 1 )\n        return( MBEDTLS_ERR_X509_INVALID_NAME +\n                MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n    if( **p != MBEDTLS_ASN1_BMP_STRING \u0026\u0026 **p != MBEDTLS_ASN1_UTF8_STRING      \u0026\u0026\n        **p != MBEDTLS_ASN1_T61_STRING \u0026\u0026 **p != MBEDTLS_ASN1_PRINTABLE_STRING \u0026\u0026\n        **p != MBEDTLS_ASN1_IA5_STRING \u0026\u0026 **p != MBEDTLS_ASN1_UNIVERSAL_STRING \u0026\u0026\n        **p != MBEDTLS_ASN1_BIT_STRING )\n        return( MBEDTLS_ERR_X509_INVALID_NAME +\n                MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n\n    val = \u0026cur-\u003eval;\n    val-\u003etag = *(*p)++;\n\n    if( ( ret = mbedtls_asn1_get_len( p, end, \u0026val-\u003elen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_NAME + ret );\n\n    val-\u003ep = *p;\n    *p += val-\u003elen;\n\n    if( *p != end )\n    {\n        return( MBEDTLS_ERR_X509_INVALID_NAME +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    cur-\u003enext = NULL;\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":352,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"506236":{"score":0.7917838,"function_name":"mbedtls_x509_get_name","code":"int mbedtls_x509_get_name( unsigned char **p, const unsigned char *end,\n                   mbedtls_x509_name *cur )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t set_len;\n    const unsigned char *end_set;\n\n    /* don't use recursion, we'd risk stack overflow if not optimized */\n    while( 1 )\n    {\n        /*\n         * parse SET\n         */\n        if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026set_len,\n                MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SET ) ) != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_NAME + ret );\n\n        end_set  = *p + set_len;\n\n        while( 1 )\n        {\n            if( ( ret = x509_get_attr_type_value( p, end_set, cur ) ) != 0 )\n                return( ret );\n\n            if( *p == end_set )\n                break;\n\n            /* Mark this item as being no the only one in a set */\n            cur-\u003enext_merged = 1;\n\n            cur-\u003enext = mbedtls_calloc( 1, sizeof( mbedtls_x509_name ) );\n\n            if( cur-\u003enext == NULL )\n                return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n            cur = cur-\u003enext;\n        }\n\n        /*\n         * continue until end of SEQUENCE is reached\n         */\n        if( *p == end )\n            return( 0 );\n\n        cur-\u003enext = mbedtls_calloc( 1, sizeof( mbedtls_x509_name ) );\n\n        if( cur-\u003enext == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n        cur = cur-\u003enext;\n    }\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":434,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"506537":{"score":0.9427087,"function_name":"x509_parse_int","code":"static int x509_parse_int( unsigned char **p, size_t n, int *res )\n{\n    *res = 0;\n\n    for( ; n \u003e 0; --n )\n    {\n        if( ( **p \u003c '0') || ( **p \u003e '9' ) )\n            return ( MBEDTLS_ERR_X509_INVALID_DATE );\n\n        *res *= 10;\n        *res += ( *(*p)++ - '0' );\n    }\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":487,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"506664":{"score":0.8586422,"function_name":"x509_date_is_valid","code":"static int x509_date_is_valid(const mbedtls_x509_time *t )\n{\n    int ret = MBEDTLS_ERR_X509_INVALID_DATE;\n    int month_len;\n\n    CHECK_RANGE( 0, 9999, t-\u003eyear );\n    CHECK_RANGE( 0, 23,   t-\u003ehour );\n    CHECK_RANGE( 0, 59,   t-\u003emin  );\n    CHECK_RANGE( 0, 59,   t-\u003esec  );\n\n    switch( t-\u003emon )\n    {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            month_len = 31;\n            break;\n        case 4: case 6: case 9: case 11:\n            month_len = 30;\n            break;\n        case 2:\n            if( ( !( t-\u003eyear % 4 ) \u0026\u0026 t-\u003eyear % 100 ) ||\n                !( t-\u003eyear % 400 ) )\n                month_len = 29;\n            else\n                month_len = 28;\n            break;\n        default:\n            return( ret );\n    }\n    CHECK_RANGE( 1, month_len, t-\u003eday );\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":503,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"506996":{"score":0.84124124,"function_name":"x509_parse_time","code":"static int x509_parse_time( unsigned char **p, size_t len, size_t yearlen,\n                            mbedtls_x509_time *tm )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    /*\n     * Minimum length is 10 or 12 depending on yearlen\n     */\n    if ( len \u003c yearlen + 8 )\n        return ( MBEDTLS_ERR_X509_INVALID_DATE );\n    len -= yearlen + 8;\n\n    /*\n     * Parse year, month, day, hour, minute\n     */\n    CHECK( x509_parse_int( p, yearlen, \u0026tm-\u003eyear ) );\n    if ( 2 == yearlen )\n    {\n        if ( tm-\u003eyear \u003c 50 )\n            tm-\u003eyear += 100;\n\n        tm-\u003eyear += 1900;\n    }\n\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003emon ) );\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003eday ) );\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003ehour ) );\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003emin ) );\n\n    /*\n     * Parse seconds if present\n     */\n    if ( len \u003e= 2 )\n    {\n        CHECK( x509_parse_int( p, 2, \u0026tm-\u003esec ) );\n        len -= 2;\n    }\n    else\n        return ( MBEDTLS_ERR_X509_INVALID_DATE );\n\n    /*\n     * Parse trailing 'Z' if present\n     */\n    if ( 1 == len \u0026\u0026 'Z' == **p )\n    {\n        (*p)++;\n        len--;\n    }\n\n    /*\n     * We should have parsed all characters at this point\n     */\n    if ( 0 != len )\n        return ( MBEDTLS_ERR_X509_INVALID_DATE );\n\n    CHECK( x509_date_is_valid( tm ) );\n\n    return ( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":540,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"507406":{"score":0.8175564,"function_name":"mbedtls_x509_get_time","code":"int mbedtls_x509_get_time( unsigned char **p, const unsigned char *end,\n                           mbedtls_x509_time *tm )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t len, year_len;\n    unsigned char tag;\n\n    if( ( end - *p ) \u003c 1 )\n        return( MBEDTLS_ERR_X509_INVALID_DATE +\n                MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n    tag = **p;\n\n    if( tag == MBEDTLS_ASN1_UTC_TIME )\n        year_len = 2;\n    else if( tag == MBEDTLS_ASN1_GENERALIZED_TIME )\n        year_len = 4;\n    else\n        return( MBEDTLS_ERR_X509_INVALID_DATE +\n                MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );\n\n    (*p)++;\n    ret = mbedtls_asn1_get_len( p, end, \u0026len );\n\n    if( ret != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_DATE + ret );\n\n    return x509_parse_time( p, len, year_len, tm );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":605,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"507622":{"score":0.8110539,"function_name":"mbedtls_x509_get_sig","code":"int mbedtls_x509_get_sig( unsigned char **p, const unsigned char *end, mbedtls_x509_buf *sig )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t len;\n    int tag_type;\n\n    if( ( end - *p ) \u003c 1 )\n        return( MBEDTLS_ERR_X509_INVALID_SIGNATURE +\n                MBEDTLS_ERR_ASN1_OUT_OF_DATA );\n\n    tag_type = **p;\n\n    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, \u0026len ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_SIGNATURE + ret );\n\n    sig-\u003etag = tag_type;\n    sig-\u003elen = len;\n    sig-\u003ep = *p;\n\n    *p += len;\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":635,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"507818":{"score":0.7155012,"function_name":"mbedtls_x509_get_sig_alg","code":"int mbedtls_x509_get_sig_alg( const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params,\n                      mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg,\n                      void **sig_opts )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    if( *sig_opts != NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    if( ( ret = mbedtls_oid_get_sig_alg( sig_oid, md_alg, pk_alg ) ) != 0 )\n        return( MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + ret );\n\n#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)\n    if( *pk_alg == MBEDTLS_PK_RSASSA_PSS )\n    {\n        mbedtls_pk_rsassa_pss_options *pss_opts;\n\n        pss_opts = mbedtls_calloc( 1, sizeof( mbedtls_pk_rsassa_pss_options ) );\n        if( pss_opts == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n\n        ret = mbedtls_x509_get_rsassa_pss_params( sig_params,\n                                          md_alg,\n                                          \u0026pss_opts-\u003emgf1_hash_id,\n                                          \u0026pss_opts-\u003eexpected_salt_len );\n        if( ret != 0 )\n        {\n            mbedtls_free( pss_opts );\n            return( ret );\n        }\n\n        *sig_opts = (void *) pss_opts;\n    }\n    else\n#endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */\n    {\n        /* Make sure parameters are absent or NULL */\n        if( ( sig_params-\u003etag != MBEDTLS_ASN1_NULL \u0026\u0026 sig_params-\u003etag != 0 ) ||\n              sig_params-\u003elen != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_ALG );\n    }\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":662,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"507938":{"score":0.8028004,"function_name":"mbedtls_x509_get_ext","code":"int mbedtls_x509_get_ext( unsigned char **p, const unsigned char *end,\n                  mbedtls_x509_buf *ext, int tag )\n{\n    int ret;\n    size_t len;\n\n    if( *p == end )\n        return( 0 );\n\n    ext-\u003etag = **p;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026ext-\u003elen,\n            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | tag ) ) != 0 )\n        return( ret );\n\n    ext-\u003ep = *p;\n    end = *p + ext-\u003elen;\n\n    /*\n     * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n     *\n     * Extension  ::=  SEQUENCE  {\n     *      extnID      OBJECT IDENTIFIER,\n     *      critical    BOOLEAN DEFAULT FALSE,\n     *      extnValue   OCTET STRING  }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( end != *p + len )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":628,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"beta-oob-2"},"508179":{"score":0.80517054,"function_name":"mbedtls_x509_dn_gets","code":"int mbedtls_x509_dn_gets( char *buf, size_t size, const mbedtls_x509_name *dn )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t i, n;\n    unsigned char c, merge = 0;\n    const mbedtls_x509_name *name;\n    const char *short_name = NULL;\n    char s[MBEDTLS_X509_MAX_DN_NAME_SIZE], *p;\n\n    memset( s, 0, sizeof( s ) );\n\n    name = dn;\n    p = buf;\n    n = size;\n\n    while( name != NULL )\n    {\n        if( !name-\u003eoid.p )\n        {\n            name = name-\u003enext;\n            continue;\n        }\n\n        if( name != dn )\n        {\n            ret = mbedtls_snprintf( p, n, merge ? \" + \" : \", \" );\n            MBEDTLS_X509_SAFE_SNPRINTF;\n        }\n\n        ret = mbedtls_oid_get_attr_short_name( \u0026name-\u003eoid, \u0026short_name );\n\n        if( ret == 0 )\n            ret = mbedtls_snprintf( p, n, \"%s=\", short_name );\n        else\n            ret = mbedtls_snprintf( p, n, \"\\?\\?=\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        for( i = 0; i \u003c name-\u003eval.len; i++ )\n        {\n            if( i \u003e= sizeof( s ) - 1 )\n                break;\n\n            c = name-\u003eval.p[i];\n            if( c \u003c 32 || c == 127 || ( c \u003e 128 \u0026\u0026 c \u003c 160 ) )\n                 s[i] = '?';\n            else s[i] = c;\n        }\n        s[i] = '\\0';\n        ret = mbedtls_snprintf( p, n, \"%s\", s );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n\n        merge = name-\u003enext_merged;\n        name = name-\u003enext;\n    }\n\n    return( (int) ( size - n ) );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":747,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"508990":{"score":0.80106205,"function_name":"mbedtls_x509_serial_gets","code":"int mbedtls_x509_serial_gets( char *buf, size_t size, const mbedtls_x509_buf *serial )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t i, n, nr;\n    char *p;\n\n    p = buf;\n    n = size;\n\n    nr = ( serial-\u003elen \u003c= 32 )\n        ? serial-\u003elen  : 28;\n\n    for( i = 0; i \u003c nr; i++ )\n    {\n        if( i == 0 \u0026\u0026 nr \u003e 1 \u0026\u0026 serial-\u003ep[i] == 0x0 )\n            continue;\n\n        ret = mbedtls_snprintf( p, n, \"%02X%s\",\n                serial-\u003ep[i], ( i \u003c nr - 1 ) ? \":\" : \"\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n    }\n\n    if( nr != serial-\u003elen )\n    {\n        ret = mbedtls_snprintf( p, n, \"....\" );\n        MBEDTLS_X509_SAFE_SNPRINTF;\n    }\n\n    return( (int) ( size - n ) );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":809,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"509505":{"score":0.8007277,"function_name":"mbedtls_x509_key_size_helper","code":"int mbedtls_x509_key_size_helper( char *buf, size_t buf_size, const char *name )\n{\n    char *p = buf;\n    size_t n = buf_size;\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n    ret = mbedtls_snprintf( p, n, \"%s key size\", name );\n    MBEDTLS_X509_SAFE_SNPRINTF;\n\n    return( 0 );\n}","filepath":"openvpn/src/main/cpp/mbedtls/library/x509.c","line_number":888,"entry_url":"https://github.com/ProtonVPN/android-app.git","slot_name":"2.6.91.0"},"509646":{"score":0.88148665,"function_name":"_iot_dump_create_dump_state","code":"static struct iot_dump_state* _iot_dump_create_dump_state(struct iot_context *iot_ctx)\n{\n    struct iot_dump_state* dump_state;\n    struct timeval time;\n\n    IOT_INFO(\"log version : %x\", IOT_DUMP_LOG_VERSION);\n\n    dump_state = iot_os_malloc(sizeof(struct iot_dump_state));\n    if (!dump_state) {\n        IOT_ERROR(\"failed to malloc for evt_data\");\n        return NULL;\n    }\n    memset(dump_state, 0, sizeof(struct iot_dump_state));\n\n    dump_state-\u003estdk_version_code = STDK_VERSION_CODE;\n    dump_state-\u003eclock_time = clock();\n    COPY_STR_TO_BYTE(dump_state-\u003eos_name, iot_os_get_os_name(), sizeof(dump_state-\u003eos_name));\n    COPY_STR_TO_BYTE(dump_state-\u003eos_version, iot_os_get_os_version_string(), sizeof(dump_state-\u003eos_version));\n    COPY_STR_TO_BYTE(dump_state-\u003ebsp_name, iot_bsp_get_bsp_name(), sizeof(dump_state-\u003ebsp_name));\n    COPY_STR_TO_BYTE(dump_state-\u003ebsp_version, iot_bsp_get_bsp_version_string(), sizeof(dump_state-\u003ebsp_version));\n\n    gettimeofday(\u0026time, NULL);\n    dump_state-\u003elog_time = time.tv_sec;\n\n    if (iot_ctx) {\n        dump_state-\u003esequence_number = iot_ctx-\u003eevent_sequence_num;\n\n        COPY_STR_TO_BYTE(dump_state-\u003edevice_id, iot_ctx-\u003eiot_reg_data.deviceId,\n                sizeof(dump_state-\u003edevice_id));\n\n        if (iot_ctx-\u003edevconf.dip) {\n            memcpy(dump_state-\u003edip_id, iot_ctx-\u003edevconf.dip-\u003edip_id.id,\n                    sizeof(dump_state-\u003edip_id));\n\n            dump_state-\u003edip_version =\n                    ((iot_ctx-\u003edevconf.dip-\u003edip_major_version \u0026 0xffff) \u003c\u003c 16)\n                            | (iot_ctx-\u003edevconf.dip-\u003edip_minor_version \u0026 0xffff);\n        }\n        if (iot_ctx-\u003edevice_info.firmware_version) {\n            COPY_STR_TO_BYTE(dump_state-\u003efirmware_version, iot_ctx-\u003edevice_info.firmware_version,\n                    sizeof(dump_state-\u003efirmware_version));\n        }\n        if (iot_ctx-\u003edevice_info.model_number) {\n            COPY_STR_TO_BYTE(dump_state-\u003emodel_number, iot_ctx-\u003edevice_info.model_number,\n                    sizeof(dump_state-\u003emodel_number));\n        }\n        if (iot_ctx-\u003edevice_info.manufacturer_name) {\n            COPY_STR_TO_BYTE(dump_state-\u003emanufacturer_name, iot_ctx-\u003edevice_info.manufacturer_name,\n                    sizeof(dump_state-\u003emanufacturer_name));\n        }\n\n        dump_state-\u003emqtt_connection_success_count = iot_ctx-\u003emqtt_connection_success_count;\n        dump_state-\u003emqtt_connection_try_count = iot_ctx-\u003emqtt_connection_try_count;\n    }\n    return dump_state;\n}","filepath":"src/iot_dump_log.c","line_number":36,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"510715":{"score":0.93615055,"function_name":"_iot_dump_create_header","code":"static struct iot_dump_header* _iot_dump_create_header()\n{\n    struct iot_dump_header* header;\n    header = iot_os_malloc(sizeof(struct iot_dump_header));\n    if (!header) {\n        IOT_ERROR(\"failed to malloc for header_line of dump\");\n        return NULL;\n    }\n    memset(header, 0, sizeof(struct iot_dump_header));\n\n    header-\u003emagic_number = IOT_DUMP_MAGIC_NUMBER;\n    header-\u003elog_version = IOT_DUMP_LOG_VERSION;\n    header-\u003edump_state_size = sizeof(struct iot_dump_state);\n\n    return header;\n}","filepath":"src/iot_dump_log.c","line_number":93,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"510853":{"score":0.9000437,"function_name":"_iot_dump_copy_memory","code":"static iot_error_t _iot_dump_copy_memory(void *dest, int dest_size, const void *src, int src_size,\n        void *buf, int buf_size, int *remain_number, int *written_len, int need_base64)\n{\n    size_t pre_out_len = 0;\n    size_t main_out_len = 0;\n    size_t pre_copy_len = 0;\n    size_t main_copy_len = 0;\n    iot_error_t iot_err = IOT_ERROR_NONE;\n\n    if ((!written_len) || (!dest) || (!src) || (dest_size \u003c= 0) || (src_size \u003c= 0) || (buf_size \u003c 3))\n        return IOT_ERROR_BAD_REQ;\n\n    *written_len = 0;\n\n    if (src_size \u003e dest_size)\n        src_size = dest_size;\n\n    if (!need_base64) {\n        memcpy(dest, src, src_size);\n        *written_len = src_size;\n        return IOT_ERROR_NONE;\n    }\n    //Step1: old 'remain' bytes and new (3-'remain') bytes are combined to 3bytes, and converted to base64\n    if (*remain_number \u003e 0) {\n        pre_copy_len = 3 - *remain_number;\n        memcpy(buf + *remain_number, src, pre_copy_len);\n        iot_err = iot_security_base64_encode(buf, 3, dest, dest_size, \u0026pre_out_len);\n        if (iot_err \u003c 0) {\n            return iot_err;\n        }\n        memset(buf, 0, 3);\n        *written_len = pre_out_len;\n    }\n    //Step2: convert multiples of 3 bytes\n    *remain_number = (src_size - pre_copy_len) % 3;\n    main_copy_len = GET_LARGEST_MULTIPLE(src_size - pre_copy_len, 3);\n    if (main_copy_len \u003e 0) {\n        iot_err = iot_security_base64_encode(src + pre_copy_len, main_copy_len, dest + pre_out_len,\n                                             dest_size - pre_out_len, \u0026main_out_len);\n        if (iot_err \u003c 0) {\n            return iot_err;\n        }\n    }\n    //Step3: save unconverted remain bytes to buf\n    memcpy(buf, src + pre_copy_len + main_copy_len, *remain_number);\n    *written_len = pre_out_len + main_out_len;\n    return iot_err;\n}","filepath":"src/iot_dump_log.c","line_number":110,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"511394":{"score":0.86174333,"function_name":"st_create_log_dump","code":"int st_create_log_dump(IOT_CTX *iot_ctx, char **log_dump_output, size_t max_log_dump_size, size_t *allocated_size, int log_mode)\n{\n    struct iot_dump_header* header;\n    struct iot_dump_state* dump_state;\n    struct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n    char temp_buf[IOT_DUMP_BUFFER_SIZE] = \"\";\n    char *all_log_dump;\n    int remain_number = 0;\n    int written_len = 0;\n\n    size_t max_msg_size = 0;\n    size_t min_log_size = 0;\n    size_t output_log_size = 0;\n    size_t stored_log_size = 0;\n    size_t curr_size = 0;\n\n    int need_base64 = log_mode \u0026 IOT_DUMP_MODE_NEED_BASE64;\n    int need_dump_state = log_mode \u0026 IOT_DUMP_MODE_NEED_DUMP_STATE;\n\n    size_t iot_dump_state_size = sizeof(struct iot_dump_state);\n\n    iot_error_t iot_err = IOT_ERROR_NONE;\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n    size_t msg_size;\n    iot_log_file_handle_t *logfile;\n#endif\n\n    if (!need_dump_state) {\n        iot_dump_state_size = 0;\n    }\n\n    if (need_base64) {\n        min_log_size = IOT_SECURITY_B64_ENCODE_LEN(sizeof(struct iot_dump_header) + iot_dump_state_size);\n    } else {\n        min_log_size = sizeof(struct iot_dump_header) + iot_dump_state_size;\n    }\n    if (max_log_dump_size \u003c min_log_size) {\n        IOT_ERROR(\"input log size is smaller than minimum log size\");\n        return IOT_ERROR_BAD_REQ;\n    }\n\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE_RAM_ONLY)\n    logfile = iot_log_file_open(\u0026stored_log_size, RAM_ONLY);\n#elif defined(CONFIG_STDK_IOT_CORE_LOG_FILE_FLASH_WITH_RAM)\n    logfile = iot_log_file_open(\u0026stored_log_size, FLASH_WITH_RAM);\n#else\n#error \"Need to choice STDK_IOT_CORE_LOG_FILE_TYPE first\"\n#endif\n    if (!logfile) {\n        IOT_ERROR(\"fail to open log file\");\n        return IOT_ERROR_BAD_REQ;\n    }\n#endif\n\n    if (need_base64) {\n        max_msg_size = (max_log_dump_size - 1) / 4 * 3 - sizeof(struct iot_dump_header) - iot_dump_state_size;\n    } else {\n        max_msg_size = max_log_dump_size - sizeof(struct iot_dump_header) - iot_dump_state_size;\n    }\n    if (max_msg_size \u003e stored_log_size)\n        max_msg_size = stored_log_size;\n    max_msg_size = GET_LARGEST_MULTIPLE(max_msg_size, IOT_DUMP_LOG_MSG_LINE_LENGTH);\n\n    if (need_base64) {\n        output_log_size = IOT_SECURITY_B64_ENCODE_LEN(max_msg_size + sizeof(struct iot_dump_header) + iot_dump_state_size);\n    } else {\n        output_log_size = max_msg_size + sizeof(struct iot_dump_header) + iot_dump_state_size;\n    }\n\n    all_log_dump = iot_os_malloc(output_log_size);\n    if (!all_log_dump) {\n        IOT_ERROR(\"failed to malloc for all_log_dump\");\n        iot_err = IOT_ERROR_MEM_ALLOC;\n        goto end;\n    }\n    memset(all_log_dump, 0, output_log_size);\n\n    header = _iot_dump_create_header();\n    if (!need_dump_state) {\n        header-\u003edump_state_size = 0;\n    }\n    iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                header, sizeof(struct iot_dump_header), temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n    iot_os_free(header);\n    if (iot_err \u003c 0) {\n        IOT_ERROR(\"failed to get header for all_log_dump : ret %d\", iot_err);\n        goto end;\n    }\n    curr_size += written_len;\n\n    if (need_dump_state) {\n        dump_state = _iot_dump_create_dump_state(ctx);\n        iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                    dump_state, sizeof(struct iot_dump_state), temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n        iot_os_free(dump_state);\n        if (iot_err \u003c 0) {\n            IOT_ERROR(\"failed to get dump_state for all_log_dump : ret %d\", iot_err);\n            goto end;\n        }\n        curr_size += written_len;\n    }\n\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n    if (logfile) {\n        iot_log_file_seek(logfile, 0 - max_msg_size, logfile-\u003etail_addr);\n\n        while (max_msg_size) {\n            msg_size = sizeof(temp_buf) - remain_number;\n            if (msg_size \u003e max_msg_size)\n                msg_size = max_msg_size;\n\n            iot_log_file_read(logfile, temp_buf + remain_number, msg_size, \u0026msg_size);\n\n            max_msg_size -= msg_size;\n            msg_size += remain_number;\n            remain_number = 0;\n\n            iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                    temp_buf, msg_size, temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n            if (iot_err \u003c 0) {\n                IOT_ERROR(\"failed to get log msg for all_log_dump : ret %d\", iot_err);\n                goto end;\n            }\n            curr_size += written_len;\n        }\n        iot_log_file_close(logfile);\n    }\n#endif\n\n    if (remain_number) {\n        memset(temp_buf + remain_number, 0, 3 - remain_number);\n        iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                temp_buf, 3 - remain_number, temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n        if (iot_err \u003c 0) {\n            IOT_ERROR(\"failed to get remain character for all_log_dump : ret %d\", iot_err);\n            goto end;\n        }\n        curr_size += written_len;\n    }\n\n    if (allocated_size)\n        *allocated_size = output_log_size;\n    *log_dump_output = all_log_dump;\n    return iot_err;\n\nend:\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n    if (logfile) {\n        iot_log_file_close(logfile);\n    }\n#endif\n    if (all_log_dump)\n        iot_os_free(all_log_dump);\n    if (allocated_size)\n        *allocated_size = 0;\n    *log_dump_output = NULL;\n    return iot_err;\n}","filepath":"src/iot_dump_log.c","line_number":159,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"512550":{"score":0.84131014,"function_name":"is_header_content_length","code":"static bool is_header_content_length(char *header_key)\n{\n\tint i;\n\tsize_t len;\n\n\tconst char content_length_lower[] = \"content-length\";\n\tlen = strlen(content_length_lower);\n\n\tif (!header_key) {\n\t\treturn false;\n\t}\n\n\tif (strlen(header_key) != len) {\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i \u003c len; i++) {\n\t\tif (content_length_lower[i] != (char)tolower((int)header_key[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}","filepath":"src/easysetup/http/iot_easysetup_http_parser.c","line_number":41,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"512773":{"score":0.8571446,"function_name":"es_msg_parser","code":"iot_error_t es_msg_parser(char *rx_buffer, size_t rx_buffer_len, char **payload, int *cmd, int *type, size_t *content_len)\n{\n\t// Client request\n\tchar *method = NULL; // \"GET\" or \"POST\"\n\tchar *uri = NULL; // \"/index.html\" things before '?'\n\tchar *prot = NULL; // \"HTTP/1.1\"\n\n\tif ((rx_buffer == NULL) || (cmd == NULL) || (type == NULL))\n\t{\n\t\tIOT_ERROR(\"invalid data format!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tmethod = strtok(rx_buffer, \" \\t\\r\\n\");\n\turi = strtok(NULL, \" \\t\");\n\tprot = strtok(NULL, \" \\t\\r\\n\");\n\n\tif ((method == NULL) || (uri == NULL) || (prot == NULL))\n\t{\n\t\tIOT_ERROR(\"invalid data reported\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!strcmp(method,  \"GET\")) {\n\t\t*type = D2D_GET;\n\t\tif (!strcmp(uri, IOT_ES_URI_GET_DEVICEINFO)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_DEVICEINFO;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_GET_WIFISCANINFO)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_WIFISCANINFO;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_GET_LOGS_SYSTEMINFO)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_LOG_SYSTEMINFO;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_GET_LOGS_DUMP)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_LOG_GET_DUMP;\n\t\t} else {\n\t\t\tIOT_ERROR(\"[GET] invalid step : %s\", uri);\n\t\t\t*cmd = IOT_EASYSETUP_INVALID_STEP;\n\t\t}\n\t} else if (!strcmp(method,  \"POST\")) {\n\t\tint post_content_len = -1;\n\t\theader_t *p_hdr = reqhdr;\n\t\tchar *p_body = NULL;\n\n\t\twhile (p_hdr \u003c reqhdr + MAX_HEADER_SUPPORT) {\n\t\t\tchar *key, *value;\n\n\t\t\tkey = strtok(NULL, \"\\r\\n: \\t\");\n\t\t\tif (!key)\n\t\t\t\tbreak;\n\n\t\t\tvalue = strtok(NULL, \"\\r\\n\");\n\t\t\tif (!value)\n\t\t\t\tbreak;\n\n\t\t\twhile (*value \u0026\u0026 *value == ' ')\n\t\t\t\tvalue++;\n\n\t\t\tp_hdr-\u003ename = key;\n\t\t\tp_hdr-\u003evalue = value;\n\t\t\tif (is_header_content_length(p_hdr-\u003ename)) {\n\t\t\t\tchar *p_end;\n\t\t\t\tlong val;\n\t\t\t\tval = strtol(p_hdr-\u003evalue, \u0026p_end, 10);\n\t\t\t\tif (val == LONG_MAX || val == LONG_MIN || p_hdr-\u003evalue == p_end) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpost_content_len = (int) val;\n\t\t\t}\n\t\t\tp_hdr++;\n\n\t\t\tp_body = value + strlen(value);\n\t\t\tif (p_body[1] == '\\n' \u0026\u0026 p_body[2] == '\\r' \u0026\u0026 p_body[3] == '\\n') {\n\t\t\t\t// end of header\n\t\t\t\tp_body += 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (p_body == NULL || post_content_len \u003c 0) {\n\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t}\n\n\t\tif (post_content_len == 0) {\n\t\t\t*payload = NULL;\n\t\t} else {\n\t\t\tp_body++;\n\t\t\tif ((p_body) \u003c (rx_buffer + rx_buffer_len)) {\n\t\t\t\t*payload = p_body;\n\t\t\t\t*content_len = post_content_len;\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"[POST] out-of-range\");\n\t\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t\t}\n\t\t}\n\t\t*type = D2D_POST;\n\t\tif (!strcmp(uri, IOT_ES_URI_POST_KEYINFO)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_KEYINFO;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_POST_CONFIRMINFO)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_CONFIRMINFO;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_POST_CONFIRM)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_CONFIRM;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_POST_WIFIPROVISIONINGINFO)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_POST_SETUPCOMPLETE)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_SETUPCOMPLETE;\n\t\t} else if (!strcmp(uri, IOT_ES_URI_POST_LOGS)) {\n\t\t\t*cmd = IOT_EASYSETUP_STEP_LOG_CREATE_DUMP;\n\t\t} else {\n\t\t\tIOT_ERROR(\"[POST] invalid step : %s\", uri);\n\t\t\t*cmd = IOT_EASYSETUP_INVALID_STEP;\n\t\t}\n\t\tIOT_DEBUG(\"payload : %s\", payload);\n\t} else {\n\t\tIOT_ERROR(\"[%s] not support type : %s\", prot, method);\n\t\t*type = D2D_ERROR;\n\t}\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/easysetup/http/iot_easysetup_http_parser.c","line_number":66,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"514140":{"score":0.7101177,"function_name":"is_http_conn_handle_initialized","code":"bool is_http_conn_handle_initialized(HTTP_CONN_H *handle)\n{\n\tif ((handle == NULL) || (handle-\u003eaccept_sock == CONN_HANDLE_UNINITIALIZED) ||\n\t\t\t(handle-\u003elisten_sock == CONN_HANDLE_UNINITIALIZED)) {\n\t\treturn false;\n\t}\n\treturn true;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":23,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514194":{"score":0.8397397,"function_name":"http_cleanup_all_connection","code":"void http_cleanup_all_connection(HTTP_CONN_H *handle)\n{\n\tif (handle == NULL) {\n\t\treturn;\n\t}\n\n\tif (handle-\u003elisten_sock != CONN_HANDLE_UNINITIALIZED) {\n\t\tIOT_INFO(\"close listen socket\");\n\t\tclose(handle-\u003elisten_sock);\n\t\thandle-\u003elisten_sock = CONN_HANDLE_UNINITIALIZED;\n\t}\n\n\t// if http deinit before ST app reset tcp connection, we need close it here\n\tif (handle-\u003eaccept_sock != CONN_HANDLE_UNINITIALIZED) {\n\t\tIOT_INFO(\"close accept socket\");\n\t\tclose(handle-\u003eaccept_sock);\n\t\thandle-\u003eaccept_sock = CONN_HANDLE_UNINITIALIZED;\n\t}\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":32,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514377":{"score":0.8487347,"function_name":"http_cleanup_accepted_connection","code":"void http_cleanup_accepted_connection(HTTP_CONN_H *handle)\n{\n\tif (handle == NULL) {\n\t\treturn;\n\t}\n\tif (handle-\u003eaccept_sock != CONN_HANDLE_UNINITIALIZED) {\n\t\tIOT_INFO(\"close accept socket\");\n\t\tclose(handle-\u003eaccept_sock);\n\t\thandle-\u003eaccept_sock = CONN_HANDLE_UNINITIALIZED;\n\t}\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":52,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514484":{"score":0.92674625,"function_name":"http_packet_send","code":"ssize_t http_packet_send(HTTP_CONN_H *handle, char *tx_buffer, size_t tx_buffer_len)\n{\n\tint len;\n\n\tif (handle == NULL || is_http_conn_handle_initialized(handle) == false) {\n\t\treturn -1;\n\t}\n\tif (tx_buffer == NULL) {\n\t\treturn -1;\n\t}\n\n\tlen = send(handle-\u003eaccept_sock, tx_buffer, tx_buffer_len, 0);\n\treturn len;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":64,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514580":{"score":0.90291363,"function_name":"http_packet_read","code":"iot_error_t http_packet_read(HTTP_CONN_H *handle, char *rx_buffer, size_t rx_buffer_size, size_t *received_len,\n\t\t\t\t\t\t\t size_t *http_header_len)\n{\n\tssize_t len;\n\tsize_t existing_len;\n\tint header_position = -1;\n\tint i;\n\n\tif (handle == NULL || rx_buffer == NULL || received_len == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\texisting_len = *received_len;\n\t// ensure complete http request header before es_msg_parser\n\tdo {\n\t\tlen = recv(handle-\u003eaccept_sock, rx_buffer + existing_len, rx_buffer_size - existing_len - 1, 0);\n\t\tif (len \u003c 0) {\n\t\t\tif (!is_es_http_deinit_processing()) {\n\t\t\t\tIOT_ERROR(\"recv failed: errno %d\", errno);\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_RECV_FAIL, errno);\n\t\t\t}\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_RECV_FAIL;\n\t\t}\n\t\telse if (len == 0) {\n\t\t\tIOT_WARN(\"peer connection closed\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_EASYSETUP_SOCKET_CON_CLOSE, 0);\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED;\n\t\t}\n\t\telse {\n\t\t\texisting_len += len;\n\t\t}\n\n\t\t// \\r\\n\\r\\n  header end\n\t\tfor (i = 0; i \u003c existing_len; i++) {\n\t\t\tif (i \u003c existing_len - 3) {\n\t\t\t\tif ((rx_buffer[i] == '\\r') \u0026\u0026 (rx_buffer[i + 1] == '\\n') \u0026\u0026 (rx_buffer[i + 2] == '\\r')\n\t\t\t\t\t\u0026\u0026 (rx_buffer[i + 3] == '\\n')) {\n\t\t\t\t\theader_position = i + 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (header_position \u003c 0);\n\n\t*received_len = existing_len;\n\t*http_header_len = header_position;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":79,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514960":{"score":0.89694715,"function_name":"http_packet_read_remaining","code":"iot_error_t http_packet_read_remaining(HTTP_CONN_H *handle, char *rx_buffer, size_t rx_buffer_size, size_t offset,\n\t\t\t\t\t\t\t\t\t   size_t expected_len)\n{\n\tssize_t len;\n\tsize_t total_recv_len = offset;\n\n\tif (handle == NULL || rx_buffer == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tdo {\n\t\tlen = recv(handle-\u003eaccept_sock, rx_buffer + offset, rx_buffer_size - offset - 1, 0);\n\t\tif (len \u003c 0) {\n\t\t\tIOT_ERROR(\"recv failed: errno %d\", errno);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_RECV_FAIL, errno);\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_RECV_FAIL;\n\t\t}\n\t\telse if (len == 0) {\n\t\t\tIOT_ERROR(\"peer connection closed\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_CON_CLOSE, 0);\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED;\n\t\t}\n\t\telse {\n\t\t\ttotal_recv_len += len;\n\t\t}\n\t} while (total_recv_len \u003c expected_len);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":128,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"515185":{"score":0.9047053,"function_name":"http_try_configure_connection","code":"void http_try_configure_connection(HTTP_CONN_H *handle)\n{\n\tint ret;\n\n\tif (handle == NULL || is_http_conn_handle_initialized(handle) == false) {\n\t\treturn;\n\t}\n\t// set tcp keepalive related opts\n\t// if ST app WiFi disconnect coincidentally during easysetup,\n\t// we need short time tcp keepalive here.\n\tint keep_alive = 1;\n\tret = setsockopt(handle-\u003eaccept_sock, SOL_SOCKET, SO_KEEPALIVE, \u0026keep_alive, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-alive failed %d\", errno);\n\t}\n\n\tint idle = 10;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_KEEPIDLE, \u0026idle, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-idle failed %d\", errno);\n\t}\n\n\tint interval = 5;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_KEEPINTVL, \u0026interval, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-interval failed %d\", errno);\n\t}\n\n\tint maxpkt = 3;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_KEEPCNT, \u0026maxpkt, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-count failed %d\", errno);\n\t}\n\n\t// HTTP response as tcp payload is sent once, and mostly less than MTU.\n\t// There is no need for tcp packet coalesced.\n\t// To enhance throughput, disable TCP Nagle's algorithm here.\n\tint no_delay = 1;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_NODELAY, \u0026no_delay, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set no-delay failed %d\", errno);\n\t}\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":157,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"515732":{"score":0.79703844,"function_name":"http_initialize_connection","code":"iot_error_t http_initialize_connection(HTTP_CONN_H *handle)\n{\n\tint addr_family, ip_protocol, ret;\n\tint opt = 1;\n\tstruct sockaddr_in destAddr;\n\tdestAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tdestAddr.sin_family = AF_INET;\n\tdestAddr.sin_port = htons(HTTP_PORT);\n\taddr_family = AF_INET;\n\tip_protocol = IPPROTO_IP;\n\tint listen_sock;\n\n\tif (handle == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\thandle-\u003elisten_sock = CONN_HANDLE_UNINITIALIZED;\n\thandle-\u003eaccept_sock = CONN_HANDLE_UNINITIALIZED;\n\n\tlisten_sock = socket(addr_family, SOCK_STREAM, ip_protocol);\n\tif (listen_sock \u003c 0) {\n\t\tIOT_ERROR(\"Unable to create socket: errno %d\", errno);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_CREATE_FAIL, errno);\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\n\tret = setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, \u0026opt, sizeof(opt));\n\tif (ret != 0) {\n\t\tIOT_INFO(\"reuse socket isn't supported\");\n\t}\n\n\tret = bind(listen_sock, (struct sockaddr *)\u0026destAddr, sizeof(destAddr));\n\tif (ret != 0) {\n\t\tIOT_ERROR(\"Socket unable to bind: errno %d\", errno);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_BIND_FAIL, errno);\n\t\tclose(listen_sock);\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\n\tret = listen(listen_sock, 1);\n\tif (ret != 0) {\n\t\tIOT_ERROR(\"Error occurred during listen: errno %d\", errno);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_LISTEN_FAIL, errno);\n\t\tclose(listen_sock);\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\n\thandle-\u003elisten_sock = listen_sock;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":201,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"516247":{"score":0.9103902,"function_name":"http_accept_connection","code":"iot_error_t http_accept_connection(HTTP_CONN_H *handle)\n{\n\tstruct sockaddr_in source_addr;\n\tuint addr_len;\n\tint sock;\n\n\tif (handle == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\taddr_len = sizeof(source_addr);\n\n\tsock = accept(handle-\u003elisten_sock, (struct sockaddr *)\u0026source_addr, \u0026addr_len);\n\tif (sock \u003c 0) {\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\thandle-\u003eaccept_sock = sock;\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":253,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"516383":{"score":0.6936523,"function_name":"_iot_security_be_bsp_fs_storage_id2target","code":"STATIC_FUNCTION\niot_security_storage_target_t _iot_security_be_bsp_fs_storage_id2target(iot_security_storage_id_t storage_id)\n{\n\tif (storage_id == IOT_NVD_UNKNOWN) {\n\t\treturn IOT_SECURITY_STORAGE_TARGET_UNKNOWN;\n\t}\n\n\tif (storage_id \u003c IOT_NVD_FACTORY) {\n\t\treturn IOT_SECURITY_STORAGE_TARGET_NV;\n\t}\n\n\tif (storage_id \u003c IOT_NVD_MAX) {\n#if defined(CONFIG_STDK_IOT_CORE_SUPPORT_STNV_PARTITION)\n\t\treturn IOT_SECURITY_STORAGE_TARGET_FACTORY;\n#else\n\t\treturn IOT_SECURITY_STORAGE_TARGET_DI;\n#endif\n\t}\n\n\treturn IOT_SECURITY_STORAGE_TARGET_UNKNOWN;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":34,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"516442":{"score":0.89142823,"function_name":"_iot_security_be_bsp_fs_storage_id2filename","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_storage_id2filename(iot_security_storage_id_t storage_id, char *filename, size_t filename_len)\n{\n\tconst char *storage_file;\n\tconst char *extra_path = (const char *)IOT_SECURITY_STORAGE_EXTRA_PATH;\n\tint c = 0;\n\n\tif (!filename || (filename_len == 0)) {\n\t\tIOT_ERROR(\"filename is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_ARGS, 0);\n\t}\n\n\tstorage_file = iot_bsp_nv_get_data_path(storage_id);\n\tif (!storage_file) {\n\t\tIOT_ERROR(\"not found file for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_INVALID_ID, storage_id);\n\t}\n\n\tif (extra_path) {\n\t\tc = snprintf(filename, filename_len, \"%s/\", extra_path);\n\t}\n\n\tif (filename_len \u003c strlen(storage_file) + c) {\n\t\tIOT_ERROR(\"length is not enough (%d \u003c (%d + %d)\", (int)filename_len, strlen(storage_file), c);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_BUFFER, filename_len);\n\t}\n\n\tsnprintf(filename + c, filename_len - c, \"%s\", storage_file);\n\n\tIOT_DEBUG(\"storage file = '%s'\", filename);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":56,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"516777":{"score":0.85150236,"function_name":"_iot_security_be_bsp_fs_load_from_nv","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_load_from_nv(iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_bsp_fs_handle_t handle;\n\tchar filename[IOT_SECURITY_STORAGE_FILENAME_MAX_LEN];\n\tchar *fs_buf;\n\tsize_t fs_buf_len;\n\tunsigned char *realloc_buf;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\terr = _iot_security_be_bsp_fs_storage_id2filename(storage_id, filename, sizeof(filename));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (storage_id \u003e= IOT_NVD_FACTORY) {\n#if defined(CONFIG_STDK_IOT_CORE_SUPPORT_STNV_PARTITION)\n\t\terr = iot_bsp_fs_open_from_stnv(filename, \u0026handle);\n\t\tif (err) {\n\t\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\t\terr = IOT_ERROR_SECURITY_FS_NOT_FOUND;\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open_from_stnv(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_NOT_FOUND, err);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open_from_stnv(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, err);\n\t\t\t}\n\t\t}\n#else\n\t\tIOT_ERROR(\"not defined factory partition\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, 0);\n#endif\n\t} else {\n\t\terr = iot_bsp_fs_open(filename, FS_READONLY, \u0026handle);\n\t\tif (err) {\n\t\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\t\terr = IOT_ERROR_SECURITY_FS_NOT_FOUND;\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_NOT_FOUND, err);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, err);\n\t\t\t}\n\t\t}\n\t}\n\n\tfs_buf_len = IOT_SECURITY_STORAGE_BUF_MAX_LEN;\n\tfs_buf = (char *)iot_os_malloc(fs_buf_len);\n\tif (!fs_buf) {\n\t\tIOT_ERROR(\"failed to malloc for fs buf\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\terr = iot_bsp_fs_read(handle, fs_buf, \u0026fs_buf_len);\n\tif (err) {\n\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\terr = IOT_ERROR_SECURITY_FS_NOT_FOUND;\n\t\t} else {\n\t\t\tIOT_ERROR(\"iot_bsp_fs_read = %d\", err);\n\t\t\terr = IOT_ERROR_SECURITY_FS_READ;\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\t}\n\n\t\tiot_os_free(fs_buf);\n\t\t(void)iot_bsp_fs_close(handle);\n\n\t\treturn err;\n\t}\n\n\trealloc_buf = (unsigned char *)iot_os_realloc(fs_buf, fs_buf_len + 1);\n\tif (realloc_buf) {\n\t\trealloc_buf[fs_buf_len] = '\\0';\n\t\toutput_buf-\u003ep = realloc_buf;\n\t\toutput_buf-\u003elen = fs_buf_len;\n\t} else {\n\t\tIOT_ERROR(\"failed to realloc for buf\");\n\t\tiot_os_free(fs_buf);\n\t\t(void)iot_bsp_fs_close(handle);\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\terr = iot_bsp_fs_close(handle);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_close = %d\", err);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_CLOSE, err);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"517744":{"score":0.9010416,"function_name":"_iot_security_be_bsp_fs_load","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_load(iot_security_be_context_t *be_context, iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\tif (!be_context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_CONTEXT_NULL, 0);\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_ARGS, 0);\n\t}\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tstorage_target = _iot_security_be_bsp_fs_storage_id2target(storage_id);\n\n\tswitch (storage_target) {\n\tcase IOT_SECURITY_STORAGE_TARGET_NV:\n\tcase IOT_SECURITY_STORAGE_TARGET_FACTORY:\n\t\treturn _iot_security_be_bsp_fs_load_from_nv(storage_id, output_buf);\n\tcase IOT_SECURITY_STORAGE_TARGET_DI:\n\t\tif (!be_context-\u003eexternal_device_info_cb) {\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(BE_EXTERNAL_NULL, 0);\n\t\t}\n\t\treturn be_context-\u003eexternal_device_info_cb(storage_id, output_buf);\n\tdefault:\n\t\tIOT_ERROR(\"cannot found target for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_UNKNOWN_TARGET, 0);\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":182,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"517998":{"score":0.832927,"function_name":"_iot_security_be_bsp_fs_store_to_nv","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_store_to_nv(iot_security_storage_id_t storage_id, iot_security_buffer_t *input_buf)\n{\n\tiot_error_t err;\n\tiot_bsp_fs_handle_t handle;\n\tchar filename[IOT_SECURITY_STORAGE_FILENAME_MAX_LEN];\n\n\terr = _iot_security_be_bsp_fs_storage_id2filename(storage_id, filename, sizeof(filename));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_bsp_fs_open(filename, FS_READWRITE, \u0026handle);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_open(%s) = %d\", filename, err);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, err);\n\t}\n\n\terr = iot_bsp_fs_write(handle, (const char *)input_buf-\u003ep, (unsigned int)input_buf-\u003elen);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_write = %d\", err);\n\t\t(void)iot_bsp_fs_close(handle);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_WRITE, err);\n\t}\n\n\terr = iot_bsp_fs_close(handle);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_close = %d\", err);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_CLOSE, err);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":217,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"518491":{"score":0.90764415,"function_name":"_iot_security_be_bsp_fs_store","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_store(iot_security_be_context_t *be_context, iot_security_storage_id_t storage_id, iot_security_buffer_t *input_buf)\n{\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_ARGS, 0);\n\t}\n\n\tstorage_target = _iot_security_be_bsp_fs_storage_id2target(storage_id);\n\n\tswitch (storage_target) {\n\tcase IOT_SECURITY_STORAGE_TARGET_NV:\n\t\treturn _iot_security_be_bsp_fs_store_to_nv(storage_id, input_buf);\n\tcase IOT_SECURITY_STORAGE_TARGET_FACTORY:\n\t\tIOT_ERROR(\"cannot update factory nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tcase IOT_SECURITY_STORAGE_TARGET_DI:\n\t\tIOT_ERROR(\"cannot update device info nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tdefault:\n\t\tIOT_ERROR(\"cannot found target for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_UNKNOWN_TARGET, storage_id);\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":251,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"518790":{"score":0.891624,"function_name":"_iot_security_be_bsp_fs_remove_from_nv","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_remove_from_nv(iot_security_storage_id_t storage_id)\n{\n\tiot_error_t err;\n\tchar filename[IOT_SECURITY_STORAGE_FILENAME_MAX_LEN];\n\n\terr = _iot_security_be_bsp_fs_storage_id2filename(storage_id, filename, sizeof(filename));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_bsp_fs_remove(filename);\n\tif (err) {\n\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_NOT_FOUND, 0);\n\t\t} else {\n\t\t\tIOT_ERROR(\"iot_bsp_fs_remove = %d\", err);\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_REMOVE, err);\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":280,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"518966":{"score":0.9098779,"function_name":"_iot_security_be_bsp_fs_remove","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_remove(iot_security_be_context_t *be_context, iot_security_storage_id_t storage_id)\n{\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\tstorage_target = _iot_security_be_bsp_fs_storage_id2target(storage_id);\n\n\tswitch (storage_target) {\n\tcase IOT_SECURITY_STORAGE_TARGET_NV:\n\t\treturn _iot_security_be_bsp_fs_remove_from_nv(storage_id);\n\tcase IOT_SECURITY_STORAGE_TARGET_FACTORY:\n\t\tIOT_ERROR(\"cannot remove factory nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tcase IOT_SECURITY_STORAGE_TARGET_DI:\n\t\tIOT_ERROR(\"cannot remove device info nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tdefault:\n\t\tIOT_ERROR(\"cannot found target for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_UNKNOWN_TARGET, storage_id);\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":304,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"519185":{"score":0.6674719,"function_name":"iot_security_be_bsp_init","code":"iot_error_t iot_security_be_bsp_init(iot_security_be_context_t *be_context)\n{\n\tif (!be_context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_CONTEXT_NULL, 0);\n\t}\n\n\tbe_context-\u003ebsp_fn = \u0026iot_security_be_software_bsp_funcs;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":334,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"519345":{"score":0.7553441,"function_name":"chacha_keysetup","code":"static void\nchacha_keysetup(chacha_ctx *ctx, const uint8_t *k)\n{\n    ctx-\u003einput[0]  = U32C(0x61707865);\n    ctx-\u003einput[1]  = U32C(0x3320646e);\n    ctx-\u003einput[2]  = U32C(0x79622d32);\n    ctx-\u003einput[3]  = U32C(0x6b206574);\n    ctx-\u003einput[4]  = LOAD32_LE(k + 0);\n    ctx-\u003einput[5]  = LOAD32_LE(k + 4);\n    ctx-\u003einput[6]  = LOAD32_LE(k + 8);\n    ctx-\u003einput[7]  = LOAD32_LE(k + 12);\n    ctx-\u003einput[8]  = LOAD32_LE(k + 16);\n    ctx-\u003einput[9]  = LOAD32_LE(k + 20);\n    ctx-\u003einput[10] = LOAD32_LE(k + 24);\n    ctx-\u003einput[11] = LOAD32_LE(k + 28);\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":44,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"519607":{"score":0.70666146,"function_name":"chacha_ivsetup","code":"static void\nchacha_ivsetup(chacha_ctx *ctx, const uint8_t *iv, const uint8_t *counter)\n{\n    ctx-\u003einput[12] = counter == NULL ? 0 : LOAD32_LE(counter + 0);\n    ctx-\u003einput[13] = counter == NULL ? 0 : LOAD32_LE(counter + 4);\n    ctx-\u003einput[14] = LOAD32_LE(iv + 0);\n    ctx-\u003einput[15] = LOAD32_LE(iv + 4);\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":61,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"519748":{"score":0.7338085,"function_name":"chacha_ietf_ivsetup","code":"static void\nchacha_ietf_ivsetup(chacha_ctx *ctx, const u8 *iv, const u8 *counter)\n{\n    ctx-\u003einput[12] = counter == NULL ? 0 : U8TO32_LITTLE(counter);\n    ctx-\u003einput[13] = U8TO32_LITTLE(iv + 0);\n    ctx-\u003einput[14] = U8TO32_LITTLE(iv + 4);\n    ctx-\u003einput[15] = U8TO32_LITTLE(iv + 8);\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/stream_chacha20_ref.c","line_number":94,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.8"},"519876":{"score":0.7237949,"function_name":"chacha20_encrypt_bytes","code":"static void\nchacha20_encrypt_bytes(chacha_ctx *ctx, const uint8_t *m, uint8_t *c,\n                       unsigned long long bytes)\n{\n    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,\n        x15;\n    uint32_t j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14,\n        j15;\n    uint8_t     *ctarget = NULL;\n    uint8_t      tmp[64];\n    unsigned int i;\n\n    if (!bytes) {\n        return; /* LCOV_EXCL_LINE */\n    }\n    if (bytes \u003e 64ULL * (1ULL \u003c\u003c 32) - 64ULL) {\n        abort();\n    }\n    j0  = ctx-\u003einput[0];\n    j1  = ctx-\u003einput[1];\n    j2  = ctx-\u003einput[2];\n    j3  = ctx-\u003einput[3];\n    j4  = ctx-\u003einput[4];\n    j5  = ctx-\u003einput[5];\n    j6  = ctx-\u003einput[6];\n    j7  = ctx-\u003einput[7];\n    j8  = ctx-\u003einput[8];\n    j9  = ctx-\u003einput[9];\n    j10 = ctx-\u003einput[10];\n    j11 = ctx-\u003einput[11];\n    j12 = ctx-\u003einput[12];\n    j13 = ctx-\u003einput[13];\n    j14 = ctx-\u003einput[14];\n    j15 = ctx-\u003einput[15];\n\n    for (;;) {\n        if (bytes \u003c 64) {\n            memset(tmp, 0, 64);\n            for (i = 0; i \u003c bytes; ++i) {\n                tmp[i] = m[i];\n            }\n            m       = tmp;\n            ctarget = c;\n            c       = tmp;\n        }\n        x0  = j0;\n        x1  = j1;\n        x2  = j2;\n        x3  = j3;\n        x4  = j4;\n        x5  = j5;\n        x6  = j6;\n        x7  = j7;\n        x8  = j8;\n        x9  = j9;\n        x10 = j10;\n        x11 = j11;\n        x12 = j12;\n        x13 = j13;\n        x14 = j14;\n        x15 = j15;\n        for (i = 20; i \u003e 0; i -= 2) {\n            QUARTERROUND(x0, x4, x8, x12)\n            QUARTERROUND(x1, x5, x9, x13)\n            QUARTERROUND(x2, x6, x10, x14)\n            QUARTERROUND(x3, x7, x11, x15)\n            QUARTERROUND(x0, x5, x10, x15)\n            QUARTERROUND(x1, x6, x11, x12)\n            QUARTERROUND(x2, x7, x8, x13)\n            QUARTERROUND(x3, x4, x9, x14)\n        }\n        x0  = PLUS(x0, j0);\n        x1  = PLUS(x1, j1);\n        x2  = PLUS(x2, j2);\n        x3  = PLUS(x3, j3);\n        x4  = PLUS(x4, j4);\n        x5  = PLUS(x5, j5);\n        x6  = PLUS(x6, j6);\n        x7  = PLUS(x7, j7);\n        x8  = PLUS(x8, j8);\n        x9  = PLUS(x9, j9);\n        x10 = PLUS(x10, j10);\n        x11 = PLUS(x11, j11);\n        x12 = PLUS(x12, j12);\n        x13 = PLUS(x13, j13);\n        x14 = PLUS(x14, j14);\n        x15 = PLUS(x15, j15);\n\n        x0  = XOR(x0, LOAD32_LE(m + 0));\n        x1  = XOR(x1, LOAD32_LE(m + 4));\n        x2  = XOR(x2, LOAD32_LE(m + 8));\n        x3  = XOR(x3, LOAD32_LE(m + 12));\n        x4  = XOR(x4, LOAD32_LE(m + 16));\n        x5  = XOR(x5, LOAD32_LE(m + 20));\n        x6  = XOR(x6, LOAD32_LE(m + 24));\n        x7  = XOR(x7, LOAD32_LE(m + 28));\n        x8  = XOR(x8, LOAD32_LE(m + 32));\n        x9  = XOR(x9, LOAD32_LE(m + 36));\n        x10 = XOR(x10, LOAD32_LE(m + 40));\n        x11 = XOR(x11, LOAD32_LE(m + 44));\n        x12 = XOR(x12, LOAD32_LE(m + 48));\n        x13 = XOR(x13, LOAD32_LE(m + 52));\n        x14 = XOR(x14, LOAD32_LE(m + 56));\n        x15 = XOR(x15, LOAD32_LE(m + 60));\n\n        j12 = PLUSONE(j12);\n        /* LCOV_EXCL_START */\n        if (!j12) {\n            j13 = PLUSONE(j13);\n        }\n        /* LCOV_EXCL_STOP */\n\n        STORE32_LE(c + 0, x0);\n        STORE32_LE(c + 4, x1);\n        STORE32_LE(c + 8, x2);\n        STORE32_LE(c + 12, x3);\n        STORE32_LE(c + 16, x4);\n        STORE32_LE(c + 20, x5);\n        STORE32_LE(c + 24, x6);\n        STORE32_LE(c + 28, x7);\n        STORE32_LE(c + 32, x8);\n        STORE32_LE(c + 36, x9);\n        STORE32_LE(c + 40, x10);\n        STORE32_LE(c + 44, x11);\n        STORE32_LE(c + 48, x12);\n        STORE32_LE(c + 52, x13);\n        STORE32_LE(c + 56, x14);\n        STORE32_LE(c + 60, x15);\n\n        if (bytes \u003c= 64) {\n            if (bytes \u003c 64) {\n                for (i = 0; i \u003c (unsigned int) bytes; ++i) {\n                    ctarget[i] = c[i]; /* ctarget cannot be NULL */\n                }\n            }\n            ctx-\u003einput[12] = j12;\n            ctx-\u003einput[13] = j13;\n\n            return;\n        }\n        bytes -= 64;\n        c += 64;\n        m += 64;\n    }\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":79,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"523204":{"score":0.76298743,"function_name":"stream_ref","code":"static int\nstream_ref(unsigned char *c, unsigned long long clen, const unsigned char *n,\n           const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n\n    if (!clen) {\n        return 0;\n    }\n    COMPILER_ASSERT(crypto_stream_chacha20_KEYBYTES == 256 / 8);\n    chacha_keysetup(\u0026ctx, k);\n    chacha_ivsetup(\u0026ctx, n, NULL);\n    memset(c, 0, clen);\n    chacha20_encrypt_bytes(\u0026ctx, c, c, clen);\n    sodium_memzero(\u0026ctx, sizeof ctx);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":225,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"523422":{"score":0.74807286,"function_name":"stream_vec","code":"static int\nstream_vec(unsigned char *c, unsigned long long clen,\n           const unsigned char *n, const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n\n    if (!clen) {\n        return 0;\n    }\n    (void) sizeof(int[crypto_stream_chacha20_KEYBYTES == 256 / 8 ? 1 : -1]);\n    chacha_keysetup(\u0026ctx, k);\n    chacha_ivsetup(\u0026ctx, n, 0ULL);\n    memset(c, 0, clen);\n    chacha_encrypt_bytes(\u0026ctx, c, c, clen);\n    sodium_memzero(\u0026ctx, sizeof ctx);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/chacha20/vec/stream_chacha20_vec.c","line_number":245,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.7"},"523640":{"score":0.67070985,"function_name":"stream_ietf_ref_xor_ic","code":"static int\nstream_ietf_ref_xor_ic(unsigned char *c, const unsigned char *m,\n                       unsigned long long mlen, const unsigned char *n,\n                       uint32_t ic, const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n    uint8_t           ic_bytes[4];\n\n    if (!mlen) {\n        return 0;\n    }\n    STORE32_LE(ic_bytes, ic);\n    chacha_keysetup(\u0026ctx, k);\n    chacha_ietf_ivsetup(\u0026ctx, n, ic_bytes);\n    chacha20_encrypt_bytes(\u0026ctx, m, c, mlen);\n    sodium_memzero(\u0026ctx, sizeof ctx);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":288,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"523970":{"score":0.7983475,"function_name":"stream_vec_xor_ic","code":"static int\nstream_vec_xor_ic(unsigned char *c, const unsigned char *m,\n                  unsigned long long mlen,\n                  const unsigned char *n, uint64_t ic,\n                  const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n\n    if (!mlen) {\n        return 0;\n    }\n    chacha_keysetup(\u0026ctx, k);\n    chacha_ivsetup(\u0026ctx, n, ic);\n    chacha_encrypt_bytes(\u0026ctx, m, c, mlen);\n    sodium_memzero(\u0026ctx, sizeof ctx);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/chacha20/vec/stream_chacha20_vec.c","line_number":283,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.7"},"524191":{"score":0.75451636,"function_name":"sodium_init","code":"int\nsodium_init(void)\n{\n    if (sodium_crit_enter() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    if (initialized != 0) {\n        if (sodium_crit_leave() != 0) {\n            return -1; /* LCOV_EXCL_LINE */\n        }\n        return 1;\n    }\n    _sodium_runtime_get_cpu_features();\n    randombytes_stir();\n    _sodium_alloc_init();\n    _crypto_pwhash_argon2_pick_best_implementation();\n    _crypto_generichash_blake2b_pick_best_implementation();\n    _crypto_onetimeauth_poly1305_pick_best_implementation();\n    _crypto_scalarmult_curve25519_pick_best_implementation();\n    _crypto_stream_chacha20_pick_best_implementation();\n    _crypto_stream_salsa20_pick_best_implementation();\n    initialized = 1;\n    if (sodium_crit_leave() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/sodium/core.c","line_number":27,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"524380":{"score":0.8376474,"function_name":"sodium_misuse","code":"void\nsodium_misuse(void)\n{\n    void (*handler)(void);\n\n    (void) sodium_crit_leave();\n    if (sodium_crit_enter() == 0) {\n        handler = _misuse_handler;\n        if (handler != NULL) {\n            handler();\n        }\n    }\n/* LCOV_EXCL_START */\n    abort();\n}","filepath":"src/libsodium/sodium/core.c","line_number":186,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"524437":{"score":0.7919216,"function_name":"sodium_set_misuse_handler","code":"int\nsodium_set_misuse_handler(void (*handler)(void))\n{\n    if (sodium_crit_enter() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    _misuse_handler = handler;\n    if (sodium_crit_leave() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/sodium/core.c","line_number":203,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"525292":{"score":0.89814484,"function_name":"fe_neg","code":"static void\nfe_neg(fe h, const fe f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t h0 = -f0;\n    int32_t h1 = -f1;\n    int32_t h2 = -f2;\n    int32_t h3 = -f3;\n    int32_t h4 = -f4;\n    int32_t h5 = -f5;\n    int32_t h6 = -f6;\n    int32_t h7 = -f7;\n    int32_t h8 = -f8;\n    int32_t h9 = -f9;\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n    h[5] = h5;\n    h[6] = h6;\n    h[7] = h7;\n    h[8] = h8;\n    h[9] = h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":762,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"525545":{"score":0.85648024,"function_name":"fe25519_cmov","code":"static void\nfe25519_cmov(fe25519 f, const fe25519 g, unsigned int b)\n{\n    const uint64_t mask = (uint64_t) (-(int64_t) b);\n\n    uint64_t f0 = f[0];\n    uint64_t f1 = f[1];\n    uint64_t f2 = f[2];\n    uint64_t f3 = f[3];\n    uint64_t f4 = f[4];\n\n    uint64_t x0 = f0 ^ g[0];\n    uint64_t x1 = f1 ^ g[1];\n    uint64_t x2 = f2 ^ g[2];\n    uint64_t x3 = f3 ^ g[3];\n    uint64_t x4 = f4 ^ g[4];\n\n    x0 \u0026= mask;\n    x1 \u0026= mask;\n    x2 \u0026= mask;\n    x3 \u0026= mask;\n    x4 \u0026= mask;\n\n    f[0] = f0 ^ x0;\n    f[1] = f1 ^ x1;\n    f[2] = f2 ^ x2;\n    f[3] = f3 ^ x3;\n    f[4] = f4 ^ x4;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_51.h","line_number":108,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"526690":{"score":0.7271893,"function_name":"fe25519_copy","code":"static inline void\nfe25519_copy(fe25519 h, const fe25519 f)\n{\n    uint64_t f0 = f[0];\n    uint64_t f1 = f[1];\n    uint64_t f2 = f[2];\n    uint64_t f3 = f[3];\n    uint64_t f4 = f[4];\n\n    h[0] = f0;\n    h[1] = f1;\n    h[2] = f2;\n    h[3] = f3;\n    h[4] = f4;\n}","filepath":"third_party/heimdal/lib/hcrypto/x25519/ed25519_ref10_fe_51.h","line_number":212,"entry_url":"git://git.samba.org/samba.git","slot_name":"tdb-1.4.6"},"526905":{"score":0.48816353,"function_name":"fe25519_getparity","code":"unsigned char fe25519_getparity(const fe25519 *x)\n{\n  fe25519 t;\n  int i;\n  for(i=0;i\u003c32;i++) t.v[i] = x-\u003ev[i];\n  freeze(\u0026t);\n  return t.v[0] \u0026 1;\n}","filepath":"src/libsodium/crypto_sign/edwards25519sha512batch/ref/fe25519_edwards25519sha512batch.c","line_number":124,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.4"},"527077":{"score":0.81709933,"function_name":"fe25519_mul","code":"static void\nfe25519_mul(fe25519 h, const fe25519 f, const fe25519 g)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t g0 = g[0];\n    int32_t g1 = g[1];\n    int32_t g2 = g[2];\n    int32_t g3 = g[3];\n    int32_t g4 = g[4];\n    int32_t g5 = g[5];\n    int32_t g6 = g[6];\n    int32_t g7 = g[7];\n    int32_t g8 = g[8];\n    int32_t g9 = g[9];\n\n    int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */\n    int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */\n    int32_t g3_19 = 19 * g3;\n    int32_t g4_19 = 19 * g4;\n    int32_t g5_19 = 19 * g5;\n    int32_t g6_19 = 19 * g6;\n    int32_t g7_19 = 19 * g7;\n    int32_t g8_19 = 19 * g8;\n    int32_t g9_19 = 19 * g9;\n    int32_t f1_2  = 2 * f1;\n    int32_t f3_2  = 2 * f3;\n    int32_t f5_2  = 2 * f5;\n    int32_t f7_2  = 2 * f7;\n    int32_t f9_2  = 2 * f9;\n\n    int64_t f0g0    = f0 * (int64_t) g0;\n    int64_t f0g1    = f0 * (int64_t) g1;\n    int64_t f0g2    = f0 * (int64_t) g2;\n    int64_t f0g3    = f0 * (int64_t) g3;\n    int64_t f0g4    = f0 * (int64_t) g4;\n    int64_t f0g5    = f0 * (int64_t) g5;\n    int64_t f0g6    = f0 * (int64_t) g6;\n    int64_t f0g7    = f0 * (int64_t) g7;\n    int64_t f0g8    = f0 * (int64_t) g8;\n    int64_t f0g9    = f0 * (int64_t) g9;\n    int64_t f1g0    = f1 * (int64_t) g0;\n    int64_t f1g1_2  = f1_2 * (int64_t) g1;\n    int64_t f1g2    = f1 * (int64_t) g2;\n    int64_t f1g3_2  = f1_2 * (int64_t) g3;\n    int64_t f1g4    = f1 * (int64_t) g4;\n    int64_t f1g5_2  = f1_2 * (int64_t) g5;\n    int64_t f1g6    = f1 * (int64_t) g6;\n    int64_t f1g7_2  = f1_2 * (int64_t) g7;\n    int64_t f1g8    = f1 * (int64_t) g8;\n    int64_t f1g9_38 = f1_2 * (int64_t) g9_19;\n    int64_t f2g0    = f2 * (int64_t) g0;\n    int64_t f2g1    = f2 * (int64_t) g1;\n    int64_t f2g2    = f2 * (int64_t) g2;\n    int64_t f2g3    = f2 * (int64_t) g3;\n    int64_t f2g4    = f2 * (int64_t) g4;\n    int64_t f2g5    = f2 * (int64_t) g5;\n    int64_t f2g6    = f2 * (int64_t) g6;\n    int64_t f2g7    = f2 * (int64_t) g7;\n    int64_t f2g8_19 = f2 * (int64_t) g8_19;\n    int64_t f2g9_19 = f2 * (int64_t) g9_19;\n    int64_t f3g0    = f3 * (int64_t) g0;\n    int64_t f3g1_2  = f3_2 * (int64_t) g1;\n    int64_t f3g2    = f3 * (int64_t) g2;\n    int64_t f3g3_2  = f3_2 * (int64_t) g3;\n    int64_t f3g4    = f3 * (int64_t) g4;\n    int64_t f3g5_2  = f3_2 * (int64_t) g5;\n    int64_t f3g6    = f3 * (int64_t) g6;\n    int64_t f3g7_38 = f3_2 * (int64_t) g7_19;\n    int64_t f3g8_19 = f3 * (int64_t) g8_19;\n    int64_t f3g9_38 = f3_2 * (int64_t) g9_19;\n    int64_t f4g0    = f4 * (int64_t) g0;\n    int64_t f4g1    = f4 * (int64_t) g1;\n    int64_t f4g2    = f4 * (int64_t) g2;\n    int64_t f4g3    = f4 * (int64_t) g3;\n    int64_t f4g4    = f4 * (int64_t) g4;\n    int64_t f4g5    = f4 * (int64_t) g5;\n    int64_t f4g6_19 = f4 * (int64_t) g6_19;\n    int64_t f4g7_19 = f4 * (int64_t) g7_19;\n    int64_t f4g8_19 = f4 * (int64_t) g8_19;\n    int64_t f4g9_19 = f4 * (int64_t) g9_19;\n    int64_t f5g0    = f5 * (int64_t) g0;\n    int64_t f5g1_2  = f5_2 * (int64_t) g1;\n    int64_t f5g2    = f5 * (int64_t) g2;\n    int64_t f5g3_2  = f5_2 * (int64_t) g3;\n    int64_t f5g4    = f5 * (int64_t) g4;\n    int64_t f5g5_38 = f5_2 * (int64_t) g5_19;\n    int64_t f5g6_19 = f5 * (int64_t) g6_19;\n    int64_t f5g7_38 = f5_2 * (int64_t) g7_19;\n    int64_t f5g8_19 = f5 * (int64_t) g8_19;\n    int64_t f5g9_38 = f5_2 * (int64_t) g9_19;\n    int64_t f6g0    = f6 * (int64_t) g0;\n    int64_t f6g1    = f6 * (int64_t) g1;\n    int64_t f6g2    = f6 * (int64_t) g2;\n    int64_t f6g3    = f6 * (int64_t) g3;\n    int64_t f6g4_19 = f6 * (int64_t) g4_19;\n    int64_t f6g5_19 = f6 * (int64_t) g5_19;\n    int64_t f6g6_19 = f6 * (int64_t) g6_19;\n    int64_t f6g7_19 = f6 * (int64_t) g7_19;\n    int64_t f6g8_19 = f6 * (int64_t) g8_19;\n    int64_t f6g9_19 = f6 * (int64_t) g9_19;\n    int64_t f7g0    = f7 * (int64_t) g0;\n    int64_t f7g1_2  = f7_2 * (int64_t) g1;\n    int64_t f7g2    = f7 * (int64_t) g2;\n    int64_t f7g3_38 = f7_2 * (int64_t) g3_19;\n    int64_t f7g4_19 = f7 * (int64_t) g4_19;\n    int64_t f7g5_38 = f7_2 * (int64_t) g5_19;\n    int64_t f7g6_19 = f7 * (int64_t) g6_19;\n    int64_t f7g7_38 = f7_2 * (int64_t) g7_19;\n    int64_t f7g8_19 = f7 * (int64_t) g8_19;\n    int64_t f7g9_38 = f7_2 * (int64_t) g9_19;\n    int64_t f8g0    = f8 * (int64_t) g0;\n    int64_t f8g1    = f8 * (int64_t) g1;\n    int64_t f8g2_19 = f8 * (int64_t) g2_19;\n    int64_t f8g3_19 = f8 * (int64_t) g3_19;\n    int64_t f8g4_19 = f8 * (int64_t) g4_19;\n    int64_t f8g5_19 = f8 * (int64_t) g5_19;\n    int64_t f8g6_19 = f8 * (int64_t) g6_19;\n    int64_t f8g7_19 = f8 * (int64_t) g7_19;\n    int64_t f8g8_19 = f8 * (int64_t) g8_19;\n    int64_t f8g9_19 = f8 * (int64_t) g9_19;\n    int64_t f9g0    = f9 * (int64_t) g0;\n    int64_t f9g1_38 = f9_2 * (int64_t) g1_19;\n    int64_t f9g2_19 = f9 * (int64_t) g2_19;\n    int64_t f9g3_38 = f9_2 * (int64_t) g3_19;\n    int64_t f9g4_19 = f9 * (int64_t) g4_19;\n    int64_t f9g5_38 = f9_2 * (int64_t) g5_19;\n    int64_t f9g6_19 = f9 * (int64_t) g6_19;\n    int64_t f9g7_38 = f9_2 * (int64_t) g7_19;\n    int64_t f9g8_19 = f9 * (int64_t) g8_19;\n    int64_t f9g9_38 = f9_2 * (int64_t) g9_19;\n\n    int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 +\n                 f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;\n    int64_t h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 +\n                 f7g4_19 + f8g3_19 + f9g2_19;\n    int64_t h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 +\n                 f7g5_38 + f8g4_19 + f9g3_38;\n    int64_t h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 +\n                 f7g6_19 + f8g5_19 + f9g4_19;\n    int64_t h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 +\n                 f7g7_38 + f8g6_19 + f9g5_38;\n    int64_t h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 +\n                 f8g7_19 + f9g6_19;\n    int64_t h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 +\n                 f7g9_38 + f8g8_19 + f9g7_38;\n    int64_t h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 +\n                 f8g9_19 + f9g8_19;\n    int64_t h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 +\n                 f8g0 + f9g9_38;\n    int64_t h9 =\n        f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    /*\n     |h0| \u003c= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))\n     i.e. |h0| \u003c= 1.4*2^60; narrower ranges for h2, h4, h6, h8\n     |h1| \u003c= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))\n     i.e. |h1| \u003c= 1.7*2^59; narrower ranges for h3, h5, h7, h9\n     */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25 */\n    /* |h4| \u003c= 2^25 */\n    /* |h1| \u003c= 1.71*2^59 */\n    /* |h5| \u003c= 1.71*2^59 */\n\n    carry1 = (h1 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h1| \u003c= 2^24; from now on fits into int32 */\n    /* |h5| \u003c= 2^24; from now on fits into int32 */\n    /* |h2| \u003c= 1.41*2^60 */\n    /* |h6| \u003c= 1.41*2^60 */\n\n    carry2 = (h2 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h2| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h6| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h3| \u003c= 1.71*2^59 */\n    /* |h7| \u003c= 1.71*2^59 */\n\n    carry3 = (h3 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h3| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h7| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h4| \u003c= 1.72*2^34 */\n    /* |h8| \u003c= 1.41*2^60 */\n\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h4| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h8| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h5| \u003c= 1.01*2^24 */\n    /* |h9| \u003c= 1.71*2^59 */\n\n    carry9 = (h9 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h0 += carry9 * 19;\n    h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h9| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h0| \u003c= 1.1*2^39 */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h1| \u003c= 1.01*2^24 */\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_25_5.h","line_number":367,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"536928":{"score":0.78099793,"function_name":"fe_sq","code":"void fe_sq(fe h,fe f)\n{\n  crypto_int32 f0 = f[0];\n  crypto_int32 f1 = f[1];\n  crypto_int32 f2 = f[2];\n  crypto_int32 f3 = f[3];\n  crypto_int32 f4 = f[4];\n  crypto_int32 f5 = f[5];\n  crypto_int32 f6 = f[6];\n  crypto_int32 f7 = f[7];\n  crypto_int32 f8 = f[8];\n  crypto_int32 f9 = f[9];\n  crypto_int32 f0_2 = 2 * f0;\n  crypto_int32 f1_2 = 2 * f1;\n  crypto_int32 f2_2 = 2 * f2;\n  crypto_int32 f3_2 = 2 * f3;\n  crypto_int32 f4_2 = 2 * f4;\n  crypto_int32 f5_2 = 2 * f5;\n  crypto_int32 f6_2 = 2 * f6;\n  crypto_int32 f7_2 = 2 * f7;\n  crypto_int32 f5_38 = 38 * f5; /* 1.31*2^30 */\n  crypto_int32 f6_19 = 19 * f6; /* 1.31*2^30 */\n  crypto_int32 f7_38 = 38 * f7; /* 1.31*2^30 */\n  crypto_int32 f8_19 = 19 * f8; /* 1.31*2^30 */\n  crypto_int32 f9_38 = 38 * f9; /* 1.31*2^30 */\n  crypto_int64 f0f0    = f0   * (crypto_int64) f0;\n  crypto_int64 f0f1_2  = f0_2 * (crypto_int64) f1;\n  crypto_int64 f0f2_2  = f0_2 * (crypto_int64) f2;\n  crypto_int64 f0f3_2  = f0_2 * (crypto_int64) f3;\n  crypto_int64 f0f4_2  = f0_2 * (crypto_int64) f4;\n  crypto_int64 f0f5_2  = f0_2 * (crypto_int64) f5;\n  crypto_int64 f0f6_2  = f0_2 * (crypto_int64) f6;\n  crypto_int64 f0f7_2  = f0_2 * (crypto_int64) f7;\n  crypto_int64 f0f8_2  = f0_2 * (crypto_int64) f8;\n  crypto_int64 f0f9_2  = f0_2 * (crypto_int64) f9;\n  crypto_int64 f1f1_2  = f1_2 * (crypto_int64) f1;\n  crypto_int64 f1f2_2  = f1_2 * (crypto_int64) f2;\n  crypto_int64 f1f3_4  = f1_2 * (crypto_int64) f3_2;\n  crypto_int64 f1f4_2  = f1_2 * (crypto_int64) f4;\n  crypto_int64 f1f5_4  = f1_2 * (crypto_int64) f5_2;\n  crypto_int64 f1f6_2  = f1_2 * (crypto_int64) f6;\n  crypto_int64 f1f7_4  = f1_2 * (crypto_int64) f7_2;\n  crypto_int64 f1f8_2  = f1_2 * (crypto_int64) f8;\n  crypto_int64 f1f9_76 = f1_2 * (crypto_int64) f9_38;\n  crypto_int64 f2f2    = f2   * (crypto_int64) f2;\n  crypto_int64 f2f3_2  = f2_2 * (crypto_int64) f3;\n  crypto_int64 f2f4_2  = f2_2 * (crypto_int64) f4;\n  crypto_int64 f2f5_2  = f2_2 * (crypto_int64) f5;\n  crypto_int64 f2f6_2  = f2_2 * (crypto_int64) f6;\n  crypto_int64 f2f7_2  = f2_2 * (crypto_int64) f7;\n  crypto_int64 f2f8_38 = f2_2 * (crypto_int64) f8_19;\n  crypto_int64 f2f9_38 = f2   * (crypto_int64) f9_38;\n  crypto_int64 f3f3_2  = f3_2 * (crypto_int64) f3;\n  crypto_int64 f3f4_2  = f3_2 * (crypto_int64) f4;\n  crypto_int64 f3f5_4  = f3_2 * (crypto_int64) f5_2;\n  crypto_int64 f3f6_2  = f3_2 * (crypto_int64) f6;\n  crypto_int64 f3f7_76 = f3_2 * (crypto_int64) f7_38;\n  crypto_int64 f3f8_38 = f3_2 * (crypto_int64) f8_19;\n  crypto_int64 f3f9_76 = f3_2 * (crypto_int64) f9_38;\n  crypto_int64 f4f4    = f4   * (crypto_int64) f4;\n  crypto_int64 f4f5_2  = f4_2 * (crypto_int64) f5;\n  crypto_int64 f4f6_38 = f4_2 * (crypto_int64) f6_19;\n  crypto_int64 f4f7_38 = f4   * (crypto_int64) f7_38;\n  crypto_int64 f4f8_38 = f4_2 * (crypto_int64) f8_19;\n  crypto_int64 f4f9_38 = f4   * (crypto_int64) f9_38;\n  crypto_int64 f5f5_38 = f5   * (crypto_int64) f5_38;\n  crypto_int64 f5f6_38 = f5_2 * (crypto_int64) f6_19;\n  crypto_int64 f5f7_76 = f5_2 * (crypto_int64) f7_38;\n  crypto_int64 f5f8_38 = f5_2 * (crypto_int64) f8_19;\n  crypto_int64 f5f9_76 = f5_2 * (crypto_int64) f9_38;\n  crypto_int64 f6f6_19 = f6   * (crypto_int64) f6_19;\n  crypto_int64 f6f7_38 = f6   * (crypto_int64) f7_38;\n  crypto_int64 f6f8_38 = f6_2 * (crypto_int64) f8_19;\n  crypto_int64 f6f9_38 = f6   * (crypto_int64) f9_38;\n  crypto_int64 f7f7_38 = f7   * (crypto_int64) f7_38;\n  crypto_int64 f7f8_38 = f7_2 * (crypto_int64) f8_19;\n  crypto_int64 f7f9_76 = f7_2 * (crypto_int64) f9_38;\n  crypto_int64 f8f8_19 = f8   * (crypto_int64) f8_19;\n  crypto_int64 f8f9_38 = f8   * (crypto_int64) f9_38;\n  crypto_int64 f9f9_38 = f9   * (crypto_int64) f9_38;\n  crypto_int64 h0 = f0f0  +f1f9_76+f2f8_38+f3f7_76+f4f6_38+f5f5_38;\n  crypto_int64 h1 = f0f1_2+f2f9_38+f3f8_38+f4f7_38+f5f6_38;\n  crypto_int64 h2 = f0f2_2+f1f1_2 +f3f9_76+f4f8_38+f5f7_76+f6f6_19;\n  crypto_int64 h3 = f0f3_2+f1f2_2 +f4f9_38+f5f8_38+f6f7_38;\n  crypto_int64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;\n  crypto_int64 h5 = f0f5_2+f1f4_2 +f2f3_2 +f6f9_38+f7f8_38;\n  crypto_int64 h6 = f0f6_2+f1f5_4 +f2f4_2 +f3f3_2 +f7f9_76+f8f8_19;\n  crypto_int64 h7 = f0f7_2+f1f6_2 +f2f5_2 +f3f4_2 +f8f9_38;\n  crypto_int64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;\n  crypto_int64 h9 = f0f9_2+f1f8_2 +f2f7_2 +f3f6_2 +f4f5_2;\n  crypto_int64 carry0;\n  crypto_int64 carry1;\n  crypto_int64 carry2;\n  crypto_int64 carry3;\n  crypto_int64 carry4;\n  crypto_int64 carry5;\n  crypto_int64 carry6;\n  crypto_int64 carry7;\n  crypto_int64 carry8;\n  crypto_int64 carry9;\n\n  carry0 = (h0 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h1 += carry0; h0 -= carry0 \u003c\u003c 26;\n  carry4 = (h4 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h5 += carry4; h4 -= carry4 \u003c\u003c 26;\n\n  carry1 = (h1 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h2 += carry1; h1 -= carry1 \u003c\u003c 25;\n  carry5 = (h5 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h6 += carry5; h5 -= carry5 \u003c\u003c 25;\n\n  carry2 = (h2 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h3 += carry2; h2 -= carry2 \u003c\u003c 26;\n  carry6 = (h6 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h7 += carry6; h6 -= carry6 \u003c\u003c 26;\n\n  carry3 = (h3 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h4 += carry3; h3 -= carry3 \u003c\u003c 25;\n  carry7 = (h7 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h8 += carry7; h7 -= carry7 \u003c\u003c 25;\n\n  carry4 = (h4 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h5 += carry4; h4 -= carry4 \u003c\u003c 26;\n  carry8 = (h8 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h9 += carry8; h8 -= carry8 \u003c\u003c 26;\n\n  carry9 = (h9 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h0 += carry9 * 19; h9 -= carry9 \u003c\u003c 25;\n\n  carry0 = (h0 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h1 += carry0; h0 -= carry0 \u003c\u003c 26;\n\n  h[0] = h0;\n  h[1] = h1;\n  h[2] = h2;\n  h[3] = h3;\n  h[4] = h4;\n  h[5] = h5;\n  h[6] = h6;\n  h[7] = h7;\n  h[8] = h8;\n  h[9] = h9;\n}","filepath":"debian/nacl-20110221/crypto_scalarmult/curve25519/ref10/fe_sq.c","line_number":19,"entry_url":"https://github.com/janmojzis/tinyssh.git","slot_name":"20150801"},"551377":{"score":0.690601,"function_name":"fe_frombytes","code":"void fe_frombytes(fe h,const unsigned char *s)\n{\n    int64_t h0 = load_4(s);\n    int64_t h1 = load_3(s + 4) \u003c\u003c 6;\n    int64_t h2 = load_3(s + 7) \u003c\u003c 5;\n    int64_t h3 = load_3(s + 10) \u003c\u003c 3;\n    int64_t h4 = load_3(s + 13) \u003c\u003c 2;\n    int64_t h5 = load_4(s + 16);\n    int64_t h6 = load_3(s + 20) \u003c\u003c 7;\n    int64_t h7 = load_3(s + 23) \u003c\u003c 5;\n    int64_t h8 = load_3(s + 26) \u003c\u003c 4;\n    int64_t h9 = (load_3(s + 29) \u0026 8388607) \u003c\u003c 2;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    carry9 = (h9 + (int64_t) (1L \u003c\u003c 24)) \u003e\u003e 25; h0 += carry9 * 19; h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n    carry1 = (h1 + (int64_t) (1L \u003c\u003c 24)) \u003e\u003e 25; h2 += carry1; h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry3 = (h3 + (int64_t) (1L \u003c\u003c 24)) \u003e\u003e 25; h4 += carry3; h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t) (1L \u003c\u003c 24)) \u003e\u003e 25; h6 += carry5; h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t) (1L \u003c\u003c 24)) \u003e\u003e 25; h8 += carry7; h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry0 = (h0 + (int64_t) (1L \u003c\u003c 25)) \u003e\u003e 26; h1 += carry0; h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry2 = (h2 + (int64_t) (1L \u003c\u003c 25)) \u003e\u003e 26; h3 += carry2; h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t) (1L \u003c\u003c 25)) \u003e\u003e 26; h5 += carry4; h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t) (1L \u003c\u003c 25)) \u003e\u003e 26; h7 += carry6; h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t) (1L \u003c\u003c 25)) \u003e\u003e 26; h9 += carry8; h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":198,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.9"},"552943":{"score":0.8498076,"function_name":"fe25519_reduce","code":"static void\nfe25519_reduce(fe25519 h, const fe25519 f)\n{\n    int32_t h0 = f[0];\n    int32_t h1 = f[1];\n    int32_t h2 = f[2];\n    int32_t h3 = f[3];\n    int32_t h4 = f[4];\n    int32_t h5 = f[5];\n    int32_t h6 = f[6];\n    int32_t h7 = f[7];\n    int32_t h8 = f[8];\n    int32_t h9 = f[9];\n\n    int32_t q;\n    int32_t carry0, carry1, carry2, carry3, carry4, carry5, carry6, carry7, carry8, carry9;\n\n    q = (19 * h9 + ((uint32_t) 1L \u003c\u003c 24)) \u003e\u003e 25;\n    q = (h0 + q) \u003e\u003e 26;\n    q = (h1 + q) \u003e\u003e 25;\n    q = (h2 + q) \u003e\u003e 26;\n    q = (h3 + q) \u003e\u003e 25;\n    q = (h4 + q) \u003e\u003e 26;\n    q = (h5 + q) \u003e\u003e 25;\n    q = (h6 + q) \u003e\u003e 26;\n    q = (h7 + q) \u003e\u003e 25;\n    q = (h8 + q) \u003e\u003e 26;\n    q = (h9 + q) \u003e\u003e 25;\n\n    /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */\n    h0 += 19 * q;\n    /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */\n\n    carry0 = h0 \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint32_t) 1L \u003c\u003c 26);\n    carry1 = h1 \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint32_t) 1L \u003c\u003c 25);\n    carry2 = h2 \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint32_t) 1L \u003c\u003c 26);\n    carry3 = h3 \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint32_t) 1L \u003c\u003c 25);\n    carry4 = h4 \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint32_t) 1L \u003c\u003c 26);\n    carry5 = h5 \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint32_t) 1L \u003c\u003c 25);\n    carry6 = h6 \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint32_t) 1L \u003c\u003c 26);\n    carry7 = h7 \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint32_t) 1L \u003c\u003c 25);\n    carry8 = h8 \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint32_t) 1L \u003c\u003c 26);\n    carry9 = h9 \u003e\u003e 25;\n    h9 -= carry9 * ((uint32_t) 1L \u003c\u003c 25);\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n    h[5] = h5;\n    h[6] = h6;\n    h[7] = h7;\n    h[8] = h8;\n    h[9] = h9;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/fe_25_5/fe.h","line_number":99,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"553624":{"score":0.8147142,"function_name":"fe25519_tobytes","code":"void\nfe25519_tobytes(unsigned char *s, const fe25519 h)\n{\n    fe25519 t;\n\n    fe25519_reduce(t, h);\n    s[0]  = t[0] \u003e\u003e 0;\n    s[1]  = t[0] \u003e\u003e 8;\n    s[2]  = t[0] \u003e\u003e 16;\n    s[3]  = (t[0] \u003e\u003e 24) | (t[1] * ((uint32_t) 1 \u003c\u003c 2));\n    s[4]  = t[1] \u003e\u003e 6;\n    s[5]  = t[1] \u003e\u003e 14;\n    s[6]  = (t[1] \u003e\u003e 22) | (t[2] * ((uint32_t) 1 \u003c\u003c 3));\n    s[7]  = t[2] \u003e\u003e 5;\n    s[8]  = t[2] \u003e\u003e 13;\n    s[9]  = (t[2] \u003e\u003e 21) | (t[3] * ((uint32_t) 1 \u003c\u003c 5));\n    s[10] = t[3] \u003e\u003e 3;\n    s[11] = t[3] \u003e\u003e 11;\n    s[12] = (t[3] \u003e\u003e 19) | (t[4] * ((uint32_t) 1 \u003c\u003c 6));\n    s[13] = t[4] \u003e\u003e 2;\n    s[14] = t[4] \u003e\u003e 10;\n    s[15] = t[4] \u003e\u003e 18;\n    s[16] = t[5] \u003e\u003e 0;\n    s[17] = t[5] \u003e\u003e 8;\n    s[18] = t[5] \u003e\u003e 16;\n    s[19] = (t[5] \u003e\u003e 24) | (t[6] * ((uint32_t) 1 \u003c\u003c 1));\n    s[20] = t[6] \u003e\u003e 7;\n    s[21] = t[6] \u003e\u003e 15;\n    s[22] = (t[6] \u003e\u003e 23) | (t[7] * ((uint32_t) 1 \u003c\u003c 3));\n    s[23] = t[7] \u003e\u003e 5;\n    s[24] = t[7] \u003e\u003e 13;\n    s[25] = (t[7] \u003e\u003e 21) | (t[8] * ((uint32_t) 1 \u003c\u003c 4));\n    s[26] = t[8] \u003e\u003e 4;\n    s[27] = t[8] \u003e\u003e 12;\n    s[28] = (t[8] \u003e\u003e 20) | (t[9] * ((uint32_t) 1 \u003c\u003c 6));\n    s[29] = t[9] \u003e\u003e 2;\n    s[30] = t[9] \u003e\u003e 10;\n    s[31] = t[9] \u003e\u003e 18;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/fe_25_5/fe.h","line_number":182,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"554283":{"score":0.82529896,"function_name":"chi25519","code":"static void\nchi25519(fe25519 out, const fe25519 z)\n{\n    fe25519 t0, t1, t2, t3;\n    int     i;\n\n    fe25519_sq(t0, z);\n    fe25519_mul(t1, t0, z);\n    fe25519_sq(t0, t1);\n    fe25519_sq(t2, t0);\n    fe25519_sq(t2, t2);\n    fe25519_mul(t2, t2, t0);\n    fe25519_mul(t1, t2, z);\n    fe25519_sq(t2, t1);\n\n    for (i = 1; i \u003c 5; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 10; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t2, t2, t1);\n    fe25519_sq(t3, t2);\n    for (i = 1; i \u003c 20; i++) {\n        fe25519_sq(t3, t3);\n    }\n    fe25519_mul(t2, t3, t2);\n    fe25519_sq(t2, t2);\n    for (i = 1; i \u003c 10; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 50; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t2, t2, t1);\n    fe25519_sq(t3, t2);\n    for (i = 1; i \u003c 100; i++) {\n        fe25519_sq(t3, t3);\n    }\n    fe25519_mul(t2, t3, t2);\n    fe25519_sq(t2, t2);\n    for (i = 1; i \u003c 50; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t1, t1);\n    for (i = 1; i \u003c 4; i++) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(out, t1, t0);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2472,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"555244":{"score":0.77869856,"function_name":"fe25519_pow22523","code":"static void\nfe25519_pow22523(fe25519 out, const fe25519 z)\n{\n    fe25519 t0;\n    fe25519 t1;\n    fe25519 t2;\n    int     i;\n\n    fe25519_sq(t0, z);\n    fe25519_sq(t1, t0);\n    fe25519_sq(t1, t1);\n    fe25519_mul(t1, z, t1);\n    fe25519_mul(t0, t0, t1);\n    fe25519_sq(t0, t0);\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i \u003c 5; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i \u003c 10; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t1, t1, t0);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 20; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t1, t1);\n    for (i = 1; i \u003c 10; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i \u003c 50; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t1, t1, t0);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 100; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t1, t1);\n    for (i = 1; i \u003c 50; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t0, t0);\n    fe25519_sq(t0, t0);\n    fe25519_mul(out, t0, z);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":111,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"556161":{"score":0.63395405,"function_name":"fe25519_cneg","code":"static inline void\nfe25519_cneg(fe25519 h, const fe25519 f, unsigned int b)\n{\n    fe25519 negf;\n\n    fe25519_neg(negf, f);\n    fe25519_copy(h, f);\n    fe25519_cmov(h, negf, b);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":166,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"556318":{"score":0.70875645,"function_name":"add_p1p1","code":"static void add_p1p1(ge25519_p1p1 *r, const ge25519_p3 *p, const ge25519_p3 *q)\n{\n  fe25519 a, b, c, d, t, fd;\n  fe25519_unpack(\u0026fd, ecd);\n\n  fe25519_sub(\u0026a, \u0026p-\u003ey, \u0026p-\u003ex); // A = (Y1-X1)*(Y2-X2)\n  fe25519_sub(\u0026t, \u0026q-\u003ey, \u0026q-\u003ex);\n  fe25519_mul(\u0026a, \u0026a, \u0026t);\n  fe25519_add(\u0026b, \u0026p-\u003ex, \u0026p-\u003ey); // B = (Y1+X1)*(Y2+X2)\n  fe25519_add(\u0026t, \u0026q-\u003ex, \u0026q-\u003ey);\n  fe25519_mul(\u0026b, \u0026b, \u0026t);\n  fe25519_mul(\u0026c, \u0026p-\u003et, \u0026q-\u003et); //C = T1*k*T2\n  fe25519_mul(\u0026c, \u0026c, \u0026fd);\n  fe25519_add(\u0026c, \u0026c, \u0026c);       //XXX: Can save this addition by precomputing 2*ecd\n  fe25519_mul(\u0026d, \u0026p-\u003ez, \u0026q-\u003ez); //D = Z1*2*Z2\n  fe25519_add(\u0026d, \u0026d, \u0026d);\n  fe25519_sub(\u0026r-\u003ex, \u0026b, \u0026a); // E = B-A\n  fe25519_sub(\u0026r-\u003et, \u0026d, \u0026c); // F = D-C\n  fe25519_add(\u0026r-\u003ez, \u0026d, \u0026c); // G = D+C\n  fe25519_add(\u0026r-\u003ey, \u0026b, \u0026a); // H = B+A\n}","filepath":"src/libsodium/crypto_sign/edwards25519sha512batch/ref/ge25519_edwards25519sha512batch.c","line_number":92,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.4.4"},"556693":{"score":0.86887544,"function_name":"slide_vartime","code":"static void\nslide_vartime(signed char *r, const unsigned char *a)\n{\n    int i;\n    int b;\n    int k;\n    int ribs;\n    int cmp;\n\n    for (i = 0; i \u003c 256; ++i) {\n        r[i] = 1 \u0026 (a[i \u003e\u003e 3] \u003e\u003e (i \u0026 7));\n    }\n    for (i = 0; i \u003c 256; ++i) {\n        if (! r[i]) {\n            continue;\n        }\n        for (b = 1; b \u003c= 6 \u0026\u0026 i + b \u003c 256; ++b) {\n            if (! r[i + b]) {\n                continue;\n            }\n            ribs = r[i + b] \u003c\u003c b;\n            cmp = r[i] + ribs;\n            if (cmp \u003c= 15) {\n                r[i] = cmp;\n                r[i + b] = 0;\n            } else {\n                cmp = r[i] - ribs;\n                if (cmp \u003c -15) {\n                    break;\n                }\n                r[i] = cmp;\n                for (k = i + b; k \u003c 256; ++k) {\n                    if (! r[k]) {\n                        r[k] = 1;\n                        break;\n                    }\n                    r[k] = 0;\n                }\n            }\n        }\n    }\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":204,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"557104":{"score":0.7146057,"function_name":"ge25519_frombytes","code":"int\nge25519_frombytes(ge25519_p3 *h, const unsigned char *s)\n{\n    fe25519 u;\n    fe25519 v;\n    fe25519 v3;\n    fe25519 vxx;\n    fe25519 m_root_check, p_root_check;\n    fe25519 negx;\n    fe25519 x_sqrtm1;\n    int     has_m_root, has_p_root;\n\n    fe25519_frombytes(h-\u003eY, s);\n    fe25519_1(h-\u003eZ);\n    fe25519_sq(u, h-\u003eY);\n    fe25519_mul(v, u, d);\n    fe25519_sub(u, u, h-\u003eZ); /* u = y^2-1 */\n    fe25519_add(v, v, h-\u003eZ); /* v = dy^2+1 */\n\n    fe25519_sq(v3, v);\n    fe25519_mul(v3, v3, v); /* v3 = v^3 */\n    fe25519_sq(h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, v);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^7 */\n\n    fe25519_pow22523(h-\u003eX, h-\u003eX); /* x = (uv^7)^((q-5)/8) */\n    fe25519_mul(h-\u003eX, h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^3(uv^7)^((q-5)/8) */\n\n    fe25519_sq(vxx, h-\u003eX);\n    fe25519_mul(vxx, vxx, v);\n    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */\n    fe25519_add(p_root_check, vxx, u); /* vx^2+u */\n    has_m_root = fe25519_iszero(m_root_check);\n    has_p_root = fe25519_iszero(p_root_check);\n    fe25519_mul(x_sqrtm1, h-\u003eX, sqrtm1); /* x*sqrt(-1) */\n    fe25519_cmov(h-\u003eX, x_sqrtm1, 1 - has_m_root);\n\n    fe25519_neg(negx, h-\u003eX);\n    fe25519_cmov(h-\u003eX, negx, fe25519_isnegative(h-\u003eX) ^ (s[31] \u003e\u003e 7));\n    fe25519_mul(h-\u003eT, h-\u003eX, h-\u003eY);\n\n    return (has_m_root | has_p_root) - 1;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":247,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"557960":{"score":0.72461295,"function_name":"ge25519_frombytes_negate_vartime","code":"int\nge25519_frombytes_negate_vartime(ge25519_p3 *h, const unsigned char *s)\n{\n    fe25519 u;\n    fe25519 v;\n    fe25519 v3;\n    fe25519 vxx;\n    fe25519 m_root_check, p_root_check;\n\n    fe25519_frombytes(h-\u003eY, s);\n    fe25519_1(h-\u003eZ);\n    fe25519_sq(u, h-\u003eY);\n    fe25519_mul(v, u, d);\n    fe25519_sub(u, u, h-\u003eZ); /* u = y^2-1 */\n    fe25519_add(v, v, h-\u003eZ); /* v = dy^2+1 */\n\n    fe25519_sq(v3, v);\n    fe25519_mul(v3, v3, v); /* v3 = v^3 */\n    fe25519_sq(h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, v);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^7 */\n\n    fe25519_pow22523(h-\u003eX, h-\u003eX); /* x = (uv^7)^((q-5)/8) */\n    fe25519_mul(h-\u003eX, h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^3(uv^7)^((q-5)/8) */\n\n    fe25519_sq(vxx, h-\u003eX);\n    fe25519_mul(vxx, vxx, v);\n    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */\n    if (fe25519_iszero(m_root_check) == 0) {\n        fe25519_add(p_root_check, vxx, u); /* vx^2+u */\n        if (fe25519_iszero(p_root_check) == 0) {\n            return -1;\n        }\n        fe25519_mul(h-\u003eX, h-\u003eX, sqrtm1);\n    }\n\n    if (fe25519_isnegative(h-\u003eX) == (s[31] \u003e\u003e 7)) {\n        fe25519_neg(h-\u003eX, h-\u003eX);\n    }\n    fe25519_mul(h-\u003eT, h-\u003eX, h-\u003eY);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":292,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"559099":{"score":0.73736703,"function_name":"ge25519_msub","code":"static void\nge25519_msub(ge25519_p1p1 *r, const ge25519_p3 *p, const ge25519_precomp *q)\n{\n    fe25519 t0;\n\n    fe25519_add(r-\u003eX, p-\u003eY, p-\u003eX);\n    fe25519_sub(r-\u003eY, p-\u003eY, p-\u003eX);\n    fe25519_mul(r-\u003eZ, r-\u003eX, q-\u003eyminusx);\n    fe25519_mul(r-\u003eY, r-\u003eY, q-\u003eyplusx);\n    fe25519_mul(r-\u003eT, q-\u003exy2d, p-\u003eT);\n    fe25519_add(t0, p-\u003eZ, p-\u003eZ);\n    fe25519_sub(r-\u003eX, r-\u003eZ, r-\u003eY);\n    fe25519_add(r-\u003eY, r-\u003eZ, r-\u003eY);\n    fe25519_sub(r-\u003eZ, t0, r-\u003eT);\n    fe25519_add(r-\u003eT, t0, r-\u003eT);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":362,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"559557":{"score":0.7085719,"function_name":"ge25519_p1p1_to_p3","code":"void\nge25519_p1p1_to_p3(ge25519_p3 *r, const ge25519_p1p1 *p)\n{\n    fe25519_mul(r-\u003eX, p-\u003eX, p-\u003eT);\n    fe25519_mul(r-\u003eY, p-\u003eY, p-\u003eZ);\n    fe25519_mul(r-\u003eZ, p-\u003eZ, p-\u003eT);\n    fe25519_mul(r-\u003eT, p-\u003eX, p-\u003eY);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":395,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"559762":{"score":0.82904154,"function_name":"ge25519_p2_dbl","code":"static void\nge25519_p2_dbl(ge25519_p1p1 *r, const ge25519_p2 *p)\n{\n    fe25519 t0;\n\n    fe25519_sq(r-\u003eX, p-\u003eX);\n    fe25519_sq(r-\u003eZ, p-\u003eY);\n    fe25519_sq2(r-\u003eT, p-\u003eZ);\n    fe25519_add(r-\u003eY, p-\u003eX, p-\u003eY);\n    fe25519_sq(t0, r-\u003eY);\n    fe25519_add(r-\u003eY, r-\u003eZ, r-\u003eX);\n    fe25519_sub(r-\u003eZ, r-\u003eZ, r-\u003eX);\n    fe25519_sub(r-\u003eX, t0, r-\u003eY);\n    fe25519_sub(r-\u003eT, r-\u003eT, r-\u003eZ);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":416,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560045":{"score":0.75948715,"function_name":"ge25519_p3_0","code":"static void\nge25519_p3_0(ge25519_p3 *h)\n{\n    fe25519_0(h-\u003eX);\n    fe25519_1(h-\u003eY);\n    fe25519_1(h-\u003eZ);\n    fe25519_0(h-\u003eT);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":432,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560133":{"score":0.7916155,"function_name":"ge25519_cached_0","code":"static void\nge25519_cached_0(ge25519_cached *h)\n{\n    fe25519_1(h-\u003eYplusX);\n    fe25519_1(h-\u003eYminusX);\n    fe25519_1(h-\u003eZ);\n    fe25519_0(h-\u003eT2d);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":441,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560221":{"score":0.7018437,"function_name":"ge25519_p3_to_cached","code":"void\nge25519_p3_to_cached(ge25519_cached *r, const ge25519_p3 *p)\n{\n    fe25519_add(r-\u003eYplusX, p-\u003eY, p-\u003eX);\n    fe25519_sub(r-\u003eYminusX, p-\u003eY, p-\u003eX);\n    fe25519_copy(r-\u003eZ, p-\u003eZ);\n    fe25519_mul(r-\u003eT2d, p-\u003eT, d2);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":454,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560348":{"score":0.7826003,"function_name":"ge25519_p3_to_precomp","code":"static void\nge25519_p3_to_precomp(ge25519_precomp *pi, const ge25519_p3 *p)\n{\n    fe25519 recip;\n    fe25519 x;\n    fe25519 y;\n    fe25519 xy;\n\n    fe25519_invert(recip, p-\u003eZ);\n    fe25519_mul(x, p-\u003eX, recip);\n    fe25519_mul(y, p-\u003eY, recip);\n    fe25519_add(pi-\u003eyplusx, y, x);\n    fe25519_sub(pi-\u003eyminusx, y, x);\n    fe25519_mul(xy, x, y);\n    fe25519_mul(pi-\u003exy2d, xy, d2);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":463,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560708":{"score":0.8381896,"function_name":"ge_tobytes","code":"void ge_tobytes(unsigned char *s,const ge_p2 *h)\n{\n    fe recip;\n    fe x;\n    fe y;\n\n    fe_invert(recip,h-\u003eZ);\n    fe_mul(x,h-\u003eX,recip);\n    fe_mul(y,h-\u003eY,recip);\n    fe_tobytes(s,y);\n    s[31] ^= fe_isnegative(x) \u003c\u003c 7;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1505,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.9"},"561358":{"score":0.85724914,"function_name":"ge25519_cmov_cached","code":"static void\nge25519_cmov_cached(ge25519_cached *t, const ge25519_cached *u, unsigned char b)\n{\n    fe25519_cmov(t-\u003eYplusX, u-\u003eYplusX, b);\n    fe25519_cmov(t-\u003eYminusX, u-\u003eYminusX, b);\n    fe25519_cmov(t-\u003eZ, u-\u003eZ, b);\n    fe25519_cmov(t-\u003eT2d, u-\u003eT2d, b);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":559,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"562279":{"score":0.752286,"function_name":"ge25519_cmov8_cached","code":"static void\nge25519_cmov8_cached(ge25519_cached *t, const ge25519_cached cached[8], const signed char b)\n{\n    ge25519_cached      minust;\n    const unsigned char bnegative = negative(b);\n    const unsigned char babs      = b - (((-bnegative) \u0026 b) * ((signed char) 1 \u003c\u003c 1));\n\n    ge25519_cached_0(t);\n    ge25519_cmov_cached(t, \u0026cached[0], equal(babs, 1));\n    ge25519_cmov_cached(t, \u0026cached[1], equal(babs, 2));\n    ge25519_cmov_cached(t, \u0026cached[2], equal(babs, 3));\n    ge25519_cmov_cached(t, \u0026cached[3], equal(babs, 4));\n    ge25519_cmov_cached(t, \u0026cached[4], equal(babs, 5));\n    ge25519_cmov_cached(t, \u0026cached[5], equal(babs, 6));\n    ge25519_cmov_cached(t, \u0026cached[6], equal(babs, 7));\n    ge25519_cmov_cached(t, \u0026cached[7], equal(babs, 8));\n    fe25519_copy(minust.YplusX, t-\u003eYminusX);\n    fe25519_copy(minust.YminusX, t-\u003eYplusX);\n    fe25519_copy(minust.Z, t-\u003eZ);\n    fe25519_neg(minust.T2d, t-\u003eT2d);\n    ge25519_cmov_cached(t, \u0026minust, bnegative);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":603,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"563044":{"score":0.6549419,"function_name":"ge_sub","code":"void ge_sub(ge_p1p1 *r,const ge_p3 *p,const ge_cached *q)\n{\n    fe t0;\n\n    fe_add(r-\u003eX, p-\u003eY, p-\u003eX);\n    fe_sub(r-\u003eY, p-\u003eY, p-\u003eX);\n    fe_mul(r-\u003eZ, r-\u003eX, q-\u003eYminusX);\n    fe_mul(r-\u003eY, r-\u003eY, q-\u003eYplusX);\n    fe_mul(r-\u003eT, q-\u003eT2d, p-\u003eT);\n    fe_mul(r-\u003eX, p-\u003eZ, q-\u003eZ);\n    fe_add(t0, r-\u003eX, r-\u003eX);\n    fe_sub(r-\u003eX, r-\u003eZ, r-\u003eY);\n    fe_add(r-\u003eY, r-\u003eZ, r-\u003eY);\n    fe_sub(r-\u003eZ, t0, r-\u003eT);\n    fe_add(r-\u003eT, t0, r-\u003eT);\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1488,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.9"},"563419":{"score":0.8865699,"function_name":"ge25519_p3_tobytes","code":"void\nge25519_p3_tobytes(unsigned char *s, const ge25519_p3 *h)\n{\n    fe25519 recip;\n    fe25519 x;\n    fe25519 y;\n\n    fe25519_invert(recip, h-\u003eZ);\n    fe25519_mul(x, h-\u003eX, recip);\n    fe25519_mul(y, h-\u003eY, recip);\n    fe25519_tobytes(s, y);\n    s[31] ^= fe25519_isnegative(x) \u003c\u003c 7;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":492,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"563648":{"score":0.7362209,"function_name":"ge25519_double_scalarmult_vartime","code":"void\nge25519_double_scalarmult_vartime(ge25519_p2 *r, const unsigned char *a,\n                                  const ge25519_p3 *A, const unsigned char *b)\n{\n    static const ge25519_precomp Bi[8] = {\n#ifdef HAVE_TI_MODE\n# include \"fe_51/base2.h\"\n#else\n# include \"fe_25_5/base2.h\"\n#endif\n    };\n    signed char    aslide[256];\n    signed char    bslide[256];\n    ge25519_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */\n    ge25519_p1p1   t;\n    ge25519_p3     u;\n    ge25519_p3     A2;\n    int            i;\n\n    slide_vartime(aslide, a);\n    slide_vartime(bslide, b);\n\n    ge25519_p3_to_cached(\u0026Ai[0], A);\n\n    ge25519_p3_dbl(\u0026t, A);\n    ge25519_p1p1_to_p3(\u0026A2, \u0026t);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[0]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[1], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[1]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[2], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[2]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[3], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[3]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[4], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[4]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[5], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[5]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[6], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[6]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[7], \u0026u);\n\n    ge25519_p2_0(r);\n\n    for (i = 255; i \u003e= 0; --i) {\n        if (aslide[i] || bslide[i]) {\n            break;\n        }\n    }\n\n    for (; i \u003e= 0; --i) {\n        ge25519_p2_dbl(\u0026t, r);\n\n        if (aslide[i] \u003e 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_add(\u0026t, \u0026u, \u0026Ai[aslide[i] / 2]);\n        } else if (aslide[i] \u003c 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_sub(\u0026t, \u0026u, \u0026Ai[(-aslide[i]) / 2]);\n        }\n\n        if (bslide[i] \u003e 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_madd(\u0026t, \u0026u, \u0026Bi[bslide[i] / 2]);\n        } else if (bslide[i] \u003c 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_msub(\u0026t, \u0026u, \u0026Bi[(-bslide[i]) / 2]);\n        }\n\n        ge25519_p1p1_to_p2(r, \u0026t);\n    }\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":671,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"565130":{"score":0.8147918,"function_name":"ge25519_scalarmult","code":"void\nge25519_scalarmult(ge25519_p3 *h, const unsigned char *a, const ge25519_p3 *p)\n{\n    signed char     e[64];\n    signed char     carry;\n    ge25519_p1p1    r;\n    ge25519_p2      s;\n    ge25519_p1p1    t2, t3, t4, t5, t6, t7, t8;\n    ge25519_p3      p2, p3, p4, p5, p6, p7, p8;\n    ge25519_cached  pi[8];\n    ge25519_cached  t;\n    int             i;\n\n    ge25519_p3_to_cached(\u0026pi[1 - 1], p);   /* p */\n\n    ge25519_p3_dbl(\u0026t2, p);\n    ge25519_p1p1_to_p3(\u0026p2, \u0026t2);\n    ge25519_p3_to_cached(\u0026pi[2 - 1], \u0026p2); /* 2p = 2*p */\n\n    ge25519_add(\u0026t3, p, \u0026pi[2 - 1]);\n    ge25519_p1p1_to_p3(\u0026p3, \u0026t3);\n    ge25519_p3_to_cached(\u0026pi[3 - 1], \u0026p3); /* 3p = 2p+p */\n\n    ge25519_p3_dbl(\u0026t4, \u0026p2);\n    ge25519_p1p1_to_p3(\u0026p4, \u0026t4);\n    ge25519_p3_to_cached(\u0026pi[4 - 1], \u0026p4); /* 4p = 2*2p */\n\n    ge25519_add(\u0026t5, p, \u0026pi[4 - 1]);\n    ge25519_p1p1_to_p3(\u0026p5, \u0026t5);\n    ge25519_p3_to_cached(\u0026pi[5 - 1], \u0026p5); /* 5p = 4p+p */\n\n    ge25519_p3_dbl(\u0026t6, \u0026p3);\n    ge25519_p1p1_to_p3(\u0026p6, \u0026t6);\n    ge25519_p3_to_cached(\u0026pi[6 - 1], \u0026p6); /* 6p = 2*3p */\n\n    ge25519_add(\u0026t7, p, \u0026pi[6 - 1]);\n    ge25519_p1p1_to_p3(\u0026p7, \u0026t7);\n    ge25519_p3_to_cached(\u0026pi[7 - 1], \u0026p7); /* 7p = 6p+p */\n\n    ge25519_p3_dbl(\u0026t8, \u0026p4);\n    ge25519_p1p1_to_p3(\u0026p8, \u0026t8);\n    ge25519_p3_to_cached(\u0026pi[8 - 1], \u0026p8); /* 8p = 2*4p */\n\n    for (i = 0; i \u003c 32; ++i) {\n        e[2 * i + 0] = (a[i] \u003e\u003e 0) \u0026 15;\n        e[2 * i + 1] = (a[i] \u003e\u003e 4) \u0026 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i \u003c 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry \u003e\u003e= 4;\n        e[i] -= carry * ((signed char) 1 \u003c\u003c 4);\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge25519_p3_0(h);\n\n    for (i = 63; i != 0; i--) {\n        ge25519_cmov8_cached(\u0026t, pi, e[i]);\n        ge25519_add(\u0026r, h, \u0026t);\n\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n\n        ge25519_p1p1_to_p3(h, \u0026r);  /* *16 */\n    }\n    ge25519_cmov8_cached(\u0026t, pi, e[i]);\n    ge25519_add(\u0026r, h, \u0026t);\n\n    ge25519_p1p1_to_p3(h, \u0026r);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":767,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"566539":{"score":0.784195,"function_name":"ge25519_scalarmult_base","code":"void\nge25519_scalarmult_base(ge25519_p3 *h, const unsigned char *a)\n{\n    signed char     e[64];\n    signed char     carry;\n    ge25519_p1p1    r;\n    ge25519_p2      s;\n    ge25519_precomp t;\n    int             i;\n\n    for (i = 0; i \u003c 32; ++i) {\n        e[2 * i + 0] = (a[i] \u003e\u003e 0) \u0026 15;\n        e[2 * i + 1] = (a[i] \u003e\u003e 4) \u0026 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i \u003c 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry \u003e\u003e= 4;\n        e[i] -= carry * ((signed char) 1 \u003c\u003c 4);\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge25519_p3_0(h);\n\n    for (i = 1; i \u003c 64; i += 2) {\n        ge25519_cmov8_base(\u0026t, i / 2, e[i]);\n        ge25519_madd(\u0026r, h, \u0026t);\n        ge25519_p1p1_to_p3(h, \u0026r);\n    }\n\n    ge25519_p3_dbl(\u0026r, h);\n    ge25519_p1p1_to_p2(\u0026s, \u0026r);\n    ge25519_p2_dbl(\u0026r, \u0026s);\n    ge25519_p1p1_to_p2(\u0026s, \u0026r);\n    ge25519_p2_dbl(\u0026r, \u0026s);\n    ge25519_p1p1_to_p2(\u0026s, \u0026r);\n    ge25519_p2_dbl(\u0026r, \u0026s);\n    ge25519_p1p1_to_p3(h, \u0026r);\n\n    for (i = 0; i \u003c 64; i += 2) {\n        ge25519_cmov8_base(\u0026t, i / 2, e[i]);\n        ge25519_madd(\u0026r, h, \u0026t);\n        ge25519_p1p1_to_p3(h, \u0026r);\n    }\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":860,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"567363":{"score":0.7867166,"function_name":"ge25519_mul_l","code":"static void\nge25519_mul_l(ge25519_p3 *r, const ge25519_p3 *A)\n{\n    static const signed char aslide[253] = {\n        13, 0, 0, 0, 0, -1, 0, 0, 0, 0, -11, 0, 0, 0, 0, 0, 0, -5, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, -13, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, -13, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, -13, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 3, 0, 0, 0, 0, -11, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n    };\n    ge25519_cached Ai[8];\n    ge25519_p1p1   t;\n    ge25519_p3     u;\n    ge25519_p3     A2;\n    int            i;\n\n    ge25519_p3_to_cached(\u0026Ai[0], A);\n    ge25519_p3_dbl(\u0026t, A);\n    ge25519_p1p1_to_p3(\u0026A2, \u0026t);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[0]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[1], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[1]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[2], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[2]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[3], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[3]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[4], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[4]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[5], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[5]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[6], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[6]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[7], \u0026u);\n\n    ge25519_p3_0(r);\n\n    for (i = 252; i \u003e= 0; --i) {\n        ge25519_p3_dbl(\u0026t, r);\n\n        if (aslide[i] \u003e 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_add(\u0026t, \u0026u, \u0026Ai[aslide[i] / 2]);\n        } else if (aslide[i] \u003c 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_sub(\u0026t, \u0026u, \u0026Ai[(-aslide[i]) / 2]);\n        }\n\n        ge25519_p1p1_to_p3(r, \u0026t);\n    }\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":912,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"568489":{"score":0.73322,"function_name":"ge25519_is_on_curve","code":"int\nge25519_is_on_curve(const ge25519_p3 *p)\n{\n    fe25519 x2;\n    fe25519 y2;\n    fe25519 z2;\n    fe25519 z4;\n    fe25519 t0;\n    fe25519 t1;\n\n    fe25519_sq(x2, p-\u003eX);\n    fe25519_sq(y2, p-\u003eY);\n    fe25519_sq(z2, p-\u003eZ);\n    fe25519_sub(t0, y2, x2);\n    fe25519_mul(t0, t0, z2);\n\n    fe25519_mul(t1, x2, y2);\n    fe25519_mul(t1, t1, d);\n    fe25519_sq(z4, z2);\n    fe25519_add(t1, t1, z4);\n    fe25519_sub(t0, t0, t1);\n\n    return fe25519_iszero(t0);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":966,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"568920":{"score":0.8525932,"function_name":"ge25519_is_canonical","code":"int\nge25519_is_canonical(const unsigned char *s)\n{\n    unsigned char c;\n    unsigned char d;\n    unsigned int  i;\n\n    c = (s[31] \u0026 0x7f) ^ 0x7f;\n    for (i = 30; i \u003e 0; i--) {\n        c |= s[i] ^ 0xff;\n    }\n    c = (((unsigned int) c) - 1U) \u003e\u003e 8;\n    d = (0xed - 1U - (unsigned int) s[0]) \u003e\u003e 8;\n\n    return 1 - (c \u0026 d \u0026 1);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":1001,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"569048":{"score":0.7511924,"function_name":"ge25519_has_small_order","code":"int\nge25519_has_small_order(const unsigned char s[32])\n{\n    CRYPTO_ALIGN(16)\n    static const unsigned char blacklist[][32] = {\n        /* 0 (order 4) */\n        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 1 (order 1) */\n        { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 2707385501144840649318225287225658788936804267575313519463743609750303402022\n           (order 8) */\n        { 0x26, 0xe8, 0x95, 0x8f, 0xc2, 0xb2, 0x27, 0xb0, 0x45, 0xc3, 0xf4,\n          0x89, 0xf2, 0xef, 0x98, 0xf0, 0xd5, 0xdf, 0xac, 0x05, 0xd3, 0xc6,\n          0x33, 0x39, 0xb1, 0x38, 0x02, 0x88, 0x6d, 0x53, 0xfc, 0x05 },\n        /* 55188659117513257062467267217118295137698188065244968500265048394206261417927\n           (order 8) */\n        { 0xc7, 0x17, 0x6a, 0x70, 0x3d, 0x4d, 0xd8, 0x4f, 0xba, 0x3c, 0x0b,\n          0x76, 0x0d, 0x10, 0x67, 0x0f, 0x2a, 0x20, 0x53, 0xfa, 0x2c, 0x39,\n          0xcc, 0xc6, 0x4e, 0xc7, 0xfd, 0x77, 0x92, 0xac, 0x03, 0x7a },\n        /* p-1 (order 2) */\n        { 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p (=0, order 4) */\n        { 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p+1 (=1, order 1) */\n        { 0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f }\n    };\n    unsigned char c[7] = { 0 };\n    unsigned int  k;\n    size_t        i, j;\n\n    COMPILER_ASSERT(7 == sizeof blacklist / sizeof blacklist[0]);\n    for (j = 0; j \u003c 31; j++) {\n        for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n            c[i] |= s[j] ^ blacklist[i][j];\n        }\n    }\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        c[i] |= (s[j] \u0026 0x7f) ^ blacklist[i][j];\n    }\n    k = 0;\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        k |= (c[i] - 1);\n    }\n    return (int) ((k \u003e\u003e 8) \u0026 1);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":1018,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"569366":{"score":0.6410868,"function_name":"sc25519_mul","code":"void\nsc25519_mul(unsigned char s[32], const unsigned char a[32], const unsigned char b[32])\n{\n    int64_t a0  = 2097151 \u0026 load_3(a);\n    int64_t a1  = 2097151 \u0026 (load_4(a + 2) \u003e\u003e 5);\n    int64_t a2  = 2097151 \u0026 (load_3(a + 5) \u003e\u003e 2);\n    int64_t a3  = 2097151 \u0026 (load_4(a + 7) \u003e\u003e 7);\n    int64_t a4  = 2097151 \u0026 (load_4(a + 10) \u003e\u003e 4);\n    int64_t a5  = 2097151 \u0026 (load_3(a + 13) \u003e\u003e 1);\n    int64_t a6  = 2097151 \u0026 (load_4(a + 15) \u003e\u003e 6);\n    int64_t a7  = 2097151 \u0026 (load_3(a + 18) \u003e\u003e 3);\n    int64_t a8  = 2097151 \u0026 load_3(a + 21);\n    int64_t a9  = 2097151 \u0026 (load_4(a + 23) \u003e\u003e 5);\n    int64_t a10 = 2097151 \u0026 (load_3(a + 26) \u003e\u003e 2);\n    int64_t a11 = (load_4(a + 28) \u003e\u003e 7);\n\n    int64_t b0  = 2097151 \u0026 load_3(b);\n    int64_t b1  = 2097151 \u0026 (load_4(b + 2) \u003e\u003e 5);\n    int64_t b2  = 2097151 \u0026 (load_3(b + 5) \u003e\u003e 2);\n    int64_t b3  = 2097151 \u0026 (load_4(b + 7) \u003e\u003e 7);\n    int64_t b4  = 2097151 \u0026 (load_4(b + 10) \u003e\u003e 4);\n    int64_t b5  = 2097151 \u0026 (load_3(b + 13) \u003e\u003e 1);\n    int64_t b6  = 2097151 \u0026 (load_4(b + 15) \u003e\u003e 6);\n    int64_t b7  = 2097151 \u0026 (load_3(b + 18) \u003e\u003e 3);\n    int64_t b8  = 2097151 \u0026 load_3(b + 21);\n    int64_t b9  = 2097151 \u0026 (load_4(b + 23) \u003e\u003e 5);\n    int64_t b10 = 2097151 \u0026 (load_3(b + 26) \u003e\u003e 2);\n    int64_t b11 = (load_4(b + 28) \u003e\u003e 7);\n\n    int64_t s0;\n    int64_t s1;\n    int64_t s2;\n    int64_t s3;\n    int64_t s4;\n    int64_t s5;\n    int64_t s6;\n    int64_t s7;\n    int64_t s8;\n    int64_t s9;\n    int64_t s10;\n    int64_t s11;\n    int64_t s12;\n    int64_t s13;\n    int64_t s14;\n    int64_t s15;\n    int64_t s16;\n    int64_t s17;\n    int64_t s18;\n    int64_t s19;\n    int64_t s20;\n    int64_t s21;\n    int64_t s22;\n    int64_t s23;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n    int64_t carry17;\n    int64_t carry18;\n    int64_t carry19;\n    int64_t carry20;\n    int64_t carry21;\n    int64_t carry22;\n\n    s0 = a0 * b0;\n    s1 = a0 * b1 + a1 * b0;\n    s2 = a0 * b2 + a1 * b1 + a2 * b0;\n    s3 = a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;\n    s4 = a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;\n    s5 = a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;\n    s6 = a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0;\n    s7 = a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 +\n         a6 * b1 + a7 * b0;\n    s8 = a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 +\n         a6 * b2 + a7 * b1 + a8 * b0;\n    s9 = a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 +\n         a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;\n    s10 = a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 +\n          a6 * b4 + a7 * b3 + a8 * b2 + a9 * b1 + a10 * b0;\n    s11 = a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 +\n          a6 * b5 + a7 * b4 + a8 * b3 + a9 * b2 + a10 * b1 + a11 * b0;\n    s12 = a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 +\n          a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;\n    s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 +\n          a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;\n    s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 +\n          a9 * b5 + a10 * b4 + a11 * b3;\n    s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 +\n          a10 * b5 + a11 * b4;\n    s16 =\n        a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;\n    s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;\n    s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;\n    s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;\n    s20 = a9 * b11 + a10 * b10 + a11 * b9;\n    s21 = a10 * b11 + a11 * b10;\n    s22 = a11 * b11;\n    s23 = 0;\n\n    carry0 = (s0 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = (s2 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = (s4 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry12 = (s12 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L \u003c\u003c 21);\n    carry14 = (s14 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L \u003c\u003c 21);\n    carry16 = (s16 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L \u003c\u003c 21);\n    carry18 = (s18 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s19 += carry18;\n    s18 -= carry18 * ((uint64_t) 1L \u003c\u003c 21);\n    carry20 = (s20 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s21 += carry20;\n    s20 -= carry20 * ((uint64_t) 1L \u003c\u003c 21);\n    carry22 = (s22 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s23 += carry22;\n    s22 -= carry22 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry1 = (s1 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = (s3 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = (s5 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n    carry13 = (s13 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L \u003c\u003c 21);\n    carry15 = (s15 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L \u003c\u003c 21);\n    carry17 = (s17 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s18 += carry17;\n    s17 -= carry17 * ((uint64_t) 1L \u003c\u003c 21);\n    carry19 = (s19 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s20 += carry19;\n    s19 -= carry19 * ((uint64_t) 1L \u003c\u003c 21);\n    carry21 = (s21 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s22 += carry21;\n    s21 -= carry21 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n\n    s9 += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n\n    s8 += s20 * 666643;\n    s9 += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n\n    s7 += s19 * 666643;\n    s8 += s19 * 470296;\n    s9 += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n\n    s6 += s18 * 666643;\n    s7 += s18 * 470296;\n    s8 += s18 * 654183;\n    s9 -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry12 = (s12 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L \u003c\u003c 21);\n    carry14 = (s14 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L \u003c\u003c 21);\n    carry16 = (s16 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n    carry13 = (s13 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L \u003c\u003c 21);\n    carry15 = (s15 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s5 += s17 * 666643;\n    s6 += s17 * 470296;\n    s7 += s17 * 654183;\n    s8 -= s17 * 997805;\n    s9 += s17 * 136657;\n    s10 -= s17 * 683901;\n\n    s4 += s16 * 666643;\n    s5 += s16 * 470296;\n    s6 += s16 * 654183;\n    s7 -= s16 * 997805;\n    s8 += s16 * 136657;\n    s9 -= s16 * 683901;\n\n    s3 += s15 * 666643;\n    s4 += s15 * 470296;\n    s5 += s15 * 654183;\n    s6 -= s15 * 997805;\n    s7 += s15 * 136657;\n    s8 -= s15 * 683901;\n\n    s2 += s14 * 666643;\n    s3 += s14 * 470296;\n    s4 += s14 * 654183;\n    s5 -= s14 * 997805;\n    s6 += s14 * 136657;\n    s7 -= s14 * 683901;\n\n    s1 += s13 * 666643;\n    s2 += s13 * 470296;\n    s3 += s13 * 654183;\n    s4 -= s13 * 997805;\n    s5 += s13 * 136657;\n    s6 -= s13 * 683901;\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = (s2 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = (s4 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry1 = (s1 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = (s3 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = (s5 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = s11 \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s[0]  = s0 \u003e\u003e 0;\n    s[1]  = s0 \u003e\u003e 8;\n    s[2]  = (s0 \u003e\u003e 16) | (s1 * ((uint64_t) 1 \u003c\u003c 5));\n    s[3]  = s1 \u003e\u003e 3;\n    s[4]  = s1 \u003e\u003e 11;\n    s[5]  = (s1 \u003e\u003e 19) | (s2 * ((uint64_t) 1 \u003c\u003c 2));\n    s[6]  = s2 \u003e\u003e 6;\n    s[7]  = (s2 \u003e\u003e 14) | (s3 * ((uint64_t) 1 \u003c\u003c 7));\n    s[8]  = s3 \u003e\u003e 1;\n    s[9]  = s3 \u003e\u003e 9;\n    s[10] = (s3 \u003e\u003e 17) | (s4 * ((uint64_t) 1 \u003c\u003c 4));\n    s[11] = s4 \u003e\u003e 4;\n    s[12] = s4 \u003e\u003e 12;\n    s[13] = (s4 \u003e\u003e 20) | (s5 * ((uint64_t) 1 \u003c\u003c 1));\n    s[14] = s5 \u003e\u003e 7;\n    s[15] = (s5 \u003e\u003e 15) | (s6 * ((uint64_t) 1 \u003c\u003c 6));\n    s[16] = s6 \u003e\u003e 2;\n    s[17] = s6 \u003e\u003e 10;\n    s[18] = (s6 \u003e\u003e 18) | (s7 * ((uint64_t) 1 \u003c\u003c 3));\n    s[19] = s7 \u003e\u003e 5;\n    s[20] = s7 \u003e\u003e 13;\n    s[21] = s8 \u003e\u003e 0;\n    s[22] = s8 \u003e\u003e 8;\n    s[23] = (s8 \u003e\u003e 16) | (s9 * ((uint64_t) 1 \u003c\u003c 5));\n    s[24] = s9 \u003e\u003e 3;\n    s[25] = s9 \u003e\u003e 11;\n    s[26] = (s9 \u003e\u003e 19) | (s10 * ((uint64_t) 1 \u003c\u003c 2));\n    s[27] = s10 \u003e\u003e 6;\n    s[28] = (s10 \u003e\u003e 14) | (s11 * ((uint64_t) 1 \u003c\u003c 7));\n    s[29] = s11 \u003e\u003e 1;\n    s[30] = s11 \u003e\u003e 9;\n    s[31] = s11 \u003e\u003e 17;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":1084,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"591731":{"score":0.7248583,"function_name":"sc_muladd","code":"void sc_muladd(unsigned char *s,const unsigned char *a,const unsigned char *b,const unsigned char *c)\n{\n    int64_t a0 = 2097151 \u0026 load_3(a);\n    int64_t a1 = 2097151 \u0026 (load_4(a + 2) \u003e\u003e 5);\n    int64_t a2 = 2097151 \u0026 (load_3(a + 5) \u003e\u003e 2);\n    int64_t a3 = 2097151 \u0026 (load_4(a + 7) \u003e\u003e 7);\n    int64_t a4 = 2097151 \u0026 (load_4(a + 10) \u003e\u003e 4);\n    int64_t a5 = 2097151 \u0026 (load_3(a + 13) \u003e\u003e 1);\n    int64_t a6 = 2097151 \u0026 (load_4(a + 15) \u003e\u003e 6);\n    int64_t a7 = 2097151 \u0026 (load_3(a + 18) \u003e\u003e 3);\n    int64_t a8 = 2097151 \u0026 load_3(a + 21);\n    int64_t a9 = 2097151 \u0026 (load_4(a + 23) \u003e\u003e 5);\n    int64_t a10 = 2097151 \u0026 (load_3(a + 26) \u003e\u003e 2);\n    int64_t a11 = (load_4(a + 28) \u003e\u003e 7);\n    int64_t b0 = 2097151 \u0026 load_3(b);\n    int64_t b1 = 2097151 \u0026 (load_4(b + 2) \u003e\u003e 5);\n    int64_t b2 = 2097151 \u0026 (load_3(b + 5) \u003e\u003e 2);\n    int64_t b3 = 2097151 \u0026 (load_4(b + 7) \u003e\u003e 7);\n    int64_t b4 = 2097151 \u0026 (load_4(b + 10) \u003e\u003e 4);\n    int64_t b5 = 2097151 \u0026 (load_3(b + 13) \u003e\u003e 1);\n    int64_t b6 = 2097151 \u0026 (load_4(b + 15) \u003e\u003e 6);\n    int64_t b7 = 2097151 \u0026 (load_3(b + 18) \u003e\u003e 3);\n    int64_t b8 = 2097151 \u0026 load_3(b + 21);\n    int64_t b9 = 2097151 \u0026 (load_4(b + 23) \u003e\u003e 5);\n    int64_t b10 = 2097151 \u0026 (load_3(b + 26) \u003e\u003e 2);\n    int64_t b11 = (load_4(b + 28) \u003e\u003e 7);\n    int64_t c0 = 2097151 \u0026 load_3(c);\n    int64_t c1 = 2097151 \u0026 (load_4(c + 2) \u003e\u003e 5);\n    int64_t c2 = 2097151 \u0026 (load_3(c + 5) \u003e\u003e 2);\n    int64_t c3 = 2097151 \u0026 (load_4(c + 7) \u003e\u003e 7);\n    int64_t c4 = 2097151 \u0026 (load_4(c + 10) \u003e\u003e 4);\n    int64_t c5 = 2097151 \u0026 (load_3(c + 13) \u003e\u003e 1);\n    int64_t c6 = 2097151 \u0026 (load_4(c + 15) \u003e\u003e 6);\n    int64_t c7 = 2097151 \u0026 (load_3(c + 18) \u003e\u003e 3);\n    int64_t c8 = 2097151 \u0026 load_3(c + 21);\n    int64_t c9 = 2097151 \u0026 (load_4(c + 23) \u003e\u003e 5);\n    int64_t c10 = 2097151 \u0026 (load_3(c + 26) \u003e\u003e 2);\n    int64_t c11 = (load_4(c + 28) \u003e\u003e 7);\n    int64_t s0;\n    int64_t s1;\n    int64_t s2;\n    int64_t s3;\n    int64_t s4;\n    int64_t s5;\n    int64_t s6;\n    int64_t s7;\n    int64_t s8;\n    int64_t s9;\n    int64_t s10;\n    int64_t s11;\n    int64_t s12;\n    int64_t s13;\n    int64_t s14;\n    int64_t s15;\n    int64_t s16;\n    int64_t s17;\n    int64_t s18;\n    int64_t s19;\n    int64_t s20;\n    int64_t s21;\n    int64_t s22;\n    int64_t s23;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n    int64_t carry17;\n    int64_t carry18;\n    int64_t carry19;\n    int64_t carry20;\n    int64_t carry21;\n    int64_t carry22;\n\n    s0 = c0 + a0*b0;\n    s1 = c1 + a0*b1 + a1*b0;\n    s2 = c2 + a0*b2 + a1*b1 + a2*b0;\n    s3 = c3 + a0*b3 + a1*b2 + a2*b1 + a3*b0;\n    s4 = c4 + a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0;\n    s5 = c5 + a0*b5 + a1*b4 + a2*b3 + a3*b2 + a4*b1 + a5*b0;\n    s6 = c6 + a0*b6 + a1*b5 + a2*b4 + a3*b3 + a4*b2 + a5*b1 + a6*b0;\n    s7 = c7 + a0*b7 + a1*b6 + a2*b5 + a3*b4 + a4*b3 + a5*b2 + a6*b1 + a7*b0;\n    s8 = c8 + a0*b8 + a1*b7 + a2*b6 + a3*b5 + a4*b4 + a5*b3 + a6*b2 + a7*b1 + a8*b0;\n    s9 = c9 + a0*b9 + a1*b8 + a2*b7 + a3*b6 + a4*b5 + a5*b4 + a6*b3 + a7*b2 + a8*b1 + a9*b0;\n    s10 = c10 + a0*b10 + a1*b9 + a2*b8 + a3*b7 + a4*b6 + a5*b5 + a6*b4 + a7*b3 + a8*b2 + a9*b1 + a10*b0;\n    s11 = c11 + a0*b11 + a1*b10 + a2*b9 + a3*b8 + a4*b7 + a5*b6 + a6*b5 + a7*b4 + a8*b3 + a9*b2 + a10*b1 + a11*b0;\n    s12 = a1*b11 + a2*b10 + a3*b9 + a4*b8 + a5*b7 + a6*b6 + a7*b5 + a8*b4 + a9*b3 + a10*b2 + a11*b1;\n    s13 = a2*b11 + a3*b10 + a4*b9 + a5*b8 + a6*b7 + a7*b6 + a8*b5 + a9*b4 + a10*b3 + a11*b2;\n    s14 = a3*b11 + a4*b10 + a5*b9 + a6*b8 + a7*b7 + a8*b6 + a9*b5 + a10*b4 + a11*b3;\n    s15 = a4*b11 + a5*b10 + a6*b9 + a7*b8 + a8*b7 + a9*b6 + a10*b5 + a11*b4;\n    s16 = a5*b11 + a6*b10 + a7*b9 + a8*b8 + a9*b7 + a10*b6 + a11*b5;\n    s17 = a6*b11 + a7*b10 + a8*b9 + a9*b8 + a10*b7 + a11*b6;\n    s18 = a7*b11 + a8*b10 + a9*b9 + a10*b8 + a11*b7;\n    s19 = a8*b11 + a9*b10 + a10*b9 + a11*b8;\n    s20 = a9*b11 + a10*b10 + a11*b9;\n    s21 = a10*b11 + a11*b10;\n    s22 = a11*b11;\n    s23 = 0;\n\n    carry0 = (s0 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s1 += carry0; s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = (s2 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s3 += carry2; s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = (s4 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s5 += carry4; s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s7 += carry6; s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s9 += carry8; s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s11 += carry10; s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry12 = (s12 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s13 += carry12; s12 -= carry12 * ((uint64_t) 1L \u003c\u003c 21);\n    carry14 = (s14 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s15 += carry14; s14 -= carry14 * ((uint64_t) 1L \u003c\u003c 21);\n    carry16 = (s16 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s17 += carry16; s16 -= carry16 * ((uint64_t) 1L \u003c\u003c 21);\n    carry18 = (s18 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s19 += carry18; s18 -= carry18 * ((uint64_t) 1L \u003c\u003c 21);\n    carry20 = (s20 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s21 += carry20; s20 -= carry20 * ((uint64_t) 1L \u003c\u003c 21);\n    carry22 = (s22 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s23 += carry22; s22 -= carry22 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry1 = (s1 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s2 += carry1; s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = (s3 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s4 += carry3; s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = (s5 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s6 += carry5; s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s8 += carry7; s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s10 += carry9; s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s12 += carry11; s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n    carry13 = (s13 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s14 += carry13; s13 -= carry13 * ((uint64_t) 1L \u003c\u003c 21);\n    carry15 = (s15 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s16 += carry15; s15 -= carry15 * ((uint64_t) 1L \u003c\u003c 21);\n    carry17 = (s17 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s18 += carry17; s17 -= carry17 * ((uint64_t) 1L \u003c\u003c 21);\n    carry19 = (s19 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s20 += carry19; s19 -= carry19 * ((uint64_t) 1L \u003c\u003c 21);\n    carry21 = (s21 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s22 += carry21; s21 -= carry21 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n\n    s9 += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n\n    s8 += s20 * 666643;\n    s9 += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n\n    s7 += s19 * 666643;\n    s8 += s19 * 470296;\n    s9 += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n\n    s6 += s18 * 666643;\n    s7 += s18 * 470296;\n    s8 += s18 * 654183;\n    s9 -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s7 += carry6; s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s9 += carry8; s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s11 += carry10; s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry12 = (s12 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s13 += carry12; s12 -= carry12 * ((uint64_t) 1L \u003c\u003c 21);\n    carry14 = (s14 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s15 += carry14; s14 -= carry14 * ((uint64_t) 1L \u003c\u003c 21);\n    carry16 = (s16 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s17 += carry16; s16 -= carry16 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s8 += carry7; s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s10 += carry9; s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s12 += carry11; s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n    carry13 = (s13 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s14 += carry13; s13 -= carry13 * ((uint64_t) 1L \u003c\u003c 21);\n    carry15 = (s15 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s16 += carry15; s15 -= carry15 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s5 += s17 * 666643;\n    s6 += s17 * 470296;\n    s7 += s17 * 654183;\n    s8 -= s17 * 997805;\n    s9 += s17 * 136657;\n    s10 -= s17 * 683901;\n\n    s4 += s16 * 666643;\n    s5 += s16 * 470296;\n    s6 += s16 * 654183;\n    s7 -= s16 * 997805;\n    s8 += s16 * 136657;\n    s9 -= s16 * 683901;\n\n    s3 += s15 * 666643;\n    s4 += s15 * 470296;\n    s5 += s15 * 654183;\n    s6 -= s15 * 997805;\n    s7 += s15 * 136657;\n    s8 -= s15 * 683901;\n\n    s2 += s14 * 666643;\n    s3 += s14 * 470296;\n    s4 += s14 * 654183;\n    s5 -= s14 * 997805;\n    s6 += s14 * 136657;\n    s7 -= s14 * 683901;\n\n    s1 += s13 * 666643;\n    s2 += s13 * 470296;\n    s3 += s13 * 654183;\n    s4 -= s13 * 997805;\n    s5 += s13 * 136657;\n    s6 -= s13 * 683901;\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s1 += carry0; s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = (s2 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s3 += carry2; s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = (s4 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s5 += carry4; s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s7 += carry6; s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s9 += carry8; s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s11 += carry10; s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry1 = (s1 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s2 += carry1; s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = (s3 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s4 += carry3; s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = (s5 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s6 += carry5; s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s8 += carry7; s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s10 += carry9; s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21; s12 += carry11; s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = s0 \u003e\u003e 21; s1 += carry0; s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21; s2 += carry1; s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21; s3 += carry2; s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21; s4 += carry3; s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21; s5 += carry4; s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21; s6 += carry5; s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21; s7 += carry6; s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21; s8 += carry7; s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21; s9 += carry8; s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21; s10 += carry9; s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21; s11 += carry10; s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = s11 \u003e\u003e 21; s12 += carry11; s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n\n    carry0 = s0 \u003e\u003e 21; s1 += carry0; s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21; s2 += carry1; s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21; s3 += carry2; s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21; s4 += carry3; s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21; s5 += carry4; s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21; s6 += carry5; s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21; s7 += carry6; s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21; s8 += carry7; s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21; s9 += carry8; s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21; s10 += carry9; s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21; s11 += carry10; s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s[0] = s0 \u003e\u003e 0;\n    s[1] = s0 \u003e\u003e 8;\n    s[2] = (s0 \u003e\u003e 16) | (s1 * ((uint64_t) 1 \u003c\u003c 5));\n    s[3] = s1 \u003e\u003e 3;\n    s[4] = s1 \u003e\u003e 11;\n    s[5] = (s1 \u003e\u003e 19) | (s2 * ((uint64_t) 1 \u003c\u003c 2));\n    s[6] = s2 \u003e\u003e 6;\n    s[7] = (s2 \u003e\u003e 14) | (s3 * ((uint64_t) 1 \u003c\u003c 7));\n    s[8] = s3 \u003e\u003e 1;\n    s[9] = s3 \u003e\u003e 9;\n    s[10] = (s3 \u003e\u003e 17) | (s4 * ((uint64_t) 1 \u003c\u003c 4));\n    s[11] = s4 \u003e\u003e 4;\n    s[12] = s4 \u003e\u003e 12;\n    s[13] = (s4 \u003e\u003e 20) | (s5 * ((uint64_t) 1 \u003c\u003c 1));\n    s[14] = s5 \u003e\u003e 7;\n    s[15] = (s5 \u003e\u003e 15) | (s6 * ((uint64_t) 1 \u003c\u003c 6));\n    s[16] = s6 \u003e\u003e 2;\n    s[17] = s6 \u003e\u003e 10;\n    s[18] = (s6 \u003e\u003e 18) | (s7 * ((uint64_t) 1 \u003c\u003c 3));\n    s[19] = s7 \u003e\u003e 5;\n    s[20] = s7 \u003e\u003e 13;\n    s[21] = s8 \u003e\u003e 0;\n    s[22] = s8 \u003e\u003e 8;\n    s[23] = (s8 \u003e\u003e 16) | (s9 * ((uint64_t) 1 \u003c\u003c 5));\n    s[24] = s9 \u003e\u003e 3;\n    s[25] = s9 \u003e\u003e 11;\n    s[26] = (s9 \u003e\u003e 19) | (s10 * ((uint64_t) 1 \u003c\u003c 2));\n    s[27] = s10 \u003e\u003e 6;\n    s[28] = (s10 \u003e\u003e 14) | (s11 * ((uint64_t) 1 \u003c\u003c 7));\n    s[29] = s11 \u003e\u003e 1;\n    s[30] = s11 \u003e\u003e 9;\n    s[31] = s11 \u003e\u003e 17;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1682,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.9"},"614887":{"score":0.7624073,"function_name":"sc25519_sqmul","code":"static inline void\nsc25519_sqmul(unsigned char s[32], const int n, const unsigned char a[32])\n{\n    int i;\n\n    for (i = 0; i \u003c n; i++) {\n        sc25519_sq(s, s);\n    }\n    sc25519_mul(s, s, a);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2060,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"614961":{"score":0.6692337,"function_name":"sc25519_invert","code":"void\nsc25519_invert(unsigned char recip[32], const unsigned char s[32])\n{\n    unsigned char _10[32], _100[32], _11[32], _101[32], _111[32],\n        _1001[32], _1011[32], _1111[32];\n\n    sc25519_sq(_10, s);\n    sc25519_sq(_100, _10);\n    sc25519_mul(_11, _10, s);\n    sc25519_mul(_101, _10, _11);\n    sc25519_mul(_111, _10, _101);\n    sc25519_mul(_1001, _10, _111);\n    sc25519_mul(_1011, _10, _1001);\n    sc25519_mul(_1111, _100, _1011);\n    sc25519_mul(recip, _1111, s);\n\n    sc25519_sqmul(recip, 123 + 3, _101);\n    sc25519_sqmul(recip, 2 + 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 4, _1001);\n    sc25519_sqmul(recip, 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 1 + 3, _101);\n    sc25519_sqmul(recip, 3 + 3, _101);\n    sc25519_sqmul(recip, 3, _111);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 2 + 3, _111);\n    sc25519_sqmul(recip, 2 + 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1011);\n    sc25519_sqmul(recip, 2 + 4, _1011);\n    sc25519_sqmul(recip, 6 + 4, _1001);\n    sc25519_sqmul(recip, 2 + 2, _11);\n    sc25519_sqmul(recip, 3 + 2, _11);\n    sc25519_sqmul(recip, 3 + 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1001);\n    sc25519_sqmul(recip, 1 + 3, _111);\n    sc25519_sqmul(recip, 2 + 4, _1111);\n    sc25519_sqmul(recip, 1 + 4, _1011);\n    sc25519_sqmul(recip, 3, _101);\n    sc25519_sqmul(recip, 2 + 4, _1111);\n    sc25519_sqmul(recip, 3, _101);\n    sc25519_sqmul(recip, 1 + 2, _11);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2071,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"615941":{"score":0.8434262,"function_name":"sc_reduce","code":"void\nsc_reduce(unsigned char *s)\n{\n    int64_t s0  = 2097151 \u0026 load_3(s);\n    int64_t s1  = 2097151 \u0026 (load_4(s + 2) \u003e\u003e 5);\n    int64_t s2  = 2097151 \u0026 (load_3(s + 5) \u003e\u003e 2);\n    int64_t s3  = 2097151 \u0026 (load_4(s + 7) \u003e\u003e 7);\n    int64_t s4  = 2097151 \u0026 (load_4(s + 10) \u003e\u003e 4);\n    int64_t s5  = 2097151 \u0026 (load_3(s + 13) \u003e\u003e 1);\n    int64_t s6  = 2097151 \u0026 (load_4(s + 15) \u003e\u003e 6);\n    int64_t s7  = 2097151 \u0026 (load_3(s + 18) \u003e\u003e 3);\n    int64_t s8  = 2097151 \u0026 load_3(s + 21);\n    int64_t s9  = 2097151 \u0026 (load_4(s + 23) \u003e\u003e 5);\n    int64_t s10 = 2097151 \u0026 (load_3(s + 26) \u003e\u003e 2);\n    int64_t s11 = 2097151 \u0026 (load_4(s + 28) \u003e\u003e 7);\n    int64_t s12 = 2097151 \u0026 (load_4(s + 31) \u003e\u003e 4);\n    int64_t s13 = 2097151 \u0026 (load_3(s + 34) \u003e\u003e 1);\n    int64_t s14 = 2097151 \u0026 (load_4(s + 36) \u003e\u003e 6);\n    int64_t s15 = 2097151 \u0026 (load_3(s + 39) \u003e\u003e 3);\n    int64_t s16 = 2097151 \u0026 load_3(s + 42);\n    int64_t s17 = 2097151 \u0026 (load_4(s + 44) \u003e\u003e 5);\n    int64_t s18 = 2097151 \u0026 (load_3(s + 47) \u003e\u003e 2);\n    int64_t s19 = 2097151 \u0026 (load_4(s + 49) \u003e\u003e 7);\n    int64_t s20 = 2097151 \u0026 (load_4(s + 52) \u003e\u003e 4);\n    int64_t s21 = 2097151 \u0026 (load_3(s + 55) \u003e\u003e 1);\n    int64_t s22 = 2097151 \u0026 (load_4(s + 57) \u003e\u003e 6);\n    int64_t s23 = (load_4(s + 60) \u003e\u003e 3);\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n\n    s9 += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n\n    s8 += s20 * 666643;\n    s9 += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n\n    s7 += s19 * 666643;\n    s8 += s19 * 470296;\n    s9 += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n\n    s6 += s18 * 666643;\n    s7 += s18 * 470296;\n    s8 += s18 * 654183;\n    s9 -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n\n    carry6 = (s6 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry12 = (s12 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L \u003c\u003c 21);\n    carry14 = (s14 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L \u003c\u003c 21);\n    carry16 = (s16 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry7 = (s7 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n    carry13 = (s13 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L \u003c\u003c 21);\n    carry15 = (s15 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s5 += s17 * 666643;\n    s6 += s17 * 470296;\n    s7 += s17 * 654183;\n    s8 -= s17 * 997805;\n    s9 += s17 * 136657;\n    s10 -= s17 * 683901;\n\n    s4 += s16 * 666643;\n    s5 += s16 * 470296;\n    s6 += s16 * 654183;\n    s7 -= s16 * 997805;\n    s8 += s16 * 136657;\n    s9 -= s16 * 683901;\n\n    s3 += s15 * 666643;\n    s4 += s15 * 470296;\n    s5 += s15 * 654183;\n    s6 -= s15 * 997805;\n    s7 += s15 * 136657;\n    s8 -= s15 * 683901;\n\n    s2 += s14 * 666643;\n    s3 += s14 * 470296;\n    s4 += s14 * 654183;\n    s5 -= s14 * 997805;\n    s6 += s14 * 136657;\n    s7 -= s14 * 683901;\n\n    s1 += s13 * 666643;\n    s2 += s13 * 470296;\n    s3 += s13 * 654183;\n    s4 -= s13 * 997805;\n    s5 += s13 * 136657;\n    s6 -= s13 * 683901;\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = (s2 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = (s4 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = (s6 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry1 = (s1 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = (s3 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = (s5 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = (s7 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t)(1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = s11 \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s[0]  = s0 \u003e\u003e 0;\n    s[1]  = s0 \u003e\u003e 8;\n    s[2]  = (s0 \u003e\u003e 16) | (s1 * ((uint64_t) 1 \u003c\u003c 5));\n    s[3]  = s1 \u003e\u003e 3;\n    s[4]  = s1 \u003e\u003e 11;\n    s[5]  = (s1 \u003e\u003e 19) | (s2 * ((uint64_t) 1 \u003c\u003c 2));\n    s[6]  = s2 \u003e\u003e 6;\n    s[7]  = (s2 \u003e\u003e 14) | (s3 * ((uint64_t) 1 \u003c\u003c 7));\n    s[8]  = s3 \u003e\u003e 1;\n    s[9]  = s3 \u003e\u003e 9;\n    s[10] = (s3 \u003e\u003e 17) | (s4 * ((uint64_t) 1 \u003c\u003c 4));\n    s[11] = s4 \u003e\u003e 4;\n    s[12] = s4 \u003e\u003e 12;\n    s[13] = (s4 \u003e\u003e 20) | (s5 * ((uint64_t) 1 \u003c\u003c 1));\n    s[14] = s5 \u003e\u003e 7;\n    s[15] = (s5 \u003e\u003e 15) | (s6 * ((uint64_t) 1 \u003c\u003c 6));\n    s[16] = s6 \u003e\u003e 2;\n    s[17] = s6 \u003e\u003e 10;\n    s[18] = (s6 \u003e\u003e 18) | (s7 * ((uint64_t) 1 \u003c\u003c 3));\n    s[19] = s7 \u003e\u003e 5;\n    s[20] = s7 \u003e\u003e 13;\n    s[21] = s8 \u003e\u003e 0;\n    s[22] = s8 \u003e\u003e 8;\n    s[23] = (s8 \u003e\u003e 16) | (s9 * ((uint64_t) 1 \u003c\u003c 5));\n    s[24] = s9 \u003e\u003e 3;\n    s[25] = s9 \u003e\u003e 11;\n    s[26] = (s9 \u003e\u003e 19) | (s10 * ((uint64_t) 1 \u003c\u003c 2));\n    s[27] = s10 \u003e\u003e 6;\n    s[28] = (s10 \u003e\u003e 14) | (s11 * ((uint64_t) 1 \u003c\u003c 7));\n    s[29] = s11 \u003e\u003e 1;\n    s[30] = s11 \u003e\u003e 9;\n    s[31] = s11 \u003e\u003e 17;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":2414,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.13"},"627680":{"score":0.8594662,"function_name":"sc25519_is_canonical","code":"int\nsc25519_is_canonical(const unsigned char s[32])\n{\n    /* 2^252+27742317777372353535851937790883648493 */\n    static const unsigned char L[32] = {\n        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7,\n        0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10\n    };\n    unsigned char c = 0;\n    unsigned char n = 1;\n    unsigned int  i = 32;\n\n    do {\n        i--;\n        c |= ((s[i] - L[i]) \u003e\u003e 8) \u0026 n;\n        n \u0026= ((s[i] ^ L[i]) - 1) \u003e\u003e 8;\n    } while (i != 0);\n\n    return (c != 0);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2450,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"628788":{"score":0.79846036,"function_name":"ge25519_elligator2","code":"static void\nge25519_elligator2(unsigned char s[32], const fe25519 r, const unsigned char x_sign)\n{\n    fe25519      e;\n    fe25519      negx;\n    fe25519      rr2;\n    fe25519      x, x2, x3;\n    ge25519_p3   p3;\n    ge25519_p1p1 p1;\n    ge25519_p2   p2;\n    unsigned int e_is_minus_1;\n\n    fe25519_sq2(rr2, r);\n    rr2[0]++;\n    fe25519_invert(rr2, rr2);\n    fe25519_mul(x, curve25519_A, rr2);\n    fe25519_neg(x, x);\n\n    fe25519_sq(x2, x);\n    fe25519_mul(x3, x, x2);\n    fe25519_add(e, x3, x);\n    fe25519_mul(x2, x2, curve25519_A);\n    fe25519_add(e, x2, e);\n\n    chi25519(e, e);\n\n    fe25519_tobytes(s, e);\n    e_is_minus_1 = s[1] \u0026 1;\n    fe25519_neg(negx, x);\n    fe25519_cmov(x, negx, e_is_minus_1);\n    fe25519_0(x2);\n    fe25519_cmov(x2, curve25519_A, e_is_minus_1);\n    fe25519_sub(x, x, x2);\n\n    /* yed = (x-1)/(x+1) */\n    {\n        fe25519 one;\n        fe25519 x_plus_one;\n        fe25519 x_plus_one_inv;\n        fe25519 x_minus_one;\n        fe25519 yed;\n\n        fe25519_1(one);\n        fe25519_add(x_plus_one, x, one);\n        fe25519_sub(x_minus_one, x, one);\n        fe25519_invert(x_plus_one_inv, x_plus_one);\n        fe25519_mul(yed, x_minus_one, x_plus_one_inv);\n        fe25519_tobytes(s, yed);\n    }\n\n    /* recover x */\n    s[31] |= x_sign;\n    if (ge25519_frombytes(\u0026p3, s) != 0) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n\n    /* multiply by the cofactor */\n    ge25519_p3_dbl(\u0026p1, \u0026p3);\n    ge25519_p1p1_to_p2(\u0026p2, \u0026p1);\n    ge25519_p2_dbl(\u0026p1, \u0026p2);\n    ge25519_p1p1_to_p2(\u0026p2, \u0026p1);\n    ge25519_p2_dbl(\u0026p1, \u0026p2);\n    ge25519_p1p1_to_p3(\u0026p3, \u0026p1);\n\n    ge25519_p3_tobytes(s, \u0026p3);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2528,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"629752":{"score":0.7402645,"function_name":"ge25519_from_uniform","code":"void\nge25519_from_uniform(unsigned char s[32], const unsigned char r[32])\n{\n    fe25519       r_fe;\n    unsigned char x_sign;\n\n    memcpy(s, r, 32);\n    x_sign = s[31] \u0026 0x80;\n    s[31] \u0026= 0x7f;\n    fe25519_frombytes(r_fe, s);\n    ge25519_elligator2(s, r_fe, x_sign);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2595,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"629913":{"score":0.8932465,"function_name":"ge25519_from_hash","code":"void\nge25519_from_hash(unsigned char s[32], const unsigned char h[64])\n{\n    unsigned char fl[32];\n    unsigned char gl[32];\n    fe25519       fe_f;\n    fe25519       fe_g;\n    size_t        i;\n    unsigned char x_sign;\n\n    x_sign = h[0] \u0026 0x80;\n    for (i = 0; i \u003c 32; i++) {\n        fl[i] = h[63 - i];\n        gl[i] = h[31 - i];\n    }\n    fl[31] \u0026= 0x7f;\n    gl[31] \u0026= 0x7f;\n    fe25519_frombytes(fe_f, fl);\n    fe25519_frombytes(fe_g, gl);\n    fe_f[0] += (h[32] \u003e\u003e 7) * 19;\n    for (i = 0; i \u003c sizeof (fe25519) / sizeof fe_f[0]; i++) {\n        fe_f[i] += 38 * fe_g[i];\n    }\n    fe25519_reduce(fe_f, fe_f);\n    ge25519_elligator2(s, fe_f, x_sign);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2608,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"630322":{"score":0.7691456,"function_name":"ristretto255_sqrt_ratio_m1","code":"static int\nristretto255_sqrt_ratio_m1(fe25519 x, const fe25519 u, const fe25519 v)\n{\n    fe25519 v3;\n    fe25519 vxx;\n    fe25519 m_root_check, p_root_check, f_root_check;\n    fe25519 x_sqrtm1;\n    int     has_m_root, has_p_root, has_f_root;\n\n    fe25519_sq(v3, v);\n    fe25519_mul(v3, v3, v); /* v3 = v^3 */\n    fe25519_sq(x, v3);\n    fe25519_mul(x, x, v);\n    fe25519_mul(x, x, u); /* x = uv^7 */\n\n    fe25519_pow22523(x, x); /* x = (uv^7)^((q-5)/8) */\n    fe25519_mul(x, x, v3);\n    fe25519_mul(x, x, u); /* x = uv^3(uv^7)^((q-5)/8) */\n\n    fe25519_sq(vxx, x);\n    fe25519_mul(vxx, vxx, v); /* vx^2 */\n    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */\n    fe25519_add(p_root_check, vxx, u); /* vx^2+u */\n    fe25519_mul(f_root_check, u, sqrtm1); /* u*sqrt(-1) */\n    fe25519_add(f_root_check, vxx, f_root_check); /* vx^2+u*sqrt(-1) */\n    has_m_root = fe25519_iszero(m_root_check);\n    has_p_root = fe25519_iszero(p_root_check);\n    has_f_root = fe25519_iszero(f_root_check);\n    fe25519_mul(x_sqrtm1, x, sqrtm1); /* x*sqrt(-1) */\n\n    fe25519_cmov(x, x_sqrtm1, has_p_root | has_f_root);\n    fe25519_abs(x, x);\n\n    return has_m_root | has_p_root;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2637,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"630953":{"score":0.8670542,"function_name":"ge25519_is_canonical","code":"int\nge25519_is_canonical(const unsigned char *s)\n{\n    unsigned char c;\n    unsigned char d;\n    unsigned int  i;\n\n    c = (s[31] \u0026 0x7f) ^ 0x7f;\n    for (i = 30; i \u003e 0; i--) {\n        c |= s[i] ^ 0xff;\n    }\n    c = (((unsigned int) c) - 1U) \u003e\u003e 8;\n    d = (0xed - 1U - (unsigned int) s[0]) \u003e\u003e 8;\n\n    return 1 - (c \u0026 d \u0026 1);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":1001,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"631091":{"score":0.8228882,"function_name":"ristretto255_frombytes","code":"int\nristretto255_frombytes(ge25519_p3 *h, const unsigned char *s)\n{\n    fe25519 inv_sqrt;\n    fe25519 one;\n    fe25519 s_;\n    fe25519 ss;\n    fe25519 u1, u2;\n    fe25519 u1u1, u2u2;\n    fe25519 v;\n    fe25519 v_u2u2;\n    int     was_square;\n\n    if (ristretto255_is_canonical(s) == 0) {\n        return -1;\n    }\n    fe25519_frombytes(s_, s);\n    fe25519_sq(ss, s_);                /* ss = s^2 */\n\n    fe25519_1(u1);\n    fe25519_sub(u1, u1, ss);           /* u1 = 1-ss */\n    fe25519_sq(u1u1, u1);              /* u1u1 = u1^2 */\n\n    fe25519_1(u2);\n    fe25519_add(u2, u2, ss);           /* u2 = 1+ss */\n    fe25519_sq(u2u2, u2);              /* u2u2 = u2^2 */\n\n    fe25519_mul(v, d, u1u1);           /* v = d*u1^2 */\n    fe25519_neg(v, v);                 /* v = -d*u1^2 */\n    fe25519_sub(v, v, u2u2);           /* v = -(d*u1^2)-u2^2 */\n\n    fe25519_mul(v_u2u2, v, u2u2);      /* v_u2u2 = v*u2^2 */\n\n    fe25519_1(one);\n    was_square = ristretto255_sqrt_ratio_m1(inv_sqrt, one, v_u2u2);\n    fe25519_mul(h-\u003eX, inv_sqrt, u2);\n    fe25519_mul(h-\u003eY, inv_sqrt, h-\u003eX);\n    fe25519_mul(h-\u003eY, h-\u003eY, v);\n\n    fe25519_mul(h-\u003eX, h-\u003eX, s_);\n    fe25519_add(h-\u003eX, h-\u003eX, h-\u003eX);\n    fe25519_abs(h-\u003eX, h-\u003eX);\n    fe25519_mul(h-\u003eY, u1, h-\u003eY);\n    fe25519_1(h-\u003eZ);\n    fe25519_mul(h-\u003eT, h-\u003eX, h-\u003eY);\n\n    return - ((1 - was_square) |\n              fe25519_isnegative(h-\u003eT) | fe25519_iszero(h-\u003eY));\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2690,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"631886":{"score":0.775424,"function_name":"ristretto255_p3_tobytes","code":"void\nristretto255_p3_tobytes(unsigned char *s, const ge25519_p3 *h)\n{\n    fe25519 den1, den2;\n    fe25519 den_inv;\n    fe25519 eden;\n    fe25519 inv_sqrt;\n    fe25519 ix, iy;\n    fe25519 one;\n    fe25519 s_;\n    fe25519 t_z_inv;\n    fe25519 u1, u2;\n    fe25519 u1_u2u2;\n    fe25519 x_, y_;\n    fe25519 x_z_inv;\n    fe25519 z_inv;\n    fe25519 zmy;\n    int     rotate;\n\n    fe25519_add(u1, h-\u003eZ, h-\u003eY);       /* u1 = Z+Y */\n    fe25519_sub(zmy, h-\u003eZ, h-\u003eY);      /* zmy = Z-Y */\n    fe25519_mul(u1, u1, zmy);          /* u1 = (Z+Y)*(Z-Y) */\n    fe25519_mul(u2, h-\u003eX, h-\u003eY);       /* u2 = X*Y */\n\n    fe25519_sq(u1_u2u2, u2);           /* u1_u2u2 = u2^2 */\n    fe25519_mul(u1_u2u2, u1, u1_u2u2); /* u1_u2u2 = u1*u2^2 */\n\n    fe25519_1(one);\n    (void) ristretto255_sqrt_ratio_m1(inv_sqrt, one, u1_u2u2);\n    fe25519_mul(den1, inv_sqrt, u1);   /* den1 = inv_sqrt*u1 */\n    fe25519_mul(den2, inv_sqrt, u2);   /* den2 = inv_sqrt*u2 */\n    fe25519_mul(z_inv, den1, den2);    /* z_inv = den1*den2 */\n    fe25519_mul(z_inv, z_inv, h-\u003eT);   /* z_inv = den1*den2*T */\n\n    fe25519_mul(ix, h-\u003eX, sqrtm1);     /* ix = X*sqrt(-1) */\n    fe25519_mul(iy, h-\u003eY, sqrtm1);     /* iy = Y*sqrt(-1) */\n    fe25519_mul(eden, den1, invsqrtamd); /* eden = den1*sqrt(a-d) */\n\n    fe25519_mul(t_z_inv, h-\u003eT, z_inv); /* t_z_inv = T*z_inv */\n    rotate = fe25519_isnegative(t_z_inv);\n\n    fe25519_copy(x_, h-\u003eX);\n    fe25519_copy(y_, h-\u003eY);\n    fe25519_copy(den_inv, den2);\n\n    fe25519_cmov(x_, iy, rotate);\n    fe25519_cmov(y_, ix, rotate);\n    fe25519_cmov(den_inv, eden, rotate);\n\n    fe25519_mul(x_z_inv, x_, z_inv);\n    fe25519_cneg(y_, y_, fe25519_isnegative(x_z_inv));\n\n    fe25519_sub(s_, h-\u003eZ, y_);\n    fe25519_mul(s_, den_inv, s_);\n    fe25519_abs(s_, s_);\n    fe25519_tobytes(s, s_);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2740,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"632834":{"score":0.76972353,"function_name":"ristretto255_elligator","code":"static void\nristretto255_elligator(ge25519_p3 *p, const fe25519 t)\n{\n    fe25519 c;\n    fe25519 n;\n    fe25519 one;\n    fe25519 r;\n    fe25519 rpd;\n    fe25519 s, s_prime;\n    fe25519 ss;\n    fe25519 u, v;\n    fe25519 w0, w1, w2, w3;\n    int     wasnt_square;\n\n    fe25519_1(one);\n    fe25519_sq(r, t);                  /* r = t^2 */\n    fe25519_mul(r, sqrtm1, r);         /* r = sqrt(-1)*t^2 */\n    fe25519_add(u, r, one);            /* u = r+1 */\n    fe25519_mul(u, u, onemsqd);        /* u = (r+1)*(1-d^2) */\n    fe25519_1(c);\n    fe25519_neg(c, c);                 /* c = -1 */\n    fe25519_add(rpd, r, d);            /* rpd = r*d */\n    fe25519_mul(v, r, d);              /* v = r*d */\n    fe25519_sub(v, c, v);              /* v = c-r*d */\n    fe25519_mul(v, v, rpd);            /* v = (c-r*d)*(r+d) */\n\n    wasnt_square = 1 - ristretto255_sqrt_ratio_m1(s, u, v);\n    fe25519_mul(s_prime, s, t);\n    fe25519_abs(s_prime, s_prime);\n    fe25519_neg(s_prime, s_prime);     /* s_prime = -|s*t| */\n    fe25519_cmov(s, s_prime, wasnt_square);\n    fe25519_cmov(c, r, wasnt_square);\n\n    fe25519_sub(n, r, one);            /* n = r-1 */\n    fe25519_mul(n, n, c);              /* n = c*(r-1) */\n    fe25519_mul(n, n, sqdmone);        /* n = c*(r-1)*(d-1)^2 */\n    fe25519_sub(n, n, v);              /* n =  c*(r-1)*(d-1)^2-v */\n\n    fe25519_add(w0, s, s);             /* w0 = 2s */\n    fe25519_mul(w0, w0, v);            /* w0 = 2s*v */\n    fe25519_mul(w1, n, sqrtadm1);      /* w1 = n*sqrt(ad-1) */\n    fe25519_sq(ss, s);                 /* ss = s^2 */\n    fe25519_sub(w2, one, ss);          /* w2 = 1-s^2 */\n    fe25519_add(w3, one, ss);          /* w3 = 1+s^2 */\n\n    fe25519_mul(p-\u003eX, w0, w3);\n    fe25519_mul(p-\u003eY, w2, w1);\n    fe25519_mul(p-\u003eZ, w1, w3);\n    fe25519_mul(p-\u003eT, w0, w2);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2798,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"633840":{"score":0.6829804,"function_name":"dbl_p1p1","code":"static void dbl_p1p1(ge25519_p1p1 *r, const ge25519_p2 *p)\n{\n  fe25519 a,b,c,d;\n  fe25519_square(\u0026a, \u0026p-\u003ex);\n  fe25519_square(\u0026b, \u0026p-\u003ey);\n  fe25519_square(\u0026c, \u0026p-\u003ez);\n  fe25519_add(\u0026c, \u0026c, \u0026c);\n  fe25519_neg(\u0026d, \u0026a);\n\n  fe25519_add(\u0026r-\u003ex, \u0026p-\u003ex, \u0026p-\u003ey);\n  fe25519_square(\u0026r-\u003ex, \u0026r-\u003ex);\n  fe25519_sub(\u0026r-\u003ex, \u0026r-\u003ex, \u0026a);\n  fe25519_sub(\u0026r-\u003ex, \u0026r-\u003ex, \u0026b);\n  fe25519_add(\u0026r-\u003ez, \u0026d, \u0026b);\n  fe25519_sub(\u0026r-\u003et, \u0026r-\u003ez, \u0026c);\n  fe25519_sub(\u0026r-\u003ey, \u0026d, \u0026b);\n}","filepath":"plugins/ssh-base/crypto/ge25519.c","line_number":127,"entry_url":"https://github.com/warmcat/libwebsockets.git","slot_name":"v4.2-rc1"},"634110":{"score":0.66405743,"function_name":"crypto_generichash_blake2b","code":"int\ncrypto_generichash_blake2b(unsigned char *out, size_t outlen,\n                           const unsigned char *in, unsigned long long inlen,\n                           const unsigned char *key, size_t keylen)\n{\n    if (outlen \u003c= 0U || outlen \u003e BLAKE2B_OUTBYTES ||\n        keylen \u003e BLAKE2B_KEYBYTES || inlen \u003e UINT64_MAX) {\n        return -1;\n    }\n    assert(outlen \u003c= UINT8_MAX);\n    assert(keylen \u003c= UINT8_MAX);\n\n    return blake2b((uint8_t *) out, in, key, (uint8_t) outlen, (uint64_t) inlen,\n                   (uint8_t) keylen);\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/generichash_blake2b.c","line_number":11,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"634289":{"score":0.7598082,"function_name":"crypto_generichash_blake2b_salt_personal","code":"int\ncrypto_generichash_blake2b_salt_personal(\n    unsigned char *out, size_t outlen, const unsigned char *in,\n    unsigned long long inlen, const unsigned char *key, size_t keylen,\n    const unsigned char *salt, const unsigned char *personal)\n{\n    if (outlen \u003c= 0U || outlen \u003e BLAKE2B_OUTBYTES ||\n        keylen \u003e BLAKE2B_KEYBYTES || inlen \u003e UINT64_MAX) {\n        return -1;\n    }\n    assert(outlen \u003c= UINT8_MAX);\n    assert(keylen \u003c= UINT8_MAX);\n\n    return blake2b_salt_personal((uint8_t *) out, in, key, (uint8_t) outlen,\n                                 (uint64_t) inlen, (uint8_t) keylen, salt,\n                                 personal);\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/generichash_blake2b.c","line_number":27,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"634474":{"score":0.7537128,"function_name":"crypto_generichash_blake2b_init","code":"int\ncrypto_generichash_blake2b_init(crypto_generichash_blake2b_state *state,\n                                const unsigned char *key, const size_t keylen,\n                                const size_t outlen)\n{\n    if (outlen \u003c= 0U || outlen \u003e BLAKE2B_OUTBYTES ||\n        keylen \u003e BLAKE2B_KEYBYTES) {\n        return -1;\n    }\n    assert(outlen \u003c= UINT8_MAX);\n    assert(keylen \u003c= UINT8_MAX);\n    COMPILER_ASSERT(sizeof(blake2b_state) \u003c= sizeof *state);\n    if (key == NULL || keylen \u003c= 0U) {\n        if (blake2b_init((blake2b_state *) (void *) state, (uint8_t) outlen) != 0) {\n            return -1; /* LCOV_EXCL_LINE */\n        }\n    } else if (blake2b_init_key((blake2b_state *) (void *) state, (uint8_t) outlen, key,\n                                (uint8_t) keylen) != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/generichash_blake2b.c","line_number":45,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"634694":{"score":0.75000083,"function_name":"crypto_generichash_blake2b_init_salt_personal","code":"int\ncrypto_generichash_blake2b_init_salt_personal(\n    crypto_generichash_blake2b_state *state, const unsigned char *key,\n    const size_t keylen, const size_t outlen, const unsigned char *salt,\n    const unsigned char *personal)\n{\n    if (outlen \u003c= 0U || outlen \u003e BLAKE2B_OUTBYTES ||\n        keylen \u003e BLAKE2B_KEYBYTES) {\n        return -1;\n    }\n    assert(outlen \u003c= UINT8_MAX);\n    assert(keylen \u003c= UINT8_MAX);\n    if (key == NULL || keylen \u003c= 0U) {\n        if (blake2b_init_salt_personal((blake2b_state *) (void *) state,\n                                       (uint8_t) outlen, salt, personal) != 0) {\n            return -1; /* LCOV_EXCL_LINE */\n        }\n    } else if (blake2b_init_key_salt_personal((blake2b_state *) (void *) state,\n                                              (uint8_t) outlen, key,\n                                              (uint8_t) keylen, salt,\n                                              personal) != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/generichash_blake2b.c","line_number":68,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"634982":{"score":0.6978442,"function_name":"crypto_generichash_blake2b_final","code":"int\ncrypto_generichash_blake2b_final(crypto_generichash_blake2b_state *state,\n                                 unsigned char *out, const size_t outlen)\n{\n    assert(outlen \u003c= UINT8_MAX);\n    return blake2b_final((blake2b_state *) (void *) state,\n                         (uint8_t *) out, (uint8_t) outlen);\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/generichash_blake2b.c","line_number":103,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"635534":{"score":0.7496568,"function_name":"be64enc","code":"static inline void\nbe64enc(void * pp, uint64_t x)\n{\n    uint8_t * p = (uint8_t *)pp;\n\n    p[7] = x \u0026 0xff;\n    p[6] = (x \u003e\u003e 8) \u0026 0xff;\n    p[5] = (x \u003e\u003e 16) \u0026 0xff;\n    p[4] = (x \u003e\u003e 24) \u0026 0xff;\n    p[3] = (x \u003e\u003e 32) \u0026 0xff;\n    p[2] = (x \u003e\u003e 40) \u0026 0xff;\n    p[1] = (x \u003e\u003e 48) \u0026 0xff;\n    p[0] = (x \u003e\u003e 56) \u0026 0xff;\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256.c","line_number":64,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.7"},"635818":{"score":0.5885279,"function_name":"be64enc_vect","code":"static void\nbe64enc_vect(unsigned char *dst, const uint64_t *src, size_t len)\n{\n    size_t i;\n\n    for (i = 0; i \u003c len / 8; i++) {\n        STORE64_BE(dst + i * 8, src[i]);\n    }\n}","filepath":"src/libsodium/crypto_hash/sha512/cp/hash_sha512_cp.c","line_number":40,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"635914":{"score":0.5939364,"function_name":"Hacl_Bignum_Fproduct_sum_scalar_multiplication_","code":"inline static void\nHacl_Bignum_Fproduct_sum_scalar_multiplication_(\n  FStar_UInt128_uint128 *output,\n  uint64_t *input,\n  uint64_t s\n)\n{\n  uint32_t i;\n  for (i = (uint32_t)0U; i \u003c (uint32_t)5U; i = i + (uint32_t)1U)\n  {\n    FStar_UInt128_uint128 xi = output[i];\n    uint64_t yi = input[i];\n    output[i] = FStar_UInt128_add_mod(xi, FStar_UInt128_mul_wide(yi, s));\n  }\n}","filepath":"3rdparty/everest/library/legacy/Hacl_Curve25519.c","line_number":55,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.22.0"},"636009":{"score":0.76458776,"function_name":"SHA512_Transform","code":"static void\nSHA512_Transform(uint64_t *state, const uint8_t block[128], uint64_t W[80],\n                 uint64_t S[8])\n{\n    int i;\n\n    be64dec_vect(W, block, 128);\n    memcpy(S, state, 64);\n    for (i = 0; i \u003c 80; i += 16) {\n        RNDr(S, W, 0, i);\n        RNDr(S, W, 1, i);\n        RNDr(S, W, 2, i);\n        RNDr(S, W, 3, i);\n        RNDr(S, W, 4, i);\n        RNDr(S, W, 5, i);\n        RNDr(S, W, 6, i);\n        RNDr(S, W, 7, i);\n        RNDr(S, W, 8, i);\n        RNDr(S, W, 9, i);\n        RNDr(S, W, 10, i);\n        RNDr(S, W, 11, i);\n        RNDr(S, W, 12, i);\n        RNDr(S, W, 13, i);\n        RNDr(S, W, 14, i);\n        RNDr(S, W, 15, i);\n        if (i == 64) {\n            break;\n        }\n        MSCH(W, 0, i);\n        MSCH(W, 1, i);\n        MSCH(W, 2, i);\n        MSCH(W, 3, i);\n        MSCH(W, 4, i);\n        MSCH(W, 5, i);\n        MSCH(W, 6, i);\n        MSCH(W, 7, i);\n        MSCH(W, 8, i);\n        MSCH(W, 9, i);\n        MSCH(W, 10, i);\n        MSCH(W, 11, i);\n        MSCH(W, 12, i);\n        MSCH(W, 13, i);\n        MSCH(W, 14, i);\n        MSCH(W, 15, i);\n    }\n    for (i = 0; i \u003c 8; i++) {\n        state[i] += S[i];\n    }\n}","filepath":"src/libsodium/crypto_hash/sha512/cp/hash_sha512_cp.c","line_number":113,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"656611":{"score":0.8920719,"function_name":"SHA512_Pad","code":"static void\nSHA512_Pad(crypto_hash_sha512_state *state, uint64_t tmp64[80 + 8])\n{\n    uint64_t r;\n    uint64_t i;\n\n    r = (state-\u003ecount[1] \u003e\u003e 3) \u0026 0x7f;\n    if (r \u003c 112) {\n        for (i = 0; i \u003c 112 - r; i++) {\n            state-\u003ebuf[r + i] = PAD[i];\n        }\n    } else {\n        for (i = 0; i \u003c 128 - r; i++) {\n            state-\u003ebuf[r + i] = PAD[i];\n        }\n        SHA512_Transform(state-\u003estate, state-\u003ebuf, \u0026tmp64[0], \u0026tmp64[80]);\n        memset(\u0026state-\u003ebuf[0], 0, 112);\n    }\n    be64enc_vect(\u0026state-\u003ebuf[112], state-\u003ecount, 16);\n    SHA512_Transform(state-\u003estate, state-\u003ebuf, \u0026tmp64[0], \u0026tmp64[80]);\n}","filepath":"src/libsodium/crypto_hash/sha512/cp/hash_sha512_cp.c","line_number":172,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"656901":{"score":0.7889768,"function_name":"crypto_hash_sha512_init","code":"int\ncrypto_hash_sha512_init(crypto_hash_sha512_state *state)\n{\n    static const uint64_t sha512_initial_state[8] = {\n        0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL, 0x3c6ef372fe94f82bULL,\n        0xa54ff53a5f1d36f1ULL, 0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,\n        0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL\n    };\n\n    state-\u003ecount[0] = state-\u003ecount[1] = (uint64_t) 0U;\n    memcpy(state-\u003estate, sha512_initial_state, sizeof sha512_initial_state);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_hash/sha512/cp/hash_sha512_cp.c","line_number":194,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"656990":{"score":0.7708311,"function_name":"crypto_hash_sha512_update","code":"int\ncrypto_hash_sha512_update(crypto_hash_sha512_state *state,\n                          const unsigned char *in, unsigned long long inlen)\n{\n    uint64_t           tmp64[80 + 8];\n    uint64_t           bitlen[2];\n    unsigned long long i;\n    unsigned long long r;\n\n    if (inlen \u003c= 0U) {\n        return 0;\n    }\n    r = (unsigned long long) ((state-\u003ecount[1] \u003e\u003e 3) \u0026 0x7f);\n\n    bitlen[1] = ((uint64_t) inlen) \u003c\u003c 3;\n    bitlen[0] = ((uint64_t) inlen) \u003e\u003e 61;\n    if ((state-\u003ecount[1] += bitlen[1]) \u003c bitlen[1]) {\n        state-\u003ecount[0]++;\n    }\n    state-\u003ecount[0] += bitlen[0];\n    if (inlen \u003c 128 - r) {\n        for (i = 0; i \u003c inlen; i++) {\n            state-\u003ebuf[r + i] = in[i];\n        }\n        return 0;\n    }\n    for (i = 0; i \u003c 128 - r; i++) {\n        state-\u003ebuf[r + i] = in[i];\n    }\n    SHA512_Transform(state-\u003estate, state-\u003ebuf, \u0026tmp64[0], \u0026tmp64[80]);\n    in += 128 - r;\n    inlen -= 128 - r;\n\n    while (inlen \u003e= 128) {\n        SHA512_Transform(state-\u003estate, in, \u0026tmp64[0], \u0026tmp64[80]);\n        in += 128;\n        inlen -= 128;\n    }\n    inlen \u0026= 127;\n    for (i = 0; i \u003c inlen; i++) {\n        state-\u003ebuf[i] = in[i];\n    }\n    sodium_memzero((void *) tmp64, sizeof tmp64);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_hash/sha512/cp/hash_sha512_cp.c","line_number":209,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"658080":{"score":0.7675021,"function_name":"crypto_hash_sha512_final","code":"int\ncrypto_hash_sha512_final(crypto_hash_sha512_state *state, unsigned char *out)\n{\n    uint64_t tmp64[80 + 8];\n\n    SHA512_Pad(state, tmp64);\n    be64enc_vect(out, state-\u003estate, 64);\n    sodium_memzero((void *) tmp64, sizeof tmp64);\n    sodium_memzero((void *) state, sizeof *state);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_hash/sha512/cp/hash_sha512_cp.c","line_number":256,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"658811":{"score":0.49744427,"function_name":"U8TO32","code":"static unsigned long\nU8TO32(const unsigned char *p)\n{\n        return\n        (((unsigned long)(p[0] \u0026 0xff)      ) |\n         ((unsigned long)(p[1] \u0026 0xff) \u003c\u003c  8) |\n         ((unsigned long)(p[2] \u0026 0xff) \u003c\u003c 16) |\n         ((unsigned long)(p[3] \u0026 0xff) \u003c\u003c 24));\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna32.h","line_number":26,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.8"},"658898":{"score":0.8812152,"function_name":"poly1305_init","code":"static void\npoly1305_init(poly1305_state_internal_t *st, const unsigned char key[32])\n{\n        /* r \u0026= 0xffffffc0ffffffc0ffffffc0fffffff */\n        st-\u003er[0] = (U8TO32(\u0026key[ 0])     ) \u0026 0x3ffffff;\n        st-\u003er[1] = (U8TO32(\u0026key[ 3]) \u003e\u003e 2) \u0026 0x3ffff03;\n        st-\u003er[2] = (U8TO32(\u0026key[ 6]) \u003e\u003e 4) \u0026 0x3ffc0ff;\n        st-\u003er[3] = (U8TO32(\u0026key[ 9]) \u003e\u003e 6) \u0026 0x3f03fff;\n        st-\u003er[4] = (U8TO32(\u0026key[12]) \u003e\u003e 8) \u0026 0x00fffff;\n\n        /* h = 0 */\n        st-\u003eh[0] = 0;\n        st-\u003eh[1] = 0;\n        st-\u003eh[2] = 0;\n        st-\u003eh[3] = 0;\n        st-\u003eh[4] = 0;\n\n        /* save pad for later */\n        st-\u003epad[0] = U8TO32(\u0026key[16]);\n        st-\u003epad[1] = U8TO32(\u0026key[20]);\n        st-\u003epad[2] = U8TO32(\u0026key[24]);\n        st-\u003epad[3] = U8TO32(\u0026key[28]);\n\n        st-\u003eleftover = 0;\n        st-\u003efinal = 0;\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna32.h","line_number":46,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.8"},"659257":{"score":0.6305592,"function_name":"poly1305_blocks","code":"static void\npoly1305_blocks(poly1305_state_internal_t *st, const unsigned char *m, unsigned long long bytes)\n{\n        const unsigned long hibit = (st-\u003efinal) ? 0 : (1 \u003c\u003c 24); /* 1 \u003c\u003c 128 */\n        unsigned long r0,r1,r2,r3,r4;\n        unsigned long s1,s2,s3,s4;\n        unsigned long h0,h1,h2,h3,h4;\n        unsigned long long d0,d1,d2,d3,d4;\n        unsigned long c;\n\n        r0 = st-\u003er[0];\n        r1 = st-\u003er[1];\n        r2 = st-\u003er[2];\n        r3 = st-\u003er[3];\n        r4 = st-\u003er[4];\n\n        s1 = r1 * 5;\n        s2 = r2 * 5;\n        s3 = r3 * 5;\n        s4 = r4 * 5;\n\n        h0 = st-\u003eh[0];\n        h1 = st-\u003eh[1];\n        h2 = st-\u003eh[2];\n        h3 = st-\u003eh[3];\n        h4 = st-\u003eh[4];\n\n        while (bytes \u003e= poly1305_block_size) {\n                /* h += m[i] */\n                h0 += (U8TO32(m+ 0)     ) \u0026 0x3ffffff;\n                h1 += (U8TO32(m+ 3) \u003e\u003e 2) \u0026 0x3ffffff;\n                h2 += (U8TO32(m+ 6) \u003e\u003e 4) \u0026 0x3ffffff;\n                h3 += (U8TO32(m+ 9) \u003e\u003e 6) \u0026 0x3ffffff;\n                h4 += (U8TO32(m+12) \u003e\u003e 8) | hibit;\n\n                /* h *= r */\n                d0 = ((unsigned long long)h0 * r0) + ((unsigned long long)h1 * s4) + ((unsigned long long)h2 * s3) + ((unsigned long long)h3 * s2) + ((unsigned long long)h4 * s1);\n                d1 = ((unsigned long long)h0 * r1) + ((unsigned long long)h1 * r0) + ((unsigned long long)h2 * s4) + ((unsigned long long)h3 * s3) + ((unsigned long long)h4 * s2);\n                d2 = ((unsigned long long)h0 * r2) + ((unsigned long long)h1 * r1) + ((unsigned long long)h2 * r0) + ((unsigned long long)h3 * s4) + ((unsigned long long)h4 * s3);\n                d3 = ((unsigned long long)h0 * r3) + ((unsigned long long)h1 * r2) + ((unsigned long long)h2 * r1) + ((unsigned long long)h3 * r0) + ((unsigned long long)h4 * s4);\n                d4 = ((unsigned long long)h0 * r4) + ((unsigned long long)h1 * r3) + ((unsigned long long)h2 * r2) + ((unsigned long long)h3 * r1) + ((unsigned long long)h4 * r0);\n\n                /* (partial) h %= p */\n                              c = (unsigned long)(d0 \u003e\u003e 26); h0 = (unsigned long)d0 \u0026 0x3ffffff;\n                d1 += c;      c = (unsigned long)(d1 \u003e\u003e 26); h1 = (unsigned long)d1 \u0026 0x3ffffff;\n                d2 += c;      c = (unsigned long)(d2 \u003e\u003e 26); h2 = (unsigned long)d2 \u0026 0x3ffffff;\n                d3 += c;      c = (unsigned long)(d3 \u003e\u003e 26); h3 = (unsigned long)d3 \u0026 0x3ffffff;\n                d4 += c;      c = (unsigned long)(d4 \u003e\u003e 26); h4 = (unsigned long)d4 \u0026 0x3ffffff;\n                h0 += c * 5;  c =                (h0 \u003e\u003e 26); h0 =                h0 \u0026 0x3ffffff;\n                h1 += c;\n\n                m += poly1305_block_size;\n                bytes -= poly1305_block_size;\n        }\n\n        st-\u003eh[0] = h0;\n        st-\u003eh[1] = h1;\n        st-\u003eh[2] = h2;\n        st-\u003eh[3] = h3;\n        st-\u003eh[4] = h4;\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna32.h","line_number":73,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.8"},"661413":{"score":0.8243972,"function_name":"poly1305_finish","code":"static POLY1305_NOINLINE void\npoly1305_finish(poly1305_state_internal_t *st, unsigned char mac[16])\n{\n        unsigned long h0,h1,h2,h3,h4,c;\n        unsigned long g0,g1,g2,g3,g4;\n        unsigned long long f;\n        unsigned long mask;\n\n        /* process the remaining block */\n        if (st-\u003eleftover) {\n                unsigned long long i = st-\u003eleftover;\n                st-\u003ebuffer[i++] = 1;\n                for (; i \u003c poly1305_block_size; i++)\n                        st-\u003ebuffer[i] = 0;\n                st-\u003efinal = 1;\n                poly1305_blocks(st, st-\u003ebuffer, poly1305_block_size);\n        }\n\n        /* fully carry h */\n        h0 = st-\u003eh[0];\n        h1 = st-\u003eh[1];\n        h2 = st-\u003eh[2];\n        h3 = st-\u003eh[3];\n        h4 = st-\u003eh[4];\n\n                     c = h1 \u003e\u003e 26; h1 = h1 \u0026 0x3ffffff;\n        h2 +=     c; c = h2 \u003e\u003e 26; h2 = h2 \u0026 0x3ffffff;\n        h3 +=     c; c = h3 \u003e\u003e 26; h3 = h3 \u0026 0x3ffffff;\n        h4 +=     c; c = h4 \u003e\u003e 26; h4 = h4 \u0026 0x3ffffff;\n        h0 += c * 5; c = h0 \u003e\u003e 26; h0 = h0 \u0026 0x3ffffff;\n        h1 +=     c;\n\n        /* compute h + -p */\n        g0 = h0 + 5; c = g0 \u003e\u003e 26; g0 \u0026= 0x3ffffff;\n        g1 = h1 + c; c = g1 \u003e\u003e 26; g1 \u0026= 0x3ffffff;\n        g2 = h2 + c; c = g2 \u003e\u003e 26; g2 \u0026= 0x3ffffff;\n        g3 = h3 + c; c = g3 \u003e\u003e 26; g3 \u0026= 0x3ffffff;\n        g4 = h4 + c - (1 \u003c\u003c 26);\n\n        /* select h if h \u003c p, or h + -p if h \u003e= p */\n        mask = (g4 \u003e\u003e ((sizeof(unsigned long) * 8) - 1)) - 1;\n        g0 \u0026= mask;\n        g1 \u0026= mask;\n        g2 \u0026= mask;\n        g3 \u0026= mask;\n        g4 \u0026= mask;\n        mask = ~mask;\n        h0 = (h0 \u0026 mask) | g0;\n        h1 = (h1 \u0026 mask) | g1;\n        h2 = (h2 \u0026 mask) | g2;\n        h3 = (h3 \u0026 mask) | g3;\n        h4 = (h4 \u0026 mask) | g4;\n\n        /* h = h % (2^128) */\n        h0 = ((h0      ) | (h1 \u003c\u003c 26)) \u0026 0xffffffff;\n        h1 = ((h1 \u003e\u003e  6) | (h2 \u003c\u003c 20)) \u0026 0xffffffff;\n        h2 = ((h2 \u003e\u003e 12) | (h3 \u003c\u003c 14)) \u0026 0xffffffff;\n        h3 = ((h3 \u003e\u003e 18) | (h4 \u003c\u003c  8)) \u0026 0xffffffff;\n\n        /* mac = (h + pad) % (2^128) */\n        f = (unsigned long long)h0 + st-\u003epad[0]            ; h0 = (unsigned long)f;\n        f = (unsigned long long)h1 + st-\u003epad[1] + (f \u003e\u003e 32); h1 = (unsigned long)f;\n        f = (unsigned long long)h2 + st-\u003epad[2] + (f \u003e\u003e 32); h2 = (unsigned long)f;\n        f = (unsigned long long)h3 + st-\u003epad[3] + (f \u003e\u003e 32); h3 = (unsigned long)f;\n\n        U32TO8(mac +  0, h0);\n        U32TO8(mac +  4, h1);\n        U32TO8(mac +  8, h2);\n        U32TO8(mac + 12, h3);\n\n        /* zero out the state */\n        sodium_memzero((void *)st, sizeof *st);\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna32.h","line_number":135,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.8"},"662325":{"score":0.717361,"function_name":"poly1305_update","code":"static void\npoly1305_update(poly1305_state_internal_t *st, const unsigned char *m,\n                unsigned long long bytes)\n{\n    unsigned long long i;\n\n    /* handle leftover */\n    if (st-\u003eleftover) {\n        unsigned long long want = (poly1305_block_size - st-\u003eleftover);\n\n        if (want \u003e bytes)\n            want = bytes;\n        for (i = 0; i \u003c want; i++)\n            st-\u003ebuffer[st-\u003eleftover + i] = m[i];\n        bytes -= want;\n        m += want;\n        st-\u003eleftover += want;\n        if (st-\u003eleftover \u003c poly1305_block_size)\n            return;\n        poly1305_blocks(st, st-\u003ebuffer, poly1305_block_size);\n        st-\u003eleftover = 0;\n    }\n\n    /* process full blocks */\n    if (bytes \u003e= poly1305_block_size) {\n        unsigned long long want = (bytes \u0026 ~(poly1305_block_size - 1));\n\n        poly1305_blocks(st, m, want);\n        m += want;\n        bytes -= want;\n    }\n\n    /* store leftover */\n    if (bytes) {\n        for (i = 0; i \u003c bytes; i++) {\n            st-\u003ebuffer[st-\u003eleftover + i] = m[i];\n        }\n        st-\u003eleftover += bytes;\n    }\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna.c","line_number":12,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.7"},"662894":{"score":0.72996825,"function_name":"crypto_onetimeauth_poly1305_donna","code":"static int\ncrypto_onetimeauth_poly1305_donna(unsigned char *out, const unsigned char *m,\n                                  unsigned long long inlen,\n                                  const unsigned char *key)\n{\n    CRYPTO_ALIGN(64) poly1305_state_internal_t state;\n\n    poly1305_init(\u0026state, key);\n    poly1305_update(\u0026state, m, inlen);\n    poly1305_finish(\u0026state, out);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna.c","line_number":53,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.7"},"663227":{"score":0.7077426,"function_name":"crypto_onetimeauth_poly1305_donna_verify","code":"static int\ncrypto_onetimeauth_poly1305_donna_verify(const unsigned char *h,\n                                         const unsigned char *in,\n                                         unsigned long long inlen,\n                                         const unsigned char *k)\n{\n    unsigned char correct[16];\n\n    crypto_onetimeauth_poly1305_donna(correct,in,inlen,k);\n\n    return crypto_verify_16(h,correct);\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna.c","line_number":97,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.7"},"663383":{"score":0.5051463,"function_name":"Hacl_Bignum_Modulo_carry_top","code":"static void Hacl_Bignum_Modulo_carry_top(uint64_t *b)\n{\n  uint64_t b4 = b[4U];\n  uint64_t b0 = b[0U];\n  uint64_t b4_ = b4 \u0026 (uint64_t)0x7ffffffffffffU;\n  uint64_t b0_ = b0 + (uint64_t)19U * (b4 \u003e\u003e (uint32_t)51U);\n  b[4U] = b4_;\n  b[0U] = b0_;\n}","filepath":"3rdparty/everest/library/legacy/Hacl_Curve25519.c","line_number":34,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.22.0"},"663649":{"score":0.5657452,"function_name":"sodium_crit_enter","code":"int\nsodium_crit_enter(void)\n{\n    int ret;\n\n    if ((ret = pthread_mutex_lock(\u0026_sodium_lock)) == 0) {\n        assert(locked == 0);\n        locked = 1;\n    }\n    return ret;\n}","filepath":"src/libsodium/sodium/core.c","line_number":128,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"664641":{"score":0.8585386,"function_name":"fe_add","code":"void fe_add(fe h,fe f,fe g)\n{\n  crypto_int32 f0 = f[0];\n  crypto_int32 f1 = f[1];\n  crypto_int32 f2 = f[2];\n  crypto_int32 f3 = f[3];\n  crypto_int32 f4 = f[4];\n  crypto_int32 f5 = f[5];\n  crypto_int32 f6 = f[6];\n  crypto_int32 f7 = f[7];\n  crypto_int32 f8 = f[8];\n  crypto_int32 f9 = f[9];\n  crypto_int32 g0 = g[0];\n  crypto_int32 g1 = g[1];\n  crypto_int32 g2 = g[2];\n  crypto_int32 g3 = g[3];\n  crypto_int32 g4 = g[4];\n  crypto_int32 g5 = g[5];\n  crypto_int32 g6 = g[6];\n  crypto_int32 g7 = g[7];\n  crypto_int32 g8 = g[8];\n  crypto_int32 g9 = g[9];\n  crypto_int32 h0 = f0 + g0;\n  crypto_int32 h1 = f1 + g1;\n  crypto_int32 h2 = f2 + g2;\n  crypto_int32 h3 = f3 + g3;\n  crypto_int32 h4 = f4 + g4;\n  crypto_int32 h5 = f5 + g5;\n  crypto_int32 h6 = f6 + g6;\n  crypto_int32 h7 = f7 + g7;\n  crypto_int32 h8 = f8 + g8;\n  crypto_int32 h9 = f9 + g9;\n  h[0] = h0;\n  h[1] = h1;\n  h[2] = h2;\n  h[3] = h3;\n  h[4] = h4;\n  h[5] = h5;\n  h[6] = h6;\n  h[7] = h7;\n  h[8] = h8;\n  h[9] = h9;\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/fe_add_curve25519_ref10.c","line_number":17,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.6.0"},"664971":{"score":0.8943474,"function_name":"fe_sub","code":"void fe_sub(fe h,fe f,fe g)\n{\n  crypto_int32 f0 = f[0];\n  crypto_int32 f1 = f[1];\n  crypto_int32 f2 = f[2];\n  crypto_int32 f3 = f[3];\n  crypto_int32 f4 = f[4];\n  crypto_int32 f5 = f[5];\n  crypto_int32 f6 = f[6];\n  crypto_int32 f7 = f[7];\n  crypto_int32 f8 = f[8];\n  crypto_int32 f9 = f[9];\n  crypto_int32 g0 = g[0];\n  crypto_int32 g1 = g[1];\n  crypto_int32 g2 = g[2];\n  crypto_int32 g3 = g[3];\n  crypto_int32 g4 = g[4];\n  crypto_int32 g5 = g[5];\n  crypto_int32 g6 = g[6];\n  crypto_int32 g7 = g[7];\n  crypto_int32 g8 = g[8];\n  crypto_int32 g9 = g[9];\n  crypto_int32 h0 = f0 - g0;\n  crypto_int32 h1 = f1 - g1;\n  crypto_int32 h2 = f2 - g2;\n  crypto_int32 h3 = f3 - g3;\n  crypto_int32 h4 = f4 - g4;\n  crypto_int32 h5 = f5 - g5;\n  crypto_int32 h6 = f6 - g6;\n  crypto_int32 h7 = f7 - g7;\n  crypto_int32 h8 = f8 - g8;\n  crypto_int32 h9 = f9 - g9;\n  h[0] = h0;\n  h[1] = h1;\n  h[2] = h2;\n  h[3] = h3;\n  h[4] = h4;\n  h[5] = h5;\n  h[6] = h6;\n  h[7] = h7;\n  h[8] = h8;\n  h[9] = h9;\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/fe_sub_curve25519_ref10.c","line_number":17,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.6.0"},"666466":{"score":0.81270516,"function_name":"fe_copy","code":"void fe_copy(fe h,fe f)\n{\n  crypto_int32 f0 = f[0];\n  crypto_int32 f1 = f[1];\n  crypto_int32 f2 = f[2];\n  crypto_int32 f3 = f[3];\n  crypto_int32 f4 = f[4];\n  crypto_int32 f5 = f[5];\n  crypto_int32 f6 = f[6];\n  crypto_int32 f7 = f[7];\n  crypto_int32 f8 = f[8];\n  crypto_int32 f9 = f[9];\n  h[0] = f0;\n  h[1] = f1;\n  h[2] = f2;\n  h[3] = f3;\n  h[4] = f4;\n  h[5] = f5;\n  h[6] = f6;\n  h[7] = f7;\n  h[8] = f8;\n  h[9] = f9;\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/fe_copy_curve25519_ref10.c","line_number":9,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.6.0"},"666681":{"score":0.80616456,"function_name":"fe_mul","code":"void fe_mul(fe h,const fe f,const fe g)\n{\n  crypto_int32 f0 = f[0];\n  crypto_int32 f1 = f[1];\n  crypto_int32 f2 = f[2];\n  crypto_int32 f3 = f[3];\n  crypto_int32 f4 = f[4];\n  crypto_int32 f5 = f[5];\n  crypto_int32 f6 = f[6];\n  crypto_int32 f7 = f[7];\n  crypto_int32 f8 = f[8];\n  crypto_int32 f9 = f[9];\n  crypto_int32 g0 = g[0];\n  crypto_int32 g1 = g[1];\n  crypto_int32 g2 = g[2];\n  crypto_int32 g3 = g[3];\n  crypto_int32 g4 = g[4];\n  crypto_int32 g5 = g[5];\n  crypto_int32 g6 = g[6];\n  crypto_int32 g7 = g[7];\n  crypto_int32 g8 = g[8];\n  crypto_int32 g9 = g[9];\n  crypto_int32 g1_19 = 19 * g1; /* 1.959375*2^29 */\n  crypto_int32 g2_19 = 19 * g2; /* 1.959375*2^30; still ok */\n  crypto_int32 g3_19 = 19 * g3;\n  crypto_int32 g4_19 = 19 * g4;\n  crypto_int32 g5_19 = 19 * g5;\n  crypto_int32 g6_19 = 19 * g6;\n  crypto_int32 g7_19 = 19 * g7;\n  crypto_int32 g8_19 = 19 * g8;\n  crypto_int32 g9_19 = 19 * g9;\n  crypto_int32 f1_2 = 2 * f1;\n  crypto_int32 f3_2 = 2 * f3;\n  crypto_int32 f5_2 = 2 * f5;\n  crypto_int32 f7_2 = 2 * f7;\n  crypto_int32 f9_2 = 2 * f9;\n  crypto_int64 f0g0    = f0   * (crypto_int64) g0;\n  crypto_int64 f0g1    = f0   * (crypto_int64) g1;\n  crypto_int64 f0g2    = f0   * (crypto_int64) g2;\n  crypto_int64 f0g3    = f0   * (crypto_int64) g3;\n  crypto_int64 f0g4    = f0   * (crypto_int64) g4;\n  crypto_int64 f0g5    = f0   * (crypto_int64) g5;\n  crypto_int64 f0g6    = f0   * (crypto_int64) g6;\n  crypto_int64 f0g7    = f0   * (crypto_int64) g7;\n  crypto_int64 f0g8    = f0   * (crypto_int64) g8;\n  crypto_int64 f0g9    = f0   * (crypto_int64) g9;\n  crypto_int64 f1g0    = f1   * (crypto_int64) g0;\n  crypto_int64 f1g1_2  = f1_2 * (crypto_int64) g1;\n  crypto_int64 f1g2    = f1   * (crypto_int64) g2;\n  crypto_int64 f1g3_2  = f1_2 * (crypto_int64) g3;\n  crypto_int64 f1g4    = f1   * (crypto_int64) g4;\n  crypto_int64 f1g5_2  = f1_2 * (crypto_int64) g5;\n  crypto_int64 f1g6    = f1   * (crypto_int64) g6;\n  crypto_int64 f1g7_2  = f1_2 * (crypto_int64) g7;\n  crypto_int64 f1g8    = f1   * (crypto_int64) g8;\n  crypto_int64 f1g9_38 = f1_2 * (crypto_int64) g9_19;\n  crypto_int64 f2g0    = f2   * (crypto_int64) g0;\n  crypto_int64 f2g1    = f2   * (crypto_int64) g1;\n  crypto_int64 f2g2    = f2   * (crypto_int64) g2;\n  crypto_int64 f2g3    = f2   * (crypto_int64) g3;\n  crypto_int64 f2g4    = f2   * (crypto_int64) g4;\n  crypto_int64 f2g5    = f2   * (crypto_int64) g5;\n  crypto_int64 f2g6    = f2   * (crypto_int64) g6;\n  crypto_int64 f2g7    = f2   * (crypto_int64) g7;\n  crypto_int64 f2g8_19 = f2   * (crypto_int64) g8_19;\n  crypto_int64 f2g9_19 = f2   * (crypto_int64) g9_19;\n  crypto_int64 f3g0    = f3   * (crypto_int64) g0;\n  crypto_int64 f3g1_2  = f3_2 * (crypto_int64) g1;\n  crypto_int64 f3g2    = f3   * (crypto_int64) g2;\n  crypto_int64 f3g3_2  = f3_2 * (crypto_int64) g3;\n  crypto_int64 f3g4    = f3   * (crypto_int64) g4;\n  crypto_int64 f3g5_2  = f3_2 * (crypto_int64) g5;\n  crypto_int64 f3g6    = f3   * (crypto_int64) g6;\n  crypto_int64 f3g7_38 = f3_2 * (crypto_int64) g7_19;\n  crypto_int64 f3g8_19 = f3   * (crypto_int64) g8_19;\n  crypto_int64 f3g9_38 = f3_2 * (crypto_int64) g9_19;\n  crypto_int64 f4g0    = f4   * (crypto_int64) g0;\n  crypto_int64 f4g1    = f4   * (crypto_int64) g1;\n  crypto_int64 f4g2    = f4   * (crypto_int64) g2;\n  crypto_int64 f4g3    = f4   * (crypto_int64) g3;\n  crypto_int64 f4g4    = f4   * (crypto_int64) g4;\n  crypto_int64 f4g5    = f4   * (crypto_int64) g5;\n  crypto_int64 f4g6_19 = f4   * (crypto_int64) g6_19;\n  crypto_int64 f4g7_19 = f4   * (crypto_int64) g7_19;\n  crypto_int64 f4g8_19 = f4   * (crypto_int64) g8_19;\n  crypto_int64 f4g9_19 = f4   * (crypto_int64) g9_19;\n  crypto_int64 f5g0    = f5   * (crypto_int64) g0;\n  crypto_int64 f5g1_2  = f5_2 * (crypto_int64) g1;\n  crypto_int64 f5g2    = f5   * (crypto_int64) g2;\n  crypto_int64 f5g3_2  = f5_2 * (crypto_int64) g3;\n  crypto_int64 f5g4    = f5   * (crypto_int64) g4;\n  crypto_int64 f5g5_38 = f5_2 * (crypto_int64) g5_19;\n  crypto_int64 f5g6_19 = f5   * (crypto_int64) g6_19;\n  crypto_int64 f5g7_38 = f5_2 * (crypto_int64) g7_19;\n  crypto_int64 f5g8_19 = f5   * (crypto_int64) g8_19;\n  crypto_int64 f5g9_38 = f5_2 * (crypto_int64) g9_19;\n  crypto_int64 f6g0    = f6   * (crypto_int64) g0;\n  crypto_int64 f6g1    = f6   * (crypto_int64) g1;\n  crypto_int64 f6g2    = f6   * (crypto_int64) g2;\n  crypto_int64 f6g3    = f6   * (crypto_int64) g3;\n  crypto_int64 f6g4_19 = f6   * (crypto_int64) g4_19;\n  crypto_int64 f6g5_19 = f6   * (crypto_int64) g5_19;\n  crypto_int64 f6g6_19 = f6   * (crypto_int64) g6_19;\n  crypto_int64 f6g7_19 = f6   * (crypto_int64) g7_19;\n  crypto_int64 f6g8_19 = f6   * (crypto_int64) g8_19;\n  crypto_int64 f6g9_19 = f6   * (crypto_int64) g9_19;\n  crypto_int64 f7g0    = f7   * (crypto_int64) g0;\n  crypto_int64 f7g1_2  = f7_2 * (crypto_int64) g1;\n  crypto_int64 f7g2    = f7   * (crypto_int64) g2;\n  crypto_int64 f7g3_38 = f7_2 * (crypto_int64) g3_19;\n  crypto_int64 f7g4_19 = f7   * (crypto_int64) g4_19;\n  crypto_int64 f7g5_38 = f7_2 * (crypto_int64) g5_19;\n  crypto_int64 f7g6_19 = f7   * (crypto_int64) g6_19;\n  crypto_int64 f7g7_38 = f7_2 * (crypto_int64) g7_19;\n  crypto_int64 f7g8_19 = f7   * (crypto_int64) g8_19;\n  crypto_int64 f7g9_38 = f7_2 * (crypto_int64) g9_19;\n  crypto_int64 f8g0    = f8   * (crypto_int64) g0;\n  crypto_int64 f8g1    = f8   * (crypto_int64) g1;\n  crypto_int64 f8g2_19 = f8   * (crypto_int64) g2_19;\n  crypto_int64 f8g3_19 = f8   * (crypto_int64) g3_19;\n  crypto_int64 f8g4_19 = f8   * (crypto_int64) g4_19;\n  crypto_int64 f8g5_19 = f8   * (crypto_int64) g5_19;\n  crypto_int64 f8g6_19 = f8   * (crypto_int64) g6_19;\n  crypto_int64 f8g7_19 = f8   * (crypto_int64) g7_19;\n  crypto_int64 f8g8_19 = f8   * (crypto_int64) g8_19;\n  crypto_int64 f8g9_19 = f8   * (crypto_int64) g9_19;\n  crypto_int64 f9g0    = f9   * (crypto_int64) g0;\n  crypto_int64 f9g1_38 = f9_2 * (crypto_int64) g1_19;\n  crypto_int64 f9g2_19 = f9   * (crypto_int64) g2_19;\n  crypto_int64 f9g3_38 = f9_2 * (crypto_int64) g3_19;\n  crypto_int64 f9g4_19 = f9   * (crypto_int64) g4_19;\n  crypto_int64 f9g5_38 = f9_2 * (crypto_int64) g5_19;\n  crypto_int64 f9g6_19 = f9   * (crypto_int64) g6_19;\n  crypto_int64 f9g7_38 = f9_2 * (crypto_int64) g7_19;\n  crypto_int64 f9g8_19 = f9   * (crypto_int64) g8_19;\n  crypto_int64 f9g9_38 = f9_2 * (crypto_int64) g9_19;\n  crypto_int64 h0 = f0g0+f1g9_38+f2g8_19+f3g7_38+f4g6_19+f5g5_38+f6g4_19+f7g3_38+f8g2_19+f9g1_38;\n  crypto_int64 h1 = f0g1+f1g0   +f2g9_19+f3g8_19+f4g7_19+f5g6_19+f6g5_19+f7g4_19+f8g3_19+f9g2_19;\n  crypto_int64 h2 = f0g2+f1g1_2 +f2g0   +f3g9_38+f4g8_19+f5g7_38+f6g6_19+f7g5_38+f8g4_19+f9g3_38;\n  crypto_int64 h3 = f0g3+f1g2   +f2g1   +f3g0   +f4g9_19+f5g8_19+f6g7_19+f7g6_19+f8g5_19+f9g4_19;\n  crypto_int64 h4 = f0g4+f1g3_2 +f2g2   +f3g1_2 +f4g0   +f5g9_38+f6g8_19+f7g7_38+f8g6_19+f9g5_38;\n  crypto_int64 h5 = f0g5+f1g4   +f2g3   +f3g2   +f4g1   +f5g0   +f6g9_19+f7g8_19+f8g7_19+f9g6_19;\n  crypto_int64 h6 = f0g6+f1g5_2 +f2g4   +f3g3_2 +f4g2   +f5g1_2 +f6g0   +f7g9_38+f8g8_19+f9g7_38;\n  crypto_int64 h7 = f0g7+f1g6   +f2g5   +f3g4   +f4g3   +f5g2   +f6g1   +f7g0   +f8g9_19+f9g8_19;\n  crypto_int64 h8 = f0g8+f1g7_2 +f2g6   +f3g5_2 +f4g4   +f5g3_2 +f6g2   +f7g1_2 +f8g0   +f9g9_38;\n  crypto_int64 h9 = f0g9+f1g8   +f2g7   +f3g6   +f4g5   +f5g4   +f6g3   +f7g2   +f8g1   +f9g0   ;\n  crypto_int64 carry0;\n  crypto_int64 carry1;\n  crypto_int64 carry2;\n  crypto_int64 carry3;\n  crypto_int64 carry4;\n  crypto_int64 carry5;\n  crypto_int64 carry6;\n  crypto_int64 carry7;\n  crypto_int64 carry8;\n  crypto_int64 carry9;\n\n  /*\n  |h0| \u003c= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))\n    i.e. |h0| \u003c= 1.4*2^60; narrower ranges for h2, h4, h6, h8\n  |h1| \u003c= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))\n    i.e. |h1| \u003c= 1.7*2^59; narrower ranges for h3, h5, h7, h9\n  */\n\n  carry0 = (h0 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h1 += carry0; h0 -= carry0 \u003c\u003c 26;\n  carry4 = (h4 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h5 += carry4; h4 -= carry4 \u003c\u003c 26;\n  /* |h0| \u003c= 2^25 */\n  /* |h4| \u003c= 2^25 */\n  /* |h1| \u003c= 1.71*2^59 */\n  /* |h5| \u003c= 1.71*2^59 */\n\n  carry1 = (h1 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h2 += carry1; h1 -= carry1 \u003c\u003c 25;\n  carry5 = (h5 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h6 += carry5; h5 -= carry5 \u003c\u003c 25;\n  /* |h1| \u003c= 2^24; from now on fits into int32 */\n  /* |h5| \u003c= 2^24; from now on fits into int32 */\n  /* |h2| \u003c= 1.41*2^60 */\n  /* |h6| \u003c= 1.41*2^60 */\n\n  carry2 = (h2 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h3 += carry2; h2 -= carry2 \u003c\u003c 26;\n  carry6 = (h6 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h7 += carry6; h6 -= carry6 \u003c\u003c 26;\n  /* |h2| \u003c= 2^25; from now on fits into int32 unchanged */\n  /* |h6| \u003c= 2^25; from now on fits into int32 unchanged */\n  /* |h3| \u003c= 1.71*2^59 */\n  /* |h7| \u003c= 1.71*2^59 */\n\n  carry3 = (h3 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h4 += carry3; h3 -= carry3 \u003c\u003c 25;\n  carry7 = (h7 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h8 += carry7; h7 -= carry7 \u003c\u003c 25;\n  /* |h3| \u003c= 2^24; from now on fits into int32 unchanged */\n  /* |h7| \u003c= 2^24; from now on fits into int32 unchanged */\n  /* |h4| \u003c= 1.72*2^34 */\n  /* |h8| \u003c= 1.41*2^60 */\n\n  carry4 = (h4 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h5 += carry4; h4 -= carry4 \u003c\u003c 26;\n  carry8 = (h8 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h9 += carry8; h8 -= carry8 \u003c\u003c 26;\n  /* |h4| \u003c= 2^25; from now on fits into int32 unchanged */\n  /* |h8| \u003c= 2^25; from now on fits into int32 unchanged */\n  /* |h5| \u003c= 1.01*2^24 */\n  /* |h9| \u003c= 1.71*2^59 */\n\n  carry9 = (h9 + (crypto_int64) (1\u003c\u003c24)) \u003e\u003e 25; h0 += carry9 * 19; h9 -= carry9 \u003c\u003c 25;\n  /* |h9| \u003c= 2^24; from now on fits into int32 unchanged */\n  /* |h0| \u003c= 1.1*2^39 */\n\n  carry0 = (h0 + (crypto_int64) (1\u003c\u003c25)) \u003e\u003e 26; h1 += carry0; h0 -= carry0 \u003c\u003c 26;\n  /* |h0| \u003c= 2^25; from now on fits into int32 unchanged */\n  /* |h1| \u003c= 1.01*2^24 */\n\n  h[0] = (crypto_int32) h0;\n  h[1] = (crypto_int32) h1;\n  h[2] = (crypto_int32) h2;\n  h[3] = (crypto_int32) h3;\n  h[4] = (crypto_int32) h4;\n  h[5] = (crypto_int32) h5;\n  h[6] = (crypto_int32) h6;\n  h[7] = (crypto_int32) h7;\n  h[8] = (crypto_int32) h8;\n  h[9] = (crypto_int32) h9;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/fe_mul.c","line_number":36,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.1"},"690701":{"score":0.7742227,"function_name":"has_small_order","code":"static int\nhas_small_order(const unsigned char s[32])\n{\n    CRYPTO_ALIGN(16)\n    static const unsigned char blacklist[][32] = {\n        /* 0 (order 4) */\n        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 1 (order 1) */\n        { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 325606250916557431795983626356110631294008115727848805560023387167927233504\n           (order 8) */\n        { 0xe0, 0xeb, 0x7a, 0x7c, 0x3b, 0x41, 0xb8, 0xae, 0x16, 0x56, 0xe3,\n          0xfa, 0xf1, 0x9f, 0xc4, 0x6a, 0xda, 0x09, 0x8d, 0xeb, 0x9c, 0x32,\n          0xb1, 0xfd, 0x86, 0x62, 0x05, 0x16, 0x5f, 0x49, 0xb8, 0x00 },\n        /* 39382357235489614581723060781553021112529911719440698176882885853963445705823\n           (order 8) */\n        { 0x5f, 0x9c, 0x95, 0xbc, 0xa3, 0x50, 0x8c, 0x24, 0xb1, 0xd0, 0xb1,\n          0x55, 0x9c, 0x83, 0xef, 0x5b, 0x04, 0x44, 0x5c, 0xc4, 0x58, 0x1c,\n          0x8e, 0x86, 0xd8, 0x22, 0x4e, 0xdd, 0xd0, 0x9f, 0x11, 0x57 },\n        /* p-1 (order 2) */\n        { 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p (=0, order 4) */\n        { 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p+1 (=1, order 1) */\n        { 0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f }\n    };\n    unsigned char c[7] = { 0 };\n    unsigned int  k;\n    size_t        i, j;\n\n    COMPILER_ASSERT(7 == sizeof blacklist / sizeof blacklist[0]);\n    for (j = 0; j \u003c 31; j++) {\n        for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n            c[i] |= s[j] ^ blacklist[i][j];\n        }\n    }\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        c[i] |= (s[j] \u0026 0x7f) ^ blacklist[i][j];\n    }\n    k = 0;\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        k |= (c[i] - 1);\n    }\n    return (int) ((k \u003e\u003e 8) \u0026 1);\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":16,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"691019":{"score":0.7726804,"function_name":"crypto_scalarmult_curve25519_ref10","code":"static int\ncrypto_scalarmult_curve25519_ref10(unsigned char *q,\n                                   const unsigned char *n,\n                                   const unsigned char *p)\n{\n    unsigned char *t = q;\n    unsigned int   i;\n    fe25519        x1;\n    fe25519        x2;\n    fe25519        z2;\n    fe25519        x3;\n    fe25519        z3;\n    fe25519        tmp0;\n    fe25519        tmp1;\n    int            pos;\n    unsigned int   swap;\n    unsigned int   b;\n\n    if (has_small_order(p)) {\n        return -1;\n    }\n    for (i = 0; i \u003c 32; i++) {\n        t[i] = n[i];\n    }\n    t[0] \u0026= 248;\n    t[31] \u0026= 127;\n    t[31] |= 64;\n    fe25519_frombytes(x1, p);\n    fe25519_1(x2);\n    fe25519_0(z2);\n    fe25519_copy(x3, x1);\n    fe25519_1(z3);\n\n    swap = 0;\n    for (pos = 254; pos \u003e= 0; --pos) {\n        b = t[pos / 8] \u003e\u003e (pos \u0026 7);\n        b \u0026= 1;\n        swap ^= b;\n        fe25519_cswap(x2, x3, swap);\n        fe25519_cswap(z2, z3, swap);\n        swap = b;\n        fe25519_sub(tmp0, x3, z3);\n        fe25519_sub(tmp1, x2, z2);\n        fe25519_add(x2, x2, z2);\n        fe25519_add(z2, x3, z3);\n        fe25519_mul(z3, tmp0, x2);\n        fe25519_mul(z2, z2, tmp1);\n        fe25519_sq(tmp0, tmp1);\n        fe25519_sq(tmp1, x2);\n        fe25519_add(x3, z3, z2);\n        fe25519_sub(z2, z3, z2);\n        fe25519_mul(x2, tmp1, tmp0);\n        fe25519_sub(tmp1, tmp1, tmp0);\n        fe25519_sq(z2, z2);\n        fe25519_scalar_product(z3, tmp1, 121666);\n        fe25519_sq(x3, x3);\n        fe25519_add(tmp0, tmp0, z3);\n        fe25519_mul(z3, x1, z2);\n        fe25519_mul(z2, tmp1, tmp0);\n    }\n    fe25519_cswap(x2, x3, swap);\n    fe25519_cswap(z2, z3, swap);\n\n    fe25519_invert(z2, z2);\n    fe25519_mul(x2, x2, z2);\n    fe25519_tobytes(q, x2);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":72,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"692216":{"score":0.8480243,"function_name":"edwards_to_montgomery","code":"static void\nedwards_to_montgomery(fe25519 montgomeryX, const fe25519 edwardsY, const fe25519 edwardsZ)\n{\n    fe25519 tempX;\n    fe25519 tempZ;\n\n    fe25519_add(tempX, edwardsZ, edwardsY);\n    fe25519_sub(tempZ, edwardsZ, edwardsY);\n    fe25519_invert(tempZ, tempZ);\n    fe25519_mul(montgomeryX, tempX, tempZ);\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":142,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"692363":{"score":0.7757683,"function_name":"crypto_scalarmult_curve25519_ref10_base","code":"static int\ncrypto_scalarmult_curve25519_ref10_base(unsigned char *q,\n                                        const unsigned char *n)\n{\n    unsigned char *t = q;\n    ge25519_p3     A;\n    fe25519        pk;\n    unsigned int   i;\n\n    for (i = 0; i \u003c 32; i++) {\n        t[i] = n[i];\n    }\n    t[0] \u0026= 248;\n    t[31] \u0026= 127;\n    t[31] |= 64;\n    ge25519_scalarmult_base(\u0026A, t);\n    edwards_to_montgomery(pk, A.Y, A.Z);\n    fe25519_tobytes(q, pk);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":154,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"692673":{"score":0.8215794,"function_name":"iot_bsp_nv_get_data_path","code":"const char* iot_bsp_nv_get_data_path(iot_nvd_t nv_type)\n{\n\tHIT();\n\tIOT_WARN_CHECK((nv_type \u003c 0 || nv_type \u003e IOT_NVD_MAX), NULL, \"Invalid args\");\n\n\tswitch (nv_type) {\n\n\t/* wifi prov data */\n\tcase IOT_NVD_WIFI_PROV_STATUS:\n\t\treturn \"WifiProvStatus\";\n\tcase IOT_NVD_AP_SSID:\n\t\treturn \"IotAPSSID\";\n\tcase IOT_NVD_AP_PASS:\n\t\treturn \"IotAPPASS\";\n\tcase IOT_NVD_AP_BSSID:\n\t\treturn \"IotAPBSSID\";\n\tcase IOT_NVD_AP_AUTH_TYPE:\n\t\treturn \"IotAPAuthType\";\n\t/* wifi prov data */\n\n\t/* cloud prov data */\n\tcase IOT_NVD_CLOUD_PROV_STATUS:\n\t\treturn \"CloudProvStatus\";\n\tcase IOT_NVD_SERVER_URL:\n\t\treturn \"ServerURL\";\n\tcase IOT_NVD_SERVER_PORT:\n\t\treturn \"ServerPort\";\n\tcase IOT_NVD_LABEL:\n\t\treturn \"Label\";\n\t/* cloud prov data */\n\n\tcase IOT_NVD_DEVICE_ID:\n\t\treturn \"DeviceID\";\n\tcase IOT_NVD_MISC_INFO:\n\t\treturn \"MiscInfo\";\n\n\t/* stored in stnv partition (manufacturer data) */\n\tcase IOT_NVD_PRIVATE_KEY:\n\t\treturn \"PrivateKey\";\n\tcase IOT_NVD_PUBLIC_KEY:\n\t\treturn \"PublicKey\";\n\tcase IOT_NVD_ROOT_CA_CERT:\n\t\treturn \"RootCert\";\n\tcase IOT_NVD_SUB_CA_CERT:\n\t\treturn \"SubCert\";\n\tcase IOT_NVD_DEVICE_CERT:\n\t\treturn \"DeviceCert\";\n\tcase IOT_NVD_SERIAL_NUM:\n\t\treturn \"SerialNum\";\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}","filepath":"src/port/bsp/rtl8721c/iot_bsp_nv_data_rtl8721c.c","line_number":23,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"693110":{"score":0.6531402,"function_name":"store_block","code":"static void\nstore_block(void *output, const block *src)\n{\n    unsigned i;\n    for (i = 0; i \u003c ARGON2_QWORDS_IN_BLOCK; ++i) {\n        STORE64_LE((uint8_t *) output + i * sizeof(src-\u003ev[i]), src-\u003ev[i]);\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":70,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.13"},"693218":{"score":0.8397665,"function_name":"index_alpha","code":"uint32_t\nindex_alpha(const argon2_instance_t *instance,\n            const argon2_position_t *position, uint32_t pseudo_rand,\n            int same_lane)\n{\n    /*\n     * Pass 0:\n     *      This lane : all already finished segments plus already constructed\n     * blocks in this segment\n     *      Other lanes : all already finished segments\n     * Pass 1+:\n     *      This lane : (SYNC_POINTS - 1) last segments plus already constructed\n     * blocks in this segment\n     *      Other lanes : (SYNC_POINTS - 1) last segments\n     */\n    uint32_t reference_area_size;\n    uint64_t relative_position;\n    uint32_t start_position, absolute_position;\n\n    if (position-\u003epass == 0) {\n        /* First pass */\n        if (position-\u003eslice == 0) {\n            /* First slice */\n            reference_area_size =\n                position-\u003eindex - 1; /* all but the previous */\n        } else {\n            if (same_lane) {\n                /* The same lane =\u003e add current segment */\n                reference_area_size =\n                    position-\u003eslice * instance-\u003esegment_length +\n                    position-\u003eindex - 1;\n            } else {\n                reference_area_size =\n                    position-\u003eslice * instance-\u003esegment_length +\n                    ((position-\u003eindex == 0) ? (-1) : 0);\n            }\n        }\n    } else {\n        /* Second pass */\n        if (same_lane) {\n            reference_area_size = instance-\u003elane_length -\n                                  instance-\u003esegment_length + position-\u003eindex -\n                                  1;\n        } else {\n            reference_area_size = instance-\u003elane_length -\n                                  instance-\u003esegment_length +\n                                  ((position-\u003eindex == 0) ? (-1) : 0);\n        }\n    }\n\n    /* 1.2.4. Mapping pseudo_rand to 0..\u003creference_area_size-1\u003e and produce\n     * relative position */\n    relative_position = pseudo_rand;\n    relative_position = relative_position * relative_position \u003e\u003e 32;\n    relative_position = reference_area_size - 1 -\n                        (reference_area_size * relative_position \u003e\u003e 32);\n\n    /* 1.2.5 Computing starting position */\n    start_position = 0;\n\n    if (position-\u003epass != 0) {\n        start_position = (position-\u003eslice == ARGON2_SYNC_POINTS - 1)\n                             ? 0\n                             : (position-\u003eslice + 1) * instance-\u003esegment_length;\n    }\n\n    /* 1.2.6. Computing absolute position */\n    absolute_position = (start_position + relative_position) %\n                        instance-\u003elane_length; /* absolute position */\n    return absolute_position;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":223,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.13"},"693682":{"score":0.54801893,"function_name":"load_block","code":"static void\nload_block(block *dst, const void *input)\n{\n    unsigned i;\n    for (i = 0; i \u003c ARGON2_QWORDS_IN_BLOCK; ++i) {\n        dst-\u003ev[i] = LOAD64_LE((const uint8_t *) input + i * sizeof(dst-\u003ev[i]));\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":61,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.13"},"693764":{"score":0.6315713,"function_name":"store_block","code":"static void\nstore_block(void *output, const block *src)\n{\n    unsigned i;\n    for (i = 0; i \u003c ARGON2_QWORDS_IN_BLOCK; ++i) {\n        STORE64_LE((uint8_t *) output + i * sizeof(src-\u003ev[i]), src-\u003ev[i]);\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":48,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"693849":{"score":0.7354933,"function_name":"allocate_memory","code":"static int\nallocate_memory(block_region **region, uint32_t m_cost)\n{\n    void * base;\n    block *memory;\n    size_t memory_size;\n\n    if (region == NULL) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    memory_size = sizeof(block) * m_cost;\n    if (m_cost == 0 ||\n        memory_size / m_cost !=\n            sizeof(block)) { /*1. Check for multiplication overflow*/\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    *region = (block_region *) malloc(\n        sizeof(block_region)); /*2. Try to allocate region*/\n    if (!*region) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    (*region)-\u003ebase = (*region)-\u003ememory = NULL;\n\n#if defined(MAP_ANON) \u0026\u0026 defined(HAVE_MMAP)\n    if ((base = mmap(NULL, memory_size, PROT_READ | PROT_WRITE,\n#ifdef MAP_NOCORE\n                     MAP_ANON | MAP_PRIVATE | MAP_NOCORE,\n#else\n                     MAP_ANON | MAP_PRIVATE,\n#endif\n                     -1, 0)) == MAP_FAILED) {\n        base = NULL; /* LCOV_EXCL_LINE */\n    }                /* LCOV_EXCL_LINE */\n    memcpy(\u0026memory, \u0026base, sizeof memory);\n#elif defined(HAVE_POSIX_MEMALIGN)\n    if ((errno = posix_memalign((void **) \u0026base, 64, memory_size)) != 0) {\n        base = NULL;\n    }\n    memcpy(\u0026memory, \u0026base, sizeof memory);\n#else\n    memory = NULL;\n    if (memory_size + 63 \u003c memory_size) {\n        base  = NULL;\n        errno = ENOMEM;\n    } else if ((base = malloc(memory_size + 63)) != NULL) {\n        uint8_t *aligned = ((uint8_t *) base) + 63;\n        aligned -= (uintptr_t) aligned \u0026 63;\n        memcpy(\u0026memory, \u0026aligned, sizeof memory);\n    }\n#endif\n    if (base == NULL) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    (*region)-\u003ebase   = base;\n    (*region)-\u003ememory = memory;\n    (*region)-\u003esize   = memory_size;\n\n    return ARGON2_OK;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":65,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694187":{"score":0.88797176,"function_name":"clear_memory","code":"static void\nclear_memory(argon2_instance_t *instance, int clear)\n{\n    /* LCOV_EXCL_START */\n    if (clear) {\n        if (instance-\u003eregion != NULL) {\n            sodium_memzero(instance-\u003eregion-\u003ememory,\n                           sizeof(block) * instance-\u003ememory_blocks);\n        }\n        if (instance-\u003epseudo_rands != NULL) {\n            sodium_memzero(instance-\u003epseudo_rands,\n                           sizeof(uint64_t) * instance-\u003esegment_length);\n        }\n    }\n    /* LCOV_EXCL_STOP */\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":133,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694300":{"score":0.63611674,"function_name":"free_memory","code":"static void\nfree_memory(block_region *region)\n{\n    if (region \u0026\u0026 region-\u003ebase) {\n#if defined(MAP_ANON) \u0026\u0026 defined(HAVE_MMAP)\n        if (munmap(region-\u003ebase, region-\u003esize)) {\n            return; /* LCOV_EXCL_LINE */\n        }\n#else\n        free(region-\u003ebase);\n#endif\n    }\n    free(region);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":155,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694370":{"score":0.8431582,"function_name":"free_instance","code":"void\nfree_instance(argon2_instance_t *instance, int flags)\n{\n    /* Clear memory */\n    clear_memory(instance, flags \u0026 ARGON2_FLAG_CLEAR_MEMORY);\n\n    /* Deallocate the memory */\n    free(instance-\u003epseudo_rands);\n    instance-\u003epseudo_rands = NULL;\n    free_memory(instance-\u003eregion);\n    instance-\u003eregion = NULL;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":170,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694469":{"score":0.9146013,"function_name":"finalize","code":"void\nfinalize(const argon2_context *context, argon2_instance_t *instance)\n{\n    if (context != NULL \u0026\u0026 instance != NULL) {\n        block    blockhash;\n        uint32_t l;\n\n        copy_block(\u0026blockhash,\n                   instance-\u003eregion-\u003ememory + instance-\u003elane_length - 1);\n\n        /* XOR the last blocks */\n        for (l = 1; l \u003c instance-\u003elanes; ++l) {\n            uint32_t last_block_in_lane =\n                l * instance-\u003elane_length + (instance-\u003elane_length - 1);\n            xor_block(\u0026blockhash,\n                      instance-\u003eregion-\u003ememory + last_block_in_lane);\n        }\n\n        /* Hash the result */\n        {\n            uint8_t blockhash_bytes[ARGON2_BLOCK_SIZE];\n            store_block(blockhash_bytes, \u0026blockhash);\n            blake2b_long(context-\u003eout, context-\u003eoutlen, blockhash_bytes,\n                         ARGON2_BLOCK_SIZE);\n            sodium_memzero(blockhash.v,\n                           ARGON2_BLOCK_SIZE); /* clear blockhash */\n            sodium_memzero(blockhash_bytes,\n                           ARGON2_BLOCK_SIZE); /* clear blockhash_bytes */\n        }\n\n        free_instance(instance, context-\u003eflags);\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":183,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694861":{"score":0.7276201,"function_name":"fill_memory_blocks","code":"void\nfill_memory_blocks(argon2_instance_t *instance)\n{\n    uint32_t r, s;\n\n    if (instance == NULL || instance-\u003elanes == 0) {\n        return; /* LCOV_EXCL_LINE */\n    }\n\n    for (r = 0; r \u003c instance-\u003epasses; ++r) {\n        for (s = 0; s \u003c ARGON2_SYNC_POINTS; ++s) {\n            uint32_t l;\n\n            for (l = 0; l \u003c instance-\u003elanes; ++l) {\n                argon2_position_t position;\n\n                position.pass  = r;\n                position.lane  = l;\n                position.slice = (uint8_t) s;\n                position.index = 0;\n                fill_segment(instance, position);\n            }\n        }\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":289,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"695000":{"score":0.8819288,"function_name":"validate_inputs","code":"int\nvalidate_inputs(const argon2_context *context)\n{\n    /* LCOV_EXCL_START */\n    if (NULL == context) {\n        return ARGON2_INCORRECT_PARAMETER;\n    }\n\n    if (NULL == context-\u003eout) {\n        return ARGON2_OUTPUT_PTR_NULL;\n    }\n\n    /* Validate output length */\n    if (ARGON2_MIN_OUTLEN \u003e context-\u003eoutlen) {\n        return ARGON2_OUTPUT_TOO_SHORT;\n    }\n\n    if (ARGON2_MAX_OUTLEN \u003c context-\u003eoutlen) {\n        return ARGON2_OUTPUT_TOO_LONG;\n    }\n\n    /* Validate password (required param) */\n    if (NULL == context-\u003epwd) {\n        if (0 != context-\u003epwdlen) {\n            return ARGON2_PWD_PTR_MISMATCH;\n        }\n    }\n\n    if (ARGON2_MIN_PWD_LENGTH \u003e context-\u003epwdlen) {\n        return ARGON2_PWD_TOO_SHORT;\n    }\n\n    if (ARGON2_MAX_PWD_LENGTH \u003c context-\u003epwdlen) {\n        return ARGON2_PWD_TOO_LONG;\n    }\n\n    /* Validate salt (required param) */\n    if (NULL == context-\u003esalt) {\n        if (0 != context-\u003esaltlen) {\n            return ARGON2_SALT_PTR_MISMATCH;\n        }\n    }\n\n    if (ARGON2_MIN_SALT_LENGTH \u003e context-\u003esaltlen) {\n        return ARGON2_SALT_TOO_SHORT;\n    }\n\n    if (ARGON2_MAX_SALT_LENGTH \u003c context-\u003esaltlen) {\n        return ARGON2_SALT_TOO_LONG;\n    }\n\n    /* Validate secret (optional param) */\n    if (NULL == context-\u003esecret) {\n        if (0 != context-\u003esecretlen) {\n            return ARGON2_SECRET_PTR_MISMATCH;\n        }\n    } else {\n        if (ARGON2_MIN_SECRET \u003e context-\u003esecretlen) {\n            return ARGON2_SECRET_TOO_SHORT;\n        }\n\n        if (ARGON2_MAX_SECRET \u003c context-\u003esecretlen) {\n            return ARGON2_SECRET_TOO_LONG;\n        }\n    }\n\n    /* Validate associated data (optional param) */\n    if (NULL == context-\u003ead) {\n        if (0 != context-\u003eadlen) {\n            return ARGON2_AD_PTR_MISMATCH;\n        }\n    } else {\n        if (ARGON2_MIN_AD_LENGTH \u003e context-\u003eadlen) {\n            return ARGON2_AD_TOO_SHORT;\n        }\n\n        if (ARGON2_MAX_AD_LENGTH \u003c context-\u003eadlen) {\n            return ARGON2_AD_TOO_LONG;\n        }\n    }\n\n    /* Validate memory cost */\n    if (ARGON2_MIN_MEMORY \u003e context-\u003em_cost) {\n        return ARGON2_MEMORY_TOO_LITTLE;\n    }\n\n    if (ARGON2_MAX_MEMORY \u003c context-\u003em_cost) {\n        return ARGON2_MEMORY_TOO_MUCH;\n    }\n\n    if (context-\u003em_cost \u003c 8 * context-\u003elanes) {\n        return ARGON2_MEMORY_TOO_LITTLE;\n    }\n\n    /* Validate time cost */\n    if (ARGON2_MIN_TIME \u003e context-\u003et_cost) {\n        return ARGON2_TIME_TOO_SMALL;\n    }\n\n    if (ARGON2_MAX_TIME \u003c context-\u003et_cost) {\n        return ARGON2_TIME_TOO_LARGE;\n    }\n\n    /* Validate lanes */\n    if (ARGON2_MIN_LANES \u003e context-\u003elanes) {\n        return ARGON2_LANES_TOO_FEW;\n    }\n\n    if (ARGON2_MAX_LANES \u003c context-\u003elanes) {\n        return ARGON2_LANES_TOO_MANY;\n    }\n\n    /* Validate threads */\n    if (ARGON2_MIN_THREADS \u003e context-\u003ethreads) {\n        return ARGON2_THREADS_TOO_FEW;\n    }\n\n    if (ARGON2_MAX_THREADS \u003c context-\u003ethreads) {\n        return ARGON2_THREADS_TOO_MANY;\n    }\n    /* LCOV_EXCL_STOP */\n\n    return ARGON2_OK;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":326,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.13"},"695375":{"score":0.8422068,"function_name":"fill_first_blocks","code":"void\nfill_first_blocks(uint8_t *blockhash, const argon2_instance_t *instance)\n{\n    uint32_t l;\n    /* Make the first and second block in each lane as G(H0||i||0) or\n       G(H0||i||1) */\n    uint8_t blockhash_bytes[ARGON2_BLOCK_SIZE];\n    for (l = 0; l \u003c instance-\u003elanes; ++l) {\n        STORE32_LE(blockhash + ARGON2_PREHASH_DIGEST_LENGTH, 0);\n        STORE32_LE(blockhash + ARGON2_PREHASH_DIGEST_LENGTH + 4, l);\n        blake2b_long(blockhash_bytes, ARGON2_BLOCK_SIZE, blockhash,\n                     ARGON2_PREHASH_SEED_LENGTH);\n        load_block(\u0026instance-\u003eregion-\u003ememory[l * instance-\u003elane_length + 0],\n                   blockhash_bytes);\n\n        STORE32_LE(blockhash + ARGON2_PREHASH_DIGEST_LENGTH, 1);\n        blake2b_long(blockhash_bytes, ARGON2_BLOCK_SIZE, blockhash,\n                     ARGON2_PREHASH_SEED_LENGTH);\n        load_block(\u0026instance-\u003eregion-\u003ememory[l * instance-\u003elane_length + 1],\n                   blockhash_bytes);\n    }\n    sodium_memzero(blockhash_bytes, ARGON2_BLOCK_SIZE);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":451,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.13"},"695742":{"score":0.7694839,"function_name":"initial_hash","code":"void\ninitial_hash(uint8_t *blockhash, argon2_context *context, argon2_type type)\n{\n    crypto_generichash_blake2b_state BlakeHash;\n    uint8_t                          value[4U /* sizeof(uint32_t) */];\n\n    if (NULL == context || NULL == blockhash) {\n        return; /* LCOV_EXCL_LINE */\n    }\n\n    crypto_generichash_blake2b_init(\u0026BlakeHash, NULL, 0U,\n                                    ARGON2_PREHASH_DIGEST_LENGTH);\n\n    STORE32_LE(value, context-\u003elanes);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003eoutlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003em_cost);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003et_cost);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, ARGON2_VERSION_NUMBER);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, (uint32_t) type);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003epwdlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    if (context-\u003epwd != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003epwd, context-\u003epwdlen);\n\n        /* LCOV_EXCL_START */\n        if (context-\u003eflags \u0026 ARGON2_FLAG_CLEAR_PASSWORD) {\n            sodium_memzero(context-\u003epwd, context-\u003epwdlen);\n            context-\u003epwdlen = 0;\n        }\n        /* LCOV_EXCL_STOP */\n    }\n\n    STORE32_LE(value, context-\u003esaltlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    if (context-\u003esalt != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003esalt, context-\u003esaltlen);\n    }\n\n    STORE32_LE(value, context-\u003esecretlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    /* LCOV_EXCL_START */\n    if (context-\u003esecret != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003esecret, context-\u003esecretlen);\n\n        if (context-\u003eflags \u0026 ARGON2_FLAG_CLEAR_SECRET) {\n            sodium_memzero(context-\u003esecret, context-\u003esecretlen);\n            context-\u003esecretlen = 0;\n        }\n    }\n    /* LCOV_EXCL_STOP */\n\n    STORE32_LE(value, context-\u003eadlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    /* LCOV_EXCL_START */\n    if (context-\u003ead != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003ead, context-\u003eadlen);\n    }\n    /* LCOV_EXCL_STOP */\n\n    crypto_generichash_blake2b_final(\u0026BlakeHash, blockhash,\n                                     ARGON2_PREHASH_DIGEST_LENGTH);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":464,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"696710":{"score":0.82491255,"function_name":"initialize","code":"int\ninitialize(argon2_instance_t *instance, argon2_context *context)\n{\n    uint8_t blockhash[ARGON2_PREHASH_SEED_LENGTH];\n    int     result = ARGON2_OK;\n\n    if (instance == NULL || context == NULL) {\n        return ARGON2_INCORRECT_PARAMETER;\n    }\n\n    /* 1. Memory allocation */\n\n    if ((instance-\u003epseudo_rands = (uint64_t *)\n         malloc(sizeof(uint64_t) * instance-\u003esegment_length)) == NULL) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR;\n    }\n\n    result = allocate_memory(\u0026(instance-\u003eregion), instance-\u003ememory_blocks);\n    if (ARGON2_OK != result) {\n        free_instance(instance, context-\u003eflags);\n        return result;\n    }\n\n    /* 2. Initial hashing */\n    /* H_0 + 8 extra bytes to produce the first blocks */\n    /* uint8_t blockhash[ARGON2_PREHASH_SEED_LENGTH]; */\n    /* Hashing all inputs */\n    initial_hash(blockhash, context, instance-\u003etype);\n    /* Zeroing 8 extra bytes */\n    sodium_memzero(blockhash + ARGON2_PREHASH_DIGEST_LENGTH,\n                   ARGON2_PREHASH_SEED_LENGTH - ARGON2_PREHASH_DIGEST_LENGTH);\n\n    /* 3. Creating first blocks, we always have at least two blocks in a slice\n     */\n    fill_first_blocks(blockhash, instance);\n    /* Clearing the hash */\n    sodium_memzero(blockhash, ARGON2_PREHASH_SEED_LENGTH);\n\n    return ARGON2_OK;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":547,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"697258":{"score":0.84211564,"function_name":"index_alpha","code":"uint32_t index_alpha(const argon2_instance_t *instance,\n                     const argon2_position_t *position, uint32_t pseudo_rand,\n                     int same_lane) {\n    /*\n     * Pass 0:\n     *      This lane : all already finished segments plus already constructed\n     * blocks in this segment\n     *      Other lanes : all already finished segments\n     * Pass 1+:\n     *      This lane : (SYNC_POINTS - 1) last segments plus already constructed\n     * blocks in this segment\n     *      Other lanes : (SYNC_POINTS - 1) last segments\n     */\n    uint32_t reference_area_size;\n    uint64_t relative_position;\n    uint32_t start_position, absolute_position;\n\n    if (position-\u003epass == 0) {\n        /* First pass */\n        if (position-\u003eslice == 0) {\n            /* First slice */\n            reference_area_size =\n                position-\u003eindex - 1; /* all but the previous */\n        } else {\n            if (same_lane) {\n                /* The same lane =\u003e add current segment */\n                reference_area_size =\n                    position-\u003eslice * instance-\u003esegment_length +\n                    position-\u003eindex - 1;\n            } else {\n                reference_area_size =\n                    position-\u003eslice * instance-\u003esegment_length +\n                    ((position-\u003eindex == 0) ? (-1) : 0);\n            }\n        }\n    } else {\n        /* Second pass */\n        if (same_lane) {\n            reference_area_size = instance-\u003elane_length -\n                                  instance-\u003esegment_length + position-\u003eindex -\n                                  1;\n        } else {\n            reference_area_size = instance-\u003elane_length -\n                                  instance-\u003esegment_length +\n                                  ((position-\u003eindex == 0) ? (-1) : 0);\n        }\n    }\n\n    /* 1.2.4. Mapping pseudo_rand to 0..\u003creference_area_size-1\u003e and produce\n     * relative position */\n    relative_position = pseudo_rand;\n    relative_position = relative_position * relative_position \u003e\u003e 32;\n    relative_position = reference_area_size - 1 -\n                        (reference_area_size * relative_position \u003e\u003e 32);\n\n    /* 1.2.5 Computing starting position */\n    start_position = 0;\n\n    if (position-\u003epass != 0) {\n        start_position = (position-\u003eslice == ARGON2_SYNC_POINTS - 1)\n                             ? 0\n                             : (position-\u003eslice + 1) * instance-\u003esegment_length;\n    }\n\n    /* 1.2.6. Computing absolute position */\n    absolute_position = (start_position + relative_position) %\n                        instance-\u003elane_length; /* absolute position */\n    return absolute_position;\n}","filepath":"deps/libsodium/src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":200,"entry_url":"https://github.com/sodium-friends/sodium-native.git","slot_name":"v0.0.1"},"711700":{"score":0.6754856,"function_name":"fill_block","code":"static void\nfill_block(const block *prev_block, const block *ref_block, block *next_block)\n{\n    block    blockR, block_tmp;\n    unsigned i;\n\n    copy_block(\u0026blockR, ref_block);\n    xor_block(\u0026blockR, prev_block);\n    copy_block(\u0026block_tmp, \u0026blockR);\n    /* Now blockR = ref_block + prev_block and bloc_tmp = ref_block + prev_block\n       Apply Blake2 on columns of 64-bit words: (0,1,...,15), then\n       (16,17,..31)... finally (112,113,...127) */\n    for (i = 0; i \u003c 8; ++i) {\n        BLAKE2_ROUND_NOMSG(\n            blockR.v[16 * i], blockR.v[16 * i + 1], blockR.v[16 * i + 2],\n            blockR.v[16 * i + 3], blockR.v[16 * i + 4], blockR.v[16 * i + 5],\n            blockR.v[16 * i + 6], blockR.v[16 * i + 7], blockR.v[16 * i + 8],\n            blockR.v[16 * i + 9], blockR.v[16 * i + 10], blockR.v[16 * i + 11],\n            blockR.v[16 * i + 12], blockR.v[16 * i + 13], blockR.v[16 * i + 14],\n            blockR.v[16 * i + 15]);\n    }\n\n    /* Apply Blake2 on rows of 64-bit words: (0,1,16,17,...112,113), then\n       (2,3,18,19,...,114,115).. finally (14,15,30,31,...,126,127) */\n    for (i = 0; i \u003c 8; i++) {\n        BLAKE2_ROUND_NOMSG(\n            blockR.v[2 * i], blockR.v[2 * i + 1], blockR.v[2 * i + 16],\n            blockR.v[2 * i + 17], blockR.v[2 * i + 32], blockR.v[2 * i + 33],\n            blockR.v[2 * i + 48], blockR.v[2 * i + 49], blockR.v[2 * i + 64],\n            blockR.v[2 * i + 65], blockR.v[2 * i + 80], blockR.v[2 * i + 81],\n            blockR.v[2 * i + 96], blockR.v[2 * i + 97], blockR.v[2 * i + 112],\n            blockR.v[2 * i + 113]);\n    }\n\n    copy_block(next_block, \u0026block_tmp);\n    xor_block(next_block, \u0026blockR);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c","line_number":23,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"725409":{"score":0.84318584,"function_name":"generate_addresses","code":"static void\ngenerate_addresses(const argon2_instance_t *instance,\n                   const argon2_position_t *position, uint64_t *pseudo_rands)\n{\n    block    zero_block, input_block, address_block, tmp_block;\n    uint32_t i;\n\n    init_block_value(\u0026zero_block, 0);\n    init_block_value(\u0026input_block, 0);\n\n    if (instance != NULL \u0026\u0026 position != NULL) {\n        input_block.v[0] = position-\u003epass;\n        input_block.v[1] = position-\u003elane;\n        input_block.v[2] = position-\u003eslice;\n        input_block.v[3] = instance-\u003ememory_blocks;\n        input_block.v[4] = instance-\u003epasses;\n        input_block.v[5] = instance-\u003etype;\n\n        for (i = 0; i \u003c instance-\u003esegment_length; ++i) {\n            if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {\n                input_block.v[6]++;\n                init_block_value(\u0026tmp_block, 0);\n                init_block_value(\u0026address_block, 0);\n                fill_block_with_xor(\u0026zero_block, \u0026input_block, \u0026tmp_block);\n                fill_block_with_xor(\u0026zero_block, \u0026tmp_block, \u0026address_block);\n            }\n\n            pseudo_rands[i] = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];\n        }\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c","line_number":111,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"725954":{"score":0.68510467,"function_name":"fill_segment_ref","code":"void\nfill_segment_ref(const argon2_instance_t *instance, argon2_position_t position)\n{\n    block    *ref_block = NULL, *curr_block = NULL;\n    /* Pseudo-random values that determine the reference block position */\n    uint64_t *pseudo_rands = NULL;\n    uint64_t  pseudo_rand, ref_index, ref_lane;\n    uint32_t  prev_offset, curr_offset;\n    uint32_t  starting_index;\n    uint32_t  i;\n    int       data_independent_addressing = 1;\n\n    if (instance == NULL) {\n        return;\n    }\n\n    if (instance-\u003etype == Argon2_id \u0026\u0026\n        (position.pass != 0 || position.slice \u003e= ARGON2_SYNC_POINTS / 2)) {\n        data_independent_addressing = 0;\n    }\n\n    pseudo_rands = instance-\u003epseudo_rands;\n\n    if (data_independent_addressing) {\n        generate_addresses(instance, \u0026position, pseudo_rands);\n    }\n\n    starting_index = 0;\n\n    if ((0 == position.pass) \u0026\u0026 (0 == position.slice)) {\n        starting_index = 2; /* we have already generated the first two blocks */\n    }\n\n    /* Offset of the current block */\n    curr_offset = position.lane * instance-\u003elane_length +\n                  position.slice * instance-\u003esegment_length + starting_index;\n\n    if (0 == curr_offset % instance-\u003elane_length) {\n        /* Last block in this lane */\n        prev_offset = curr_offset + instance-\u003elane_length - 1;\n    } else {\n        /* Previous block */\n        prev_offset = curr_offset - 1;\n    }\n\n    for (i = starting_index; i \u003c instance-\u003esegment_length;\n         ++i, ++curr_offset, ++prev_offset) {\n        /*1.1 Rotating prev_offset if needed */\n        if (curr_offset % instance-\u003elane_length == 1) {\n            prev_offset = curr_offset - 1;\n        }\n\n        /* 1.2 Computing the index of the reference block */\n        /* 1.2.1 Taking pseudo-random value from the previous block */\n        if (data_independent_addressing) {\n#pragma warning(push)\n#pragma warning(disable : 6385)\n            pseudo_rand = pseudo_rands[i];\n#pragma warning(pop)\n        } else {\n            pseudo_rand = instance-\u003eregion-\u003ememory[prev_offset].v[0];\n        }\n\n        /* 1.2.2 Computing the lane of the reference block */\n        ref_lane = ((pseudo_rand \u003e\u003e 32)) % instance-\u003elanes;\n\n        if ((position.pass == 0) \u0026\u0026 (position.slice == 0)) {\n            /* Can not reference other lanes yet */\n            ref_lane = position.lane;\n        }\n\n        /* 1.2.3 Computing the number of possible reference block within the\n         * lane.\n         */\n        position.index = i;\n        ref_index = index_alpha(instance, \u0026position, pseudo_rand \u0026 0xFFFFFFFF,\n                                ref_lane == position.lane);\n\n        /* 2 Creating a new block */\n        ref_block = instance-\u003eregion-\u003ememory +\n                    instance-\u003elane_length * ref_lane + ref_index;\n        curr_block = instance-\u003eregion-\u003ememory + curr_offset;\n        if (position.pass != 0) {\n            fill_block_with_xor(instance-\u003eregion-\u003ememory + prev_offset,\n                                ref_block, curr_block);\n        } else {\n            fill_block(instance-\u003eregion-\u003ememory + prev_offset, ref_block,\n                       curr_block);\n        }\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c","line_number":143,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"726635":{"score":0.72958213,"function_name":"blake2b_long","code":"int\nblake2b_long(void *pout, size_t outlen, const void *in, size_t inlen)\n{\n    uint8_t *out = (uint8_t *) pout;\n    crypto_generichash_blake2b_state blake_state;\n    uint8_t outlen_bytes[4 /* sizeof(uint32_t) */] = { 0 };\n    int     ret = -1;\n\n    if (outlen \u003e UINT32_MAX) {\n        goto fail; /* LCOV_EXCL_LINE */\n    }\n\n    /* Ensure little-endian byte order! */\n    STORE32_LE(outlen_bytes, (uint32_t) outlen);\n\n#define TRY(statement)   \\\n    do {                 \\\n        ret = statement; \\\n        if (ret \u003c 0) {   \\\n            goto fail;   \\\n        }                \\\n    } while ((void) 0, 0)\n\n    if (outlen \u003c= crypto_generichash_blake2b_BYTES_MAX) {\n        TRY(crypto_generichash_blake2b_init(\u0026blake_state, NULL, 0U, outlen));\n        TRY(crypto_generichash_blake2b_update(\u0026blake_state, outlen_bytes,\n                                              sizeof(outlen_bytes)));\n        TRY(crypto_generichash_blake2b_update(\n            \u0026blake_state, (const unsigned char *) in, inlen));\n        TRY(crypto_generichash_blake2b_final(\u0026blake_state, out, outlen));\n    } else {\n        uint32_t toproduce;\n        uint8_t  out_buffer[crypto_generichash_blake2b_BYTES_MAX];\n        uint8_t  in_buffer[crypto_generichash_blake2b_BYTES_MAX];\n        TRY(crypto_generichash_blake2b_init(\n            \u0026blake_state, NULL, 0U, crypto_generichash_blake2b_BYTES_MAX));\n        TRY(crypto_generichash_blake2b_update(\u0026blake_state, outlen_bytes,\n                                              sizeof(outlen_bytes)));\n        TRY(crypto_generichash_blake2b_update(\n            \u0026blake_state, (const unsigned char *) in, inlen));\n        TRY(crypto_generichash_blake2b_final(\n            \u0026blake_state, out_buffer, crypto_generichash_blake2b_BYTES_MAX));\n        memcpy(out, out_buffer, crypto_generichash_blake2b_BYTES_MAX / 2);\n        out += crypto_generichash_blake2b_BYTES_MAX / 2;\n        toproduce =\n            (uint32_t) outlen - crypto_generichash_blake2b_BYTES_MAX / 2;\n\n        while (toproduce \u003e crypto_generichash_blake2b_BYTES_MAX) {\n            memcpy(in_buffer, out_buffer, crypto_generichash_blake2b_BYTES_MAX);\n            TRY(crypto_generichash_blake2b(\n                out_buffer, crypto_generichash_blake2b_BYTES_MAX, in_buffer,\n                crypto_generichash_blake2b_BYTES_MAX, NULL, 0U));\n            memcpy(out, out_buffer, crypto_generichash_blake2b_BYTES_MAX / 2);\n            out += crypto_generichash_blake2b_BYTES_MAX / 2;\n            toproduce -= crypto_generichash_blake2b_BYTES_MAX / 2;\n        }\n\n        memcpy(in_buffer, out_buffer, crypto_generichash_blake2b_BYTES_MAX);\n        TRY(crypto_generichash_blake2b(out_buffer, toproduce, in_buffer,\n                                       crypto_generichash_blake2b_BYTES_MAX,\n                                       NULL, 0U));\n        memcpy(out, out_buffer, toproduce);\n    }\nfail:\n    sodium_memzero(\u0026blake_state, sizeof(blake_state));\n    return ret;\n#undef TRY\n}","filepath":"src/libsodium/crypto_pwhash/argon2/blake2b-long.c","line_number":12,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"727933":{"score":0.7601574,"function_name":"blake2b_set_lastblock","code":"static inline int\nblake2b_set_lastblock(blake2b_state *S)\n{\n    if (S-\u003elast_node) {\n        blake2b_set_lastnode(S);\n    }\n    S-\u003ef[0] = -1;\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":51,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"727995":{"score":0.5701299,"function_name":"blake2b_increment_counter","code":"static inline int\nblake2b_increment_counter(blake2b_state *S, const uint64_t inc)\n{\n#ifdef HAVE_TI_MODE\n    uint128_t t = ((uint128_t) S-\u003et[1] \u003c\u003c 64) | S-\u003et[0];\n    t += inc;\n    S-\u003et[0] = (uint64_t)(t \u003e\u003e 0);\n    S-\u003et[1] = (uint64_t)(t \u003e\u003e 64);\n#else\n    S-\u003et[0] += inc;\n    S-\u003et[1] += (S-\u003et[0] \u003c inc);\n#endif\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":61,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"728230":{"score":0.86063683,"function_name":"blake2b_init0","code":"static inline int\nblake2b_init0(blake2b_state *S)\n{\n    int i;\n\n    for (i  = 0; i \u003c 8; i++) {\n        S-\u003eh[i] = blake2b_IV[i];\n    }\n    /* zero everything between .t and .last_node */\n    memset((void *) \u0026S-\u003et, 0,\n           offsetof(blake2b_state, last_node) + sizeof(S-\u003elast_node)\n           - offsetof(blake2b_state, t));\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":92,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"728337":{"score":0.8525101,"function_name":"blake2b_init_param","code":"int\nblake2b_init_param(blake2b_state *S, const blake2b_param *P)\n{\n    size_t         i;\n    const uint8_t *p;\n\n    COMPILER_ASSERT(sizeof *P == 64);\n    blake2b_init0(S);\n    p = (const uint8_t *) (P);\n\n    /* IV XOR ParamBlock */\n    for (i = 0; i \u003c 8; i++) {\n        S-\u003eh[i] ^= LOAD64_LE(p + sizeof(S-\u003eh[i]) * i);\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":108,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"728480":{"score":0.83153105,"function_name":"blake2b_init","code":"int\nblake2b_init(blake2b_state *S, const uint8_t outlen)\n{\n    blake2b_param P[1];\n\n    if ((!outlen) || (outlen \u003e BLAKE2B_OUTBYTES)) {\n        sodium_misuse();\n    }\n    P-\u003edigest_length = outlen;\n    P-\u003ekey_length    = 0;\n    P-\u003efanout        = 1;\n    P-\u003edepth         = 1;\n    STORE32_LE(P-\u003eleaf_length, 0);\n    STORE64_LE(P-\u003enode_offset, 0);\n    P-\u003enode_depth   = 0;\n    P-\u003einner_length = 0;\n    memset(P-\u003ereserved, 0, sizeof(P-\u003ereserved));\n    memset(P-\u003esalt, 0, sizeof(P-\u003esalt));\n    memset(P-\u003epersonal, 0, sizeof(P-\u003epersonal));\n    return blake2b_init_param(S, P);\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":125,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"728715":{"score":0.77829236,"function_name":"blake2b_init_salt_personal","code":"int\nblake2b_init_salt_personal(blake2b_state *S, const uint8_t outlen,\n                           const void *salt, const void *personal)\n{\n    blake2b_param P[1];\n\n    if ((!outlen) || (outlen \u003e BLAKE2B_OUTBYTES)) {\n        sodium_misuse();\n    }\n    P-\u003edigest_length = outlen;\n    P-\u003ekey_length    = 0;\n    P-\u003efanout        = 1;\n    P-\u003edepth         = 1;\n    STORE32_LE(P-\u003eleaf_length, 0);\n    STORE64_LE(P-\u003enode_offset, 0);\n    P-\u003enode_depth   = 0;\n    P-\u003einner_length = 0;\n    memset(P-\u003ereserved, 0, sizeof(P-\u003ereserved));\n    if (salt != NULL) {\n        blake2b_param_set_salt(P, (const uint8_t *) salt);\n    } else {\n        memset(P-\u003esalt, 0, sizeof(P-\u003esalt));\n    }\n    if (personal != NULL) {\n        blake2b_param_set_personal(P, (const uint8_t *) personal);\n    } else {\n        memset(P-\u003epersonal, 0, sizeof(P-\u003epersonal));\n    }\n    return blake2b_init_param(S, P);\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":147,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"729014":{"score":0.81993306,"function_name":"blake2b_init_key","code":"int\nblake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key,\n                 const uint8_t keylen)\n{\n    blake2b_param P[1];\n\n    if ((!outlen) || (outlen \u003e BLAKE2B_OUTBYTES)) {\n        sodium_misuse();\n    }\n    if (!key || !keylen || keylen \u003e BLAKE2B_KEYBYTES) {\n        sodium_misuse(); /* does not return */\n    }\n    P-\u003edigest_length = outlen;\n    P-\u003ekey_length    = keylen;\n    P-\u003efanout        = 1;\n    P-\u003edepth         = 1;\n    STORE32_LE(P-\u003eleaf_length, 0);\n    STORE64_LE(P-\u003enode_offset, 0);\n    P-\u003enode_depth   = 0;\n    P-\u003einner_length = 0;\n    memset(P-\u003ereserved, 0, sizeof(P-\u003ereserved));\n    memset(P-\u003esalt, 0, sizeof(P-\u003esalt));\n    memset(P-\u003epersonal, 0, sizeof(P-\u003epersonal));\n\n    if (blake2b_init_param(S, P) \u003c 0) {\n        sodium_misuse();\n    }\n    {\n        uint8_t block[BLAKE2B_BLOCKBYTES];\n        memset(block, 0, BLAKE2B_BLOCKBYTES);\n        memcpy(block, key, keylen); /* key and keylen cannot be 0 */\n        blake2b_update(S, block, BLAKE2B_BLOCKBYTES);\n        sodium_memzero(block, BLAKE2B_BLOCKBYTES); /* Burn the key from stack */\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":178,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"729486":{"score":0.6960556,"function_name":"blake2b","code":"int\nblake2b(uint8_t *out, const void *in, const void *key, const uint8_t outlen,\n        const uint64_t inlen, uint8_t keylen)\n{\n    CRYPTO_ALIGN(64) blake2b_state S[1];\n\n    /* Verify parameters */\n    if (NULL == in \u0026\u0026 inlen \u003e 0) {\n        sodium_misuse();\n    }\n    if (NULL == out) {\n        sodium_misuse();\n    }\n    if (!outlen || outlen \u003e BLAKE2B_OUTBYTES) {\n        sodium_misuse();\n    }\n    if (NULL == key \u0026\u0026 keylen \u003e 0) {\n        sodium_misuse();\n    }\n    if (keylen \u003e BLAKE2B_KEYBYTES) {\n        sodium_misuse();\n    }\n    if (keylen \u003e 0) {\n        if (blake2b_init_key(S, outlen, key, keylen) \u003c 0) {\n            sodium_misuse();\n        }\n    } else {\n        if (blake2b_init(S, outlen) \u003c 0) {\n            sodium_misuse();\n        }\n    }\n\n    blake2b_update(S, (const uint8_t *) in, inlen);\n    blake2b_final(S, out, outlen);\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":334,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"730046":{"score":0.7159777,"function_name":"blake2b_update","code":"int\nblake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen)\n{\n    while (inlen \u003e 0) {\n        size_t left = S-\u003ebuflen;\n        size_t fill = 2 * BLAKE2B_BLOCKBYTES - left;\n\n        if (inlen \u003e fill) {\n            memcpy(S-\u003ebuf + left, in, fill); /* Fill buffer */\n            S-\u003ebuflen += fill;\n            blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n            blake2b_compress(S, S-\u003ebuf); /* Compress */\n            memcpy(S-\u003ebuf, S-\u003ebuf + BLAKE2B_BLOCKBYTES,\n                   BLAKE2B_BLOCKBYTES); /* Shift buffer left */\n            S-\u003ebuflen -= BLAKE2B_BLOCKBYTES;\n            in += fill;\n            inlen -= fill;\n        } else /* inlen \u003c= fill */\n        {\n            memcpy(S-\u003ebuf + left, in, inlen);\n            S-\u003ebuflen += inlen; /* Be lazy, do not compress */\n            in += inlen;\n            inlen -= inlen;\n        }\n    }\n\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":262,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"730427":{"score":0.84520316,"function_name":"blake2b_final","code":"int\nblake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen)\n{\n    unsigned char buffer[BLAKE2B_OUTBYTES];\n\n    if (!outlen || outlen \u003e BLAKE2B_OUTBYTES) {\n        sodium_misuse();\n    }\n    if (blake2b_is_lastblock(S)) {\n        return -1;\n    }\n    if (S-\u003ebuflen \u003e BLAKE2B_BLOCKBYTES) {\n        blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n        blake2b_compress(S, S-\u003ebuf);\n        S-\u003ebuflen -= BLAKE2B_BLOCKBYTES;\n        assert(S-\u003ebuflen \u003c= BLAKE2B_BLOCKBYTES);\n        memcpy(S-\u003ebuf, S-\u003ebuf + BLAKE2B_BLOCKBYTES, S-\u003ebuflen);\n    }\n\n    blake2b_increment_counter(S, S-\u003ebuflen);\n    blake2b_set_lastblock(S);\n    memset(S-\u003ebuf + S-\u003ebuflen, 0,\n           2 * BLAKE2B_BLOCKBYTES - S-\u003ebuflen); /* Padding */\n    blake2b_compress(S, S-\u003ebuf);\n\n    COMPILER_ASSERT(sizeof buffer == 64U);\n    STORE64_LE(buffer + 8 * 0, S-\u003eh[0]);\n    STORE64_LE(buffer + 8 * 1, S-\u003eh[1]);\n    STORE64_LE(buffer + 8 * 2, S-\u003eh[2]);\n    STORE64_LE(buffer + 8 * 3, S-\u003eh[3]);\n    STORE64_LE(buffer + 8 * 4, S-\u003eh[4]);\n    STORE64_LE(buffer + 8 * 5, S-\u003eh[5]);\n    STORE64_LE(buffer + 8 * 6, S-\u003eh[6]);\n    STORE64_LE(buffer + 8 * 7, S-\u003eh[7]);\n    memcpy(out, buffer, outlen); /* outlen \u003c= BLAKE2B_OUTBYTES (64) */\n\n    sodium_memzero(S-\u003eh, sizeof S-\u003eh);\n    sodium_memzero(S-\u003ebuf, sizeof S-\u003ebuf);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":291,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"731129":{"score":0.71629715,"function_name":"blake2b_salt_personal","code":"int\nblake2b_salt_personal(uint8_t *out, const void *in, const void *key,\n                      const uint8_t outlen, const uint64_t inlen,\n                      uint8_t keylen, const void *salt, const void *personal)\n{\n    CRYPTO_ALIGN(64) blake2b_state S[1];\n\n    /* Verify parameters */\n    if (NULL == in \u0026\u0026 inlen \u003e 0) {\n        sodium_misuse();\n    }\n    if (NULL == out) {\n        sodium_misuse();\n    }\n    if (!outlen || outlen \u003e BLAKE2B_OUTBYTES) {\n        sodium_misuse();\n    }\n    if (NULL == key \u0026\u0026 keylen \u003e 0) {\n        sodium_misuse();\n    }\n    if (keylen \u003e BLAKE2B_KEYBYTES) {\n        sodium_misuse();\n    }\n    if (keylen \u003e 0) {\n        if (blake2b_init_key_salt_personal(S, outlen, key, keylen, salt,\n                                           personal) \u003c 0) {\n            sodium_misuse();\n        }\n    } else {\n        if (blake2b_init_salt_personal(S, outlen, salt, personal) \u003c 0) {\n            sodium_misuse();\n        }\n    }\n\n    blake2b_update(S, (const uint8_t *) in, inlen);\n    blake2b_final(S, out, outlen);\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":371,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"731560":{"score":0.66245323,"function_name":"blake2b_salt_personal","code":"int blake2b_salt_personal( uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen,\n                           const void *salt, const void *personal )\n{\n  blake2b_state S[1];\n\n  /* Verify parameters */\n  if ( NULL == in ) return -1;\n\n  if ( NULL == out ) return -1;\n\n  if( NULL == key ) keylen = 0;\n\n  if( keylen \u003e 0 )\n  {\n    if( blake2b_init_key_salt_personal( S, outlen, key, keylen, salt, personal ) \u003c 0 ) return -1;\n  }\n  else\n  {\n    if( blake2b_init_salt_personal( S, outlen, salt, personal ) \u003c 0 ) return -1;\n  }\n\n  blake2b_update( S, ( const uint8_t * )in, inlen );\n  blake2b_final( S, out, outlen );\n  return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c","line_number":436,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.6.0"},"732065":{"score":0.84642875,"function_name":"stream_ref","code":"static int\nstream_ref(unsigned char *c, unsigned long long clen, const unsigned char *n,\n           const unsigned char *k)\n{\n    unsigned char in[16];\n    unsigned char block[64];\n    unsigned char kcopy[32];\n    unsigned int  i;\n    unsigned int  u;\n\n    if (!clen) {\n        return 0;\n    }\n    for (i = 0; i \u003c 32; i++) {\n        kcopy[i] = k[i];\n    }\n    for (i = 0; i \u003c 8; i++) {\n        in[i] = n[i];\n    }\n    for (i = 8; i \u003c 16; i++) {\n        in[i] = 0;\n    }\n    while (clen \u003e= 64) {\n        crypto_core_salsa20(c, in, kcopy, NULL);\n        u = 1;\n        for (i = 8; i \u003c 16; i++) {\n            u += (unsigned int) in[i];\n            in[i] = u;\n            u \u003e\u003e= 8;\n        }\n        clen -= 64;\n        c += 64;\n    }\n    if (clen) {\n        crypto_core_salsa20(block, in, kcopy, NULL);\n        for (i = 0; i \u003c (unsigned int) clen; i++) {\n            c[i] = block[i];\n        }\n    }\n    sodium_memzero(block, sizeof block);\n    sodium_memzero(kcopy, sizeof kcopy);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/salsa20/ref/salsa20_ref.c","line_number":18,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"732712":{"score":0.8382266,"function_name":"stream_ref_xor_ic","code":"static int\nstream_ref_xor_ic(unsigned char *c, const unsigned char *m,\n                  unsigned long long mlen, const unsigned char *n, uint64_t ic,\n                  const unsigned char *k)\n{\n    unsigned char in[16];\n    unsigned char block[64];\n    unsigned char kcopy[32];\n    unsigned int  i;\n    unsigned int  u;\n\n    if (!mlen) {\n        return 0;\n    }\n    for (i = 0; i \u003c 32; i++) {\n        kcopy[i] = k[i];\n    }\n    for (i = 0; i \u003c 8; i++) {\n        in[i] = n[i];\n    }\n    for (i = 8; i \u003c 16; i++) {\n        in[i] = (unsigned char) (ic \u0026 0xff);\n        ic \u003e\u003e= 8;\n    }\n    while (mlen \u003e= 64) {\n        crypto_core_salsa20(block, in, kcopy, NULL);\n        for (i = 0; i \u003c 64; i++) {\n            c[i] = m[i] ^ block[i];\n        }\n        u = 1;\n        for (i = 8; i \u003c 16; i++) {\n            u += (unsigned int) in[i];\n            in[i] = u;\n            u \u003e\u003e= 8;\n        }\n        mlen -= 64;\n        c += 64;\n        m += 64;\n    }\n    if (mlen) {\n        crypto_core_salsa20(block, in, kcopy, NULL);\n        for (i = 0; i \u003c (unsigned int) mlen; i++) {\n            c[i] = m[i] ^ block[i];\n        }\n    }\n    sodium_memzero(block, sizeof block);\n    sodium_memzero(kcopy, sizeof kcopy);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/salsa20/ref/salsa20_ref.c","line_number":63,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"733747":{"score":0.7737684,"function_name":"blake2b_compress","code":"static int blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )\n{\n  uint64_t m[16];\n  uint64_t v[16];\n  int      i;\n\n  for( i = 0; i \u003c 16; ++i )\n    m[i] = load64( block + i * sizeof( m[i] ) );\n\n  for( i = 0; i \u003c 8; ++i )\n    v[i] = S-\u003eh[i];\n\n  v[ 8] = blake2b_IV[0];\n  v[ 9] = blake2b_IV[1];\n  v[10] = blake2b_IV[2];\n  v[11] = blake2b_IV[3];\n  v[12] = S-\u003et[0] ^ blake2b_IV[4];\n  v[13] = S-\u003et[1] ^ blake2b_IV[5];\n  v[14] = S-\u003ef[0] ^ blake2b_IV[6];\n  v[15] = S-\u003ef[1] ^ blake2b_IV[7];\n#define G(r,i,a,b,c,d) \\\n  do { \\\n    a = a + b + m[blake2b_sigma[r][2*i+0]]; \\\n    d = rotr64(d ^ a, 32); \\\n    c = c + d; \\\n    b = rotr64(b ^ c, 24); \\\n    a = a + b + m[blake2b_sigma[r][2*i+1]]; \\\n    d = rotr64(d ^ a, 16); \\\n    c = c + d; \\\n    b = rotr64(b ^ c, 63); \\\n  } while(0)\n#define ROUND(r)  \\\n  do { \\\n    G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \\\n    G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \\\n    G(r,2,v[ 2],v[ 6],v[10],v[14]); \\\n    G(r,3,v[ 3],v[ 7],v[11],v[15]); \\\n    G(r,4,v[ 0],v[ 5],v[10],v[15]); \\\n    G(r,5,v[ 1],v[ 6],v[11],v[12]); \\\n    G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \\\n    G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \\\n  } while(0)\n  ROUND( 0 );\n  ROUND( 1 );\n  ROUND( 2 );\n  ROUND( 3 );\n  ROUND( 4 );\n  ROUND( 5 );\n  ROUND( 6 );\n  ROUND( 7 );\n  ROUND( 8 );\n  ROUND( 9 );\n  ROUND( 10 );\n  ROUND( 11 );\n\n  for( i = 0; i \u003c 8; ++i )\n    S-\u003eh[i] = S-\u003eh[i] ^ v[i] ^ v[i + 8];\n\n#undef G\n#undef ROUND\n  return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c","line_number":220,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.4.4"},"75079":{"score":0.88855016,"function_name":"cap_switch_init_cb","code":"void cap_switch_init_cb(IOT_CAP_HANDLE *handle, void *usr_data)\n{\n    int32_t sequence_no = 1;\n\n    /* Send initial switch attribute */\n    ST_CAP_SEND_ATTR_STRING(handle, \"switch\", \"on\", NULL, NULL, sequence_no);\n\n    if (sequence_no \u003c 0)\n        printf(\"fail to send switch value\\n\");\n    else\n        printf(\"Sequence number return : %d\\n\", sequence_no);\n}","filepath":"example/example.c","line_number":61,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75294":{"score":0.89598805,"function_name":"cap_switch_cmd_off_cb","code":"void cap_switch_cmd_off_cb(IOT_CAP_HANDLE *handle,\n                           iot_cap_cmd_data_t *cmd_data, void *usr_data)\n{\n    int32_t sequence_no = 1;\n\n    printf(\"OFF command received\");\n\n    /* Update switch attribute */\n    ST_CAP_SEND_ATTR_STRING(handle, \"switch\", \"off\", NULL, NULL, sequence_no);\n\n    if (sequence_no \u003c 0)\n        printf(\"fail to send switch value\\n\");\n    else\n        printf(\"Sequence number return : %d\\n\", sequence_no);\n}","filepath":"example/example.c","line_number":74,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75533":{"score":0.9004369,"function_name":"cap_switch_cmd_on_cb","code":"void cap_switch_cmd_on_cb(IOT_CAP_HANDLE *handle,\n                          iot_cap_cmd_data_t *cmd_data, void *usr_data)\n{\n    int32_t sequence_no = 1;\n\n    printf(\"ON command received\");\n\n    /* Update switch attribute */\n    ST_CAP_SEND_ATTR_STRING(handle, \"switch\", \"on\", NULL, NULL, sequence_no);\n\n    if (sequence_no \u003c 0)\n        printf(\"fail to send switch value\\n\");\n    else\n        printf(\"Sequence number return : %d\\n\", sequence_no);\n}","filepath":"example/example.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75772":{"score":0.9638918,"function_name":"iot_noti_cb","code":"void iot_noti_cb(iot_noti_data_t *noti_data, void *noti_usr_data)\n{\n    printf(\"Notification message received\\n\");\n\n    if (noti_data-\u003etype == IOT_NOTI_TYPE_DEV_DELETED) {\n        printf(\"[device deleted]\\n\");\n    } else if (noti_data-\u003etype == IOT_NOTI_TYPE_RATE_LIMIT) {\n        printf(\"[rate limit] Remaining time:%d, sequence number:%d\\n\",\n               noti_data-\u003eraw.rate_limit.remainingTime, noti_data-\u003eraw.rate_limit.sequenceNumber);\n    }\n}","filepath":"example/example.c","line_number":106,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75885":{"score":0.80424726,"function_name":"main","code":"void main(void)\n{\n    /**\n\t  SmartThings Device SDK(STDK) aims to make it easier to develop IoT devices by providing\n\t  additional st_iot_core layer to the existing chip vendor SW Architecture.\n\n      That is, you can simply develop a basic application by just calling the APIs provided by st_iot_core layer\n\t  like below. st_iot_core currently offers 14 API.\n\n      //create a iot context\n\t  1. st_conn_init();\n\n      //create a handle to process capability\n\t  2. st_cap_handle_init();\n\n      //register a callback function to process capability command when it comes from the SmartThings Server.\n\t  3. st_cap_cmd_set_cb();\n\n      //needed when it is necessary to keep monitoring the device status\n\t  4. user_defined_task()\n\n      //process on-boarding procedure. There is nothing more to do on the app side than call the API.\n\t  5. st_conn_start();\n\t */\n\n    unsigned char *onboarding_config = (unsigned char *)onboarding_config_start;\n    unsigned int onboarding_config_len = onboarding_config_end - onboarding_config_start;\n    unsigned char *device_info = (unsigned char *)device_info_start;\n    unsigned int device_info_len = device_info_end - device_info_start;\n    IOT_CAP_HANDLE *handle = NULL;\n    int iot_err;\n\n    // 1. create a iot context\n    ctx = st_conn_init(onboarding_config, onboarding_config_len, device_info, device_info_len);\n    if (ctx != NULL) {\n        iot_err = st_conn_set_noti_cb(ctx, iot_noti_cb, NULL);\n        if (iot_err)\n            printf(\"fail to set notification callback function\\n\");\n\n        // 2. create a handle to process capability\n        //\timplement init_callback function (cap_switch_init_cb)\n        handle = st_cap_handle_init(ctx, \"main\", \"switch\", cap_switch_init_cb, NULL);\n\n        // 3. register a callback function to process capability command when it comes from the SmartThings Server\n        //\timplement callback function (cap_switch_cmd_off_cb)\n        iot_err = st_cap_cmd_set_cb(handle, \"off\", cap_switch_cmd_off_cb, NULL);\n        if (iot_err)\n            printf(\"fail to set cmd_cb for off\\n\");\n\n        //\timplement callback function (cap_switch_cmd_on_cb)\n        iot_err = st_cap_cmd_set_cb(handle, \"on\", cap_switch_cmd_on_cb, NULL);\n        if (iot_err)\n            printf(\"fail to set cmd_cb for on\\n\");\n    } else {\n        printf(\"fail to create the iot_context\\n\");\n    }\n\n    // 4. needed when it is necessary to keep monitoring the device status\n    //xTaskCreate(user_defined_task, \"user_defined_task\", 2048, (void *)handle, 10, NULL);\n\n    // 5. process on-boarding procedure. There is nothing more to do on the app side than call the API.\n    st_conn_start(ctx, (st_status_cb)\u0026iot_status_cb, IOT_STATUS_ALL, NULL, NULL);\n\n    // exit by using Ctrl+C\n    signal(SIGINT, signal_handler);\n\n    event_loop();\n}","filepath":"example/example.c","line_number":118,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"77481":{"score":0.7378598,"function_name":"st_cap_attr_create_string_array","code":"DEPRECATED IOT_EVENT* st_cap_attr_create_string_array(const char *attribute,\n\t\t\tuint8_t str_num, char *string_array[], const char *unit)\n{\n\tiot_cap_val_t value;\n\tvalue.type = IOT_CAP_VAL_TYPE_STR_ARRAY;\n\tvalue.str_num = str_num;\n\tvalue.strings = string_array;\n\n\treturn _iot_cap_create_attr(attribute, \u0026value, unit, NULL);\n}","filepath":"src/iot_capability.c","line_number":79,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"77631":{"score":0.81676316,"function_name":"st_cap_create_attr_with_id","code":"IOT_EVENT* st_cap_create_attr_with_id(IOT_CAP_HANDLE *cap_handle, const char *attribute,\n\t\t\tiot_cap_val_t *value, const char *unit, const char *data, char *command_id)\n{\n\tiot_cap_evt_data_t* evt_data;\n\n\tevt_data = (iot_cap_evt_data_t *)st_cap_create_attr(cap_handle, attribute, value, unit, data);\n\n\tif (evt_data != NULL \u0026\u0026 command_id != NULL) {\n\t\tevt_data-\u003eoptions.command_id = iot_os_strdup(command_id);\n\t}\n\n\treturn (IOT_EVENT*)evt_data;\n}","filepath":"src/iot_capability.c","line_number":96,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"77720":{"score":0.9116991,"function_name":"_iot_cap_create_attr","code":"static IOT_EVENT* _iot_cap_create_attr(const char *attribute,\n\t\t\tiot_cap_val_t *value, const char *unit, const char *data)\n{\n\tint i;\n\tiot_cap_evt_data_t* evt_data;\n\n\tif (!attribute) {\n\t\tIOT_ERROR(\"attribute is NULL\");\n\t\treturn NULL;\n\t}\n\n\tif (!value) {\n\t\tIOT_ERROR(\"value is NULL\");\n\t\treturn NULL;\n\t}\n\n\tevt_data = iot_os_malloc(sizeof(iot_cap_evt_data_t));\n\tif (!evt_data) {\n\t\tIOT_ERROR(\"failed to malloc for evt_data\");\n\t\treturn NULL;\n\t}\n\tmemset(evt_data, 0, sizeof(iot_cap_evt_data_t));\n\n\n\tevt_data-\u003eevt_type = iot_os_strdup(attribute);\n\tswitch (value-\u003etype) {\n\tcase IOT_CAP_VAL_TYPE_BOOLEAN:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_BOOLEAN;\n\t\tevt_data-\u003eevt_value.boolean = value-\u003eboolean;\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_INTEGER:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_INTEGER;\n\t\tevt_data-\u003eevt_value.integer = value-\u003einteger;\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_NUMBER:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_NUMBER;\n\t\tevt_data-\u003eevt_value.number = value-\u003enumber;\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_STRING:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_STRING;\n\t\tif (value-\u003estring) {\n\t\t\tevt_data-\u003eevt_value.string = iot_os_strdup(value-\u003estring);\n\t\t} else {\n\t\t\tIOT_ERROR(\"There is no string value\");\n\t\t\t_iot_free_evt_data(evt_data);\n\t\t\tiot_os_free(evt_data);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_STR_ARRAY:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_STR_ARRAY;\n\t\tevt_data-\u003eevt_value.str_num = value-\u003estr_num;\n\t\tevt_data-\u003eevt_value.strings = iot_os_malloc(value-\u003estr_num * sizeof(char*));\n\t\tif (value-\u003estr_num != 0 \u0026\u0026 !evt_data-\u003eevt_value.strings) {\n\t\t\tIOT_ERROR(\"failed to malloc for string array\");\n\t\t\t_iot_free_evt_data(evt_data);\n\t\t\tiot_os_free(evt_data);\n\t\t\treturn NULL;\n\t\t} else if (evt_data-\u003eevt_value.strings) {\n\t\t\tmemset(evt_data-\u003eevt_value.strings, 0, value-\u003estr_num * sizeof(char*));\n\t\t}\n\t\tfor (i = 0; i \u003c value-\u003estr_num; i++) {\n\t\t\tif (value-\u003estrings[i]) {\n\t\t\t\tevt_data-\u003eevt_value.strings[i] = iot_os_strdup(value-\u003estrings[i]);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"found no string value in array\");\n\t\t\t\t_iot_free_evt_data(evt_data);\n\t\t\t\tiot_os_free(evt_data);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_JSON_OBJECT:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_JSON_OBJECT;\n\t\tevt_data-\u003eevt_value.json_object = iot_os_strdup(value-\u003ejson_object);\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"unknown attribute data type\");\n\t\t_iot_free_evt_data(evt_data);\n\t\tiot_os_free(evt_data);\n\t\treturn NULL;\n\t}\n\n\tif (unit != NULL) {\n\t\tevt_data-\u003eevt_unit.type = IOT_CAP_UNIT_TYPE_STRING;\n\t\tevt_data-\u003eevt_unit.string = iot_os_strdup(unit);\n\t} else {\n\t\tevt_data-\u003eevt_unit.type = IOT_CAP_UNIT_TYPE_UNUSED;\n\t}\n\n\tif (data != NULL) {\n\t\tevt_data-\u003eevt_value_data = iot_os_strdup(data);\n\t}\n\n\treturn (IOT_EVENT*)evt_data;\n}","filepath":"src/iot_capability.c","line_number":110,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"78815":{"score":0.9251865,"function_name":"st_cap_create_attr_with_option","code":"IOT_EVENT* st_cap_create_attr_with_option(IOT_CAP_HANDLE *cap_handle, const char *attribute,\n\t\t\tiot_cap_val_t *value, const char *unit, const char *data, iot_cap_attr_option_t *options)\n{\n\tiot_cap_evt_data_t* evt_data = NULL;\n\n\tif (cap_handle == NULL) {\n\t\tIOT_ERROR(\"There is no cap handle\");\n\t\treturn NULL;\n\t}\n\n\tevt_data = (iot_cap_evt_data_t *)_iot_cap_create_attr(attribute, value, unit, data);\n\tif (evt_data == NULL)\n\t\treturn NULL;\n\n\tevt_data-\u003eref_cap = (struct iot_cap_handle *)cap_handle;\n\n\tif (options != NULL)\n\t{\n\t\tevt_data-\u003eoptions.state_change = options-\u003estate_change;\n\t\tif (options-\u003ecommand_id)\n\t\t{\n\t\t\tevt_data-\u003eoptions.command_id = iot_os_strdup(options-\u003ecommand_id);\n\t\t\tif (evt_data-\u003eoptions.command_id == NULL)\n\t\t\t{\n\t\t\t\tgoto failed_creat_attr_option;\n\t\t\t}\n\t\t}\n\n\t\tif (options-\u003edisplayed != NULL)\n\t\t{\n\t\t\tevt_data-\u003eoptions.displayed = (bool *)iot_os_malloc(sizeof(bool));\n\t\t\tif (evt_data-\u003eoptions.displayed != NULL)\n\t\t\t{\n\t\t\t\t*(evt_data-\u003eoptions.displayed) = *(options-\u003edisplayed);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgoto failed_creat_attr_option;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (IOT_EVENT*)evt_data;\n\nfailed_creat_attr_option:\n\n\tif (evt_data-\u003eoptions.displayed != NULL)\n\t{\n\t\tiot_os_free(evt_data-\u003eoptions.displayed);\n\t\tevt_data-\u003eoptions.displayed = NULL;\n\t}\n\n\tif (evt_data-\u003eoptions.command_id != NULL)\n\t{\n\t\tiot_os_free(evt_data-\u003eoptions.command_id);\n\t\tevt_data-\u003eoptions.command_id = NULL;\n\t}\n\n\tif (evt_data != NULL)\n\t{\n\t\t_iot_free_evt_data(evt_data);\n\t\tiot_os_free(evt_data);\n\t}\n\n\treturn NULL;\n}","filepath":"src/iot_capability.c","line_number":213,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"79193":{"score":0.73606056,"function_name":"st_cap_free_attr","code":"void st_cap_free_attr(IOT_EVENT* event)\n{\n\tiot_cap_evt_data_t* evt_data = (iot_cap_evt_data_t*) event;\n\n\tif (evt_data) {\n\t\t_iot_free_evt_data(evt_data);\n\t\tiot_os_free(evt_data);\n\t}\n}","filepath":"src/iot_capability.c","line_number":290,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"79321":{"score":0.9077815,"function_name":"st_cap_handle_init","code":"IOT_CAP_HANDLE *st_cap_handle_init(IOT_CTX *iot_ctx, const char *component,\n\t\t\tconst char *capability, st_cap_init_cb init_cb, void *init_usr_data)\n{\n\tstruct iot_cap_handle *handle = NULL;\n\tstruct iot_cap_handle_list *cur_list;\n\tstruct iot_cap_handle_list *new_list;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (!ctx || !capability) {\n\t    return NULL;\n\t}\n\n\thandle = iot_os_malloc(sizeof(struct iot_cap_handle));\n\tif (!handle) {\n\t\tIOT_ERROR(\"failed to malloc for iot_cap_handle\");\n\t\treturn NULL;\n\t}\n\n\tmemset(handle, 0, sizeof(struct iot_cap_handle));\n\n\tif (component) {\n\t\thandle-\u003ecomponent = iot_os_strdup(component);\n\t} else {\n\t\thandle-\u003ecomponent = iot_os_strdup(\"main\");\n\t}\n\tif (!handle-\u003ecomponent) {\n\t\tIOT_ERROR(\"failed to malloc for component\");\n\t\tiot_os_free(handle);\n\t\treturn NULL;\n\t}\n\n\thandle-\u003ecapability = iot_os_strdup(capability);\n\tif (!handle-\u003ecapability) {\n\t\tIOT_ERROR(\"failed to malloc for capability\");\n\t\tiot_os_free((void *)handle-\u003ecomponent);\n\t\tiot_os_free(handle);\n\t\treturn NULL;\n\t}\n\n\thandle-\u003ecmd_list = NULL;\n\n\tnew_list = (iot_cap_handle_list_t *)iot_os_malloc(sizeof(iot_cap_handle_list_t));\n\tif (!new_list) {\n\t\tIOT_ERROR(\"failed to malloc for handle list\");\n\t\tiot_os_free((void *)handle-\u003ecomponent);\n\t\tiot_os_free((void *)handle-\u003ecapability);\n\t\tiot_os_free(handle);\n\t\treturn NULL;\n\t}\n\n\tif (ctx-\u003ecap_handle_list == NULL) {\n\t\tctx-\u003ecap_handle_list = new_list;\n\t\tcur_list = ctx-\u003ecap_handle_list;\n\t} else {\n\t\tcur_list = ctx-\u003ecap_handle_list;\n\t\twhile (cur_list-\u003enext != NULL)\n\t\t\tcur_list = cur_list-\u003enext;\n\t\tcur_list-\u003enext = new_list;\n\t\tcur_list = cur_list-\u003enext;\n\t}\n\tcur_list-\u003enext = NULL;\n\tcur_list-\u003ehandle = handle;\n\n\tif (init_cb)\n\t\thandle-\u003einit_cb = init_cb;\n\n\tif (init_usr_data)\n\t\thandle-\u003einit_usr_data = init_usr_data;\n\n\thandle-\u003ectx = ctx;\n\treturn (IOT_CAP_HANDLE*)handle;\n}","filepath":"src/iot_capability.c","line_number":300,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"79976":{"score":0.9289477,"function_name":"st_conn_set_noti_cb","code":"int st_conn_set_noti_cb(IOT_CTX *iot_ctx,\n\t\tst_cap_noti_cb noti_cb, void *noti_usr_data)\n{\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (!ctx || !noti_cb) {\n\t\tIOT_ERROR(\"There is no ctx or cb !!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tctx-\u003enoti_cb = noti_cb;\n\n\tif (noti_usr_data)\n\t\tctx-\u003enoti_usr_data = noti_usr_data;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":373,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"80099":{"score":0.9198545,"function_name":"st_cap_cmd_set_cb","code":"int st_cap_cmd_set_cb(IOT_CAP_HANDLE *cap_handle, const char *cmd_type,\n\t\tst_cap_cmd_cb cmd_cb, void *usr_data)\n{\n\tstruct iot_cap_handle *handle = (struct iot_cap_handle*)cap_handle;\n\tstruct iot_cap_cmd_set *command;\n\tstruct iot_cap_cmd_set_list *cur_list;\n\tstruct iot_cap_cmd_set_list *new_list;\n\tconst char *needle_str, *cmd_str;\n\tsize_t str_len;\n\n\tif (!handle || !cmd_type || !cmd_cb) {\n\t\tIOT_ERROR(\"There is no handle or cb data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tneedle_str = cmd_type;\n\tstr_len = strlen(needle_str);\n\n\tcur_list = handle-\u003ecmd_list;\n\twhile (cur_list) {\n\t\tcmd_str = cur_list-\u003ecommand-\u003ecmd_type;\n\t\tif (cmd_str \u0026\u0026 !strncmp(cmd_str, needle_str, str_len)) {\n\t\t\tIOT_ERROR(\"There is already same handle for : %s\",\n\t\t\t\t\t\tneedle_str);\n\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t}\n\t\tcur_list = cur_list-\u003enext;\n\t}\n\n\tcommand = (iot_cap_cmd_set_t *)iot_os_malloc(sizeof(iot_cap_cmd_set_t));\n\tif (!command) {\n\t\tIOT_ERROR(\"failed to malloc for cmd set\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tcommand-\u003ecmd_type = iot_os_strdup(needle_str);\n\tcommand-\u003ecmd_cb = cmd_cb;\n\tcommand-\u003eusr_data = usr_data;\n\n\tnew_list = (iot_cap_cmd_set_list_t *)iot_os_malloc(sizeof(iot_cap_cmd_set_list_t));\n\tif (!new_list) {\n\t\tIOT_ERROR(\"failed to malloc for cmd set list\");\n\t\tiot_os_free(command-\u003ecmd_type);\n\t\tiot_os_free(command);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tnew_list-\u003ecommand = command;\n\tnew_list-\u003enext = handle-\u003ecmd_list;\n\thandle-\u003ecmd_list = new_list;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":391,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"80579":{"score":0.8657928,"function_name":"st_cap_attr_send","code":"DEPRECATED int st_cap_attr_send(IOT_CAP_HANDLE *cap_handle,\n\t\tuint8_t evt_num, IOT_EVENT *event[])\n{\n\tiot_cap_evt_data_t** evt_data = (iot_cap_evt_data_t**)event;\n\tint ret;\n\tstruct iot_context *ctx;\n\tst_mqtt_msg msg = {0};\n\tstruct iot_cap_handle *handle = (struct iot_cap_handle*)cap_handle;\n\tint i;\n\tJSON_H *evt_root = NULL;\n\tJSON_H *evt_arr = NULL;\n\tJSON_H *evt_item = NULL;\n\n\tif (!handle || !handle-\u003ecomponent || !handle-\u003ecapability || !handle-\u003ectx || !evt_data || !evt_num) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_DATA_ERROR, 0, 0);\n\t\tIOT_ERROR(\"There is no handle or evt_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tctx = handle-\u003ectx;\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_CONNECT_ERROR, ctx-\u003ecurr_state, 0);\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (ctx-\u003erate_limit) {\n\t\tif ((iot_os_timer_isexpired(ctx-\u003erate_limit_timeout))) {\n\t\t\tctx-\u003erate_limit = false;\n\t\t} else {\n\t\t\tIOT_WARN(\"Exceed rate limit. Can't send attributes for a while\");\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t}\n\n\tif (ctx-\u003eevent_sequence_num == MAX_SQNUM) {\n\t\tctx-\u003eevent_sequence_num = 0;\n\t}\n\tctx-\u003eevent_sequence_num = (ctx-\u003eevent_sequence_num + 1) \u0026 MAX_SQNUM;\n\n\tevt_root = JSON_CREATE_OBJECT();\n\tevt_arr = JSON_CREATE_ARRAY();\n\n\tJSON_ADD_ITEM_TO_OBJECT(evt_root, \"deviceEvents\", evt_arr);\n\n\t/* Make event data format \u0026 enqueue data */\n\tfor (i = 0; i \u003c evt_num; i++) {\n\t\tevt_item = _iot_make_evt_data(handle-\u003ecomponent, handle-\u003ecapability, evt_data[i], ctx-\u003eevent_sequence_num);\n\t\tif (evt_item == NULL) {\n\t\t\tIOT_ERROR(\"Cannot make evt_data!!\");\n\t\t\tJSON_DELETE(evt_root);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_ARRAY(evt_arr, evt_item);\n\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(evt_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(evt_root);\n\tif (msg.payload != NULL) {\n\t\tmsg.payloadlen = strlen(msg.payload);\n\t}\n#endif\n\tJSON_DELETE(evt_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to transfer to payload\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = ctx-\u003emqtt_event_topic;\n\n\tIOT_INFO(\"publish event, topic : %s, payload :\\n%s\",\n\t\tctx-\u003emqtt_event_topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish_async(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tIOT_WARN(\"MQTT pub error(%d)\", ret);\n\t\tfree(msg.payload);\n\t\treturn IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t}\n\n#if !defined(STDK_MQTT_TASK)\n\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_CAPABILITY);\n#endif\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_SEND_EVENT_SUCCESS, evt_num, 0);\n\n\tfree(msg.payload);\n\treturn ctx-\u003eevent_sequence_num;\n}","filepath":"src/iot_capability.c","line_number":443,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"81577":{"score":0.8864526,"function_name":"st_cap_send_attr","code":"int st_cap_send_attr(IOT_EVENT *event[], uint8_t evt_num)\n{\n\tiot_cap_evt_data_t** evt_data = (iot_cap_evt_data_t**)event;\n\tint ret;\n\tstruct iot_context *ctx = NULL;\n\tst_mqtt_msg msg = {0};\n\tint i;\n\tJSON_H *evt_root = NULL;\n\tJSON_H *evt_arr = NULL;\n\tJSON_H *evt_item = NULL;\n\n\tif (!evt_data || !evt_num || !evt_data[0] || !evt_data[0]-\u003eref_cap || !evt_data[0]-\u003eref_cap-\u003ectx) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_DATA_ERROR, 0, 0);\n\t\tIOT_ERROR(\"There is no ctx or evt_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tctx = evt_data[0]-\u003eref_cap-\u003ectx;\n\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_CONNECT_ERROR, ctx-\u003ecurr_state, 0);\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (ctx-\u003erate_limit) {\n\t\tif ((iot_os_timer_isexpired(ctx-\u003erate_limit_timeout))) {\n\t\t\tctx-\u003erate_limit = false;\n\t\t} else {\n\t\t\tIOT_WARN(\"Exceed rate limit. Can't send attributes for a while\");\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t}\n\n\tif (ctx-\u003eevent_sequence_num == MAX_SQNUM) {\n\t\tctx-\u003eevent_sequence_num = 0;\n\t}\n\tctx-\u003eevent_sequence_num = (ctx-\u003eevent_sequence_num + 1) \u0026 MAX_SQNUM;\n\n\tevt_root = JSON_CREATE_OBJECT();\n\tevt_arr = JSON_CREATE_ARRAY();\n\n\tJSON_ADD_ITEM_TO_OBJECT(evt_root, \"deviceEvents\", evt_arr);\n\n\t/* Make event data format \u0026 enqueue data */\n\tfor (i = 0; i \u003c evt_num; i++) {\n\t\tif (!evt_data[i] || !(evt_data[i]-\u003eref_cap) || ctx != evt_data[i]-\u003eref_cap-\u003ectx) {\n\t\t\tIOT_ERROR(\"There si no capability reference in event data or ctx not matched\");\n\t\t\tJSON_DELETE(evt_root);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tevt_item = _iot_make_evt_data(evt_data[i]-\u003eref_cap-\u003ecomponent, evt_data[i]-\u003eref_cap-\u003ecapability,\n\t\t\t\tevt_data[i], ctx-\u003eevent_sequence_num);\n\t\tif (evt_item == NULL) {\n\t\t\tIOT_ERROR(\"Cannot make evt_data!!\");\n\t\t\tJSON_DELETE(evt_root);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_ARRAY(evt_arr, evt_item);\n\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(evt_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(evt_root);\n\tif (msg.payload != NULL) {\n\t\tmsg.payloadlen = strlen(msg.payload);\n\t}\n#endif\n\tJSON_DELETE(evt_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to transfer to payload\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = ctx-\u003emqtt_event_topic;\n\n\tIOT_INFO(\"publish event, topic : %s, payload :\\n%s\",\n\t\tctx-\u003emqtt_event_topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish_async(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tIOT_WARN(\"MQTT pub error(%d)\", ret);\n\t\tfree(msg.payload);\n\t\treturn IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t}\n\n#if !defined(STDK_MQTT_TASK)\n\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_CAPABILITY);\n#endif\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_SEND_EVENT_SUCCESS, evt_num, 0);\n\n\tfree(msg.payload);\n\treturn ctx-\u003eevent_sequence_num;\n}","filepath":"src/iot_capability.c","line_number":535,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"82741":{"score":0.7626455,"function_name":"_iot_parse_noti_data","code":"STATIC_FUNCTION\niot_error_t _iot_parse_noti_data(void *data, iot_noti_data_t *noti_data)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tJSON_H *json = NULL;\n\tJSON_H *noti_type = NULL;\n\tJSON_H *item = NULL;\n\tchar *noti_type_string = NULL;\n\tchar *payload = NULL;\n\tchar time_str[11] = {0,};\n\n\tjson = JSON_PARSE(data);\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"Cannot parse by json\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tpayload = JSON_PRINT(json);\n\tIOT_INFO(\"payload : %s\", payload);\n\tfree(payload);\n\n\tnoti_type = JSON_GET_OBJECT_ITEM(json, \"event\");\n\tif (noti_type == NULL) {\n\t\tIOT_ERROR(\"there is no event in raw_msgn\");\n\t\terr = IOT_ERROR_BAD_REQ;\n\t\tgoto out_noti_parse;\n\t}\n\n\tnoti_type_string = JSON_GET_STRING_VALUE(noti_type);\n\tif (noti_type_string == NULL) {\n\t\tIOT_ERROR(\"there is no event type string\");\n\t\tgoto out_noti_parse;\n\t}\n\tif (!strncmp(noti_type_string, SERVER_NOTI_TYPE_DEVICE_DELETED, strlen(SERVER_NOTI_TYPE_DEVICE_DELETED))) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_DEVICE_DELETED_RECEIVED, 0, 0);\n\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_DEV_DELETED;\n\t} else if (!strncmp(noti_type_string, SERVER_NOTI_TYPE_EXPIRED_JWT, strlen(SERVER_NOTI_TYPE_EXPIRED_JWT))) {\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_JWT_EXPIRED;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"currentTime\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no currentTime in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\n\t\tsnprintf(time_str, sizeof(time_str), \"%d\", item-\u003evalueint);\n\t\tIOT_INFO(\"Set SNTP with current time %s\", time_str);\n\t\tiot_bsp_system_set_time_in_sec(time_str);\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_EXPIRED_JWT_RECEIVED, item-\u003evalueint, 0);\n\t} else if (!strncmp(noti_type_string, SERVER_NOTI_TYPE_RATE_LIMIT_REACHED, strlen(SERVER_NOTI_TYPE_RATE_LIMIT_REACHED))) {\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_RATE_LIMIT;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"count\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no count in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.count = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"threshold\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no threshold in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.threshold = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"remainingTime\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no remainingTime in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.remainingTime = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"sequenceNumber\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no sequenceNumber in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.sequenceNumber = item-\u003evalueint;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_RATE_LIMIT_RECEIVED, noti_data-\u003eraw.rate_limit.sequenceNumber, 0);\n\t} else if (!strncmp(noti_type_string, SERVER_NOTI_TYPE_QUOTA_REACHED, strlen(SERVER_NOTI_TYPE_QUOTA_REACHED))) {\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_QUOTA_REACHED;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"used\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no used in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.quota.used = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"limit\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no limit in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.quota.limit = item-\u003evalueint;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_QUOTA_LIMIT_RECEIVED, noti_data-\u003eraw.quota.used, noti_data-\u003eraw.quota.limit);\n\t} else {\n\t\tIOT_WARN(\"There is no noti_type matched\");\n\t\terr = IOT_ERROR_BAD_REQ;\n\t}\n\nout_noti_parse:\n\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn err;\n}","filepath":"src/iot_capability.c","line_number":631,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"84127":{"score":0.91398835,"function_name":"iot_noti_sub_cb","code":"void iot_noti_sub_cb(struct iot_context *ctx, char *payload)\n{\n\tiot_error_t err;\n\tiot_noti_data_t noti_data;\n\n\tif (!ctx || !payload) {\n\t\tIOT_ERROR(\"There is no ctx or payload\");\n\t\treturn;\n\t}\n\n\tmemset(\u0026noti_data, 0, sizeof(iot_noti_data_t));\n\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_NOTI_RECEIVED, 0, 0);\n\terr = _iot_parse_noti_data((void *)payload, \u0026noti_data);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Cannot parse notification data\");\n\t\treturn;\n\t}\n\tif (noti_data.type == IOT_NOTI_TYPE_RATE_LIMIT) {\n\t\tctx-\u003erate_limit = true;\n\t\tiot_os_timer_count_ms(ctx-\u003erate_limit_timeout, IOT_RATE_LIMIT_BREAK_TIME);\n\t}\n\n\tiot_command_send(ctx, IOT_COMMAND_NOTIFICATION_RECEIVED,\n\t\t\u0026noti_data, sizeof(noti_data));\n}","filepath":"src/iot_capability.c","line_number":750,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"84396":{"score":0.90273386,"function_name":"_iot_process_cmd","code":"static iot_error_t _iot_process_cmd(iot_cap_handle_list_t *cap_handle_list, char *component_name,\n\t\t\tchar *capability_name, char *command_name, iot_cap_cmd_data_t *cmd_data)\n{\n\tstruct iot_cap_handle_list *handle_list = NULL;\n\tstruct iot_cap_handle *handle = NULL;\n\tstruct iot_cap_cmd_set_list *command_list = NULL;\n\tstruct iot_cap_cmd_set *command = NULL;\n\n\t/* find handle with capability */\n\thandle_list = cap_handle_list;\n\twhile (handle_list != NULL) {\n\t\thandle = handle_list-\u003ehandle;\n\t\tif (handle \u0026\u0026 !strcmp(component_name, handle-\u003ecomponent) \u0026\u0026 !strcmp(capability_name, handle-\u003ecapability)) {\n\t\t\tIOT_DEBUG(\"found handle for [%s]%s\", component_name, capability_name);\n\t\t\tbreak;\n\t\t}\n\t\thandle_list = handle_list-\u003enext;\n\t}\n\n\tif (handle_list == NULL) {\n\t\tIOT_ERROR(\"Cannot find handle for [%s]%s\", component_name, capability_name);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\t/* find cmd set */\n\tcommand_list = handle-\u003ecmd_list;\n\twhile (command_list != NULL) {\n\t\tcommand = command_list-\u003ecommand;\n\t\tif (!strcmp(command_name, command-\u003ecmd_type)) {\n\t\t\tcommand-\u003ecmd_cb((IOT_CAP_HANDLE *)handle,\n\t\t\t\tcmd_data, command-\u003eusr_data);\n\t\t\tbreak;\n\t\t}\n\t\tcommand_list = command_list-\u003enext;\n\t}\n\n\tif (command_list == NULL) {\n\t\tIOT_WARN(\"Not registed cmd set received '%s'\", command_name);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_COMMAND_SUCCEED, 0, 0);\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":777,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"84744":{"score":0.8710054,"function_name":"iot_cap_sub_cb","code":"void iot_cap_sub_cb(iot_cap_handle_list_t *cap_handle_list, char *payload)\n{\n\tJSON_H *json = NULL;\n\tJSON_H *cap_cmds = NULL;\n\tJSON_H *cmditem = NULL;\n\tchar *raw_data = NULL;\n\tiot_error_t err;\n\tint i;\n\tint arr_size = 0;\n\n\tif (!cap_handle_list || !payload) {\n\t\tIOT_ERROR(\"There is no cap_handle_list or payload\");\n\t\treturn;\n\t}\n\n\tjson = JSON_PARSE(payload);\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"Cannot parse by json\");\n\t\tgoto out;\n\t}\n\n\traw_data = JSON_PRINT(json);\n\tIOT_INFO(\"command : %s\", raw_data);\n\tfree(raw_data);\n\n\tcap_cmds = JSON_GET_OBJECT_ITEM(json, \"commands\");\n\tif (cap_cmds == NULL) {\n\t\tIOT_ERROR(\"there is no commands in raw_data\");\n\t\tgoto out;\n\t}\n\n\tarr_size = JSON_GET_ARRAY_SIZE(cap_cmds);\n\tIOT_DEBUG(\"cap_cmds arr_size=%d\", arr_size);\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_COMMANDS_RECEIVED, arr_size, 0);\n\n\tif (arr_size == 0) {\n\t\tIOT_ERROR(\"There are no commands data\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i \u003c arr_size; i++) {\n\t\tchar *component_name = NULL;\n\t\tchar *capability_name = NULL;\n\t\tchar *command_name = NULL;\n\t\tiot_cap_cmd_data_t cmd_data;\n\n\t\tcmd_data.num_args = 0;\n\t\tcmd_data.total_commands_num = arr_size;\n\t\tcmd_data.order_of_command = i + 1;\n\t\tcmd_data.command_id = NULL;\n\n\t\tcmditem = JSON_GET_ARRAY_ITEM(cap_cmds, i);\n\t\tif (!cmditem) {\n\t\t\tIOT_ERROR(\"Cannot get %dth commands data\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_PROCESS_COMMAND, i + 1, 0);\n\t\terr = _iot_parse_cmd_data(cmditem, \u0026component_name, \u0026capability_name, \u0026command_name, \u0026cmd_data);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Cannot parse %dth command data\", i);\n\t\t} else {\n\t\t\t_iot_process_cmd(cap_handle_list, component_name, capability_name, command_name, \u0026cmd_data);\n\t\t}\n\n\t\tif (cmd_data.num_args != 0) {\n\t\t\t_iot_free_cmd_data(\u0026cmd_data);\n\t\t\tcmd_data.num_args = 0;\n\t\t}\n\n\t\tif (component_name != NULL) {\n\t\t\tiot_os_free(component_name);\n\t\t\tcomponent_name = NULL;\n\t\t}\n\n\t\tif (capability_name != NULL) {\n\t\t\tiot_os_free(capability_name);\n\t\t\tcapability_name = NULL;\n\t\t}\n\n\t\tif (command_name != NULL) {\n\t\t\tiot_os_free(command_name);\n\t\t\tcommand_name = NULL;\n\t\t}\n\n\t\tif (cmd_data.command_id != NULL) {\n\t\t\tiot_os_free(cmd_data.command_id);\n\t\t\tcmd_data.command_id = NULL;\n\t\t}\n\t}\n\nout:\n\tif (json != NULL)\n\t\tJSON_DELETE(json);\n}","filepath":"src/iot_capability.c","line_number":822,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"85802":{"score":0.8879786,"function_name":"_iot_parse_cmd_data","code":"static iot_error_t _iot_parse_cmd_data(JSON_H* cmditem, char** component,\n\t\t\tchar** capability, char** command, iot_cap_cmd_data_t* cmd_data)\n{\n\tJSON_H *cap_component = NULL;\n\tJSON_H *cap_capability = NULL;\n\tJSON_H *cap_command = NULL;\n\tJSON_H *cap_args = NULL;\n\tJSON_H *subitem = NULL;\n\tJSON_H *command_id = NULL;\n\tint arr_size = 0;\n\tint num_args = 0;\n\tint i;\n\n\tcap_component = JSON_GET_OBJECT_ITEM(cmditem, \"component\");\n\tcap_capability = JSON_GET_OBJECT_ITEM(cmditem, \"capability\");\n\tcap_command = JSON_GET_OBJECT_ITEM(cmditem, \"command\");\n\tcap_args = JSON_GET_OBJECT_ITEM(cmditem, \"arguments\");\n\tcommand_id = JSON_GET_OBJECT_ITEM(cmditem, \"id\");\n\n\tif (cap_component == NULL || cap_capability == NULL || cap_command == NULL) {\n\t\tIOT_ERROR(\"Cannot find value index!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\t*component = iot_os_strdup(cap_component-\u003evaluestring);\n\t*capability = iot_os_strdup(cap_capability-\u003evaluestring);\n\t*command = iot_os_strdup(cap_command-\u003evaluestring);\n\n\tIOT_DEBUG(\"component:%s, capability:%s command:%s\", *component, *capability, *command);\n\n\tarr_size = JSON_GET_ARRAY_SIZE(cap_args);\n\tIOT_DEBUG(\"cap_args arr_size=%d\", arr_size);\n\tsubitem = JSON_GET_ARRAY_ITEM(cap_args, 0);\n\n\tif (subitem != NULL) {\n\t\tfor (i = 0; i \u003c arr_size; i++) {\n\t\t\tif (JSON_IS_BOOL(subitem)) {\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_BOOLEAN;\n\t\t\t\tif (JSON_IS_TRUE(subitem)) {\n\t\t\t\t\tIOT_DEBUG(\"[%d] True\", num_args);\n\t\t\t\t\tcmd_data-\u003ecmd_data[num_args].boolean = true;\n\t\t\t\t} else {\n\t\t\t\t\tIOT_DEBUG(\"[%d] False\", num_args);\n\t\t\t\t\tcmd_data-\u003ecmd_data[num_args].boolean = false;\n\t\t\t\t}\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\telse if (JSON_IS_NUMBER(subitem)) {\n\t\t\t\tIOT_DEBUG(\"[%d] %d | %f\", num_args, subitem-\u003evalueint, subitem-\u003evaluedouble);\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_INT_OR_NUM;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].integer = subitem-\u003evalueint;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].number = subitem-\u003evaluedouble;\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\telse if (JSON_IS_STRING(subitem)) {\n\t\t\t\tIOT_DEBUG(\"[%d] %s\", num_args, JSON_GET_STRING_VALUE(subitem));\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_STRING;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].string = iot_os_strdup(JSON_GET_STRING_VALUE(subitem));\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\telse if (JSON_IS_OBJECT(subitem) || JSON_IS_ARRAY(subitem)) {\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_JSON_OBJECT;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].json_object = JSON_PRINT(subitem);\n\t\t\t\tIOT_DEBUG(\"[%d] %s\", num_args, cmd_data-\u003ecmd_data[num_args].json_object);\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\tsubitem = subitem-\u003enext;\n\t\t}\n\t}\n\tcmd_data-\u003enum_args = num_args;\n\n\tif (command_id != NULL) {\n\t\tcmd_data-\u003ecommand_id = iot_os_strdup(JSON_GET_STRING_VALUE(command_id));\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":920,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"86785":{"score":0.8638321,"function_name":"_iot_make_evt_data","code":"static JSON_H *_iot_make_evt_data(const char* component, const char* capability, iot_cap_evt_data_t* evt_data, int seq_num)\n{\n\tJSON_H *evt_item = NULL;\n\tJSON_H *evt_subarr = NULL;\n\tJSON_H *evt_subjson = NULL;\n\tJSON_H *evt_subdata = NULL;\n\tJSON_H *prov_data = NULL;\n\tJSON_H *visibility_data = NULL;\n\tchar time_in_ms[16]; /* 155934720000 is '2019-06-01 00:00:00.00 UTC' */\n\n\tevt_item = JSON_CREATE_OBJECT();\n\n\tif (evt_data-\u003eoptions.command_id != NULL) {\n\t\t/* commandId */\n\t\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"commandId\", evt_data-\u003eoptions.command_id);\n\t}\n\n\t/* component */\n\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"component\", component);\n\n\t/* capability */\n\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"capability\", capability);\n\n\t/* attribute */\n\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"attribute\", evt_data-\u003eevt_type);\n\n\t/* value */\n\tif (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_BOOLEAN) {\n\t\tJSON_ADD_BOOL_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.boolean);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_INTEGER) {\n\t\tJSON_ADD_NUMBER_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.integer);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_NUMBER) {\n\t\tJSON_ADD_NUMBER_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.number);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_STRING) {\n\t\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.string);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_STR_ARRAY) {\n\t\tif (evt_data-\u003eevt_value.str_num == 0) {\n\t\t\tevt_subarr = JSON_CREATE_ARRAY();\n\t\t} else {\n\t\t\tevt_subarr = JSON_CREATE_STRING_ARRAY(\n\t\t\t\t(const char**)evt_data-\u003eevt_value.strings, evt_data-\u003eevt_value.str_num);\n\t\t}\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"value\", evt_subarr);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_JSON_OBJECT) {\n\t\tevt_subjson = JSON_PARSE(evt_data-\u003eevt_value.json_object);\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"value\", evt_subjson);\n\t} else {\n\t\tIOT_ERROR(\"Event data value type error :%d\", evt_data-\u003eevt_value.type);\n\t\tJSON_DELETE(evt_item);\n\t\treturn NULL;\n\t}\n\n\t/* unit */\n\tif (evt_data-\u003eevt_unit.type == IOT_CAP_UNIT_TYPE_STRING)\n\t\t\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"unit\", evt_data-\u003eevt_unit.string);\n\n\t/* data */\n\tif (evt_data-\u003eevt_value_data) {\n\t\tevt_subdata = JSON_PARSE(evt_data-\u003eevt_value_data);\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"data\", evt_subdata);\n\t}\n\n\t/* visibility */\n\tif (evt_data-\u003eoptions.displayed != NULL)\n\t{\n\t\tvisibility_data = JSON_CREATE_OBJECT();\n\t\tJSON_ADD_BOOL_TO_OBJECT(visibility_data, \"displayed\", *(evt_data-\u003eoptions.displayed));\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"visibility\", visibility_data);\n\t}\n\n\t/* providerData */\n\tprov_data = JSON_CREATE_OBJECT();\n\tJSON_ADD_NUMBER_TO_OBJECT(prov_data, \"sequenceNumber\", seq_num);\n\n\tif (iot_get_time_in_ms(time_in_ms, sizeof(time_in_ms)) != IOT_ERROR_NONE)\n\t\tIOT_WARN(\"Cannot add optional timestamp value\");\n\telse\n\t\tJSON_ADD_STRING_TO_OBJECT(prov_data, \"timestamp\", time_in_ms);\n\n\tif (evt_data-\u003eoptions.state_change)\n\t\tJSON_ADD_STRING_TO_OBJECT(prov_data, \"stateChange\", \"Y\");\n\n\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"providerData\", prov_data);\n\n\treturn evt_item;\n}","filepath":"src/iot_capability.c","line_number":1002,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"87789":{"score":0.94533306,"function_name":"iot_cap_call_init_cb","code":"void iot_cap_call_init_cb(iot_cap_handle_list_t *cap_handle_list)\n{\n\tstruct iot_cap_handle *handle = NULL;\n\tstruct iot_cap_handle_list *cur_list;\n\n\tif (!cap_handle_list) {\n\t\tIOT_ERROR(\"There is no cap_handle_list\");\n\t\treturn;\n\t}\n\n\tcur_list = cap_handle_list;\n\twhile (cur_list != NULL) {\n\t\thandle = cur_list-\u003ehandle;\n\t\tif (handle \u0026\u0026 handle-\u003einit_cb) {\n\t\t\tIOT_INFO(\"Call init_cb for %s capability\",\n\t\t\t\thandle-\u003ecapability ? handle-\u003ecapability : \"NULL\");\n\t\t\thandle-\u003einit_cb((IOT_CAP_HANDLE*)handle, handle-\u003einit_usr_data);\n\t\t}\n\t\tcur_list = cur_list-\u003enext;\n\t}\n}","filepath":"src/iot_capability.c","line_number":1090,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88002":{"score":0.8936006,"function_name":"_iot_free_val","code":"static void _iot_free_val(iot_cap_val_t* val)\n{\n\tint i;\n\n\tif (val == NULL) {\n\t\treturn;\n\t}\n\n\tif (val-\u003etype == IOT_CAP_VAL_TYPE_STRING\n\t\t\t\t\u0026\u0026 val-\u003estring != NULL) {\n\t\tiot_os_free(val-\u003estring);\n\t}\n\telse if (val-\u003etype == IOT_CAP_VAL_TYPE_STR_ARRAY\n\t\t\t\t\u0026\u0026 val-\u003estrings != NULL) {\n\t\tfor (i = 0; i \u003c val-\u003estr_num; i++) {\n\t\t\tif (val-\u003estrings[i] != NULL) {\n\t\t\t\tiot_os_free(val-\u003estrings[i]);\n\t\t\t}\n\t\t}\n\t\tiot_os_free(val-\u003estrings);\n\t} else if (val-\u003etype == IOT_CAP_VAL_TYPE_JSON_OBJECT) {\n\t\tiot_os_free(val-\u003ejson_object);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1112,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88225":{"score":0.7486477,"function_name":"_iot_free_unit","code":"static void _iot_free_unit(iot_cap_unit_t* unit)\n{\n\tif (unit == NULL) {\n\t\treturn;\n\t}\n\n\tif (unit-\u003etype == IOT_CAP_UNIT_TYPE_STRING\n\t\t\t\t\u0026\u0026 unit-\u003estring != NULL) {\n\t\tiot_os_free(unit-\u003estring);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1137,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88297":{"score":0.86067086,"function_name":"_iot_free_cmd_data","code":"static void _iot_free_cmd_data(iot_cap_cmd_data_t* cmd_data)\n{\n\tint i;\n\n\tif (cmd_data == NULL) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i \u003c cmd_data-\u003enum_args; i++) {\n\t\tif (cmd_data-\u003eargs_str[i] != NULL) {\n\t\t\tfree(cmd_data-\u003eargs_str[i]);\n\t\t}\n\t\t_iot_free_val(\u0026cmd_data-\u003ecmd_data[i]);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1149,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88428":{"score":0.740069,"function_name":"_iot_free_evt_data","code":"static void _iot_free_evt_data(iot_cap_evt_data_t* evt_data)\n{\n\tif (evt_data == NULL) {\n\t\treturn;\n\t}\n\n\tif (evt_data-\u003eevt_type != NULL) {\n\t\tiot_os_free((void *)evt_data-\u003eevt_type);\n\t}\n\t_iot_free_val(\u0026evt_data-\u003eevt_value);\n\t_iot_free_unit(\u0026evt_data-\u003eevt_unit);\n\n\tif (evt_data-\u003eevt_value_data != NULL) {\n\t\tiot_os_free(evt_data-\u003eevt_value_data);\n\t}\n\n\tif (evt_data-\u003eoptions.command_id != NULL) {\n\t\tiot_os_free(evt_data-\u003eoptions.command_id);\n\t}\n\n\tif (evt_data-\u003eoptions.displayed != NULL) {\n\t\tiot_os_free(evt_data-\u003eoptions.displayed);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1165,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88820":{"score":0.90863806,"function_name":"_iot_command_peek","code":"STATIC_FUNCTION\niot_error_t _iot_command_peek(struct iot_context *ctx, enum iot_command_type peek_cmd)\n{\n\tstruct iot_command cmd_data;\n\tint ret;\n\tiot_error_t err;\n\tbool *cmd_only = NULL;\n\n\tif (peek_cmd != IOT_COMMAND_CHECK_PROV_STATUS) {\n\t\tIOT_ERROR(\"Unsupported peek cmd(%d)\", peek_cmd);\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tcmd_only = iot_os_malloc(sizeof(bool));\n\tif (!cmd_only) {\n\t\tIOT_ERROR(\"failed to malloc for iot_command_peek param\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\t*cmd_only = true;\n\n\tcmd_data.param = cmd_only;\n\tcmd_data.cmd_type = peek_cmd;\n\n\tret = iot_os_queue_send(ctx-\u003ecmd_queue, \u0026cmd_data, 0);\n\tif (ret != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"Cannot put the cmd into cmd_queue\");\n\t\tiot_os_free(cmd_data.param);\n\t\terr = IOT_ERROR_BAD_REQ;\n\t} else {\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_COMMAND);\n\t\terr = IOT_ERROR_NONE;\n\t}\n\n\treturn err;\n}","filepath":"src/iot_main.c","line_number":56,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"89156":{"score":0.91116583,"function_name":"_check_prov_data_validation","code":"STATIC_FUNCTION\niot_error_t _check_prov_data_validation(struct iot_device_prov_data *prov_data)\n{\n\tstruct iot_wifi_prov_data *wifi = \u0026(prov_data-\u003ewifi);\n\tstruct iot_cloud_prov_data *cloud = \u0026(prov_data-\u003ecloud);\n\n\tif (wifi-\u003essid[0] == '\\0') {\n\t\tIOT_ERROR(\"There is no ssid on prov_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!cloud-\u003ebroker_url) {\n\t\tIOT_ERROR(\"There is no broker_url on prov_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (cloud-\u003ebroker_port \u003c 0) {\n\t\tIOT_ERROR(\"There is wrong port(%d) on prov_data\", cloud-\u003ebroker_port);\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_main.c","line_number":93,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"89369":{"score":0.78741723,"function_name":"_delete_easysetup_resources_all","code":"STATIC_FUNCTION\nvoid _delete_easysetup_resources_all(struct iot_context *ctx)\n{\n\tctx-\u003ees_res_created = false;\n\n\tif (ctx-\u003epin) {\n\t\tiot_os_free(ctx-\u003epin);\n\t\tctx-\u003epin = NULL;\n\t}\n\tif (ctx-\u003eeasysetup_security_context) {\n\t\tiot_security_deinit(ctx-\u003eeasysetup_security_context);\n\t\tctx-\u003eeasysetup_security_context = NULL;\n\t}\n\tif (ctx-\u003eeasysetup_req_queue) {\n\t\tiot_os_queue_delete(ctx-\u003eeasysetup_req_queue);\n\t\tctx-\u003eeasysetup_req_queue = NULL;\n\t}\n\tif (ctx-\u003eeasysetup_resp_queue) {\n\t\tiot_os_queue_delete(ctx-\u003eeasysetup_resp_queue);\n\t\tctx-\u003eeasysetup_resp_queue = NULL;\n\t}\n}","filepath":"src/iot_main.c","line_number":116,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"89570":{"score":0.87518823,"function_name":"_create_easysetup_resources","code":"STATIC_FUNCTION\niot_error_t _create_easysetup_resources(struct iot_context *ctx, iot_pin_t *pin_num)\n{\n\tiot_error_t ret;\n\n\t/* If PIN type used, iot_pin_t should be set */\n\tif (ctx-\u003edevconf.ownership_validation_type \u0026 IOT_OVF_TYPE_PIN) {\n\t\tif (!ctx-\u003epin) {\n\t\t\tif ((ctx-\u003epin = iot_os_malloc(sizeof(iot_pin_t))) == NULL) {\n\t\t\t\tIOT_ERROR(\"failed to malloc for pin\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t\t}\n\t\t}\n\n\t\tif (pin_num) {\n\t\t\tmemcpy(ctx-\u003epin, pin_num, sizeof(iot_pin_t));\n\t\t} else {\n\t\t\tret = IOT_ERROR_INVALID_ARGS;\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tctx-\u003eeasysetup_security_context = iot_security_init();\n\tif (ctx-\u003eeasysetup_security_context == NULL) {\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tret = IOT_ERROR_SECURITY_INIT;\n\t\tgoto create_fail;\n\t}\n\n\tif (!ctx-\u003eeasysetup_req_queue) {\n\t\tctx-\u003eeasysetup_req_queue = iot_os_queue_create(1, sizeof(struct iot_easysetup_payload));\n\t\tif (!ctx-\u003eeasysetup_req_queue) {\n\t\t\tIOT_ERROR(\"failed to create Queue for easysetup request\\n\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\tret = IOT_ERROR_BAD_REQ;\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tif (!ctx-\u003eeasysetup_resp_queue) {\n\t\tctx-\u003eeasysetup_resp_queue = iot_os_queue_create(1, sizeof(struct iot_easysetup_payload));\n\t\tif (!ctx-\u003eeasysetup_resp_queue) {\n\t\t\tIOT_ERROR(\"failed to create Queue for easysetup response\\n\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\tret = IOT_ERROR_BAD_REQ;\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tctx-\u003ees_res_created = true;\n\treturn IOT_ERROR_NONE;\n\ncreate_fail:\n\t_delete_easysetup_resources_all(ctx);\n\treturn ret;\n}","filepath":"src/iot_main.c","line_number":139,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"90106":{"score":0.9139755,"function_name":"_do_status_report","code":"STATIC_FUNCTION\nvoid _do_status_report(struct iot_context *ctx,\n\tiot_state_t target_state, bool is_final)\n{\n\tiot_status_t fn_stat = 0;\n\tiot_stat_lv_t fn_stat_lv = 0;\n\tunsigned int curr_stat = 0;\n\tbool is_report = false;\n\n\tswitch (target_state) {\n\tcase IOT_STATE_CHANGE_FAILED:\n\t\tif (ctx-\u003ereported_stat) {\n\t\t\tfn_stat = (ctx-\u003ereported_stat \u0026 IOT_STATUS_ALL);\n\t\t\tfn_stat_lv = IOT_STAT_LV_FAIL;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_INITIALIZED:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_IDLE;\n\t\t\tfn_stat_lv = IOT_STAT_LV_STAY;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_ENTER:\n\t\tif (is_final) {\n\t\t\tfn_stat = IOT_STATUS_PROVISIONING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_START;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONN_MOBILE:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_PROVISIONING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_CONN;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONFIRM:\n\t\tif (ctx-\u003ecurr_otm_feature == OVF_BIT_BUTTON) {\n\t\t\tfn_stat = IOT_STATUS_NEED_INTERACT;\n\t\t\tfn_stat_lv = IOT_STAT_LV_STAY;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_DONE:\n\t\tif (is_final) {\n\t\t\tfn_stat = IOT_STATUS_PROVISIONING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_DONE;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_CONNECTING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_SIGN_UP;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_CONNECTING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_SIGN_IN;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTED:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_CONNECTING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_DONE;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_DISCONNECTED:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_IDLE;\n\t\t\tfn_stat_lv = IOT_STAT_LV_STAY;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_INFO(\"Unsupported state %d for %d/%d\", target_state, fn_stat, fn_stat_lv);\n\t\tbreak;\n\t}\n\n\tif (is_report \u0026\u0026 (fn_stat \u0026 ctx-\u003estatus_maps)) {\n\t\t/* we assume that fn_stat uses only 8bits */\n\t\tcurr_stat = fn_stat | (fn_stat_lv \u003c\u003c 8);\n\n\t\tif (ctx-\u003ereported_stat != curr_stat) {\n\t\t\tIOT_INFO(\"Call usr status_cb with %d/%d\", fn_stat, fn_stat_lv);\n\t\t\tctx-\u003estatus_cb(fn_stat, fn_stat_lv, ctx-\u003estatus_usr_data);\n\t\t\tctx-\u003ereported_stat = curr_stat;\n\t\t}\n\t}\n\n}","filepath":"src/iot_main.c","line_number":204,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"90776":{"score":0.8208431,"function_name":"_clear_cmd_status","code":"static void _clear_cmd_status(struct iot_context *ctx, enum iot_command_type cmd_type)\n{\n\tif (cmd_type != IOT_COMMNAD_STATE_UPDATE) {\n\t\tctx-\u003ecmd_count[cmd_type]--;\n\t\tif (!ctx-\u003ecmd_count[cmd_type])\n\t\tctx-\u003ecmd_status \u0026= ~(1u \u003c\u003c cmd_type);\n\t}\n}","filepath":"src/iot_main.c","line_number":312,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"90895":{"score":0.87194526,"function_name":"_unlikely_with_stored_dip","code":"static bool _unlikely_with_stored_dip(struct iot_dip_data *chk_dip)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_dip_data old_dip;\n\tint idx;\n\n\tif (chk_dip == NULL) {\n\t\treturn true;\n\t}\n\n\terr = iot_misc_info_load(IOT_MISC_INFO_DIP, (void *)\u0026old_dip);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to load stored DIP!! (%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\treturn true;\n\t}\n\n\tfor (idx = 0; idx \u003c IOT_UUID_BYTES; idx++) {\n\t\tif (chk_dip-\u003edip_id.id[idx] != old_dip.dip_id.id[idx]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (chk_dip-\u003edip_major_version != old_dip.dip_major_version) {\n\t\treturn true;\n\t}\n\n\tif (chk_dip-\u003edip_minor_version != old_dip.dip_minor_version) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}","filepath":"src/iot_main.c","line_number":321,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"91147":{"score":0.8972808,"function_name":"_prepare_self_reged","code":"static iot_error_t _prepare_self_reged(struct iot_context *ctx)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_uuid old_location;\n\tchar *location_str = NULL;\n\tchar *lookup_str = NULL;\n\n\tif (!ctx) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\t/* Make new lookup_id for self-registration */\n\tlookup_str = (char *)iot_os_malloc(IOT_REG_UUID_STR_LEN + 1);\n\tif (!lookup_str) {\n\t\tIOT_ERROR(\"Failed to malloc for lookup_str\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tmemset(lookup_str, 0, (IOT_REG_UUID_STR_LEN +1));\n\n\terr = iot_get_random_id_str(lookup_str,\n\t\t\t(IOT_REG_UUID_STR_LEN + 1));\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to get new lookup_str(%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\tgoto error_prepare_self;\n\t}\n\n\t/* Load previous locationId from NV */\n\terr = iot_misc_info_load(IOT_MISC_INFO_LOCATION,\n\t\t\t(void *)\u0026old_location);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to load old_location(%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\tgoto error_prepare_self;\n\t}\n\n\tlocation_str = (char *)iot_os_malloc(IOT_REG_UUID_STR_LEN +1);\n\tif (!location_str) {\n\t\tIOT_ERROR(\"Failed to malloc for location_str\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tgoto error_prepare_self;\n\t}\n\tmemset(location_str, 0, (IOT_REG_UUID_STR_LEN +1));\n\n\terr = iot_util_convert_uuid_str(\u0026old_location, location_str,\n\t\t\t(IOT_REG_UUID_STR_LEN + 1));\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to convert location_str(%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\tgoto error_prepare_self;\n\t}\n\n\t/* lookup_id \u0026 location are runtime allocated string\n\t * during D2D process, so free it first to avoid memory-leak\n\t */\n\tif (ctx-\u003elookup_id) {\n\t\tiot_os_free(ctx-\u003elookup_id);\n\t}\n\tctx-\u003elookup_id = lookup_str;\n\n\tif (ctx-\u003eprov_data.cloud.location) {\n\t\tiot_os_free(ctx-\u003eprov_data.cloud.location);\n\t}\n\tctx-\u003eprov_data.cloud.location = location_str;\n\n\treturn IOT_ERROR_NONE;\n\nerror_prepare_self:\n\tif (lookup_str) {\n\t\tiot_os_free(lookup_str);\n\t}\n\n\tif (location_str) {\n\t\tiot_os_free(location_str);\n\t}\n\n\treturn err;\n}","filepath":"src/iot_main.c","line_number":355,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"91781":{"score":0.9406173,"function_name":"_delete_dev_card_by_usr","code":"STATIC_FUNCTION\niot_error_t _delete_dev_card_by_usr(struct iot_context *ctx)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tunsigned char curr_events;\n\tst_mqtt_msg msg;\n\tint ret;\n\n\tif (!ctx) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif ((!ctx-\u003eevt_mqttcli) || (ctx-\u003ecurr_state != IOT_STATE_CLOUD_CONNECTED)) {\n\t\tIOT_WARN(\"not connected, so can't send device_card deleting msg\");\n\t\treturn IOT_ERROR_NONE;\n\t}\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_CMD_DONE);\n\tctx-\u003eusr_delete_req = true;\n\n\t/* GreatGate wants to receive 'empty' payload */\n\tmsg.payload = NULL;\n\tmsg.payloadlen = 0;\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = IOT_PUB_TOPIC_DELETE;\n\n\tret = st_mqtt_publish(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tIOT_ERROR(\"error MQTTpub for %s(%d)\", (char *)msg.topic, ret);\n\t\tctx-\u003eusr_delete_req = false;\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t} else {\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE, true, (NEXT_STATE_TIMEOUT_MS / 2));\n\n\t\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_CMD_DONE)) {\n\t\t\tIOT_ERROR(\"Timeout happened for device_card deleting\");\n\t\t\tctx-\u003eusr_delete_req = false;\n\t\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t\t}\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":436,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"92188":{"score":0.8928757,"function_name":"_do_iot_main_command","code":"static iot_error_t _do_iot_main_command(struct iot_context *ctx,\n\tstruct iot_command *cmd)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_state_t next_state;\n\tint state_opt = IOT_STATE_OPT_NONE;\n\tiot_wifi_conf *conf = NULL;\n\tchar *usr_id = NULL;\n\tsize_t str_len;\n\tstruct iot_state_data *state_data;\n\tunsigned int needed_tout = 0;\n\tiot_noti_data_t *noti = NULL;\n\tbool is_diff_dip = false;\n\tbool *reboot = NULL;\n\tbool *cmd_only = NULL;\n\n\tIOT_INFO(\"curr_main_cmd:%d, curr_main_state:%d/%d\",\n\t\tcmd-\u003ecmd_type, ctx-\u003ecurr_state, ctx-\u003ereq_state);\n\n\t/* Some State has to queue several commands sequentially\n\t * But sometimes next command queuing or next process can make error\n\t * after the first command queued successfully.\n\t * So to prevent the first command handling after error occurred,\n\t * added command skipping coroutine\n\t */\n\tif (ctx-\u003ecmd_err \u0026\u0026 (cmd-\u003ecmd_type \u003c IOT_COMMAND_TYPE_MAX)) {\n\t\tIOT_WARN(\"iot-core had errors!!(0x%0x), skip cmd\", ctx-\u003ecmd_err);\n\t\tIOT_DUMP_MAIN_ARG2(WARN, COMMAND, ctx-\u003ecmd_err, ctx-\u003ecurr_state);\n\t\tgoto out_do_cmd;\n\t}\n\n\tswitch (cmd-\u003ecmd_type) {\n\t\tcase IOT_COMMNAD_STATE_UPDATE:\n\t\t\tstate_data = (struct iot_state_data *)cmd-\u003eparam;\n\t\t\tif (!state_data) {\n\t\t\t\tIOT_ERROR(\"There is no state_data for cmd :%d\", cmd-\u003ecmd_type);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((ctx-\u003ecurr_state \u003e IOT_STATE_UNKNOWN) \u0026\u0026\n\t\t\t\t\t(ctx-\u003ecurr_state == state_data-\u003eiot_state)) {\n\t\t\t\tIOT_WARN(\"Redundant command. state update in progress !\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = _do_state_updating(ctx, state_data-\u003eiot_state,\n\t\t\t\t\tstate_data-\u003eopt, \u0026needed_tout);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to handle new state : %d\", state_data-\u003eiot_state);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, state_data-\u003eiot_state);\n\t\t\t} else {\n\t\t\t\tif (needed_tout) {\n\t\t\t\t\t/* Internal state will be updated with timeout */\n\t\t\t\t\tctx-\u003ecmd_err = 0;\n\t\t\t\t\tctx-\u003ereq_state = state_data-\u003eiot_state;\n\t\t\t\t\t_do_update_timeout(ctx, needed_tout);\n\t\t\t\t}\n\n\t\t\t\t/* Call the user's status_cb function if it's available */\n\t\t\t\tif (ctx-\u003estatus_cb)\n\t\t\t\t\t_do_status_report(ctx, state_data-\u003eiot_state, false);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t/* For Resource control */\n\t\tcase IOT_COMMAND_READY_TO_CTL:\n\t\t\tctx-\u003ercv_fail_state = IOT_STATE_INITIALIZED;\n\t\t\tctx-\u003ercv_try_cnt = 0;\n\t\t\tiot_cap_call_init_cb(ctx-\u003ecap_handle_list);\n\t\t\tbreak;\n\n\t\t/* For Device control */\n\t\tcase IOT_COMMAND_NETWORK_MODE:\n\t\t\tconf = (iot_wifi_conf *)cmd-\u003eparam;\n\t\t\tif (!conf) {\n\t\t\t\tIOT_ERROR(\"failed to get iot_wifi_conf\\n\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t} else {\n\t\t\t\terr = iot_bsp_wifi_set_mode(conf);\n\t\t\t\tif (err \u003c 0) {\n\t\t\t\t\tIOT_ERROR(\"failed to set wifi_set_mode\\n\");\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!conf || err \u003c 0) {\n\t\t\t\tif (ctx-\u003ereq_state != IOT_STATE_CHANGE_FAILED) {\n\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\terr = iot_state_update(ctx,\n\t\t\t\t\t\t\tnext_state, state_opt);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"Duplicated error handling, skip updating!!\");\n\t\t\t\t\terr = IOT_ERROR_DUPLICATED_CMD;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (conf-\u003emode) {\n\t\t\tcase IOT_WIFI_MODE_SOFTAP:\n\t\t\t\tif (ctx-\u003ereq_state == IOT_STATE_PROV_ENTER) {\n\t\t\t\t\terr = iot_easysetup_init(ctx);\n\t\t\t\t\tIOT_MEM_CHECK(\"ES_INIT DONE \u003e\u003ePT\u003c\u003c\");\n\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_ERROR(\"failed to iot_easysetup_init(%d)\", err);\n\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\n\t\t\t\t\t\tif (ctx-\u003ereq_state != IOT_STATE_CHANGE_FAILED) {\n\t\t\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\t\t\terr = iot_state_update(ctx,\n\t\t\t\t\t\t\t\tnext_state, state_opt);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tIOT_WARN(\"Duplicated error handling, skip updating!!\");\n\t\t\t\t\t\t\terr = IOT_ERROR_DUPLICATED_CMD;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx-\u003ees_http_ready = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* For state related control */\n\t\tcase IOT_COMMAND_CHECK_PROV_STATUS:\n\t\t\tif (cmd-\u003eparam) {\n\t\t\t\tcmd_only = (bool *)cmd-\u003eparam;\n\t\t\t}\n\t\t\tctx-\u003eiot_reg_data.new_reged = false;\n\n\t\t\t/* Now we allow D2D process reentrant and prov_data could be loaded\n\t\t\t * at the init state or previous D2D, so free it first to avoid memory-leak\n\t\t\t */\n\t\t\tiot_api_prov_data_mem_free(\u0026ctx-\u003eprov_data);\n\t\t\terr = iot_nv_get_prov_data(\u0026ctx-\u003eprov_data);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_DEBUG(\"There are no prov data in NV\\n\");\n\t\t\t\terr = iot_nv_erase(IOT_NVD_DEVICE_ID);\n\t\t\t\tif ((err != IOT_ERROR_NONE) \u0026\u0026 (err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\t\t\t\tIOT_ERROR(\"Can't remove deviceId for new registraiton\");\n\t\t\t\t}\n\n\t\t\t\tctx-\u003eiot_reg_data.new_reged = true;\n\t\t\t\tnext_state = IOT_STATE_PROV_ENTER;\n\t\t\t} else {\n\t\t\t\terr = _check_prov_data_validation(\u0026ctx-\u003eprov_data);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_WARN(\"There are no valid prov data in NV\\n\");\n\t\t\t\t\terr = iot_nv_erase(IOT_NVD_DEVICE_ID);\n\t\t\t\t\tif ((err != IOT_ERROR_NONE) \u0026\u0026 (err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\t\t\t\t\tIOT_ERROR(\"Can't remove deviceId for new registraiton\");\n\t\t\t\t\t}\n\n\t\t\t\t\tctx-\u003eiot_reg_data.new_reged = true;\n\t\t\t\t\tnext_state = IOT_STATE_PROV_ENTER;\n\t\t\t\t} else {\n\t\t\t\t\tnext_state = IOT_STATE_PROV_DONE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cmd_only \u0026\u0026 *cmd_only) {\n\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE);\n\t\t\t\t/* We don't need recovering for command only case */\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_WARN(\"Internal WARN(%d) happened for command only\", err);\n\t\t\t\t}\n\n\t\t\t\treturn IOT_ERROR_NONE;\n\t\t\t} else {\n\t\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CHECK_CLOUD_STATE:\n\t\t\tctx-\u003eiot_reg_data.self_reged = false;\n\n\t\t\tif (ctx-\u003eiot_reg_data.new_reged) {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t} else if (ctx-\u003eiot_reg_data.updated) {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t} else {\n\t\t\t\terr = iot_nv_get_device_id(\u0026usr_id, \u0026str_len);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_WARN(\"There are no reged data in NV\\n\");\n\t\t\t\t\tif (ctx-\u003ereq_state == IOT_STATE_PROV_DONE) {\n\t\t\t\t\t\t/* Current server does not send any notification when the device\n\t\t\t\t\t\t * tries to start registration process with invalid information\n\t\t\t\t\t\t * such as manuall or forcely reboot case after provisioning step.\n\t\t\t\t\t\t * So, we forcely remove all data \u0026 reboot the device\n\t\t\t\t\t\t */\n\t\t\t\t\t\tIOT_WARN(\"Some thing went wrong, got provisioning but no deviceId\");\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xC1EAC1EA);\n\n\t\t\t\t\t\tif (ctx-\u003ees_http_ready) {\n\t\t\t\t\t\t\tctx-\u003ees_http_ready = false;\n\t\t\t\t\t\t\tiot_easysetup_deinit(ctx);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ctx-\u003ees_res_created)\n\t\t\t\t\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t\t\t\t\tiot_device_cleanup(ctx);\n\n\t\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\t\t/* The device will be reboot forcely */\n\t\t\t\t\t\tIOT_REBOOT();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (str_len \u003e IOT_REG_UUID_STR_LEN) {\n\t\t\t\t\t\tIOT_WARN(\"Long deviceID in NV %s, use it insize\\n\",\n\t\t\t\t\t\t\tusr_id);\n\t\t\t\t\t\tmemcpy(ctx-\u003eiot_reg_data.deviceId, usr_id,\n\t\t\t\t\t\t\tIOT_REG_UUID_STR_LEN);\n\t\t\t\t\t\tctx-\u003eiot_reg_data.deviceId[IOT_REG_UUID_STR_LEN] = '\\0';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemcpy(ctx-\u003eiot_reg_data.deviceId, usr_id, str_len);\n\t\t\t\t\t\tctx-\u003eiot_reg_data.deviceId[str_len] = '\\0';\n\n\t\t\t\t\t\tIOT_INFO(\"Current deviceID: %s (%d)\\n\",\n\t\t\t\t\t\t\tctx-\u003eiot_reg_data.deviceId, str_len);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ctx-\u003edevconf.dip) {\n\t\t\t\t\t\tis_diff_dip = _unlikely_with_stored_dip(ctx-\u003edevconf.dip);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tis_diff_dip = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_diff_dip) {\n\t\t\t\t\t\terr = _prepare_self_reged(ctx);\n\t\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\t\tIOT_ERROR(\"Failed to prepare self registration(%d)\", err);\n\t\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t\t\t\tis_diff_dip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_diff_dip) {\n\t\t\t\t\t\tctx-\u003eiot_reg_data.self_reged = true;\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx-\u003eiot_reg_data.updated = true;\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(usr_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CLOUD_REGISTERING:\n\t\t\t/* if there is previous connection, disconnect it first. */\n\t\t\tif (ctx-\u003ereg_mqttcli != NULL) {\n\t\t\t\tIOT_INFO(\"There is active registering, disconnect it first.\\n\");\n\t\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\t}\n\n\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\tif (err == IOT_ERROR_MQTT_REJECT_CONNECT) {\n\t\t\t\t/* This error case will be happended when server replies\n\t\t\t\t * some specific response, so the trial to connect with server\n\t\t\t\t * is succeeded (with REJECT). By this reason, we don't want\n\t\t\t\t * to change the STATE by the failure.\n\t\t\t\t */\n\t\t\t\tIOT_WARN(\"Intended error case(reboot), go to STATE_UNKONWN\\n\");\n\t\t\t\terr = iot_state_update(ctx, IOT_STATE_UNKNOWN, state_opt);\n\t\t\t} else if (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to iot_es_connect for registration\\n\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\n\t\t\t\tif (ctx-\u003ereq_state != IOT_STATE_CHANGE_FAILED) {\n\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\terr = iot_state_update(ctx,\n\t\t\t\t\t\t\tnext_state, state_opt);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"Duplicated error handling, skip updating!!\");\n\t\t\t\t\terr = IOT_ERROR_DUPLICATED_CMD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIOT_MEM_CHECK(\"CLOUD_REGISTERING DONE \u003e\u003ePT\u003c\u003c\");\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CLOUD_REGISTERED:\n\t\t\tif (iot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION) != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to _iot_es_disconnect for registration\\n\");\n\t\t\t}\n\n\t\t\tif (ctx-\u003eprov_data.cloud.location) {\n\t\t\t\tiot_os_free(ctx-\u003eprov_data.cloud.location);\n\t\t\t\tctx-\u003eprov_data.cloud.location = NULL;\n\t\t\t}\n\n\t\t\tif (ctx-\u003eprov_data.cloud.room) {\n\t\t\t\tiot_os_free(ctx-\u003eprov_data.cloud.room);\n\t\t\t\tctx-\u003eprov_data.cloud.room = NULL;\n\t\t\t}\n\n\t\t\tif (ctx-\u003eiot_reg_data.updated) {\n\t\t\t\tif (ctx-\u003eiot_reg_data.dip) {\n\t\t\t\t\terr = iot_misc_info_store(IOT_MISC_INFO_DIP,\n\t\t\t\t\t\t\t(const void *)ctx-\u003eiot_reg_data.dip);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_ERROR(\"Store DIP failed!! (%d)\", err);\n\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t\t}\n\n\t\t\t\t\tiot_os_free(ctx-\u003eiot_reg_data.dip);\n\t\t\t\t\tctx-\u003eiot_reg_data.dip = NULL;\n\t\t\t\t}\n\n\t\t\t\tif (ctx-\u003eiot_reg_data.locationId) {\n\t\t\t\t\terr = iot_misc_info_store(IOT_MISC_INFO_LOCATION,\n\t\t\t\t\t\t\t(const void *)ctx-\u003eiot_reg_data.locationId);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_ERROR(\"Store LocationId failed!! (%d)\", err);\n\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t\t}\n\n\t\t\t\t\tiot_os_free(ctx-\u003eiot_reg_data.locationId);\n\t\t\t\t\tctx-\u003eiot_reg_data.locationId = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"There is no locationId!!\");\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xBAD2C1EA);\n\t\t\t\t}\n\n\t\t\t\terr = iot_nv_set_device_id(ctx-\u003eiot_reg_data.deviceId);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"Set deviceId failed!! (%d)\", err);\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"Rgistration data updated failed!!\");\n\t\t\t\terr = IOT_ERROR_REG_UPDATED;\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t}\n\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t} else {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t}\n\n\t\t\tIOT_MEM_CHECK(\"CLOUD_REGISTERED DONE \u003e\u003ePT\u003c\u003c\");\n\n\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CLOUD_CONNECTING:\n\t\t\t/* we don't need this lookup_id anymore */\n\t\t\tif (ctx-\u003elookup_id) {\n\t\t\t\tfree(ctx-\u003elookup_id);\n\t\t\t\tctx-\u003elookup_id = NULL;\n\t\t\t}\n\n\t\t\t/* we don't need this hashed_sn anymore*/\n\t\t\tif (ctx-\u003edevconf.hashed_sn) {\n\t\t\t\tfree(ctx-\u003edevconf.hashed_sn);\n\t\t\t\tctx-\u003edevconf.hashed_sn = NULL;\n\t\t\t}\n\n\t\t\t/* if there is previous connection, disconnect it first. */\n\t\t\tif (ctx-\u003eevt_mqttcli != NULL) {\n\t\t\t\tIOT_INFO(\"There is previous connecting, disconnect it first.\\n\");\n\t\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t}\n\n\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\tif (err == IOT_ERROR_MQTT_REJECT_CONNECT) {\n\t\t\t\t/* This error case will be happended when server replies\n\t\t\t\t * some specific response, so the trial to connect with server\n\t\t\t\t * is succeeded (with REJECT). By this reason, we don't want\n\t\t\t\t * to change the STATE by the failure.\n\t\t\t\t */\n\t\t\t\tIOT_WARN(\"Intended error case(reboot), go to STATE_UNKONWN\\n\");\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\tnext_state = IOT_STATE_UNKNOWN;\n\t\t\t} else if (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to iot_es_connect for communication\\n\");\n\n\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t} else {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTED;\n\t\t\t}\n\n\t\t\tIOT_MEM_CHECK(\"CLOUD_CONNECTTING DONE \u003e\u003ePT\u003c\u003c\");\n\n\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_NOTIFICATION_RECEIVED:\n\t\t\tnoti = (iot_noti_data_t *)cmd-\u003eparam;\n\t\t\tif (!noti) {\n\t\t\t\tIOT_ERROR(\"There is no noti handler\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tIOT_DUMP_MAIN(INFO, BASE, noti-\u003etype);\n\n\t\t\tif (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_DEV_DELETED) {\n\t\t\t\tif (ctx-\u003eusr_delete_req) {\n\t\t\t\t\tIOT_INFO(\"Device-card deleting is done\");\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xC1EAC1EB);\n\n\t\t\t\t\tctx-\u003eusr_delete_req = false;\n\t\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_INFO(\"cleanup device\");\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xC1EAC1EA);\n\n\t\t\t\t\tiot_device_cleanup(ctx);\n\t\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\n\t\t\t\t\tIOT_REBOOT();\n\t\t\t\t}\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_RATE_LIMIT) {\n\t\t\t\tIOT_INFO(\"rate limit\");\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xBAD22222);\n\n\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_QUOTA_REACHED) {\n\t\t\t\tIOT_INFO(\"quota reached\");\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xBAD200BE);\n\n\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_SEND_FAILED) {\n\t\t\t\tIOT_INFO(\"send failed seq number : %d\", noti-\u003eraw.send_fail.failed_sequence_num);\n\n\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_JWT_EXPIRED) {\n\t\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t\tif (iot_es_connect(ctx, IOT_CONNECT_TYPE_COMMUNICATION) != IOT_ERROR_NONE)\n                                    IOT_ERROR(\"failed to iot_es_connect for communication\");\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CHANGE_STATE_TIMEOUT:\n\t\t\tstate_data = (struct iot_state_data *)cmd-\u003eparam;\n\t\t\tif (!state_data) {\n\t\t\t\tIOT_ERROR(\"There is no state_data for cmd :%d\", cmd-\u003ecmd_type);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((ctx-\u003ecurr_state == ctx-\u003ereq_state) || (state_data-\u003eiot_state != ctx-\u003ereq_state)) {\n\t\t\t\tIOT_INFO(\"Already iot-stat updated or mis-matched, can't change timeout : %d for %d\",\n\t\t\t\t\tstate_data-\u003eopt, state_data-\u003eiot_state);\n\t\t\t} else {\n\t\t\t\tIOT_INFO(\"We've got timemout changing cmd for %d\", state_data-\u003eiot_state);\n\t\t\t\tIOT_DUMP_MAIN(INFO, BASE, ((state_data-\u003eiot_state \u003c\u003c 8u) | state_data-\u003eopt));\n\t\t\t\t_do_update_timeout(ctx, (unsigned int)state_data-\u003eopt);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_SELF_CLEANUP:\n\t\t\tIOT_WARN(\"self device cleanup\");\n\t\t\tif (cmd-\u003eparam) {\n\t\t\t\treboot = (bool *)cmd-\u003eparam;\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, (int)*reboot);\n\t\t\t} else {\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0);\n\t\t\t}\n\n\t\t\tif (ctx-\u003ees_http_ready) {\n\t\t\t\tctx-\u003ees_http_ready = false;\n\t\t\t\tiot_easysetup_deinit(ctx);\n\t\t\t}\n\n\t\t\tif (ctx-\u003ees_res_created)\n\t\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t\tiot_device_cleanup(ctx);\n\n\t\t\tif (reboot \u0026\u0026 *reboot) {\n\t\t\t\tIOT_REBOOT();\n\t\t\t} else {\n\t\t\t\terr = iot_state_update(ctx, IOT_STATE_UNKNOWN,\n\t\t\t\t\t\tIOT_STATE_OPT_CLEANUP);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_ERROR(\"Unsupported command(%d)\", cmd-\u003ecmd_type);\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tbreak;\n\t}\n\nout_do_cmd:\n\tif (err == IOT_ERROR_NONE || err == IOT_ERROR_DUPLICATED_CMD) {\n\t\t_clear_cmd_status(ctx, cmd-\u003ecmd_type);\n\t} else {\n\t\tIOT_ERROR(\"failed to handle cmd: %d\\n\", cmd-\u003ecmd_type);\n\t\tIOT_DUMP_MAIN_ARG2(ERROR, COMMAND, cmd-\u003ecmd_type, ctx-\u003ecurr_state);\n\t}\n\n\treturn err;\n}","filepath":"src/iot_main.c","line_number":482,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"97127":{"score":0.92807114,"function_name":"_do_cmd_tout_check","code":"static void _do_cmd_tout_check(struct iot_context *ctx)\n{\n\tchar is_expired;\n\tiot_state_t next_state;\n\n\t/* If the iot-core is stayed in IOT_STATE_UNKNOWN,\n\t * we don't need to check timeout \u0026 condition\n\t */\n\tif ((ctx-\u003ecurr_state == IOT_STATE_UNKNOWN) \u0026\u0026\n\t\t\t(ctx-\u003ereq_state == IOT_STATE_UNKNOWN))\n\t\treturn;\n\n\t/* If device comes to connected_state, we don't need timeout checking */\n\tif (ctx-\u003ecurr_state == IOT_STATE_CLOUD_CONNECTED)\n\t\tis_expired = 0;\n\telse\n\t\tis_expired = iot_os_timer_isexpired(ctx-\u003estate_timer);\n\n\tif ((ctx-\u003ecurr_state != ctx-\u003ereq_state) || is_expired) {\n\t\tif (is_expired \u0026\u0026 !ctx-\u003ecmd_err) {\n\t\t\tIOT_WARN(\"New state changing timeout\");\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0x8BADF00D);\n\n\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\tif (iot_state_update(ctx, next_state, ctx-\u003ereq_state)\n\t\t\t\t\t!= IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Failed state error updated (%d/%d)\",\n\t\t\t\t\tctx-\u003ecurr_state, ctx-\u003ereq_state);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, ctx-\u003ereq_state);\n\t\t\t}\n\t\t} else if (!ctx-\u003ecmd_status) {\n\t\t\t/* All command processes are done for req_state */\n\t\t\tif (!ctx-\u003ecmd_err) {\n\t\t\t\tIOT_INFO(\"New state updated for %d\", ctx-\u003ereq_state);\n\t\t\t\tctx-\u003ecurr_state = ctx-\u003ereq_state;\n\n\t\t\t\tif (ctx-\u003estatus_cb)\n\t\t\t\t\t_do_status_report(ctx, ctx-\u003ecurr_state, true);\n\t\t\t} else {\n\t\t\t\t/* Some command makes error, so do not update state */\n\t\t\t\tIOT_ERROR(\"Some cmd(0x%0x) failed for %d state\",\n\t\t\t\t\tctx-\u003ecmd_err, ctx-\u003ereq_state);\n\t\t\t}\n\t\t}\n\t}\n}","filepath":"src/iot_main.c","line_number":1008,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"97588":{"score":0.8975769,"function_name":"_throw_away_all_cmd_queue","code":"static void _throw_away_all_cmd_queue(struct iot_context *ctx)\n{\n\tstruct iot_command cmd;\n\tenum iot_command_type cmd_type;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"There is no ctx!!\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\treturn;\n\t}\n\n\tcmd.param = NULL;\n\twhile (iot_os_queue_receive(ctx-\u003ecmd_queue,\n\t\t\t\t\u0026cmd, 0) == IOT_OS_TRUE) {\n\t\t_clear_cmd_status(ctx, cmd.cmd_type);\n\t\tif (cmd.param) {\n\t\t\tfree(cmd.param);\n\t\t\tcmd.param = NULL;\n\t\t}\n\t}\n\n\tif (ctx-\u003ecmd_status) {\n\t\tIOT_WARN(\"There are unfinished cmds : 0x%x\", ctx-\u003ecmd_status);\n\t\tfor (cmd_type = IOT_COMMAND_READY_TO_CTL;\n\t\t\t\tcmd_type \u003c= IOT_COMMAND_TYPE_MAX; cmd_type++) {\n\t\t\tif (ctx-\u003ecmd_count[cmd_type]) {\n\t\t\t\tIOT_WARN(\"Remained cmd[%d] = %d\", cmd_type,\n\t\t\t\t\tctx-\u003ecmd_count[cmd_type]);\n\t\t\t\tctx-\u003ecmd_count[cmd_type] = 0;\n\t\t\t}\n\t\t}\n\t\tctx-\u003ecmd_status = 0;\n\t}\n}","filepath":"src/iot_main.c","line_number":1055,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"97990":{"score":0.82598823,"function_name":"_iot_main_task","code":"static void _iot_main_task(struct iot_context *ctx)\n{\n\tstruct iot_command cmd;\n\tunsigned char curr_events;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_easysetup_payload easysetup_req;\n#if !defined(STDK_MQTT_TASK)\n\tiot_state_t next_state;\n\tunsigned int task_cycle = IOT_MAIN_TASK_DEFAULT_CYCLE;\n#endif\n\n\tfor( ; ; ) {\n#if defined(STDK_MQTT_TASK)\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_ALL, true, false, 500);\n#else\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_ALL, true, task_cycle);\n#endif\n\t\tif (curr_events \u0026 IOT_EVENT_BIT_COMMAND) {\n\t\t\tcmd.param = NULL;\n\n\t\t\tif (iot_os_mutex_lock(\u0026ctx-\u003eiot_cmd_lock) != IOT_OS_TRUE)\n\t\t\t\tcontinue;\n\n\t\t\tif (iot_os_queue_receive(ctx-\u003ecmd_queue,\n\t\t\t\t\t\u0026cmd, 0) != IOT_OS_FALSE) {\n\n\t\t\t\tIOT_DEBUG(\"cmd: %d\\n\", cmd.cmd_type);\n\n\t\t\t\terr = _do_iot_main_command(ctx, \u0026cmd);\n\t\t\t\tif (cmd.param)\n\t\t\t\t\tfree(cmd.param);\n\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"failed handle cmd (%d): %d\\n\", cmd.cmd_type, err);\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t}\n\n\t\t\t\t/* Set bit again to check whether the several cmds are already\n\t\t\t\t * stacked up in the queue.\n\t\t\t\t */\n\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_COMMAND);\n\t\t\t}\n\t\t\tiot_os_mutex_unlock(\u0026ctx-\u003eiot_cmd_lock);\n\t\t}\n\n\t\tif ((curr_events \u0026 IOT_EVENT_BIT_EASYSETUP_REQ) \u0026\u0026\n\t\t\t\t\t\tctx-\u003eeasysetup_req_queue) {\n\t\t\teasysetup_req.payload = NULL;\n\t\t\teasysetup_req.err = IOT_ERROR_NONE;\n\t\t\tif (iot_os_queue_receive(ctx-\u003eeasysetup_req_queue,\n\t\t\t\t\t\u0026easysetup_req, 0) != IOT_OS_FALSE) {\n\t\t\t\tIOT_DEBUG(\"request step: %d\\n\", easysetup_req.step);\n\n\t\t\t\terr = iot_easysetup_request_handler(ctx, easysetup_req);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"failed handle easysetup request step %d: %d\\n\", easysetup_req.step, err);\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t} else {\n\t\t\t\t\t/* The SDK can't detect mobile's disconnecting after easy-setupcomplete\n\t\t\t\t\t * so to guarantee final msg sending to mobile before disconnecting\n\t\t\t\t\t * add some experiential delay after easy-setupcomplete\n\t\t\t\t\t */\n\t\t\t\t\tif (easysetup_req.step == IOT_EASYSETUP_STEP_SETUPCOMPLETE) {\n\t\t\t\t\t\tiot_os_delay(1000); /* delay for easysetup/httpd */\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Set bit again to check whether the several cmds are already\n\t\t\t\t * stacked up in the queue.\n\t\t\t\t */\n\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_REQ);\n\t\t\t}\n\t\t}\n\n#if !defined(STDK_MQTT_TASK)\n\t\t/* check if there is MQTT packet from GG */\n\t\ttask_cycle = IOT_MAIN_TASK_DEFAULT_CYCLE;\n\t\tif (ctx-\u003ereg_mqttcli) {\n\t\t\tint rc = st_mqtt_yield(ctx-\u003ereg_mqttcli, 0);\n\t\t\tif (rc \u003c 0) {\n\t\t\t\terr = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\t\tif (err == IOT_ERROR_NONE) {\n\t\t\t\t\t/* Quickly try to connect without user notification fist */\n\t\t\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_WARN(\"Report Disconnected..\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_DISCONNECTED;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\n\t\t\t\t\t\tIOT_WARN(\"Try MQTT self re-registering..\\n\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"REG disconnecting failed(%d) for mqtt_yield\", err);\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t}\n\t\t\t} else if (rc \u003e 0) {\n\t\t\t\ttask_cycle = 0;\n\t\t\t}\n\t\t} else if (ctx-\u003eevt_mqttcli) {\n\t\t\tint rc = st_mqtt_yield(ctx-\u003eevt_mqttcli, 0);\n\t\t\tif (rc \u003c 0) {\n\t\t\t\terr = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t\tif (err == IOT_ERROR_NONE) {\n\t\t\t\t\t/* Quickly try to connect without user notification first */\n\t\t\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_WARN(\"Report Disconnected..\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_DISCONNECTED;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\n\t\t\t\t\t\tIOT_WARN(\"Try MQTT self re-connecting..\\n\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"COMM disconnecting failed(%d) for mqtt_yield\", err);\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t}\n\t\t\t} else if (rc \u003e 0) {\n\t\t\t\ttask_cycle = 0;\n\t\t\t}\n\t\t}\n#endif\n\t\t_do_cmd_tout_check(ctx);\n\t}\n}","filepath":"src/iot_main.c","line_number":1090,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"99145":{"score":0.8025553,"function_name":"st_conn_init","code":"IOT_CTX* st_conn_init(unsigned char *onboarding_config, unsigned int onboarding_config_len,\n\t\t\t\t\tunsigned char *device_info, unsigned int device_info_len)\n{\n\tstruct iot_context *ctx = NULL;\n\tiot_error_t iot_err;\n\tstruct iot_devconf_prov_data *devconf_prov;\n\tstruct iot_device_info *dev_info;\n\n\tif (!onboarding_config || !device_info) {\n\t\tIOT_ERROR(\"invalid parameters\\n\");\n\t\treturn NULL;\n\t}\n\n\tctx = iot_os_malloc(sizeof(struct iot_context));\n\tif (!ctx) {\n\t\tIOT_ERROR(\"failed to malloc for iot_context\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* Initialize all values */\n\tmemset(ctx, 0, sizeof(struct iot_context));\n\n\tiot_err = iot_os_timer_init(\u0026ctx-\u003estate_timer);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to malloc for state_timer\\n\");\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\n\tiot_err = iot_os_timer_init(\u0026ctx-\u003erate_limit_timeout);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to malloc for rate_limit_timeout\\n\");\n\t\tiot_os_timer_destroy(\u0026ctx-\u003estate_timer);\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\n\t// Initialize device nv section\n\tiot_err = iot_nv_init(device_info, device_info_len);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"NV init fail\");\n\t\tgoto error_main_bsp_init;\n\t}\n\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE)\n\t/* Initialize logging task */\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE_RAM_ONLY)\n\tiot_err = iot_log_file_init(RAM_ONLY);\n#elif defined(CONFIG_STDK_IOT_CORE_LOG_FILE_FLASH_WITH_RAM)\n\tiot_err = iot_log_file_init(FLASH_WITH_RAM);\n#else\n#error \"Need to choice STDK_IOT_CORE_LOG_FILE_TYPE first\"\n#endif\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"log file init fail\");\n\t\tgoto error_main_log_file_init;\n\t}\n#endif\n\n\t// Initialize device profile \u0026 device info\n\tdevconf_prov = \u0026(ctx-\u003edevconf);\n\tiot_err = iot_api_onboarding_config_load(onboarding_config, onboarding_config_len, devconf_prov);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed loading onboarding profile (%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tgoto error_main_load_onboarding_config;\n\t}\n\n\tdev_info = \u0026(ctx-\u003edevice_info);\n\tiot_err = iot_api_device_info_load(device_info, device_info_len, dev_info);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed loading device info (%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tgoto error_main_load_device_info;\n\t}\n\n    // Initialize Wi-Fi\n    iot_err = iot_bsp_wifi_init();\n    if (iot_err != IOT_ERROR_NONE) {\n        IOT_ERROR(\"failed to init iot_bsp_wifi_init (%d)\", iot_err);\n        IOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\n        iot_api_device_info_mem_free(dev_info);\n        goto error_main_load_device_info;\n    }\n\n\t/* create queue */\n\tctx-\u003ecmd_queue = iot_os_queue_create(IOT_QUEUE_LENGTH,\n\t\t\tsizeof(struct iot_command));\n\n\tif (!ctx-\u003ecmd_queue) {\n\t\tIOT_ERROR(\"failed to create Queue for iot core task\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, IOT_QUEUE_LENGTH);\n\t\tgoto error_main_init_cmd_q;\n\t}\n\n\t/* create msg queue for IOT_STATE */\n\tctx-\u003eusr_events = iot_os_eventgroup_create();\n\tif (!ctx-\u003eusr_events) {\n\t\tIOT_ERROR(\"failed to create EventGroup for usr_events\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_init_usr_evts;\n\t}\n\n\t/* create msg eventgroup for each queue handling */\n\tctx-\u003eiot_events = iot_os_eventgroup_create();\n\tif (!ctx-\u003eiot_events) {\n\t\tIOT_ERROR(\"failed to create EventGroup for iot_task\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_init_events;\n\t}\n\n\tctx-\u003eiot_reg_data.new_reged = false;\n\tctx-\u003ecurr_state = ctx-\u003ereq_state = IOT_STATE_UNKNOWN;\n\n\t/* create mutex for iot-core's command handling */\n\tif (iot_os_mutex_init(\u0026ctx-\u003eiot_cmd_lock) != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"failed to init iot_cmd_lock\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_cmd_mutex_init;\n\t}\n\n\t/* create mutex for user level st_conn_xxx APIs */\n\tif (iot_os_mutex_init(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"failed to init st_conn_lock\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_conn_mutex_init;\n\t}\n\n\t/* create task */\n\tif (iot_os_thread_create(_iot_main_task, IOT_TASK_NAME,\n\t\t\tIOT_TASK_STACK_SIZE, (void *)ctx, IOT_TASK_PRIORITY,\n\t\t\t\u0026ctx-\u003emain_thread) != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"failed to create iot_task\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, IOT_TASK_STACK_SIZE);\n\t\tgoto error_main_task_init;\n\t}\n\n\tIOT_MEM_CHECK(\"MAIN_INIT_ALL_DONE \u003e\u003ePT\u003c\u003c\");\n\n#ifdef VER_EXTRA_STR\n\tIOT_INFO(\"stdk_version : %d.%d.%d-%s\",\n\t\tVER_MAJOR, VER_MINOR, VER_PATCH, VER_EXTRA_STR);\n#else\n\tIOT_INFO(\"stdk_version : %s\", STDK_VERSION_STRING);\n#endif\n\n\tIOT_DUMP_MAIN(INFO, BASE, STDK_VERSION_CODE);\n\n\treturn (IOT_CTX*)ctx;\n\nerror_main_task_init:\n\tiot_os_mutex_destroy(\u0026ctx-\u003est_conn_lock);\n\nerror_main_conn_mutex_init:\n\tiot_os_mutex_destroy(\u0026ctx-\u003eiot_cmd_lock);\n\nerror_main_cmd_mutex_init:\n\tiot_os_eventgroup_delete(ctx-\u003eiot_events);\n\nerror_main_init_events:\n\tiot_os_eventgroup_delete(ctx-\u003eusr_events);\n\nerror_main_init_usr_evts:\n\tiot_os_queue_delete(ctx-\u003ecmd_queue);\n\nerror_main_init_cmd_q:\n\tiot_api_device_info_mem_free(dev_info);\n\nerror_main_load_device_info:\n\tiot_api_onboarding_config_mem_free(devconf_prov);\n\nerror_main_load_onboarding_config:\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE)\n\tiot_log_file_exit();\n\nerror_main_log_file_init:\n#endif\n\tiot_nv_deinit();\n\nerror_main_bsp_init:\n\tiot_os_timer_destroy(\u0026ctx-\u003erate_limit_timeout);\n\tiot_os_timer_destroy(\u0026ctx-\u003estate_timer);\n\tfree(ctx);\n\n\treturn NULL;\n}","filepath":"src/iot_main.c","line_number":1225,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"}}}