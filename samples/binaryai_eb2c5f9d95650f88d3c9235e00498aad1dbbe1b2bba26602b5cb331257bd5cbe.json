{"file_sha256":"eb2c5f9d95650f88d3c9235e00498aad1dbbe1b2bba26602b5cb331257bd5cbe","base_addr":1048576,"functions":{"1635664":{"score":0.5540781,"function_name":"fallbackSimpleSort","code":"static \n__inline__\nvoid fallbackSimpleSort ( UInt32* fmap, \n                          UInt32* eclass, \n                          Int32   lo, \n                          Int32   hi )\n{\n   Int32 i, j, tmp;\n   UInt32 ec_tmp;\n\n   if (lo == hi) return;\n\n   if (hi - lo \u003e 3) {\n      for ( i = hi-4; i \u003e= lo; i-- ) {\n         tmp = fmap[i];\n         ec_tmp = eclass[tmp];\n         for ( j = i+4; j \u003c= hi \u0026\u0026 ec_tmp \u003e eclass[fmap[j]]; j += 4 )\n            fmap[j-4] = fmap[j];\n         fmap[j-4] = tmp;\n      }\n   }\n\n   for ( i = hi-1; i \u003e= lo; i-- ) {\n      tmp = fmap[i];\n      ec_tmp = eclass[tmp];\n      for ( j = i+1; j \u003c= hi \u0026\u0026 ec_tmp \u003e eclass[fmap[j]]; j++ )\n         fmap[j-1] = fmap[j];\n      fmap[j-1] = tmp;\n   }\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":2050,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1669712":{"score":0.6406781,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzBuffToBuffDecompress) \n                           ( char*         dest, \n                             unsigned int* destLen,\n                             char*         source, \n                             unsigned int  sourceLen,\n                             int           small,\n                             int           verbosity )\n{\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL || destLen == NULL || \n       source == NULL ||\n       (small != 0 \u0026\u0026 small != 1) ||\n       verbosity \u003c 0 || verbosity \u003e 4) \n          return BZ_PARAM_ERROR;\n\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzDecompressInit ( \u0026strm, verbosity, small );\n   if (ret != BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzDecompress ( \u0026strm );\n   if (ret == BZ_OK) goto output_overflow_or_eof;\n   if (ret != BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;\n   BZ2_bzDecompressEnd ( \u0026strm );\n   return BZ_OK;\n\n   output_overflow_or_eof:\n   if (strm.avail_out \u003e 0) {\n      BZ2_bzDecompressEnd ( \u0026strm );\n      return BZ_UNEXPECTED_EOF;\n   } else {\n      BZ2_bzDecompressEnd ( \u0026strm );\n      return BZ_OUTBUFF_FULL;\n   };      \n\n   errhandler:\n   BZ2_bzDecompressEnd ( \u0026strm );\n   return ret; \n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5632,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1681888":{"score":0.8708279,"function_name":"fallbackSort","code":"static\nvoid fallbackSort ( UInt32* fmap, \n                    UInt32* eclass, \n                    UInt32* bhtab,\n                    Int32   nblock,\n                    Int32   verb )\n{\n   Int32 ftab[257];\n   Int32 ftabCopy[256];\n   Int32 H, i, j, k, l, r, cc, cc1;\n   Int32 nNotDone;\n   Int32 nBhtab;\n   UChar* eclass8 = (UChar*)eclass;\n\n   /*--\n      Initial 1-char radix sort to generate\n      initial fmap and initial BH bits.\n   --*/\n   if (verb \u003e= 4)\n      VPrintf0 ( \"        bucket sorting ...\\n\" );\n   for (i = 0; i \u003c 257;    i++) ftab[i] = 0;\n   for (i = 0; i \u003c nblock; i++) ftab[eclass8[i]]++;\n   for (i = 0; i \u003c 256;    i++) ftabCopy[i] = ftab[i];\n   for (i = 1; i \u003c 257;    i++) ftab[i] += ftab[i-1];\n\n   for (i = 0; i \u003c nblock; i++) {\n      j = eclass8[i];\n      k = ftab[j] - 1;\n      ftab[j] = k;\n      fmap[k] = i;\n   }\n\n   nBhtab = 2 + (nblock / 32);\n   for (i = 0; i \u003c nBhtab; i++) bhtab[i] = 0;\n   for (i = 0; i \u003c 256; i++) SET_BH(ftab[i]);\n\n   /*--\n      Inductively refine the buckets.  Kind-of an\n      \"exponential radix sort\" (!), inspired by the\n      Manber-Myers suffix array construction algorithm.\n   --*/\n\n   /*-- set sentinel bits for block-end detection --*/\n   for (i = 0; i \u003c 32; i++) { \n      SET_BH(nblock + 2*i);\n      CLEAR_BH(nblock + 2*i + 1);\n   }\n\n   /*-- the log(N) loop --*/\n   H = 1;\n   while (1) {\n\n      if (verb \u003e= 4) \n         VPrintf1 ( \"        depth %6d has \", H );\n\n      j = 0;\n      for (i = 0; i \u003c nblock; i++) {\n         if (ISSET_BH(i)) j = i;\n         k = fmap[i] - H; if (k \u003c 0) k += nblock;\n         eclass[k] = j;\n      }\n\n      nNotDone = 0;\n      r = -1;\n      while (1) {\n\n\t /*-- find the next non-singleton bucket --*/\n         k = r + 1;\n         while (ISSET_BH(k) \u0026\u0026 UNALIGNED_BH(k)) k++;\n         if (ISSET_BH(k)) {\n            while (WORD_BH(k) == 0xffffffff) k += 32;\n            while (ISSET_BH(k)) k++;\n         }\n         l = k - 1;\n         if (l \u003e= nblock) break;\n         while (!ISSET_BH(k) \u0026\u0026 UNALIGNED_BH(k)) k++;\n         if (!ISSET_BH(k)) {\n            while (WORD_BH(k) == 0x00000000) k += 32;\n            while (!ISSET_BH(k)) k++;\n         }\n         r = k - 1;\n         if (r \u003e= nblock) break;\n\n         /*-- now [l, r] bracket current bucket --*/\n         if (r \u003e l) {\n            nNotDone += (r - l + 1);\n            fallbackQSort3 ( fmap, eclass, l, r );\n\n            /*-- scan bucket and generate header bits-- */\n            cc = -1;\n            for (i = l; i \u003c= r; i++) {\n               cc1 = eclass[fmap[i]];\n               if (cc != cc1) { SET_BH(i); cc = cc1; };\n            }\n         }\n      }\n\n      if (verb \u003e= 4) \n         VPrintf1 ( \"%6d unresolved strings\\n\", nNotDone );\n\n      H *= 2;\n      if (H \u003e nblock || nNotDone == 0) break;\n   }\n\n   /*-- \n      Reconstruct the original block in\n      eclass8 [0 .. nblock-1], since the\n      previous phase destroyed it.\n   --*/\n   if (verb \u003e= 4)\n      VPrintf0 ( \"        reconstructing block ...\\n\" );\n   j = 0;\n   for (i = 0; i \u003c nblock; i++) {\n      while (ftabCopy[j] == 0) j++;\n      ftabCopy[j]--;\n      eclass8[fmap[i]] = (UChar)j;\n   }\n   AssertH ( j \u003c 256, 1005 );\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":2231,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1684896":{"score":0.94656384,"function_name":"mainSort","code":"static\nvoid mainSort ( UInt32* ptr, \n                UChar*  block,\n                UInt16* quadrant, \n                UInt32* ftab,\n                Int32   nblock,\n                Int32   verb,\n                Int32*  budget )\n{\n   Int32  i, j, k, ss, sb;\n   Int32  runningOrder[256];\n   Bool   bigDone[256];\n   Int32  copyStart[256];\n   Int32  copyEnd  [256];\n   UChar  c1;\n   Int32  numQSorted;\n   UInt16 s;\n   if (verb \u003e= 4) VPrintf0 ( \"        main sort initialise ...\\n\" );\n\n   /*-- set up the 2-byte frequency table --*/\n   for (i = 65536; i \u003e= 0; i--) ftab[i] = 0;\n\n   j = block[0] \u003c\u003c 8;\n   i = nblock-1;\n   for (; i \u003e= 3; i -= 4) {\n      quadrant[i] = 0;\n      j = (j \u003e\u003e 8) | ( ((UInt16)block[i]) \u003c\u003c 8);\n      ftab[j]++;\n      quadrant[i-1] = 0;\n      j = (j \u003e\u003e 8) | ( ((UInt16)block[i-1]) \u003c\u003c 8);\n      ftab[j]++;\n      quadrant[i-2] = 0;\n      j = (j \u003e\u003e 8) | ( ((UInt16)block[i-2]) \u003c\u003c 8);\n      ftab[j]++;\n      quadrant[i-3] = 0;\n      j = (j \u003e\u003e 8) | ( ((UInt16)block[i-3]) \u003c\u003c 8);\n      ftab[j]++;\n   }\n   for (; i \u003e= 0; i--) {\n      quadrant[i] = 0;\n      j = (j \u003e\u003e 8) | ( ((UInt16)block[i]) \u003c\u003c 8);\n      ftab[j]++;\n   }\n\n   /*-- (emphasises close relationship of block \u0026 quadrant) --*/\n   for (i = 0; i \u003c BZ_N_OVERSHOOT; i++) {\n      block   [nblock+i] = block[i];\n      quadrant[nblock+i] = 0;\n   }\n\n   if (verb \u003e= 4) VPrintf0 ( \"        bucket sorting ...\\n\" );\n\n   /*-- Complete the initial radix sort --*/\n   for (i = 1; i \u003c= 65536; i++) ftab[i] += ftab[i-1];\n\n   s = block[0] \u003c\u003c 8;\n   i = nblock-1;\n   for (; i \u003e= 3; i -= 4) {\n      s = (s \u003e\u003e 8) | (block[i] \u003c\u003c 8);\n      j = ftab[s] -1;\n      ftab[s] = j;\n      ptr[j] = i;\n      s = (s \u003e\u003e 8) | (block[i-1] \u003c\u003c 8);\n      j = ftab[s] -1;\n      ftab[s] = j;\n      ptr[j] = i-1;\n      s = (s \u003e\u003e 8) | (block[i-2] \u003c\u003c 8);\n      j = ftab[s] -1;\n      ftab[s] = j;\n      ptr[j] = i-2;\n      s = (s \u003e\u003e 8) | (block[i-3] \u003c\u003c 8);\n      j = ftab[s] -1;\n      ftab[s] = j;\n      ptr[j] = i-3;\n   }\n   for (; i \u003e= 0; i--) {\n      s = (s \u003e\u003e 8) | (block[i] \u003c\u003c 8);\n      j = ftab[s] -1;\n      ftab[s] = j;\n      ptr[j] = i;\n   }\n\n   /*--\n      Now ftab contains the first loc of every small bucket.\n      Calculate the running order, from smallest to largest\n      big bucket.\n   --*/\n   for (i = 0; i \u003c= 255; i++) {\n      bigDone     [i] = False;\n      runningOrder[i] = i;\n   }\n\n   {\n      Int32 vv;\n      Int32 h = 1;\n      do h = 3 * h + 1; while (h \u003c= 256);\n      do {\n         h = h / 3;\n         for (i = h; i \u003c= 255; i++) {\n            vv = runningOrder[i];\n            j = i;\n            while ( BIGFREQ(runningOrder[j-h]) \u003e BIGFREQ(vv) ) {\n               runningOrder[j] = runningOrder[j-h];\n               j = j - h;\n               if (j \u003c= (h - 1)) goto zero;\n            }\n            zero:\n            runningOrder[j] = vv;\n         }\n      } while (h != 1);\n   }\n\n   /*--\n      The main sorting loop.\n   --*/\n\n   numQSorted = 0;\n\n   for (i = 0; i \u003c= 255; i++) {\n\n      /*--\n         Process big buckets, starting with the least full.\n         Basically this is a 3-step process in which we call\n         mainQSort3 to sort the small buckets [ss, j], but\n         also make a big effort to avoid the calls if we can.\n      --*/\n      ss = runningOrder[i];\n\n      /*--\n         Step 1:\n         Complete the big bucket [ss] by quicksorting\n         any unsorted small buckets [ss, j], for j != ss.  \n         Hopefully previous pointer-scanning phases have already\n         completed many of the small buckets [ss, j], so\n         we don't have to sort them at all.\n      --*/\n      for (j = 0; j \u003c= 255; j++) {\n         if (j != ss) {\n            sb = (ss \u003c\u003c 8) + j;\n            if ( ! (ftab[sb] \u0026 SETMASK) ) {\n               Int32 lo = ftab[sb]   \u0026 CLEARMASK;\n               Int32 hi = (ftab[sb+1] \u0026 CLEARMASK) - 1;\n               if (hi \u003e lo) {\n                  if (verb \u003e= 4)\n                     VPrintf4 ( \"        qsort [0x%x, 0x%x]   \"\n                                \"done %d   this %d\\n\",\n                                ss, j, numQSorted, hi - lo + 1 );\n                  mainQSort3 ( \n                     ptr, block, quadrant, nblock, \n                     lo, hi, BZ_N_RADIX, budget \n                  );   \n                  numQSorted += (hi - lo + 1);\n                  if (*budget \u003c 0) return;\n               }\n            }\n            ftab[sb] |= SETMASK;\n         }\n      }\n\n      AssertH ( !bigDone[ss], 1006 );\n\n      /*--\n         Step 2:\n         Now scan this big bucket [ss] so as to synthesise the\n         sorted order for small buckets [t, ss] for all t,\n         including, magically, the bucket [ss,ss] too.\n         This will avoid doing Real Work in subsequent Step 1's.\n      --*/\n      {\n         for (j = 0; j \u003c= 255; j++) {\n            copyStart[j] =  ftab[(j \u003c\u003c 8) + ss]     \u0026 CLEARMASK;\n            copyEnd  [j] = (ftab[(j \u003c\u003c 8) + ss + 1] \u0026 CLEARMASK) - 1;\n         }\n         for (j = ftab[ss \u003c\u003c 8] \u0026 CLEARMASK; j \u003c copyStart[ss]; j++) {\n            k = ptr[j]-1; if (k \u003c 0) k += nblock;\n            c1 = block[k];\n            if (!bigDone[c1])\n               ptr[ copyStart[c1]++ ] = k;\n         }\n         for (j = (ftab[(ss+1) \u003c\u003c 8] \u0026 CLEARMASK) - 1; j \u003e copyEnd[ss]; j--) {\n            k = ptr[j]-1; if (k \u003c 0) k += nblock;\n            c1 = block[k];\n            if (!bigDone[c1]) \n               ptr[ copyEnd[c1]-- ] = k;\n         }\n      }\n\n      AssertH ( (copyStart[ss]-1 == copyEnd[ss])\n                || \n                /* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.\n                   Necessity for this case is demonstrated by compressing \n                   a sequence of approximately 48.5 million of character \n                   251; 1.0.0/1.0.1 will then die here. */\n                (copyStart[ss] == 0 \u0026\u0026 copyEnd[ss] == nblock-1),\n                1007 )\n\n      for (j = 0; j \u003c= 255; j++) ftab[(j \u003c\u003c 8) + ss] |= SETMASK;\n\n      /*--\n         Step 3:\n         The [ss] big bucket is now done.  Record this fact,\n         and update the quadrant descriptors.  Remember to\n         update quadrants in the overshoot area too, if\n         necessary.  The \"if (i \u003c 255)\" test merely skips\n         this updating for the last bucket processed, since\n         updating for the last bucket is pointless.\n\n         The quadrant array provides a way to incrementally\n         cache sort orderings, as they appear, so as to \n         make subsequent comparisons in fullGtU() complete\n         faster.  For repetitive blocks this makes a big\n         difference (but not big enough to be able to avoid\n         the fallback sorting mechanism, exponential radix sort).\n\n         The precise meaning is: at all times:\n\n            for 0 \u003c= i \u003c nblock and 0 \u003c= j \u003c= nblock\n\n            if block[i] != block[j], \n\n               then the relative values of quadrant[i] and \n                    quadrant[j] are meaningless.\n\n               else {\n                  if quadrant[i] \u003c quadrant[j]\n                     then the string starting at i lexicographically\n                     precedes the string starting at j\n\n                  else if quadrant[i] \u003e quadrant[j]\n                     then the string starting at j lexicographically\n                     precedes the string starting at i\n\n                  else\n                     the relative ordering of the strings starting\n                     at i and j has not yet been determined.\n               }\n      --*/\n      bigDone[ss] = True;\n\n      if (i \u003c 255) {\n         Int32 bbStart  = ftab[ss \u003c\u003c 8] \u0026 CLEARMASK;\n         Int32 bbSize   = (ftab[(ss+1) \u003c\u003c 8] \u0026 CLEARMASK) - bbStart;\n         Int32 shifts   = 0;\n\n         while ((bbSize \u003e\u003e shifts) \u003e 65534) shifts++;\n\n         for (j = bbSize-1; j \u003e= 0; j--) {\n            Int32 a2update     = ptr[bbStart + j];\n            UInt16 qVal        = (UInt16)(j \u003e\u003e shifts);\n            quadrant[a2update] = qVal;\n            if (a2update \u003c BZ_N_OVERSHOOT)\n               quadrant[a2update + nblock] = qVal;\n         }\n         AssertH ( ((bbSize-1) \u003e\u003e shifts) \u003c= 65535, 1002 );\n      }\n\n   }\n\n   if (verb \u003e= 4)\n      VPrintf3 ( \"        %d pointers, %d sorted, %d scanned\\n\",\n                 nblock, numQSorted, nblock - numQSorted );\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":2770,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1692912":{"score":0.86603975,"function_name":"BZ2_hbMakeCodeLengths","code":"void BZ2_hbMakeCodeLengths ( UChar *len, \n                             Int32 *freq,\n                             Int32 alphaSize,\n                             Int32 maxLen )\n{\n   /*--\n      Nodes and heap entries run from 1.  Entry 0\n      for both the heap and nodes is a sentinel.\n   --*/\n   Int32 nNodes, nHeap, n1, n2, i, j, k;\n   Bool  tooLong;\n\n   Int32 heap   [ BZ_MAX_ALPHA_SIZE + 2 ];\n   Int32 weight [ BZ_MAX_ALPHA_SIZE * 2 ];\n   Int32 parent [ BZ_MAX_ALPHA_SIZE * 2 ]; \n\n   for (i = 0; i \u003c alphaSize; i++)\n      weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) \u003c\u003c 8;\n\n   while (True) {\n\n      nNodes = alphaSize;\n      nHeap = 0;\n\n      heap[0] = 0;\n      weight[0] = 0;\n      parent[0] = -2;\n\n      for (i = 1; i \u003c= alphaSize; i++) {\n         parent[i] = -1;\n         nHeap++;\n         heap[nHeap] = i;\n         UPHEAP(nHeap);\n      }\n\n      AssertH( nHeap \u003c (BZ_MAX_ALPHA_SIZE+2), 2001 );\n   \n      while (nHeap \u003e 1) {\n         n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);\n         n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);\n         nNodes++;\n         parent[n1] = parent[n2] = nNodes;\n         weight[nNodes] = ADDWEIGHTS(weight[n1], weight[n2]);\n         parent[nNodes] = -1;\n         nHeap++;\n         heap[nHeap] = nNodes;\n         UPHEAP(nHeap);\n      }\n\n      AssertH( nNodes \u003c (BZ_MAX_ALPHA_SIZE * 2), 2002 );\n\n      tooLong = False;\n      for (i = 1; i \u003c= alphaSize; i++) {\n         j = 0;\n         k = i;\n         while (parent[k] \u003e= 0) { k = parent[k]; j++; }\n         len[i-1] = j;\n         if (j \u003e maxLen) tooLong = True;\n      }\n      \n      if (! tooLong) break;\n\n      /* 17 Oct 04: keep-going condition for the following loop used\n         to be 'i \u003c alphaSize', which missed the last element,\n         theoretically leading to the possibility of the compressor\n         looping.  However, this count-scaling step is only needed if\n         one of the generated Huffman code words is longer than\n         maxLen, which up to and including version 1.0.2 was 20 bits,\n         which is extremely unlikely.  In version 1.0.3 maxLen was\n         changed to 17 bits, which has minimal effect on compression\n         ratio, but does mean this scaling step is used from time to\n         time, enough to verify that it works.\n\n         This means that bzip2-1.0.3 and later will only produce\n         Huffman codes with a maximum length of 17 bits.  However, in\n         order to preserve backwards compatibility with bitstreams\n         produced by versions pre-1.0.3, the decompressor must still\n         handle lengths of up to 20. */\n\n      for (i = 1; i \u003c= alphaSize; i++) {\n         j = weight[i] \u003e\u003e 8;\n         j = 1 + (j / 2);\n         weight[i] = j \u003c\u003c 8;\n      }\n   }\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":3216,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1694544":{"score":0.88352627,"function_name":"BZ2_hbAssignCodes","code":"void BZ2_hbAssignCodes ( Int32 *code,\n                         UChar *length,\n                         Int32 minLen,\n                         Int32 maxLen,\n                         Int32 alphaSize )\n{\n   Int32 n, vec, i;\n\n   vec = 0;\n   for (n = minLen; n \u003c= maxLen; n++) {\n      for (i = 0; i \u003c alphaSize; i++)\n         if (length[i] == n) { code[i] = vec; vec++; };\n      vec \u003c\u003c= 1;\n   }\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":3305,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1694624":{"score":0.8942158,"function_name":"BZ2_hbCreateDecodeTables","code":"void BZ2_hbCreateDecodeTables ( Int32 *limit,\n                                Int32 *base,\n                                Int32 *perm,\n                                UChar *length,\n                                Int32 minLen,\n                                Int32 maxLen,\n                                Int32 alphaSize )\n{\n   Int32 pp, i, j, vec;\n\n   pp = 0;\n   for (i = minLen; i \u003c= maxLen; i++)\n      for (j = 0; j \u003c alphaSize; j++)\n         if (length[j] == i) { perm[pp] = j; pp++; };\n\n   for (i = 0; i \u003c BZ_MAX_CODE_LEN; i++) base[i] = 0;\n   for (i = 0; i \u003c alphaSize; i++) base[length[i]+1]++;\n\n   for (i = 1; i \u003c BZ_MAX_CODE_LEN; i++) base[i] += base[i-1];\n\n   for (i = 0; i \u003c BZ_MAX_CODE_LEN; i++) limit[i] = 0;\n   vec = 0;\n\n   for (i = minLen; i \u003c= maxLen; i++) {\n      vec += (base[i+1] - base[i]);\n      limit[i] = vec-1;\n      vec \u003c\u003c= 1;\n   }\n   for (i = minLen + 1; i \u003c= maxLen; i++)\n      base[i] = ((limit[i-1] + 1) \u003c\u003c 1) - base[i];\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":3323,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1695296":{"score":0.8178808,"function_name":"bsPutUInt32","code":"static\nvoid bsPutUInt32 ( EState* s, UInt32 u )\n{\n   bsW ( s, 8, (u \u003e\u003e 24) \u0026 0xffL );\n   bsW ( s, 8, (u \u003e\u003e 16) \u0026 0xffL );\n   bsW ( s, 8, (u \u003e\u003e  8) \u0026 0xffL );\n   bsW ( s, 8,  u        \u0026 0xffL );\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":3483,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1743536":{"score":0.85985965,"function_name":"add_pair_to_block","code":"static\nvoid add_pair_to_block ( EState* s )\n{\n   Int32 i;\n   UChar ch = (UChar)(s-\u003estate_in_ch);\n   for (i = 0; i \u003c s-\u003estate_in_len; i++) {\n      BZ_UPDATE_CRC( s-\u003eblockCRC, ch );\n   }\n   s-\u003einUse[s-\u003estate_in_ch] = True;\n   switch (s-\u003estate_in_len) {\n      case 1:\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         break;\n      case 2:\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         break;\n      case 3:\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         break;\n      default:\n         s-\u003einUse[s-\u003estate_in_len-4] = True;\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         s-\u003eblock[s-\u003enblock] = (UChar)ch; s-\u003enblock++;\n         s-\u003eblock[s-\u003enblock] = ((UChar)(s-\u003estate_in_len-4));\n         s-\u003enblock++;\n         break;\n   }\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":4564,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1743920":{"score":0.67957187,"function_name":"handle_compress","code":"static\nBool handle_compress ( bz_stream* strm )\n{\n   Bool progress_in  = False;\n   Bool progress_out = False;\n   EState* s = strm-\u003estate;\n   \n   while (True) {\n\n      if (s-\u003estate == BZ_S_OUTPUT) {\n         progress_out |= copy_output_until_stop ( s );\n         if (s-\u003estate_out_pos \u003c s-\u003enumZ) break;\n         if (s-\u003emode == BZ_M_FINISHING \u0026\u0026 \n             s-\u003eavail_in_expect == 0 \u0026\u0026\n             isempty_RL(s)) break;\n         prepare_new_block ( s );\n         s-\u003estate = BZ_S_INPUT;\n         if (s-\u003emode == BZ_M_FLUSHING \u0026\u0026 \n             s-\u003eavail_in_expect == 0 \u0026\u0026\n             isempty_RL(s)) break;\n      }\n\n      if (s-\u003estate == BZ_S_INPUT) {\n         progress_in |= copy_input_until_stop ( s );\n         if (s-\u003emode != BZ_M_RUNNING \u0026\u0026 s-\u003eavail_in_expect == 0) {\n            flush_RL ( s );\n            BZ2_compressBlock ( s, (Bool)(s-\u003emode == BZ_M_FINISHING) );\n            s-\u003estate = BZ_S_OUTPUT;\n         }\n         else\n         if (s-\u003enblock \u003e= s-\u003enblockMAX) {\n            BZ2_compressBlock ( s, False );\n            s-\u003estate = BZ_S_OUTPUT;\n         }\n         else\n         if (s-\u003estrm-\u003eavail_in == 0) {\n            break;\n         }\n      }\n\n   }\n\n   return progress_in || progress_out;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":4709,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1745280":{"score":0.8423082,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzCompressInit) \n                    ( bz_stream* strm, \n                     int        blockSize100k,\n                     int        verbosity,\n                     int        workFactor )\n{\n   Int32   n;\n   EState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL || \n       blockSize100k \u003c 1 || blockSize100k \u003e 9 ||\n       workFactor \u003c 0 || workFactor \u003e 250)\n     return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   if (strm-\u003ebzalloc == NULL) strm-\u003ebzalloc = default_bzalloc;\n   if (strm-\u003ebzfree == NULL) strm-\u003ebzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(EState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s-\u003estrm = strm;\n\n   s-\u003earr1 = NULL;\n   s-\u003earr2 = NULL;\n   s-\u003eftab = NULL;\n\n   n       = 100000 * blockSize100k;\n   s-\u003earr1 = BZALLOC( n                  * sizeof(UInt32) );\n   s-\u003earr2 = BZALLOC( (n+BZ_N_OVERSHOOT) * sizeof(UInt32) );\n   s-\u003eftab = BZALLOC( 65537              * sizeof(UInt32) );\n\n   if (s-\u003earr1 == NULL || s-\u003earr2 == NULL || s-\u003eftab == NULL) {\n      if (s-\u003earr1 != NULL) BZFREE(s-\u003earr1);\n      if (s-\u003earr2 != NULL) BZFREE(s-\u003earr2);\n      if (s-\u003eftab != NULL) BZFREE(s-\u003eftab);\n      if (s       != NULL) BZFREE(s);\n      return BZ_MEM_ERROR;\n   }\n\n   s-\u003eblockNo           = 0;\n   s-\u003estate             = BZ_S_INPUT;\n   s-\u003emode              = BZ_M_RUNNING;\n   s-\u003ecombinedCRC       = 0;\n   s-\u003eblockSize100k     = blockSize100k;\n   s-\u003enblockMAX         = 100000 * blockSize100k - 19;\n   s-\u003everbosity         = verbosity;\n   s-\u003eworkFactor        = workFactor;\n\n   s-\u003eblock             = (UChar*)s-\u003earr2;\n   s-\u003emtfv              = (UInt16*)s-\u003earr1;\n   s-\u003ezbits             = NULL;\n   s-\u003eptr               = (UInt32*)s-\u003earr1;\n\n   strm-\u003estate          = s;\n   strm-\u003etotal_in_lo32  = 0;\n   strm-\u003etotal_in_hi32  = 0;\n   strm-\u003etotal_out_lo32 = 0;\n   strm-\u003etotal_out_hi32 = 0;\n   init_RL ( s );\n   prepare_new_block ( s );\n   return BZ_OK;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":4497,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1745856":{"score":0.88056594,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )\n{\n   Bool progress;\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm-\u003estate;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s-\u003estrm != strm) return BZ_PARAM_ERROR;\n\n   preswitch:\n   switch (s-\u003emode) {\n\n      case BZ_M_IDLE:\n         return BZ_SEQUENCE_ERROR;\n\n      case BZ_M_RUNNING:\n         if (action == BZ_RUN) {\n            progress = handle_compress ( strm );\n            return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;\n         } \n         else\n\t if (action == BZ_FLUSH) {\n            s-\u003eavail_in_expect = strm-\u003eavail_in;\n            s-\u003emode = BZ_M_FLUSHING;\n            goto preswitch;\n         }\n         else\n         if (action == BZ_FINISH) {\n            s-\u003eavail_in_expect = strm-\u003eavail_in;\n            s-\u003emode = BZ_M_FINISHING;\n            goto preswitch;\n         }\n         else \n            return BZ_PARAM_ERROR;\n\n      case BZ_M_FLUSHING:\n         if (action != BZ_FLUSH) return BZ_SEQUENCE_ERROR;\n         if (s-\u003eavail_in_expect != s-\u003estrm-\u003eavail_in) \n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (s-\u003eavail_in_expect \u003e 0 || !isempty_RL(s) ||\n             s-\u003estate_out_pos \u003c s-\u003enumZ) return BZ_FLUSH_OK;\n         s-\u003emode = BZ_M_RUNNING;\n         return BZ_RUN_OK;\n\n      case BZ_M_FINISHING:\n         if (action != BZ_FINISH) return BZ_SEQUENCE_ERROR;\n         if (s-\u003eavail_in_expect != s-\u003estrm-\u003eavail_in) \n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (!progress) return BZ_SEQUENCE_ERROR;\n         if (s-\u003eavail_in_expect \u003e 0 || !isempty_RL(s) ||\n             s-\u003estate_out_pos \u003c s-\u003enumZ) return BZ_FINISH_OK;\n         s-\u003emode = BZ_M_IDLE;\n         return BZ_STREAM_END;\n   }\n   return BZ_OK; /*--not reached--*/\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":4756,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1746352":{"score":0.85914916,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )\n{\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm-\u003estate;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s-\u003estrm != strm) return BZ_PARAM_ERROR;\n\n   if (s-\u003earr1 != NULL) BZFREE(s-\u003earr1);\n   if (s-\u003earr2 != NULL) BZFREE(s-\u003earr2);\n   if (s-\u003eftab != NULL) BZFREE(s-\u003eftab);\n   BZFREE(strm-\u003estate);\n\n   strm-\u003estate = NULL;   \n\n   return BZ_OK;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":4817,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1746480":{"score":0.8464313,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzDecompressInit) \n                     ( bz_stream* strm, \n                       int        verbosity,\n                       int        small )\n{\n   DState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   if (small != 0 \u0026\u0026 small != 1) return BZ_PARAM_ERROR;\n   if (verbosity \u003c 0 || verbosity \u003e 4) return BZ_PARAM_ERROR;\n\n   if (strm-\u003ebzalloc == NULL) strm-\u003ebzalloc = default_bzalloc;\n   if (strm-\u003ebzfree == NULL) strm-\u003ebzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(DState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s-\u003estrm                  = strm;\n   strm-\u003estate              = s;\n   s-\u003estate                 = BZ_X_MAGIC_1;\n   s-\u003ebsLive                = 0;\n   s-\u003ebsBuff                = 0;\n   s-\u003ecalculatedCombinedCRC = 0;\n   strm-\u003etotal_in_lo32      = 0;\n   strm-\u003etotal_in_hi32      = 0;\n   strm-\u003etotal_out_lo32     = 0;\n   strm-\u003etotal_out_hi32     = 0;\n   s-\u003esmallDecompress       = (Bool)small;\n   s-\u003ell4                   = NULL;\n   s-\u003ell16                  = NULL;\n   s-\u003ett                    = NULL;\n   s-\u003ecurrBlockNo           = 0;\n   s-\u003everbosity             = verbosity;\n\n   return BZ_OK;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":4841,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1746736":{"score":0.85529816,"function_name":"BZ2_indexIntoF","code":"__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )\n{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) \u003e\u003e 1;\n      if (indx \u003e= cftab[mid]) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":1440,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1746832":{"score":0.7118223,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzDecompress) ( bz_stream *strm )\n{\n   Bool    corrupt;\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm-\u003estate;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s-\u003estrm != strm) return BZ_PARAM_ERROR;\n\n   while (True) {\n      if (s-\u003estate == BZ_X_IDLE) return BZ_SEQUENCE_ERROR;\n      if (s-\u003estate == BZ_X_OUTPUT) {\n         if (s-\u003esmallDecompress)\n            corrupt = unRLE_obuf_to_output_SMALL ( s ); else\n            corrupt = unRLE_obuf_to_output_FAST  ( s );\n         if (corrupt) return BZ_DATA_ERROR;\n         if (s-\u003enblock_used == s-\u003esave_nblock+1 \u0026\u0026 s-\u003estate_out_len == 0) {\n            BZ_FINALISE_CRC ( s-\u003ecalculatedBlockCRC );\n            if (s-\u003everbosity \u003e= 3) \n               VPrintf2 ( \" {0x%08x, 0x%08x}\", s-\u003estoredBlockCRC, \n                          s-\u003ecalculatedBlockCRC );\n            if (s-\u003everbosity \u003e= 2) VPrintf0 ( \"]\" );\n            if (s-\u003ecalculatedBlockCRC != s-\u003estoredBlockCRC)\n               return BZ_DATA_ERROR;\n            s-\u003ecalculatedCombinedCRC \n               = (s-\u003ecalculatedCombinedCRC \u003c\u003c 1) | \n                    (s-\u003ecalculatedCombinedCRC \u003e\u003e 31);\n            s-\u003ecalculatedCombinedCRC ^= s-\u003ecalculatedBlockCRC;\n            s-\u003estate = BZ_X_BLKHDR_1;\n         } else {\n            return BZ_OK;\n         }\n      }\n      if (s-\u003estate \u003e= BZ_X_MAGIC_1) {\n         Int32 r = BZ2_decompress ( s );\n         if (r == BZ_STREAM_END) {\n            if (s-\u003everbosity \u003e= 3)\n               VPrintf2 ( \"\\n    combined CRCs: stored = 0x%08x, computed = 0x%08x\", \n                          s-\u003estoredCombinedCRC, s-\u003ecalculatedCombinedCRC );\n            if (s-\u003ecalculatedCombinedCRC != s-\u003estoredCombinedCRC)\n               return BZ_DATA_ERROR;\n            return r;\n         }\n         if (s-\u003estate != BZ_X_OUTPUT) return r;\n      }\n   }\n\n   AssertH ( 0, 6001 );\n\n   return 0;  /*NOTREACHED*/\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5141,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1751120":{"score":0.86227363,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )\n{\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm-\u003estate;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s-\u003estrm != strm) return BZ_PARAM_ERROR;\n\n   if (s-\u003earr1 != NULL) BZFREE(s-\u003earr1);\n   if (s-\u003earr2 != NULL) BZFREE(s-\u003earr2);\n   if (s-\u003eftab != NULL) BZFREE(s-\u003eftab);\n   BZFREE(strm-\u003estate);\n\n   strm-\u003estate = NULL;   \n\n   return BZ_OK;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":4817,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1751264":{"score":0.8408518,"function_name":"BZ_API","code":"BZFILE* BZ_API(BZ2_bzWriteOpen) \n                    ( int*  bzerror,      \n                      FILE* f, \n                      int   blockSize100k, \n                      int   verbosity,\n                      int   workFactor )\n{\n   Int32   ret;\n   bzFile* bzf = NULL;\n\n   BZ_SETERR(BZ_OK);\n\n   if (f == NULL ||\n       (blockSize100k \u003c 1 || blockSize100k \u003e 9) ||\n       (workFactor \u003c 0 || workFactor \u003e 250) ||\n       (verbosity \u003c 0 || verbosity \u003e 4))\n      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };\n\n   if (ferror(f))\n      { BZ_SETERR(BZ_IO_ERROR); return NULL; };\n\n   bzf = malloc ( sizeof(bzFile) );\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };\n\n   BZ_SETERR(BZ_OK);\n   bzf-\u003einitialisedOk = False;\n   bzf-\u003ebufN          = 0;\n   bzf-\u003ehandle        = f;\n   bzf-\u003ewriting       = True;\n   bzf-\u003estrm.bzalloc  = NULL;\n   bzf-\u003estrm.bzfree   = NULL;\n   bzf-\u003estrm.opaque   = NULL;\n\n   if (workFactor == 0) workFactor = 30;\n   ret = BZ2_bzCompressInit ( \u0026(bzf-\u003estrm), blockSize100k, \n                              verbosity, workFactor );\n   if (ret != BZ_OK)\n      { BZ_SETERR(ret); free(bzf); return NULL; };\n\n   bzf-\u003estrm.avail_in = 0;\n   bzf-\u003einitialisedOk = True;\n   return bzf;   \n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5249,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1751680":{"score":0.8272553,"function_name":"BZ_API","code":"void BZ_API(BZ2_bzWrite)\n             ( int*    bzerror, \n               BZFILE* b, \n               void*   buf, \n               int     len )\n{\n   Int32 n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL || buf == NULL || len \u003c 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n   if (!(bzf-\u003ewriting))\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (ferror(bzf-\u003ehandle))\n      { BZ_SETERR(BZ_IO_ERROR); return; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return; };\n\n   bzf-\u003estrm.avail_in = len;\n   bzf-\u003estrm.next_in  = buf;\n\n   while (True) {\n      bzf-\u003estrm.avail_out = BZ_MAX_UNUSED;\n      bzf-\u003estrm.next_out = bzf-\u003ebuf;\n      ret = BZ2_bzCompress ( \u0026(bzf-\u003estrm), BZ_RUN );\n      if (ret != BZ_RUN_OK)\n         { BZ_SETERR(ret); return; };\n\n      if (bzf-\u003estrm.avail_out \u003c BZ_MAX_UNUSED) {\n         n = BZ_MAX_UNUSED - bzf-\u003estrm.avail_out;\n         n2 = fwrite ( (void*)(bzf-\u003ebuf), sizeof(UChar), \n                       n, bzf-\u003ehandle );\n         if (n != n2 || ferror(bzf-\u003ehandle))\n            { BZ_SETERR(BZ_IO_ERROR); return; };\n      }\n\n      if (bzf-\u003estrm.avail_in == 0)\n         { BZ_SETERR(BZ_OK); return; };\n   }\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5297,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1752240":{"score":0.64077944,"function_name":"BZ_API","code":"void BZ_API(BZ2_bzWriteClose64)\n                  ( int*          bzerror, \n                    BZFILE*       b, \n                    int           abandon,\n                    unsigned int* nbytes_in_lo32,\n                    unsigned int* nbytes_in_hi32,\n                    unsigned int* nbytes_out_lo32,\n                    unsigned int* nbytes_out_hi32 )\n{\n   Int32   n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n   if (!(bzf-\u003ewriting))\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (ferror(bzf-\u003ehandle))\n      { BZ_SETERR(BZ_IO_ERROR); return; };\n\n   if (nbytes_in_lo32 != NULL) *nbytes_in_lo32 = 0;\n   if (nbytes_in_hi32 != NULL) *nbytes_in_hi32 = 0;\n   if (nbytes_out_lo32 != NULL) *nbytes_out_lo32 = 0;\n   if (nbytes_out_hi32 != NULL) *nbytes_out_hi32 = 0;\n\n   if ((!abandon) \u0026\u0026 bzf-\u003elastErr == BZ_OK) {\n      while (True) {\n         bzf-\u003estrm.avail_out = BZ_MAX_UNUSED;\n         bzf-\u003estrm.next_out = bzf-\u003ebuf;\n         ret = BZ2_bzCompress ( \u0026(bzf-\u003estrm), BZ_FINISH );\n         if (ret != BZ_FINISH_OK \u0026\u0026 ret != BZ_STREAM_END)\n            { BZ_SETERR(ret); return; };\n\n         if (bzf-\u003estrm.avail_out \u003c BZ_MAX_UNUSED) {\n            n = BZ_MAX_UNUSED - bzf-\u003estrm.avail_out;\n            n2 = fwrite ( (void*)(bzf-\u003ebuf), sizeof(UChar), \n                          n, bzf-\u003ehandle );\n            if (n != n2 || ferror(bzf-\u003ehandle))\n               { BZ_SETERR(BZ_IO_ERROR); return; };\n         }\n\n         if (ret == BZ_STREAM_END) break;\n      }\n   }\n\n   if ( !abandon \u0026\u0026 !ferror ( bzf-\u003ehandle ) ) {\n      fflush ( bzf-\u003ehandle );\n      if (ferror(bzf-\u003ehandle))\n         { BZ_SETERR(BZ_IO_ERROR); return; };\n   }\n\n   if (nbytes_in_lo32 != NULL)\n      *nbytes_in_lo32 = bzf-\u003estrm.total_in_lo32;\n   if (nbytes_in_hi32 != NULL)\n      *nbytes_in_hi32 = bzf-\u003estrm.total_in_hi32;\n   if (nbytes_out_lo32 != NULL)\n      *nbytes_out_lo32 = bzf-\u003estrm.total_out_lo32;\n   if (nbytes_out_hi32 != NULL)\n      *nbytes_out_hi32 = bzf-\u003estrm.total_out_hi32;\n\n   BZ_SETERR(BZ_OK);\n   BZ2_bzCompressEnd ( \u0026(bzf-\u003estrm) );\n   free ( bzf );\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5354,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1753056":{"score":0.8602472,"function_name":"BZ_API","code":"void BZ_API(BZ2_bzWriteClose64)\n                  ( int*          bzerror, \n                    BZFILE*       b, \n                    int           abandon,\n                    unsigned int* nbytes_in_lo32,\n                    unsigned int* nbytes_in_hi32,\n                    unsigned int* nbytes_out_lo32,\n                    unsigned int* nbytes_out_hi32 )\n{\n   Int32   n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n   if (!(bzf-\u003ewriting))\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (ferror(bzf-\u003ehandle))\n      { BZ_SETERR(BZ_IO_ERROR); return; };\n\n   if (nbytes_in_lo32 != NULL) *nbytes_in_lo32 = 0;\n   if (nbytes_in_hi32 != NULL) *nbytes_in_hi32 = 0;\n   if (nbytes_out_lo32 != NULL) *nbytes_out_lo32 = 0;\n   if (nbytes_out_hi32 != NULL) *nbytes_out_hi32 = 0;\n\n   if ((!abandon) \u0026\u0026 bzf-\u003elastErr == BZ_OK) {\n      while (True) {\n         bzf-\u003estrm.avail_out = BZ_MAX_UNUSED;\n         bzf-\u003estrm.next_out = bzf-\u003ebuf;\n         ret = BZ2_bzCompress ( \u0026(bzf-\u003estrm), BZ_FINISH );\n         if (ret != BZ_FINISH_OK \u0026\u0026 ret != BZ_STREAM_END)\n            { BZ_SETERR(ret); return; };\n\n         if (bzf-\u003estrm.avail_out \u003c BZ_MAX_UNUSED) {\n            n = BZ_MAX_UNUSED - bzf-\u003estrm.avail_out;\n            n2 = fwrite ( (void*)(bzf-\u003ebuf), sizeof(UChar), \n                          n, bzf-\u003ehandle );\n            if (n != n2 || ferror(bzf-\u003ehandle))\n               { BZ_SETERR(BZ_IO_ERROR); return; };\n         }\n\n         if (ret == BZ_STREAM_END) break;\n      }\n   }\n\n   if ( !abandon \u0026\u0026 !ferror ( bzf-\u003ehandle ) ) {\n      fflush ( bzf-\u003ehandle );\n      if (ferror(bzf-\u003ehandle))\n         { BZ_SETERR(BZ_IO_ERROR); return; };\n   }\n\n   if (nbytes_in_lo32 != NULL)\n      *nbytes_in_lo32 = bzf-\u003estrm.total_in_lo32;\n   if (nbytes_in_hi32 != NULL)\n      *nbytes_in_hi32 = bzf-\u003estrm.total_in_hi32;\n   if (nbytes_out_lo32 != NULL)\n      *nbytes_out_lo32 = bzf-\u003estrm.total_out_lo32;\n   if (nbytes_out_hi32 != NULL)\n      *nbytes_out_hi32 = bzf-\u003estrm.total_out_hi32;\n\n   BZ_SETERR(BZ_OK);\n   BZ2_bzCompressEnd ( \u0026(bzf-\u003estrm) );\n   free ( bzf );\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5354,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1753904":{"score":0.798525,"function_name":"BZ_API","code":"BZFILE* BZ_API(BZ2_bzReadOpen) \n                   ( int*  bzerror, \n                     FILE* f, \n                     int   verbosity,\n                     int   small,\n                     void* unused,\n                     int   nUnused )\n{\n   bzFile* bzf = NULL;\n   int     ret;\n\n   BZ_SETERR(BZ_OK);\n\n   if (f == NULL || \n       (small != 0 \u0026\u0026 small != 1) ||\n       (verbosity \u003c 0 || verbosity \u003e 4) ||\n       (unused == NULL \u0026\u0026 nUnused != 0) ||\n       (unused != NULL \u0026\u0026 (nUnused \u003c 0 || nUnused \u003e BZ_MAX_UNUSED)))\n      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };\n\n   if (ferror(f))\n      { BZ_SETERR(BZ_IO_ERROR); return NULL; };\n\n   bzf = malloc ( sizeof(bzFile) );\n   if (bzf == NULL) \n      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };\n\n   BZ_SETERR(BZ_OK);\n\n   bzf-\u003einitialisedOk = False;\n   bzf-\u003ehandle        = f;\n   bzf-\u003ebufN          = 0;\n   bzf-\u003ewriting       = False;\n   bzf-\u003estrm.bzalloc  = NULL;\n   bzf-\u003estrm.bzfree   = NULL;\n   bzf-\u003estrm.opaque   = NULL;\n   \n   while (nUnused \u003e 0) {\n      bzf-\u003ebuf[bzf-\u003ebufN] = *((UChar*)(unused)); bzf-\u003ebufN++;\n      unused = ((void*)( 1 + ((UChar*)(unused))  ));\n      nUnused--;\n   }\n\n   ret = BZ2_bzDecompressInit ( \u0026(bzf-\u003estrm), verbosity, small );\n   if (ret != BZ_OK)\n      { BZ_SETERR(ret); free(bzf); return NULL; };\n\n   bzf-\u003estrm.avail_in = bzf-\u003ebufN;\n   bzf-\u003estrm.next_in  = bzf-\u003ebuf;\n\n   bzf-\u003einitialisedOk = True;\n   return bzf;   \n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5420,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1754672":{"score":0.8399993,"function_name":"bzopen_or_bzdopen","code":"static\nBZFILE * bzopen_or_bzdopen\n               ( const char *path,   /* no use when bzdopen */\n                 int fd,             /* no use when bzdopen */\n                 const char *mode,\n                 int open_mode)      /* bzopen: 0, bzdopen:1 */\n{\n   int    bzerr;\n   char   unused[BZ_MAX_UNUSED];\n   int    blockSize100k = 9;\n   int    writing       = 0;\n   char   mode2[10]     = \"\";\n   FILE   *fp           = NULL;\n   BZFILE *bzfp         = NULL;\n   int    verbosity     = 0;\n   int    workFactor    = 30;\n   int    smallMode     = 0;\n   int    nUnused       = 0; \n\n   if (mode == NULL) return NULL;\n   while (*mode) {\n      switch (*mode) {\n      case 'r':\n         writing = 0; break;\n      case 'w':\n         writing = 1; break;\n      case 's':\n         smallMode = 1; break;\n      default:\n         if (isdigit((int)(*mode))) {\n            blockSize100k = *mode-BZ_HDR_0;\n         }\n      }\n      mode++;\n   }\n   strcat(mode2, writing ? \"w\" : \"r\" );\n   strcat(mode2,\"b\");   /* binary mode */\n\n   if (open_mode==0) {\n      if (path==NULL || strcmp(path,\"\")==0) {\n        fp = (writing ? stdout : stdin);\n        SET_BINARY_MODE(fp);\n      } else {\n        fp = fopen(path,mode2);\n      }\n   } else {\n#ifdef BZ_STRICT_ANSI\n      fp = NULL;\n#else\n      fp = fdopen(fd,mode2);\n#endif\n   }\n   if (fp == NULL) return NULL;\n\n   if (writing) {\n      /* Guard against total chaos and anarchy -- JRS */\n      if (blockSize100k \u003c 1) blockSize100k = 1;\n      if (blockSize100k \u003e 9) blockSize100k = 9; \n      bzfp = BZ2_bzWriteOpen(\u0026bzerr,fp,blockSize100k,\n                             verbosity,workFactor);\n   } else {\n      bzfp = BZ2_bzReadOpen(\u0026bzerr,fp,verbosity,smallMode,\n                            unused,nUnused);\n   }\n   if (bzfp == NULL) {\n      if (fp != stdin \u0026\u0026 fp != stdout) fclose(fp);\n      return NULL;\n   }\n   return bzfp;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5716,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1755248":{"score":0.63409877,"function_name":"BZ_API","code":"void BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )\n{\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n\n   if (bzf-\u003ewriting)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n\n   if (bzf-\u003einitialisedOk)\n      (void)BZ2_bzDecompressEnd ( \u0026(bzf-\u003estrm) );\n   free ( bzf );\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5476,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1755392":{"score":0.8454302,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzRead) \n           ( int*    bzerror, \n             BZFILE* b, \n             void*   buf, \n             int     len )\n{\n   Int32   n, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n\n   if (bzf == NULL || buf == NULL || len \u003c 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };\n\n   if (bzf-\u003ewriting)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return 0; };\n\n   bzf-\u003estrm.avail_out = len;\n   bzf-\u003estrm.next_out = buf;\n\n   while (True) {\n\n      if (ferror(bzf-\u003ehandle)) \n         { BZ_SETERR(BZ_IO_ERROR); return 0; };\n\n      if (bzf-\u003estrm.avail_in == 0 \u0026\u0026 !myfeof(bzf-\u003ehandle)) {\n         n = fread ( bzf-\u003ebuf, sizeof(UChar), \n                     BZ_MAX_UNUSED, bzf-\u003ehandle );\n         if (ferror(bzf-\u003ehandle))\n            { BZ_SETERR(BZ_IO_ERROR); return 0; };\n         bzf-\u003ebufN = n;\n         bzf-\u003estrm.avail_in = bzf-\u003ebufN;\n         bzf-\u003estrm.next_in = bzf-\u003ebuf;\n      }\n\n      ret = BZ2_bzDecompress ( \u0026(bzf-\u003estrm) );\n\n      if (ret != BZ_OK \u0026\u0026 ret != BZ_STREAM_END)\n         { BZ_SETERR(ret); return 0; };\n\n      if (ret == BZ_OK \u0026\u0026 myfeof(bzf-\u003ehandle) \u0026\u0026 \n          bzf-\u003estrm.avail_in == 0 \u0026\u0026 bzf-\u003estrm.avail_out \u003e 0)\n         { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };\n\n      if (ret == BZ_STREAM_END)\n         { BZ_SETERR(BZ_STREAM_END);\n           return len - bzf-\u003estrm.avail_out; };\n      if (bzf-\u003estrm.avail_out == 0)\n         { BZ_SETERR(BZ_OK); return len; };\n      \n   }\n\n   return 0; /*not reached*/\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5494,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1756080":{"score":0.766236,"function_name":"BZ_API","code":"void BZ_API(BZ2_bzReadGetUnused) \n                     ( int*    bzerror, \n                       BZFILE* b, \n                       void**  unused, \n                       int*    nUnused )\n{\n   bzFile* bzf = (bzFile*)b;\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n   if (bzf-\u003elastErr != BZ_STREAM_END)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (unused == NULL || nUnused == NULL)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n\n   BZ_SETERR(BZ_OK);\n   *nUnused = bzf-\u003estrm.avail_in;\n   *unused = bzf-\u003estrm.next_in;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5554,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1756224":{"score":0.9315286,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzBuffToBuffCompress) \n                         ( char*         dest, \n                           unsigned int* destLen,\n                           char*         source, \n                           unsigned int  sourceLen,\n                           int           blockSize100k, \n                           int           verbosity, \n                           int           workFactor )\n{\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL || destLen == NULL || \n       source == NULL ||\n       blockSize100k \u003c 1 || blockSize100k \u003e 9 ||\n       verbosity \u003c 0 || verbosity \u003e 4 ||\n       workFactor \u003c 0 || workFactor \u003e 250) \n      return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzCompressInit ( \u0026strm, blockSize100k, \n                              verbosity, workFactor );\n   if (ret != BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzCompress ( \u0026strm, BZ_FINISH );\n   if (ret == BZ_FINISH_OK) goto output_overflow;\n   if (ret != BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;   \n   BZ2_bzCompressEnd ( \u0026strm );\n   return BZ_OK;\n\n   output_overflow:\n   BZ2_bzCompressEnd ( \u0026strm );\n   return BZ_OUTBUFF_FULL;\n\n   errhandler:\n   BZ2_bzCompressEnd ( \u0026strm );\n   return ret;\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5580,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1756560":{"score":0.91106445,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzBuffToBuffDecompress) \n                           ( char*         dest, \n                             unsigned int* destLen,\n                             char*         source, \n                             unsigned int  sourceLen,\n                             int           small,\n                             int           verbosity )\n{\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL || destLen == NULL || \n       source == NULL ||\n       (small != 0 \u0026\u0026 small != 1) ||\n       verbosity \u003c 0 || verbosity \u003e 4) \n          return BZ_PARAM_ERROR;\n\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzDecompressInit ( \u0026strm, verbosity, small );\n   if (ret != BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzDecompress ( \u0026strm );\n   if (ret == BZ_OK) goto output_overflow_or_eof;\n   if (ret != BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;\n   BZ2_bzDecompressEnd ( \u0026strm );\n   return BZ_OK;\n\n   output_overflow_or_eof:\n   if (strm.avail_out \u003e 0) {\n      BZ2_bzDecompressEnd ( \u0026strm );\n      return BZ_UNEXPECTED_EOF;\n   } else {\n      BZ2_bzDecompressEnd ( \u0026strm );\n      return BZ_OUTBUFF_FULL;\n   };      \n\n   errhandler:\n   BZ2_bzDecompressEnd ( \u0026strm );\n   return ret; \n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5632,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1757056":{"score":0.8419906,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzread) (BZFILE* b, void* buf, int len )\n{\n   int bzerr, nread;\n   if (((bzFile*)b)-\u003elastErr == BZ_STREAM_END) return 0;\n   nread = BZ2_bzRead(\u0026bzerr,b,buf,len);\n   if (bzerr == BZ_OK || bzerr == BZ_STREAM_END) {\n      return nread;\n   } else {\n      return -1;\n   }\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5812,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1757152":{"score":0.6724428,"function_name":"BZ_API","code":"int BZ_API(BZ2_bzRead) \n           ( int*    bzerror, \n             BZFILE* b, \n             void*   buf, \n             int     len )\n{\n   Int32   n, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n\n   if (bzf == NULL || buf == NULL || len \u003c 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };\n\n   if (bzf-\u003ewriting)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return 0; };\n\n   bzf-\u003estrm.avail_out = len;\n   bzf-\u003estrm.next_out = buf;\n\n   while (True) {\n\n      if (ferror(bzf-\u003ehandle)) \n         { BZ_SETERR(BZ_IO_ERROR); return 0; };\n\n      if (bzf-\u003estrm.avail_in == 0 \u0026\u0026 !myfeof(bzf-\u003ehandle)) {\n         n = fread ( bzf-\u003ebuf, sizeof(UChar), \n                     BZ_MAX_UNUSED, bzf-\u003ehandle );\n         if (ferror(bzf-\u003ehandle))\n            { BZ_SETERR(BZ_IO_ERROR); return 0; };\n         bzf-\u003ebufN = n;\n         bzf-\u003estrm.avail_in = bzf-\u003ebufN;\n         bzf-\u003estrm.next_in = bzf-\u003ebuf;\n      }\n\n      ret = BZ2_bzDecompress ( \u0026(bzf-\u003estrm) );\n\n      if (ret != BZ_OK \u0026\u0026 ret != BZ_STREAM_END)\n         { BZ_SETERR(ret); return 0; };\n\n      if (ret == BZ_OK \u0026\u0026 myfeof(bzf-\u003ehandle) \u0026\u0026 \n          bzf-\u003estrm.avail_in == 0 \u0026\u0026 bzf-\u003estrm.avail_out \u003e 0)\n         { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };\n\n      if (ret == BZ_STREAM_END)\n         { BZ_SETERR(BZ_STREAM_END);\n           return len - bzf-\u003estrm.avail_out; };\n      if (bzf-\u003estrm.avail_out == 0)\n         { BZ_SETERR(BZ_OK); return len; };\n      \n   }\n\n   return 0; /*not reached*/\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5494,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1757632":{"score":0.69474065,"function_name":"BZ_API","code":"void BZ_API(BZ2_bzclose) (BZFILE* b)\n{\n   int bzerr;\n   FILE *fp = ((bzFile *)b)-\u003ehandle;\n   \n   if (b==NULL) {return;}\n   if(((bzFile*)b)-\u003ewriting){\n      BZ2_bzWriteClose(\u0026bzerr,b,0,NULL,NULL);\n      if(bzerr != BZ_OK){\n         BZ2_bzWriteClose(NULL,b,1,NULL,NULL);\n      }\n   }else{\n      BZ2_bzReadClose(\u0026bzerr,b);\n   }\n   if(fp!=stdin \u0026\u0026 fp!=stdout){\n      fclose(fp);\n   }\n}","filepath":"VEX/switchback/test_bzip2.c","line_number":5848,"entry_url":"https://github.com/Cr4sh/openreil.git","slot_name":"0.1.2"},"1763152":{"score":0.8086816,"function_name":"build_tree","code":"static void\nbuild_tree(u32 A[], unsigned sym_count)\n{\n\t/*\n\t * Index, in 'A', of next lowest frequency symbol that has not yet been\n\t * processed.\n\t */\n\tunsigned i = 0;\n\n\t/*\n\t * Index, in 'A', of next lowest frequency parentless non-leaf node; or,\n\t * if equal to 'e', then no such node exists yet.\n\t */\n\tunsigned b = 0;\n\n\t/* Index, in 'A', of next node to allocate as a non-leaf. */\n\tunsigned e = 0;\n\n\tdo {\n\t\tunsigned m, n;\n\t\tu32 freq_shifted;\n\n\t\t/* Choose the two next lowest frequency entries. */\n\n\t\tif (i != sym_count \u0026\u0026\n\t\t    (b == e ||\n\t\t     (A[i] \u003e\u003e NUM_SYMBOL_BITS) \u003c= (A[b] \u003e\u003e NUM_SYMBOL_BITS)))\n\t\t\tm = i++;\n\t\telse\n\t\t\tm = b++;\n\n\t\tif (i != sym_count \u0026\u0026\n\t\t    (b == e ||\n\t\t     (A[i] \u003e\u003e NUM_SYMBOL_BITS) \u003c= (A[b] \u003e\u003e NUM_SYMBOL_BITS)))\n\t\t\tn = i++;\n\t\telse\n\t\t\tn = b++;\n\n\t\t/*\n\t\t * Allocate a non-leaf node and link the entries to it.\n\t\t *\n\t\t * If we link an entry that we're visiting for the first time\n\t\t * (via index 'i'), then we're actually linking a leaf node and\n\t\t * it will have no effect, since the leaf will be overwritten\n\t\t * with a non-leaf when index 'e' catches up to it.  But it's\n\t\t * not any slower to unconditionally set the parent index.\n\t\t *\n\t\t * We also compute the frequency of the non-leaf node as the sum\n\t\t * of its two children's frequencies.\n\t\t */\n\n\t\tfreq_shifted = (A[m] \u0026 ~SYMBOL_MASK) + (A[n] \u0026 ~SYMBOL_MASK);\n\n\t\tA[m] = (A[m] \u0026 SYMBOL_MASK) | (e \u003c\u003c NUM_SYMBOL_BITS);\n\t\tA[n] = (A[n] \u0026 SYMBOL_MASK) | (e \u003c\u003c NUM_SYMBOL_BITS);\n\t\tA[e] = (A[e] \u0026 SYMBOL_MASK) | freq_shifted;\n\t\te++;\n\t} while (sym_count - e \u003e 1);\n\t\t/*\n\t\t * When just one entry remains, it is a \"leaf\" that was linked\n\t\t * to some other node.  We ignore it, since the rest of the\n\t\t * array contains the non-leaves which we need.  (Note that\n\t\t * we're assuming the cases with 0 or 1 symbols were handled\n\t\t * separately.)\n\t\t */\n}","filepath":"lib/deflate_compress.c","line_number":942,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1763456":{"score":0.7563442,"function_name":"compute_length_counts","code":"static void\ncompute_length_counts(u32 A[restrict], unsigned root_idx,\n\t\t      unsigned len_counts[restrict], unsigned max_codeword_len)\n{\n\tunsigned len;\n\tint node;\n\n\t/*\n\t * The key observations are:\n\t *\n\t * (1) We can traverse the non-leaf nodes of the tree, always visiting a\n\t *     parent before its children, by simply iterating through the array\n\t *     in reverse order.  Consequently, we can compute the depth of each\n\t *     node in one pass, overwriting the parent indices with depths.\n\t *\n\t * (2) We can initially assume that in the real Huffman tree, both\n\t *     children of the root are leaves.  This corresponds to two\n\t *     codewords of length 1.  Then, whenever we visit a (non-leaf) node\n\t *     during the traversal, we modify this assumption to account for\n\t *     the current node *not* being a leaf, but rather its two children\n\t *     being leaves.  This causes the loss of one codeword for the\n\t *     current depth and the addition of two codewords for the current\n\t *     depth plus one.\n\t *\n\t * (3) We can handle the length-limited constraint fairly easily by\n\t *     simply using the largest length available when a depth exceeds\n\t *     max_codeword_len.\n\t */\n\n\tfor (len = 0; len \u003c= max_codeword_len; len++)\n\t\tlen_counts[len] = 0;\n\tlen_counts[1] = 2;\n\n\t/* Set the root node's depth to 0. */\n\tA[root_idx] \u0026= SYMBOL_MASK;\n\n\tfor (node = root_idx - 1; node \u003e= 0; node--) {\n\n\t\t/* Calculate the depth of this node. */\n\n\t\tunsigned parent = A[node] \u003e\u003e NUM_SYMBOL_BITS;\n\t\tunsigned parent_depth = A[parent] \u003e\u003e NUM_SYMBOL_BITS;\n\t\tunsigned depth = parent_depth + 1;\n\t\tunsigned len = depth;\n\n\t\t/*\n\t\t * Set the depth of this node so that it is available when its\n\t\t * children (if any) are processed.\n\t\t */\n\t\tA[node] = (A[node] \u0026 SYMBOL_MASK) | (depth \u003c\u003c NUM_SYMBOL_BITS);\n\n\t\t/*\n\t\t * If needed, decrease the length to meet the length-limited\n\t\t * constraint.  This is not the optimal method for generating\n\t\t * length-limited Huffman codes!  But it should be good enough.\n\t\t */\n\t\tif (len \u003e= max_codeword_len) {\n\t\t\tlen = max_codeword_len;\n\t\t\tdo {\n\t\t\t\tlen--;\n\t\t\t} while (len_counts[len] == 0);\n\t\t}\n\n\t\t/*\n\t\t * Account for the fact that we have a non-leaf node at the\n\t\t * current depth.\n\t\t */\n\t\tlen_counts[len]--;\n\t\tlen_counts[len + 1] += 2;\n\t}\n}","filepath":"lib/deflate_compress.c","line_number":1034,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1763664":{"score":0.8213961,"function_name":"do_end_block_check","code":"static bool\ndo_end_block_check(struct block_split_stats *stats, u32 block_length)\n{\n\tif (stats-\u003enum_observations \u003e 0) {\n\t\t/*\n\t\t * Compute the sum of absolute differences of probabilities.  To\n\t\t * avoid needing to use floating point arithmetic or do slow\n\t\t * divisions, we do all arithmetic with the probabilities\n\t\t * multiplied by num_observations * num_new_observations.  E.g.,\n\t\t * for the \"old\" observations the probabilities would be\n\t\t * (double)observations[i] / num_observations, but since we\n\t\t * multiply by both num_observations and num_new_observations we\n\t\t * really do observations[i] * num_new_observations.\n\t\t */\n\t\tu32 total_delta = 0;\n\t\tu32 num_items;\n\t\tu32 cutoff;\n\t\tint i;\n\n\t\tfor (i = 0; i \u003c NUM_OBSERVATION_TYPES; i++) {\n\t\t\tu32 expected = stats-\u003eobservations[i] *\n\t\t\t\t       stats-\u003enum_new_observations;\n\t\t\tu32 actual = stats-\u003enew_observations[i] *\n\t\t\t\t     stats-\u003enum_observations;\n\t\t\tu32 delta = (actual \u003e expected) ? actual - expected :\n\t\t\t\t\t\t\t  expected - actual;\n\n\t\t\ttotal_delta += delta;\n\t\t}\n\n\t\tnum_items = stats-\u003enum_observations +\n\t\t\t    stats-\u003enum_new_observations;\n\t\t/*\n\t\t * Heuristic: the cutoff is when the sum of absolute differences\n\t\t * of probabilities becomes at least 200/512.  As above, the\n\t\t * probability is multiplied by both num_new_observations and\n\t\t * num_observations.  Be careful to avoid integer overflow.\n\t\t */\n\t\tcutoff = stats-\u003enum_new_observations * 200 / 512 *\n\t\t\t stats-\u003enum_observations;\n\t\t/*\n\t\t * Very short blocks have a lot of overhead for the Huffman\n\t\t * codes, so only use them if it clearly seems worthwhile.\n\t\t * (This is an additional penalty, which adds to the smaller\n\t\t * penalty below which scales more slowly.)\n\t\t */\n\t\tif (block_length \u003c 10000 \u0026\u0026 num_items \u003c 8192)\n\t\t\tcutoff += (u64)cutoff * (8192 - num_items) / 8192;\n\n\t\t/* Ready to end the block? */\n\t\tif (total_delta +\n\t\t    (block_length / 4096) * stats-\u003enum_observations \u003e= cutoff)\n\t\t\treturn true;\n\t}\n\tmerge_new_observations(stats);\n\treturn false;\n}","filepath":"lib/deflate_compress.c","line_number":2080,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1765328":{"score":0.5990895,"function_name":"deflate_adjust_costs","code":"static void\ndeflate_adjust_costs(struct libdeflate_compressor *c,\n\t\t     u32 lit_cost, u32 len_sym_cost)\n{\n\tu64 total_delta = 0;\n\tu64 cutoff;\n\tint i;\n\n\t/*\n\t * Decide how different the current block is from the previous block,\n\t * using the block splitting statistics from the current and previous\n\t * blocks.  The more different the current block is, the more we prefer\n\t * the default costs rather than the previous block's costs.\n\t *\n\t * The algorithm here is similar to the end-of-block check one, but here\n\t * we compare two entire blocks rather than a partial block with a small\n\t * extra part, and therefore we need 64-bit numbers in some places.\n\t */\n\tfor (i = 0; i \u003c NUM_OBSERVATION_TYPES; i++) {\n\t\tu64 prev = (u64)c-\u003ep.n.prev_observations[i] *\n\t\t\t    c-\u003esplit_stats.num_observations;\n\t\tu64 cur = (u64)c-\u003esplit_stats.observations[i] *\n\t\t\t  c-\u003ep.n.prev_num_observations;\n\n\t\ttotal_delta += prev \u003e cur ? prev - cur : cur - prev;\n\t}\n\tcutoff = ((u64)c-\u003ep.n.prev_num_observations *\n\t\t  c-\u003esplit_stats.num_observations * 200) / 512;\n\n\tif (4 * total_delta \u003e 9 * cutoff)\n\t\tdeflate_adjust_costs_impl(c, lit_cost, len_sym_cost, 3);\n\telse if (2 * total_delta \u003e 3 * cutoff)\n\t\tdeflate_adjust_costs_impl(c, lit_cost, len_sym_cost, 2);\n\telse if (2 * total_delta \u003e cutoff)\n\t\tdeflate_adjust_costs_impl(c, lit_cost, len_sym_cost, 1);\n\telse\n\t\tdeflate_adjust_costs_impl(c, lit_cost, len_sym_cost, 0);\n}","filepath":"lib/deflate_compress.c","line_number":3113,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1767632":{"score":0.8083273,"function_name":"deflate_find_min_cost_path","code":"static void\ndeflate_find_min_cost_path(struct libdeflate_compressor *c,\n\t\t\t   const u32 block_length,\n\t\t\t   const struct lz_match *cache_ptr)\n{\n\tstruct deflate_optimum_node *end_node =\n\t\t\u0026c-\u003ep.n.optimum_nodes[block_length];\n\tstruct deflate_optimum_node *cur_node = end_node;\n\n\tcur_node-\u003ecost_to_end = 0;\n\tdo {\n\t\tunsigned num_matches;\n\t\tunsigned literal;\n\t\tu32 best_cost_to_end;\n\n\t\tcur_node--;\n\t\tcache_ptr--;\n\n\t\tnum_matches = cache_ptr-\u003elength;\n\t\tliteral = cache_ptr-\u003eoffset;\n\n\t\t/* It's always possible to choose a literal. */\n\t\tbest_cost_to_end = c-\u003ep.n.costs.literal[literal] +\n\t\t\t\t   (cur_node + 1)-\u003ecost_to_end;\n\t\tcur_node-\u003eitem = ((u32)literal \u003c\u003c OPTIMUM_OFFSET_SHIFT) | 1;\n\n\t\t/* Also consider matches if there are any. */\n\t\tif (num_matches) {\n\t\t\tconst struct lz_match *match;\n\t\t\tunsigned len;\n\t\t\tunsigned offset;\n\t\t\tunsigned offset_slot;\n\t\t\tu32 offset_cost;\n\t\t\tu32 cost_to_end;\n\n\t\t\t/*\n\t\t\t * Consider each length from the minimum\n\t\t\t * (DEFLATE_MIN_MATCH_LEN) to the length of the longest\n\t\t\t * match found at this position.  For each length, we\n\t\t\t * consider only the smallest offset for which that\n\t\t\t * length is available.  Although this is not guaranteed\n\t\t\t * to be optimal due to the possibility of a larger\n\t\t\t * offset costing less than a smaller offset to code,\n\t\t\t * this is a very useful heuristic.\n\t\t\t */\n\t\t\tmatch = cache_ptr - num_matches;\n\t\t\tlen = DEFLATE_MIN_MATCH_LEN;\n\t\t\tdo {\n\t\t\t\toffset = match-\u003eoffset;\n\t\t\t\toffset_slot = c-\u003ep.n.offset_slot_full[offset];\n\t\t\t\toffset_cost =\n\t\t\t\t\tc-\u003ep.n.costs.offset_slot[offset_slot];\n\t\t\t\tdo {\n\t\t\t\t\tcost_to_end = offset_cost +\n\t\t\t\t\t\tc-\u003ep.n.costs.length[len] +\n\t\t\t\t\t\t(cur_node + len)-\u003ecost_to_end;\n\t\t\t\t\tif (cost_to_end \u003c best_cost_to_end) {\n\t\t\t\t\t\tbest_cost_to_end = cost_to_end;\n\t\t\t\t\t\tcur_node-\u003eitem = len |\n\t\t\t\t\t\t\t((u32)offset \u003c\u003c\n\t\t\t\t\t\t\t OPTIMUM_OFFSET_SHIFT);\n\t\t\t\t\t}\n\t\t\t\t} while (++len \u003c= match-\u003elength);\n\t\t\t} while (++match != cache_ptr);\n\t\t\tcache_ptr -= num_matches;\n\t\t}\n\t\tcur_node-\u003ecost_to_end = best_cost_to_end;\n\t} while (cur_node != \u0026c-\u003ep.n.optimum_nodes[0]);\n}","filepath":"lib/deflate_compress.c","line_number":3166,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1767872":{"score":0.843409,"function_name":"deflate_choose_default_litlen_costs","code":"static void\ndeflate_choose_default_litlen_costs(struct libdeflate_compressor *c,\n\t\t\t\t    const u8 *block_begin, u32 block_length,\n\t\t\t\t    u32 *lit_cost, u32 *len_sym_cost)\n{\n\tunsigned num_used_literals = 0;\n\tu32 literal_freq = block_length;\n\tu32 match_freq = 0;\n\tu32 cutoff;\n\tu32 i;\n\n\t/* Calculate the number of distinct literals that exist in the data. */\n\tmemset(c-\u003efreqs.litlen, 0,\n\t       DEFLATE_NUM_LITERALS * sizeof(c-\u003efreqs.litlen[0]));\n\tcutoff = literal_freq \u003e\u003e 11; /* Ignore literals used very rarely. */\n\tfor (i = 0; i \u003c block_length; i++)\n\t\tc-\u003efreqs.litlen[block_begin[i]]++;\n\tfor (i = 0; i \u003c DEFLATE_NUM_LITERALS; i++) {\n\t\tif (c-\u003efreqs.litlen[i] \u003e cutoff)\n\t\t\tnum_used_literals++;\n\t}\n\tif (num_used_literals == 0)\n\t\tnum_used_literals = 1;\n\n\t/*\n\t * Estimate the relative frequency of literals and matches in the\n\t * optimal parsing solution.  We don't know the optimal solution, so\n\t * this can only be a very rough estimate.  Therefore, we basically use\n\t * the match frequency from a greedy parse.  We also apply the min_len\n\t * heuristic used by the greedy and lazy parsers, to avoid counting too\n\t * many matches when literals are cheaper than short matches.\n\t */\n\tmatch_freq = 0;\n\ti = choose_min_match_len(num_used_literals, c-\u003emax_search_depth);\n\tfor (; i \u003c ARRAY_LEN(c-\u003ep.n.match_len_freqs); i++) {\n\t\tmatch_freq += c-\u003ep.n.match_len_freqs[i];\n\t\tliteral_freq -= i * c-\u003ep.n.match_len_freqs[i];\n\t}\n\tif ((s32)literal_freq \u003c 0) /* shouldn't happen */\n\t\tliteral_freq = 0;\n\n\tif (match_freq \u003e literal_freq)\n\t\ti = 2; /* many matches */\n\telse if (match_freq * 4 \u003e literal_freq)\n\t\ti = 1; /* neutral */\n\telse\n\t\ti = 0; /* few matches */\n\n\tSTATIC_ASSERT(BIT_COST == 16);\n\t*lit_cost = default_litlen_costs[i].used_lits_to_lit_cost[\n\t\t\t\t\t\t\tnum_used_literals];\n\t*len_sym_cost = default_litlen_costs[i].len_sym_cost;\n}","filepath":"lib/deflate_compress.c","line_number":2965,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1768704":{"score":0.8053334,"function_name":"heap_sort","code":"static void\nheap_sort(u32 A[], unsigned length)\n{\n\tA--; /* Use 1-based indices  */\n\n\theapify_array(A, length);\n\n\twhile (length \u003e= 2) {\n\t\tu32 tmp = A[length];\n\n\t\tA[length] = A[1];\n\t\tA[1] = tmp;\n\t\tlength--;\n\t\theapify_subtree(A, length, 1);\n\t}\n}","filepath":"lib/deflate_compress.c","line_number":801,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1769104":{"score":0.674973,"function_name":"sort_symbols","code":"static unsigned\nsort_symbols(unsigned num_syms, const u32 freqs[restrict],\n\t     u8 lens[restrict], u32 symout[restrict])\n{\n\tunsigned sym;\n\tunsigned i;\n\tunsigned num_used_syms;\n\tunsigned num_counters;\n\tunsigned counters[GET_NUM_COUNTERS(DEFLATE_MAX_NUM_SYMS)];\n\n\t/*\n\t * We use heapsort, but with an added optimization.  Since often most\n\t * symbol frequencies are low, we first do a count sort using a limited\n\t * number of counters.  High frequencies are counted in the last\n\t * counter, and only they will be sorted with heapsort.\n\t *\n\t * Note: with more symbols, it is generally beneficial to have more\n\t * counters.  About 1 counter per symbol seems fastest.\n\t */\n\n\tnum_counters = GET_NUM_COUNTERS(num_syms);\n\n\tmemset(counters, 0, num_counters * sizeof(counters[0]));\n\n\t/* Count the frequencies. */\n\tfor (sym = 0; sym \u003c num_syms; sym++)\n\t\tcounters[MIN(freqs[sym], num_counters - 1)]++;\n\n\t/*\n\t * Make the counters cumulative, ignoring the zero-th, which counted\n\t * symbols with zero frequency.  As a side effect, this calculates the\n\t * number of symbols with nonzero frequency.\n\t */\n\tnum_used_syms = 0;\n\tfor (i = 1; i \u003c num_counters; i++) {\n\t\tunsigned count = counters[i];\n\n\t\tcounters[i] = num_used_syms;\n\t\tnum_used_syms += count;\n\t}\n\n\t/*\n\t * Sort nonzero-frequency symbols using the counters.  At the same time,\n\t * set the codeword lengths of zero-frequency symbols to 0.\n\t */\n\tfor (sym = 0; sym \u003c num_syms; sym++) {\n\t\tu32 freq = freqs[sym];\n\n\t\tif (freq != 0) {\n\t\t\tsymout[counters[MIN(freq, num_counters - 1)]++] =\n\t\t\t\tsym | (freq \u003c\u003c NUM_SYMBOL_BITS);\n\t\t} else {\n\t\t\tlens[sym] = 0;\n\t\t}\n\t}\n\n\t/* Sort the symbols counted in the last counter. */\n\theap_sort(symout + counters[num_counters - 2],\n\t\t  counters[num_counters - 1] - counters[num_counters - 2]);\n\n\treturn num_used_syms;\n}","filepath":"lib/deflate_compress.c","line_number":848,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1769376":{"score":0.64428324,"function_name":"sort_symbols","code":"static unsigned\nsort_symbols(unsigned num_syms, const u32 freqs[restrict],\n\t     u8 lens[restrict], u32 symout[restrict])\n{\n\tunsigned sym;\n\tunsigned i;\n\tunsigned num_used_syms;\n\tunsigned num_counters;\n\tunsigned counters[GET_NUM_COUNTERS(DEFLATE_MAX_NUM_SYMS)];\n\n\t/*\n\t * We use heapsort, but with an added optimization.  Since often most\n\t * symbol frequencies are low, we first do a count sort using a limited\n\t * number of counters.  High frequencies are counted in the last\n\t * counter, and only they will be sorted with heapsort.\n\t *\n\t * Note: with more symbols, it is generally beneficial to have more\n\t * counters.  About 1 counter per symbol seems fastest.\n\t */\n\n\tnum_counters = GET_NUM_COUNTERS(num_syms);\n\n\tmemset(counters, 0, num_counters * sizeof(counters[0]));\n\n\t/* Count the frequencies. */\n\tfor (sym = 0; sym \u003c num_syms; sym++)\n\t\tcounters[MIN(freqs[sym], num_counters - 1)]++;\n\n\t/*\n\t * Make the counters cumulative, ignoring the zero-th, which counted\n\t * symbols with zero frequency.  As a side effect, this calculates the\n\t * number of symbols with nonzero frequency.\n\t */\n\tnum_used_syms = 0;\n\tfor (i = 1; i \u003c num_counters; i++) {\n\t\tunsigned count = counters[i];\n\n\t\tcounters[i] = num_used_syms;\n\t\tnum_used_syms += count;\n\t}\n\n\t/*\n\t * Sort nonzero-frequency symbols using the counters.  At the same time,\n\t * set the codeword lengths of zero-frequency symbols to 0.\n\t */\n\tfor (sym = 0; sym \u003c num_syms; sym++) {\n\t\tu32 freq = freqs[sym];\n\n\t\tif (freq != 0) {\n\t\t\tsymout[counters[MIN(freq, num_counters - 1)]++] =\n\t\t\t\tsym | (freq \u003c\u003c NUM_SYMBOL_BITS);\n\t\t} else {\n\t\t\tlens[sym] = 0;\n\t\t}\n\t}\n\n\t/* Sort the symbols counted in the last counter. */\n\theap_sort(symout + counters[num_counters - 2],\n\t\t  counters[num_counters - 1] - counters[num_counters - 2]);\n\n\treturn num_used_syms;\n}","filepath":"lib/deflate_compress.c","line_number":848,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1769648":{"score":0.6468547,"function_name":"sort_symbols","code":"static unsigned\nsort_symbols(unsigned num_syms, const u32 freqs[restrict],\n\t     u8 lens[restrict], u32 symout[restrict])\n{\n\tunsigned sym;\n\tunsigned i;\n\tunsigned num_used_syms;\n\tunsigned num_counters;\n\tunsigned counters[GET_NUM_COUNTERS(DEFLATE_MAX_NUM_SYMS)];\n\n\t/*\n\t * We use heapsort, but with an added optimization.  Since often most\n\t * symbol frequencies are low, we first do a count sort using a limited\n\t * number of counters.  High frequencies are counted in the last\n\t * counter, and only they will be sorted with heapsort.\n\t *\n\t * Note: with more symbols, it is generally beneficial to have more\n\t * counters.  About 1 counter per symbol seems fastest.\n\t */\n\n\tnum_counters = GET_NUM_COUNTERS(num_syms);\n\n\tmemset(counters, 0, num_counters * sizeof(counters[0]));\n\n\t/* Count the frequencies. */\n\tfor (sym = 0; sym \u003c num_syms; sym++)\n\t\tcounters[MIN(freqs[sym], num_counters - 1)]++;\n\n\t/*\n\t * Make the counters cumulative, ignoring the zero-th, which counted\n\t * symbols with zero frequency.  As a side effect, this calculates the\n\t * number of symbols with nonzero frequency.\n\t */\n\tnum_used_syms = 0;\n\tfor (i = 1; i \u003c num_counters; i++) {\n\t\tunsigned count = counters[i];\n\n\t\tcounters[i] = num_used_syms;\n\t\tnum_used_syms += count;\n\t}\n\n\t/*\n\t * Sort nonzero-frequency symbols using the counters.  At the same time,\n\t * set the codeword lengths of zero-frequency symbols to 0.\n\t */\n\tfor (sym = 0; sym \u003c num_syms; sym++) {\n\t\tu32 freq = freqs[sym];\n\n\t\tif (freq != 0) {\n\t\t\tsymout[counters[MIN(freq, num_counters - 1)]++] =\n\t\t\t\tsym | (freq \u003c\u003c NUM_SYMBOL_BITS);\n\t\t} else {\n\t\t\tlens[sym] = 0;\n\t\t}\n\t}\n\n\t/* Sort the symbols counted in the last counter. */\n\theap_sort(symout + counters[num_counters - 2],\n\t\t  counters[num_counters - 1] - counters[num_counters - 2]);\n\n\treturn num_used_syms;\n}","filepath":"lib/deflate_compress.c","line_number":848,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1769920":{"score":0.7779717,"function_name":"deflate_write_uncompressed_block","code":"static void\ndeflate_write_uncompressed_block(struct deflate_output_bitstream *os,\n\t\t\t\t const u8 *data, u16 len,\n\t\t\t\t bool is_final_block)\n{\n\tdeflate_write_block_header(os, is_final_block,\n\t\t\t\t   DEFLATE_BLOCKTYPE_UNCOMPRESSED);\n\tdeflate_align_bitstream(os);\n\n\tif (4 + (u32)len \u003e= os-\u003eend - os-\u003enext) {\n\t\tos-\u003enext = os-\u003eend;\n\t\treturn;\n\t}\n\n\tput_unaligned_le16(len, os-\u003enext);\n\tos-\u003enext += 2;\n\tput_unaligned_le16(~len, os-\u003enext);\n\tos-\u003enext += 2;\n\tmemcpy(os-\u003enext, data, len);\n\tos-\u003enext += len;\n}","filepath":"lib/deflate_compress.c","line_number":1830,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1771680":{"score":0.80390394,"function_name":"deflate_flush_block","code":"static void\ndeflate_flush_block(struct libdeflate_compressor * restrict c,\n\t\t    struct deflate_output_bitstream * restrict os,\n\t\t    const u8 * restrict block_begin, u32 block_length,\n\t\t    const struct deflate_sequence *sequences,\n\t\t    bool is_final_block)\n{\n\tstatic const u8 deflate_extra_precode_bits[DEFLATE_NUM_PRECODE_SYMS] = {\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7,\n\t};\n\n\t/* Costs are measured in bits */\n\tu32 dynamic_cost = 0;\n\tu32 static_cost = 0;\n\tu32 uncompressed_cost = 0;\n\tstruct deflate_codes *codes;\n\tint block_type;\n\tunsigned sym;\n\n\tif (sequences != NULL /* !near_optimal */ ||\n\t    !SUPPORT_NEAR_OPTIMAL_PARSING) {\n\t\t/* Tally the end-of-block symbol. */\n\t\tc-\u003efreqs.litlen[DEFLATE_END_OF_BLOCK]++;\n\n\t\t/* Build dynamic Huffman codes. */\n\t\tdeflate_make_huffman_codes(\u0026c-\u003efreqs, \u0026c-\u003ecodes);\n\t} /* Else, this was already done. */\n\n\t/* Account for the cost of sending dynamic Huffman codes. */\n\tdeflate_precompute_huffman_header(c);\n\tdynamic_cost += 5 + 5 + 4 + (3 * c-\u003enum_explicit_lens);\n\tfor (sym = 0; sym \u003c DEFLATE_NUM_PRECODE_SYMS; sym++) {\n\t\tu32 extra = deflate_extra_precode_bits[sym];\n\n\t\tdynamic_cost += c-\u003eprecode_freqs[sym] *\n\t\t\t\t(extra + c-\u003eprecode_lens[sym]);\n\t}\n\n\t/* Account for the cost of encoding literals. */\n\tfor (sym = 0; sym \u003c 256; sym++) {\n\t\tdynamic_cost += c-\u003efreqs.litlen[sym] *\n\t\t\t\tc-\u003ecodes.lens.litlen[sym];\n\t}\n\tfor (sym = 0; sym \u003c 144; sym++)\n\t\tstatic_cost += c-\u003efreqs.litlen[sym] * 8;\n\tfor (; sym \u003c 256; sym++)\n\t\tstatic_cost += c-\u003efreqs.litlen[sym] * 9;\n\n\t/* Account for the cost of encoding the end-of-block symbol. */\n\tdynamic_cost += c-\u003ecodes.lens.litlen[DEFLATE_END_OF_BLOCK];\n\tstatic_cost += 7;\n\n\t/* Account for the cost of encoding lengths. */\n\tfor (sym = DEFLATE_FIRST_LEN_SYM;\n\t     sym \u003c DEFLATE_FIRST_LEN_SYM + ARRAY_LEN(deflate_extra_length_bits);\n\t     sym++) {\n\t\tu32 extra = deflate_extra_length_bits[\n\t\t\t\t\tsym - DEFLATE_FIRST_LEN_SYM];\n\n\t\tdynamic_cost += c-\u003efreqs.litlen[sym] *\n\t\t\t\t(extra + c-\u003ecodes.lens.litlen[sym]);\n\t\tstatic_cost += c-\u003efreqs.litlen[sym] *\n\t\t\t\t(extra + c-\u003estatic_codes.lens.litlen[sym]);\n\t}\n\n\t/* Account for the cost of encoding offsets. */\n\tfor (sym = 0; sym \u003c ARRAY_LEN(deflate_extra_offset_bits); sym++) {\n\t\tu32 extra = deflate_extra_offset_bits[sym];\n\n\t\tdynamic_cost += c-\u003efreqs.offset[sym] *\n\t\t\t\t(extra + c-\u003ecodes.lens.offset[sym]);\n\t\tstatic_cost += c-\u003efreqs.offset[sym] * (extra + 5);\n\t}\n\n\t/* Compute the cost of using uncompressed blocks. */\n\tuncompressed_cost += (-(os-\u003ebitcount + 3) \u0026 7) + 32 +\n\t\t\t     (40 * (DIV_ROUND_UP(block_length,\n\t\t\t\t\t\t UINT16_MAX) - 1)) +\n\t\t\t     (8 * block_length);\n\n\t/* Choose the cheapest block type. */\n\tif (dynamic_cost \u003c MIN(static_cost, uncompressed_cost)) {\n\t\tblock_type = DEFLATE_BLOCKTYPE_DYNAMIC_HUFFMAN;\n\t\tcodes = \u0026c-\u003ecodes;\n\t} else if (static_cost \u003c uncompressed_cost) {\n\t\tblock_type = DEFLATE_BLOCKTYPE_STATIC_HUFFMAN;\n\t\tcodes = \u0026c-\u003estatic_codes;\n\t} else {\n\t\tblock_type = DEFLATE_BLOCKTYPE_UNCOMPRESSED;\n\t}\n\n\t/* Now actually output the block. */\n\n\tif (block_type == DEFLATE_BLOCKTYPE_UNCOMPRESSED) {\n\t\t/*\n\t\t * Note: the length being flushed may exceed the maximum length\n\t\t * of an uncompressed block (65535 bytes).  Therefore, more than\n\t\t * one uncompressed block might be needed.\n\t\t */\n\t\tdeflate_write_uncompressed_blocks(os, block_begin, block_length,\n\t\t\t\t\t\t  is_final_block);\n\t} else {\n\t\t/* Output the block header. */\n\t\tdeflate_write_block_header(os, is_final_block, block_type);\n\n\t\t/* Output the Huffman codes (dynamic Huffman blocks only). */\n\t\tif (block_type == DEFLATE_BLOCKTYPE_DYNAMIC_HUFFMAN)\n\t\t\tdeflate_write_huffman_header(c, os);\n\n\t\t/* Output the literals, matches, and end-of-block symbol. */\n\t#if SUPPORT_NEAR_OPTIMAL_PARSING\n\t\tif (sequences == NULL)\n\t\t\tdeflate_write_item_list(os, codes, c, block_length);\n\t\telse\n\t#endif\n\t\t\tdeflate_write_sequences(os, codes, sequences,\n\t\t\t\t\t\tblock_begin);\n\t\tdeflate_write_end_of_block(os, codes);\n\t}\n}","filepath":"lib/deflate_compress.c","line_number":1871,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1778432":{"score":0.70650935,"function_name":"deflate_compress_near_optimal","code":"static size_t\ndeflate_compress_near_optimal(struct libdeflate_compressor * restrict c,\n\t\t\t      const u8 * restrict in, size_t in_nbytes,\n\t\t\t      u8 * restrict out, size_t out_nbytes_avail)\n{\n\tconst u8 *in_next = in;\n\tconst u8 *in_block_begin = in_next;\n\tconst u8 *in_end = in_next + in_nbytes;\n\tstruct deflate_output_bitstream os;\n\tconst u8 *in_cur_base = in_next;\n\tconst u8 *in_next_slide =\n\t\tin_next + MIN(in_end - in_next, MATCHFINDER_WINDOW_SIZE);\n\tunsigned max_len = DEFLATE_MAX_MATCH_LEN;\n\tunsigned nice_len = MIN(c-\u003enice_match_length, max_len);\n\tstruct lz_match *cache_ptr = c-\u003ep.n.match_cache;\n\tu32 next_hashes[2] = {0, 0};\n\n\tdeflate_init_output(\u0026os, out, out_nbytes_avail);\n\tbt_matchfinder_init(\u0026c-\u003ep.n.bt_mf);\n\tdeflate_near_optimal_init_stats(c);\n\n\tdo {\n\t\t/* Starting a new DEFLATE block */\n\t\tconst u8 * const in_max_block_end = choose_max_block_end(\n\t\t\t\tin_block_begin, in_end, SOFT_MAX_BLOCK_LENGTH);\n\t\tconst u8 *prev_end_block_check = NULL;\n\t\tbool change_detected = false;\n\t\tconst u8 *next_observation = in_next;\n\t\tunsigned min_len;\n\n\t\t/*\n\t\t * Use the minimum match length heuristic to improve the\n\t\t * literal/match statistics gathered during matchfinding.\n\t\t * However, the actual near-optimal parse won't respect min_len,\n\t\t * as it can accurately assess the costs of different matches.\n\t\t */\n\t\tmin_len = calculate_min_match_len(\n\t\t\t\t\tin_block_begin,\n\t\t\t\t\tin_max_block_end - in_block_begin,\n\t\t\t\t\tc-\u003emax_search_depth);\n\n\t\t/*\n\t\t * Find matches until we decide to end the block.  We end the\n\t\t * block if any of the following is true:\n\t\t *\n\t\t * (1) Maximum block length has been reached\n\t\t * (2) Match catch may overflow.\n\t\t * (3) Block split heuristic says to split now.\n\t\t */\n\t\tfor (;;) {\n\t\t\tstruct lz_match *matches;\n\t\t\tunsigned best_len;\n\t\t\tsize_t remaining = in_end - in_next;\n\n\t\t\t/* Slide the window forward if needed. */\n\t\t\tif (in_next == in_next_slide) {\n\t\t\t\tbt_matchfinder_slide_window(\u0026c-\u003ep.n.bt_mf);\n\t\t\t\tin_cur_base = in_next;\n\t\t\t\tin_next_slide = in_next +\n\t\t\t\t\tMIN(remaining, MATCHFINDER_WINDOW_SIZE);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find matches with the current position using the\n\t\t\t * binary tree matchfinder and save them in match_cache.\n\t\t\t *\n\t\t\t * Note: the binary tree matchfinder is more suited for\n\t\t\t * optimal parsing than the hash chain matchfinder.  The\n\t\t\t * reasons for this include:\n\t\t\t *\n\t\t\t * - The binary tree matchfinder can find more matches\n\t\t\t *   in the same number of steps.\n\t\t\t * - One of the major advantages of hash chains is that\n\t\t\t *   skipping positions (not searching for matches at\n\t\t\t *   them) is faster; however, with optimal parsing we\n\t\t\t *   search for matches at almost all positions, so this\n\t\t\t *   advantage of hash chains is negated.\n\t\t\t */\n\t\t\tmatches = cache_ptr;\n\t\t\tbest_len = 0;\n\t\t\tadjust_max_and_nice_len(\u0026max_len, \u0026nice_len, remaining);\n\t\t\tif (likely(max_len \u003e= BT_MATCHFINDER_REQUIRED_NBYTES)) {\n\t\t\t\tcache_ptr = bt_matchfinder_get_matches(\n\t\t\t\t\t\t\u0026c-\u003ep.n.bt_mf,\n\t\t\t\t\t\tin_cur_base,\n\t\t\t\t\t\tin_next - in_cur_base,\n\t\t\t\t\t\tmax_len,\n\t\t\t\t\t\tnice_len,\n\t\t\t\t\t\tc-\u003emax_search_depth,\n\t\t\t\t\t\tnext_hashes,\n\t\t\t\t\t\tmatches);\n\t\t\t\tif (cache_ptr \u003e matches)\n\t\t\t\t\tbest_len = cache_ptr[-1].length;\n\t\t\t}\n\t\t\tif (in_next \u003e= next_observation) {\n\t\t\t\tif (best_len \u003e= min_len) {\n\t\t\t\t\tobserve_match(\u0026c-\u003esplit_stats,\n\t\t\t\t\t\t      best_len);\n\t\t\t\t\tnext_observation = in_next + best_len;\n\t\t\t\t\tc-\u003ep.n.new_match_len_freqs[best_len]++;\n\t\t\t\t} else {\n\t\t\t\t\tobserve_literal(\u0026c-\u003esplit_stats,\n\t\t\t\t\t\t\t*in_next);\n\t\t\t\t\tnext_observation = in_next + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcache_ptr-\u003elength = cache_ptr - matches;\n\t\t\tcache_ptr-\u003eoffset = *in_next;\n\t\t\tin_next++;\n\t\t\tcache_ptr++;\n\n\t\t\t/*\n\t\t\t * If there was a very long match found, don't cache any\n\t\t\t * matches for the bytes covered by that match.  This\n\t\t\t * avoids degenerate behavior when compressing highly\n\t\t\t * redundant data, where the number of matches can be\n\t\t\t * very large.\n\t\t\t *\n\t\t\t * This heuristic doesn't actually hurt the compression\n\t\t\t * ratio very much.  If there's a long match, then the\n\t\t\t * data must be highly compressible, so it doesn't\n\t\t\t * matter much what we do.\n\t\t\t */\n\t\t\tif (best_len \u003e= DEFLATE_MIN_MATCH_LEN \u0026\u0026\n\t\t\t    best_len \u003e= nice_len) {\n\t\t\t\t--best_len;\n\t\t\t\tdo {\n\t\t\t\t\tremaining = in_end - in_next;\n\t\t\t\t\tif (in_next == in_next_slide) {\n\t\t\t\t\t\tbt_matchfinder_slide_window(\n\t\t\t\t\t\t\t\u0026c-\u003ep.n.bt_mf);\n\t\t\t\t\t\tin_cur_base = in_next;\n\t\t\t\t\t\tin_next_slide = in_next +\n\t\t\t\t\t\t\tMIN(remaining,\n\t\t\t\t\t\t\t    MATCHFINDER_WINDOW_SIZE);\n\t\t\t\t\t}\n\t\t\t\t\tadjust_max_and_nice_len(\u0026max_len,\n\t\t\t\t\t\t\t\t\u0026nice_len,\n\t\t\t\t\t\t\t\tremaining);\n\t\t\t\t\tif (max_len \u003e=\n\t\t\t\t\t    BT_MATCHFINDER_REQUIRED_NBYTES) {\n\t\t\t\t\t\tbt_matchfinder_skip_byte(\n\t\t\t\t\t\t\t\u0026c-\u003ep.n.bt_mf,\n\t\t\t\t\t\t\tin_cur_base,\n\t\t\t\t\t\t\tin_next - in_cur_base,\n\t\t\t\t\t\t\tnice_len,\n\t\t\t\t\t\t\tc-\u003emax_search_depth,\n\t\t\t\t\t\t\tnext_hashes);\n\t\t\t\t\t}\n\t\t\t\t\tcache_ptr-\u003elength = 0;\n\t\t\t\t\tcache_ptr-\u003eoffset = *in_next;\n\t\t\t\t\tin_next++;\n\t\t\t\t\tcache_ptr++;\n\t\t\t\t} while (--best_len);\n\t\t\t}\n\t\t\t/* Maximum block length or end of input reached? */\n\t\t\tif (in_next \u003e= in_max_block_end)\n\t\t\t\tbreak;\n\t\t\t/* Match cache overflowed? */\n\t\t\tif (cache_ptr \u003e=\n\t\t\t    \u0026c-\u003ep.n.match_cache[MATCH_CACHE_LENGTH])\n\t\t\t\tbreak;\n\t\t\t/* Not ready to try to end the block (again)? */\n\t\t\tif (!ready_to_check_block(\u0026c-\u003esplit_stats,\n\t\t\t\t\t\t  in_block_begin, in_next,\n\t\t\t\t\t\t  in_end))\n\t\t\t\tcontinue;\n\t\t\t/* Check if it would be worthwhile to end the block. */\n\t\t\tif (do_end_block_check(\u0026c-\u003esplit_stats,\n\t\t\t\t\t       in_next - in_block_begin)) {\n\t\t\t\tchange_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Ending the block doesn't seem worthwhile here. */\n\t\t\tdeflate_near_optimal_merge_stats(c);\n\t\t\tprev_end_block_check = in_next;\n\t\t}\n\t\t/*\n\t\t * All the matches for this block have been cached.  Now choose\n\t\t * the precise end of the block and the sequence of items to\n\t\t * output to represent it, then flush the block.\n\t\t */\n\t\tif (change_detected \u0026\u0026 prev_end_block_check != NULL) {\n\t\t\t/*\n\t\t\t * The block is being ended because a recent chunk of\n\t\t\t * data differs from the rest of the block.  We could\n\t\t\t * end the block at 'in_next' like the greedy and lazy\n\t\t\t * compressors do, but that's not ideal since it would\n\t\t\t * include the differing chunk in the block.  The\n\t\t\t * near-optimal compressor has time to do a better job.\n\t\t\t * Therefore, we rewind to just before the chunk, and\n\t\t\t * output a block that only goes up to there.\n\t\t\t *\n\t\t\t * We then set things up to correctly start the next\n\t\t\t * block, considering that some work has already been\n\t\t\t * done on it (some matches found and stats gathered).\n\t\t\t */\n\t\t\tstruct lz_match *orig_cache_ptr = cache_ptr;\n\t\t\tconst u8 *in_block_end = prev_end_block_check;\n\t\t\tu32 block_length = in_block_end - in_block_begin;\n\t\t\tbool is_first = (in_block_begin == in);\n\t\t\tbool is_final = false;\n\t\t\tu32 num_bytes_to_rewind = in_next - in_block_end;\n\t\t\tsize_t cache_len_rewound;\n\n\t\t\t/* Rewind the match cache. */\n\t\t\tdo {\n\t\t\t\tcache_ptr--;\n\t\t\t\tcache_ptr -= cache_ptr-\u003elength;\n\t\t\t} while (--num_bytes_to_rewind);\n\t\t\tcache_len_rewound = orig_cache_ptr - cache_ptr;\n\n\t\t\tdeflate_optimize_block(c, in_block_begin, block_length,\n\t\t\t\t\t       cache_ptr, is_first, is_final);\n\t\t\tdeflate_flush_block(c, \u0026os, in_block_begin,\n\t\t\t\t\t    block_length, NULL, is_final);\n\t\t\tmemmove(c-\u003ep.n.match_cache, cache_ptr,\n\t\t\t\tcache_len_rewound * sizeof(*cache_ptr));\n\t\t\tcache_ptr = \u0026c-\u003ep.n.match_cache[cache_len_rewound];\n\t\t\tdeflate_near_optimal_save_stats(c);\n\t\t\t/*\n\t\t\t * Clear the stats for the just-flushed block, leaving\n\t\t\t * just the stats for the beginning of the next block.\n\t\t\t */\n\t\t\tdeflate_near_optimal_clear_old_stats(c);\n\t\t\tin_block_begin = in_block_end;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The block is being ended for a reason other than a\n\t\t\t * differing data chunk being detected.  Don't rewind at\n\t\t\t * all; just end the block at the current position.\n\t\t\t */\n\t\t\tu32 block_length = in_next - in_block_begin;\n\t\t\tbool is_first = (in_block_begin == in);\n\t\t\tbool is_final = (in_next == in_end);\n\n\t\t\tdeflate_near_optimal_merge_stats(c);\n\t\t\tdeflate_optimize_block(c, in_block_begin, block_length,\n\t\t\t\t\t       cache_ptr, is_first, is_final);\n\t\t\tdeflate_flush_block(c, \u0026os, in_block_begin,\n\t\t\t\t\t    block_length, NULL, is_final);\n\t\t\tcache_ptr = \u0026c-\u003ep.n.match_cache[0];\n\t\t\tdeflate_near_optimal_save_stats(c);\n\t\t\tdeflate_near_optimal_init_stats(c);\n\t\t\tin_block_begin = in_next;\n\t\t}\n\t} while (in_next != in_end);\n\n\treturn deflate_flush_output(\u0026os);\n}","filepath":"lib/deflate_compress.c","line_number":3355,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1788576":{"score":0.7700752,"function_name":"deflate_compress_near_optimal","code":"static size_t\ndeflate_compress_near_optimal(struct libdeflate_compressor * restrict c,\n\t\t\t      const u8 * restrict in, size_t in_nbytes,\n\t\t\t      u8 * restrict out, size_t out_nbytes_avail)\n{\n\tconst u8 *in_next = in;\n\tconst u8 *in_block_begin = in_next;\n\tconst u8 *in_end = in_next + in_nbytes;\n\tstruct deflate_output_bitstream os;\n\tconst u8 *in_cur_base = in_next;\n\tconst u8 *in_next_slide =\n\t\tin_next + MIN(in_end - in_next, MATCHFINDER_WINDOW_SIZE);\n\tunsigned max_len = DEFLATE_MAX_MATCH_LEN;\n\tunsigned nice_len = MIN(c-\u003enice_match_length, max_len);\n\tstruct lz_match *cache_ptr = c-\u003ep.n.match_cache;\n\tu32 next_hashes[2] = {0, 0};\n\n\tdeflate_init_output(\u0026os, out, out_nbytes_avail);\n\tbt_matchfinder_init(\u0026c-\u003ep.n.bt_mf);\n\tdeflate_near_optimal_init_stats(c);\n\n\tdo {\n\t\t/* Starting a new DEFLATE block */\n\t\tconst u8 * const in_max_block_end = choose_max_block_end(\n\t\t\t\tin_block_begin, in_end, SOFT_MAX_BLOCK_LENGTH);\n\t\tconst u8 *prev_end_block_check = NULL;\n\t\tbool change_detected = false;\n\t\tconst u8 *next_observation = in_next;\n\t\tunsigned min_len;\n\n\t\t/*\n\t\t * Use the minimum match length heuristic to improve the\n\t\t * literal/match statistics gathered during matchfinding.\n\t\t * However, the actual near-optimal parse won't respect min_len,\n\t\t * as it can accurately assess the costs of different matches.\n\t\t */\n\t\tmin_len = calculate_min_match_len(\n\t\t\t\t\tin_block_begin,\n\t\t\t\t\tin_max_block_end - in_block_begin,\n\t\t\t\t\tc-\u003emax_search_depth);\n\n\t\t/*\n\t\t * Find matches until we decide to end the block.  We end the\n\t\t * block if any of the following is true:\n\t\t *\n\t\t * (1) Maximum block length has been reached\n\t\t * (2) Match catch may overflow.\n\t\t * (3) Block split heuristic says to split now.\n\t\t */\n\t\tfor (;;) {\n\t\t\tstruct lz_match *matches;\n\t\t\tunsigned best_len;\n\t\t\tsize_t remaining = in_end - in_next;\n\n\t\t\t/* Slide the window forward if needed. */\n\t\t\tif (in_next == in_next_slide) {\n\t\t\t\tbt_matchfinder_slide_window(\u0026c-\u003ep.n.bt_mf);\n\t\t\t\tin_cur_base = in_next;\n\t\t\t\tin_next_slide = in_next +\n\t\t\t\t\tMIN(remaining, MATCHFINDER_WINDOW_SIZE);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find matches with the current position using the\n\t\t\t * binary tree matchfinder and save them in match_cache.\n\t\t\t *\n\t\t\t * Note: the binary tree matchfinder is more suited for\n\t\t\t * optimal parsing than the hash chain matchfinder.  The\n\t\t\t * reasons for this include:\n\t\t\t *\n\t\t\t * - The binary tree matchfinder can find more matches\n\t\t\t *   in the same number of steps.\n\t\t\t * - One of the major advantages of hash chains is that\n\t\t\t *   skipping positions (not searching for matches at\n\t\t\t *   them) is faster; however, with optimal parsing we\n\t\t\t *   search for matches at almost all positions, so this\n\t\t\t *   advantage of hash chains is negated.\n\t\t\t */\n\t\t\tmatches = cache_ptr;\n\t\t\tbest_len = 0;\n\t\t\tadjust_max_and_nice_len(\u0026max_len, \u0026nice_len, remaining);\n\t\t\tif (likely(max_len \u003e= BT_MATCHFINDER_REQUIRED_NBYTES)) {\n\t\t\t\tcache_ptr = bt_matchfinder_get_matches(\n\t\t\t\t\t\t\u0026c-\u003ep.n.bt_mf,\n\t\t\t\t\t\tin_cur_base,\n\t\t\t\t\t\tin_next - in_cur_base,\n\t\t\t\t\t\tmax_len,\n\t\t\t\t\t\tnice_len,\n\t\t\t\t\t\tc-\u003emax_search_depth,\n\t\t\t\t\t\tnext_hashes,\n\t\t\t\t\t\tmatches);\n\t\t\t\tif (cache_ptr \u003e matches)\n\t\t\t\t\tbest_len = cache_ptr[-1].length;\n\t\t\t}\n\t\t\tif (in_next \u003e= next_observation) {\n\t\t\t\tif (best_len \u003e= min_len) {\n\t\t\t\t\tobserve_match(\u0026c-\u003esplit_stats,\n\t\t\t\t\t\t      best_len);\n\t\t\t\t\tnext_observation = in_next + best_len;\n\t\t\t\t\tc-\u003ep.n.new_match_len_freqs[best_len]++;\n\t\t\t\t} else {\n\t\t\t\t\tobserve_literal(\u0026c-\u003esplit_stats,\n\t\t\t\t\t\t\t*in_next);\n\t\t\t\t\tnext_observation = in_next + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcache_ptr-\u003elength = cache_ptr - matches;\n\t\t\tcache_ptr-\u003eoffset = *in_next;\n\t\t\tin_next++;\n\t\t\tcache_ptr++;\n\n\t\t\t/*\n\t\t\t * If there was a very long match found, don't cache any\n\t\t\t * matches for the bytes covered by that match.  This\n\t\t\t * avoids degenerate behavior when compressing highly\n\t\t\t * redundant data, where the number of matches can be\n\t\t\t * very large.\n\t\t\t *\n\t\t\t * This heuristic doesn't actually hurt the compression\n\t\t\t * ratio very much.  If there's a long match, then the\n\t\t\t * data must be highly compressible, so it doesn't\n\t\t\t * matter much what we do.\n\t\t\t */\n\t\t\tif (best_len \u003e= DEFLATE_MIN_MATCH_LEN \u0026\u0026\n\t\t\t    best_len \u003e= nice_len) {\n\t\t\t\t--best_len;\n\t\t\t\tdo {\n\t\t\t\t\tremaining = in_end - in_next;\n\t\t\t\t\tif (in_next == in_next_slide) {\n\t\t\t\t\t\tbt_matchfinder_slide_window(\n\t\t\t\t\t\t\t\u0026c-\u003ep.n.bt_mf);\n\t\t\t\t\t\tin_cur_base = in_next;\n\t\t\t\t\t\tin_next_slide = in_next +\n\t\t\t\t\t\t\tMIN(remaining,\n\t\t\t\t\t\t\t    MATCHFINDER_WINDOW_SIZE);\n\t\t\t\t\t}\n\t\t\t\t\tadjust_max_and_nice_len(\u0026max_len,\n\t\t\t\t\t\t\t\t\u0026nice_len,\n\t\t\t\t\t\t\t\tremaining);\n\t\t\t\t\tif (max_len \u003e=\n\t\t\t\t\t    BT_MATCHFINDER_REQUIRED_NBYTES) {\n\t\t\t\t\t\tbt_matchfinder_skip_byte(\n\t\t\t\t\t\t\t\u0026c-\u003ep.n.bt_mf,\n\t\t\t\t\t\t\tin_cur_base,\n\t\t\t\t\t\t\tin_next - in_cur_base,\n\t\t\t\t\t\t\tnice_len,\n\t\t\t\t\t\t\tc-\u003emax_search_depth,\n\t\t\t\t\t\t\tnext_hashes);\n\t\t\t\t\t}\n\t\t\t\t\tcache_ptr-\u003elength = 0;\n\t\t\t\t\tcache_ptr-\u003eoffset = *in_next;\n\t\t\t\t\tin_next++;\n\t\t\t\t\tcache_ptr++;\n\t\t\t\t} while (--best_len);\n\t\t\t}\n\t\t\t/* Maximum block length or end of input reached? */\n\t\t\tif (in_next \u003e= in_max_block_end)\n\t\t\t\tbreak;\n\t\t\t/* Match cache overflowed? */\n\t\t\tif (cache_ptr \u003e=\n\t\t\t    \u0026c-\u003ep.n.match_cache[MATCH_CACHE_LENGTH])\n\t\t\t\tbreak;\n\t\t\t/* Not ready to try to end the block (again)? */\n\t\t\tif (!ready_to_check_block(\u0026c-\u003esplit_stats,\n\t\t\t\t\t\t  in_block_begin, in_next,\n\t\t\t\t\t\t  in_end))\n\t\t\t\tcontinue;\n\t\t\t/* Check if it would be worthwhile to end the block. */\n\t\t\tif (do_end_block_check(\u0026c-\u003esplit_stats,\n\t\t\t\t\t       in_next - in_block_begin)) {\n\t\t\t\tchange_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Ending the block doesn't seem worthwhile here. */\n\t\t\tdeflate_near_optimal_merge_stats(c);\n\t\t\tprev_end_block_check = in_next;\n\t\t}\n\t\t/*\n\t\t * All the matches for this block have been cached.  Now choose\n\t\t * the precise end of the block and the sequence of items to\n\t\t * output to represent it, then flush the block.\n\t\t */\n\t\tif (change_detected \u0026\u0026 prev_end_block_check != NULL) {\n\t\t\t/*\n\t\t\t * The block is being ended because a recent chunk of\n\t\t\t * data differs from the rest of the block.  We could\n\t\t\t * end the block at 'in_next' like the greedy and lazy\n\t\t\t * compressors do, but that's not ideal since it would\n\t\t\t * include the differing chunk in the block.  The\n\t\t\t * near-optimal compressor has time to do a better job.\n\t\t\t * Therefore, we rewind to just before the chunk, and\n\t\t\t * output a block that only goes up to there.\n\t\t\t *\n\t\t\t * We then set things up to correctly start the next\n\t\t\t * block, considering that some work has already been\n\t\t\t * done on it (some matches found and stats gathered).\n\t\t\t */\n\t\t\tstruct lz_match *orig_cache_ptr = cache_ptr;\n\t\t\tconst u8 *in_block_end = prev_end_block_check;\n\t\t\tu32 block_length = in_block_end - in_block_begin;\n\t\t\tbool is_first = (in_block_begin == in);\n\t\t\tbool is_final = false;\n\t\t\tu32 num_bytes_to_rewind = in_next - in_block_end;\n\t\t\tsize_t cache_len_rewound;\n\n\t\t\t/* Rewind the match cache. */\n\t\t\tdo {\n\t\t\t\tcache_ptr--;\n\t\t\t\tcache_ptr -= cache_ptr-\u003elength;\n\t\t\t} while (--num_bytes_to_rewind);\n\t\t\tcache_len_rewound = orig_cache_ptr - cache_ptr;\n\n\t\t\tdeflate_optimize_block(c, in_block_begin, block_length,\n\t\t\t\t\t       cache_ptr, is_first, is_final);\n\t\t\tdeflate_flush_block(c, \u0026os, in_block_begin,\n\t\t\t\t\t    block_length, NULL, is_final);\n\t\t\tmemmove(c-\u003ep.n.match_cache, cache_ptr,\n\t\t\t\tcache_len_rewound * sizeof(*cache_ptr));\n\t\t\tcache_ptr = \u0026c-\u003ep.n.match_cache[cache_len_rewound];\n\t\t\tdeflate_near_optimal_save_stats(c);\n\t\t\t/*\n\t\t\t * Clear the stats for the just-flushed block, leaving\n\t\t\t * just the stats for the beginning of the next block.\n\t\t\t */\n\t\t\tdeflate_near_optimal_clear_old_stats(c);\n\t\t\tin_block_begin = in_block_end;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The block is being ended for a reason other than a\n\t\t\t * differing data chunk being detected.  Don't rewind at\n\t\t\t * all; just end the block at the current position.\n\t\t\t */\n\t\t\tu32 block_length = in_next - in_block_begin;\n\t\t\tbool is_first = (in_block_begin == in);\n\t\t\tbool is_final = (in_next == in_end);\n\n\t\t\tdeflate_near_optimal_merge_stats(c);\n\t\t\tdeflate_optimize_block(c, in_block_begin, block_length,\n\t\t\t\t\t       cache_ptr, is_first, is_final);\n\t\t\tdeflate_flush_block(c, \u0026os, in_block_begin,\n\t\t\t\t\t    block_length, NULL, is_final);\n\t\t\tcache_ptr = \u0026c-\u003ep.n.match_cache[0];\n\t\t\tdeflate_near_optimal_save_stats(c);\n\t\t\tdeflate_near_optimal_init_stats(c);\n\t\t\tin_block_begin = in_next;\n\t\t}\n\t} while (in_next != in_end);\n\n\treturn deflate_flush_output(\u0026os);\n}","filepath":"lib/deflate_compress.c","line_number":3355,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1814176":{"score":0.81331813,"function_name":"libdeflate_deflate_compress","code":"LIBDEFLATEAPI\nlibdeflate_deflate_compress(struct libdeflate_compressor *c,\n\t\t\t    const void *in, size_t in_nbytes,\n\t\t\t    void *out, size_t out_nbytes_avail)\n{\n\tif (unlikely(out_nbytes_avail \u003c OUTPUT_END_PADDING))\n\t\treturn 0;\n\n\t/* For extremely small inputs, just use a single uncompressed block. */\n\tif (unlikely(in_nbytes \u003c c-\u003emin_size_to_compress)) {\n\t\tstruct deflate_output_bitstream os;\n\t\tdeflate_init_output(\u0026os, out, out_nbytes_avail);\n\t\tif (in_nbytes == 0)\n\t\t\tin = \u0026os; /* Avoid passing NULL to memcpy(). */\n\t\tdeflate_write_uncompressed_block(\u0026os, in, in_nbytes, true);\n\t\treturn deflate_flush_output(\u0026os);\n\t}\n\n\treturn (*c-\u003eimpl)(c, in, in_nbytes, out, out_nbytes_avail);\n}","filepath":"lib/deflate_compress.c","line_number":3746,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1814480":{"score":0.77191794,"function_name":"libdeflate_deflate_compress_bound","code":"LIBDEFLATEAPI\nlibdeflate_deflate_compress_bound(struct libdeflate_compressor *c,\n\t\t\t\t  size_t in_nbytes)\n{\n\t/*\n\t * The worst case is all uncompressed blocks where one block has length\n\t * \u003c= MIN_BLOCK_LENGTH and the others have length MIN_BLOCK_LENGTH.\n\t * Each uncompressed block has 5 bytes of overhead: 1 for BFINAL, BTYPE,\n\t * and alignment to a byte boundary; 2 for LEN; and 2 for NLEN.\n\t */\n\tsize_t max_num_blocks =\n\t\tMAX(DIV_ROUND_UP(in_nbytes, MIN_BLOCK_LENGTH), 1);\n\n\treturn (5 * max_num_blocks) + in_nbytes + 1 + OUTPUT_END_PADDING;\n}","filepath":"lib/deflate_compress.c","line_number":3779,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"1833760":{"score":0.6753144,"function_name":"deflate_near_optimal_save_stats","code":"static void\ndeflate_near_optimal_save_stats(struct libdeflate_compressor *c)\n{\n\tint i;\n\n\tfor (i = 0; i \u003c NUM_OBSERVATION_TYPES; i++)\n\t\tc-\u003ep.n.prev_observations[i] = c-\u003esplit_stats.observations[i];\n\tc-\u003ep.n.prev_num_observations = c-\u003esplit_stats.num_observations;\n}","filepath":"lib/deflate_compress.c","line_number":3321,"entry_url":"https://github.com/ebiggers/libdeflate.git","slot_name":"v1.10"},"2361680":{"score":0.80651283,"function_name":"XXH32","code":"int XXH32 (const void* input, size_t len, unsigned int seed)\n{\n#if 0\n\t/* Simple version, good for code maintenance, but unfortunately slow for small inputs */\n\tXXH32_CREATESTATE_STATIC(state);\n\tXXH32_reset(state, seed);\n\tXXH32_update(state, input, len);\n\treturn XXH32_digest(state);\n#else\n\tXXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;\n\n\tif (XXH_FORCE_ALIGN_CHECK) {\n\t\tif ((((size_t)input) \u0026 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */\n\t\t\tif ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)\n\t\t\t\treturn XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);\n\t\t\telse\n\t\t\t\treturn XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);\n\t}   }\n\n\tif ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)\n\t\treturn XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);\n\telse\n\t\treturn XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);\n#endif\n}","filepath":"contrib/linux-kernel/lib/zstd/xxhash.c","line_number":248,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.2.0"},"2362400":{"score":0.8431628,"function_name":"XXH32_reset","code":"XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, unsigned int seed)\n{\n\tXXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */\n\tmemset(\u0026state, 0, sizeof(state)-4);   /* do not write into reserved, for future removal */\n\tstate.v1 = seed + PRIME32_1 + PRIME32_2;\n\tstate.v2 = seed + PRIME32_2;\n\tstate.v3 = seed + 0;\n\tstate.v4 = seed - PRIME32_1;\n\tmemcpy(statePtr, \u0026state, sizeof(state));\n\treturn XXH_OK;\n}","filepath":"contrib/linux-kernel/lib/zstd/xxhash.c","line_number":394,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.2.0"},"2363168":{"score":0.7094806,"function_name":"XXH32_digest","code":"int XXH32_digest (const XXH32_state_t* state_in)\n{\n\tXXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;\n\n\tif ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)\n\t\treturn XXH32_digest_endian(state_in, XXH_littleEndian);\n\telse\n\t\treturn XXH32_digest_endian(state_in, XXH_bigEndian);\n}","filepath":"contrib/linux-kernel/lib/zstd/xxhash.c","line_number":526,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.2.0"},"2363744":{"score":0.7604727,"function_name":"XXH64","code":"long long XXH64 (const void* input, size_t len, unsigned long long seed)\n{\n#if 0\n\t/* Simple version, good for code maintenance, but unfortunately slow for small inputs */\n\tXXH64_CREATESTATE_STATIC(state);\n\tXXH64_reset(state, seed);\n\tXXH64_update(state, input, len);\n\treturn XXH64_digest(state);\n#else\n\tXXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;\n\n\tif (XXH_FORCE_ALIGN_CHECK) {\n\t\tif ((((size_t)input) \u0026 7)==0) {  /* Input is aligned, let's leverage the speed advantage */\n\t\t\tif ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)\n\t\t\t\treturn XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);\n\t\t\telse\n\t\t\t\treturn XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);\n\t}   }\n\n\tif ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)\n\t\treturn XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);\n\telse\n\t\treturn XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);\n#endif\n}","filepath":"contrib/linux-kernel/lib/zstd/xxhash.c","line_number":360,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.2.0"},"2364256":{"score":0.7737364,"function_name":"XXH64_reset","code":"XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, unsigned long long seed)\n{\n\tXXH64_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */\n\tmemset(\u0026state, 0, sizeof(state)-8);   /* do not write into reserved, for future removal */\n\tstate.v1 = seed + PRIME64_1 + PRIME64_2;\n\tstate.v2 = seed + PRIME64_2;\n\tstate.v3 = seed + 0;\n\tstate.v4 = seed - PRIME64_1;\n\tmemcpy(statePtr, \u0026state, sizeof(state));\n\treturn XXH_OK;\n}","filepath":"contrib/linux-kernel/lib/zstd/xxhash.c","line_number":407,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.2.0"},"2365040":{"score":0.7019133,"function_name":"XXH64_digest","code":"long long XXH64_digest (const XXH64_state_t* state_in)\n{\n\tXXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;\n\n\tif ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)\n\t\treturn XXH64_digest_endian(state_in, XXH_littleEndian);\n\telse\n\t\treturn XXH64_digest_endian(state_in, XXH_bigEndian);\n}","filepath":"contrib/linux-kernel/lib/zstd/xxhash.c","line_number":659,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.2.0"},"2371120":{"score":0.56522065,"function_name":"Arithmetic_Codec::put_bit","code":"void Arithmetic_Codec::put_bit(unsigned bit)\r\n{\r\n#ifdef _DEBUG\r\n  if (mode != 1) AC_Error(\"encoder not initialized\");\r\n#endif\r\n\r\n  length \u003e\u003e= 1;                                              // halve interval\r\n  if (bit) {\r\n    unsigned init_base = base;\r\n    base += length;                                               // move base\r\n    if (init_base \u003e base) propagate_carry();               // overflow = carry\r\n  }\r\n\r\n  if (length \u003c AC__MinLength) renorm_enc_interval();        // renormalization\r\n}","filepath":"fastac/arithmetic_codec.cpp","line_number":108,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"2371264":{"score":0.55804557,"function_name":"Arithmetic_Codec::encode","code":"void Arithmetic_Codec::encode(unsigned bit,\r\n                              Static_Bit_Model \u0026 M)\r\n{\r\n#ifdef _DEBUG\r\n  if (mode != 1) AC_Error(\"encoder not initialized\");\r\n#endif\r\n\r\n  unsigned x = M.bit_0_prob * (length \u003e\u003e BM__LengthShift);   // product l x p0\r\n                                                            // update interval\r\n  if (bit == 0)\r\n    length  = x;\r\n  else {\r\n    unsigned init_base = base;\r\n    base   += x;\r\n    length -= x;\r\n    if (init_base \u003e base) propagate_carry();               // overflow = carry\r\n  }\r\n\r\n  if (length \u003c AC__MinLength) renorm_enc_interval();        // renormalization\r\n}","filepath":"fastac/arithmetic_codec.cpp","line_number":177,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"2373472":{"score":0.561815,"function_name":"Arithmetic_Codec::decode","code":"unsigned Arithmetic_Codec::decode(Adaptive_Bit_Model \u0026 M)\r\n{\r\n#ifdef _DEBUG\r\n  if (mode != 2) AC_Error(\"decoder not initialized\");\r\n#endif\r\n\r\n  unsigned x = M.bit_0_prob * (length \u003e\u003e BM__LengthShift);   // product l x p0\r\n  unsigned bit = (value \u003e= x);                                     // decision\r\n                                                            // update interval\r\n  if (bit == 0) {\r\n    length = x;\r\n    ++M.bit_0_count;\r\n  }\r\n  else {\r\n    value  -= x;\r\n    length -= x;\r\n  }\r\n\r\n  if (length \u003c AC__MinLength) renorm_dec_interval();        // renormalization\r\n\r\n  if (--M.bits_until_update == 0) M.update();         // periodic model update\r\n\r\n  return bit;                                         // return data bit value\r\n}","filepath":"fastac/arithmetic_codec.cpp","line_number":250,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"2406000":{"score":0.6100617,"function_name":"Adaptive_Bit_Model::update","code":"void Adaptive_Bit_Model::update(void)\r\n{\r\n                                   // halve counts when a threshold is reached\r\n\r\n  if ((bit_count += update_cycle) \u003e BM__MaxCount) {\r\n    bit_count = (bit_count + 1) \u003e\u003e 1;\r\n    bit_0_count = (bit_0_count + 1) \u003e\u003e 1;\r\n    if (bit_0_count == bit_count) ++bit_count;\r\n  }\r\n                                           // compute scaled bit 0 probability\r\n  unsigned scale = 0x80000000U / bit_count;\r\n  bit_0_prob = (bit_0_count * scale) \u003e\u003e (31 - BM__LengthShift);\r\n\r\n                                             // set frequency of model updates\r\n  update_cycle = (5 * update_cycle) \u003e\u003e 2;\r\n  if (update_cycle \u003e 64) update_cycle = 64;\r\n  bits_until_update = update_cycle;\r\n}","filepath":"fastac/arithmetic_codec.cpp","line_number":640,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"2406624":{"score":0.59413767,"function_name":"ZSTD_reset_compressedBlockState","code":"void ZSTD_reset_compressedBlockState(ZSTD_compressedBlockState_t* bs)\n{\n    int i;\n    for (i = 0; i \u003c ZSTD_REP_NUM; ++i)\n        bs-\u003erep[i] = repStartValue[i];\n    bs-\u003eentropy.huf.repeatMode = HUF_repeat_none;\n    bs-\u003eentropy.fse.offcode_repeatMode = FSE_repeat_none;\n    bs-\u003eentropy.fse.matchlength_repeatMode = FSE_repeat_none;\n    bs-\u003eentropy.fse.litlength_repeatMode = FSE_repeat_none;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1510,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2407456":{"score":0.5899839,"function_name":"ZSTD_reset_compressedBlockState","code":"void ZSTD_reset_compressedBlockState(ZSTD_compressedBlockState_t* bs)\n{\n    int i;\n    for (i = 0; i \u003c ZSTD_REP_NUM; ++i)\n        bs-\u003erep[i] = repStartValue[i];\n    bs-\u003eentropy.huf.repeatMode = HUF_repeat_none;\n    bs-\u003eentropy.fse.offcode_repeatMode = FSE_repeat_none;\n    bs-\u003eentropy.fse.matchlength_repeatMode = FSE_repeat_none;\n    bs-\u003eentropy.fse.litlength_repeatMode = FSE_repeat_none;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1510,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2411616":{"score":0.6236059,"function_name":"ZSTD_compressBegin_advanced","code":"size_t ZSTD_compressBegin_advanced(ZSTD_CCtx* cctx,\n                             const void* dict, size_t dictSize,\n                                   ZSTD_parameters params, unsigned long long pledgedSrcSize)\n{\n    ZSTD_CCtx_params cctxParams;\n    ZSTD_CCtxParams_init_internal(\u0026cctxParams, \u0026params, ZSTD_NO_CLEVEL);\n    return ZSTD_compressBegin_advanced_internal(cctx,\n                                            dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast,\n                                            NULL /*cdict*/,\n                                            \u0026cctxParams, pledgedSrcSize);\n}","filepath":"lib/compress/zstd_compress.c","line_number":3472,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2414064":{"score":0.5544504,"function_name":"ZSTD_CCtxParams_setZstdParams","code":"static void ZSTD_CCtxParams_setZstdParams(\n        ZSTD_CCtx_params* cctxParams, const ZSTD_parameters* params)\n{\n    assert(!ZSTD_checkCParams(params-\u003ecParams));\n    cctxParams-\u003ecParams = params-\u003ecParams;\n    cctxParams-\u003efParams = params-\u003efParams;\n    /* Should not matter, as all cParams are presumed properly defined.\n     * But, set it for tracing anyway.\n     */\n    cctxParams-\u003ecompressionLevel = ZSTD_NO_CLEVEL;\n}","filepath":"lib/compress/zstd_compress.c","line_number":302,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2419056":{"score":0.80883986,"function_name":"ZSTD_writeFrameHeader","code":"static size_t ZSTD_writeFrameHeader(void* dst, size_t dstCapacity,\n                                    const ZSTD_CCtx_params* params, U64 pledgedSrcSize, U32 dictID)\n{   BYTE* const op = (BYTE*)dst;\n    U32   const dictIDSizeCodeLength = (dictID\u003e0) + (dictID\u003e=256) + (dictID\u003e=65536);   /* 0-3 */\n    U32   const dictIDSizeCode = params-\u003efParams.noDictIDFlag ? 0 : dictIDSizeCodeLength;   /* 0-3 */\n    U32   const checksumFlag = params-\u003efParams.checksumFlag\u003e0;\n    U32   const windowSize = (U32)1 \u003c\u003c params-\u003ecParams.windowLog;\n    U32   const singleSegment = params-\u003efParams.contentSizeFlag \u0026\u0026 (windowSize \u003e= pledgedSrcSize);\n    BYTE  const windowLogByte = (BYTE)((params-\u003ecParams.windowLog - ZSTD_WINDOWLOG_ABSOLUTEMIN) \u003c\u003c 3);\n    U32   const fcsCode = params-\u003efParams.contentSizeFlag ?\n                     (pledgedSrcSize\u003e=256) + (pledgedSrcSize\u003e=65536+256) + (pledgedSrcSize\u003e=0xFFFFFFFFU) : 0;  /* 0-3 */\n    BYTE  const frameHeaderDescriptionByte = (BYTE)(dictIDSizeCode + (checksumFlag\u003c\u003c2) + (singleSegment\u003c\u003c5) + (fcsCode\u003c\u003c6) );\n    size_t pos=0;\n\n    assert(!(params-\u003efParams.contentSizeFlag \u0026\u0026 pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN));\n    RETURN_ERROR_IF(dstCapacity \u003c ZSTD_FRAMEHEADERSIZE_MAX, dstSize_tooSmall,\n                    \"dst buf is too small to fit worst-case frame header size.\");\n    DEBUGLOG(4, \"ZSTD_writeFrameHeader : dictIDFlag : %u ; dictID : %u ; dictIDSizeCode : %u\",\n                !params-\u003efParams.noDictIDFlag, (unsigned)dictID, (unsigned)dictIDSizeCode);\n    if (params-\u003eformat == ZSTD_f_zstd1) {\n        MEM_writeLE32(dst, ZSTD_MAGICNUMBER);\n        pos = 4;\n    }\n    op[pos++] = frameHeaderDescriptionByte;\n    if (!singleSegment) op[pos++] = windowLogByte;\n    switch(dictIDSizeCode)\n    {\n        default:\n            assert(0); /* impossible */\n            ZSTD_FALLTHROUGH;\n        case 0 : break;\n        case 1 : op[pos] = (BYTE)(dictID); pos++; break;\n        case 2 : MEM_writeLE16(op+pos, (U16)dictID); pos+=2; break;\n        case 3 : MEM_writeLE32(op+pos, dictID); pos+=4; break;\n    }\n    switch(fcsCode)\n    {\n        default:\n            assert(0); /* impossible */\n            ZSTD_FALLTHROUGH;\n        case 0 : if (singleSegment) op[pos++] = (BYTE)(pledgedSrcSize); break;\n        case 1 : MEM_writeLE16(op+pos, (U16)(pledgedSrcSize-256)); pos+=2; break;\n        case 2 : MEM_writeLE32(op+pos, (U32)(pledgedSrcSize)); pos+=4; break;\n        case 3 : MEM_writeLE64(op+pos, (U64)(pledgedSrcSize)); pos+=8; break;\n    }\n    return pos;\n}","filepath":"lib/compress/zstd_compress.c","line_number":2953,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2419568":{"score":0.75691164,"function_name":"ZSTD_adjustCParams_internal","code":"static ZSTD_compressionParameters\nZSTD_adjustCParams_internal(ZSTD_compressionParameters cPar,\n                            unsigned long long srcSize,\n                            size_t dictSize,\n                            ZSTD_cParamMode_e mode)\n{\n    const U64 minSrcSize = 513; /* (1\u003c\u003c9) + 1 */\n    const U64 maxWindowResize = 1ULL \u003c\u003c (ZSTD_WINDOWLOG_MAX-1);\n    assert(ZSTD_checkCParams(cPar)==0);\n\n    switch (mode) {\n    case ZSTD_cpm_unknown:\n    case ZSTD_cpm_noAttachDict:\n        /* If we don't know the source size, don't make any\n         * assumptions about it. We will already have selected\n         * smaller parameters if a dictionary is in use.\n         */\n        break;\n    case ZSTD_cpm_createCDict:\n        /* Assume a small source size when creating a dictionary\n         * with an unkown source size.\n         */\n        if (dictSize \u0026\u0026 srcSize == ZSTD_CONTENTSIZE_UNKNOWN)\n            srcSize = minSrcSize;\n        break;\n    case ZSTD_cpm_attachDict:\n        /* Dictionary has its own dedicated parameters which have\n         * already been selected. We are selecting parameters\n         * for only the source.\n         */\n        dictSize = 0;\n        break;\n    default:\n        assert(0);\n        break;\n    }\n\n    /* resize windowLog if input is small enough, to use less memory */\n    if ( (srcSize \u003c maxWindowResize)\n      \u0026\u0026 (dictSize \u003c maxWindowResize) )  {\n        U32 const tSize = (U32)(srcSize + dictSize);\n        static U32 const hashSizeMin = 1 \u003c\u003c ZSTD_HASHLOG_MIN;\n        U32 const srcLog = (tSize \u003c hashSizeMin) ? ZSTD_HASHLOG_MIN :\n                            ZSTD_highbit32(tSize-1) + 1;\n        if (cPar.windowLog \u003e srcLog) cPar.windowLog = srcLog;\n    }\n    if (srcSize != ZSTD_CONTENTSIZE_UNKNOWN) {\n        U32 const dictAndWindowLog = ZSTD_dictAndWindowLog(cPar.windowLog, (U64)srcSize, (U64)dictSize);\n        U32 const cycleLog = ZSTD_cycleLog(cPar.chainLog, cPar.strategy);\n        if (cPar.hashLog \u003e dictAndWindowLog+1) cPar.hashLog = dictAndWindowLog+1;\n        if (cycleLog \u003e dictAndWindowLog)\n            cPar.chainLog -= (cycleLog - dictAndWindowLog);\n    }\n\n    if (cPar.windowLog \u003c ZSTD_WINDOWLOG_ABSOLUTEMIN)\n        cPar.windowLog = ZSTD_WINDOWLOG_ABSOLUTEMIN;  /* minimum wlog required for valid frame header */\n\n    return cPar;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1198,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2419936":{"score":0.8215138,"function_name":"ZSTD_buildSeqStore","code":"static size_t ZSTD_buildSeqStore(ZSTD_CCtx* zc, const void* src, size_t srcSize)\n{\n    ZSTD_matchState_t* const ms = \u0026zc-\u003eblockState.matchState;\n    DEBUGLOG(5, \"ZSTD_buildSeqStore (srcSize=%zu)\", srcSize);\n    assert(srcSize \u003c= ZSTD_BLOCKSIZE_MAX);\n    /* Assert that we have correctly flushed the ctx params into the ms's copy */\n    ZSTD_assertEqualCParams(zc-\u003eappliedParams.cParams, ms-\u003ecParams);\n    if (srcSize \u003c MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1) {\n        if (zc-\u003eappliedParams.cParams.strategy \u003e= ZSTD_btopt) {\n            ZSTD_ldm_skipRawSeqStoreBytes(\u0026zc-\u003eexternSeqStore, srcSize);\n        } else {\n            ZSTD_ldm_skipSequences(\u0026zc-\u003eexternSeqStore, srcSize, zc-\u003eappliedParams.cParams.minMatch);\n        }\n        return ZSTDbss_noCompress; /* don't even attempt compression below a certain srcSize */\n    }\n    ZSTD_resetSeqStore(\u0026(zc-\u003eseqStore));\n    /* required for optimal parser to read stats from dictionary */\n    ms-\u003eopt.symbolCosts = \u0026zc-\u003eblockState.prevCBlock-\u003eentropy;\n    /* tell the optimal parser how we expect to compress literals */\n    ms-\u003eopt.literalCompressionMode = zc-\u003eappliedParams.literalCompressionMode;\n    /* a gap between an attached dict and the current window is not safe,\n     * they must remain adjacent,\n     * and when that stops being the case, the dict must be unset */\n    assert(ms-\u003edictMatchState == NULL || ms-\u003eloadedDictEnd == ms-\u003ewindow.dictLimit);\n\n    /* limited update after a very long match */\n    {   const BYTE* const base = ms-\u003ewindow.base;\n        const BYTE* const istart = (const BYTE*)src;\n        const U32 curr = (U32)(istart-base);\n        if (sizeof(ptrdiff_t)==8) assert(istart - base \u003c (ptrdiff_t)(U32)(-1));   /* ensure no overflow */\n        if (curr \u003e ms-\u003enextToUpdate + 384)\n            ms-\u003enextToUpdate = curr - MIN(192, (U32)(curr - ms-\u003enextToUpdate - 384));\n    }\n\n    /* select and store sequences */\n    {   ZSTD_dictMode_e const dictMode = ZSTD_matchState_dictMode(ms);\n        size_t lastLLSize;\n        {   int i;\n            for (i = 0; i \u003c ZSTD_REP_NUM; ++i)\n                zc-\u003eblockState.nextCBlock-\u003erep[i] = zc-\u003eblockState.prevCBlock-\u003erep[i];\n        }\n        if (zc-\u003eexternSeqStore.pos \u003c zc-\u003eexternSeqStore.size) {\n            assert(!zc-\u003eappliedParams.ldmParams.enableLdm);\n            /* Updates ldmSeqStore.pos */\n            lastLLSize =\n                ZSTD_ldm_blockCompress(\u0026zc-\u003eexternSeqStore,\n                                       ms, \u0026zc-\u003eseqStore,\n                                       zc-\u003eblockState.nextCBlock-\u003erep,\n                                       src, srcSize);\n            assert(zc-\u003eexternSeqStore.pos \u003c= zc-\u003eexternSeqStore.size);\n        } else if (zc-\u003eappliedParams.ldmParams.enableLdm) {\n            rawSeqStore_t ldmSeqStore = kNullRawSeqStore;\n\n            ldmSeqStore.seq = zc-\u003eldmSequences;\n            ldmSeqStore.capacity = zc-\u003emaxNbLdmSequences;\n            /* Updates ldmSeqStore.size */\n            FORWARD_IF_ERROR(ZSTD_ldm_generateSequences(\u0026zc-\u003eldmState, \u0026ldmSeqStore,\n                                               \u0026zc-\u003eappliedParams.ldmParams,\n                                               src, srcSize), \"\");\n            /* Updates ldmSeqStore.pos */\n            lastLLSize =\n                ZSTD_ldm_blockCompress(\u0026ldmSeqStore,\n                                       ms, \u0026zc-\u003eseqStore,\n                                       zc-\u003eblockState.nextCBlock-\u003erep,\n                                       src, srcSize);\n            assert(ldmSeqStore.pos == ldmSeqStore.size);\n        } else {   /* not long range mode */\n            ZSTD_blockCompressor const blockCompressor = ZSTD_selectBlockCompressor(zc-\u003eappliedParams.cParams.strategy, dictMode);\n            ms-\u003eldmSeqStore = NULL;\n            lastLLSize = blockCompressor(ms, \u0026zc-\u003eseqStore, zc-\u003eblockState.nextCBlock-\u003erep, src, srcSize);\n        }\n        {   const BYTE* const lastLiterals = (const BYTE*)src + srcSize - lastLLSize;\n            ZSTD_storeLastLiterals(\u0026zc-\u003eseqStore, lastLiterals, lastLLSize);\n    }   }\n    return ZSTDbss_compress;\n}","filepath":"lib/compress/zstd_compress.c","line_number":2482,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2420672":{"score":0.8790645,"function_name":"ZSTD_isRLE","code":"static int ZSTD_isRLE(const BYTE* src, size_t length) {\n    const BYTE* ip = src;\n    const BYTE value = ip[0];\n    const size_t valueST = (size_t)((U64)value * 0x0101010101010101ULL);\n    const size_t unrollSize = sizeof(size_t) * 4;\n    const size_t unrollMask = unrollSize - 1;\n    const size_t prefixLength = length \u0026 unrollMask;\n    size_t i;\n    size_t u;\n    if (length == 1) return 1;\n    /* Check if prefix is RLE first before using unrolled loop */\n    if (prefixLength \u0026\u0026 ZSTD_count(ip+1, ip, ip+prefixLength) != prefixLength-1) {\n        return 0;\n    }\n    for (i = prefixLength; i != length; i += unrollSize) {\n        for (u = 0; u \u003c unrollSize; u += sizeof(size_t)) {\n            if (MEM_readST(ip + i + u) != valueST) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}","filepath":"lib/compress/zstd_compress.c","line_number":2660,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2422656":{"score":0.7933098,"function_name":"ZSTD_copyBlockSequences","code":"static void ZSTD_copyBlockSequences(ZSTD_CCtx* zc)\n{\n    const seqStore_t* seqStore = ZSTD_getSeqStore(zc);\n    const seqDef* seqStoreSeqs = seqStore-\u003esequencesStart;\n    size_t seqStoreSeqSize = seqStore-\u003esequences - seqStoreSeqs;\n    size_t seqStoreLiteralsSize = (size_t)(seqStore-\u003elit - seqStore-\u003elitStart);\n    size_t literalsRead = 0;\n    size_t lastLLSize;\n\n    ZSTD_Sequence* outSeqs = \u0026zc-\u003eseqCollector.seqStart[zc-\u003eseqCollector.seqIndex];\n    size_t i;\n    repcodes_t updatedRepcodes;\n\n    assert(zc-\u003eseqCollector.seqIndex + 1 \u003c zc-\u003eseqCollector.maxSequences);\n    /* Ensure we have enough space for last literals \"sequence\" */\n    assert(zc-\u003eseqCollector.maxSequences \u003e= seqStoreSeqSize + 1);\n    ZSTD_memcpy(updatedRepcodes.rep, zc-\u003eblockState.prevCBlock-\u003erep, sizeof(repcodes_t));\n    for (i = 0; i \u003c seqStoreSeqSize; ++i) {\n        U32 rawOffset = seqStoreSeqs[i].offset - ZSTD_REP_NUM;\n        outSeqs[i].litLength = seqStoreSeqs[i].litLength;\n        outSeqs[i].matchLength = seqStoreSeqs[i].matchLength + MINMATCH;\n        outSeqs[i].rep = 0;\n\n        if (i == seqStore-\u003elongLengthPos) {\n            if (seqStore-\u003elongLengthID == 1) {\n                outSeqs[i].litLength += 0x10000;\n            } else if (seqStore-\u003elongLengthID == 2) {\n                outSeqs[i].matchLength += 0x10000;\n            }\n        }\n\n        if (seqStoreSeqs[i].offset \u003c= ZSTD_REP_NUM) {\n            /* Derive the correct offset corresponding to a repcode */\n            outSeqs[i].rep = seqStoreSeqs[i].offset;\n            if (outSeqs[i].litLength != 0) {\n                rawOffset = updatedRepcodes.rep[outSeqs[i].rep - 1];\n            } else {\n                if (outSeqs[i].rep == 3) {\n                    rawOffset = updatedRepcodes.rep[0] - 1;\n                } else {\n                    rawOffset = updatedRepcodes.rep[outSeqs[i].rep];\n                }\n            }\n        }\n        outSeqs[i].offset = rawOffset;\n        /* seqStoreSeqs[i].offset == offCode+1, and ZSTD_updateRep() expects offCode\n           so we provide seqStoreSeqs[i].offset - 1 */\n        updatedRepcodes = ZSTD_updateRep(updatedRepcodes.rep,\n                                         seqStoreSeqs[i].offset - 1,\n                                         seqStoreSeqs[i].litLength == 0);\n        literalsRead += outSeqs[i].litLength;\n    }\n    /* Insert last literals (if any exist) in the block as a sequence with ml == off == 0.\n     * If there are no last literals, then we'll emit (of: 0, ml: 0, ll: 0), which is a marker\n     * for the block boundary, according to the API.\n     */\n    assert(seqStoreLiteralsSize \u003e= literalsRead);\n    lastLLSize = seqStoreLiteralsSize - literalsRead;\n    outSeqs[i].litLength = (U32)lastLLSize;\n    outSeqs[i].matchLength = outSeqs[i].offset = outSeqs[i].rep = 0;\n    seqStoreSeqSize++;\n    zc-\u003eseqCollector.seqIndex += seqStoreSeqSize;\n}","filepath":"lib/compress/zstd_compress.c","line_number":2559,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2423312":{"score":0.8264326,"function_name":"ZSTD_copySequencesToSeqStoreExplicitBlockDelim","code":"static size_t ZSTD_copySequencesToSeqStoreExplicitBlockDelim(ZSTD_CCtx* cctx, ZSTD_sequencePosition* seqPos,\n                                                             const ZSTD_Sequence* const inSeqs, size_t inSeqsSize,\n                                                             const void* src, size_t blockSize) {\n    U32 idx = seqPos-\u003eidx;\n    BYTE const* ip = (BYTE const*)(src);\n    const BYTE* const iend = ip + blockSize;\n    repcodes_t updatedRepcodes;\n    U32 dictSize;\n    U32 litLength;\n    U32 matchLength;\n    U32 ll0;\n    U32 offCode;\n\n    if (cctx-\u003ecdict) {\n        dictSize = (U32)cctx-\u003ecdict-\u003edictContentSize;\n    } else if (cctx-\u003eprefixDict.dict) {\n        dictSize = (U32)cctx-\u003eprefixDict.dictSize;\n    } else {\n        dictSize = 0;\n    }\n    ZSTD_memcpy(updatedRepcodes.rep, cctx-\u003eblockState.prevCBlock-\u003erep, sizeof(repcodes_t));\n    for (; (inSeqs[idx].matchLength != 0 || inSeqs[idx].offset != 0) \u0026\u0026 idx \u003c inSeqsSize; ++idx) {\n        litLength = inSeqs[idx].litLength;\n        matchLength = inSeqs[idx].matchLength;\n        ll0 = litLength == 0;\n        offCode = ZSTD_finalizeOffCode(inSeqs[idx].offset, updatedRepcodes.rep, ll0);\n        updatedRepcodes = ZSTD_updateRep(updatedRepcodes.rep, offCode, ll0);\n\n        DEBUGLOG(6, \"Storing sequence: (of: %u, ml: %u, ll: %u)\", offCode, matchLength, litLength);\n        if (cctx-\u003eappliedParams.validateSequences) {\n            seqPos-\u003eposInSrc += litLength + matchLength;\n            FORWARD_IF_ERROR(ZSTD_validateSequence(offCode, matchLength, seqPos-\u003eposInSrc,\n                                                cctx-\u003eappliedParams.cParams.windowLog, dictSize,\n                                                cctx-\u003eappliedParams.cParams.minMatch),\n                                                \"Sequence validation failed\");\n        }\n        RETURN_ERROR_IF(idx - seqPos-\u003eidx \u003e cctx-\u003eseqStore.maxNbSeq, memory_allocation,\n                        \"Not enough memory allocated. Try adjusting ZSTD_c_minMatch.\");\n        ZSTD_storeSeq(\u0026cctx-\u003eseqStore, litLength, ip, iend, offCode, matchLength - MINMATCH);\n        ip += matchLength + litLength;\n    }\n    ZSTD_memcpy(cctx-\u003eblockState.nextCBlock-\u003erep, updatedRepcodes.rep, sizeof(repcodes_t));\n\n    if (inSeqs[idx].litLength) {\n        DEBUGLOG(6, \"Storing last literals of size: %u\", inSeqs[idx].litLength);\n        ZSTD_storeLastLiterals(\u0026cctx-\u003eseqStore, ip, inSeqs[idx].litLength);\n        ip += inSeqs[idx].litLength;\n        seqPos-\u003eposInSrc += inSeqs[idx].litLength;\n    }\n    RETURN_ERROR_IF(ip != iend, corruption_detected, \"Blocksize doesn't agree with block delimiter!\");\n    seqPos-\u003eidx = idx+1;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":4679,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2424816":{"score":0.8426575,"function_name":"ZSTD_copySequencesToSeqStoreNoBlockDelim","code":"static size_t ZSTD_copySequencesToSeqStoreNoBlockDelim(ZSTD_CCtx* cctx, ZSTD_sequencePosition* seqPos,\n                                                       const ZSTD_Sequence* const inSeqs, size_t inSeqsSize,\n                                                       const void* src, size_t blockSize) {\n    U32 idx = seqPos-\u003eidx;\n    U32 startPosInSequence = seqPos-\u003eposInSequence;\n    U32 endPosInSequence = seqPos-\u003eposInSequence + (U32)blockSize;\n    size_t dictSize;\n    BYTE const* ip = (BYTE const*)(src);\n    BYTE const* iend = ip + blockSize;  /* May be adjusted if we decide to process fewer than blockSize bytes */\n    repcodes_t updatedRepcodes;\n    U32 bytesAdjustment = 0;\n    U32 finalMatchSplit = 0;\n    U32 litLength;\n    U32 matchLength;\n    U32 rawOffset;\n    U32 offCode;\n\n    if (cctx-\u003ecdict) {\n        dictSize = cctx-\u003ecdict-\u003edictContentSize;\n    } else if (cctx-\u003eprefixDict.dict) {\n        dictSize = cctx-\u003eprefixDict.dictSize;\n    } else {\n        dictSize = 0;\n    }\n    DEBUGLOG(5, \"ZSTD_copySequencesToSeqStore: idx: %u PIS: %u blockSize: %zu\", idx, startPosInSequence, blockSize);\n    DEBUGLOG(5, \"Start seq: idx: %u (of: %u ml: %u ll: %u)\", idx, inSeqs[idx].offset, inSeqs[idx].matchLength, inSeqs[idx].litLength);\n    ZSTD_memcpy(updatedRepcodes.rep, cctx-\u003eblockState.prevCBlock-\u003erep, sizeof(repcodes_t));\n    while (endPosInSequence \u0026\u0026 idx \u003c inSeqsSize \u0026\u0026 !finalMatchSplit) {\n        const ZSTD_Sequence currSeq = inSeqs[idx];\n        litLength = currSeq.litLength;\n        matchLength = currSeq.matchLength;\n        rawOffset = currSeq.offset;\n\n        /* Modify the sequence depending on where endPosInSequence lies */\n        if (endPosInSequence \u003e= currSeq.litLength + currSeq.matchLength) {\n            if (startPosInSequence \u003e= litLength) {\n                startPosInSequence -= litLength;\n                litLength = 0;\n                matchLength -= startPosInSequence;\n            } else {\n                litLength -= startPosInSequence;\n            }\n            /* Move to the next sequence */\n            endPosInSequence -= currSeq.litLength + currSeq.matchLength;\n            startPosInSequence = 0;\n            idx++;\n        } else {\n            /* This is the final (partial) sequence we're adding from inSeqs, and endPosInSequence\n               does not reach the end of the match. So, we have to split the sequence */\n            DEBUGLOG(6, \"Require a split: diff: %u, idx: %u PIS: %u\",\n                     currSeq.litLength + currSeq.matchLength - endPosInSequence, idx, endPosInSequence);\n            if (endPosInSequence \u003e litLength) {\n                U32 firstHalfMatchLength;\n                litLength = startPosInSequence \u003e= litLength ? 0 : litLength - startPosInSequence;\n                firstHalfMatchLength = endPosInSequence - startPosInSequence - litLength;\n                if (matchLength \u003e blockSize \u0026\u0026 firstHalfMatchLength \u003e= cctx-\u003eappliedParams.cParams.minMatch) {\n                    /* Only ever split the match if it is larger than the block size */\n                    U32 secondHalfMatchLength = currSeq.matchLength + currSeq.litLength - endPosInSequence;\n                    if (secondHalfMatchLength \u003c cctx-\u003eappliedParams.cParams.minMatch) {\n                        /* Move the endPosInSequence backward so that it creates match of minMatch length */\n                        endPosInSequence -= cctx-\u003eappliedParams.cParams.minMatch - secondHalfMatchLength;\n                        bytesAdjustment = cctx-\u003eappliedParams.cParams.minMatch - secondHalfMatchLength;\n                        firstHalfMatchLength -= bytesAdjustment;\n                    }\n                    matchLength = firstHalfMatchLength;\n                    /* Flag that we split the last match - after storing the sequence, exit the loop,\n                       but keep the value of endPosInSequence */\n                    finalMatchSplit = 1;\n                } else {\n                    /* Move the position in sequence backwards so that we don't split match, and break to store\n                     * the last literals. We use the original currSeq.litLength as a marker for where endPosInSequence\n                     * should go. We prefer to do this whenever it is not necessary to split the match, or if doing so\n                     * would cause the first half of the match to be too small\n                     */\n                    bytesAdjustment = endPosInSequence - currSeq.litLength;\n                    endPosInSequence = currSeq.litLength;\n                    break;\n                }\n            } else {\n                /* This sequence ends inside the literals, break to store the last literals */\n                break;\n            }\n        }\n        /* Check if this offset can be represented with a repcode */\n        {   U32 ll0 = (litLength == 0);\n            offCode = ZSTD_finalizeOffCode(rawOffset, updatedRepcodes.rep, ll0);\n            updatedRepcodes = ZSTD_updateRep(updatedRepcodes.rep, offCode, ll0);\n        }\n\n        if (cctx-\u003eappliedParams.validateSequences) {\n            seqPos-\u003eposInSrc += litLength + matchLength;\n            FORWARD_IF_ERROR(ZSTD_validateSequence(offCode, matchLength, seqPos-\u003eposInSrc,\n                                                   cctx-\u003eappliedParams.cParams.windowLog, dictSize,\n                                                   cctx-\u003eappliedParams.cParams.minMatch),\n                                                   \"Sequence validation failed\");\n        }\n        DEBUGLOG(6, \"Storing sequence: (of: %u, ml: %u, ll: %u)\", offCode, matchLength, litLength);\n        RETURN_ERROR_IF(idx - seqPos-\u003eidx \u003e cctx-\u003eseqStore.maxNbSeq, memory_allocation,\n                        \"Not enough memory allocated. Try adjusting ZSTD_c_minMatch.\");\n        ZSTD_storeSeq(\u0026cctx-\u003eseqStore, litLength, ip, iend, offCode, matchLength - MINMATCH);\n        ip += matchLength + litLength;\n    }\n    DEBUGLOG(5, \"Ending seq: idx: %u (of: %u ml: %u ll: %u)\", idx, inSeqs[idx].offset, inSeqs[idx].matchLength, inSeqs[idx].litLength);\n    assert(idx == inSeqsSize || endPosInSequence \u003c= inSeqs[idx].litLength + inSeqs[idx].matchLength);\n    seqPos-\u003eidx = idx;\n    seqPos-\u003eposInSequence = endPosInSequence;\n    ZSTD_memcpy(cctx-\u003eblockState.nextCBlock-\u003erep, updatedRepcodes.rep, sizeof(repcodes_t));\n\n    iend -= bytesAdjustment;\n    if (ip != iend) {\n        /* Store any last literals */\n        U32 lastLLSize = (U32)(iend - ip);\n        assert(ip \u003c= iend);\n        DEBUGLOG(6, \"Storing last literals of size: %u\", lastLLSize);\n        ZSTD_storeLastLiterals(\u0026cctx-\u003eseqStore, ip, lastLLSize);\n        seqPos-\u003eposInSrc += lastLLSize;\n    }\n\n    return bytesAdjustment;\n}","filepath":"lib/compress/zstd_compress.c","line_number":4744,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2426592":{"score":0.73070604,"function_name":"ZSTD_clearAllDicts","code":"static void ZSTD_clearAllDicts(ZSTD_CCtx* cctx)\n{\n    ZSTD_customFree(cctx-\u003elocalDict.dictBuffer, cctx-\u003ecustomMem);\n    ZSTD_freeCDict(cctx-\u003elocalDict.cdict);\n    ZSTD_memset(\u0026cctx-\u003elocalDict, 0, sizeof(cctx-\u003elocalDict));\n    ZSTD_memset(\u0026cctx-\u003eprefixDict, 0, sizeof(cctx-\u003eprefixDict));\n    cctx-\u003ecdict = NULL;\n}","filepath":"lib/compress/zstd_compress.c","line_number":133,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2426912":{"score":0.81965715,"function_name":"ZSTD_loadDictionaryContent","code":"static size_t ZSTD_loadDictionaryContent(ZSTD_matchState_t* ms,\n                                         ldmState_t* ls,\n                                         ZSTD_cwksp* ws,\n                                         ZSTD_CCtx_params const* params,\n                                         const void* src, size_t srcSize,\n                                         ZSTD_dictTableLoadMethod_e dtlm)\n{\n    const BYTE* ip = (const BYTE*) src;\n    const BYTE* const iend = ip + srcSize;\n\n    ZSTD_window_update(\u0026ms-\u003ewindow, src, srcSize);\n    ms-\u003eloadedDictEnd = params-\u003eforceWindow ? 0 : (U32)(iend - ms-\u003ewindow.base);\n\n    if (params-\u003eldmParams.enableLdm \u0026\u0026 ls != NULL) {\n        ZSTD_window_update(\u0026ls-\u003ewindow, src, srcSize);\n        ls-\u003eloadedDictEnd = params-\u003eforceWindow ? 0 : (U32)(iend - ls-\u003ewindow.base);\n    }\n\n    /* Assert that we the ms params match the params we're being given */\n    ZSTD_assertEqualCParams(params-\u003ecParams, ms-\u003ecParams);\n\n    if (srcSize \u003c= HASH_READ_SIZE) return 0;\n\n    while (iend - ip \u003e HASH_READ_SIZE) {\n        size_t const remaining = (size_t)(iend - ip);\n        size_t const chunk = MIN(remaining, ZSTD_CHUNKSIZE_MAX);\n        const BYTE* const ichunk = ip + chunk;\n\n        ZSTD_overflowCorrectIfNeeded(ms, ws, params, ip, ichunk);\n\n        if (params-\u003eldmParams.enableLdm \u0026\u0026 ls != NULL)\n            ZSTD_ldm_fillHashTable(ls, (const BYTE*)src, (const BYTE*)src + srcSize, \u0026params-\u003eldmParams);\n\n        switch(params-\u003ecParams.strategy)\n        {\n        case ZSTD_fast:\n            ZSTD_fillHashTable(ms, ichunk, dtlm);\n            break;\n        case ZSTD_dfast:\n            ZSTD_fillDoubleHashTable(ms, ichunk, dtlm);\n            break;\n\n        case ZSTD_greedy:\n        case ZSTD_lazy:\n        case ZSTD_lazy2:\n            if (chunk \u003e= HASH_READ_SIZE \u0026\u0026 ms-\u003ededicatedDictSearch) {\n                assert(chunk == remaining); /* must load everything in one go */\n                ZSTD_dedicatedDictSearch_lazy_loadDictionary(ms, ichunk-HASH_READ_SIZE);\n            } else if (chunk \u003e= HASH_READ_SIZE) {\n                ZSTD_insertAndFindFirstIndex(ms, ichunk-HASH_READ_SIZE);\n            }\n            break;\n\n        case ZSTD_btlazy2:   /* we want the dictionary table fully sorted */\n        case ZSTD_btopt:\n        case ZSTD_btultra:\n        case ZSTD_btultra2:\n            if (chunk \u003e= HASH_READ_SIZE)\n                ZSTD_updateTree(ms, ichunk-HASH_READ_SIZE, ichunk);\n            break;\n\n        default:\n            assert(0);  /* not possible : not a valid strategy id */\n        }\n\n        ip = ichunk;\n    }\n\n    ms-\u003enextToUpdate = (U32)(iend - ms-\u003ewindow.base);\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3140,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2427728":{"score":0.8012179,"function_name":"ZSTD_estimateCCtxSize_usingCCtxParams_internal","code":"static size_t ZSTD_estimateCCtxSize_usingCCtxParams_internal(\n        const ZSTD_compressionParameters* cParams,\n        const ldmParams_t* ldmParams,\n        const int isStatic,\n        const size_t buffInSize,\n        const size_t buffOutSize,\n        const U64 pledgedSrcSize)\n{\n    size_t const windowSize = MAX(1, (size_t)MIN(((U64)1 \u003c\u003c cParams-\u003ewindowLog), pledgedSrcSize));\n    size_t const blockSize = MIN(ZSTD_BLOCKSIZE_MAX, windowSize);\n    U32    const divider = (cParams-\u003eminMatch==3) ? 3 : 4;\n    size_t const maxNbSeq = blockSize / divider;\n    size_t const tokenSpace = ZSTD_cwksp_alloc_size(WILDCOPY_OVERLENGTH + blockSize)\n                            + ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(seqDef))\n                            + 3 * ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(BYTE));\n    size_t const entropySpace = ZSTD_cwksp_alloc_size(ENTROPY_WORKSPACE_SIZE);\n    size_t const blockStateSpace = 2 * ZSTD_cwksp_alloc_size(sizeof(ZSTD_compressedBlockState_t));\n    size_t const matchStateSize = ZSTD_sizeof_matchState(cParams, /* forCCtx */ 1);\n\n    size_t const ldmSpace = ZSTD_ldm_getTableSize(*ldmParams);\n    size_t const maxNbLdmSeq = ZSTD_ldm_getMaxNbSeq(*ldmParams, blockSize);\n    size_t const ldmSeqSpace = ldmParams-\u003eenableLdm ?\n        ZSTD_cwksp_alloc_size(maxNbLdmSeq * sizeof(rawSeq)) : 0;\n\n\n    size_t const bufferSpace = ZSTD_cwksp_alloc_size(buffInSize)\n                             + ZSTD_cwksp_alloc_size(buffOutSize);\n\n    size_t const cctxSpace = isStatic ? ZSTD_cwksp_alloc_size(sizeof(ZSTD_CCtx)) : 0;\n\n    size_t const neededSpace =\n        cctxSpace +\n        entropySpace +\n        blockStateSpace +\n        ldmSpace +\n        ldmSeqSpace +\n        matchStateSize +\n        tokenSpace +\n        bufferSpace;\n\n    DEBUGLOG(5, \"estimate workspace : %u\", (U32)neededSpace);\n    return neededSpace;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1327,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2428368":{"score":0.709723,"function_name":"ZSTD_adjustCParams_internal","code":"static ZSTD_compressionParameters\nZSTD_adjustCParams_internal(ZSTD_compressionParameters cPar,\n                            unsigned long long srcSize,\n                            size_t dictSize,\n                            ZSTD_cParamMode_e mode)\n{\n    const U64 minSrcSize = 513; /* (1\u003c\u003c9) + 1 */\n    const U64 maxWindowResize = 1ULL \u003c\u003c (ZSTD_WINDOWLOG_MAX-1);\n    assert(ZSTD_checkCParams(cPar)==0);\n\n    switch (mode) {\n    case ZSTD_cpm_unknown:\n    case ZSTD_cpm_noAttachDict:\n        /* If we don't know the source size, don't make any\n         * assumptions about it. We will already have selected\n         * smaller parameters if a dictionary is in use.\n         */\n        break;\n    case ZSTD_cpm_createCDict:\n        /* Assume a small source size when creating a dictionary\n         * with an unkown source size.\n         */\n        if (dictSize \u0026\u0026 srcSize == ZSTD_CONTENTSIZE_UNKNOWN)\n            srcSize = minSrcSize;\n        break;\n    case ZSTD_cpm_attachDict:\n        /* Dictionary has its own dedicated parameters which have\n         * already been selected. We are selecting parameters\n         * for only the source.\n         */\n        dictSize = 0;\n        break;\n    default:\n        assert(0);\n        break;\n    }\n\n    /* resize windowLog if input is small enough, to use less memory */\n    if ( (srcSize \u003c maxWindowResize)\n      \u0026\u0026 (dictSize \u003c maxWindowResize) )  {\n        U32 const tSize = (U32)(srcSize + dictSize);\n        static U32 const hashSizeMin = 1 \u003c\u003c ZSTD_HASHLOG_MIN;\n        U32 const srcLog = (tSize \u003c hashSizeMin) ? ZSTD_HASHLOG_MIN :\n                            ZSTD_highbit32(tSize-1) + 1;\n        if (cPar.windowLog \u003e srcLog) cPar.windowLog = srcLog;\n    }\n    if (srcSize != ZSTD_CONTENTSIZE_UNKNOWN) {\n        U32 const dictAndWindowLog = ZSTD_dictAndWindowLog(cPar.windowLog, (U64)srcSize, (U64)dictSize);\n        U32 const cycleLog = ZSTD_cycleLog(cPar.chainLog, cPar.strategy);\n        if (cPar.hashLog \u003e dictAndWindowLog+1) cPar.hashLog = dictAndWindowLog+1;\n        if (cycleLog \u003e dictAndWindowLog)\n            cPar.chainLog -= (cycleLog - dictAndWindowLog);\n    }\n\n    if (cPar.windowLog \u003c ZSTD_WINDOWLOG_ABSOLUTEMIN)\n        cPar.windowLog = ZSTD_WINDOWLOG_ABSOLUTEMIN;  /* minimum wlog required for valid frame header */\n\n    return cPar;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1198,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2436176":{"score":0.7817085,"function_name":"ZSTD_initStaticCCtx","code":"ZSTD_CCtx* ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize)\n{\n    ZSTD_cwksp ws;\n    ZSTD_CCtx* cctx;\n    if (workspaceSize \u003c= sizeof(ZSTD_CCtx)) return NULL;  /* minimum size */\n    if ((size_t)workspace \u0026 7) return NULL;  /* must be 8-aligned */\n    ZSTD_cwksp_init(\u0026ws, workspace, workspaceSize, ZSTD_cwksp_static_alloc);\n\n    cctx = (ZSTD_CCtx*)ZSTD_cwksp_reserve_object(\u0026ws, sizeof(ZSTD_CCtx));\n    if (cctx == NULL) return NULL;\n\n    ZSTD_memset(cctx, 0, sizeof(ZSTD_CCtx));\n    ZSTD_cwksp_move(\u0026cctx-\u003eworkspace, \u0026ws);\n    cctx-\u003estaticSize = workspaceSize;\n\n    /* statically sized space. entropyWorkspace never moves (but prev/next block swap places) */\n    if (!ZSTD_cwksp_check_available(\u0026cctx-\u003eworkspace, ENTROPY_WORKSPACE_SIZE + 2 * sizeof(ZSTD_compressedBlockState_t))) return NULL;\n    cctx-\u003eblockState.prevCBlock = (ZSTD_compressedBlockState_t*)ZSTD_cwksp_reserve_object(\u0026cctx-\u003eworkspace, sizeof(ZSTD_compressedBlockState_t));\n    cctx-\u003eblockState.nextCBlock = (ZSTD_compressedBlockState_t*)ZSTD_cwksp_reserve_object(\u0026cctx-\u003eworkspace, sizeof(ZSTD_compressedBlockState_t));\n    cctx-\u003eentropyWorkspace = (U32*)ZSTD_cwksp_reserve_object(\u0026cctx-\u003eworkspace, ENTROPY_WORKSPACE_SIZE);\n    cctx-\u003ebmi2 = ZSTD_cpuid_bmi2(ZSTD_cpuid());\n    return cctx;\n}","filepath":"lib/compress/zstd_compress.c","line_number":106,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2437120":{"score":0.7353816,"function_name":"ZSTD_sizeof_CCtx","code":"size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx)\n{\n    if (cctx==NULL) return 0;   /* support sizeof on NULL */\n    /* cctx may be in the workspace */\n    return (cctx-\u003eworkspace.workspace == cctx ? 0 : sizeof(*cctx))\n           + ZSTD_cwksp_sizeof(\u0026cctx-\u003eworkspace)\n           + ZSTD_sizeof_localDict(cctx-\u003elocalDict)\n           + ZSTD_sizeof_mtctx(cctx);\n}","filepath":"lib/compress/zstd_compress.c","line_number":187,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2437232":{"score":0.7401844,"function_name":"ZSTD_sizeof_CCtx","code":"size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx)\n{\n    if (cctx==NULL) return 0;   /* support sizeof on NULL */\n    /* cctx may be in the workspace */\n    return (cctx-\u003eworkspace.workspace == cctx ? 0 : sizeof(*cctx))\n           + ZSTD_cwksp_sizeof(\u0026cctx-\u003eworkspace)\n           + ZSTD_sizeof_localDict(cctx-\u003elocalDict)\n           + ZSTD_sizeof_mtctx(cctx);\n}","filepath":"lib/compress/zstd_compress.c","line_number":187,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442080":{"score":0.8867666,"function_name":"ZSTD_CCtx_setPledgedSrcSize","code":"ZSTDLIB_API size_t ZSTD_CCtx_setPledgedSrcSize(ZSTD_CCtx* cctx, unsigned long long pledgedSrcSize)\n{\n    DEBUGLOG(4, \"ZSTD_CCtx_setPledgedSrcSize to %u bytes\", (U32)pledgedSrcSize);\n    RETURN_ERROR_IF(cctx-\u003estreamStage != zcss_init, stage_wrong,\n                    \"Can't set pledgedSrcSize when not in init stage.\");\n    cctx-\u003epledgedSrcSizePlusOne = pledgedSrcSize+1;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":961,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442112":{"score":0.8972529,"function_name":"ZSTD_CCtx_loadDictionary_advanced","code":"size_t ZSTD_CCtx_loadDictionary_advanced(\n        ZSTD_CCtx* cctx, const void* dict, size_t dictSize,\n        ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(cctx-\u003estreamStage != zcss_init, stage_wrong,\n                    \"Can't load a dictionary when ctx is not in init stage.\");\n    DEBUGLOG(4, \"ZSTD_CCtx_loadDictionary_advanced (size: %u)\", (U32)dictSize);\n    ZSTD_clearAllDicts(cctx);  /* in case one already exists */\n    if (dict == NULL || dictSize == 0)  /* no dictionary mode */\n        return 0;\n    if (dictLoadMethod == ZSTD_dlm_byRef) {\n        cctx-\u003elocalDict.dict = dict;\n    } else {\n        void* dictBuffer;\n        RETURN_ERROR_IF(cctx-\u003estaticSize, memory_allocation,\n                        \"no malloc for static CCtx\");\n        dictBuffer = ZSTD_customMalloc(dictSize, cctx-\u003ecustomMem);\n        RETURN_ERROR_IF(!dictBuffer, memory_allocation, \"NULL pointer!\");\n        ZSTD_memcpy(dictBuffer, dict, dictSize);\n        cctx-\u003elocalDict.dictBuffer = dictBuffer;\n        cctx-\u003elocalDict.dict = dictBuffer;\n    }\n    cctx-\u003elocalDict.dictSize = dictSize;\n    cctx-\u003elocalDict.dictContentType = dictContentType;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1014,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442336":{"score":0.81443274,"function_name":"ZSTD_referenceExternalSequences","code":"size_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq)\n{\n    RETURN_ERROR_IF(cctx-\u003estage != ZSTDcs_init, stage_wrong,\n                    \"wrong cctx stage\");\n    RETURN_ERROR_IF(cctx-\u003eappliedParams.ldmParams.enableLdm,\n                    parameter_unsupported,\n                    \"incompatible with ldm\");\n    cctx-\u003eexternSeqStore.seq = seq;\n    cctx-\u003eexternSeqStore.size = nbSeq;\n    cctx-\u003eexternSeqStore.capacity = nbSeq;\n    cctx-\u003eexternSeqStore.pos = 0;\n    cctx-\u003eexternSeqStore.posInSequence = 0;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3036,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442448":{"score":0.7089914,"function_name":"ZSTD_referenceExternalSequences","code":"size_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq)\n{\n    RETURN_ERROR_IF(cctx-\u003estage != ZSTDcs_init, stage_wrong,\n                    \"wrong cctx stage\");\n    RETURN_ERROR_IF(cctx-\u003eappliedParams.ldmParams.enableLdm,\n                    parameter_unsupported,\n                    \"incompatible with ldm\");\n    cctx-\u003eexternSeqStore.seq = seq;\n    cctx-\u003eexternSeqStore.size = nbSeq;\n    cctx-\u003eexternSeqStore.capacity = nbSeq;\n    cctx-\u003eexternSeqStore.pos = 0;\n    cctx-\u003eexternSeqStore.posInSequence = 0;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3036,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442688":{"score":0.86668754,"function_name":"ZSTD_CCtx_refCDict","code":"size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict)\n{\n    RETURN_ERROR_IF(cctx-\u003estreamStage != zcss_init, stage_wrong,\n                    \"Can't ref a dict when ctx not in init stage.\");\n    /* Free the existing local cdict (if any) to save memory. */\n    ZSTD_clearAllDicts(cctx);\n    cctx-\u003ecdict = cdict;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1055,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442752":{"score":0.79234725,"function_name":"ZSTD_CCtx_refCDict","code":"size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict)\n{\n    RETURN_ERROR_IF(cctx-\u003estreamStage != zcss_init, stage_wrong,\n                    \"Can't ref a dict when ctx not in init stage.\");\n    /* Free the existing local cdict (if any) to save memory. */\n    ZSTD_clearAllDicts(cctx);\n    cctx-\u003ecdict = cdict;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1055,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442784":{"score":0.6792537,"function_name":"ZSTD_referenceExternalSequences","code":"size_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq)\n{\n    RETURN_ERROR_IF(cctx-\u003estage != ZSTDcs_init, stage_wrong,\n                    \"wrong cctx stage\");\n    RETURN_ERROR_IF(cctx-\u003eappliedParams.ldmParams.enableLdm,\n                    parameter_unsupported,\n                    \"incompatible with ldm\");\n    cctx-\u003eexternSeqStore.seq = seq;\n    cctx-\u003eexternSeqStore.size = nbSeq;\n    cctx-\u003eexternSeqStore.capacity = nbSeq;\n    cctx-\u003eexternSeqStore.pos = 0;\n    cctx-\u003eexternSeqStore.posInSequence = 0;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3036,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2442896":{"score":0.88455033,"function_name":"ZSTD_CCtx_refPrefix_advanced","code":"size_t ZSTD_CCtx_refPrefix_advanced(\n        ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(cctx-\u003estreamStage != zcss_init, stage_wrong,\n                    \"Can't ref a prefix when ctx not in init stage.\");\n    ZSTD_clearAllDicts(cctx);\n    if (prefix != NULL \u0026\u0026 prefixSize \u003e 0) {\n        cctx-\u003eprefixDict.dict = prefix;\n        cctx-\u003eprefixDict.dictSize = prefixSize;\n        cctx-\u003eprefixDict.dictContentType = dictContentType;\n    }\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1078,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2443488":{"score":0.73886293,"function_name":"ZSTD_adjustCParams","code":"ZSTD_compressionParameters\nZSTD_adjustCParams(ZSTD_compressionParameters cPar,\n                   unsigned long long srcSize,\n                   size_t dictSize)\n{\n    cPar = ZSTD_clampCParams(cPar);   /* resulting cPar is necessarily valid (all parameters within range) */\n    if (srcSize == 0) srcSize = ZSTD_CONTENTSIZE_UNKNOWN;\n    return ZSTD_adjustCParams_internal(cPar, srcSize, dictSize, ZSTD_cpm_unknown);\n}","filepath":"lib/compress/zstd_compress.c","line_number":1258,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2443936":{"score":0.67580396,"function_name":"ZSTD_getCParamsFromCCtxParams","code":"ZSTD_compressionParameters ZSTD_getCParamsFromCCtxParams(\n        const ZSTD_CCtx_params* CCtxParams, U64 srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode)\n{\n    ZSTD_compressionParameters cParams;\n    if (srcSizeHint == ZSTD_CONTENTSIZE_UNKNOWN \u0026\u0026 CCtxParams-\u003esrcSizeHint \u003e 0) {\n      srcSizeHint = CCtxParams-\u003esrcSizeHint;\n    }\n    cParams = ZSTD_getCParams_internal(CCtxParams-\u003ecompressionLevel, srcSizeHint, dictSize, mode);\n    if (CCtxParams-\u003eldmParams.enableLdm) cParams.windowLog = ZSTD_LDM_DEFAULT_WINDOW_LOG;\n    ZSTD_overrideCParams(\u0026cParams, \u0026CCtxParams-\u003ecParams);\n    assert(!ZSTD_checkCParams(cParams));\n    /* srcSizeHint == 0 means 0 */\n    return ZSTD_adjustCParams_internal(cParams, srcSizeHint, dictSize, mode);\n}","filepath":"lib/compress/zstd_compress.c","line_number":1284,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2447600":{"score":0.66571826,"function_name":"ZSTD_estimateCCtxSize_internal","code":"static size_t ZSTD_estimateCCtxSize_internal(int compressionLevel)\n{\n    int tier = 0;\n    size_t largestSize = 0;\n    static const unsigned long long srcSizeTiers[4] = {16 KB, 128 KB, 256 KB, ZSTD_CONTENTSIZE_UNKNOWN};\n    for (; tier \u003c 4; ++tier) {\n        /* Choose the set of cParams for a given level across all srcSizes that give the largest cctxSize */\n        ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, srcSizeTiers[tier], 0, ZSTD_cpm_noAttachDict);\n        largestSize = MAX(ZSTD_estimateCCtxSize_usingCParams(cParams), largestSize);\n    }\n    return largestSize;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1390,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2449792":{"score":0.58311373,"function_name":"ZSTD_nextInputSizeHint_MTorST","code":"static size_t ZSTD_nextInputSizeHint_MTorST(const ZSTD_CCtx* cctx)\n{\n#ifdef ZSTD_MULTITHREAD\n    if (cctx-\u003eappliedParams.nbWorkers \u003e= 1) {\n        assert(cctx-\u003emtctx != NULL);\n        return ZSTDMT_nextInputSizeHint(cctx-\u003emtctx);\n    }\n#endif\n    return ZSTD_nextInputSizeHint(cctx);\n\n}","filepath":"lib/compress/zstd_compress.c","line_number":4379,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2450448":{"score":0.7182676,"function_name":"ZSTD_estimateCCtxSize_internal","code":"static size_t ZSTD_estimateCCtxSize_internal(int compressionLevel)\n{\n    int tier = 0;\n    size_t largestSize = 0;\n    static const unsigned long long srcSizeTiers[4] = {16 KB, 128 KB, 256 KB, ZSTD_CONTENTSIZE_UNKNOWN};\n    for (; tier \u003c 4; ++tier) {\n        /* Choose the set of cParams for a given level across all srcSizes that give the largest cctxSize */\n        ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, srcSizeTiers[tier], 0, ZSTD_cpm_noAttachDict);\n        largestSize = MAX(ZSTD_estimateCCtxSize_usingCParams(cParams), largestSize);\n    }\n    return largestSize;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1390,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2451376":{"score":0.6408778,"function_name":"ZSTD_getFrameProgression","code":"ZSTD_frameProgression ZSTD_getFrameProgression(const ZSTD_CCtx* cctx)\n{\n#ifdef ZSTD_MULTITHREAD\n    if (cctx-\u003eappliedParams.nbWorkers \u003e 0) {\n        return ZSTDMT_getFrameProgression(cctx-\u003emtctx);\n    }\n#endif\n    {   ZSTD_frameProgression fp;\n        size_t const buffered = (cctx-\u003einBuff == NULL) ? 0 :\n                                cctx-\u003einBuffPos - cctx-\u003einToCompress;\n        if (buffered) assert(cctx-\u003einBuffPos \u003e= cctx-\u003einToCompress);\n        assert(buffered \u003c= ZSTD_BLOCKSIZE_MAX);\n        fp.ingested = cctx-\u003econsumedSrcSize + buffered;\n        fp.consumed = cctx-\u003econsumedSrcSize;\n        fp.produced = cctx-\u003eproducedCSize;\n        fp.flushed  = cctx-\u003eproducedCSize;   /* simplified; some data might still be left within streaming output buffer */\n        fp.currentJobID = 0;\n        fp.nbActiveWorkers = 0;\n        return fp;\n}   }","filepath":"lib/compress/zstd_compress.c","line_number":1461,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2451472":{"score":0.6703216,"function_name":"ZSTD_reset_compressedBlockState","code":"void ZSTD_reset_compressedBlockState(ZSTD_compressedBlockState_t* bs)\n{\n    int i;\n    for (i = 0; i \u003c ZSTD_REP_NUM; ++i)\n        bs-\u003erep[i] = repStartValue[i];\n    bs-\u003eentropy.huf.repeatMode = HUF_repeat_none;\n    bs-\u003eentropy.fse.offcode_repeatMode = FSE_repeat_none;\n    bs-\u003eentropy.fse.matchlength_repeatMode = FSE_repeat_none;\n    bs-\u003eentropy.fse.litlength_repeatMode = FSE_repeat_none;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1510,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2451552":{"score":0.6758727,"function_name":"ZSTD_copyCCtx","code":"size_t ZSTD_copyCCtx(ZSTD_CCtx* dstCCtx, const ZSTD_CCtx* srcCCtx, unsigned long long pledgedSrcSize)\n{\n    ZSTD_frameParameters fParams = { 1 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };\n    ZSTD_buffered_policy_e const zbuff = srcCCtx-\u003ebufferedPolicy;\n    ZSTD_STATIC_ASSERT((U32)ZSTDb_buffered==1);\n    if (pledgedSrcSize==0) pledgedSrcSize = ZSTD_CONTENTSIZE_UNKNOWN;\n    fParams.contentSizeFlag = (pledgedSrcSize != ZSTD_CONTENTSIZE_UNKNOWN);\n\n    return ZSTD_copyCCtx_internal(dstCCtx, srcCCtx,\n                                fParams, pledgedSrcSize,\n                                zbuff);\n}","filepath":"lib/compress/zstd_compress.c","line_number":2060,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2452480":{"score":0.7080878,"function_name":"ZSTD_entropyCompressSequences_internal","code":"MEM_STATIC size_t\nZSTD_entropyCompressSequences_internal(seqStore_t* seqStorePtr,\n                          const ZSTD_entropyCTables_t* prevEntropy,\n                                ZSTD_entropyCTables_t* nextEntropy,\n                          const ZSTD_CCtx_params* cctxParams,\n                                void* dst, size_t dstCapacity,\n                                void* entropyWorkspace, size_t entropyWkspSize,\n                          const int bmi2)\n{\n    const int longOffsets = cctxParams-\u003ecParams.windowLog \u003e STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams-\u003ecParams.strategy;\n    unsigned* count = (unsigned*)entropyWorkspace;\n    FSE_CTable* CTable_LitLength = nextEntropy-\u003efse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy-\u003efse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy-\u003efse.matchlengthCTable;\n    U32 LLtype, Offtype, MLtype;   /* compressed, raw or rle */\n    const seqDef* const sequences = seqStorePtr-\u003esequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr-\u003eofCode;\n    const BYTE* const llCodeTable = seqStorePtr-\u003ellCode;\n    const BYTE* const mlCodeTable = seqStorePtr-\u003emlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t const nbSeq = (size_t)(seqStorePtr-\u003esequences - seqStorePtr-\u003esequencesStart);\n    BYTE* seqHead;\n    BYTE* lastNCount = NULL;\n\n    entropyWorkspace = count + (MaxSeq + 1);\n    entropyWkspSize -= (MaxSeq + 1) * sizeof(*count);\n\n    DEBUGLOG(4, \"ZSTD_entropyCompressSequences_internal (nbSeq=%zu)\", nbSeq);\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE \u003e= (1\u003c\u003cMAX(MLFSELog,LLFSELog)));\n    assert(entropyWkspSize \u003e= HUF_WORKSPACE_SIZE);\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr-\u003elitStart;\n        size_t const litSize = (size_t)(seqStorePtr-\u003elit - literals);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    \u0026prevEntropy-\u003ehuf, \u0026nextEntropy-\u003ehuf,\n                                    cctxParams-\u003ecParams.strategy,\n                                    ZSTD_disableLiteralsCompression(cctxParams),\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    entropyWorkspace, entropyWkspSize,\n                                    bmi2);\n        FORWARD_IF_ERROR(cSize, \"ZSTD_compressLiterals failed\");\n        assert(cSize \u003c= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    RETURN_ERROR_IF((oend-op) \u003c 3 /*max nbSeq Size*/ + 1 /*seqHead*/,\n                    dstSize_tooSmall, \"Can't fit seq hdr in output buf!\");\n    if (nbSeq \u003c 128) {\n        *op++ = (BYTE)nbSeq;\n    } else if (nbSeq \u003c LONGNBSEQ) {\n        op[0] = (BYTE)((nbSeq\u003e\u003e8) + 0x80);\n        op[1] = (BYTE)nbSeq;\n        op+=2;\n    } else {\n        op[0]=0xFF;\n        MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));\n        op+=3;\n    }\n    assert(op \u003c= oend);\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        ZSTD_memcpy(\u0026nextEntropy-\u003efse, \u0026prevEntropy-\u003efse, sizeof(prevEntropy-\u003efse));\n        return (size_t)(op - ostart);\n    }\n\n    /* seqHead : flags for FSE encoding type */\n    seqHead = op++;\n    assert(op \u003c= oend);\n\n    /* convert length/distances into codes */\n    ZSTD_seqToCodes(seqStorePtr);\n    /* build CTable for Literal Lengths */\n    {   unsigned max = MaxLL;\n        size_t const mostFrequent = HIST_countFast_wksp(count, \u0026max, llCodeTable, nbSeq, entropyWorkspace, entropyWkspSize);   /* can't fail */\n        DEBUGLOG(5, \"Building LL table\");\n        nextEntropy-\u003efse.litlength_repeatMode = prevEntropy-\u003efse.litlength_repeatMode;\n        LLtype = ZSTD_selectEncodingType(\u0026nextEntropy-\u003efse.litlength_repeatMode,\n                                        count, max, mostFrequent, nbSeq,\n                                        LLFSELog, prevEntropy-\u003efse.litlengthCTable,\n                                        LL_defaultNorm, LL_defaultNormLog,\n                                        ZSTD_defaultAllowed, strategy);\n        assert(set_basic \u003c set_compressed \u0026\u0026 set_rle \u003c set_compressed);\n        assert(!(LLtype \u003c set_compressed \u0026\u0026 nextEntropy-\u003efse.litlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(\n                op, (size_t)(oend - op),\n                CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,\n                count, max, llCodeTable, nbSeq,\n                LL_defaultNorm, LL_defaultNormLog, MaxLL,\n                prevEntropy-\u003efse.litlengthCTable,\n                sizeof(prevEntropy-\u003efse.litlengthCTable),\n                entropyWorkspace, entropyWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for LitLens failed\");\n            if (LLtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n            assert(op \u003c= oend);\n    }   }\n    /* build CTable for Offsets */\n    {   unsigned max = MaxOff;\n        size_t const mostFrequent = HIST_countFast_wksp(\n            count, \u0026max, ofCodeTable, nbSeq, entropyWorkspace, entropyWkspSize);  /* can't fail */\n        /* We can only use the basic table if max \u003c= DefaultMaxOff, otherwise the offsets are too large */\n        ZSTD_defaultPolicy_e const defaultPolicy = (max \u003c= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;\n        DEBUGLOG(5, \"Building OF table\");\n        nextEntropy-\u003efse.offcode_repeatMode = prevEntropy-\u003efse.offcode_repeatMode;\n        Offtype = ZSTD_selectEncodingType(\u0026nextEntropy-\u003efse.offcode_repeatMode,\n                                        count, max, mostFrequent, nbSeq,\n                                        OffFSELog, prevEntropy-\u003efse.offcodeCTable,\n                                        OF_defaultNorm, OF_defaultNormLog,\n                                        defaultPolicy, strategy);\n        assert(!(Offtype \u003c set_compressed \u0026\u0026 nextEntropy-\u003efse.offcode_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(\n                op, (size_t)(oend - op),\n                CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,\n                count, max, ofCodeTable, nbSeq,\n                OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,\n                prevEntropy-\u003efse.offcodeCTable,\n                sizeof(prevEntropy-\u003efse.offcodeCTable),\n                entropyWorkspace, entropyWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for Offsets failed\");\n            if (Offtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n            assert(op \u003c= oend);\n    }   }\n    /* build CTable for MatchLengths */\n    {   unsigned max = MaxML;\n        size_t const mostFrequent = HIST_countFast_wksp(\n            count, \u0026max, mlCodeTable, nbSeq, entropyWorkspace, entropyWkspSize);   /* can't fail */\n        DEBUGLOG(5, \"Building ML table (remaining space : %i)\", (int)(oend-op));\n        nextEntropy-\u003efse.matchlength_repeatMode = prevEntropy-\u003efse.matchlength_repeatMode;\n        MLtype = ZSTD_selectEncodingType(\u0026nextEntropy-\u003efse.matchlength_repeatMode,\n                                        count, max, mostFrequent, nbSeq,\n                                        MLFSELog, prevEntropy-\u003efse.matchlengthCTable,\n                                        ML_defaultNorm, ML_defaultNormLog,\n                                        ZSTD_defaultAllowed, strategy);\n        assert(!(MLtype \u003c set_compressed \u0026\u0026 nextEntropy-\u003efse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(\n                op, (size_t)(oend - op),\n                CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,\n                count, max, mlCodeTable, nbSeq,\n                ML_defaultNorm, ML_defaultNormLog, MaxML,\n                prevEntropy-\u003efse.matchlengthCTable,\n                sizeof(prevEntropy-\u003efse.matchlengthCTable),\n                entropyWorkspace, entropyWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for MatchLengths failed\");\n            if (MLtype == set_compressed)\n                lastNCount = op;\n            op += countSize;\n            assert(op \u003c= oend);\n    }   }\n\n    *seqHead = (BYTE)((LLtype\u003c\u003c6) + (Offtype\u003c\u003c4) + (MLtype\u003c\u003c2));\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, (size_t)(oend - op),\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n        assert(op \u003c= oend);\n        /* zstd versions \u003c= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() receives a buffer \u003c 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastNCount \u0026\u0026 (op - lastNCount) \u003c 4) {\n            /* NCountSize \u003e= 2 \u0026\u0026 bitstreamSize \u003e 0 ==\u003e lastCountSize == 3 */\n            assert(op - lastNCount == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions \u003c= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    DEBUGLOG(5, \"compressed block size : %u\", (unsigned)(op - ostart));\n    return (size_t)(op - ostart);\n}","filepath":"lib/compress/zstd_compress.c","line_number":2189,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2457808":{"score":0.86318815,"function_name":"ZSTD_mergeBlockDelimiters","code":"size_t ZSTD_mergeBlockDelimiters(ZSTD_Sequence* sequences, size_t seqsSize) {\n    size_t in = 0;\n    size_t out = 0;\n    for (; in \u003c seqsSize; ++in) {\n        if (sequences[in].offset == 0 \u0026\u0026 sequences[in].matchLength == 0) {\n            if (in != seqsSize - 1) {\n                sequences[in+1].litLength += sequences[in].litLength;\n            }\n        } else {\n            sequences[out] = sequences[in];\n            ++out;\n        }\n    }\n    return out;\n}","filepath":"lib/compress/zstd_compress.c","line_number":2643,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2465168":{"score":0.8282689,"function_name":"ZSTD_writeSkippableFrame","code":"size_t ZSTD_writeSkippableFrame(void* dst, size_t dstCapacity,\n                                const void* src, size_t srcSize, unsigned magicVariant) {\n    BYTE* op = (BYTE*)dst;\n    RETURN_ERROR_IF(dstCapacity \u003c srcSize + ZSTD_SKIPPABLEHEADERSIZE /* Skippable frame overhead */,\n                    dstSize_tooSmall, \"Not enough room for skippable frame\");\n    RETURN_ERROR_IF(srcSize \u003e (unsigned)0xFFFFFFFF, srcSize_wrong, \"Src size too large for skippable frame\");\n    RETURN_ERROR_IF(magicVariant \u003e 15, parameter_outOfBound, \"Skippable frame magic number variant not supported\");\n\n    MEM_writeLE32(op, (U32)(ZSTD_MAGIC_SKIPPABLE_START + magicVariant));\n    MEM_writeLE32(op+4, (U32)srcSize);\n    ZSTD_memcpy(op+8, src, srcSize);\n    return srcSize + ZSTD_SKIPPABLEHEADERSIZE;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3007,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2465296":{"score":0.72501665,"function_name":"ZSTD_writeLastEmptyBlock","code":"size_t ZSTD_writeLastEmptyBlock(void* dst, size_t dstCapacity)\n{\n    RETURN_ERROR_IF(dstCapacity \u003c ZSTD_blockHeaderSize, dstSize_tooSmall,\n                    \"dst buf is too small to write frame trailer empty block.\");\n    {   U32 const cBlockHeader24 = 1 /*lastBlock*/ + (((U32)bt_raw)\u003c\u003c1);  /* 0 size */\n        MEM_writeLE24(dst, cBlockHeader24);\n        return ZSTD_blockHeaderSize;\n    }\n}","filepath":"lib/compress/zstd_compress.c","line_number":3026,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2465328":{"score":0.8734579,"function_name":"ZSTD_referenceExternalSequences","code":"size_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq)\n{\n    RETURN_ERROR_IF(cctx-\u003estage != ZSTDcs_init, stage_wrong,\n                    \"wrong cctx stage\");\n    RETURN_ERROR_IF(cctx-\u003eappliedParams.ldmParams.enableLdm,\n                    parameter_unsupported,\n                    \"incompatible with ldm\");\n    cctx-\u003eexternSeqStore.seq = seq;\n    cctx-\u003eexternSeqStore.size = nbSeq;\n    cctx-\u003eexternSeqStore.capacity = nbSeq;\n    cctx-\u003eexternSeqStore.pos = 0;\n    cctx-\u003eexternSeqStore.posInSequence = 0;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3036,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2466816":{"score":0.92130053,"function_name":"ZSTD_loadCEntropy","code":"size_t ZSTD_loadCEntropy(ZSTD_compressedBlockState_t* bs, void* workspace,\n                         const void* const dict, size_t dictSize)\n{\n    short offcodeNCount[MaxOff+1];\n    unsigned offcodeMaxValue = MaxOff;\n    const BYTE* dictPtr = (const BYTE*)dict;    /* skip magic num and dict ID */\n    const BYTE* const dictEnd = dictPtr + dictSize;\n    dictPtr += 8;\n    bs-\u003eentropy.huf.repeatMode = HUF_repeat_check;\n\n    {   unsigned maxSymbolValue = 255;\n        unsigned hasZeroWeights = 1;\n        size_t const hufHeaderSize = HUF_readCTable((HUF_CElt*)bs-\u003eentropy.huf.CTable, \u0026maxSymbolValue, dictPtr,\n            dictEnd-dictPtr, \u0026hasZeroWeights);\n\n        /* We only set the loaded table as valid if it contains all non-zero\n         * weights. Otherwise, we set it to check */\n        if (!hasZeroWeights)\n            bs-\u003eentropy.huf.repeatMode = HUF_repeat_valid;\n\n        RETURN_ERROR_IF(HUF_isError(hufHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(maxSymbolValue \u003c 255, dictionary_corrupted, \"\");\n        dictPtr += hufHeaderSize;\n    }\n\n    {   unsigned offcodeLog;\n        size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, \u0026offcodeMaxValue, \u0026offcodeLog, dictPtr, dictEnd-dictPtr);\n        RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(offcodeLog \u003e OffFSELog, dictionary_corrupted, \"\");\n        /* fill all offset symbols to avoid garbage at end of table */\n        RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(\n                bs-\u003eentropy.fse.offcodeCTable,\n                offcodeNCount, MaxOff, offcodeLog,\n                workspace, HUF_WORKSPACE_SIZE)),\n            dictionary_corrupted, \"\");\n        /* Defer checking offcodeMaxValue because we need to know the size of the dictionary content */\n        dictPtr += offcodeHeaderSize;\n    }\n\n    {   short matchlengthNCount[MaxML+1];\n        unsigned matchlengthMaxValue = MaxML, matchlengthLog;\n        size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, \u0026matchlengthMaxValue, \u0026matchlengthLog, dictPtr, dictEnd-dictPtr);\n        RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(matchlengthLog \u003e MLFSELog, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(\n                bs-\u003eentropy.fse.matchlengthCTable,\n                matchlengthNCount, matchlengthMaxValue, matchlengthLog,\n                workspace, HUF_WORKSPACE_SIZE)),\n            dictionary_corrupted, \"\");\n        bs-\u003eentropy.fse.matchlength_repeatMode = ZSTD_dictNCountRepeat(matchlengthNCount, matchlengthMaxValue, MaxML);\n        dictPtr += matchlengthHeaderSize;\n    }\n\n    {   short litlengthNCount[MaxLL+1];\n        unsigned litlengthMaxValue = MaxLL, litlengthLog;\n        size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, \u0026litlengthMaxValue, \u0026litlengthLog, dictPtr, dictEnd-dictPtr);\n        RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(litlengthLog \u003e LLFSELog, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(\n                bs-\u003eentropy.fse.litlengthCTable,\n                litlengthNCount, litlengthMaxValue, litlengthLog,\n                workspace, HUF_WORKSPACE_SIZE)),\n            dictionary_corrupted, \"\");\n        bs-\u003eentropy.fse.litlength_repeatMode = ZSTD_dictNCountRepeat(litlengthNCount, litlengthMaxValue, MaxLL);\n        dictPtr += litlengthHeaderSize;\n    }\n\n    RETURN_ERROR_IF(dictPtr+12 \u003e dictEnd, dictionary_corrupted, \"\");\n    bs-\u003erep[0] = MEM_readLE32(dictPtr+0);\n    bs-\u003erep[1] = MEM_readLE32(dictPtr+4);\n    bs-\u003erep[2] = MEM_readLE32(dictPtr+8);\n    dictPtr += 12;\n\n    {   size_t const dictContentSize = (size_t)(dictEnd - dictPtr);\n        U32 offcodeMax = MaxOff;\n        if (dictContentSize \u003c= ((U32)-1) - 128 KB) {\n            U32 const maxOffset = (U32)dictContentSize + 128 KB; /* The maximum offset that must be supported */\n            offcodeMax = ZSTD_highbit32(maxOffset); /* Calculate minimum offset code required to represent maxOffset */\n        }\n        /* All offset values \u003c= dictContentSize + 128 KB must be representable for a valid table */\n        bs-\u003eentropy.fse.offcode_repeatMode = ZSTD_dictNCountRepeat(offcodeNCount, offcodeMaxValue, MIN(offcodeMax, MaxOff));\n\n        /* All repCodes must be \u003c= dictContentSize and != 0 */\n        {   U32 u;\n            for (u=0; u\u003c3; u++) {\n                RETURN_ERROR_IF(bs-\u003erep[u] == 0, dictionary_corrupted, \"\");\n                RETURN_ERROR_IF(bs-\u003erep[u] \u003e dictContentSize, dictionary_corrupted, \"\");\n    }   }   }\n\n    return dictPtr - (const BYTE*)dict;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3231,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2467760":{"score":0.6909125,"function_name":"ZSTD_compress_insertDictionary","code":"static size_t\nZSTD_compress_insertDictionary(ZSTD_compressedBlockState_t* bs,\n                               ZSTD_matchState_t* ms,\n                               ldmState_t* ls,\n                               ZSTD_cwksp* ws,\n                         const ZSTD_CCtx_params* params,\n                         const void* dict, size_t dictSize,\n                               ZSTD_dictContentType_e dictContentType,\n                               ZSTD_dictTableLoadMethod_e dtlm,\n                               void* workspace)\n{\n    DEBUGLOG(4, \"ZSTD_compress_insertDictionary (dictSize=%u)\", (U32)dictSize);\n    if ((dict==NULL) || (dictSize\u003c8)) {\n        RETURN_ERROR_IF(dictContentType == ZSTD_dct_fullDict, dictionary_wrong, \"\");\n        return 0;\n    }\n\n    ZSTD_reset_compressedBlockState(bs);\n\n    /* dict restricted modes */\n    if (dictContentType == ZSTD_dct_rawContent)\n        return ZSTD_loadDictionaryContent(ms, ls, ws, params, dict, dictSize, dtlm);\n\n    if (MEM_readLE32(dict) != ZSTD_MAGIC_DICTIONARY) {\n        if (dictContentType == ZSTD_dct_auto) {\n            DEBUGLOG(4, \"raw content dictionary detected\");\n            return ZSTD_loadDictionaryContent(\n                ms, ls, ws, params, dict, dictSize, dtlm);\n        }\n        RETURN_ERROR_IF(dictContentType == ZSTD_dct_fullDict, dictionary_wrong, \"\");\n        assert(0);   /* impossible */\n    }\n\n    /* dict as full zstd dictionary */\n    return ZSTD_loadZstdDictionary(\n        bs, ms, ws, params, dict, dictSize, dtlm, workspace);\n}","filepath":"lib/compress/zstd_compress.c","line_number":3364,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2468064":{"score":0.73293763,"function_name":"ZSTD_compressBegin_internal","code":"static size_t ZSTD_compressBegin_internal(ZSTD_CCtx* cctx,\n                                    const void* dict, size_t dictSize,\n                                    ZSTD_dictContentType_e dictContentType,\n                                    ZSTD_dictTableLoadMethod_e dtlm,\n                                    const ZSTD_CDict* cdict,\n                                    const ZSTD_CCtx_params* params, U64 pledgedSrcSize,\n                                    ZSTD_buffered_policy_e zbuff)\n{\n#if ZSTD_TRACE\n    cctx-\u003etraceCtx = ZSTD_trace_compress_begin(cctx);\n#endif\n    DEBUGLOG(4, \"ZSTD_compressBegin_internal: wlog=%u\", params-\u003ecParams.windowLog);\n    /* params are supposed to be fully validated at this point */\n    assert(!ZSTD_isError(ZSTD_checkCParams(params-\u003ecParams)));\n    assert(!((dict) \u0026\u0026 (cdict)));  /* either dict or cdict, not both */\n    if ( (cdict)\n      \u0026\u0026 (cdict-\u003edictContentSize \u003e 0)\n      \u0026\u0026 ( pledgedSrcSize \u003c ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF\n        || pledgedSrcSize \u003c cdict-\u003edictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER\n        || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN\n        || cdict-\u003ecompressionLevel == 0)\n      \u0026\u0026 (params-\u003eattachDictPref != ZSTD_dictForceLoad) ) {\n        return ZSTD_resetCCtx_usingCDict(cctx, cdict, params, pledgedSrcSize, zbuff);\n    }\n\n    FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, *params, pledgedSrcSize,\n                                     ZSTDcrp_makeClean, zbuff) , \"\");\n    {   size_t const dictID = cdict ?\n                ZSTD_compress_insertDictionary(\n                        cctx-\u003eblockState.prevCBlock, \u0026cctx-\u003eblockState.matchState,\n                        \u0026cctx-\u003eldmState, \u0026cctx-\u003eworkspace, \u0026cctx-\u003eappliedParams, cdict-\u003edictContent,\n                        cdict-\u003edictContentSize, cdict-\u003edictContentType, dtlm,\n                        cctx-\u003eentropyWorkspace)\n              : ZSTD_compress_insertDictionary(\n                        cctx-\u003eblockState.prevCBlock, \u0026cctx-\u003eblockState.matchState,\n                        \u0026cctx-\u003eldmState, \u0026cctx-\u003eworkspace, \u0026cctx-\u003eappliedParams, dict, dictSize,\n                        dictContentType, dtlm, cctx-\u003eentropyWorkspace);\n        FORWARD_IF_ERROR(dictID, \"ZSTD_compress_insertDictionary failed\");\n        assert(dictID \u003c= UINT_MAX);\n        cctx-\u003edictID = (U32)dictID;\n        cctx-\u003edictContentSize = cdict ? cdict-\u003edictContentSize : dictSize;\n    }\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3407,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2470048":{"score":0.5842073,"function_name":"ZSTD_compressBegin_advanced_internal","code":"size_t ZSTD_compressBegin_advanced_internal(ZSTD_CCtx* cctx,\n                                    const void* dict, size_t dictSize,\n                                    ZSTD_dictContentType_e dictContentType,\n                                    ZSTD_dictTableLoadMethod_e dtlm,\n                                    const ZSTD_CDict* cdict,\n                                    const ZSTD_CCtx_params* params,\n                                    unsigned long long pledgedSrcSize)\n{\n    DEBUGLOG(4, \"ZSTD_compressBegin_advanced_internal: wlog=%u\", params-\u003ecParams.windowLog);\n    /* compression parameters verification and optimization */\n    FORWARD_IF_ERROR( ZSTD_checkCParams(params-\u003ecParams) , \"\");\n    return ZSTD_compressBegin_internal(cctx,\n                                       dict, dictSize, dictContentType, dtlm,\n                                       cdict,\n                                       params, pledgedSrcSize,\n                                       ZSTDb_not_buffered);\n}","filepath":"lib/compress/zstd_compress.c","line_number":3452,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2471488":{"score":0.83400357,"function_name":"ZSTD_CCtx_trace","code":"void ZSTD_CCtx_trace(ZSTD_CCtx* cctx, size_t extraCSize)\n{\n#if ZSTD_TRACE\n    if (cctx-\u003etraceCtx) {\n        int const streaming = cctx-\u003einBuffSize \u003e 0 || cctx-\u003eoutBuffSize \u003e 0 || cctx-\u003eappliedParams.nbWorkers \u003e 0;\n        ZSTD_Trace trace;\n        ZSTD_memset(\u0026trace, 0, sizeof(trace));\n        trace.version = ZSTD_VERSION_NUMBER;\n        trace.streaming = streaming;\n        trace.dictionaryID = cctx-\u003edictID;\n        trace.dictionarySize = cctx-\u003edictContentSize;\n        trace.uncompressedSize = cctx-\u003econsumedSrcSize;\n        trace.compressedSize = cctx-\u003eproducedCSize + extraCSize;\n        trace.params = \u0026cctx-\u003eappliedParams;\n        trace.cctx = cctx;\n        ZSTD_trace_compress_end(cctx-\u003etraceCtx, \u0026trace);\n    }\n    cctx-\u003etraceCtx = 0;\n#else\n    (void)cctx;\n    (void)extraCSize;\n#endif\n}","filepath":"lib/compress/zstd_compress.c","line_number":3544,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2476896":{"score":0.6129842,"function_name":"ZSTD_sizeof_matchState","code":"static size_t\nZSTD_sizeof_matchState(const ZSTD_compressionParameters* const cParams,\n                       const U32 forCCtx)\n{\n    size_t const chainSize = (cParams-\u003estrategy == ZSTD_fast) ? 0 : ((size_t)1 \u003c\u003c cParams-\u003echainLog);\n    size_t const hSize = ((size_t)1) \u003c\u003c cParams-\u003ehashLog;\n    U32    const hashLog3 = (forCCtx \u0026\u0026 cParams-\u003eminMatch==3) ? MIN(ZSTD_HASHLOG3_MAX, cParams-\u003ewindowLog) : 0;\n    size_t const h3Size = hashLog3 ? ((size_t)1) \u003c\u003c hashLog3 : 0;\n    /* We don't use ZSTD_cwksp_alloc_size() here because the tables aren't\n     * surrounded by redzones in ASAN. */\n    size_t const tableSpace = chainSize * sizeof(U32)\n                            + hSize * sizeof(U32)\n                            + h3Size * sizeof(U32);\n    size_t const optPotentialSpace =\n        ZSTD_cwksp_alloc_size((MaxML+1) * sizeof(U32))\n      + ZSTD_cwksp_alloc_size((MaxLL+1) * sizeof(U32))\n      + ZSTD_cwksp_alloc_size((MaxOff+1) * sizeof(U32))\n      + ZSTD_cwksp_alloc_size((1\u003c\u003cLitbits) * sizeof(U32))\n      + ZSTD_cwksp_alloc_size((ZSTD_OPT_NUM+1) * sizeof(ZSTD_match_t))\n      + ZSTD_cwksp_alloc_size((ZSTD_OPT_NUM+1) * sizeof(ZSTD_optimal_t));\n    size_t const optSpace = (forCCtx \u0026\u0026 (cParams-\u003estrategy \u003e= ZSTD_btopt))\n                                ? optPotentialSpace\n                                : 0;\n    DEBUGLOG(4, \"chainSize: %u - hSize: %u - h3Size: %u\",\n                (U32)chainSize, (U32)hSize, (U32)h3Size);\n    return tableSpace + optSpace;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1299,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2477312":{"score":0.6621785,"function_name":"ZSTD_sizeof_CCtx","code":"size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx)\n{\n    if (cctx==NULL) return 0;   /* support sizeof on NULL */\n    /* cctx may be in the workspace */\n    return (cctx-\u003eworkspace.workspace == cctx ? 0 : sizeof(*cctx))\n           + ZSTD_cwksp_sizeof(\u0026cctx-\u003eworkspace)\n           + ZSTD_sizeof_localDict(cctx-\u003elocalDict)\n           + ZSTD_sizeof_mtctx(cctx);\n}","filepath":"lib/compress/zstd_compress.c","line_number":187,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2477360":{"score":0.5648695,"function_name":"ZSTD_createCDict_advanced2","code":"ZSTDLIB_API ZSTD_CDict* ZSTD_createCDict_advanced2(\n        const void* dict, size_t dictSize,\n        ZSTD_dictLoadMethod_e dictLoadMethod,\n        ZSTD_dictContentType_e dictContentType,\n        const ZSTD_CCtx_params* originalCctxParams,\n        ZSTD_customMem customMem)\n{\n    ZSTD_CCtx_params cctxParams = *originalCctxParams;\n    ZSTD_compressionParameters cParams;\n    ZSTD_CDict* cdict;\n\n    DEBUGLOG(3, \"ZSTD_createCDict_advanced2, mode %u\", (unsigned)dictContentType);\n    if (!customMem.customAlloc ^ !customMem.customFree) return NULL;\n\n    if (cctxParams.enableDedicatedDictSearch) {\n        cParams = ZSTD_dedicatedDictSearch_getCParams(\n            cctxParams.compressionLevel, dictSize);\n        ZSTD_overrideCParams(\u0026cParams, \u0026cctxParams.cParams);\n    } else {\n        cParams = ZSTD_getCParamsFromCCtxParams(\n            \u0026cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);\n    }\n\n    if (!ZSTD_dedicatedDictSearch_isSupported(\u0026cParams)) {\n        /* Fall back to non-DDSS params */\n        cctxParams.enableDedicatedDictSearch = 0;\n        cParams = ZSTD_getCParamsFromCCtxParams(\n            \u0026cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);\n    }\n\n    cctxParams.cParams = cParams;\n\n    cdict = ZSTD_createCDict_advanced_internal(dictSize,\n                        dictLoadMethod, cctxParams.cParams,\n                        customMem);\n\n    if (ZSTD_isError( ZSTD_initCDict_internal(cdict,\n                                    dict, dictSize,\n                                    dictLoadMethod, dictContentType,\n                                    cctxParams) )) {\n        ZSTD_freeCDict(cdict);\n        return NULL;\n    }\n\n    return cdict;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3808,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2479680":{"score":0.69649565,"function_name":"ZSTD_CCtx_init_compressStream2","code":"static size_t ZSTD_CCtx_init_compressStream2(ZSTD_CCtx* cctx,\n                                             ZSTD_EndDirective endOp,\n                                             size_t inSize) {\n    ZSTD_CCtx_params params = cctx-\u003erequestedParams;\n    ZSTD_prefixDict const prefixDict = cctx-\u003eprefixDict;\n    FORWARD_IF_ERROR( ZSTD_initLocalDict(cctx) , \"\"); /* Init the local dict if present. */\n    ZSTD_memset(\u0026cctx-\u003eprefixDict, 0, sizeof(cctx-\u003eprefixDict));   /* single usage */\n    assert(prefixDict.dict==NULL || cctx-\u003ecdict==NULL);    /* only one can be set */\n    if (cctx-\u003ecdict)\n        params.compressionLevel = cctx-\u003ecdict-\u003ecompressionLevel; /* let cdict take priority in terms of compression level */\n    DEBUGLOG(4, \"ZSTD_compressStream2 : transparent init stage\");\n    if (endOp == ZSTD_e_end) cctx-\u003epledgedSrcSizePlusOne = inSize + 1;  /* auto-fix pledgedSrcSize */\n    {\n        size_t const dictSize = prefixDict.dict\n                ? prefixDict.dictSize\n                : (cctx-\u003ecdict ? cctx-\u003ecdict-\u003edictContentSize : 0);\n        ZSTD_cParamMode_e const mode = ZSTD_getCParamMode(cctx-\u003ecdict, \u0026params, cctx-\u003epledgedSrcSizePlusOne - 1);\n        params.cParams = ZSTD_getCParamsFromCCtxParams(\n                \u0026params, cctx-\u003epledgedSrcSizePlusOne-1,\n                dictSize, mode);\n    }\n\n    if (ZSTD_CParams_shouldEnableLdm(\u0026params.cParams)) {\n        /* Enable LDM by default for optimal parser and window size \u003e= 128MB */\n        DEBUGLOG(4, \"LDM enabled by default (window size \u003e= 128MB, strategy \u003e= btopt)\");\n        params.ldmParams.enableLdm = 1;\n    }\n\n#ifdef ZSTD_MULTITHREAD\n    if ((cctx-\u003epledgedSrcSizePlusOne-1) \u003c= ZSTDMT_JOBSIZE_MIN) {\n        params.nbWorkers = 0; /* do not invoke multi-threading when src size is too small */\n    }\n    if (params.nbWorkers \u003e 0) {\n#if ZSTD_TRACE\n        cctx-\u003etraceCtx = ZSTD_trace_compress_begin(cctx);\n#endif\n        /* mt context creation */\n        if (cctx-\u003emtctx == NULL) {\n            DEBUGLOG(4, \"ZSTD_compressStream2: creating new mtctx for nbWorkers=%u\",\n                        params.nbWorkers);\n            cctx-\u003emtctx = ZSTDMT_createCCtx_advanced((U32)params.nbWorkers, cctx-\u003ecustomMem, cctx-\u003epool);\n            RETURN_ERROR_IF(cctx-\u003emtctx == NULL, memory_allocation, \"NULL pointer!\");\n        }\n        /* mt compression */\n        DEBUGLOG(4, \"call ZSTDMT_initCStream_internal as nbWorkers=%u\", params.nbWorkers);\n        FORWARD_IF_ERROR( ZSTDMT_initCStream_internal(\n                    cctx-\u003emtctx,\n                    prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType,\n                    cctx-\u003ecdict, params, cctx-\u003epledgedSrcSizePlusOne-1) , \"\");\n        cctx-\u003edictID = cctx-\u003ecdict ? cctx-\u003ecdict-\u003edictID : 0;\n        cctx-\u003edictContentSize = cctx-\u003ecdict ? cctx-\u003ecdict-\u003edictContentSize : prefixDict.dictSize;\n        cctx-\u003econsumedSrcSize = 0;\n        cctx-\u003eproducedCSize = 0;\n        cctx-\u003estreamStage = zcss_load;\n        cctx-\u003eappliedParams = params;\n    } else\n#endif\n    {   U64 const pledgedSrcSize = cctx-\u003epledgedSrcSizePlusOne - 1;\n        assert(!ZSTD_isError(ZSTD_checkCParams(params.cParams)));\n        FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,\n                prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType, ZSTD_dtlm_fast,\n                cctx-\u003ecdict,\n                \u0026params, pledgedSrcSize,\n                ZSTDb_buffered) , \"\");\n        assert(cctx-\u003eappliedParams.nbWorkers == 0);\n        cctx-\u003einToCompress = 0;\n        cctx-\u003einBuffPos = 0;\n        if (cctx-\u003eappliedParams.inBufferMode == ZSTD_bm_buffered) {\n            /* for small input: avoid automatic flush on reaching end of block, since\n            * it would require to add a 3-bytes null block to end frame\n            */\n            cctx-\u003einBuffTarget = cctx-\u003eblockSize + (cctx-\u003eblockSize == pledgedSrcSize);\n        } else {\n            cctx-\u003einBuffTarget = 0;\n        }\n        cctx-\u003eoutBuffContentSize = cctx-\u003eoutBuffFlushedSize = 0;\n        cctx-\u003estreamStage = zcss_load;\n        cctx-\u003eframeEnded = 0;\n    }\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":4433,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2481088":{"score":0.7631506,"function_name":"ZSTD_generateSequences","code":"size_t ZSTD_generateSequences(ZSTD_CCtx* zc, ZSTD_Sequence* outSeqs,\n                              size_t outSeqsSize, const void* src, size_t srcSize)\n{\n    const size_t dstCapacity = ZSTD_compressBound(srcSize);\n    void* dst = ZSTD_customMalloc(dstCapacity, ZSTD_defaultCMem);\n    SeqCollector seqCollector;\n\n    RETURN_ERROR_IF(dst == NULL, memory_allocation, \"NULL pointer!\");\n\n    seqCollector.collectSequences = 1;\n    seqCollector.seqStart = outSeqs;\n    seqCollector.seqIndex = 0;\n    seqCollector.maxSequences = outSeqsSize;\n    zc-\u003eseqCollector = seqCollector;\n\n    ZSTD_compress2(zc, dst, dstCapacity, src, srcSize);\n    ZSTD_customFree(dst, ZSTD_defaultCMem);\n    return zc-\u003eseqCollector.seqIndex;\n}","filepath":"lib/compress/zstd_compress.c","line_number":2623,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2481728":{"score":0.7164246,"function_name":"ZSTD_createCDict","code":"ZSTD_CDict* ZSTD_createCDict(const void* dict, size_t dictSize, int compressionLevel)\n{\n    ZSTD_compressionParameters cParams = ZSTD_getCParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);\n    ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dict, dictSize,\n                                                  ZSTD_dlm_byCopy, ZSTD_dct_auto,\n                                                  cParams, ZSTD_defaultCMem);\n    if (cdict)\n        cdict-\u003ecompressionLevel = (compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT : compressionLevel;\n    return cdict;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3855,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2482400":{"score":0.71778464,"function_name":"ZSTD_createCDict","code":"ZSTD_CDict* ZSTD_createCDict(const void* dict, size_t dictSize, int compressionLevel)\n{\n    ZSTD_compressionParameters cParams = ZSTD_getCParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);\n    ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dict, dictSize,\n                                                  ZSTD_dlm_byCopy, ZSTD_dct_auto,\n                                                  cParams, ZSTD_defaultCMem);\n    if (cdict)\n        cdict-\u003ecompressionLevel = (compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT : compressionLevel;\n    return cdict;\n}","filepath":"lib/compress/zstd_compress.c","line_number":3855,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2483072":{"score":0.6779075,"function_name":"ZSTD_freeCDict","code":"size_t ZSTD_freeCDict(ZSTD_CDict* cdict)\n{\n    if (cdict==NULL) return 0;   /* support free on NULL */\n    {   ZSTD_customMem const cMem = cdict-\u003ecustomMem;\n        int cdictInWorkspace = ZSTD_cwksp_owns_buffer(\u0026cdict-\u003eworkspace, cdict);\n        ZSTD_cwksp_free(\u0026cdict-\u003eworkspace, cMem);\n        if (!cdictInWorkspace) {\n            ZSTD_customFree(cdict, cMem);\n        }\n        return 0;\n    }\n}","filepath":"lib/compress/zstd_compress.c","line_number":3877,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2485904":{"score":0.63257897,"function_name":"ZSTD_compressBegin_usingCDict_advanced","code":"size_t ZSTD_compressBegin_usingCDict_advanced(\n    ZSTD_CCtx* const cctx, const ZSTD_CDict* const cdict,\n    ZSTD_frameParameters const fParams, unsigned long long const pledgedSrcSize)\n{\n    ZSTD_CCtx_params cctxParams;\n    DEBUGLOG(4, \"ZSTD_compressBegin_usingCDict_advanced\");\n    RETURN_ERROR_IF(cdict==NULL, dictionary_wrong, \"NULL pointer!\");\n    /* Initialize the cctxParams from the cdict */\n    {\n        ZSTD_parameters params;\n        params.fParams = fParams;\n        params.cParams = ( pledgedSrcSize \u003c ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF\n                        || pledgedSrcSize \u003c cdict-\u003edictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER\n                        || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN\n                        || cdict-\u003ecompressionLevel == 0 ) ?\n                ZSTD_getCParamsFromCDict(cdict)\n              : ZSTD_getCParams(cdict-\u003ecompressionLevel,\n                                pledgedSrcSize,\n                                cdict-\u003edictContentSize);\n        ZSTD_CCtxParams_init_internal(\u0026cctxParams, \u0026params, cdict-\u003ecompressionLevel);\n    }\n    /* Increase window log to fit the entire dictionary and source if the\n     * source size is known. Limit the increase to 19, which is the\n     * window log for compression level 1 with the largest source size.\n     */\n    if (pledgedSrcSize != ZSTD_CONTENTSIZE_UNKNOWN) {\n        U32 const limitedSrcSize = (U32)MIN(pledgedSrcSize, 1U \u003c\u003c 19);\n        U32 const limitedSrcLog = limitedSrcSize \u003e 1 ? ZSTD_highbit32(limitedSrcSize - 1) + 1 : 1;\n        cctxParams.cParams.windowLog = MAX(cctxParams.cParams.windowLog, limitedSrcLog);\n    }\n    return ZSTD_compressBegin_internal(cctx,\n                                        NULL, 0, ZSTD_dct_auto, ZSTD_dtlm_fast,\n                                        cdict,\n                                        \u0026cctxParams, pledgedSrcSize,\n                                        ZSTDb_not_buffered);\n}","filepath":"lib/compress/zstd_compress.c","line_number":3964,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2486768":{"score":0.79256356,"function_name":"ZSTD_initStaticCCtx","code":"ZSTD_CCtx* ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize)\n{\n    ZSTD_cwksp ws;\n    ZSTD_CCtx* cctx;\n    if (workspaceSize \u003c= sizeof(ZSTD_CCtx)) return NULL;  /* minimum size */\n    if ((size_t)workspace \u0026 7) return NULL;  /* must be 8-aligned */\n    ZSTD_cwksp_init(\u0026ws, workspace, workspaceSize, ZSTD_cwksp_static_alloc);\n\n    cctx = (ZSTD_CCtx*)ZSTD_cwksp_reserve_object(\u0026ws, sizeof(ZSTD_CCtx));\n    if (cctx == NULL) return NULL;\n\n    ZSTD_memset(cctx, 0, sizeof(ZSTD_CCtx));\n    ZSTD_cwksp_move(\u0026cctx-\u003eworkspace, \u0026ws);\n    cctx-\u003estaticSize = workspaceSize;\n\n    /* statically sized space. entropyWorkspace never moves (but prev/next block swap places) */\n    if (!ZSTD_cwksp_check_available(\u0026cctx-\u003eworkspace, ENTROPY_WORKSPACE_SIZE + 2 * sizeof(ZSTD_compressedBlockState_t))) return NULL;\n    cctx-\u003eblockState.prevCBlock = (ZSTD_compressedBlockState_t*)ZSTD_cwksp_reserve_object(\u0026cctx-\u003eworkspace, sizeof(ZSTD_compressedBlockState_t));\n    cctx-\u003eblockState.nextCBlock = (ZSTD_compressedBlockState_t*)ZSTD_cwksp_reserve_object(\u0026cctx-\u003eworkspace, sizeof(ZSTD_compressedBlockState_t));\n    cctx-\u003eentropyWorkspace = (U32*)ZSTD_cwksp_reserve_object(\u0026cctx-\u003eworkspace, ENTROPY_WORKSPACE_SIZE);\n    cctx-\u003ebmi2 = ZSTD_cpuid_bmi2(ZSTD_cpuid());\n    return cctx;\n}","filepath":"lib/compress/zstd_compress.c","line_number":106,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2488560":{"score":0.6128678,"function_name":"ZSTD_CCtx_refCDict","code":"size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict)\n{\n    RETURN_ERROR_IF(cctx-\u003estreamStage != zcss_init, stage_wrong,\n                    \"Can't ref a dict when ctx not in init stage.\");\n    /* Free the existing local cdict (if any) to save memory. */\n    ZSTD_clearAllDicts(cctx);\n    cctx-\u003ecdict = cdict;\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":1055,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2489904":{"score":0.56077445,"function_name":"ZSTD_initCStream_srcSize","code":"size_t ZSTD_initCStream_srcSize(ZSTD_CStream* zcs, int compressionLevel, unsigned long long pss)\n{\n    /* temporary : 0 interpreted as \"unknown\" during transition period.\n     * Users willing to specify \"unknown\" **must** use ZSTD_CONTENTSIZE_UNKNOWN.\n     * 0 will be interpreted as \"empty\" in the future.\n     */\n    U64 const pledgedSrcSize = (pss==0) ? ZSTD_CONTENTSIZE_UNKNOWN : pss;\n    DEBUGLOG(4, \"ZSTD_initCStream_srcSize\");\n    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , \"\");\n    FORWARD_IF_ERROR( ZSTD_CCtx_refCDict(zcs, NULL) , \"\");\n    FORWARD_IF_ERROR( ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel) , \"\");\n    FORWARD_IF_ERROR( ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize) , \"\");\n    return 0;\n}","filepath":"lib/compress/zstd_compress.c","line_number":4175,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2490592":{"score":0.8348815,"function_name":"ZSTD_compressStream2","code":"size_t ZSTD_compressStream2( ZSTD_CCtx* cctx,\n                             ZSTD_outBuffer* output,\n                             ZSTD_inBuffer* input,\n                             ZSTD_EndDirective endOp)\n{\n    DEBUGLOG(5, \"ZSTD_compressStream2, endOp=%u \", (unsigned)endOp);\n    /* check conditions */\n    RETURN_ERROR_IF(output-\u003epos \u003e output-\u003esize, dstSize_tooSmall, \"invalid output buffer\");\n    RETURN_ERROR_IF(input-\u003epos  \u003e input-\u003esize, srcSize_wrong, \"invalid input buffer\");\n    RETURN_ERROR_IF((U32)endOp \u003e (U32)ZSTD_e_end, parameter_outOfBound, \"invalid endDirective\");\n    assert(cctx != NULL);\n\n    /* transparent initialization stage */\n    if (cctx-\u003estreamStage == zcss_init) {\n        FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, endOp, input-\u003esize), \"CompressStream2 initialization failed\");\n        ZSTD_setBufferExpectations(cctx, output, input);    /* Set initial buffer expectations now that we've initialized */\n    }\n    /* end of transparent initialization stage */\n\n    FORWARD_IF_ERROR(ZSTD_checkBufferStability(cctx, output, input, endOp), \"invalid buffers\");\n    /* compression stage */\n#ifdef ZSTD_MULTITHREAD\n    if (cctx-\u003eappliedParams.nbWorkers \u003e 0) {\n        size_t flushMin;\n        if (cctx-\u003ecParamsChanged) {\n            ZSTDMT_updateCParams_whileCompressing(cctx-\u003emtctx, \u0026cctx-\u003erequestedParams);\n            cctx-\u003ecParamsChanged = 0;\n        }\n        for (;;) {\n            size_t const ipos = input-\u003epos;\n            size_t const opos = output-\u003epos;\n            flushMin = ZSTDMT_compressStream_generic(cctx-\u003emtctx, output, input, endOp);\n            cctx-\u003econsumedSrcSize += (U64)(input-\u003epos - ipos);\n            cctx-\u003eproducedCSize += (U64)(output-\u003epos - opos);\n            if ( ZSTD_isError(flushMin)\n              || (endOp == ZSTD_e_end \u0026\u0026 flushMin == 0) ) { /* compression completed */\n                if (flushMin == 0)\n                    ZSTD_CCtx_trace(cctx, 0);\n                ZSTD_CCtx_reset(cctx, ZSTD_reset_session_only);\n            }\n            FORWARD_IF_ERROR(flushMin, \"ZSTDMT_compressStream_generic failed\");\n\n            if (endOp == ZSTD_e_continue) {\n                /* We only require some progress with ZSTD_e_continue, not maximal progress.\n                 * We're done if we've consumed or produced any bytes, or either buffer is\n                 * full.\n                 */\n                if (input-\u003epos != ipos || output-\u003epos != opos || input-\u003epos == input-\u003esize || output-\u003epos == output-\u003esize)\n                    break;\n            } else {\n                assert(endOp == ZSTD_e_flush || endOp == ZSTD_e_end);\n                /* We require maximal progress. We're done when the flush is complete or the\n                 * output buffer is full.\n                 */\n                if (flushMin == 0 || output-\u003epos == output-\u003esize)\n                    break;\n            }\n        }\n        DEBUGLOG(5, \"completed ZSTD_compressStream2 delegating to ZSTDMT_compressStream_generic\");\n        /* Either we don't require maximum forward progress, we've finished the\n         * flush, or we are out of output space.\n         */\n        assert(endOp == ZSTD_e_continue || flushMin == 0 || output-\u003epos == output-\u003esize);\n        ZSTD_setBufferExpectations(cctx, output, input);\n        return flushMin;\n    }\n#endif\n    FORWARD_IF_ERROR( ZSTD_compressStream_generic(cctx, output, input, endOp) , \"\");\n    DEBUGLOG(5, \"completed ZSTD_compressStream2\");\n    ZSTD_setBufferExpectations(cctx, output, input);\n    return cctx-\u003eoutBuffContentSize - cctx-\u003eoutBuffFlushedSize; /* remaining to flush */\n}","filepath":"lib/compress/zstd_compress.c","line_number":4515,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2491664":{"score":0.722338,"function_name":"ZSTD_compress2","code":"size_t ZSTD_compress2(ZSTD_CCtx* cctx,\n                      void* dst, size_t dstCapacity,\n                      const void* src, size_t srcSize)\n{\n    ZSTD_bufferMode_e const originalInBufferMode = cctx-\u003erequestedParams.inBufferMode;\n    ZSTD_bufferMode_e const originalOutBufferMode = cctx-\u003erequestedParams.outBufferMode;\n    DEBUGLOG(4, \"ZSTD_compress2 (srcSize=%u)\", (unsigned)srcSize);\n    ZSTD_CCtx_reset(cctx, ZSTD_reset_session_only);\n    /* Enable stable input/output buffers. */\n    cctx-\u003erequestedParams.inBufferMode = ZSTD_bm_stable;\n    cctx-\u003erequestedParams.outBufferMode = ZSTD_bm_stable;\n    {   size_t oPos = 0;\n        size_t iPos = 0;\n        size_t const result = ZSTD_compressStream2_simpleArgs(cctx,\n                                        dst, dstCapacity, \u0026oPos,\n                                        src, srcSize, \u0026iPos,\n                                        ZSTD_e_end);\n        /* Reset to the original values. */\n        cctx-\u003erequestedParams.inBufferMode = originalInBufferMode;\n        cctx-\u003erequestedParams.outBufferMode = originalOutBufferMode;\n        FORWARD_IF_ERROR(result, \"ZSTD_compressStream2_simpleArgs failed\");\n        if (result != 0) {  /* compression not completed, due to lack of output space */\n            assert(oPos == dstCapacity);\n            RETURN_ERROR(dstSize_tooSmall, \"\");\n        }\n        assert(iPos == srcSize);   /* all input is expected consumed */\n        return oPos;\n    }\n}","filepath":"lib/compress/zstd_compress.c","line_number":4603,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2492144":{"score":0.81063485,"function_name":"ZSTD_compressSequences","code":"size_t ZSTD_compressSequences(ZSTD_CCtx* const cctx, void* dst, size_t dstCapacity,\n                              const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                              const void* src, size_t srcSize) {\n    BYTE* op = (BYTE*)dst;\n    size_t cSize = 0;\n    size_t compressedBlocksSize = 0;\n    size_t frameHeaderSize = 0;\n\n    /* Transparent initialization stage, same as compressStream2() */\n    DEBUGLOG(3, \"ZSTD_compressSequences()\");\n    assert(cctx != NULL);\n    FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize), \"CCtx initialization failed\");\n    /* Begin writing output, starting with frame header */\n    frameHeaderSize = ZSTD_writeFrameHeader(op, dstCapacity, \u0026cctx-\u003eappliedParams, srcSize, cctx-\u003edictID);\n    op += frameHeaderSize;\n    dstCapacity -= frameHeaderSize;\n    cSize += frameHeaderSize;\n    if (cctx-\u003eappliedParams.fParams.checksumFlag \u0026\u0026 srcSize) {\n        XXH64_update(\u0026cctx-\u003exxhState, src, srcSize);\n    }\n    /* cSize includes block header size and compressed sequences size */\n    compressedBlocksSize = ZSTD_compressSequences_internal(cctx,\n                                                           op, dstCapacity,\n                                                           inSeqs, inSeqsSize,\n                                                           src, srcSize);\n    FORWARD_IF_ERROR(compressedBlocksSize, \"Compressing blocks failed!\");\n    cSize += compressedBlocksSize;\n    dstCapacity -= compressedBlocksSize;\n\n    if (cctx-\u003eappliedParams.fParams.checksumFlag) {\n        U32 const checksum = (U32) XXH64_digest(\u0026cctx-\u003exxhState);\n        RETURN_ERROR_IF(dstCapacity\u003c4, dstSize_tooSmall, \"no room for checksum\");\n        DEBUGLOG(4, \"Write checksum : %08X\", (unsigned)checksum);\n        MEM_writeLE32((char*)dst + cSize, checksum);\n        cSize += 4;\n    }\n\n    DEBUGLOG(3, \"Final compressed size: %zu\", cSize);\n    return cSize;\n}","filepath":"lib/compress/zstd_compress.c","line_number":4995,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2598704":{"score":0.59184766,"function_name":"ZSTD_selectBlockCompressor","code":"ZSTD_blockCompressor ZSTD_selectBlockCompressor(ZSTD_strategy strat, ZSTD_dictMode_e dictMode)\n{\n    static const ZSTD_blockCompressor blockCompressor[4][ZSTD_STRATEGY_MAX+1] = {\n        { ZSTD_compressBlock_fast  /* default for 0 */,\n          ZSTD_compressBlock_fast,\n          ZSTD_compressBlock_doubleFast,\n          ZSTD_compressBlock_greedy,\n          ZSTD_compressBlock_lazy,\n          ZSTD_compressBlock_lazy2,\n          ZSTD_compressBlock_btlazy2,\n          ZSTD_compressBlock_btopt,\n          ZSTD_compressBlock_btultra,\n          ZSTD_compressBlock_btultra2 },\n        { ZSTD_compressBlock_fast_extDict  /* default for 0 */,\n          ZSTD_compressBlock_fast_extDict,\n          ZSTD_compressBlock_doubleFast_extDict,\n          ZSTD_compressBlock_greedy_extDict,\n          ZSTD_compressBlock_lazy_extDict,\n          ZSTD_compressBlock_lazy2_extDict,\n          ZSTD_compressBlock_btlazy2_extDict,\n          ZSTD_compressBlock_btopt_extDict,\n          ZSTD_compressBlock_btultra_extDict,\n          ZSTD_compressBlock_btultra_extDict },\n        { ZSTD_compressBlock_fast_dictMatchState  /* default for 0 */,\n          ZSTD_compressBlock_fast_dictMatchState,\n          ZSTD_compressBlock_doubleFast_dictMatchState,\n          ZSTD_compressBlock_greedy_dictMatchState,\n          ZSTD_compressBlock_lazy_dictMatchState,\n          ZSTD_compressBlock_lazy2_dictMatchState,\n          ZSTD_compressBlock_btlazy2_dictMatchState,\n          ZSTD_compressBlock_btopt_dictMatchState,\n          ZSTD_compressBlock_btultra_dictMatchState,\n          ZSTD_compressBlock_btultra_dictMatchState },\n        { NULL  /* default for 0 */,\n          NULL,\n          NULL,\n          ZSTD_compressBlock_greedy_dedicatedDictSearch,\n          ZSTD_compressBlock_lazy_dedicatedDictSearch,\n          ZSTD_compressBlock_lazy2_dedicatedDictSearch,\n          NULL,\n          NULL,\n          NULL,\n          NULL }\n    };\n    ZSTD_blockCompressor selectedCompressor;\n    ZSTD_STATIC_ASSERT((unsigned)ZSTD_fast == 1);\n\n    assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));\n    selectedCompressor = blockCompressor[(int)dictMode][(int)strat];\n    assert(selectedCompressor != NULL);\n    return selectedCompressor;\n}","filepath":"lib/compress/zstd_compress.c","line_number":2413,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.4.10"},"2749856":{"score":0.80329967,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U64 const hashPower = ldmState-\u003ehashPower;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    U32 const ldmBucketSize = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hashEveryLog = params-\u003ehashEveryLog;\n    U32 const ldmTagMask = (1U \u003c\u003c params-\u003ehashEveryLog) - 1;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - MAX(minMatchLength, HASH_READ_SIZE);\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash */\n    BYTE const* lastHashed = NULL;\n    U64 rollingHash = 0;\n\n    while (ip \u003c= ilimit) {\n        size_t mLength;\n        U32 const current = (U32)(ip - base);\n        size_t forwardMatchLength = 0, backwardMatchLength = 0;\n        ldmEntry_t* bestEntry = NULL;\n        if (ip != istart) {\n            rollingHash = ZSTD_ldm_updateHash(rollingHash, lastHashed[0],\n                                              lastHashed[minMatchLength],\n                                              hashPower);\n        } else {\n            rollingHash = ZSTD_ldm_getRollingHash(ip, minMatchLength);\n        }\n        lastHashed = ip;\n\n        /* Do not insert and do not look for a match */\n        if (ZSTD_ldm_getTag(rollingHash, hBits, hashEveryLog) != ldmTagMask) {\n           ip++;\n           continue;\n        }\n\n        /* Get the best entry and compute the match lengths */\n        {\n            ldmEntry_t* const bucket =\n                ZSTD_ldm_getBucket(ldmState,\n                                   ZSTD_ldm_getSmallHash(rollingHash, hBits),\n                                   *params);\n            ldmEntry_t* cur;\n            size_t bestMatchLength = 0;\n            U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);\n\n            for (cur = bucket; cur \u003c bucket + ldmBucketSize; ++cur) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n\n                    curForwardMatchLength = ZSTD_count_2segments(\n                                                ip, pMatch, iend,\n                                                matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,\n                                                     lowMatchPtr);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(ip, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,\n                                                     lowPrefixPtr);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                }\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n        }\n\n        /* No match found -- continue searching */\n        if (bestEntry == NULL) {\n            ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash,\n                                             hBits, current,\n                                             *params);\n            ip++;\n            continue;\n        }\n\n        /* Match found */\n        mLength = forwardMatchLength + backwardMatchLength;\n        ip -= backwardMatchLength;\n\n        {\n            /* Store the sequence:\n             * ip = current - backwardMatchLength\n             * The match is at (bestEntry-\u003eoffset - backwardMatchLength)\n             */\n            U32 const matchIndex = bestEntry-\u003eoffset;\n            U32 const offset = current - matchIndex;\n            rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n            /* Out of sequence storage */\n            if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                return ERROR(dstSize_tooSmall);\n            seq-\u003elitLength = (U32)(ip - anchor);\n            seq-\u003ematchLength = (U32)mLength;\n            seq-\u003eoffset = offset;\n            rawSeqStore-\u003esize++;\n        }\n\n        /* Insert the current entry into the hash table */\n        ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash, hBits,\n                                         (U32)(lastHashed - base),\n                                         *params);\n\n        assert(ip + backwardMatchLength == lastHashed);\n\n        /* Fill the hash table from lastHashed+1 to ip+mLength*/\n        /* Heuristic: don't need to fill the entire table at end of block */\n        if (ip + mLength \u003c= ilimit) {\n            rollingHash = ZSTD_ldm_fillLdmHashTable(\n                              ldmState, rollingHash, lastHashed,\n                              ip + mLength, base, hBits, *params);\n            lastHashed = ip + mLength - 1;\n        }\n        ip += mLength;\n        anchor = ip;\n    }\n    return iend - anchor;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":290,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.6"},"2753008":{"score":0.7848208,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U64 const hashPower = ldmState-\u003ehashPower;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    U32 const ldmBucketSize = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hashEveryLog = params-\u003ehashEveryLog;\n    U32 const ldmTagMask = (1U \u003c\u003c params-\u003ehashEveryLog) - 1;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - MAX(minMatchLength, HASH_READ_SIZE);\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash */\n    BYTE const* lastHashed = NULL;\n    U64 rollingHash = 0;\n\n    while (ip \u003c= ilimit) {\n        size_t mLength;\n        U32 const current = (U32)(ip - base);\n        size_t forwardMatchLength = 0, backwardMatchLength = 0;\n        ldmEntry_t* bestEntry = NULL;\n        if (ip != istart) {\n            rollingHash = ZSTD_ldm_updateHash(rollingHash, lastHashed[0],\n                                              lastHashed[minMatchLength],\n                                              hashPower);\n        } else {\n            rollingHash = ZSTD_ldm_getRollingHash(ip, minMatchLength);\n        }\n        lastHashed = ip;\n\n        /* Do not insert and do not look for a match */\n        if (ZSTD_ldm_getTag(rollingHash, hBits, hashEveryLog) != ldmTagMask) {\n           ip++;\n           continue;\n        }\n\n        /* Get the best entry and compute the match lengths */\n        {\n            ldmEntry_t* const bucket =\n                ZSTD_ldm_getBucket(ldmState,\n                                   ZSTD_ldm_getSmallHash(rollingHash, hBits),\n                                   *params);\n            ldmEntry_t* cur;\n            size_t bestMatchLength = 0;\n            U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);\n\n            for (cur = bucket; cur \u003c bucket + ldmBucketSize; ++cur) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n\n                    curForwardMatchLength = ZSTD_count_2segments(\n                                                ip, pMatch, iend,\n                                                matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,\n                                                     lowMatchPtr);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(ip, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,\n                                                     lowPrefixPtr);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                }\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n        }\n\n        /* No match found -- continue searching */\n        if (bestEntry == NULL) {\n            ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash,\n                                             hBits, current,\n                                             *params);\n            ip++;\n            continue;\n        }\n\n        /* Match found */\n        mLength = forwardMatchLength + backwardMatchLength;\n        ip -= backwardMatchLength;\n\n        {\n            /* Store the sequence:\n             * ip = current - backwardMatchLength\n             * The match is at (bestEntry-\u003eoffset - backwardMatchLength)\n             */\n            U32 const matchIndex = bestEntry-\u003eoffset;\n            U32 const offset = current - matchIndex;\n            rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n            /* Out of sequence storage */\n            if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                return ERROR(dstSize_tooSmall);\n            seq-\u003elitLength = (U32)(ip - anchor);\n            seq-\u003ematchLength = (U32)mLength;\n            seq-\u003eoffset = offset;\n            rawSeqStore-\u003esize++;\n        }\n\n        /* Insert the current entry into the hash table */\n        ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash, hBits,\n                                         (U32)(lastHashed - base),\n                                         *params);\n\n        assert(ip + backwardMatchLength == lastHashed);\n\n        /* Fill the hash table from lastHashed+1 to ip+mLength*/\n        /* Heuristic: don't need to fill the entire table at end of block */\n        if (ip + mLength \u003c= ilimit) {\n            rollingHash = ZSTD_ldm_fillLdmHashTable(\n                              ldmState, rollingHash, lastHashed,\n                              ip + mLength, base, hBits, *params);\n            lastHashed = ip + mLength - 1;\n        }\n        ip += mLength;\n        anchor = ip;\n    }\n    return iend - anchor;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":290,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.6"},"2755664":{"score":0.8164426,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U64 const hashPower = ldmState-\u003ehashPower;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    U32 const ldmBucketSize = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hashRateLog = params-\u003ehashRateLog;\n    U32 const ldmTagMask = (1U \u003c\u003c params-\u003ehashRateLog) - 1;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - MAX(minMatchLength, HASH_READ_SIZE);\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash */\n    BYTE const* lastHashed = NULL;\n    U64 rollingHash = 0;\n\n    while (ip \u003c= ilimit) {\n        size_t mLength;\n        U32 const curr = (U32)(ip - base);\n        size_t forwardMatchLength = 0, backwardMatchLength = 0;\n        ldmEntry_t* bestEntry = NULL;\n        if (ip != istart) {\n            rollingHash = ZSTD_rollingHash_rotate(rollingHash, lastHashed[0],\n                                                  lastHashed[minMatchLength],\n                                                  hashPower);\n        } else {\n            rollingHash = ZSTD_rollingHash_compute(ip, minMatchLength);\n        }\n        lastHashed = ip;\n\n        /* Do not insert and do not look for a match */\n        if (ZSTD_ldm_getTag(rollingHash, hBits, hashRateLog) != ldmTagMask) {\n           ip++;\n           continue;\n        }\n\n        /* Get the best entry and compute the match lengths */\n        {\n            ldmEntry_t* const bucket =\n                ZSTD_ldm_getBucket(ldmState,\n                                   ZSTD_ldm_getSmallHash(rollingHash, hBits),\n                                   *params);\n            ldmEntry_t* cur;\n            size_t bestMatchLength = 0;\n            U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);\n\n            for (cur = bucket; cur \u003c bucket + ldmBucketSize; ++cur) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n\n                    curForwardMatchLength = ZSTD_count_2segments(\n                                                ip, pMatch, iend,\n                                                matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch_2segments(ip, anchor,\n                                                               pMatch, lowMatchPtr,\n                                                               dictStart, dictEnd);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(ip, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,\n                                                     lowPrefixPtr);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                }\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n        }\n\n        /* No match found -- continue searching */\n        if (bestEntry == NULL) {\n            ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash,\n                                             hBits, curr,\n                                             *params);\n            ip++;\n            continue;\n        }\n\n        /* Match found */\n        mLength = forwardMatchLength + backwardMatchLength;\n        ip -= backwardMatchLength;\n\n        {\n            /* Store the sequence:\n             * ip = curr - backwardMatchLength\n             * The match is at (bestEntry-\u003eoffset - backwardMatchLength)\n             */\n            U32 const matchIndex = bestEntry-\u003eoffset;\n            U32 const offset = curr - matchIndex;\n            rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n            /* Out of sequence storage */\n            if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                return ERROR(dstSize_tooSmall);\n            seq-\u003elitLength = (U32)(ip - anchor);\n            seq-\u003ematchLength = (U32)mLength;\n            seq-\u003eoffset = offset;\n            rawSeqStore-\u003esize++;\n        }\n\n        /* Insert the current entry into the hash table */\n        ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash, hBits,\n                                         (U32)(lastHashed - base),\n                                         *params);\n\n        assert(ip + backwardMatchLength == lastHashed);\n\n        /* Fill the hash table from lastHashed+1 to ip+mLength*/\n        /* Heuristic: don't need to fill the entire table at end of block */\n        if (ip + mLength \u003c= ilimit) {\n            rollingHash = ZSTD_ldm_fillLdmHashTable(\n                              ldmState, rollingHash, lastHashed,\n                              ip + mLength, base, hBits, *params);\n            lastHashed = ip + mLength - 1;\n        }\n        ip += mLength;\n        anchor = ip;\n    }\n    return iend - anchor;\n}","filepath":"C/zstd/zstd_ldm.c","line_number":270,"entry_url":"https://github.com/mcmilk/7-Zip-zstd.git","slot_name":"19.00-v1.4.8-R1"},"2774496":{"score":0.7380005,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U32 const entsPerBucket = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - HASH_READ_SIZE;\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash state */\n    ldmRollingHashState_t hashState;\n    /* Arrays for staged-processing */\n    size_t* const splits = ldmState-\u003esplitIndices;\n    ldmMatchCandidate_t* const candidates = ldmState-\u003ematchCandidates;\n    unsigned numSplits;\n\n    if (srcSize \u003c minMatchLength)\n        return iend - anchor;\n\n    /* Initialize the rolling hash state with the first minMatchLength bytes */\n    ZSTD_ldm_gear_init(\u0026hashState, params);\n    ZSTD_ldm_gear_reset(\u0026hashState, ip, minMatchLength);\n    ip += minMatchLength;\n\n    while (ip \u003c ilimit) {\n        size_t hashed;\n        unsigned n;\n\n        numSplits = 0;\n        hashed = ZSTD_ldm_gear_feed(\u0026hashState, ip, ilimit - ip,\n                                    splits, \u0026numSplits);\n\n        for (n = 0; n \u003c numSplits; n++) {\n            BYTE const* const split = ip + splits[n] - minMatchLength;\n            U64 const xxhash = XXH64(split, minMatchLength, 0);\n            U32 const hash = (U32)(xxhash \u0026 (((U32)1 \u003c\u003c hBits) - 1));\n\n            candidates[n].split = split;\n            candidates[n].hash = hash;\n            candidates[n].checksum = (U32)(xxhash \u003e\u003e 32);\n            candidates[n].bucket = ZSTD_ldm_getBucket(ldmState, hash, *params);\n            PREFETCH_L1(candidates[n].bucket);\n        }\n\n        for (n = 0; n \u003c numSplits; n++) {\n            size_t forwardMatchLength = 0, backwardMatchLength = 0,\n                   bestMatchLength = 0, mLength;\n            U32 offset;\n            BYTE const* const split = candidates[n].split;\n            U32 const checksum = candidates[n].checksum;\n            U32 const hash = candidates[n].hash;\n            ldmEntry_t* const bucket = candidates[n].bucket;\n            ldmEntry_t const* cur;\n            ldmEntry_t const* bestEntry = NULL;\n            ldmEntry_t newEntry;\n\n            newEntry.offset = (U32)(split - base);\n            newEntry.checksum = checksum;\n\n            /* If a split point would generate a sequence overlapping with\n             * the previous one, we merely register it in the hash table and\n             * move on */\n            if (split \u003c anchor) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            for (cur = bucket; cur \u003c bucket + entsPerBucket; cur++) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n                    curForwardMatchLength =\n                        ZSTD_count_2segments(split, pMatch, iend, matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength = ZSTD_ldm_countBackwardsMatch_2segments(\n                            split, anchor, pMatch, lowMatchPtr, dictStart, dictEnd);\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(split, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(split, anchor, pMatch, lowPrefixPtr);\n                }\n                curTotalMatchLength = curForwardMatchLength + curBackwardMatchLength;\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n\n            /* No match found -- insert an entry into the hash table\n             * and process the next candidate match */\n            if (bestEntry == NULL) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            /* Match found */\n            offset = (U32)(split - base) - bestEntry-\u003eoffset;\n            mLength = forwardMatchLength + backwardMatchLength;\n            {\n                rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n                /* Out of sequence storage */\n                if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                    return ERROR(dstSize_tooSmall);\n                seq-\u003elitLength = (U32)(split - backwardMatchLength - anchor);\n                seq-\u003ematchLength = (U32)mLength;\n                seq-\u003eoffset = offset;\n                rawSeqStore-\u003esize++;\n            }\n\n            /* Insert the current entry into the hash table --- it must be\n             * done after the previous block to avoid clobbering bestEntry */\n            ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n\n            anchor = split + forwardMatchLength;\n\n            /* If we find a match that ends after the data that we've hashed\n             * then we have a repeating, overlapping, pattern. E.g. all zeros.\n             * If one repetition of the pattern matches our `stopMask` then all\n             * repetitions will. We don't need to insert them all into out table,\n             * only the first one. So skip over overlapping matches.\n             * This is a major speed boost (20x) for compressing a single byte\n             * repeated, when that byte ends up in the table.\n             */\n            if (anchor \u003e ip + hashed) {\n                ZSTD_ldm_gear_reset(\u0026hashState, anchor - minMatchLength, minMatchLength);\n                /* Continue the outer loop at anchor (ip + hashed == anchor). */\n                ip = anchor - hashed;\n                break;\n            }\n        }\n\n        ip += hashed;\n    }\n\n    return iend - anchor;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":321,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2777040":{"score":0.70747447,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U32 const entsPerBucket = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - HASH_READ_SIZE;\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash state */\n    ldmRollingHashState_t hashState;\n    /* Arrays for staged-processing */\n    size_t* const splits = ldmState-\u003esplitIndices;\n    ldmMatchCandidate_t* const candidates = ldmState-\u003ematchCandidates;\n    unsigned numSplits;\n\n    if (srcSize \u003c minMatchLength)\n        return iend - anchor;\n\n    /* Initialize the rolling hash state with the first minMatchLength bytes */\n    ZSTD_ldm_gear_init(\u0026hashState, params);\n    ZSTD_ldm_gear_reset(\u0026hashState, ip, minMatchLength);\n    ip += minMatchLength;\n\n    while (ip \u003c ilimit) {\n        size_t hashed;\n        unsigned n;\n\n        numSplits = 0;\n        hashed = ZSTD_ldm_gear_feed(\u0026hashState, ip, ilimit - ip,\n                                    splits, \u0026numSplits);\n\n        for (n = 0; n \u003c numSplits; n++) {\n            BYTE const* const split = ip + splits[n] - minMatchLength;\n            U64 const xxhash = XXH64(split, minMatchLength, 0);\n            U32 const hash = (U32)(xxhash \u0026 (((U32)1 \u003c\u003c hBits) - 1));\n\n            candidates[n].split = split;\n            candidates[n].hash = hash;\n            candidates[n].checksum = (U32)(xxhash \u003e\u003e 32);\n            candidates[n].bucket = ZSTD_ldm_getBucket(ldmState, hash, *params);\n            PREFETCH_L1(candidates[n].bucket);\n        }\n\n        for (n = 0; n \u003c numSplits; n++) {\n            size_t forwardMatchLength = 0, backwardMatchLength = 0,\n                   bestMatchLength = 0, mLength;\n            U32 offset;\n            BYTE const* const split = candidates[n].split;\n            U32 const checksum = candidates[n].checksum;\n            U32 const hash = candidates[n].hash;\n            ldmEntry_t* const bucket = candidates[n].bucket;\n            ldmEntry_t const* cur;\n            ldmEntry_t const* bestEntry = NULL;\n            ldmEntry_t newEntry;\n\n            newEntry.offset = (U32)(split - base);\n            newEntry.checksum = checksum;\n\n            /* If a split point would generate a sequence overlapping with\n             * the previous one, we merely register it in the hash table and\n             * move on */\n            if (split \u003c anchor) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            for (cur = bucket; cur \u003c bucket + entsPerBucket; cur++) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n                    curForwardMatchLength =\n                        ZSTD_count_2segments(split, pMatch, iend, matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength = ZSTD_ldm_countBackwardsMatch_2segments(\n                            split, anchor, pMatch, lowMatchPtr, dictStart, dictEnd);\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(split, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(split, anchor, pMatch, lowPrefixPtr);\n                }\n                curTotalMatchLength = curForwardMatchLength + curBackwardMatchLength;\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n\n            /* No match found -- insert an entry into the hash table\n             * and process the next candidate match */\n            if (bestEntry == NULL) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            /* Match found */\n            offset = (U32)(split - base) - bestEntry-\u003eoffset;\n            mLength = forwardMatchLength + backwardMatchLength;\n            {\n                rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n                /* Out of sequence storage */\n                if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                    return ERROR(dstSize_tooSmall);\n                seq-\u003elitLength = (U32)(split - backwardMatchLength - anchor);\n                seq-\u003ematchLength = (U32)mLength;\n                seq-\u003eoffset = offset;\n                rawSeqStore-\u003esize++;\n            }\n\n            /* Insert the current entry into the hash table --- it must be\n             * done after the previous block to avoid clobbering bestEntry */\n            ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n\n            anchor = split + forwardMatchLength;\n\n            /* If we find a match that ends after the data that we've hashed\n             * then we have a repeating, overlapping, pattern. E.g. all zeros.\n             * If one repetition of the pattern matches our `stopMask` then all\n             * repetitions will. We don't need to insert them all into out table,\n             * only the first one. So skip over overlapping matches.\n             * This is a major speed boost (20x) for compressing a single byte\n             * repeated, when that byte ends up in the table.\n             */\n            if (anchor \u003e ip + hashed) {\n                ZSTD_ldm_gear_reset(\u0026hashState, anchor - minMatchLength, minMatchLength);\n                /* Continue the outer loop at anchor (ip + hashed == anchor). */\n                ip = anchor - hashed;\n                break;\n            }\n        }\n\n        ip += hashed;\n    }\n\n    return iend - anchor;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":321,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2779952":{"score":0.722887,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U32 const entsPerBucket = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - HASH_READ_SIZE;\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash state */\n    ldmRollingHashState_t hashState;\n    /* Arrays for staged-processing */\n    size_t* const splits = ldmState-\u003esplitIndices;\n    ldmMatchCandidate_t* const candidates = ldmState-\u003ematchCandidates;\n    unsigned numSplits;\n\n    if (srcSize \u003c minMatchLength)\n        return iend - anchor;\n\n    /* Initialize the rolling hash state with the first minMatchLength bytes */\n    ZSTD_ldm_gear_init(\u0026hashState, params);\n    ZSTD_ldm_gear_reset(\u0026hashState, ip, minMatchLength);\n    ip += minMatchLength;\n\n    while (ip \u003c ilimit) {\n        size_t hashed;\n        unsigned n;\n\n        numSplits = 0;\n        hashed = ZSTD_ldm_gear_feed(\u0026hashState, ip, ilimit - ip,\n                                    splits, \u0026numSplits);\n\n        for (n = 0; n \u003c numSplits; n++) {\n            BYTE const* const split = ip + splits[n] - minMatchLength;\n            U64 const xxhash = XXH64(split, minMatchLength, 0);\n            U32 const hash = (U32)(xxhash \u0026 (((U32)1 \u003c\u003c hBits) - 1));\n\n            candidates[n].split = split;\n            candidates[n].hash = hash;\n            candidates[n].checksum = (U32)(xxhash \u003e\u003e 32);\n            candidates[n].bucket = ZSTD_ldm_getBucket(ldmState, hash, *params);\n            PREFETCH_L1(candidates[n].bucket);\n        }\n\n        for (n = 0; n \u003c numSplits; n++) {\n            size_t forwardMatchLength = 0, backwardMatchLength = 0,\n                   bestMatchLength = 0, mLength;\n            U32 offset;\n            BYTE const* const split = candidates[n].split;\n            U32 const checksum = candidates[n].checksum;\n            U32 const hash = candidates[n].hash;\n            ldmEntry_t* const bucket = candidates[n].bucket;\n            ldmEntry_t const* cur;\n            ldmEntry_t const* bestEntry = NULL;\n            ldmEntry_t newEntry;\n\n            newEntry.offset = (U32)(split - base);\n            newEntry.checksum = checksum;\n\n            /* If a split point would generate a sequence overlapping with\n             * the previous one, we merely register it in the hash table and\n             * move on */\n            if (split \u003c anchor) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            for (cur = bucket; cur \u003c bucket + entsPerBucket; cur++) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n                    curForwardMatchLength =\n                        ZSTD_count_2segments(split, pMatch, iend, matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength = ZSTD_ldm_countBackwardsMatch_2segments(\n                            split, anchor, pMatch, lowMatchPtr, dictStart, dictEnd);\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(split, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(split, anchor, pMatch, lowPrefixPtr);\n                }\n                curTotalMatchLength = curForwardMatchLength + curBackwardMatchLength;\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n\n            /* No match found -- insert an entry into the hash table\n             * and process the next candidate match */\n            if (bestEntry == NULL) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            /* Match found */\n            offset = (U32)(split - base) - bestEntry-\u003eoffset;\n            mLength = forwardMatchLength + backwardMatchLength;\n            {\n                rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n                /* Out of sequence storage */\n                if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                    return ERROR(dstSize_tooSmall);\n                seq-\u003elitLength = (U32)(split - backwardMatchLength - anchor);\n                seq-\u003ematchLength = (U32)mLength;\n                seq-\u003eoffset = offset;\n                rawSeqStore-\u003esize++;\n            }\n\n            /* Insert the current entry into the hash table --- it must be\n             * done after the previous block to avoid clobbering bestEntry */\n            ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n\n            anchor = split + forwardMatchLength;\n\n            /* If we find a match that ends after the data that we've hashed\n             * then we have a repeating, overlapping, pattern. E.g. all zeros.\n             * If one repetition of the pattern matches our `stopMask` then all\n             * repetitions will. We don't need to insert them all into out table,\n             * only the first one. So skip over overlapping matches.\n             * This is a major speed boost (20x) for compressing a single byte\n             * repeated, when that byte ends up in the table.\n             */\n            if (anchor \u003e ip + hashed) {\n                ZSTD_ldm_gear_reset(\u0026hashState, anchor - minMatchLength, minMatchLength);\n                /* Continue the outer loop at anchor (ip + hashed == anchor). */\n                ip = anchor - hashed;\n                break;\n            }\n        }\n\n        ip += hashed;\n    }\n\n    return iend - anchor;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":321,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2783280":{"score":0.72782457,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U64 const hashPower = ldmState-\u003ehashPower;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    U32 const ldmBucketSize = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hashRateLog = params-\u003ehashRateLog;\n    U32 const ldmTagMask = (1U \u003c\u003c params-\u003ehashRateLog) - 1;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - MAX(minMatchLength, HASH_READ_SIZE);\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash */\n    BYTE const* lastHashed = NULL;\n    U64 rollingHash = 0;\n\n    while (ip \u003c= ilimit) {\n        size_t mLength;\n        U32 const curr = (U32)(ip - base);\n        size_t forwardMatchLength = 0, backwardMatchLength = 0;\n        ldmEntry_t* bestEntry = NULL;\n        if (ip != istart) {\n            rollingHash = ZSTD_rollingHash_rotate(rollingHash, lastHashed[0],\n                                                  lastHashed[minMatchLength],\n                                                  hashPower);\n        } else {\n            rollingHash = ZSTD_rollingHash_compute(ip, minMatchLength);\n        }\n        lastHashed = ip;\n\n        /* Do not insert and do not look for a match */\n        if (ZSTD_ldm_getTag(rollingHash, hBits, hashRateLog) != ldmTagMask) {\n           ip++;\n           continue;\n        }\n\n        /* Get the best entry and compute the match lengths */\n        {\n            ldmEntry_t* const bucket =\n                ZSTD_ldm_getBucket(ldmState,\n                                   ZSTD_ldm_getSmallHash(rollingHash, hBits),\n                                   *params);\n            ldmEntry_t* cur;\n            size_t bestMatchLength = 0;\n            U32 const checksum = ZSTD_ldm_getChecksum(rollingHash, hBits);\n\n            for (cur = bucket; cur \u003c bucket + ldmBucketSize; ++cur) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n\n                    curForwardMatchLength = ZSTD_count_2segments(\n                                                ip, pMatch, iend,\n                                                matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch_2segments(ip, anchor,\n                                                               pMatch, lowMatchPtr,\n                                                               dictStart, dictEnd);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(ip, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(ip, anchor, pMatch,\n                                                     lowPrefixPtr);\n                    curTotalMatchLength = curForwardMatchLength +\n                                          curBackwardMatchLength;\n                }\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n        }\n\n        /* No match found -- continue searching */\n        if (bestEntry == NULL) {\n            ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash,\n                                             hBits, curr,\n                                             *params);\n            ip++;\n            continue;\n        }\n\n        /* Match found */\n        mLength = forwardMatchLength + backwardMatchLength;\n        ip -= backwardMatchLength;\n\n        {\n            /* Store the sequence:\n             * ip = curr - backwardMatchLength\n             * The match is at (bestEntry-\u003eoffset - backwardMatchLength)\n             */\n            U32 const matchIndex = bestEntry-\u003eoffset;\n            U32 const offset = curr - matchIndex;\n            rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n            /* Out of sequence storage */\n            if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                return ERROR(dstSize_tooSmall);\n            seq-\u003elitLength = (U32)(ip - anchor);\n            seq-\u003ematchLength = (U32)mLength;\n            seq-\u003eoffset = offset;\n            rawSeqStore-\u003esize++;\n        }\n\n        /* Insert the current entry into the hash table */\n        ZSTD_ldm_makeEntryAndInsertByTag(ldmState, rollingHash, hBits,\n                                         (U32)(lastHashed - base),\n                                         *params);\n\n        assert(ip + backwardMatchLength == lastHashed);\n\n        /* Fill the hash table from lastHashed+1 to ip+mLength*/\n        /* Heuristic: don't need to fill the entire table at end of block */\n        if (ip + mLength \u003c= ilimit) {\n            rollingHash = ZSTD_ldm_fillLdmHashTable(\n                              ldmState, rollingHash, lastHashed,\n                              ip + mLength, base, hBits, *params);\n            lastHashed = ip + mLength - 1;\n        }\n        ip += mLength;\n        anchor = ip;\n    }\n    return iend - anchor;\n}","filepath":"C/zstd/zstd_ldm.c","line_number":270,"entry_url":"https://github.com/mcmilk/7-Zip-zstd.git","slot_name":"19.00-v1.4.8-R1"},"2786368":{"score":0.7831861,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U32 const entsPerBucket = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - HASH_READ_SIZE;\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash state */\n    ldmRollingHashState_t hashState;\n    /* Arrays for staged-processing */\n    size_t* const splits = ldmState-\u003esplitIndices;\n    ldmMatchCandidate_t* const candidates = ldmState-\u003ematchCandidates;\n    unsigned numSplits;\n\n    if (srcSize \u003c minMatchLength)\n        return iend - anchor;\n\n    /* Initialize the rolling hash state with the first minMatchLength bytes */\n    ZSTD_ldm_gear_init(\u0026hashState, params);\n    ZSTD_ldm_gear_reset(\u0026hashState, ip, minMatchLength);\n    ip += minMatchLength;\n\n    while (ip \u003c ilimit) {\n        size_t hashed;\n        unsigned n;\n\n        numSplits = 0;\n        hashed = ZSTD_ldm_gear_feed(\u0026hashState, ip, ilimit - ip,\n                                    splits, \u0026numSplits);\n\n        for (n = 0; n \u003c numSplits; n++) {\n            BYTE const* const split = ip + splits[n] - minMatchLength;\n            U64 const xxhash = XXH64(split, minMatchLength, 0);\n            U32 const hash = (U32)(xxhash \u0026 (((U32)1 \u003c\u003c hBits) - 1));\n\n            candidates[n].split = split;\n            candidates[n].hash = hash;\n            candidates[n].checksum = (U32)(xxhash \u003e\u003e 32);\n            candidates[n].bucket = ZSTD_ldm_getBucket(ldmState, hash, *params);\n            PREFETCH_L1(candidates[n].bucket);\n        }\n\n        for (n = 0; n \u003c numSplits; n++) {\n            size_t forwardMatchLength = 0, backwardMatchLength = 0,\n                   bestMatchLength = 0, mLength;\n            U32 offset;\n            BYTE const* const split = candidates[n].split;\n            U32 const checksum = candidates[n].checksum;\n            U32 const hash = candidates[n].hash;\n            ldmEntry_t* const bucket = candidates[n].bucket;\n            ldmEntry_t const* cur;\n            ldmEntry_t const* bestEntry = NULL;\n            ldmEntry_t newEntry;\n\n            newEntry.offset = (U32)(split - base);\n            newEntry.checksum = checksum;\n\n            /* If a split point would generate a sequence overlapping with\n             * the previous one, we merely register it in the hash table and\n             * move on */\n            if (split \u003c anchor) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            for (cur = bucket; cur \u003c bucket + entsPerBucket; cur++) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n                    curForwardMatchLength =\n                        ZSTD_count_2segments(split, pMatch, iend, matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength = ZSTD_ldm_countBackwardsMatch_2segments(\n                            split, anchor, pMatch, lowMatchPtr, dictStart, dictEnd);\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(split, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(split, anchor, pMatch, lowPrefixPtr);\n                }\n                curTotalMatchLength = curForwardMatchLength + curBackwardMatchLength;\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n\n            /* No match found -- insert an entry into the hash table\n             * and process the next candidate match */\n            if (bestEntry == NULL) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            /* Match found */\n            offset = (U32)(split - base) - bestEntry-\u003eoffset;\n            mLength = forwardMatchLength + backwardMatchLength;\n            {\n                rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n                /* Out of sequence storage */\n                if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                    return ERROR(dstSize_tooSmall);\n                seq-\u003elitLength = (U32)(split - backwardMatchLength - anchor);\n                seq-\u003ematchLength = (U32)mLength;\n                seq-\u003eoffset = offset;\n                rawSeqStore-\u003esize++;\n            }\n\n            /* Insert the current entry into the hash table --- it must be\n             * done after the previous block to avoid clobbering bestEntry */\n            ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n\n            anchor = split + forwardMatchLength;\n\n            /* If we find a match that ends after the data that we've hashed\n             * then we have a repeating, overlapping, pattern. E.g. all zeros.\n             * If one repetition of the pattern matches our `stopMask` then all\n             * repetitions will. We don't need to insert them all into out table,\n             * only the first one. So skip over overlapping matches.\n             * This is a major speed boost (20x) for compressing a single byte\n             * repeated, when that byte ends up in the table.\n             */\n            if (anchor \u003e ip + hashed) {\n                ZSTD_ldm_gear_reset(\u0026hashState, anchor - minMatchLength, minMatchLength);\n                /* Continue the outer loop at anchor (ip + hashed == anchor). */\n                ip = anchor - hashed;\n                break;\n            }\n        }\n\n        ip += hashed;\n    }\n\n    return iend - anchor;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":321,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2788096":{"score":0.792264,"function_name":"ZSTD_ldm_generateSequences_internal","code":"static size_t ZSTD_ldm_generateSequences_internal(\n        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    /* LDM parameters */\n    int const extDict = ZSTD_window_hasExtDict(ldmState-\u003ewindow);\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U32 const entsPerBucket = 1U \u003c\u003c params-\u003ebucketSizeLog;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    /* Prefix and extDict parameters */\n    U32 const dictLimit = ldmState-\u003ewindow.dictLimit;\n    U32 const lowestIndex = extDict ? ldmState-\u003ewindow.lowLimit : dictLimit;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const dictBase = extDict ? ldmState-\u003ewindow.dictBase : NULL;\n    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;\n    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;\n    BYTE const* const lowPrefixPtr = base + dictLimit;\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    BYTE const* const ilimit = iend - HASH_READ_SIZE;\n    /* Input positions */\n    BYTE const* anchor = istart;\n    BYTE const* ip = istart;\n    /* Rolling hash state */\n    ldmRollingHashState_t hashState;\n    /* Arrays for staged-processing */\n    size_t* const splits = ldmState-\u003esplitIndices;\n    ldmMatchCandidate_t* const candidates = ldmState-\u003ematchCandidates;\n    unsigned numSplits;\n\n    if (srcSize \u003c minMatchLength)\n        return iend - anchor;\n\n    /* Initialize the rolling hash state with the first minMatchLength bytes */\n    ZSTD_ldm_gear_init(\u0026hashState, params);\n    ZSTD_ldm_gear_reset(\u0026hashState, ip, minMatchLength);\n    ip += minMatchLength;\n\n    while (ip \u003c ilimit) {\n        size_t hashed;\n        unsigned n;\n\n        numSplits = 0;\n        hashed = ZSTD_ldm_gear_feed(\u0026hashState, ip, ilimit - ip,\n                                    splits, \u0026numSplits);\n\n        for (n = 0; n \u003c numSplits; n++) {\n            BYTE const* const split = ip + splits[n] - minMatchLength;\n            U64 const xxhash = XXH64(split, minMatchLength, 0);\n            U32 const hash = (U32)(xxhash \u0026 (((U32)1 \u003c\u003c hBits) - 1));\n\n            candidates[n].split = split;\n            candidates[n].hash = hash;\n            candidates[n].checksum = (U32)(xxhash \u003e\u003e 32);\n            candidates[n].bucket = ZSTD_ldm_getBucket(ldmState, hash, *params);\n            PREFETCH_L1(candidates[n].bucket);\n        }\n\n        for (n = 0; n \u003c numSplits; n++) {\n            size_t forwardMatchLength = 0, backwardMatchLength = 0,\n                   bestMatchLength = 0, mLength;\n            U32 offset;\n            BYTE const* const split = candidates[n].split;\n            U32 const checksum = candidates[n].checksum;\n            U32 const hash = candidates[n].hash;\n            ldmEntry_t* const bucket = candidates[n].bucket;\n            ldmEntry_t const* cur;\n            ldmEntry_t const* bestEntry = NULL;\n            ldmEntry_t newEntry;\n\n            newEntry.offset = (U32)(split - base);\n            newEntry.checksum = checksum;\n\n            /* If a split point would generate a sequence overlapping with\n             * the previous one, we merely register it in the hash table and\n             * move on */\n            if (split \u003c anchor) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            for (cur = bucket; cur \u003c bucket + entsPerBucket; cur++) {\n                size_t curForwardMatchLength, curBackwardMatchLength,\n                       curTotalMatchLength;\n                if (cur-\u003echecksum != checksum || cur-\u003eoffset \u003c= lowestIndex) {\n                    continue;\n                }\n                if (extDict) {\n                    BYTE const* const curMatchBase =\n                        cur-\u003eoffset \u003c dictLimit ? dictBase : base;\n                    BYTE const* const pMatch = curMatchBase + cur-\u003eoffset;\n                    BYTE const* const matchEnd =\n                        cur-\u003eoffset \u003c dictLimit ? dictEnd : iend;\n                    BYTE const* const lowMatchPtr =\n                        cur-\u003eoffset \u003c dictLimit ? dictStart : lowPrefixPtr;\n                    curForwardMatchLength =\n                        ZSTD_count_2segments(split, pMatch, iend, matchEnd, lowPrefixPtr);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength = ZSTD_ldm_countBackwardsMatch_2segments(\n                            split, anchor, pMatch, lowMatchPtr, dictStart, dictEnd);\n                } else { /* !extDict */\n                    BYTE const* const pMatch = base + cur-\u003eoffset;\n                    curForwardMatchLength = ZSTD_count(split, pMatch, iend);\n                    if (curForwardMatchLength \u003c minMatchLength) {\n                        continue;\n                    }\n                    curBackwardMatchLength =\n                        ZSTD_ldm_countBackwardsMatch(split, anchor, pMatch, lowPrefixPtr);\n                }\n                curTotalMatchLength = curForwardMatchLength + curBackwardMatchLength;\n\n                if (curTotalMatchLength \u003e bestMatchLength) {\n                    bestMatchLength = curTotalMatchLength;\n                    forwardMatchLength = curForwardMatchLength;\n                    backwardMatchLength = curBackwardMatchLength;\n                    bestEntry = cur;\n                }\n            }\n\n            /* No match found -- insert an entry into the hash table\n             * and process the next candidate match */\n            if (bestEntry == NULL) {\n                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n                continue;\n            }\n\n            /* Match found */\n            offset = (U32)(split - base) - bestEntry-\u003eoffset;\n            mLength = forwardMatchLength + backwardMatchLength;\n            {\n                rawSeq* const seq = rawSeqStore-\u003eseq + rawSeqStore-\u003esize;\n\n                /* Out of sequence storage */\n                if (rawSeqStore-\u003esize == rawSeqStore-\u003ecapacity)\n                    return ERROR(dstSize_tooSmall);\n                seq-\u003elitLength = (U32)(split - backwardMatchLength - anchor);\n                seq-\u003ematchLength = (U32)mLength;\n                seq-\u003eoffset = offset;\n                rawSeqStore-\u003esize++;\n            }\n\n            /* Insert the current entry into the hash table --- it must be\n             * done after the previous block to avoid clobbering bestEntry */\n            ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);\n\n            anchor = split + forwardMatchLength;\n\n            /* If we find a match that ends after the data that we've hashed\n             * then we have a repeating, overlapping, pattern. E.g. all zeros.\n             * If one repetition of the pattern matches our `stopMask` then all\n             * repetitions will. We don't need to insert them all into out table,\n             * only the first one. So skip over overlapping matches.\n             * This is a major speed boost (20x) for compressing a single byte\n             * repeated, when that byte ends up in the table.\n             */\n            if (anchor \u003e ip + hashed) {\n                ZSTD_ldm_gear_reset(\u0026hashState, anchor - minMatchLength, minMatchLength);\n                /* Continue the outer loop at anchor (ip + hashed == anchor). */\n                ip = anchor - hashed;\n                break;\n            }\n        }\n\n        ip += hashed;\n    }\n\n    return iend - anchor;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":321,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2793152":{"score":0.72357035,"function_name":"ZSTD_ldm_gear_feed","code":"static size_t ZSTD_ldm_gear_feed(ldmRollingHashState_t* state,\n                                 BYTE const* data, size_t size,\n                                 size_t* splits, unsigned* numSplits)\n{\n    size_t n;\n    U64 hash, mask;\n\n    hash = state-\u003erolling;\n    mask = state-\u003estopMask;\n    n = 0;\n\n#define GEAR_ITER_ONCE() do { \\\n        hash = (hash \u003c\u003c 1) + ZSTD_ldm_gearTab[data[n] \u0026 0xff]; \\\n        n += 1; \\\n        if (UNLIKELY((hash \u0026 mask) == 0)) { \\\n            splits[*numSplits] = n; \\\n            *numSplits += 1; \\\n            if (*numSplits == LDM_BATCH_SIZE) \\\n                goto done; \\\n        } \\\n    } while (0)\n\n    while (n + 3 \u003c size) {\n        GEAR_ITER_ONCE();\n        GEAR_ITER_ONCE();\n        GEAR_ITER_ONCE();\n        GEAR_ITER_ONCE();\n    }\n    while (n \u003c size) {\n        GEAR_ITER_ONCE();\n    }\n\n#undef GEAR_ITER_ONCE\n\ndone:\n    state-\u003erolling = hash;\n    return n;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":96,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2793584":{"score":0.88995326,"function_name":"ZSTD_ldm_adjustParameters","code":"void ZSTD_ldm_adjustParameters(ldmParams_t* params,\n                               ZSTD_compressionParameters const* cParams)\n{\n    params-\u003ewindowLog = cParams-\u003ewindowLog;\n    ZSTD_STATIC_ASSERT(LDM_BUCKET_SIZE_LOG \u003c= ZSTD_LDM_BUCKETSIZELOG_MAX);\n    DEBUGLOG(4, \"ZSTD_ldm_adjustParameters\");\n    if (!params-\u003ebucketSizeLog) params-\u003ebucketSizeLog = LDM_BUCKET_SIZE_LOG;\n    if (!params-\u003eminMatchLength) params-\u003eminMatchLength = LDM_MIN_MATCH_LENGTH;\n    if (params-\u003ehashLog == 0) {\n        params-\u003ehashLog = MAX(ZSTD_HASHLOG_MIN, params-\u003ewindowLog - LDM_HASH_RLOG);\n        assert(params-\u003ehashLog \u003c= ZSTD_HASHLOG_MAX);\n    }\n    if (params-\u003ehashRateLog == 0) {\n        params-\u003ehashRateLog = params-\u003ewindowLog \u003c params-\u003ehashLog\n                                   ? 0\n                                   : params-\u003ewindowLog - params-\u003ehashLog;\n    }\n    params-\u003ebucketSizeLog = MIN(params-\u003ebucketSizeLog, params-\u003ehashLog);\n}","filepath":"lib/compress/zstd_ldm.c","line_number":135,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2793680":{"score":0.7142851,"function_name":"ZSTD_ldm_getTableSize","code":"size_t ZSTD_ldm_getTableSize(ldmParams_t params)\n{\n    size_t const ldmHSize = ((size_t)1) \u003c\u003c params.hashLog;\n    size_t const ldmBucketSizeLog = MIN(params.bucketSizeLog, params.hashLog);\n    size_t const ldmBucketSize = ((size_t)1) \u003c\u003c (params.hashLog - ldmBucketSizeLog);\n    size_t const totalSize = ZSTD_cwksp_alloc_size(ldmBucketSize)\n                           + ZSTD_cwksp_alloc_size(ldmHSize * sizeof(ldmEntry_t));\n    return params.enableLdm == ZSTD_ps_enable ? totalSize : 0;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":155,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2793776":{"score":0.8295059,"function_name":"ZSTD_ldm_fillHashTable","code":"void ZSTD_ldm_fillHashTable(\n            ldmState_t* ldmState, const BYTE* ip,\n            const BYTE* iend, ldmParams_t const* params)\n{\n    U32 const minMatchLength = params-\u003eminMatchLength;\n    U32 const hBits = params-\u003ehashLog - params-\u003ebucketSizeLog;\n    BYTE const* const base = ldmState-\u003ewindow.base;\n    BYTE const* const istart = ip;\n    ldmRollingHashState_t hashState;\n    size_t* const splits = ldmState-\u003esplitIndices;\n    unsigned numSplits;\n\n    DEBUGLOG(5, \"ZSTD_ldm_fillHashTable\");\n\n    ZSTD_ldm_gear_init(\u0026hashState, params);\n    while (ip \u003c iend) {\n        size_t hashed;\n        unsigned n;\n\n        numSplits = 0;\n        hashed = ZSTD_ldm_gear_feed(\u0026hashState, ip, iend - ip, splits, \u0026numSplits);\n\n        for (n = 0; n \u003c numSplits; n++) {\n            if (ip + splits[n] \u003e= istart + minMatchLength) {\n                BYTE const* const split = ip + splits[n] - minMatchLength;\n                U64 const xxhash = XXH64(split, minMatchLength, 0);\n                U32 const hash = (U32)(xxhash \u0026 (((U32)1 \u003c\u003c hBits) - 1));\n                ldmEntry_t entry;\n\n                entry.offset = (U32)(split - base);\n                entry.checksum = (U32)(xxhash \u003e\u003e 32);\n                ZSTD_ldm_insertEntry(ldmState, hash, entry, *params);\n            }\n        }\n\n        ip += hashed;\n    }\n}","filepath":"lib/compress/zstd_ldm.c","line_number":267,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2794288":{"score":0.7940934,"function_name":"ZSTD_ldm_generateSequences","code":"size_t ZSTD_ldm_generateSequences(\n        ldmState_t* ldmState, rawSeqStore_t* sequences,\n        ldmParams_t const* params, void const* src, size_t srcSize)\n{\n    U32 const maxDist = 1U \u003c\u003c params-\u003ewindowLog;\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    size_t const kMaxChunkSize = 1 \u003c\u003c 20;\n    size_t const nbChunks = (srcSize / kMaxChunkSize) + ((srcSize % kMaxChunkSize) != 0);\n    size_t chunk;\n    size_t leftoverSize = 0;\n\n    assert(ZSTD_CHUNKSIZE_MAX \u003e= kMaxChunkSize);\n    /* Check that ZSTD_window_update() has been called for this chunk prior\n     * to passing it to this function.\n     */\n    assert(ldmState-\u003ewindow.nextSrc \u003e= (BYTE const*)src + srcSize);\n    /* The input could be very large (in zstdmt), so it must be broken up into\n     * chunks to enforce the maximum distance and handle overflow correction.\n     */\n    assert(sequences-\u003epos \u003c= sequences-\u003esize);\n    assert(sequences-\u003esize \u003c= sequences-\u003ecapacity);\n    for (chunk = 0; chunk \u003c nbChunks \u0026\u0026 sequences-\u003esize \u003c sequences-\u003ecapacity; ++chunk) {\n        BYTE const* const chunkStart = istart + chunk * kMaxChunkSize;\n        size_t const remaining = (size_t)(iend - chunkStart);\n        BYTE const *const chunkEnd =\n            (remaining \u003c kMaxChunkSize) ? iend : chunkStart + kMaxChunkSize;\n        size_t const chunkSize = chunkEnd - chunkStart;\n        size_t newLeftoverSize;\n        size_t const prevSize = sequences-\u003esize;\n\n        assert(chunkStart \u003c iend);\n        /* 1. Perform overflow correction if necessary. */\n        if (ZSTD_window_needOverflowCorrection(ldmState-\u003ewindow, 0, maxDist, ldmState-\u003eloadedDictEnd, chunkStart, chunkEnd)) {\n            U32 const ldmHSize = 1U \u003c\u003c params-\u003ehashLog;\n            U32 const correction = ZSTD_window_correctOverflow(\n                \u0026ldmState-\u003ewindow, /* cycleLog */ 0, maxDist, chunkStart);\n            ZSTD_ldm_reduceTable(ldmState-\u003ehashTable, ldmHSize, correction);\n            /* invalidate dictionaries on overflow correction */\n            ldmState-\u003eloadedDictEnd = 0;\n        }\n        /* 2. We enforce the maximum offset allowed.\n         *\n         * kMaxChunkSize should be small enough that we don't lose too much of\n         * the window through early invalidation.\n         * TODO: * Test the chunk size.\n         *       * Try invalidation after the sequence generation and test the\n         *         the offset against maxDist directly.\n         *\n         * NOTE: Because of dictionaries + sequence splitting we MUST make sure\n         * that any offset used is valid at the END of the sequence, since it may\n         * be split into two sequences. This condition holds when using\n         * ZSTD_window_enforceMaxDist(), but if we move to checking offsets\n         * against maxDist directly, we'll have to carefully handle that case.\n         */\n        ZSTD_window_enforceMaxDist(\u0026ldmState-\u003ewindow, chunkEnd, maxDist, \u0026ldmState-\u003eloadedDictEnd, NULL);\n        /* 3. Generate the sequences for the chunk, and get newLeftoverSize. */\n        newLeftoverSize = ZSTD_ldm_generateSequences_internal(\n            ldmState, sequences, params, chunkStart, chunkSize);\n        if (ZSTD_isError(newLeftoverSize))\n            return newLeftoverSize;\n        /* 4. We add the leftover literals from previous iterations to the first\n         *    newly generated sequence, or add the `newLeftoverSize` if none are\n         *    generated.\n         */\n        /* Prepend the leftover literals from the last call */\n        if (prevSize \u003c sequences-\u003esize) {\n            sequences-\u003eseq[prevSize].litLength += (U32)leftoverSize;\n            leftoverSize = newLeftoverSize;\n        } else {\n            assert(newLeftoverSize == chunkSize);\n            leftoverSize += chunkSize;\n        }\n    }\n    return 0;\n}","filepath":"lib/compress/zstd_ldm.c","line_number":505,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2797856":{"score":0.91057974,"function_name":"ZSTD_ldm_skipSequences","code":"void ZSTD_ldm_skipSequences(rawSeqStore_t* rawSeqStore, size_t srcSize, U32 const minMatch) {\n    while (srcSize \u003e 0 \u0026\u0026 rawSeqStore-\u003epos \u003c rawSeqStore-\u003esize) {\n        rawSeq* seq = rawSeqStore-\u003eseq + rawSeqStore-\u003epos;\n        if (srcSize \u003c= seq-\u003elitLength) {\n            /* Skip past srcSize literals */\n            seq-\u003elitLength -= (U32)srcSize;\n            return;\n        }\n        srcSize -= seq-\u003elitLength;\n        seq-\u003elitLength = 0;\n        if (srcSize \u003c seq-\u003ematchLength) {\n            /* Skip past the first srcSize of the match */\n            seq-\u003ematchLength -= (U32)srcSize;\n            if (seq-\u003ematchLength \u003c minMatch) {\n                /* The match is too short, omit it */\n                if (rawSeqStore-\u003epos + 1 \u003c rawSeqStore-\u003esize) {\n                    seq[1].litLength += seq[0].matchLength;\n                }\n                rawSeqStore-\u003epos++;\n            }\n            return;\n        }\n        srcSize -= seq-\u003ematchLength;\n        seq-\u003ematchLength = 0;\n        rawSeqStore-\u003epos++;\n    }\n}","filepath":"lib/compress/zstd_ldm.c","line_number":582,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2798000":{"score":0.80412155,"function_name":"ZSTD_optLdm_skipRawSeqStoreBytes","code":"static void ZSTD_optLdm_skipRawSeqStoreBytes(rawSeqStore_t* rawSeqStore, size_t nbBytes)\n{\n    U32 currPos = (U32)(rawSeqStore-\u003eposInSequence + nbBytes);\n    while (currPos \u0026\u0026 rawSeqStore-\u003epos \u003c rawSeqStore-\u003esize) {\n        rawSeq currSeq = rawSeqStore-\u003eseq[rawSeqStore-\u003epos];\n        if (currPos \u003e= currSeq.litLength + currSeq.matchLength) {\n            currPos -= currSeq.litLength + currSeq.matchLength;\n            rawSeqStore-\u003epos++;\n        } else {\n            rawSeqStore-\u003eposInSequence = currPos;\n            break;\n        }\n    }\n    if (currPos == 0 || rawSeqStore-\u003epos == rawSeqStore-\u003esize) {\n        rawSeqStore-\u003eposInSequence = 0;\n    }\n}","filepath":"lib/compress/zstd_opt.c","line_number":881,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2798096":{"score":0.6995983,"function_name":"ZSTD_ldm_blockCompress","code":"size_t ZSTD_ldm_blockCompress(rawSeqStore_t* rawSeqStore,\n    ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n    ZSTD_paramSwitch_e useRowMatchFinder,\n    void const* src, size_t srcSize)\n{\n    const ZSTD_compressionParameters* const cParams = \u0026ms-\u003ecParams;\n    unsigned const minMatch = cParams-\u003eminMatch;\n    ZSTD_blockCompressor const blockCompressor =\n        ZSTD_selectBlockCompressor(cParams-\u003estrategy, useRowMatchFinder, ZSTD_matchState_dictMode(ms));\n    /* Input bounds */\n    BYTE const* const istart = (BYTE const*)src;\n    BYTE const* const iend = istart + srcSize;\n    /* Input positions */\n    BYTE const* ip = istart;\n\n    DEBUGLOG(5, \"ZSTD_ldm_blockCompress: srcSize=%zu\", srcSize);\n    /* If using opt parser, use LDMs only as candidates rather than always accepting them */\n    if (cParams-\u003estrategy \u003e= ZSTD_btopt) {\n        size_t lastLLSize;\n        ms-\u003eldmSeqStore = rawSeqStore;\n        lastLLSize = blockCompressor(ms, seqStore, rep, src, srcSize);\n        ZSTD_ldm_skipRawSeqStoreBytes(rawSeqStore, srcSize);\n        return lastLLSize;\n    }\n\n    assert(rawSeqStore-\u003epos \u003c= rawSeqStore-\u003esize);\n    assert(rawSeqStore-\u003esize \u003c= rawSeqStore-\u003ecapacity);\n    /* Loop through each sequence and apply the block compressor to the literals */\n    while (rawSeqStore-\u003epos \u003c rawSeqStore-\u003esize \u0026\u0026 ip \u003c iend) {\n        /* maybeSplitSequence updates rawSeqStore-\u003epos */\n        rawSeq const sequence = maybeSplitSequence(rawSeqStore,\n                                                   (U32)(iend - ip), minMatch);\n        int i;\n        /* End signal */\n        if (sequence.offset == 0)\n            break;\n\n        assert(ip + sequence.litLength + sequence.matchLength \u003c= iend);\n\n        /* Fill tables for block compressor */\n        ZSTD_ldm_limitTableUpdate(ms, ip);\n        ZSTD_ldm_fillFastTables(ms, ip);\n        /* Run the block compressor */\n        DEBUGLOG(5, \"pos %u : calling block compressor on segment of size %u\", (unsigned)(ip-istart), sequence.litLength);\n        {\n            size_t const newLitLength =\n                blockCompressor(ms, seqStore, rep, ip, sequence.litLength);\n            ip += sequence.litLength;\n            /* Update the repcodes */\n            for (i = ZSTD_REP_NUM - 1; i \u003e 0; i--)\n                rep[i] = rep[i-1];\n            rep[0] = sequence.offset;\n            /* Store the sequence */\n            ZSTD_storeSeq(seqStore, newLitLength, ip - newLitLength, iend,\n                          sequence.offset + ZSTD_REP_MOVE,\n                          sequence.matchLength - MINMATCH);\n            ip += sequence.matchLength;\n        }\n    }\n    /* Fill the tables for the block compressor */\n    ZSTD_ldm_limitTableUpdate(ms, ip);\n    ZSTD_ldm_fillFastTables(ms, ip);\n    /* Compress the last literals */\n    return blockCompressor(ms, seqStore, rep, ip, iend - ip);\n}","filepath":"lib/compress/zstd_ldm.c","line_number":658,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2811440":{"score":0.79088426,"function_name":"ZSTD_updateStats","code":"static void ZSTD_updateStats(optState_t* const optPtr,\n                             U32 litLength, const BYTE* literals,\n                             U32 offsetCode, U32 matchLength)\n{\n    /* literals */\n    if (ZSTD_compressedLiterals(optPtr)) {\n        U32 u;\n        for (u=0; u \u003c litLength; u++)\n            optPtr-\u003elitFreq[literals[u]] += ZSTD_LITFREQ_ADD;\n        optPtr-\u003elitSum += litLength*ZSTD_LITFREQ_ADD;\n    }\n\n    /* literal Length */\n    {   U32 const llCode = ZSTD_LLcode(litLength);\n        optPtr-\u003elitLengthFreq[llCode]++;\n        optPtr-\u003elitLengthSum++;\n    }\n\n    /* offset code : expected to follow storeSeq() numeric representation */\n    {   U32 const offCode = ZSTD_highbit32(STORED_TO_OFFBASE(offsetCode));\n        assert(offCode \u003c= MaxOff);\n        optPtr-\u003eoffCodeFreq[offCode]++;\n        optPtr-\u003eoffCodeSum++;\n    }\n\n    /* match Length */\n    {   U32 const mlBase = matchLength - MINMATCH;\n        U32 const mlCode = ZSTD_MLcode(mlBase);\n        optPtr-\u003ematchLengthFreq[mlCode]++;\n        optPtr-\u003ematchLengthSum++;\n    }\n}","filepath":"lib/compress/zstd_opt.c","line_number":329,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2811616":{"score":0.8089467,"function_name":"ZSTD_rescaleFreqs","code":"static void\nZSTD_rescaleFreqs(optState_t* const optPtr,\n            const BYTE* const src, size_t const srcSize,\n                  int const optLevel)\n{\n    int const compressedLiterals = ZSTD_compressedLiterals(optPtr);\n    DEBUGLOG(5, \"ZSTD_rescaleFreqs (srcSize=%u)\", (unsigned)srcSize);\n    optPtr-\u003epriceType = zop_dynamic;\n\n    if (optPtr-\u003elitLengthSum == 0) {  /* first block : init */\n        if (srcSize \u003c= ZSTD_PREDEF_THRESHOLD) {  /* heuristic */\n            DEBUGLOG(5, \"(srcSize \u003c= ZSTD_PREDEF_THRESHOLD) =\u003e zop_predef\");\n            optPtr-\u003epriceType = zop_predef;\n        }\n\n        assert(optPtr-\u003esymbolCosts != NULL);\n        if (optPtr-\u003esymbolCosts-\u003ehuf.repeatMode == HUF_repeat_valid) {\n            /* huffman table presumed generated by dictionary */\n            optPtr-\u003epriceType = zop_dynamic;\n\n            if (compressedLiterals) {\n                unsigned lit;\n                assert(optPtr-\u003elitFreq != NULL);\n                optPtr-\u003elitSum = 0;\n                for (lit=0; lit\u003c=MaxLit; lit++) {\n                    U32 const scaleLog = 11;   /* scale to 2K */\n                    U32 const bitCost = HUF_getNbBitsFromCTable(optPtr-\u003esymbolCosts-\u003ehuf.CTable, lit);\n                    assert(bitCost \u003c= scaleLog);\n                    optPtr-\u003elitFreq[lit] = bitCost ? 1 \u003c\u003c (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;\n                    optPtr-\u003elitSum += optPtr-\u003elitFreq[lit];\n            }   }\n\n            {   unsigned ll;\n                FSE_CState_t llstate;\n                FSE_initCState(\u0026llstate, optPtr-\u003esymbolCosts-\u003efse.litlengthCTable);\n                optPtr-\u003elitLengthSum = 0;\n                for (ll=0; ll\u003c=MaxLL; ll++) {\n                    U32 const scaleLog = 10;   /* scale to 1K */\n                    U32 const bitCost = FSE_getMaxNbBits(llstate.symbolTT, ll);\n                    assert(bitCost \u003c scaleLog);\n                    optPtr-\u003elitLengthFreq[ll] = bitCost ? 1 \u003c\u003c (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;\n                    optPtr-\u003elitLengthSum += optPtr-\u003elitLengthFreq[ll];\n            }   }\n\n            {   unsigned ml;\n                FSE_CState_t mlstate;\n                FSE_initCState(\u0026mlstate, optPtr-\u003esymbolCosts-\u003efse.matchlengthCTable);\n                optPtr-\u003ematchLengthSum = 0;\n                for (ml=0; ml\u003c=MaxML; ml++) {\n                    U32 const scaleLog = 10;\n                    U32 const bitCost = FSE_getMaxNbBits(mlstate.symbolTT, ml);\n                    assert(bitCost \u003c scaleLog);\n                    optPtr-\u003ematchLengthFreq[ml] = bitCost ? 1 \u003c\u003c (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;\n                    optPtr-\u003ematchLengthSum += optPtr-\u003ematchLengthFreq[ml];\n            }   }\n\n            {   unsigned of;\n                FSE_CState_t ofstate;\n                FSE_initCState(\u0026ofstate, optPtr-\u003esymbolCosts-\u003efse.offcodeCTable);\n                optPtr-\u003eoffCodeSum = 0;\n                for (of=0; of\u003c=MaxOff; of++) {\n                    U32 const scaleLog = 10;\n                    U32 const bitCost = FSE_getMaxNbBits(ofstate.symbolTT, of);\n                    assert(bitCost \u003c scaleLog);\n                    optPtr-\u003eoffCodeFreq[of] = bitCost ? 1 \u003c\u003c (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;\n                    optPtr-\u003eoffCodeSum += optPtr-\u003eoffCodeFreq[of];\n            }   }\n\n        } else {  /* not a dictionary */\n\n            assert(optPtr-\u003elitFreq != NULL);\n            if (compressedLiterals) {\n                unsigned lit = MaxLit;\n                HIST_count_simple(optPtr-\u003elitFreq, \u0026lit, src, srcSize);   /* use raw first block to init statistics */\n                optPtr-\u003elitSum = ZSTD_downscaleStats(optPtr-\u003elitFreq, MaxLit, 8);\n            }\n\n            {   unsigned const baseLLfreqs[MaxLL+1] = {\n                    4, 2, 1, 1, 1, 1, 1, 1,\n                    1, 1, 1, 1, 1, 1, 1, 1,\n                    1, 1, 1, 1, 1, 1, 1, 1,\n                    1, 1, 1, 1, 1, 1, 1, 1,\n                    1, 1, 1, 1\n                };\n                ZSTD_memcpy(optPtr-\u003elitLengthFreq, baseLLfreqs, sizeof(baseLLfreqs));\n                optPtr-\u003elitLengthSum = sum_u32(baseLLfreqs, MaxLL+1);\n            }\n\n            {   unsigned ml;\n                for (ml=0; ml\u003c=MaxML; ml++)\n                    optPtr-\u003ematchLengthFreq[ml] = 1;\n            }\n            optPtr-\u003ematchLengthSum = MaxML+1;\n\n            {   unsigned const baseOFCfreqs[MaxOff+1] = {\n                    6, 2, 1, 1, 2, 3, 4, 4,\n                    4, 3, 2, 1, 1, 1, 1, 1,\n                    1, 1, 1, 1, 1, 1, 1, 1,\n                    1, 1, 1, 1, 1, 1, 1, 1\n                };\n                ZSTD_memcpy(optPtr-\u003eoffCodeFreq, baseOFCfreqs, sizeof(baseOFCfreqs));\n                optPtr-\u003eoffCodeSum = sum_u32(baseOFCfreqs, MaxOff+1);\n            }\n\n\n        }\n\n    } else {   /* new block : re-use previous statistics, scaled down */\n\n        if (compressedLiterals)\n            optPtr-\u003elitSum = ZSTD_scaleStats(optPtr-\u003elitFreq, MaxLit, 12);\n        optPtr-\u003elitLengthSum = ZSTD_scaleStats(optPtr-\u003elitLengthFreq, MaxLL, 11);\n        optPtr-\u003ematchLengthSum = ZSTD_scaleStats(optPtr-\u003ematchLengthFreq, MaxML, 11);\n        optPtr-\u003eoffCodeSum = ZSTD_scaleStats(optPtr-\u003eoffCodeFreq, MaxOff, 11);\n    }\n\n    ZSTD_setBasePrices(optPtr, optLevel);\n}","filepath":"lib/compress/zstd_opt.c","line_number":123,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2814384":{"score":0.8585315,"function_name":"ZSTD_opt_getNextMatchAndUpdateSeqStore","code":"static void\nZSTD_opt_getNextMatchAndUpdateSeqStore(ZSTD_optLdm_t* optLdm, U32 currPosInBlock,\n                                       U32 blockBytesRemaining)\n{\n    rawSeq currSeq;\n    U32 currBlockEndPos;\n    U32 literalsBytesRemaining;\n    U32 matchBytesRemaining;\n\n    /* Setting match end position to MAX to ensure we never use an LDM during this block */\n    if (optLdm-\u003eseqStore.size == 0 || optLdm-\u003eseqStore.pos \u003e= optLdm-\u003eseqStore.size) {\n        optLdm-\u003estartPosInBlock = UINT_MAX;\n        optLdm-\u003eendPosInBlock = UINT_MAX;\n        return;\n    }\n    /* Calculate appropriate bytes left in matchLength and litLength\n     * after adjusting based on ldmSeqStore-\u003eposInSequence */\n    currSeq = optLdm-\u003eseqStore.seq[optLdm-\u003eseqStore.pos];\n    assert(optLdm-\u003eseqStore.posInSequence \u003c= currSeq.litLength + currSeq.matchLength);\n    currBlockEndPos = currPosInBlock + blockBytesRemaining;\n    literalsBytesRemaining = (optLdm-\u003eseqStore.posInSequence \u003c currSeq.litLength) ?\n            currSeq.litLength - (U32)optLdm-\u003eseqStore.posInSequence :\n            0;\n    matchBytesRemaining = (literalsBytesRemaining == 0) ?\n            currSeq.matchLength - ((U32)optLdm-\u003eseqStore.posInSequence - currSeq.litLength) :\n            currSeq.matchLength;\n\n    /* If there are more literal bytes than bytes remaining in block, no ldm is possible */\n    if (literalsBytesRemaining \u003e= blockBytesRemaining) {\n        optLdm-\u003estartPosInBlock = UINT_MAX;\n        optLdm-\u003eendPosInBlock = UINT_MAX;\n        ZSTD_optLdm_skipRawSeqStoreBytes(\u0026optLdm-\u003eseqStore, blockBytesRemaining);\n        return;\n    }\n\n    /* Matches may be \u003c MINMATCH by this process. In that case, we will reject them\n       when we are deciding whether or not to add the ldm */\n    optLdm-\u003estartPosInBlock = currPosInBlock + literalsBytesRemaining;\n    optLdm-\u003eendPosInBlock = optLdm-\u003estartPosInBlock + matchBytesRemaining;\n    optLdm-\u003eoffset = currSeq.offset;\n\n    if (optLdm-\u003eendPosInBlock \u003e currBlockEndPos) {\n        /* Match ends after the block ends, we can't use the whole match */\n        optLdm-\u003eendPosInBlock = currBlockEndPos;\n        ZSTD_optLdm_skipRawSeqStoreBytes(\u0026optLdm-\u003eseqStore, currBlockEndPos - currPosInBlock);\n    } else {\n        /* Consume nb of bytes equal to size of sequence left */\n        ZSTD_optLdm_skipRawSeqStoreBytes(\u0026optLdm-\u003eseqStore, literalsBytesRemaining + matchBytesRemaining);\n    }\n}","filepath":"lib/compress/zstd_opt.c","line_number":903,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2814800":{"score":0.78858757,"function_name":"ZSTD_optLdm_processMatchCandidate","code":"static void\nZSTD_optLdm_processMatchCandidate(ZSTD_optLdm_t* optLdm,\n                                  ZSTD_match_t* matches, U32* nbMatches,\n                                  U32 currPosInBlock, U32 remainingBytes)\n{\n    if (optLdm-\u003eseqStore.size == 0 || optLdm-\u003eseqStore.pos \u003e= optLdm-\u003eseqStore.size) {\n        return;\n    }\n\n    if (currPosInBlock \u003e= optLdm-\u003eendPosInBlock) {\n        if (currPosInBlock \u003e optLdm-\u003eendPosInBlock) {\n            /* The position at which ZSTD_optLdm_processMatchCandidate() is called is not necessarily\n             * at the end of a match from the ldm seq store, and will often be some bytes\n             * over beyond matchEndPosInBlock. As such, we need to correct for these \"overshoots\"\n             */\n            U32 const posOvershoot = currPosInBlock - optLdm-\u003eendPosInBlock;\n            ZSTD_optLdm_skipRawSeqStoreBytes(\u0026optLdm-\u003eseqStore, posOvershoot);\n        }\n        ZSTD_opt_getNextMatchAndUpdateSeqStore(optLdm, currPosInBlock, remainingBytes);\n    }\n    ZSTD_optLdm_maybeAddMatch(matches, nbMatches, optLdm, currPosInBlock);\n}","filepath":"lib/compress/zstd_opt.c","line_number":986,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2815040":{"score":0.80094147,"function_name":"ZSTD_compressBlock_opt_generic","code":"FORCE_INLINE_TEMPLATE size_t\nZSTD_compressBlock_opt_generic(ZSTD_matchState_t* ms,\n                               seqStore_t* seqStore,\n                               U32 rep[ZSTD_REP_NUM],\n                         const void* src, size_t srcSize,\n                         const int optLevel,\n                         const ZSTD_dictMode_e dictMode)\n{\n    optState_t* const optStatePtr = \u0026ms-\u003eopt;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ms-\u003ewindow.base;\n    const BYTE* const prefixStart = base + ms-\u003ewindow.dictLimit;\n    const ZSTD_compressionParameters* const cParams = \u0026ms-\u003ecParams;\n\n    ZSTD_getAllMatchesFn getAllMatches = ZSTD_selectBtGetAllMatches(ms, dictMode);\n\n    U32 const sufficient_len = MIN(cParams-\u003etargetLength, ZSTD_OPT_NUM -1);\n    U32 const minMatch = (cParams-\u003eminMatch == 3) ? 3 : 4;\n    U32 nextToUpdate3 = ms-\u003enextToUpdate;\n\n    ZSTD_optimal_t* const opt = optStatePtr-\u003epriceTable;\n    ZSTD_match_t* const matches = optStatePtr-\u003ematchTable;\n    ZSTD_optimal_t lastSequence;\n    ZSTD_optLdm_t optLdm;\n\n    optLdm.seqStore = ms-\u003eldmSeqStore ? *ms-\u003eldmSeqStore : kNullRawSeqStore;\n    optLdm.endPosInBlock = optLdm.startPosInBlock = optLdm.offset = 0;\n    ZSTD_opt_getNextMatchAndUpdateSeqStore(\u0026optLdm, (U32)(ip-istart), (U32)(iend-ip));\n\n    /* init */\n    DEBUGLOG(5, \"ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u\",\n                (U32)(ip - base), ms-\u003ewindow.dictLimit, ms-\u003enextToUpdate);\n    assert(optLevel \u003c= 2);\n    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);\n    ip += (ip==prefixStart);\n\n    /* Match Loop */\n    while (ip \u003c ilimit) {\n        U32 cur, last_pos = 0;\n\n        /* find first match */\n        {   U32 const litlen = (U32)(ip - anchor);\n            U32 const ll0 = !litlen;\n            U32 nbMatches = getAllMatches(matches, ms, \u0026nextToUpdate3, ip, iend, rep, ll0, minMatch);\n            ZSTD_optLdm_processMatchCandidate(\u0026optLdm, matches, \u0026nbMatches,\n                                              (U32)(ip-istart), (U32)(iend - ip));\n            if (!nbMatches) { ip++; continue; }\n\n            /* initialize opt[0] */\n            { U32 i ; for (i=0; i\u003cZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }\n            opt[0].mlen = 0;  /* means is_a_literal */\n            opt[0].litlen = litlen;\n            /* We don't need to include the actual price of the literals because\n             * it is static for the duration of the forward pass, and is included\n             * in every price. We include the literal length to avoid negative\n             * prices when we subtract the previous literal length.\n             */\n            opt[0].price = (int)ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);\n\n            /* large match -\u003e immediate encoding */\n            {   U32 const maxML = matches[nbMatches-1].len;\n                U32 const maxOffcode = matches[nbMatches-1].off;\n                DEBUGLOG(6, \"found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u =\u003e start new series\",\n                            nbMatches, maxML, maxOffcode, (U32)(ip-prefixStart));\n\n                if (maxML \u003e sufficient_len) {\n                    lastSequence.litlen = litlen;\n                    lastSequence.mlen = maxML;\n                    lastSequence.off = maxOffcode;\n                    DEBUGLOG(6, \"large match (%u\u003e%u), immediate encoding\",\n                                maxML, sufficient_len);\n                    cur = 0;\n                    last_pos = ZSTD_totalLen(lastSequence);\n                    goto _shortestPath;\n            }   }\n\n            /* set prices for first matches starting position == 0 */\n            assert(opt[0].price \u003e= 0);\n            {   U32 const literalsPrice = (U32)opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);\n                U32 pos;\n                U32 matchNb;\n                for (pos = 1; pos \u003c minMatch; pos++) {\n                    opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */\n                }\n                for (matchNb = 0; matchNb \u003c nbMatches; matchNb++) {\n                    U32 const offcode = matches[matchNb].off;\n                    U32 const end = matches[matchNb].len;\n                    for ( ; pos \u003c= end ; pos++ ) {\n                        U32 const matchPrice = ZSTD_getMatchPrice(offcode, pos, optStatePtr, optLevel);\n                        U32 const sequencePrice = literalsPrice + matchPrice;\n                        DEBUGLOG(7, \"rPos:%u =\u003e set initial price : %.2f\",\n                                    pos, ZSTD_fCost(sequencePrice));\n                        opt[pos].mlen = pos;\n                        opt[pos].off = offcode;\n                        opt[pos].litlen = litlen;\n                        opt[pos].price = (int)sequencePrice;\n                }   }\n                last_pos = pos-1;\n            }\n        }\n\n        /* check further positions */\n        for (cur = 1; cur \u003c= last_pos; cur++) {\n            const BYTE* const inr = ip + cur;\n            assert(cur \u003c ZSTD_OPT_NUM);\n            DEBUGLOG(7, \"cPos:%zi==rPos:%u\", inr-istart, cur)\n\n            /* Fix current position with one literal if cheaper */\n            {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;\n                int const price = opt[cur-1].price\n                                + (int)ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)\n                                + (int)ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)\n                                - (int)ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);\n                assert(price \u003c 1000000000); /* overflow check */\n                if (price \u003c= opt[cur].price) {\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u : better price (%.2f\u003c=%.2f) using literal (ll==%u) (hist:%u,%u,%u)\",\n                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,\n                                opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);\n                    opt[cur].mlen = 0;\n                    opt[cur].off = 0;\n                    opt[cur].litlen = litlen;\n                    opt[cur].price = price;\n                } else {\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u : literal would cost more (%.2f\u003e%.2f) (hist:%u,%u,%u)\",\n                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),\n                                opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);\n                }\n            }\n\n            /* Set the repcodes of the current position. We must do it here\n             * because we rely on the repcodes of the 2nd to last sequence being\n             * correct to set the next chunks repcodes during the backward\n             * traversal.\n             */\n            ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));\n            assert(cur \u003e= opt[cur].mlen);\n            if (opt[cur].mlen != 0) {\n                U32 const prev = cur - opt[cur].mlen;\n                repcodes_t const newReps = ZSTD_newRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);\n                ZSTD_memcpy(opt[cur].rep, \u0026newReps, sizeof(repcodes_t));\n            } else {\n                ZSTD_memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));\n            }\n\n            /* last match must start at a minimum distance of 8 from oend */\n            if (inr \u003e ilimit) continue;\n\n            if (cur == last_pos) break;\n\n            if ( (optLevel==0) /*static_test*/\n              \u0026\u0026 (opt[cur+1].price \u003c= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {\n                DEBUGLOG(7, \"move to next rPos:%u : price is \u003c=\", cur+1);\n                continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */\n            }\n\n            assert(opt[cur].price \u003e= 0);\n            {   U32 const ll0 = (opt[cur].mlen != 0);\n                U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;\n                U32 const previousPrice = (U32)opt[cur].price;\n                U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);\n                U32 nbMatches = getAllMatches(matches, ms, \u0026nextToUpdate3, inr, iend, opt[cur].rep, ll0, minMatch);\n                U32 matchNb;\n\n                ZSTD_optLdm_processMatchCandidate(\u0026optLdm, matches, \u0026nbMatches,\n                                                  (U32)(inr-istart), (U32)(iend-inr));\n\n                if (!nbMatches) {\n                    DEBUGLOG(7, \"rPos:%u : no match found\", cur);\n                    continue;\n                }\n\n                {   U32 const maxML = matches[nbMatches-1].len;\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u, found %u matches, of maxLength=%u\",\n                                inr-istart, cur, nbMatches, maxML);\n\n                    if ( (maxML \u003e sufficient_len)\n                      || (cur + maxML \u003e= ZSTD_OPT_NUM) ) {\n                        lastSequence.mlen = maxML;\n                        lastSequence.off = matches[nbMatches-1].off;\n                        lastSequence.litlen = litlen;\n                        cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */\n                        last_pos = cur + ZSTD_totalLen(lastSequence);\n                        if (cur \u003e ZSTD_OPT_NUM) cur = 0;   /* underflow =\u003e first match */\n                        goto _shortestPath;\n                }   }\n\n                /* set prices using matches found at position == cur */\n                for (matchNb = 0; matchNb \u003c nbMatches; matchNb++) {\n                    U32 const offset = matches[matchNb].off;\n                    U32 const lastML = matches[matchNb].len;\n                    U32 const startML = (matchNb\u003e0) ? matches[matchNb-1].len+1 : minMatch;\n                    U32 mlen;\n\n                    DEBUGLOG(7, \"testing match %u =\u003e offCode=%4u, mlen=%2u, llen=%2u\",\n                                matchNb, matches[matchNb].off, lastML, litlen);\n\n                    for (mlen = lastML; mlen \u003e= startML; mlen--) {  /* scan downward */\n                        U32 const pos = cur + mlen;\n                        int const price = (int)basePrice + (int)ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);\n\n                        if ((pos \u003e last_pos) || (price \u003c opt[pos].price)) {\n                            DEBUGLOG(7, \"rPos:%u (ml=%2u) =\u003e new better price (%.2f\u003c%.2f)\",\n                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));\n                            while (last_pos \u003c pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */\n                            opt[pos].mlen = mlen;\n                            opt[pos].off = offset;\n                            opt[pos].litlen = litlen;\n                            opt[pos].price = price;\n                        } else {\n                            DEBUGLOG(7, \"rPos:%u (ml=%2u) =\u003e new price is worse (%.2f\u003e=%.2f)\",\n                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));\n                            if (optLevel==0) break;  /* early update abort; gets ~+10% speed for about -0.01 ratio loss */\n                        }\n            }   }   }\n        }  /* for (cur = 1; cur \u003c= last_pos; cur++) */\n\n        lastSequence = opt[last_pos];\n        cur = last_pos \u003e ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */\n        assert(cur \u003c ZSTD_OPT_NUM);  /* control overflow*/\n\n_shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */\n        assert(opt[0].mlen == 0);\n\n        /* Set the next chunk's repcodes based on the repcodes of the beginning\n         * of the last match, and the last sequence. This avoids us having to\n         * update them while traversing the sequences.\n         */\n        if (lastSequence.mlen != 0) {\n            repcodes_t const reps = ZSTD_newRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);\n            ZSTD_memcpy(rep, \u0026reps, sizeof(reps));\n        } else {\n            ZSTD_memcpy(rep, opt[cur].rep, sizeof(repcodes_t));\n        }\n\n        {   U32 const storeEnd = cur + 1;\n            U32 storeStart = storeEnd;\n            U32 seqPos = cur;\n\n            DEBUGLOG(6, \"start reverse traversal (last_pos:%u, cur:%u)\",\n                        last_pos, cur); (void)last_pos;\n            assert(storeEnd \u003c ZSTD_OPT_NUM);\n            DEBUGLOG(6, \"last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)\",\n                        storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);\n            opt[storeEnd] = lastSequence;\n            while (seqPos \u003e 0) {\n                U32 const backDist = ZSTD_totalLen(opt[seqPos]);\n                storeStart--;\n                DEBUGLOG(6, \"sequence from rPos=%u copied into pos=%u (llen=%u,mlen=%u,ofc=%u)\",\n                            seqPos, storeStart, opt[seqPos].litlen, opt[seqPos].mlen, opt[seqPos].off);\n                opt[storeStart] = opt[seqPos];\n                seqPos = (seqPos \u003e backDist) ? seqPos - backDist : 0;\n            }\n\n            /* save sequences */\n            DEBUGLOG(6, \"sending selected sequences into seqStore\")\n            {   U32 storePos;\n                for (storePos=storeStart; storePos \u003c= storeEnd; storePos++) {\n                    U32 const llen = opt[storePos].litlen;\n                    U32 const mlen = opt[storePos].mlen;\n                    U32 const offCode = opt[storePos].off;\n                    U32 const advance = llen + mlen;\n                    DEBUGLOG(6, \"considering seq starting at %zi, llen=%u, mlen=%u\",\n                                anchor - istart, (unsigned)llen, (unsigned)mlen);\n\n                    if (mlen==0) {  /* only literals =\u003e must be last \"sequence\", actually starting a new stream of sequences */\n                        assert(storePos == storeEnd);   /* must be last sequence */\n                        ip = anchor + llen;     /* last \"sequence\" is a bunch of literals =\u003e don't progress anchor */\n                        continue;   /* will finish */\n                    }\n\n                    assert(anchor + llen \u003c= iend);\n                    ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);\n                    ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen);\n                    anchor += advance;\n                    ip = anchor;\n            }   }\n            ZSTD_setBasePrices(optStatePtr, optLevel);\n        }\n    }   /* while (ip \u003c ilimit) */\n\n    /* Return the last literals size */\n    return (size_t)(iend - anchor);\n}","filepath":"lib/compress/zstd_opt.c","line_number":1036,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2819840":{"score":0.7944873,"function_name":"ZSTD_compressBlock_opt_generic","code":"FORCE_INLINE_TEMPLATE size_t\nZSTD_compressBlock_opt_generic(ZSTD_matchState_t* ms,\n                               seqStore_t* seqStore,\n                               U32 rep[ZSTD_REP_NUM],\n                         const void* src, size_t srcSize,\n                         const int optLevel,\n                         const ZSTD_dictMode_e dictMode)\n{\n    optState_t* const optStatePtr = \u0026ms-\u003eopt;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ms-\u003ewindow.base;\n    const BYTE* const prefixStart = base + ms-\u003ewindow.dictLimit;\n    const ZSTD_compressionParameters* const cParams = \u0026ms-\u003ecParams;\n\n    ZSTD_getAllMatchesFn getAllMatches = ZSTD_selectBtGetAllMatches(ms, dictMode);\n\n    U32 const sufficient_len = MIN(cParams-\u003etargetLength, ZSTD_OPT_NUM -1);\n    U32 const minMatch = (cParams-\u003eminMatch == 3) ? 3 : 4;\n    U32 nextToUpdate3 = ms-\u003enextToUpdate;\n\n    ZSTD_optimal_t* const opt = optStatePtr-\u003epriceTable;\n    ZSTD_match_t* const matches = optStatePtr-\u003ematchTable;\n    ZSTD_optimal_t lastSequence;\n    ZSTD_optLdm_t optLdm;\n\n    optLdm.seqStore = ms-\u003eldmSeqStore ? *ms-\u003eldmSeqStore : kNullRawSeqStore;\n    optLdm.endPosInBlock = optLdm.startPosInBlock = optLdm.offset = 0;\n    ZSTD_opt_getNextMatchAndUpdateSeqStore(\u0026optLdm, (U32)(ip-istart), (U32)(iend-ip));\n\n    /* init */\n    DEBUGLOG(5, \"ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u\",\n                (U32)(ip - base), ms-\u003ewindow.dictLimit, ms-\u003enextToUpdate);\n    assert(optLevel \u003c= 2);\n    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);\n    ip += (ip==prefixStart);\n\n    /* Match Loop */\n    while (ip \u003c ilimit) {\n        U32 cur, last_pos = 0;\n\n        /* find first match */\n        {   U32 const litlen = (U32)(ip - anchor);\n            U32 const ll0 = !litlen;\n            U32 nbMatches = getAllMatches(matches, ms, \u0026nextToUpdate3, ip, iend, rep, ll0, minMatch);\n            ZSTD_optLdm_processMatchCandidate(\u0026optLdm, matches, \u0026nbMatches,\n                                              (U32)(ip-istart), (U32)(iend - ip));\n            if (!nbMatches) { ip++; continue; }\n\n            /* initialize opt[0] */\n            { U32 i ; for (i=0; i\u003cZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }\n            opt[0].mlen = 0;  /* means is_a_literal */\n            opt[0].litlen = litlen;\n            /* We don't need to include the actual price of the literals because\n             * it is static for the duration of the forward pass, and is included\n             * in every price. We include the literal length to avoid negative\n             * prices when we subtract the previous literal length.\n             */\n            opt[0].price = (int)ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);\n\n            /* large match -\u003e immediate encoding */\n            {   U32 const maxML = matches[nbMatches-1].len;\n                U32 const maxOffcode = matches[nbMatches-1].off;\n                DEBUGLOG(6, \"found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u =\u003e start new series\",\n                            nbMatches, maxML, maxOffcode, (U32)(ip-prefixStart));\n\n                if (maxML \u003e sufficient_len) {\n                    lastSequence.litlen = litlen;\n                    lastSequence.mlen = maxML;\n                    lastSequence.off = maxOffcode;\n                    DEBUGLOG(6, \"large match (%u\u003e%u), immediate encoding\",\n                                maxML, sufficient_len);\n                    cur = 0;\n                    last_pos = ZSTD_totalLen(lastSequence);\n                    goto _shortestPath;\n            }   }\n\n            /* set prices for first matches starting position == 0 */\n            assert(opt[0].price \u003e= 0);\n            {   U32 const literalsPrice = (U32)opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);\n                U32 pos;\n                U32 matchNb;\n                for (pos = 1; pos \u003c minMatch; pos++) {\n                    opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */\n                }\n                for (matchNb = 0; matchNb \u003c nbMatches; matchNb++) {\n                    U32 const offcode = matches[matchNb].off;\n                    U32 const end = matches[matchNb].len;\n                    for ( ; pos \u003c= end ; pos++ ) {\n                        U32 const matchPrice = ZSTD_getMatchPrice(offcode, pos, optStatePtr, optLevel);\n                        U32 const sequencePrice = literalsPrice + matchPrice;\n                        DEBUGLOG(7, \"rPos:%u =\u003e set initial price : %.2f\",\n                                    pos, ZSTD_fCost(sequencePrice));\n                        opt[pos].mlen = pos;\n                        opt[pos].off = offcode;\n                        opt[pos].litlen = litlen;\n                        opt[pos].price = (int)sequencePrice;\n                }   }\n                last_pos = pos-1;\n            }\n        }\n\n        /* check further positions */\n        for (cur = 1; cur \u003c= last_pos; cur++) {\n            const BYTE* const inr = ip + cur;\n            assert(cur \u003c ZSTD_OPT_NUM);\n            DEBUGLOG(7, \"cPos:%zi==rPos:%u\", inr-istart, cur)\n\n            /* Fix current position with one literal if cheaper */\n            {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;\n                int const price = opt[cur-1].price\n                                + (int)ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)\n                                + (int)ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)\n                                - (int)ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);\n                assert(price \u003c 1000000000); /* overflow check */\n                if (price \u003c= opt[cur].price) {\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u : better price (%.2f\u003c=%.2f) using literal (ll==%u) (hist:%u,%u,%u)\",\n                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,\n                                opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);\n                    opt[cur].mlen = 0;\n                    opt[cur].off = 0;\n                    opt[cur].litlen = litlen;\n                    opt[cur].price = price;\n                } else {\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u : literal would cost more (%.2f\u003e%.2f) (hist:%u,%u,%u)\",\n                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),\n                                opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);\n                }\n            }\n\n            /* Set the repcodes of the current position. We must do it here\n             * because we rely on the repcodes of the 2nd to last sequence being\n             * correct to set the next chunks repcodes during the backward\n             * traversal.\n             */\n            ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));\n            assert(cur \u003e= opt[cur].mlen);\n            if (opt[cur].mlen != 0) {\n                U32 const prev = cur - opt[cur].mlen;\n                repcodes_t const newReps = ZSTD_newRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);\n                ZSTD_memcpy(opt[cur].rep, \u0026newReps, sizeof(repcodes_t));\n            } else {\n                ZSTD_memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));\n            }\n\n            /* last match must start at a minimum distance of 8 from oend */\n            if (inr \u003e ilimit) continue;\n\n            if (cur == last_pos) break;\n\n            if ( (optLevel==0) /*static_test*/\n              \u0026\u0026 (opt[cur+1].price \u003c= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {\n                DEBUGLOG(7, \"move to next rPos:%u : price is \u003c=\", cur+1);\n                continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */\n            }\n\n            assert(opt[cur].price \u003e= 0);\n            {   U32 const ll0 = (opt[cur].mlen != 0);\n                U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;\n                U32 const previousPrice = (U32)opt[cur].price;\n                U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);\n                U32 nbMatches = getAllMatches(matches, ms, \u0026nextToUpdate3, inr, iend, opt[cur].rep, ll0, minMatch);\n                U32 matchNb;\n\n                ZSTD_optLdm_processMatchCandidate(\u0026optLdm, matches, \u0026nbMatches,\n                                                  (U32)(inr-istart), (U32)(iend-inr));\n\n                if (!nbMatches) {\n                    DEBUGLOG(7, \"rPos:%u : no match found\", cur);\n                    continue;\n                }\n\n                {   U32 const maxML = matches[nbMatches-1].len;\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u, found %u matches, of maxLength=%u\",\n                                inr-istart, cur, nbMatches, maxML);\n\n                    if ( (maxML \u003e sufficient_len)\n                      || (cur + maxML \u003e= ZSTD_OPT_NUM) ) {\n                        lastSequence.mlen = maxML;\n                        lastSequence.off = matches[nbMatches-1].off;\n                        lastSequence.litlen = litlen;\n                        cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */\n                        last_pos = cur + ZSTD_totalLen(lastSequence);\n                        if (cur \u003e ZSTD_OPT_NUM) cur = 0;   /* underflow =\u003e first match */\n                        goto _shortestPath;\n                }   }\n\n                /* set prices using matches found at position == cur */\n                for (matchNb = 0; matchNb \u003c nbMatches; matchNb++) {\n                    U32 const offset = matches[matchNb].off;\n                    U32 const lastML = matches[matchNb].len;\n                    U32 const startML = (matchNb\u003e0) ? matches[matchNb-1].len+1 : minMatch;\n                    U32 mlen;\n\n                    DEBUGLOG(7, \"testing match %u =\u003e offCode=%4u, mlen=%2u, llen=%2u\",\n                                matchNb, matches[matchNb].off, lastML, litlen);\n\n                    for (mlen = lastML; mlen \u003e= startML; mlen--) {  /* scan downward */\n                        U32 const pos = cur + mlen;\n                        int const price = (int)basePrice + (int)ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);\n\n                        if ((pos \u003e last_pos) || (price \u003c opt[pos].price)) {\n                            DEBUGLOG(7, \"rPos:%u (ml=%2u) =\u003e new better price (%.2f\u003c%.2f)\",\n                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));\n                            while (last_pos \u003c pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */\n                            opt[pos].mlen = mlen;\n                            opt[pos].off = offset;\n                            opt[pos].litlen = litlen;\n                            opt[pos].price = price;\n                        } else {\n                            DEBUGLOG(7, \"rPos:%u (ml=%2u) =\u003e new price is worse (%.2f\u003e=%.2f)\",\n                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));\n                            if (optLevel==0) break;  /* early update abort; gets ~+10% speed for about -0.01 ratio loss */\n                        }\n            }   }   }\n        }  /* for (cur = 1; cur \u003c= last_pos; cur++) */\n\n        lastSequence = opt[last_pos];\n        cur = last_pos \u003e ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */\n        assert(cur \u003c ZSTD_OPT_NUM);  /* control overflow*/\n\n_shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */\n        assert(opt[0].mlen == 0);\n\n        /* Set the next chunk's repcodes based on the repcodes of the beginning\n         * of the last match, and the last sequence. This avoids us having to\n         * update them while traversing the sequences.\n         */\n        if (lastSequence.mlen != 0) {\n            repcodes_t const reps = ZSTD_newRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);\n            ZSTD_memcpy(rep, \u0026reps, sizeof(reps));\n        } else {\n            ZSTD_memcpy(rep, opt[cur].rep, sizeof(repcodes_t));\n        }\n\n        {   U32 const storeEnd = cur + 1;\n            U32 storeStart = storeEnd;\n            U32 seqPos = cur;\n\n            DEBUGLOG(6, \"start reverse traversal (last_pos:%u, cur:%u)\",\n                        last_pos, cur); (void)last_pos;\n            assert(storeEnd \u003c ZSTD_OPT_NUM);\n            DEBUGLOG(6, \"last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)\",\n                        storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);\n            opt[storeEnd] = lastSequence;\n            while (seqPos \u003e 0) {\n                U32 const backDist = ZSTD_totalLen(opt[seqPos]);\n                storeStart--;\n                DEBUGLOG(6, \"sequence from rPos=%u copied into pos=%u (llen=%u,mlen=%u,ofc=%u)\",\n                            seqPos, storeStart, opt[seqPos].litlen, opt[seqPos].mlen, opt[seqPos].off);\n                opt[storeStart] = opt[seqPos];\n                seqPos = (seqPos \u003e backDist) ? seqPos - backDist : 0;\n            }\n\n            /* save sequences */\n            DEBUGLOG(6, \"sending selected sequences into seqStore\")\n            {   U32 storePos;\n                for (storePos=storeStart; storePos \u003c= storeEnd; storePos++) {\n                    U32 const llen = opt[storePos].litlen;\n                    U32 const mlen = opt[storePos].mlen;\n                    U32 const offCode = opt[storePos].off;\n                    U32 const advance = llen + mlen;\n                    DEBUGLOG(6, \"considering seq starting at %zi, llen=%u, mlen=%u\",\n                                anchor - istart, (unsigned)llen, (unsigned)mlen);\n\n                    if (mlen==0) {  /* only literals =\u003e must be last \"sequence\", actually starting a new stream of sequences */\n                        assert(storePos == storeEnd);   /* must be last sequence */\n                        ip = anchor + llen;     /* last \"sequence\" is a bunch of literals =\u003e don't progress anchor */\n                        continue;   /* will finish */\n                    }\n\n                    assert(anchor + llen \u003c= iend);\n                    ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);\n                    ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen);\n                    anchor += advance;\n                    ip = anchor;\n            }   }\n            ZSTD_setBasePrices(optStatePtr, optLevel);\n        }\n    }   /* while (ip \u003c ilimit) */\n\n    /* Return the last literals size */\n    return (size_t)(iend - anchor);\n}","filepath":"lib/compress/zstd_opt.c","line_number":1036,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2871632":{"score":0.779667,"function_name":"ZSTD_compressBlock_btultra2","code":"size_t ZSTD_compressBlock_btultra2(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    U32 const curr = (U32)((const BYTE*)src - ms-\u003ewindow.base);\n    DEBUGLOG(5, \"ZSTD_compressBlock_btultra2 (srcSize=%zu)\", srcSize);\n\n    /* 2-pass strategy:\n     * this strategy makes a first pass over first block to collect statistics\n     * and seed next round's statistics with it.\n     * After 1st pass, function forgets everything, and starts a new block.\n     * Consequently, this can only work if no data has been previously loaded in tables,\n     * aka, no dictionary, no prefix, no ldm preprocessing.\n     * The compression ratio gain is generally small (~0.5% on first block),\n     * the cost is 2x cpu time on first block. */\n    assert(srcSize \u003c= ZSTD_BLOCKSIZE_MAX);\n    if ( (ms-\u003eopt.litLengthSum==0)   /* first block */\n      \u0026\u0026 (seqStore-\u003esequences == seqStore-\u003esequencesStart)  /* no ldm */\n      \u0026\u0026 (ms-\u003ewindow.dictLimit == ms-\u003ewindow.lowLimit)   /* no dictionary */\n      \u0026\u0026 (curr == ms-\u003ewindow.dictLimit)   /* start of frame, nothing already loaded nor skipped */\n      \u0026\u0026 (srcSize \u003e ZSTD_PREDEF_THRESHOLD)\n      ) {\n        ZSTD_initStats_ultra(ms, seqStore, rep, src, srcSize);\n    }\n\n    return ZSTD_compressBlock_opt2(ms, seqStore, rep, src, srcSize, ZSTD_noDict);\n}","filepath":"lib/compress/zstd_opt.c","line_number":1388,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.2"},"2871952":{"score":0.5671338,"function_name":"ZSTD_DCtx_selectFrameDDict","code":"static void ZSTD_DCtx_selectFrameDDict(ZSTD_DCtx* dctx) {\n    assert(dctx-\u003erefMultipleDDicts \u0026\u0026 dctx-\u003eddictSet);\n    DEBUGLOG(4, \"Adjusting DDict based on requested dict ID from frame\");\n    if (dctx-\u003eddict) {\n        const ZSTD_DDict* frameDDict = ZSTD_DDictHashSet_getDDict(dctx-\u003eddictSet, dctx-\u003efParams.dictID);\n        if (frameDDict) {\n            DEBUGLOG(4, \"DDict found!\");\n            ZSTD_clearDict(dctx);\n            dctx-\u003edictID = dctx-\u003efParams.dictID;\n            dctx-\u003eddict = frameDDict;\n            dctx-\u003edictUses = ZSTD_use_indefinitely;\n        }\n    }\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":345,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2872192":{"score":0.69359386,"function_name":"ZSTD_initDStream_usingDict","code":"size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize)\n{\n    zds-\u003estreamStage = zdss_loadHeader;\n    zds-\u003elhSize = zds-\u003einPos = zds-\u003eoutStart = zds-\u003eoutEnd = 0;\n    ZSTD_freeDDict(zds-\u003eddictLocal);\n    if (dict \u0026\u0026 dictSize \u003e= 8) {\n        zds-\u003eddictLocal = ZSTD_createDDict(dict, dictSize);\n        if (zds-\u003eddictLocal == NULL) return ERROR(memory_allocation);\n    } else zds-\u003eddictLocal = NULL;\n    zds-\u003eddict = zds-\u003eddictLocal;\n    zds-\u003elegacyVersion = 0;\n    zds-\u003ehostageByte = 0;\n    return ZSTD_frameHeaderSize_prefix;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2273,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2873168":{"score":0.7515474,"function_name":"ZSTD_decompressContinue","code":"size_t ZSTD_decompressContinue(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    DEBUGLOG(5, \"ZSTD_decompressContinue (srcSize:%u)\", (unsigned)srcSize);\n    /* Sanity check */\n    RETURN_ERROR_IF(srcSize != ZSTD_nextSrcSizeToDecompressWithInputSize(dctx, srcSize), srcSize_wrong, \"not allowed\");\n    ZSTD_checkContinuity(dctx, dst, dstCapacity);\n\n    dctx-\u003eprocessedCSize += srcSize;\n\n    switch (dctx-\u003estage)\n    {\n    case ZSTDds_getFrameHeaderSize :\n        assert(src != NULL);\n        if (dctx-\u003eformat == ZSTD_f_zstd1) {  /* allows header */\n            assert(srcSize \u003e= ZSTD_FRAMEIDSIZE);  /* to read skippable magic number */\n            if ((MEM_readLE32(src) \u0026 ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {        /* skippable frame */\n                ZSTD_memcpy(dctx-\u003eheaderBuffer, src, srcSize);\n                dctx-\u003eexpected = ZSTD_SKIPPABLEHEADERSIZE - srcSize;  /* remaining to load to get full skippable frame header */\n                dctx-\u003estage = ZSTDds_decodeSkippableHeader;\n                return 0;\n        }   }\n        dctx-\u003eheaderSize = ZSTD_frameHeaderSize_internal(src, srcSize, dctx-\u003eformat);\n        if (ZSTD_isError(dctx-\u003eheaderSize)) return dctx-\u003eheaderSize;\n        ZSTD_memcpy(dctx-\u003eheaderBuffer, src, srcSize);\n        dctx-\u003eexpected = dctx-\u003eheaderSize - srcSize;\n        dctx-\u003estage = ZSTDds_decodeFrameHeader;\n        return 0;\n\n    case ZSTDds_decodeFrameHeader:\n        assert(src != NULL);\n        ZSTD_memcpy(dctx-\u003eheaderBuffer + (dctx-\u003eheaderSize - srcSize), src, srcSize);\n        FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(dctx, dctx-\u003eheaderBuffer, dctx-\u003eheaderSize), \"\");\n        dctx-\u003eexpected = ZSTD_blockHeaderSize;\n        dctx-\u003estage = ZSTDds_decodeBlockHeader;\n        return 0;\n\n    case ZSTDds_decodeBlockHeader:\n        {   blockProperties_t bp;\n            size_t const cBlockSize = ZSTD_getcBlockSize(src, ZSTD_blockHeaderSize, \u0026bp);\n            if (ZSTD_isError(cBlockSize)) return cBlockSize;\n            RETURN_ERROR_IF(cBlockSize \u003e dctx-\u003efParams.blockSizeMax, corruption_detected, \"Block Size Exceeds Maximum\");\n            dctx-\u003eexpected = cBlockSize;\n            dctx-\u003ebType = bp.blockType;\n            dctx-\u003erleSize = bp.origSize;\n            if (cBlockSize) {\n                dctx-\u003estage = bp.lastBlock ? ZSTDds_decompressLastBlock : ZSTDds_decompressBlock;\n                return 0;\n            }\n            /* empty block */\n            if (bp.lastBlock) {\n                if (dctx-\u003efParams.checksumFlag) {\n                    dctx-\u003eexpected = 4;\n                    dctx-\u003estage = ZSTDds_checkChecksum;\n                } else {\n                    dctx-\u003eexpected = 0; /* end of frame */\n                    dctx-\u003estage = ZSTDds_getFrameHeaderSize;\n                }\n            } else {\n                dctx-\u003eexpected = ZSTD_blockHeaderSize;  /* jump to next header */\n                dctx-\u003estage = ZSTDds_decodeBlockHeader;\n            }\n            return 0;\n        }\n\n    case ZSTDds_decompressLastBlock:\n    case ZSTDds_decompressBlock:\n        DEBUGLOG(5, \"ZSTD_decompressContinue: case ZSTDds_decompressBlock\");\n        {   size_t rSize;\n            switch(dctx-\u003ebType)\n            {\n            case bt_compressed:\n                DEBUGLOG(5, \"ZSTD_decompressContinue: case bt_compressed\");\n                rSize = ZSTD_decompressBlock_internal(dctx, dst, dstCapacity, src, srcSize, /* frame */ 1);\n                dctx-\u003eexpected = 0;  /* Streaming not supported */\n                break;\n            case bt_raw :\n                assert(srcSize \u003c= dctx-\u003eexpected);\n                rSize = ZSTD_copyRawBlock(dst, dstCapacity, src, srcSize);\n                FORWARD_IF_ERROR(rSize, \"ZSTD_copyRawBlock failed\");\n                assert(rSize == srcSize);\n                dctx-\u003eexpected -= rSize;\n                break;\n            case bt_rle :\n                rSize = ZSTD_setRleBlock(dst, dstCapacity, *(const BYTE*)src, dctx-\u003erleSize);\n                dctx-\u003eexpected = 0;  /* Streaming not supported */\n                break;\n            case bt_reserved :   /* should never happen */\n            default:\n                RETURN_ERROR(corruption_detected, \"invalid block type\");\n            }\n            FORWARD_IF_ERROR(rSize, \"\");\n            RETURN_ERROR_IF(rSize \u003e dctx-\u003efParams.blockSizeMax, corruption_detected, \"Decompressed Block Size Exceeds Maximum\");\n            DEBUGLOG(5, \"ZSTD_decompressContinue: decoded size from block : %u\", (unsigned)rSize);\n            dctx-\u003edecodedSize += rSize;\n            if (dctx-\u003evalidateChecksum) XXH64_update(\u0026dctx-\u003exxhState, dst, rSize);\n            dctx-\u003epreviousDstEnd = (char*)dst + rSize;\n\n            /* Stay on the same stage until we are finished streaming the block. */\n            if (dctx-\u003eexpected \u003e 0) {\n                return rSize;\n            }\n\n            if (dctx-\u003estage == ZSTDds_decompressLastBlock) {   /* end of frame */\n                DEBUGLOG(4, \"ZSTD_decompressContinue: decoded size from frame : %u\", (unsigned)dctx-\u003edecodedSize);\n                RETURN_ERROR_IF(\n                    dctx-\u003efParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN\n                 \u0026\u0026 dctx-\u003edecodedSize != dctx-\u003efParams.frameContentSize,\n                    corruption_detected, \"\");\n                if (dctx-\u003efParams.checksumFlag) {  /* another round for frame checksum */\n                    dctx-\u003eexpected = 4;\n                    dctx-\u003estage = ZSTDds_checkChecksum;\n                } else {\n                    ZSTD_DCtx_trace_end(dctx, dctx-\u003edecodedSize, dctx-\u003eprocessedCSize, /* streaming */ 1);\n                    dctx-\u003eexpected = 0;   /* ends here */\n                    dctx-\u003estage = ZSTDds_getFrameHeaderSize;\n                }\n            } else {\n                dctx-\u003estage = ZSTDds_decodeBlockHeader;\n                dctx-\u003eexpected = ZSTD_blockHeaderSize;\n            }\n            return rSize;\n        }\n\n    case ZSTDds_checkChecksum:\n        assert(srcSize == 4);  /* guaranteed by dctx-\u003eexpected */\n        {\n            if (dctx-\u003evalidateChecksum) {\n                U32 const h32 = (U32)XXH64_digest(\u0026dctx-\u003exxhState);\n                U32 const check32 = MEM_readLE32(src);\n                DEBUGLOG(4, \"ZSTD_decompressContinue: checksum : calculated %08X :: %08X read\", (unsigned)h32, (unsigned)check32);\n                RETURN_ERROR_IF(check32 != h32, checksum_wrong, \"\");\n            }\n            ZSTD_DCtx_trace_end(dctx, dctx-\u003edecodedSize, dctx-\u003eprocessedCSize, /* streaming */ 1);\n            dctx-\u003eexpected = 0;\n            dctx-\u003estage = ZSTDds_getFrameHeaderSize;\n            return 0;\n        }\n\n    case ZSTDds_decodeSkippableHeader:\n        assert(src != NULL);\n        assert(srcSize \u003c= ZSTD_SKIPPABLEHEADERSIZE);\n        ZSTD_memcpy(dctx-\u003eheaderBuffer + (ZSTD_SKIPPABLEHEADERSIZE - srcSize), src, srcSize);   /* complete skippable header */\n        dctx-\u003eexpected = MEM_readLE32(dctx-\u003eheaderBuffer + ZSTD_FRAMEIDSIZE);   /* note : dctx-\u003eexpected can grow seriously large, beyond local buffer size */\n        dctx-\u003estage = ZSTDds_skipFrame;\n        return 0;\n\n    case ZSTDds_skipFrame:\n        dctx-\u003eexpected = 0;\n        dctx-\u003estage = ZSTDds_getFrameHeaderSize;\n        return 0;\n\n    default:\n        assert(0);   /* impossible */\n        RETURN_ERROR(GENERIC, \"impossible to reach\");   /* some compiler require default to do something */\n    }\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1142,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2874880":{"score":0.8064729,"function_name":"ZSTD_decompressContinueStream","code":"static size_t ZSTD_decompressContinueStream(\n            ZSTD_DStream* zds, char** op, char* oend,\n            void const* src, size_t srcSize) {\n    int const isSkipFrame = ZSTD_isSkipFrame(zds);\n    if (zds-\u003eoutBufferMode == ZSTD_bm_buffered) {\n        size_t const dstSize = isSkipFrame ? 0 : zds-\u003eoutBuffSize - zds-\u003eoutStart;\n        size_t const decodedSize = ZSTD_decompressContinue(zds,\n                zds-\u003eoutBuff + zds-\u003eoutStart, dstSize, src, srcSize);\n        FORWARD_IF_ERROR(decodedSize, \"\");\n        if (!decodedSize \u0026\u0026 !isSkipFrame) {\n            zds-\u003estreamStage = zdss_read;\n        } else {\n            zds-\u003eoutEnd = zds-\u003eoutStart + decodedSize;\n            zds-\u003estreamStage = zdss_flush;\n        }\n    } else {\n        /* Write directly into the output buffer */\n        size_t const dstSize = isSkipFrame ? 0 : (size_t)(oend - *op);\n        size_t const decodedSize = ZSTD_decompressContinue(zds, *op, dstSize, src, srcSize);\n        FORWARD_IF_ERROR(decodedSize, \"\");\n        *op += decodedSize;\n        /* Flushing is not needed. */\n        zds-\u003estreamStage = zdss_read;\n        assert(*op \u003c= oend);\n        assert(zds-\u003eoutBufferMode == ZSTD_bm_stable);\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1881,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2875312":{"score":0.7250414,"function_name":"ZSTD_initStaticDCtx","code":"ZSTD_DCtx* ZSTD_initStaticDCtx(void *workspace, size_t workspaceSize)\n{\n    ZSTD_DCtx* const dctx = (ZSTD_DCtx*) workspace;\n\n    if ((size_t)workspace \u0026 7) return NULL;  /* 8-aligned */\n    if (workspaceSize \u003c sizeof(ZSTD_DCtx)) return NULL;  /* minimum size */\n\n    ZSTD_initDCtx_internal(dctx);\n    dctx-\u003estaticSize = workspaceSize;\n    dctx-\u003einBuff = (char*)(dctx+1);\n    return dctx;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":178,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2875568":{"score":0.7197939,"function_name":"ZSTD_createDCtx_advanced","code":"ZSTD_DCtx* ZSTD_createDCtx_advanced(ZSTD_customMem customMem)\n{\n    if (!customMem.customAlloc ^ !customMem.customFree) return NULL;\n\n    {   ZSTD_DCtx* const dctx = (ZSTD_DCtx*)ZSTD_malloc(sizeof(*dctx), customMem);\n        if (!dctx) return NULL;\n        dctx-\u003ecustomMem = customMem;\n        dctx-\u003elegacyContext = NULL;\n        dctx-\u003epreviousLegacyVersion = 0;\n        ZSTD_initDCtx_internal(dctx);\n        return dctx;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":191,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2876240":{"score":0.81081206,"function_name":"ZSTD_freeDCtx","code":"size_t ZSTD_freeDCtx(ZSTD_DCtx* dctx)\n{\n    if (dctx==NULL) return 0;   /* support free on NULL */\n    if (dctx-\u003estaticSize) return ERROR(memory_allocation);   /* not compatible with static DCtx */\n    {   ZSTD_customMem const cMem = dctx-\u003ecustomMem;\n        ZSTD_freeDDict(dctx-\u003eddictLocal);\n        dctx-\u003eddictLocal = NULL;\n        ZSTD_free(dctx-\u003einBuff, cMem);\n        dctx-\u003einBuff = NULL;\n#if defined(ZSTD_LEGACY_SUPPORT) \u0026\u0026 (ZSTD_LEGACY_SUPPORT \u003e= 1)\n        if (dctx-\u003elegacyContext)\n            ZSTD_freeLegacyStreamContext(dctx-\u003elegacyContext, dctx-\u003epreviousLegacyVersion);\n#endif\n        ZSTD_free(dctx, cMem);\n        return 0;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":210,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2876592":{"score":0.75971067,"function_name":"ZSTD_isSkippableFrame","code":"unsigned ZSTD_isSkippableFrame(const void* buffer, size_t size)\n{\n    if (size \u003c ZSTD_FRAMEIDSIZE) return 0;\n    {   U32 const magic = MEM_readLE32(buffer);\n        if ((magic \u0026 ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) return 1;\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":387,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2876640":{"score":0.817323,"function_name":"ZSTD_isSkippableFrame","code":"unsigned ZSTD_isSkippableFrame(const void* buffer, size_t size)\n{\n    if (size \u003c ZSTD_FRAMEIDSIZE) return 0;\n    {   U32 const magic = MEM_readLE32(buffer);\n        if ((magic \u0026 ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) return 1;\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":387,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2877536":{"score":0.82262534,"function_name":"ZSTD_findFrameCompressedSize","code":"size_t ZSTD_findFrameCompressedSize(const void *src, size_t srcSize)\n{\n#if defined(ZSTD_LEGACY_SUPPORT) \u0026\u0026 (ZSTD_LEGACY_SUPPORT \u003e= 1)\n    if (ZSTD_isLegacy(src, srcSize))\n        return ZSTD_findFrameCompressedSizeLegacy(src, srcSize);\n#endif\n    if ( (srcSize \u003e= ZSTD_skippableHeaderSize)\n      \u0026\u0026 (MEM_readLE32(src) \u0026 0xFFFFFFF0U) == ZSTD_MAGIC_SKIPPABLE_START ) {\n        return ZSTD_skippableHeaderSize + MEM_readLE32((const BYTE*)src + ZSTD_frameIdSize);\n    } else {\n        const BYTE* ip = (const BYTE*)src;\n        const BYTE* const ipstart = ip;\n        size_t remainingSize = srcSize;\n        ZSTD_frameHeader zfh;\n\n        /* Extract Frame Header */\n        {   size_t const ret = ZSTD_getFrameHeader(\u0026zfh, src, srcSize);\n            if (ZSTD_isError(ret)) return ret;\n            if (ret \u003e 0) return ERROR(srcSize_wrong);\n        }\n\n        ip += zfh.headerSize;\n        remainingSize -= zfh.headerSize;\n\n        /* Loop on each block */\n        while (1) {\n            blockProperties_t blockProperties;\n            size_t const cBlockSize = ZSTD_getcBlockSize(ip, remainingSize, \u0026blockProperties);\n            if (ZSTD_isError(cBlockSize)) return cBlockSize;\n\n            if (ZSTD_blockHeaderSize + cBlockSize \u003e remainingSize)\n                return ERROR(srcSize_wrong);\n\n            ip += ZSTD_blockHeaderSize + cBlockSize;\n            remainingSize -= ZSTD_blockHeaderSize + cBlockSize;\n\n            if (blockProperties.lastBlock) break;\n        }\n\n        if (zfh.checksumFlag) {   /* Final frame content checksum */\n            if (remainingSize \u003c 4) return ERROR(srcSize_wrong);\n            ip += 4;\n            remainingSize -= 4;\n        }\n\n        return ip - ipstart;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":1480,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2878992":{"score":0.73300165,"function_name":"ZSTD_readSkippableFrame","code":"ZSTDLIB_API size_t ZSTD_readSkippableFrame(void* dst, size_t dstCapacity, unsigned* magicVariant,\n                                            const void* src, size_t srcSize)\n{\n    U32 const magicNumber = MEM_readLE32(src);\n    size_t skippableFrameSize = readSkippableFrameSize(src, srcSize);\n    size_t skippableContentSize = skippableFrameSize - ZSTD_SKIPPABLEHEADERSIZE;\n\n    /* check input validity */\n    RETURN_ERROR_IF(!ZSTD_isSkippableFrame(src, srcSize), frameParameter_unsupported, \"\");\n    RETURN_ERROR_IF(skippableFrameSize \u003c ZSTD_SKIPPABLEHEADERSIZE || skippableFrameSize \u003e srcSize, srcSize_wrong, \"\");\n    RETURN_ERROR_IF(skippableContentSize \u003e dstCapacity, dstSize_tooSmall, \"\");\n\n    /* deliver payload */\n    if (skippableContentSize \u003e 0  \u0026\u0026 dst != NULL)\n        ZSTD_memcpy(dst, (const BYTE *)src + ZSTD_SKIPPABLEHEADERSIZE, skippableContentSize);\n    if (magicVariant != NULL)\n        *magicVariant = magicNumber - ZSTD_MAGIC_SKIPPABLE_START;\n    return skippableContentSize;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":570,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2880320":{"score":0.8594609,"function_name":"ZSTD_decompressBound","code":"unsigned long long ZSTD_decompressBound(const void* src, size_t srcSize)\n{\n    unsigned long long bound = 0;\n    /* Iterate over each frame */\n    while (srcSize \u003e 0) {\n        ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);\n        size_t const compressedSize = frameSizeInfo.compressedSize;\n        unsigned long long const decompressedBound = frameSizeInfo.decompressedBound;\n        if (ZSTD_isError(compressedSize) || decompressedBound == ZSTD_CONTENTSIZE_ERROR)\n            return ZSTD_CONTENTSIZE_ERROR;\n        assert(srcSize \u003e= compressedSize);\n        src = (const BYTE*)src + compressedSize;\n        srcSize -= compressedSize;\n        bound += decompressedBound;\n    }\n    return bound;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":771,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2880464":{"score":0.7704455,"function_name":"ZSTD_nextInputType","code":"ZSTD_nextInputType_e ZSTD_nextInputType(ZSTD_DCtx* dctx) {\n    switch(dctx-\u003estage)\n    {\n    default:   /* should not happen */\n        assert(0);\n    case ZSTDds_getFrameHeaderSize:\n    case ZSTDds_decodeFrameHeader:\n        return ZSTDnit_frameHeader;\n    case ZSTDds_decodeBlockHeader:\n        return ZSTDnit_blockHeader;\n    case ZSTDds_decompressBlock:\n        return ZSTDnit_block;\n    case ZSTDds_decompressLastBlock:\n        return ZSTDnit_lastBlock;\n    case ZSTDds_checkChecksum:\n        return ZSTDnit_checksum;\n    case ZSTDds_decodeSkippableHeader:\n    case ZSTDds_skipFrame:\n        return ZSTDnit_skippableFrame;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":1730,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2880576":{"score":0.87518656,"function_name":"ZSTD_loadDEntropy","code":"size_t\nZSTD_loadDEntropy(ZSTD_entropyDTables_t* entropy,\n                  const void* const dict, size_t const dictSize)\n{\n    const BYTE* dictPtr = (const BYTE*)dict;\n    const BYTE* const dictEnd = dictPtr + dictSize;\n\n    RETURN_ERROR_IF(dictSize \u003c= 8, dictionary_corrupted, \"dict is too small\");\n    assert(MEM_readLE32(dict) == ZSTD_MAGIC_DICTIONARY);   /* dict must be valid */\n    dictPtr += 8;   /* skip header = magic + dictID */\n\n    ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, OFTable) == offsetof(ZSTD_entropyDTables_t, LLTable) + sizeof(entropy-\u003eLLTable));\n    ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, MLTable) == offsetof(ZSTD_entropyDTables_t, OFTable) + sizeof(entropy-\u003eOFTable));\n    ZSTD_STATIC_ASSERT(sizeof(entropy-\u003eLLTable) + sizeof(entropy-\u003eOFTable) + sizeof(entropy-\u003eMLTable) \u003e= HUF_DECOMPRESS_WORKSPACE_SIZE);\n    {   void* const workspace = \u0026entropy-\u003eLLTable;   /* use fse tables as temporary workspace; implies fse tables are grouped together */\n        size_t const workspaceSize = sizeof(entropy-\u003eLLTable) + sizeof(entropy-\u003eOFTable) + sizeof(entropy-\u003eMLTable);\n#ifdef HUF_FORCE_DECOMPRESS_X1\n        /* in minimal huffman, we always use X1 variants */\n        size_t const hSize = HUF_readDTableX1_wksp(entropy-\u003ehufTable,\n                                                dictPtr, dictEnd - dictPtr,\n                                                workspace, workspaceSize);\n#else\n        size_t const hSize = HUF_readDTableX2_wksp(entropy-\u003ehufTable,\n                                                dictPtr, (size_t)(dictEnd - dictPtr),\n                                                workspace, workspaceSize);\n#endif\n        RETURN_ERROR_IF(HUF_isError(hSize), dictionary_corrupted, \"\");\n        dictPtr += hSize;\n    }\n\n    {   short offcodeNCount[MaxOff+1];\n        unsigned offcodeMaxValue = MaxOff, offcodeLog;\n        size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, \u0026offcodeMaxValue, \u0026offcodeLog, dictPtr, (size_t)(dictEnd-dictPtr));\n        RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(offcodeMaxValue \u003e MaxOff, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(offcodeLog \u003e OffFSELog, dictionary_corrupted, \"\");\n        ZSTD_buildFSETable( entropy-\u003eOFTable,\n                            offcodeNCount, offcodeMaxValue,\n                            OF_base, OF_bits,\n                            offcodeLog,\n                            entropy-\u003eworkspace, sizeof(entropy-\u003eworkspace),\n                            /* bmi2 */0);\n        dictPtr += offcodeHeaderSize;\n    }\n\n    {   short matchlengthNCount[MaxML+1];\n        unsigned matchlengthMaxValue = MaxML, matchlengthLog;\n        size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, \u0026matchlengthMaxValue, \u0026matchlengthLog, dictPtr, (size_t)(dictEnd-dictPtr));\n        RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(matchlengthMaxValue \u003e MaxML, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(matchlengthLog \u003e MLFSELog, dictionary_corrupted, \"\");\n        ZSTD_buildFSETable( entropy-\u003eMLTable,\n                            matchlengthNCount, matchlengthMaxValue,\n                            ML_base, ML_bits,\n                            matchlengthLog,\n                            entropy-\u003eworkspace, sizeof(entropy-\u003eworkspace),\n                            /* bmi2 */ 0);\n        dictPtr += matchlengthHeaderSize;\n    }\n\n    {   short litlengthNCount[MaxLL+1];\n        unsigned litlengthMaxValue = MaxLL, litlengthLog;\n        size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, \u0026litlengthMaxValue, \u0026litlengthLog, dictPtr, (size_t)(dictEnd-dictPtr));\n        RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(litlengthMaxValue \u003e MaxLL, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(litlengthLog \u003e LLFSELog, dictionary_corrupted, \"\");\n        ZSTD_buildFSETable( entropy-\u003eLLTable,\n                            litlengthNCount, litlengthMaxValue,\n                            LL_base, LL_bits,\n                            litlengthLog,\n                            entropy-\u003eworkspace, sizeof(entropy-\u003eworkspace),\n                            /* bmi2 */ 0);\n        dictPtr += litlengthHeaderSize;\n    }\n\n    RETURN_ERROR_IF(dictPtr+12 \u003e dictEnd, dictionary_corrupted, \"\");\n    {   int i;\n        size_t const dictContentSize = (size_t)(dictEnd - (dictPtr+12));\n        for (i=0; i\u003c3; i++) {\n            U32 const rep = MEM_readLE32(dictPtr); dictPtr += 4;\n            RETURN_ERROR_IF(rep==0 || rep \u003e dictContentSize,\n                            dictionary_corrupted, \"\");\n            entropy-\u003erep[i] = rep;\n    }   }\n\n    return (size_t)(dictPtr - (const BYTE*)dict);\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1316,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2881280":{"score":0.7761612,"function_name":"ZSTD_decompressBegin","code":"size_t ZSTD_decompressBegin(ZSTD_DCtx* dctx)\n{\n    assert(dctx != NULL);\n#if ZSTD_TRACE\n    dctx-\u003etraceCtx = (ZSTD_trace_decompress_begin != NULL) ? ZSTD_trace_decompress_begin(dctx) : 0;\n#endif\n    dctx-\u003eexpected = ZSTD_startingInputLength(dctx-\u003eformat);  /* dctx-\u003eformat must be properly set */\n    dctx-\u003estage = ZSTDds_getFrameHeaderSize;\n    dctx-\u003eprocessedCSize = 0;\n    dctx-\u003edecodedSize = 0;\n    dctx-\u003epreviousDstEnd = NULL;\n    dctx-\u003eprefixStart = NULL;\n    dctx-\u003evirtualStart = NULL;\n    dctx-\u003edictEnd = NULL;\n    dctx-\u003eentropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);  /* cover both little and big endian */\n    dctx-\u003elitEntropy = dctx-\u003efseEntropy = 0;\n    dctx-\u003edictID = 0;\n    dctx-\u003ebType = bt_reserved;\n    ZSTD_STATIC_ASSERT(sizeof(dctx-\u003eentropy.rep) == sizeof(repStartValue));\n    ZSTD_memcpy(dctx-\u003eentropy.rep, repStartValue, sizeof(repStartValue));  /* initial repcodes */\n    dctx-\u003eLLTptr = dctx-\u003eentropy.LLTable;\n    dctx-\u003eMLTptr = dctx-\u003eentropy.MLTable;\n    dctx-\u003eOFTptr = dctx-\u003eentropy.OFTable;\n    dctx-\u003eHUFptr = dctx-\u003eentropy.hufTable;\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1425,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2881488":{"score":0.72811955,"function_name":"ZSTD_initDStream_usingDict","code":"size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize)\n{\n    zds-\u003estreamStage = zdss_loadHeader;\n    zds-\u003elhSize = zds-\u003einPos = zds-\u003eoutStart = zds-\u003eoutEnd = 0;\n    ZSTD_freeDDict(zds-\u003eddictLocal);\n    if (dict \u0026\u0026 dictSize \u003e= 8) {\n        zds-\u003eddictLocal = ZSTD_createDDict(dict, dictSize);\n        if (zds-\u003eddictLocal == NULL) return ERROR(memory_allocation);\n    } else zds-\u003eddictLocal = NULL;\n    zds-\u003eddict = zds-\u003eddictLocal;\n    zds-\u003elegacyVersion = 0;\n    zds-\u003ehostageByte = 0;\n    return ZSTD_frameHeaderSize_prefix;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2273,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2881888":{"score":0.72519165,"function_name":"ZSTD_decompressBegin_usingDDict","code":"size_t ZSTD_decompressBegin_usingDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)\n{\n    DEBUGLOG(4, \"ZSTD_decompressBegin_usingDDict\");\n    assert(dctx != NULL);\n    if (ddict) {\n        const char* const dictStart = (const char*)ZSTD_DDict_dictContent(ddict);\n        size_t const dictSize = ZSTD_DDict_dictSize(ddict);\n        const void* const dictEnd = dictStart + dictSize;\n        dctx-\u003eddictIsCold = (dctx-\u003edictEnd != dictEnd);\n        DEBUGLOG(4, \"DDict is %s\",\n                    dctx-\u003eddictIsCold ? \"~cold~\" : \"hot!\");\n    }\n    FORWARD_IF_ERROR( ZSTD_decompressBegin(dctx) , \"\");\n    if (ddict) {   /* NULL ddict is equivalent to no dictionary */\n        ZSTD_copyDDictParameters(dctx, ddict);\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1465,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2882176":{"score":0.8781231,"function_name":"ZSTD_decompressMultiFrame","code":"static size_t ZSTD_decompressMultiFrame(ZSTD_DCtx* dctx,\n                                        void* dst, size_t dstCapacity,\n                                  const void* src, size_t srcSize,\n                                  const void* dict, size_t dictSize,\n                                  const ZSTD_DDict* ddict)\n{\n    void* const dststart = dst;\n    int moreThan1Frame = 0;\n\n    DEBUGLOG(5, \"ZSTD_decompressMultiFrame\");\n    assert(dict==NULL || ddict==NULL);  /* either dict or ddict set, not both */\n\n    if (ddict) {\n        dict = ZSTD_DDict_dictContent(ddict);\n        dictSize = ZSTD_DDict_dictSize(ddict);\n    }\n\n    while (srcSize \u003e= ZSTD_startingInputLength(dctx-\u003eformat)) {\n\n#if defined(ZSTD_LEGACY_SUPPORT) \u0026\u0026 (ZSTD_LEGACY_SUPPORT \u003e= 1)\n        if (ZSTD_isLegacy(src, srcSize)) {\n            size_t decodedSize;\n            size_t const frameSize = ZSTD_findFrameCompressedSizeLegacy(src, srcSize);\n            if (ZSTD_isError(frameSize)) return frameSize;\n            RETURN_ERROR_IF(dctx-\u003estaticSize, memory_allocation,\n                \"legacy support is not compatible with static dctx\");\n\n            decodedSize = ZSTD_decompressLegacy(dst, dstCapacity, src, frameSize, dict, dictSize);\n            if (ZSTD_isError(decodedSize)) return decodedSize;\n\n            assert(decodedSize \u003c= dstCapacity);\n            dst = (BYTE*)dst + decodedSize;\n            dstCapacity -= decodedSize;\n\n            src = (const BYTE*)src + frameSize;\n            srcSize -= frameSize;\n\n            continue;\n        }\n#endif\n\n        {   U32 const magicNumber = MEM_readLE32(src);\n            DEBUGLOG(4, \"reading magic number %08X (expecting %08X)\",\n                        (unsigned)magicNumber, ZSTD_MAGICNUMBER);\n            if ((magicNumber \u0026 ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {\n                size_t const skippableSize = readSkippableFrameSize(src, srcSize);\n                FORWARD_IF_ERROR(skippableSize, \"readSkippableFrameSize failed\");\n                assert(skippableSize \u003c= srcSize);\n\n                src = (const BYTE *)src + skippableSize;\n                srcSize -= skippableSize;\n                continue;\n        }   }\n\n        if (ddict) {\n            /* we were called from ZSTD_decompress_usingDDict */\n            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(dctx, ddict), \"\");\n        } else {\n            /* this will initialize correctly with no dict if dict == NULL, so\n             * use this in all cases but ddict */\n            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDict(dctx, dict, dictSize), \"\");\n        }\n        ZSTD_checkContinuity(dctx, dst, dstCapacity);\n\n        {   const size_t res = ZSTD_decompressFrame(dctx, dst, dstCapacity,\n                                                    \u0026src, \u0026srcSize);\n            RETURN_ERROR_IF(\n                (ZSTD_getErrorCode(res) == ZSTD_error_prefix_unknown)\n             \u0026\u0026 (moreThan1Frame==1),\n                srcSize_wrong,\n                \"At least one frame successfully completed, \"\n                \"but following bytes are garbage: \"\n                \"it's more likely to be a srcSize error, \"\n                \"specifying more input bytes than size of frame(s). \"\n                \"Note: one could be unlucky, it might be a corruption error instead, \"\n                \"happening right at the place where we expect zstd magic bytes. \"\n                \"But this is _much_ less likely than a srcSize field error.\");\n            if (ZSTD_isError(res)) return res;\n            assert(res \u003c= dstCapacity);\n            if (res != 0)\n                dst = (BYTE*)dst + res;\n            dstCapacity -= res;\n        }\n        moreThan1Frame = 1;\n    }  /* while (srcSize \u003e= ZSTD_frameHeaderSize_prefix) */\n\n    RETURN_ERROR_IF(srcSize, srcSize_wrong, \"input not entirely consumed\");\n\n    return (size_t)((BYTE*)dst - (BYTE*)dststart);\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":950,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2884112":{"score":0.710563,"function_name":"ZSTD_decompress","code":"size_t ZSTD_decompress(void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n#if defined(ZSTD_HEAPMODE) \u0026\u0026 (ZSTD_HEAPMODE\u003e=1)\n    size_t regenSize;\n    ZSTD_DCtx* const dctx = ZSTD_createDCtx();\n    RETURN_ERROR_IF(dctx==NULL, memory_allocation, \"NULL pointer!\");\n    regenSize = ZSTD_decompressDCtx(dctx, dst, dstCapacity, src, srcSize);\n    ZSTD_freeDCtx(dctx);\n    return regenSize;\n#else   /* stack mode */\n    ZSTD_DCtx dctx;\n    ZSTD_initDCtx_internal(\u0026dctx);\n    return ZSTD_decompressDCtx(\u0026dctx, dst, dstCapacity, src, srcSize);\n#endif\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1073,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2885552":{"score":0.7220353,"function_name":"ZSTD_initStaticDCtx","code":"ZSTD_DCtx* ZSTD_initStaticDCtx(void *workspace, size_t workspaceSize)\n{\n    ZSTD_DCtx* const dctx = (ZSTD_DCtx*) workspace;\n\n    if ((size_t)workspace \u0026 7) return NULL;  /* 8-aligned */\n    if (workspaceSize \u003c sizeof(ZSTD_DCtx)) return NULL;  /* minimum size */\n\n    ZSTD_initDCtx_internal(dctx);\n    dctx-\u003estaticSize = workspaceSize;\n    dctx-\u003einBuff = (char*)(dctx+1);\n    return dctx;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":178,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2885808":{"score":0.7159269,"function_name":"ZSTD_createDCtx_advanced","code":"ZSTD_DCtx* ZSTD_createDCtx_advanced(ZSTD_customMem customMem)\n{\n    if (!customMem.customAlloc ^ !customMem.customFree) return NULL;\n\n    {   ZSTD_DCtx* const dctx = (ZSTD_DCtx*)ZSTD_malloc(sizeof(*dctx), customMem);\n        if (!dctx) return NULL;\n        dctx-\u003ecustomMem = customMem;\n        dctx-\u003elegacyContext = NULL;\n        dctx-\u003epreviousLegacyVersion = 0;\n        ZSTD_initDCtx_internal(dctx);\n        return dctx;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":191,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2886176":{"score":0.8087302,"function_name":"ZSTD_freeDCtx","code":"size_t ZSTD_freeDCtx(ZSTD_DCtx* dctx)\n{\n    if (dctx==NULL) return 0;   /* support free on NULL */\n    if (dctx-\u003estaticSize) return ERROR(memory_allocation);   /* not compatible with static DCtx */\n    {   ZSTD_customMem const cMem = dctx-\u003ecustomMem;\n        ZSTD_freeDDict(dctx-\u003eddictLocal);\n        dctx-\u003eddictLocal = NULL;\n        ZSTD_free(dctx-\u003einBuff, cMem);\n        dctx-\u003einBuff = NULL;\n#if defined(ZSTD_LEGACY_SUPPORT) \u0026\u0026 (ZSTD_LEGACY_SUPPORT \u003e= 1)\n        if (dctx-\u003elegacyContext)\n            ZSTD_freeLegacyStreamContext(dctx-\u003elegacyContext, dctx-\u003epreviousLegacyVersion);\n#endif\n        ZSTD_free(dctx, cMem);\n        return 0;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":210,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2886544":{"score":0.87546635,"function_name":"ZSTD_DCtx_loadDictionary_advanced","code":"size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx,\n                                   const void* dict, size_t dictSize,\n                                         ZSTD_dictLoadMethod_e dictLoadMethod,\n                                         ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (dict \u0026\u0026 dictSize != 0) {\n        dctx-\u003eddictLocal = ZSTD_createDDict_advanced(dict, dictSize, dictLoadMethod, dictContentType, dctx-\u003ecustomMem);\n        RETURN_ERROR_IF(dctx-\u003eddictLocal == NULL, memory_allocation, \"NULL pointer!\");\n        dctx-\u003eddict = dctx-\u003eddictLocal;\n        dctx-\u003edictUses = ZSTD_use_indefinitely;\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1563,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2886768":{"score":0.6916164,"function_name":"ZSTD_DCtx_loadDictionary_advanced","code":"size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx,\n                                   const void* dict, size_t dictSize,\n                                         ZSTD_dictLoadMethod_e dictLoadMethod,\n                                         ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (dict \u0026\u0026 dictSize != 0) {\n        dctx-\u003eddictLocal = ZSTD_createDDict_advanced(dict, dictSize, dictLoadMethod, dictContentType, dctx-\u003ecustomMem);\n        RETURN_ERROR_IF(dctx-\u003eddictLocal == NULL, memory_allocation, \"NULL pointer!\");\n        dctx-\u003eddict = dctx-\u003eddictLocal;\n        dctx-\u003edictUses = ZSTD_use_indefinitely;\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1563,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2886976":{"score":0.6957135,"function_name":"ZSTD_DCtx_loadDictionary_advanced","code":"size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx,\n                                   const void* dict, size_t dictSize,\n                                         ZSTD_dictLoadMethod_e dictLoadMethod,\n                                         ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (dict \u0026\u0026 dictSize != 0) {\n        dctx-\u003eddictLocal = ZSTD_createDDict_advanced(dict, dictSize, dictLoadMethod, dictContentType, dctx-\u003ecustomMem);\n        RETURN_ERROR_IF(dctx-\u003eddictLocal == NULL, memory_allocation, \"NULL pointer!\");\n        dctx-\u003eddict = dctx-\u003eddictLocal;\n        dctx-\u003edictUses = ZSTD_use_indefinitely;\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1563,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2887184":{"score":0.7891284,"function_name":"ZSTD_DCtx_loadDictionary_advanced","code":"size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx,\n                                   const void* dict, size_t dictSize,\n                                         ZSTD_dictLoadMethod_e dictLoadMethod,\n                                         ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (dict \u0026\u0026 dictSize != 0) {\n        dctx-\u003eddictLocal = ZSTD_createDDict_advanced(dict, dictSize, dictLoadMethod, dictContentType, dctx-\u003ecustomMem);\n        RETURN_ERROR_IF(dctx-\u003eddictLocal == NULL, memory_allocation, \"NULL pointer!\");\n        dctx-\u003eddict = dctx-\u003eddictLocal;\n        dctx-\u003edictUses = ZSTD_use_indefinitely;\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1563,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2887392":{"score":0.6736033,"function_name":"ZSTD_DCtx_loadDictionary_advanced","code":"size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx,\n                                   const void* dict, size_t dictSize,\n                                         ZSTD_dictLoadMethod_e dictLoadMethod,\n                                         ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (dict \u0026\u0026 dictSize != 0) {\n        dctx-\u003eddictLocal = ZSTD_createDDict_advanced(dict, dictSize, dictLoadMethod, dictContentType, dctx-\u003ecustomMem);\n        RETURN_ERROR_IF(dctx-\u003eddictLocal == NULL, memory_allocation, \"NULL pointer!\");\n        dctx-\u003eddict = dctx-\u003eddictLocal;\n        dctx-\u003edictUses = ZSTD_use_indefinitely;\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1563,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2887776":{"score":0.56622535,"function_name":"ZSTD_resetDStream","code":"size_t ZSTD_resetDStream(ZSTD_DStream* zds)\n{\n    zds-\u003estreamStage = zdss_loadHeader;\n    zds-\u003elhSize = zds-\u003einPos = zds-\u003eoutStart = zds-\u003eoutEnd = 0;\n    zds-\u003elegacyVersion = 0;\n    zds-\u003ehostageByte = 0;\n    return ZSTD_frameHeaderSize_prefix;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2304,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2887856":{"score":0.6409699,"function_name":"ZSTD_DCtx_refDDict","code":"size_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (ddict) {\n        dctx-\u003eddict = ddict;\n        dctx-\u003edictUses = ZSTD_use_indefinitely;\n        if (dctx-\u003erefMultipleDDicts == ZSTD_rmd_refMultipleDDicts) {\n            if (dctx-\u003eddictSet == NULL) {\n                dctx-\u003eddictSet = ZSTD_createDDictHashSet(dctx-\u003ecustomMem);\n                if (!dctx-\u003eddictSet) {\n                    RETURN_ERROR(memory_allocation, \"Failed to allocate memory for hash set!\");\n                }\n            }\n            assert(!dctx-\u003estaticSize);  /* Impossible: ddictSet cannot have been allocated if static dctx */\n            FORWARD_IF_ERROR(ZSTD_DDictHashSet_addDDict(dctx-\u003eddictSet, ddict, dctx-\u003ecustomMem), \"\");\n        }\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1640,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2888944":{"score":0.81539464,"function_name":"ZSTD_DCtx_refDDict","code":"size_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (ddict) {\n        dctx-\u003eddict = ddict;\n        dctx-\u003edictUses = ZSTD_use_indefinitely;\n        if (dctx-\u003erefMultipleDDicts == ZSTD_rmd_refMultipleDDicts) {\n            if (dctx-\u003eddictSet == NULL) {\n                dctx-\u003eddictSet = ZSTD_createDDictHashSet(dctx-\u003ecustomMem);\n                if (!dctx-\u003eddictSet) {\n                    RETURN_ERROR(memory_allocation, \"Failed to allocate memory for hash set!\");\n                }\n            }\n            assert(!dctx-\u003estaticSize);  /* Impossible: ddictSet cannot have been allocated if static dctx */\n            FORWARD_IF_ERROR(ZSTD_DDictHashSet_addDDict(dctx-\u003eddictSet, ddict, dctx-\u003ecustomMem), \"\");\n        }\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1640,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2889936":{"score":0.77457714,"function_name":"ZSTD_DCtx_setMaxWindowSize","code":"size_t ZSTD_DCtx_setMaxWindowSize(ZSTD_DCtx* dctx, size_t maxWindowSize)\n{\n    ZSTD_STATIC_ASSERT((unsigned)zdss_loadHeader \u003e= (unsigned)zdss_init);\n    if ((unsigned)dctx-\u003estreamStage \u003e (unsigned)zdss_loadHeader)\n        return ERROR(stage_wrong);\n    dctx-\u003emaxWindowSize = maxWindowSize;\n    return 0;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2330,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2890000":{"score":0.7697654,"function_name":"ZSTD_DCtx_setFormat","code":"size_t ZSTD_DCtx_setFormat(ZSTD_DCtx* dctx, ZSTD_format_e format)\n{\n    DEBUGLOG(4, \"ZSTD_DCtx_setFormat : %u\", (unsigned)format);\n    ZSTD_STATIC_ASSERT((unsigned)zdss_loadHeader \u003e= (unsigned)zdss_init);\n    if ((unsigned)dctx-\u003estreamStage \u003e (unsigned)zdss_loadHeader)\n        return ERROR(stage_wrong);\n    dctx-\u003eformat = format;\n    return 0;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2339,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2890048":{"score":0.7026161,"function_name":"ZSTD_dParam_getBounds","code":"ZSTD_bounds ZSTD_dParam_getBounds(ZSTD_dParameter dParam)\n{\n    ZSTD_bounds bounds = { 0, 0, 0 };\n    switch(dParam) {\n        case ZSTD_d_windowLogMax:\n            bounds.lowerBound = ZSTD_WINDOWLOG_ABSOLUTEMIN;\n            bounds.upperBound = ZSTD_WINDOWLOG_MAX;\n            return bounds;\n        case ZSTD_d_format:\n            bounds.lowerBound = (int)ZSTD_f_zstd1;\n            bounds.upperBound = (int)ZSTD_f_zstd1_magicless;\n            ZSTD_STATIC_ASSERT(ZSTD_f_zstd1 \u003c ZSTD_f_zstd1_magicless);\n            return bounds;\n        case ZSTD_d_stableOutBuffer:\n            bounds.lowerBound = (int)ZSTD_bm_buffered;\n            bounds.upperBound = (int)ZSTD_bm_stable;\n            return bounds;\n        case ZSTD_d_forceIgnoreChecksum:\n            bounds.lowerBound = (int)ZSTD_d_validateChecksum;\n            bounds.upperBound = (int)ZSTD_d_ignoreChecksum;\n            return bounds;\n        case ZSTD_d_refMultipleDDicts:\n            bounds.lowerBound = (int)ZSTD_rmd_refSingleDDict;\n            bounds.upperBound = (int)ZSTD_rmd_refMultipleDDicts;\n            return bounds;\n        default:;\n    }\n    bounds.error = ERROR(parameter_unsupported);\n    return bounds;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1681,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2890128":{"score":0.76174307,"function_name":"ZSTD_DCtx_getParameter","code":"size_t ZSTD_DCtx_getParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int* value)\n{\n    switch (param) {\n        case ZSTD_d_windowLogMax:\n            *value = (int)ZSTD_highbit32((U32)dctx-\u003emaxWindowSize);\n            return 0;\n        case ZSTD_d_format:\n            *value = (int)dctx-\u003eformat;\n            return 0;\n        case ZSTD_d_stableOutBuffer:\n            *value = (int)dctx-\u003eoutBufferMode;\n            return 0;\n        case ZSTD_d_forceIgnoreChecksum:\n            *value = (int)dctx-\u003eforceIgnoreChecksum;\n            return 0;\n        case ZSTD_d_refMultipleDDicts:\n            *value = (int)dctx-\u003erefMultipleDDicts;\n            return 0;\n        default:;\n    }\n    RETURN_ERROR(parameter_unsupported, \"\");\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1728,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2890256":{"score":0.74757516,"function_name":"ZSTD_DCtx_setParameter","code":"size_t ZSTD_DCtx_setParameter(ZSTD_DCtx* dctx, ZSTD_dParameter dParam, int value)\n{\n    RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n    switch(dParam) {\n        case ZSTD_d_windowLogMax:\n            if (value == 0) value = ZSTD_WINDOWLOG_LIMIT_DEFAULT;\n            CHECK_DBOUNDS(ZSTD_d_windowLogMax, value);\n            dctx-\u003emaxWindowSize = ((size_t)1) \u003c\u003c value;\n            return 0;\n        case ZSTD_d_format:\n            CHECK_DBOUNDS(ZSTD_d_format, value);\n            dctx-\u003eformat = (ZSTD_format_e)value;\n            return 0;\n        case ZSTD_d_stableOutBuffer:\n            CHECK_DBOUNDS(ZSTD_d_stableOutBuffer, value);\n            dctx-\u003eoutBufferMode = (ZSTD_bufferMode_e)value;\n            return 0;\n        case ZSTD_d_forceIgnoreChecksum:\n            CHECK_DBOUNDS(ZSTD_d_forceIgnoreChecksum, value);\n            dctx-\u003eforceIgnoreChecksum = (ZSTD_forceIgnoreChecksum_e)value;\n            return 0;\n        case ZSTD_d_refMultipleDDicts:\n            CHECK_DBOUNDS(ZSTD_d_refMultipleDDicts, value);\n            if (dctx-\u003estaticSize != 0) {\n                RETURN_ERROR(parameter_unsupported, \"Static dctx does not support multiple DDicts!\");\n            }\n            dctx-\u003erefMultipleDDicts = (ZSTD_refMultipleDDicts_e)value;\n            return 0;\n        default:;\n    }\n    RETURN_ERROR(parameter_unsupported, \"\");\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1751,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2890496":{"score":0.8007987,"function_name":"ZSTD_DCtx_reset","code":"size_t ZSTD_DCtx_reset(ZSTD_DCtx* dctx, ZSTD_ResetDirective reset)\n{\n    if ( (reset == ZSTD_reset_session_only)\n      || (reset == ZSTD_reset_session_and_parameters) ) {\n        dctx-\u003estreamStage = zdss_init;\n        dctx-\u003enoForwardProgress = 0;\n    }\n    if ( (reset == ZSTD_reset_parameters)\n      || (reset == ZSTD_reset_session_and_parameters) ) {\n        RETURN_ERROR_IF(dctx-\u003estreamStage != zdss_init, stage_wrong, \"\");\n        ZSTD_clearDict(dctx);\n        ZSTD_DCtx_resetParameters(dctx);\n    }\n    return 0;\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":1784,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2890720":{"score":0.7730184,"function_name":"ZSTD_decodingBufferSize_min","code":"size_t ZSTD_decodingBufferSize_min(unsigned long long windowSize, unsigned long long frameContentSize)\n{\n    size_t const blockSize = (size_t) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);\n    unsigned long long const neededRBSize = windowSize + blockSize + (WILDCOPY_OVERLENGTH * 2);\n    unsigned long long const neededSize = MIN(frameContentSize, neededRBSize);\n    size_t const minRBSize = (size_t) neededSize;\n    if ((unsigned long long)minRBSize != neededSize) return ERROR(frameParameter_windowTooLarge);\n    return minRBSize;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2355,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2890784":{"score":0.78381073,"function_name":"readSkippableFrameSize","code":"static size_t readSkippableFrameSize(void const* src, size_t srcSize)\n{\n    size_t const skippableHeaderSize = ZSTD_SKIPPABLEHEADERSIZE;\n    U32 sizeU32;\n\n    RETURN_ERROR_IF(srcSize \u003c ZSTD_SKIPPABLEHEADERSIZE, srcSize_wrong, \"\");\n\n    sizeU32 = MEM_readLE32((BYTE const*)src + ZSTD_FRAMEIDSIZE);\n    RETURN_ERROR_IF((U32)(sizeU32 + ZSTD_SKIPPABLEHEADERSIZE) \u003c sizeU32,\n                    frameParameter_unsupported, \"\");\n    {\n        size_t const skippableSize = skippableHeaderSize + sizeU32;\n        RETURN_ERROR_IF(skippableSize \u003e srcSize, srcSize_wrong, \"\");\n        return skippableSize;\n    }\n}","filepath":"server/external/zstd/decompress/zstd_decompress.c","line_number":542,"entry_url":"https://github.com/dfeneyrou/palanteer.git","slot_name":"v0.2"},"2894256":{"score":0.8051419,"function_name":"ZSTD_decompress_generic_simpleArgs","code":"size_t ZSTD_decompress_generic_simpleArgs (\n                            ZSTD_DCtx* dctx,\n                            void* dst, size_t dstCapacity, size_t* dstPos,\n                      const void* src, size_t srcSize, size_t* srcPos)\n{\n    ZSTD_outBuffer output = { dst, dstCapacity, *dstPos };\n    ZSTD_inBuffer  input  = { src, srcSize, *srcPos };\n    /* ZSTD_compress_generic() will check validity of dstPos and srcPos */\n    size_t const cErr = ZSTD_decompress_generic(dctx, \u0026output, \u0026input);\n    *dstPos = output.pos;\n    *srcPos = input.pos;\n    return cErr;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2636,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2913344":{"score":0.7646328,"function_name":"ZSTD_decompressSequences","code":"static size_t ZSTD_decompressSequences(\n                               ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize,\n                         const ZSTD_longOffset_e isLongOffset)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE* const)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx-\u003elitPtr;\n    const BYTE* const litEnd = litPtr + dctx-\u003elitSize;\n    const BYTE* const base = (const BYTE*) (dctx-\u003ebase);\n    const BYTE* const vBase = (const BYTE*) (dctx-\u003evBase);\n    const BYTE* const dictEnd = (const BYTE*) (dctx-\u003edictEnd);\n    int nbSeq;\n    DEBUGLOG(5, \"ZSTD_decompressSequences\");\n\n    /* Build Decoding Tables */\n    {   size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, \u0026nbSeq, ip, seqSize);\n        DEBUGLOG(5, \"ZSTD_decodeSeqHeaders: size=%u, nbSeq=%i\",\n                    (U32)seqHSize, nbSeq);\n        if (ZSTD_isError(seqHSize)) return seqHSize;\n        ip += seqHSize;\n    }\n\n    /* Regen sequences */\n    if (nbSeq) {\n        seqState_t seqState;\n        dctx-\u003efseEntropy = 1;\n        { U32 i; for (i=0; i\u003cZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx-\u003eentropy.rep[i]; }\n        CHECK_E(BIT_initDStream(\u0026seqState.DStream, ip, iend-ip), corruption_detected);\n        FSE_initDState(\u0026seqState.stateLL, \u0026seqState.DStream, dctx-\u003eLLTptr);\n        FSE_initDState(\u0026seqState.stateOffb, \u0026seqState.DStream, dctx-\u003eOFTptr);\n        FSE_initDState(\u0026seqState.stateML, \u0026seqState.DStream, dctx-\u003eMLTptr);\n\n        for ( ; (BIT_reloadDStream(\u0026(seqState.DStream)) \u003c= BIT_DStream_completed) \u0026\u0026 nbSeq ; ) {\n            nbSeq--;\n            {   seq_t const sequence = ZSTD_decodeSequence(\u0026seqState, isLongOffset);\n                size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, \u0026litPtr, litEnd, base, vBase, dictEnd);\n                DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n                op += oneSeqSize;\n        }   }\n\n        /* check if reached exact end */\n        DEBUGLOG(5, \"after decode loop, remaining nbSeq : %i\", nbSeq);\n        if (nbSeq) return ERROR(corruption_detected);\n        /* save reps for next block */\n        { U32 i; for (i=0; i\u003cZSTD_REP_NUM; i++) dctx-\u003eentropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n    /* last literal segment */\n    {   size_t const lastLLSize = litEnd - litPtr;\n        if (lastLLSize \u003e (size_t)(oend-op)) return ERROR(dstSize_tooSmall);\n        memcpy(op, litPtr, lastLLSize);\n        op += lastLLSize;\n    }\n\n    return op-ostart;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":1076,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2935712":{"score":0.8654156,"function_name":"ZSTD_getcBlockSize","code":"size_t ZSTD_getcBlockSize(const void* src, size_t srcSize,\n                          blockProperties_t* bpPtr)\n{\n    if (srcSize \u003c ZSTD_blockHeaderSize) return ERROR(srcSize_wrong);\n    {   U32 const cBlockHeader = MEM_readLE24(src);\n        U32 const cSize = cBlockHeader \u003e\u003e 3;\n        bpPtr-\u003elastBlock = cBlockHeader \u0026 1;\n        bpPtr-\u003eblockType = (blockType_e)((cBlockHeader \u003e\u003e 1) \u0026 3);\n        bpPtr-\u003eorigSize = cSize;   /* only useful for RLE */\n        if (bpPtr-\u003eblockType == bt_rle) return 1;\n        if (bpPtr-\u003eblockType == bt_reserved) return ERROR(corruption_detected);\n        return cSize;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":485,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2942368":{"score":0.809091,"function_name":"ZSTD_copyDDictParameters","code":"void ZSTD_copyDDictParameters(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)\n{\n    DEBUGLOG(4, \"ZSTD_copyDDictParameters\");\n    assert(dctx != NULL);\n    assert(ddict != NULL);\n    dctx-\u003edictID = ddict-\u003edictID;\n    dctx-\u003eprefixStart = ddict-\u003edictContent;\n    dctx-\u003evirtualStart = ddict-\u003edictContent;\n    dctx-\u003edictEnd = (const BYTE*)ddict-\u003edictContent + ddict-\u003edictSize;\n    dctx-\u003epreviousDstEnd = dctx-\u003edictEnd;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    dctx-\u003edictContentBeginForFuzzing = dctx-\u003eprefixStart;\n    dctx-\u003edictContentEndForFuzzing = dctx-\u003epreviousDstEnd;\n#endif\n    if (ddict-\u003eentropyPresent) {\n        dctx-\u003elitEntropy = 1;\n        dctx-\u003efseEntropy = 1;\n        dctx-\u003eLLTptr = ddict-\u003eentropy.LLTable;\n        dctx-\u003eMLTptr = ddict-\u003eentropy.MLTable;\n        dctx-\u003eOFTptr = ddict-\u003eentropy.OFTable;\n        dctx-\u003eHUFptr = ddict-\u003eentropy.hufTable;\n        dctx-\u003eentropy.rep[0] = ddict-\u003eentropy.rep[0];\n        dctx-\u003eentropy.rep[1] = ddict-\u003eentropy.rep[1];\n        dctx-\u003eentropy.rep[2] = ddict-\u003eentropy.rep[2];\n    } else {\n        dctx-\u003elitEntropy = 0;\n        dctx-\u003efseEntropy = 0;\n    }\n}","filepath":"src/zstd/zstd_ddict.c","line_number":53,"entry_url":"https://github.com/maharmstone/btrfs.git","slot_name":"v1.7.8"},"2943952":{"score":0.74166083,"function_name":"ZSTD_initStaticDDict","code":"const ZSTD_DDict* ZSTD_initStaticDDict(\n                                void* sBuffer, size_t sBufferSize,\n                                const void* dict, size_t dictSize,\n                                ZSTD_dictLoadMethod_e dictLoadMethod,\n                                ZSTD_dictContentType_e dictContentType)\n{\n    size_t const neededSpace = sizeof(ZSTD_DDict)\n                             + (dictLoadMethod == ZSTD_dlm_byRef ? 0 : dictSize);\n    ZSTD_DDict* const ddict = (ZSTD_DDict*)sBuffer;\n    assert(sBuffer != NULL);\n    assert(dict != NULL);\n    if ((size_t)sBuffer \u0026 7) return NULL;   /* 8-aligned */\n    if (sBufferSize \u003c neededSpace) return NULL;\n    if (dictLoadMethod == ZSTD_dlm_byCopy) {\n        ZSTD_memcpy(ddict+1, dict, dictSize);  /* local copy */\n        dict = ddict+1;\n    }\n    if (ZSTD_isError( ZSTD_initDDict_internal(ddict,\n                                              dict, dictSize,\n                                              ZSTD_dlm_byRef, dictContentType) ))\n        return NULL;\n    return ddict;\n}","filepath":"src/zstd/zstd_ddict.c","line_number":182,"entry_url":"https://github.com/maharmstone/btrfs.git","slot_name":"v1.7.8"},"2944224":{"score":0.83670485,"function_name":"ZSTD_freeDDict","code":"size_t ZSTD_freeDDict(ZSTD_DDict* ddict)\n{\n    if (ddict==NULL) return 0;   /* support free on NULL */\n    {   ZSTD_customMem const cMem = ddict-\u003ecMem;\n        ZSTD_free(ddict-\u003edictBuffer, cMem);\n        ZSTD_free(ddict, cMem);\n        return 0;\n    }\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":2161,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2944336":{"score":0.63779885,"function_name":"ZSTD_startingInputLength","code":"static size_t ZSTD_startingInputLength(ZSTD_format_e format)\n{\n    size_t const startingInputLength = (format==ZSTD_f_zstd1_magicless) ?\n                    ZSTD_frameHeaderSize_prefix - ZSTD_frameIdSize :\n                    ZSTD_frameHeaderSize_prefix;\n    ZSTD_STATIC_ASSERT(ZSTD_FRAMEHEADERSIZE_PREFIX \u003e= ZSTD_FRAMEIDSIZE);\n    /* only supports formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless */\n    assert( (format == ZSTD_f_zstd1) || (format == ZSTD_f_zstd1_magicless) );\n    return startingInputLength;\n}","filepath":"lib/decompress/zstd_decompress.c","line_number":154,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.2"},"2944416":{"score":0.6001501,"function_name":"ZSTD_freeDDict","code":"size_t ZSTD_freeDDict(ZSTD_DDict* ddict)\n{\n    if (ddict==NULL) return 0;   /* support free on NULL */\n    {   ZSTD_customMem const cMem = ddict-\u003ecMem;\n        ZSTD_customFree(ddict-\u003edictBuffer, cMem);\n        ZSTD_customFree(ddict, cMem);\n        return 0;\n    }\n}","filepath":"src/zstd/zstd_ddict.c","line_number":207,"entry_url":"https://github.com/maharmstone/btrfs.git","slot_name":"v1.7.8"},"2944448":{"score":0.74115324,"function_name":"FSE_compress_usingCTable_generic","code":"static size_t FSE_compress_usingCTable_generic (void* dst, size_t dstSize,\n                           const void* src, size_t srcSize,\n                           const FSE_CTable* ct, const unsigned fast)\n{\n    const BYTE* const istart = (const BYTE*) src;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* ip=iend;\n    BIT_CStream_t bitC;\n    FSE_CState_t CState1, CState2;\n\n    /* init */\n    if (srcSize \u003c= 2) return 0;\n    { size_t const errorCode = BIT_initCStream(\u0026bitC, dst, dstSize);\n      if (FSE_isError(errorCode)) return 0; }\n\n#define FSE_FLUSHBITS(s)  (fast ? BIT_flushBitsFast(s) : BIT_flushBits(s))\n\n    if (srcSize \u0026 1) {\n        FSE_initCState2(\u0026CState1, ct, *--ip);\n        FSE_initCState2(\u0026CState2, ct, *--ip);\n        FSE_encodeSymbol(\u0026bitC, \u0026CState1, *--ip);\n        FSE_FLUSHBITS(\u0026bitC);\n    } else {\n        FSE_initCState2(\u0026CState2, ct, *--ip);\n        FSE_initCState2(\u0026CState1, ct, *--ip);\n    }\n\n    /* join to mod 4 */\n    srcSize -= 2;\n    if ((sizeof(bitC.bitContainer)*8 \u003e FSE_MAX_TABLELOG*4+7 ) \u0026\u0026 (srcSize \u0026 2)) {  /* test bit 2 */\n        FSE_encodeSymbol(\u0026bitC, \u0026CState2, *--ip);\n        FSE_encodeSymbol(\u0026bitC, \u0026CState1, *--ip);\n        FSE_FLUSHBITS(\u0026bitC);\n    }\n\n    /* 2 or 4 encoding per loop */\n    for ( ; ip\u003eistart ; ) {\n        FSE_encodeSymbol(\u0026bitC, \u0026CState2, *--ip);\n\n        if (sizeof(bitC.bitContainer)*8 \u003c FSE_MAX_TABLELOG*2+7 )   /* this test must be static */\n            FSE_FLUSHBITS(\u0026bitC);\n\n        FSE_encodeSymbol(\u0026bitC, \u0026CState1, *--ip);\n\n        if (sizeof(bitC.bitContainer)*8 \u003e FSE_MAX_TABLELOG*4+7 ) {  /* this test must be static */\n            FSE_encodeSymbol(\u0026bitC, \u0026CState2, *--ip);\n            FSE_encodeSymbol(\u0026bitC, \u0026CState1, *--ip);\n        }\n\n        FSE_FLUSHBITS(\u0026bitC);\n    }\n\n    FSE_flushCState(\u0026bitC, \u0026CState2);\n    FSE_flushCState(\u0026bitC, \u0026CState1);\n    return BIT_closeCStream(\u0026bitC);\n}","filepath":"lib/fse.c","line_number":874,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.6.0"},"2946704":{"score":0.82092786,"function_name":"FSE_writeNCount","code":"size_t FSE_writeNCount (void* buffer, size_t bufferSize, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)\n{\n    if (tableLog \u003e FSE_MAX_TABLELOG) return (size_t)-FSE_ERROR_GENERIC;   /* Unsupported */\n    if (tableLog \u003c FSE_MIN_TABLELOG) return (size_t)-FSE_ERROR_GENERIC;   /* Unsupported */\n\n    if (bufferSize \u003c FSE_NCountWriteBound(maxSymbolValue, tableLog))\n        return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);\n\n    return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 1);\n}","filepath":"lib/fse.c","line_number":807,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2947728":{"score":0.61373335,"function_name":"FSE_sizeof_CTable","code":"size_t FSE_sizeof_CTable (unsigned maxSymbolValue, unsigned tableLog)\n{\n    size_t size;\n    FSE_STATIC_ASSERT((size_t)FSE_CTABLE_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)*4 \u003e= sizeof(CTable_max_t));   /* A compilation error here means FSE_CTABLE_SIZE_U32 is not large enough */\n    if (tableLog \u003e FSE_MAX_TABLELOG) return (size_t)-FSE_ERROR_GENERIC;\n    size = FSE_CTABLE_SIZE_U32 (tableLog, maxSymbolValue) * sizeof(U32);\n    return size;\n}","filepath":"lib/fse.c","line_number":944,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2947872":{"score":0.86009175,"function_name":"FSE_optimalTableLog","code":"unsigned FSE_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue)\n{\n    U32 maxBitsSrc = FSE_highbit32((U32)(srcSize - 1)) - 2;\n    U32 tableLog = maxTableLog;\n    U32 minBits = FSE_minTableLog(srcSize, maxSymbolValue);\n    if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;\n    if (maxBitsSrc \u003c tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */\n    if (minBits \u003e tableLog) tableLog = minBits;   /* Need a minimum to safely represent all symbol values */\n    if (tableLog \u003c FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;\n    if (tableLog \u003e FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;\n    return tableLog;\n}","filepath":"lib/fse.c","line_number":976,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2948864":{"score":0.8409971,"function_name":"FSE_compress2","code":"size_t FSE_compress2 (void* dst, size_t dstSize, const void* src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog)\n{\n    const BYTE* const istart = (const BYTE*) src;\n    const BYTE* ip = istart;\n\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* op = ostart;\n    BYTE* const oend = ostart + dstSize;\n\n    U32   count[FSE_MAX_SYMBOL_VALUE+1];\n    S16   norm[FSE_MAX_SYMBOL_VALUE+1];\n    CTable_max_t ct;\n    size_t errorCode;\n\n    /* init conditions */\n    if (srcSize \u003c= 1) return 0;  /* Uncompressible */\n    if (!maxSymbolValue) maxSymbolValue = FSE_MAX_SYMBOL_VALUE;\n    if (!tableLog) tableLog = FSE_DEFAULT_TABLELOG;\n\n    /* Scan input and build symbol stats */\n    errorCode = FSE_count (count, \u0026maxSymbolValue, ip, srcSize);\n    if (FSE_isError(errorCode)) return errorCode;\n    if (errorCode == srcSize) return 1;\n    if (errorCode == 1) return 0;   /* each symbol only present once */\n    if (errorCode \u003c (srcSize \u003e\u003e 7)) return 0;   /* Heuristic : not compressible enough */\n\n    tableLog = FSE_optimalTableLog(tableLog, srcSize, maxSymbolValue);\n    errorCode = FSE_normalizeCount (norm, tableLog, count, srcSize, maxSymbolValue);\n    if (FSE_isError(errorCode)) return errorCode;\n\n    /* Write table description header */\n    errorCode = FSE_writeNCount (op, oend-op, norm, maxSymbolValue, tableLog);\n    if (FSE_isError(errorCode)) return errorCode;\n    op += errorCode;\n\n    /* Compress */\n    errorCode = FSE_buildCTable (ct, norm, maxSymbolValue, tableLog);\n    if (FSE_isError(errorCode)) return errorCode;\n    errorCode = FSE_compress_usingCTable(op, oend - op, ip, srcSize, ct);\n    if (errorCode == 0) return 0;   /* not enough space for compressed data */\n    op += errorCode;\n\n    /* check compressibility */\n    if ( (size_t)(op-ostart) \u003e= srcSize-1 )\n        return 0;\n\n    return op-ostart;\n}","filepath":"lib/fse.c","line_number":1378,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2949520":{"score":0.8932221,"function_name":"FSE_buildCTable_raw","code":"size_t FSE_buildCTable_raw (FSE_CTable* ct, unsigned nbBits)\n{\n    const unsigned tableSize = 1 \u003c\u003c nbBits;\n    const unsigned tableMask = tableSize - 1;\n    const unsigned maxSymbolValue = tableMask;\n    void* const ptr = ct;\n    U16* const tableU16 = ( (U16*) ptr) + 2;\n    void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableSize\u003e\u003e1);   /* assumption : tableLog \u003e= 1 */\n    FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);\n    unsigned s;\n\n    /* Sanity checks */\n    if (nbBits \u003c 1) return ERROR(GENERIC);             /* min size */\n\n    /* header */\n    tableU16[-2] = (U16) nbBits;\n    tableU16[-1] = (U16) maxSymbolValue;\n\n    /* Build table */\n    for (s=0; s\u003ctableSize; s++)\n        tableU16[s] = (U16)(tableSize + s);\n\n    /* Build Symbol Transformation Table */\n    {   const U32 deltaNbBits = (nbBits \u003c\u003c 16) - (1 \u003c\u003c nbBits);\n        for (s=0; s\u003c=maxSymbolValue; s++) {\n            symbolTT[s].deltaNbBits = deltaNbBits;\n            symbolTT[s].deltaFindState = s-1;\n    }   }\n\n    return 0;\n}","filepath":"lib/fse.c","line_number":818,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.6.0"},"2949888":{"score":0.86678815,"function_name":"FSE_buildCTable_rle","code":"size_t FSE_buildCTable_rle (FSE_CTable* ct, BYTE symbolValue)\n{\n    U16* tableU16 = ( (U16*) ct) + 2;\n    FSE_symbolCompressionTransform* symbolTT = (FSE_symbolCompressionTransform*) ((U32*)ct + 2);\n\n    /* header */\n    tableU16[-2] = (U16) 0;\n    tableU16[-1] = (U16) symbolValue;\n\n    /* Build table */\n    tableU16[0] = 0;\n    tableU16[1] = 0;   /* just in case */\n\n    /* Build Symbol Transformation Table */\n    {\n        symbolTT[symbolValue].deltaNbBits = 0;\n        symbolTT[symbolValue].deltaFindState = 0;\n    }\n\n    return 0;\n}","filepath":"lib/fse.c","line_number":1193,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2949936":{"score":0.6569332,"function_name":"FSE_compress_usingCTable","code":"size_t FSE_compress_usingCTable (void* dst, size_t dstSize,\n                           const void* src, size_t srcSize,\n                           const FSE_CTable* ct)\n{\n    const unsigned fast = (dstSize \u003e= FSE_BLOCKBOUND(srcSize));\n\n    if (fast)\n        return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 1);\n    else\n        return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 0);\n}","filepath":"lib/fse.c","line_number":1363,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2958112":{"score":0.8951032,"function_name":"FSE_buildDTable_rle","code":"size_t FSE_buildDTable_rle (FSE_DTable* dt, BYTE symbolValue)\n{\n    FSE_DTableHeader* const DTableH = (FSE_DTableHeader*)dt;\n    FSE_decode_t* const cell = (FSE_decode_t*)(dt + 1);   /* because dt is unsigned */\n\n    DTableH-\u003etableLog = 0;\n    DTableH-\u003efastMode = 0;\n\n    cell-\u003enewState = 0;\n    cell-\u003esymbol = symbolValue;\n    cell-\u003enbBits = 0;\n\n    return 0;\n}","filepath":"lib/fse.c","line_number":1436,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2958144":{"score":0.82713926,"function_name":"FSE_buildDTable_raw","code":"size_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits)\n{\n    void* ptr = dt;\n    FSE_DTableHeader* const DTableH = (FSE_DTableHeader*)ptr;\n    void* dPtr = dt + 1;\n    FSE_decode_t* const dinfo = (FSE_decode_t*)dPtr;\n    const unsigned tableSize = 1 \u003c\u003c nbBits;\n    const unsigned tableMask = tableSize - 1;\n    const unsigned maxSymbolValue = tableMask;\n    unsigned s;\n\n    /* Sanity checks */\n    if (nbBits \u003c 1) return ERROR(GENERIC);         /* min size */\n\n    /* Build Decoding Table */\n    DTableH-\u003etableLog = (U16)nbBits;\n    DTableH-\u003efastMode = 1;\n    for (s=0; s\u003c=maxSymbolValue; s++) {\n        dinfo[s].newState = 0;\n        dinfo[s].symbol = (BYTE)s;\n        dinfo[s].nbBits = (BYTE)nbBits;\n    }\n\n    return 0;\n}","filepath":"lib/fse.c","line_number":1022,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.6.0"},"2958240":{"score":0.77975094,"function_name":"FSE_decompress_usingDTable","code":"size_t FSE_decompress_usingDTable(void* dst, size_t originalSize,\n                            const void* cSrc, size_t cSrcSize,\n                            const FSE_DTable* dt)\n{\n    const FSE_DTableHeader* DTableH = (const FSE_DTableHeader*)dt;\n    const U32 fastMode = DTableH-\u003efastMode;\n\n    /* select fast mode (static) */\n    if (fastMode) return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 1);\n    return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 0);\n}","filepath":"lib/fse.c","line_number":1717,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"2961312":{"score":0.751997,"function_name":"HUF_decompress4X1_usingDTable_internal","code":"HUF_DGEN(HUF_decompress1X1_usingDTable_internal)\n\nstatic size_t HUF_decompress4X1_usingDTable_internal(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable, int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n# if ZSTD_ENABLE_ASM_X86_64_BMI2\n        return HUF_decompress4X1_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n# else\n        return HUF_decompress4X1_usingDTable_internal_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);\n# endif\n    }\n#else\n    (void)bmi2;\n#endif\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2 \u0026\u0026 defined(__BMI2__)\n    return HUF_decompress4X1_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n#else\n    return HUF_decompress4X1_usingDTable_internal_default(dst, dstSize, cSrc, cSrcSize, DTable);\n#endif\n}","filepath":"lib/decompress/huf_decompress.c","line_number":728,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2985360":{"score":0.82100147,"function_name":"HUF_decompress4X2_usingDTable_internal","code":"static size_t HUF_decompress4X2_usingDTable_internal(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable, int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n# if ZSTD_ENABLE_ASM_X86_64_BMI2\n        return HUF_decompress4X2_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n# else\n        return HUF_decompress4X2_usingDTable_internal_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);\n# endif\n    }\n#else\n    (void)bmi2;\n#endif\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2 \u0026\u0026 defined(__BMI2__)\n    return HUF_decompress4X2_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n#else\n    return HUF_decompress4X2_usingDTable_internal_default(dst, dstSize, cSrc, cSrcSize, DTable);\n#endif\n}","filepath":"lib/decompress/huf_decompress.c","line_number":1435,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"2988848":{"score":0.7783237,"function_name":"HUF_DecompressAsmArgs_init","code":"static size_t HUF_DecompressAsmArgs_init(HUF_DecompressAsmArgs* args, void* dst, size_t dstSize, void const* src, size_t srcSize, const HUF_DTable* DTable)\n{\n    void const* dt = DTable + 1;\n    U32 const dtLog = HUF_getDTableDesc(DTable).tableLog;\n\n    const BYTE* const ilimit = (const BYTE*)src + 6 + 8;\n\n    BYTE* const oend = (BYTE*)dst + dstSize;\n\n    /* The following condition is false on x32 platform,\n     * but HUF_asm is not compatible with this ABI */\n    if (!(MEM_isLittleEndian() \u0026\u0026 !MEM_32bits())) return 1;\n\n    /* strict minimum : jump table + 1 byte per stream */\n    if (srcSize \u003c 10)\n        return ERROR(corruption_detected);\n\n    /* Must have at least 8 bytes per stream because we don't handle initializing smaller bit containers.\n     * If table log is not correct at this point, fallback to the old decoder.\n     * On small inputs we don't have enough data to trigger the fast loop, so use the old decoder.\n     */\n    if (dtLog != HUF_DECODER_FAST_TABLELOG)\n        return 1;\n\n    /* Read the jump table. */\n    {\n        const BYTE* const istart = (const BYTE*)src;\n        size_t const length1 = MEM_readLE16(istart);\n        size_t const length2 = MEM_readLE16(istart+2);\n        size_t const length3 = MEM_readLE16(istart+4);\n        size_t const length4 = srcSize - (length1 + length2 + length3 + 6);\n        args-\u003eiend[0] = istart + 6;  /* jumpTable */\n        args-\u003eiend[1] = args-\u003eiend[0] + length1;\n        args-\u003eiend[2] = args-\u003eiend[1] + length2;\n        args-\u003eiend[3] = args-\u003eiend[2] + length3;\n\n        /* HUF_initDStream() requires this, and this small of an input\n         * won't benefit from the ASM loop anyways.\n         * length1 must be \u003e= 16 so that ip[0] \u003e= ilimit before the loop\n         * starts.\n         */\n        if (length1 \u003c 16 || length2 \u003c 8 || length3 \u003c 8 || length4 \u003c 8)\n            return 1;\n        if (length4 \u003e srcSize) return ERROR(corruption_detected);   /* overflow */\n    }\n    /* ip[] contains the position that is currently loaded into bits[]. */\n    args-\u003eip[0] = args-\u003eiend[1] - sizeof(U64);\n    args-\u003eip[1] = args-\u003eiend[2] - sizeof(U64);\n    args-\u003eip[2] = args-\u003eiend[3] - sizeof(U64);\n    args-\u003eip[3] = (BYTE const*)src + srcSize - sizeof(U64);\n\n    /* op[] contains the output pointers. */\n    args-\u003eop[0] = (BYTE*)dst;\n    args-\u003eop[1] = args-\u003eop[0] + (dstSize+3)/4;\n    args-\u003eop[2] = args-\u003eop[1] + (dstSize+3)/4;\n    args-\u003eop[3] = args-\u003eop[2] + (dstSize+3)/4;\n\n    /* No point to call the ASM loop for tiny outputs. */\n    if (args-\u003eop[3] \u003e= oend)\n        return 1;\n\n    /* bits[] is the bit container.\n        * It is read from the MSB down to the LSB.\n        * It is shifted left as it is read, and zeros are\n        * shifted in. After the lowest valid bit a 1 is\n        * set, so that CountTrailingZeros(bits[]) can be used\n        * to count how many bits we've consumed.\n        */\n    args-\u003ebits[0] = HUF_initDStream(args-\u003eip[0]);\n    args-\u003ebits[1] = HUF_initDStream(args-\u003eip[1]);\n    args-\u003ebits[2] = HUF_initDStream(args-\u003eip[2]);\n    args-\u003ebits[3] = HUF_initDStream(args-\u003eip[3]);\n\n    /* If ip[] \u003e= ilimit, it is guaranteed to be safe to\n        * reload bits[]. It may be beyond its section, but is\n        * guaranteed to be valid (\u003e= istart).\n        */\n    args-\u003eilimit = ilimit;\n\n    args-\u003eoend = oend;\n    args-\u003edt = dt;\n\n    return 0;\n}","filepath":"lib/decompress/huf_decompress.c","line_number":166,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3015952":{"score":0.66522217,"function_name":"HUF_decompress4X2_usingDTable_internal_bmi2_asm","code":"static HUF_ASM_X86_64_BMI2_ATTRS size_t\nHUF_decompress4X2_usingDTable_internal_bmi2_asm(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable) {\n    void const* dt = DTable + 1;\n    const BYTE* const iend = (const BYTE*)cSrc + 6;\n    BYTE* const oend = (BYTE*)dst + dstSize;\n    HUF_DecompressAsmArgs args;\n    {\n        size_t const ret = HUF_DecompressAsmArgs_init(\u0026args, dst, dstSize, cSrc, cSrcSize, DTable);\n        FORWARD_IF_ERROR(ret, \"Failed to init asm args\");\n        if (ret != 0)\n            return HUF_decompress4X2_usingDTable_internal_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);\n    }\n\n    assert(args.ip[0] \u003e= args.ilimit);\n    HUF_decompress4X2_usingDTable_internal_bmi2_asm_loop(\u0026args);\n\n    /* note : op4 already verified within main loop */\n    assert(args.ip[0] \u003e= iend);\n    assert(args.ip[1] \u003e= iend);\n    assert(args.ip[2] \u003e= iend);\n    assert(args.ip[3] \u003e= iend);\n    assert(args.op[3] \u003c= oend);\n    (void)iend;\n\n    /* finish bitStreams one by one */\n    {\n        size_t const segmentSize = (dstSize+3) / 4;\n        BYTE* segmentEnd = (BYTE*)dst;\n        int i;\n        for (i = 0; i \u003c 4; ++i) {\n            BIT_DStream_t bit;\n            if (segmentSize \u003c= (size_t)(oend - segmentEnd))\n                segmentEnd += segmentSize;\n            else\n                segmentEnd = oend;\n            FORWARD_IF_ERROR(HUF_initRemainingDStream(\u0026bit, \u0026args, i, segmentEnd), \"corruption\");\n            args.op[i] += HUF_decodeStreamX2(args.op[i], \u0026bit, segmentEnd, (HUF_DEltX2 const*)dt, HUF_DECODER_FAST_TABLELOG);\n            if (args.op[i] != segmentEnd)\n                return ERROR(corruption_detected);\n        }\n    }\n\n    /* decoded size */\n    return dstSize;\n}","filepath":"lib/decompress/huf_decompress.c","line_number":1385,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3026496":{"score":0.76834005,"function_name":"FSE_readNCount","code":"size_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,\n                 const void* headerBuffer, size_t hbSize)\n{\n    const BYTE* const istart = (const BYTE*) headerBuffer;\n    const BYTE* const iend = istart + hbSize;\n    const BYTE* ip = istart;\n    int nbBits;\n    int remaining;\n    int threshold;\n    U32 bitStream;\n    int bitCount;\n    unsigned charnum = 0;\n    int previous0 = 0;\n\n    if (hbSize \u003c 4) return (size_t)-FSE_ERROR_srcSize_wrong;\n    bitStream = FSE_readLE32(ip);\n    nbBits = (bitStream \u0026 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */\n    if (nbBits \u003e FSE_TABLELOG_ABSOLUTE_MAX) return (size_t)-FSE_ERROR_tableLog_tooLarge;\n    bitStream \u003e\u003e= 4;\n    bitCount = 4;\n    *tableLogPtr = nbBits;\n    remaining = (1\u003c\u003cnbBits)+1;\n    threshold = 1\u003c\u003cnbBits;\n    nbBits++;\n\n    while ((remaining\u003e1) \u0026\u0026 (charnum\u003c=*maxSVPtr))\n    {\n        if (previous0)\n        {\n            unsigned n0 = charnum;\n            while ((bitStream \u0026 0xFFFF) == 0xFFFF)\n            {\n                n0+=24;\n                if (ip \u003c iend-5)\n                {\n                    ip+=2;\n                    bitStream = FSE_readLE32(ip) \u003e\u003e bitCount;\n                }\n                else\n                {\n                    bitStream \u003e\u003e= 16;\n                    bitCount+=16;\n                }\n            }\n            while ((bitStream \u0026 3) == 3)\n            {\n                n0+=3;\n                bitStream\u003e\u003e=2;\n                bitCount+=2;\n            }\n            n0 += bitStream \u0026 3;\n            bitCount += 2;\n            if (n0 \u003e *maxSVPtr) return (size_t)-FSE_ERROR_maxSymbolValue_tooSmall;\n            while (charnum \u003c n0) normalizedCounter[charnum++] = 0;\n            if ((ip \u003c= iend-7) || (ip + (bitCount\u003e\u003e3) \u003c= iend-4))\n            {\n                ip += bitCount\u003e\u003e3;\n                bitCount \u0026= 7;\n                bitStream = FSE_readLE32(ip) \u003e\u003e bitCount;\n            }\n            else\n                bitStream \u003e\u003e= 2;\n        }\n        {\n            const short max = (short)((2*threshold-1)-remaining);\n            short count;\n\n            if ((bitStream \u0026 (threshold-1)) \u003c (U32)max)\n            {\n                count = (short)(bitStream \u0026 (threshold-1));\n                bitCount   += nbBits-1;\n            }\n            else\n            {\n                count = (short)(bitStream \u0026 (2*threshold-1));\n                if (count \u003e= threshold) count -= max;\n                bitCount   += nbBits;\n            }\n\n            count--;   /* extra accuracy */\n            remaining -= FSE_abs(count);\n            normalizedCounter[charnum++] = count;\n            previous0 = !count;\n            while (remaining \u003c threshold)\n            {\n                nbBits--;\n                threshold \u003e\u003e= 1;\n            }\n\n            {\n                if ((ip \u003c= iend-7) || (ip + (bitCount\u003e\u003e3) \u003c= iend-4))\n                {\n                    ip += bitCount\u003e\u003e3;\n                    bitCount \u0026= 7;\n                }\n                else\n                {\n                    bitCount -= (int)(8 * (iend - 4 - ip));\n                    ip = iend - 4;\n                }\n                bitStream = FSE_readLE32(ip) \u003e\u003e (bitCount \u0026 31);\n            }\n        }\n    }\n    if (remaining != 1) return (size_t)-FSE_ERROR_GENERIC;\n    *maxSVPtr = charnum-1;\n\n    ip += (bitCount+7)\u003e\u003e3;\n    if ((size_t)(ip-istart) \u003e hbSize) return (size_t)-FSE_ERROR_srcSize_wrong;\n    return ip-istart;\n}","filepath":"lib/fse.c","line_number":819,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"3035984":{"score":0.6982127,"function_name":"FSE_decompress","code":"size_t FSE_decompress(void* dst, size_t maxDstSize, const void* cSrc, size_t cSrcSize)\n{\n    const BYTE* const istart = (const BYTE*)cSrc;\n    const BYTE* ip = istart;\n    short counting[FSE_MAX_SYMBOL_VALUE+1];\n    DTable_max_t dt;   /* Static analyzer seems unable to understand this table will be properly initialized later */\n    unsigned tableLog;\n    unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;\n    size_t errorCode;\n\n    if (cSrcSize\u003c2) return (size_t)-FSE_ERROR_srcSize_wrong;   /* too small input size */\n\n    /* normal FSE decoding mode */\n    errorCode = FSE_readNCount (counting, \u0026maxSymbolValue, \u0026tableLog, istart, cSrcSize);\n    if (FSE_isError(errorCode)) return errorCode;\n    if (errorCode \u003e= cSrcSize) return (size_t)-FSE_ERROR_srcSize_wrong;   /* too small input size */\n    ip += errorCode;\n    cSrcSize -= errorCode;\n\n    errorCode = FSE_buildDTable (dt, counting, maxSymbolValue, tableLog);\n    if (FSE_isError(errorCode)) return errorCode;\n\n    /* always return, even if it is an error code */\n    return FSE_decompress_usingDTable (dst, maxDstSize, ip, cSrcSize, dt);\n}","filepath":"lib/fse.c","line_number":1730,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"zstd-0.1.2"},"3036192":{"score":0.8583782,"function_name":"HUF_decompress4X2_usingDTable","code":"size_t HUF_decompress4X2_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 0) return ERROR(GENERIC);\n    return HUF_decompress4X2_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":347,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3036224":{"score":0.87455225,"function_name":"HUF_decompress1X1_DCtx_wksp","code":"size_t HUF_decompress1X1_DCtx_wksp(HUF_DTable* DCtx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp(DCtx, cSrc, cSrcSize, workSpace, wkspSize);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize \u003e= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, DCtx, /* bmi2 */ 0);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":763,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3036336":{"score":0.8620658,"function_name":"HUF_decompress4X2_usingDTable","code":"size_t HUF_decompress4X2_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 0) return ERROR(GENERIC);\n    return HUF_decompress4X2_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":347,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3036368":{"score":0.8729146,"function_name":"HUF_decompress1X1_DCtx_wksp","code":"size_t HUF_decompress1X1_DCtx_wksp(HUF_DTable* DCtx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp(DCtx, cSrc, cSrcSize, workSpace, wkspSize);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize \u003e= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, DCtx, /* bmi2 */ 0);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":763,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3036480":{"score":0.68021256,"function_name":"HUF_readDTableX2_wksp_bmi2","code":"size_t HUF_readDTableX2_wksp_bmi2(HUF_DTable* DTable,\n                       const void* src, size_t srcSize,\n                             void* workSpace, size_t wkspSize, int bmi2)\n{\n    U32 tableLog, maxW, nbSymbols;\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    U32 maxTableLog = dtd.maxTableLog;\n    size_t iSize;\n    void* dtPtr = DTable+1;   /* force compiler to avoid strict-aliasing */\n    HUF_DEltX2* const dt = (HUF_DEltX2*)dtPtr;\n    U32 *rankStart;\n\n    HUF_ReadDTableX2_Workspace* const wksp = (HUF_ReadDTableX2_Workspace*)workSpace;\n\n    if (sizeof(*wksp) \u003e wkspSize) return ERROR(GENERIC);\n\n    rankStart = wksp-\u003erankStart0 + 1;\n    ZSTD_memset(wksp-\u003erankStats, 0, sizeof(wksp-\u003erankStats));\n    ZSTD_memset(wksp-\u003erankStart0, 0, sizeof(wksp-\u003erankStart0));\n\n    DEBUG_STATIC_ASSERT(sizeof(HUF_DEltX2) == sizeof(HUF_DTable));   /* if compiler fails here, assertion is wrong */\n    if (maxTableLog \u003e HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n    /* ZSTD_memset(weightList, 0, sizeof(weightList)); */  /* is not necessary, even though some analyzer complain ... */\n\n    iSize = HUF_readStats_wksp(wksp-\u003eweightList, HUF_SYMBOLVALUE_MAX + 1, wksp-\u003erankStats, \u0026nbSymbols, \u0026tableLog, src, srcSize, wksp-\u003ecalleeWksp, sizeof(wksp-\u003ecalleeWksp), bmi2);\n    if (HUF_isError(iSize)) return iSize;\n\n    /* check result */\n    if (tableLog \u003e maxTableLog) return ERROR(tableLog_tooLarge);   /* DTable can't fit code depth */\n    if (tableLog \u003c= HUF_DECODER_FAST_TABLELOG \u0026\u0026 maxTableLog \u003e HUF_DECODER_FAST_TABLELOG) maxTableLog = HUF_DECODER_FAST_TABLELOG;\n\n    /* find maxWeight */\n    for (maxW = tableLog; wksp-\u003erankStats[maxW]==0; maxW--) {}  /* necessarily finds a solution before 0 */\n\n    /* Get start index of each weight */\n    {   U32 w, nextRankStart = 0;\n        for (w=1; w\u003cmaxW+1; w++) {\n            U32 curr = nextRankStart;\n            nextRankStart += wksp-\u003erankStats[w];\n            rankStart[w] = curr;\n        }\n        rankStart[0] = nextRankStart;   /* put all 0w symbols at the end of sorted list*/\n        rankStart[maxW+1] = nextRankStart;\n    }\n\n    /* sort symbols by weight */\n    {   U32 s;\n        for (s=0; s\u003cnbSymbols; s++) {\n            U32 const w = wksp-\u003eweightList[s];\n            U32 const r = rankStart[w]++;\n            wksp-\u003esortedSymbol[r].symbol = (BYTE)s;\n        }\n        rankStart[0] = 0;   /* forget 0w symbols; this is beginning of weight(1) */\n    }\n\n    /* Build rankVal */\n    {   U32* const rankVal0 = wksp-\u003erankVal[0];\n        {   int const rescale = (maxTableLog-tableLog) - 1;   /* tableLog \u003c= maxTableLog */\n            U32 nextRankVal = 0;\n            U32 w;\n            for (w=1; w\u003cmaxW+1; w++) {\n                U32 curr = nextRankVal;\n                nextRankVal += wksp-\u003erankStats[w] \u003c\u003c (w+rescale);\n                rankVal0[w] = curr;\n        }   }\n        {   U32 const minBits = tableLog+1 - maxW;\n            U32 consumed;\n            for (consumed = minBits; consumed \u003c maxTableLog - minBits + 1; consumed++) {\n                U32* const rankValPtr = wksp-\u003erankVal[consumed];\n                U32 w;\n                for (w = 1; w \u003c maxW+1; w++) {\n                    rankValPtr[w] = rankVal0[w] \u003e\u003e consumed;\n    }   }   }   }\n\n    HUF_fillDTableX2(dt, maxTableLog,\n                   wksp-\u003esortedSymbol,\n                   wksp-\u003erankStart0, wksp-\u003erankVal, maxW,\n                   tableLog+1);\n\n    dtd.tableLog = (BYTE)maxTableLog;\n    dtd.tableType = 1;\n    ZSTD_memcpy(DTable, \u0026dtd, sizeof(dtd));\n    return iSize;\n}","filepath":"lib/decompress/huf_decompress.c","line_number":1052,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3048896":{"score":0.85633844,"function_name":"HUF_decompress4X4_usingDTable","code":"size_t HUF_decompress4X4_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 1) return ERROR(GENERIC);\n    return HUF_decompress4X4_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":813,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3048928":{"score":0.8757094,"function_name":"HUF_decompress1X1_DCtx_wksp","code":"size_t HUF_decompress1X1_DCtx_wksp(HUF_DTable* DCtx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp(DCtx, cSrc, cSrcSize, workSpace, wkspSize);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize \u003e= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, DCtx, /* bmi2 */ 0);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":763,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3049040":{"score":0.8579176,"function_name":"HUF_decompress4X4_usingDTable","code":"size_t HUF_decompress4X4_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 1) return ERROR(GENERIC);\n    return HUF_decompress4X4_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":813,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3049072":{"score":0.8740002,"function_name":"HUF_decompress1X1_DCtx_wksp","code":"size_t HUF_decompress1X1_DCtx_wksp(HUF_DTable* DCtx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp(DCtx, cSrc, cSrcSize, workSpace, wkspSize);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize \u003e= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, DCtx, /* bmi2 */ 0);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":763,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3049184":{"score":0.8210573,"function_name":"HUF_decompress4X_usingDTable","code":"size_t HUF_decompress4X_usingDTable(void* dst, size_t maxDstSize,\n                                    const void* cSrc, size_t cSrcSize,\n                                    const HUF_DTable* DTable)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n    return dtd.tableType ? HUF_decompress4X4_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable) :\n                           HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":868,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3049216":{"score":0.83632815,"function_name":"HUF_decompress4X_usingDTable","code":"size_t HUF_decompress4X_usingDTable(void* dst, size_t maxDstSize,\n                                    const void* cSrc, size_t cSrcSize,\n                                    const HUF_DTable* DTable)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n    return dtd.tableType ? HUF_decompress4X4_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable) :\n                           HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":868,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3049248":{"score":0.868157,"function_name":"HUF_selectDecoder","code":"U32 HUF_selectDecoder (size_t dstSize, size_t cSrcSize)\n{\n    /* decoder timing evaluation */\n    U32 const Q = cSrcSize \u003e= dstSize ? 15 : (U32)(cSrcSize * 16 / dstSize);   /* Q \u003c 16 */\n    U32 const D256 = (U32)(dstSize \u003e\u003e 8);\n    U32 const DTime0 = algoTime[Q][0].tableTime + (algoTime[Q][0].decode256Time * D256);\n    U32 DTime1 = algoTime[Q][1].tableTime + (algoTime[Q][1].decode256Time * D256);\n    DTime1 += DTime1 \u003e\u003e 3;  /* advantage to algorithm using less memory, for cache eviction */\n\n    return DTime1 \u003c DTime0;\n}","filepath":"lib/decompress/huf_decompress.c","line_number":905,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3049360":{"score":0.769067,"function_name":"HUF_decompress4X_hufOnly_wksp","code":"size_t HUF_decompress4X_hufOnly_wksp(HUF_DTable* dctx, void* dst,\n                                     size_t dstSize, const void* cSrc,\n                                     size_t cSrcSize, void* workSpace,\n                                     size_t wkspSize)\n{\n    /* validation checks */\n    if (dstSize == 0) return ERROR(dstSize_tooSmall);\n    if (cSrcSize == 0) return ERROR(corruption_detected);\n\n    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);\n        return algoNb ? HUF_decompress4X4_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize):\n                        HUF_decompress4X2_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize);\n    }\n}","filepath":"lib/decompress/huf_decompress.c","line_number":957,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3049680":{"score":0.8663095,"function_name":"HUF_decompress1X_DCtx_wksp","code":"size_t HUF_decompress1X_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize,\n                                  const void* cSrc, size_t cSrcSize,\n                                  void* workSpace, size_t wkspSize)\n{\n    /* validation checks */\n    if (dstSize == 0) return ERROR(dstSize_tooSmall);\n    if (cSrcSize \u003e dstSize) return ERROR(corruption_detected);   /* invalid */\n    if (cSrcSize == dstSize) { memcpy(dst, cSrc, dstSize); return dstSize; }   /* not compressed */\n    if (cSrcSize == 1) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */\n\n    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);\n        return algoNb ? HUF_decompress1X4_DCtx_wksp(dctx, dst, dstSize, cSrc,\n                                cSrcSize, workSpace, wkspSize):\n                        HUF_decompress1X2_DCtx_wksp(dctx, dst, dstSize, cSrc,\n                                cSrcSize, workSpace, wkspSize);\n    }\n}","filepath":"lib/decompress/huf_decompress.c","line_number":972,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3050080":{"score":0.621634,"function_name":"HUF_decompress4X_usingDTable","code":"size_t HUF_decompress4X_usingDTable(void* dst, size_t maxDstSize,\n                                    const void* cSrc, size_t cSrcSize,\n                                    const HUF_DTable* DTable)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n    return dtd.tableType ? HUF_decompress4X4_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable) :\n                           HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":868,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3050144":{"score":0.9017823,"function_name":"HUF_decompress1X1_DCtx_wksp_bmi2","code":"size_t HUF_decompress1X1_DCtx_wksp_bmi2(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int bmi2)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp_bmi2(dctx, cSrc, cSrcSize, workSpace, wkspSize, bmi2);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize \u003e= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, bmi2);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":1693,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.5.1"},"3050320":{"score":0.61678386,"function_name":"HUF_decompress4X_usingDTable","code":"size_t HUF_decompress4X_usingDTable(void* dst, size_t maxDstSize,\n                                    const void* cSrc, size_t cSrcSize,\n                                    const HUF_DTable* DTable)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n    return dtd.tableType ? HUF_decompress4X4_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable) :\n                           HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable);\n}","filepath":"lib/decompress/huf_decompress.c","line_number":868,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3050384":{"score":0.7443907,"function_name":"HUF_decompress4X_hufOnly_wksp","code":"size_t HUF_decompress4X_hufOnly_wksp(HUF_DTable* dctx, void* dst,\n                                     size_t dstSize, const void* cSrc,\n                                     size_t cSrcSize, void* workSpace,\n                                     size_t wkspSize)\n{\n    /* validation checks */\n    if (dstSize == 0) return ERROR(dstSize_tooSmall);\n    if (cSrcSize == 0) return ERROR(corruption_detected);\n\n    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);\n        return algoNb ? HUF_decompress4X4_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize):\n                        HUF_decompress4X2_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize);\n    }\n}","filepath":"lib/decompress/huf_decompress.c","line_number":957,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3052320":{"score":0.89755434,"function_name":"HUF_decompress4X_DCtx","code":"size_t HUF_decompress4X_DCtx (HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize)\n{\n    /* validation checks */\n    if (dstSize == 0) return ERROR(dstSize_tooSmall);\n    if (cSrcSize \u003e dstSize) return ERROR(corruption_detected);   /* invalid */\n    if (cSrcSize == dstSize) { memcpy(dst, cSrc, dstSize); return dstSize; }   /* not compressed */\n    if (cSrcSize == 1) { memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */\n\n    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);\n        return algoNb ? HUF_decompress4X4_DCtx(dctx, dst, dstSize, cSrc, cSrcSize) :\n                        HUF_decompress4X2_DCtx(dctx, dst, dstSize, cSrc, cSrcSize) ;\n    }\n}","filepath":"lib/decompress/huf_decompress.c","line_number":935,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.1"},"3068784":{"score":0.7908824,"function_name":"fill_window","code":"local void fill_window(s)\n    deflate_state *s;\n{\n    register unsigned n, m;\n    register Posf *p;\n    unsigned more;    /* Amount of free space at the end of the window. */\n    uInt wsize = s-\u003ew_size;\n\n    Assert(s-\u003elookahead \u003c MIN_LOOKAHEAD, \"already enough lookahead\");\n\n    do {\n        more = (unsigned)(s-\u003ewindow_size -(ulg)s-\u003elookahead -(ulg)s-\u003estrstart);\n\n        /* Deal with !@#$% 64K limit: */\n        if (sizeof(int) \u003c= 2) {\n            if (more == 0 \u0026\u0026 s-\u003estrstart == 0 \u0026\u0026 s-\u003elookahead == 0) {\n                more = wsize;\n\n            } else if (more == (unsigned)(-1)) {\n                /* Very unlikely, but possible on 16 bit machine if\n                 * strstart == 0 \u0026\u0026 lookahead == 1 (input done a byte at time)\n                 */\n                more--;\n            }\n        }\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        if (s-\u003estrstart \u003e= wsize+MAX_DIST(s)) {\n\n            zmemcpy(s-\u003ewindow, s-\u003ewindow+wsize, (unsigned)wsize);\n            s-\u003ematch_start -= wsize;\n            s-\u003estrstart    -= wsize; /* we now have strstart \u003e= MAX_DIST */\n            s-\u003eblock_start -= (long) wsize;\n\n            /* Slide the hash table (could be avoided with 32 bit values\n               at the expense of memory usage). We slide even when level == 0\n               to keep the hash table consistent if we switch back to level \u003e 0\n               later. (Using level 0 permanently is not an optimal usage of\n               zlib, so we don't care about this pathological case.)\n             */\n            n = s-\u003ehash_size;\n            p = \u0026s-\u003ehead[n];\n            do {\n                m = *--p;\n                *p = (Pos)(m \u003e= wsize ? m-wsize : NIL);\n            } while (--n);\n\n            n = wsize;\n#ifndef FASTEST\n            p = \u0026s-\u003eprev[n];\n            do {\n                m = *--p;\n                *p = (Pos)(m \u003e= wsize ? m-wsize : NIL);\n                /* If n is not on any hash chain, prev[n] is garbage but\n                 * its value will never be used.\n                 */\n            } while (--n);\n#endif\n            more += wsize;\n        }\n        if (s-\u003estrm-\u003eavail_in == 0) break;\n\n        /* If there was no sliding:\n         *    strstart \u003c= WSIZE+MAX_DIST-1 \u0026\u0026 lookahead \u003c= MIN_LOOKAHEAD - 1 \u0026\u0026\n         *    more == window_size - lookahead - strstart\n         * =\u003e more \u003e= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * =\u003e more \u003e= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  \u0026\u0026\n         *   strstart + s-\u003elookahead \u003c= input_size =\u003e more \u003e= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more \u003e= 2.\n         * If there was sliding, more \u003e= WSIZE. So in all cases, more \u003e= 2.\n         */\n        Assert(more \u003e= 2, \"more \u003c 2\");\n\n        n = read_buf(s-\u003estrm, s-\u003ewindow + s-\u003estrstart + s-\u003elookahead, more);\n        s-\u003elookahead += n;\n\n        /* Initialize the hash value now that we have some input: */\n        if (s-\u003elookahead + s-\u003einsert \u003e= MIN_MATCH) {\n            uInt str = s-\u003estrstart - s-\u003einsert;\n            s-\u003eins_h = s-\u003ewindow[str];\n            UPDATE_HASH(s, s-\u003eins_h, s-\u003ewindow[str + 1]);\n#if MIN_MATCH != 3\n            Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            while (s-\u003einsert) {\n                UPDATE_HASH(s, s-\u003eins_h, s-\u003ewindow[str + MIN_MATCH-1]);\n#ifndef FASTEST\n                s-\u003eprev[str \u0026 s-\u003ew_mask] = s-\u003ehead[s-\u003eins_h];\n#endif\n                s-\u003ehead[s-\u003eins_h] = (Pos)str;\n                str++;\n                s-\u003einsert--;\n                if (s-\u003elookahead + s-\u003einsert \u003c MIN_MATCH)\n                    break;\n            }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n    } while (s-\u003elookahead \u003c MIN_LOOKAHEAD \u0026\u0026 s-\u003estrm-\u003eavail_in != 0);\n\n    /* If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n     */\n    if (s-\u003ehigh_water \u003c s-\u003ewindow_size) {\n        ulg curr = s-\u003estrstart + (ulg)(s-\u003elookahead);\n        ulg init;\n\n        if (s-\u003ehigh_water \u003c curr) {\n            /* Previous high water mark below current data -- zero WIN_INIT\n             * bytes or up to end of window, whichever is less.\n             */\n            init = s-\u003ewindow_size - curr;\n            if (init \u003e WIN_INIT)\n                init = WIN_INIT;\n            zmemzero(s-\u003ewindow + curr, (unsigned)init);\n            s-\u003ehigh_water = curr + init;\n        }\n        else if (s-\u003ehigh_water \u003c (ulg)curr + WIN_INIT) {\n            /* High water mark at or above current data, but below current data\n             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n             * to end of window, whichever is less.\n             */\n            init = (ulg)curr + WIN_INIT - s-\u003ehigh_water;\n            if (init \u003e s-\u003ewindow_size - s-\u003ehigh_water)\n                init = s-\u003ewindow_size - s-\u003ehigh_water;\n            zmemzero(s-\u003ewindow + s-\u003ehigh_water, (unsigned)init);\n            s-\u003ehigh_water += init;\n        }\n    }\n\n    Assert((ulg)s-\u003estrstart \u003c= s-\u003ewindow_size - MIN_LOOKAHEAD,\n           \"not enough room for search\");\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":1398,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3072960":{"score":0.69019604,"function_name":"deflate_slow","code":"local block_state deflate_slow(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;          /* head of hash chain */\n    int bflush;              /* set if current block must be flushed */\n\n    /* Process the input block. */\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s-\u003elookahead \u003c MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s-\u003elookahead \u003c MIN_LOOKAHEAD \u0026\u0026 flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s-\u003elookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = NIL;\n        if (s-\u003elookahead \u003e= MIN_MATCH) {\n            INSERT_STRING(s, s-\u003estrstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those \u003c= prev_length.\n         */\n        s-\u003eprev_length = s-\u003ematch_length, s-\u003eprev_match = s-\u003ematch_start;\n        s-\u003ematch_length = MIN_MATCH-1;\n\n        if (hash_head != NIL \u0026\u0026 s-\u003eprev_length \u003c s-\u003emax_lazy_match \u0026\u0026\n            s-\u003estrstart - hash_head \u003c= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            s-\u003ematch_length = longest_match (s, hash_head);\n            /* longest_match() sets match_start */\n\n            if (s-\u003ematch_length \u003c= 5 \u0026\u0026 (s-\u003estrategy == Z_FILTERED\n#if TOO_FAR \u003c= 32767\n                || (s-\u003ematch_length == MIN_MATCH \u0026\u0026\n                    s-\u003estrstart - s-\u003ematch_start \u003e TOO_FAR)\n#endif\n                )) {\n\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                s-\u003ematch_length = MIN_MATCH-1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s-\u003eprev_length \u003e= MIN_MATCH \u0026\u0026 s-\u003ematch_length \u003c= s-\u003eprev_length) {\n            uInt max_insert = s-\u003estrstart + s-\u003elookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n\n            check_match(s, s-\u003estrstart-1, s-\u003eprev_match, s-\u003eprev_length);\n\n            _tr_tally_dist(s, s-\u003estrstart -1 - s-\u003eprev_match,\n                           s-\u003eprev_length - MIN_MATCH, bflush);\n\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             */\n            s-\u003elookahead -= s-\u003eprev_length-1;\n            s-\u003eprev_length -= 2;\n            do {\n                if (++s-\u003estrstart \u003c= max_insert) {\n                    INSERT_STRING(s, s-\u003estrstart, hash_head);\n                }\n            } while (--s-\u003eprev_length != 0);\n            s-\u003ematch_available = 0;\n            s-\u003ematch_length = MIN_MATCH-1;\n            s-\u003estrstart++;\n\n            if (bflush) FLUSH_BLOCK(s, 0);\n\n        } else if (s-\u003ematch_available) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            Tracevv((stderr,\"%c\", s-\u003ewindow[s-\u003estrstart-1]));\n            _tr_tally_lit(s, s-\u003ewindow[s-\u003estrstart-1], bflush);\n            if (bflush) {\n                FLUSH_BLOCK_ONLY(s, 0);\n            }\n            s-\u003estrstart++;\n            s-\u003elookahead--;\n            if (s-\u003estrm-\u003eavail_out == 0) return need_more;\n        } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            s-\u003ematch_available = 1;\n            s-\u003estrstart++;\n            s-\u003elookahead--;\n        }\n    }\n    Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s-\u003ematch_available) {\n        Tracevv((stderr,\"%c\", s-\u003ewindow[s-\u003estrstart-1]));\n        _tr_tally_lit(s, s-\u003ewindow[s-\u003estrstart-1], bflush);\n        s-\u003ematch_available = 0;\n    }\n    s-\u003einsert = s-\u003estrstart \u003c MIN_MATCH-1 ? s-\u003estrstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s-\u003elast_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":1738,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3080736":{"score":0.75555664,"function_name":"deflateSetDictionary","code":"int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n    z_streamp strm;\n    const Bytef *dictionary;\n    uInt  dictLength;\n{\n    deflate_state *s;\n    uInt str, n;\n    int wrap;\n    unsigned avail;\n    z_const unsigned char *next;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL || dictionary == Z_NULL)\n        return Z_STREAM_ERROR;\n    s = strm-\u003estate;\n    wrap = s-\u003ewrap;\n    if (wrap == 2 || (wrap == 1 \u0026\u0026 s-\u003estatus != INIT_STATE) || s-\u003elookahead)\n        return Z_STREAM_ERROR;\n\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n    if (wrap == 1)\n        strm-\u003eadler = adler32(strm-\u003eadler, dictionary, dictLength);\n    s-\u003ewrap = 0;                    /* avoid computing Adler-32 in read_buf */\n\n    /* if dictionary would fill window, just replace the history */\n    if (dictLength \u003e= s-\u003ew_size) {\n        if (wrap == 0) {            /* already empty otherwise */\n            CLEAR_HASH(s);\n            s-\u003estrstart = 0;\n            s-\u003eblock_start = 0L;\n            s-\u003einsert = 0;\n        }\n        dictionary += dictLength - s-\u003ew_size;  /* use the tail */\n        dictLength = s-\u003ew_size;\n    }\n\n    /* insert dictionary into window and hash */\n    avail = strm-\u003eavail_in;\n    next = strm-\u003enext_in;\n    strm-\u003eavail_in = dictLength;\n    strm-\u003enext_in = (z_const Bytef *)dictionary;\n    fill_window(s);\n    while (s-\u003elookahead \u003e= MIN_MATCH) {\n        str = s-\u003estrstart;\n        n = s-\u003elookahead - (MIN_MATCH-1);\n        do {\n            UPDATE_HASH(s, s-\u003eins_h, s-\u003ewindow[str + MIN_MATCH-1]);\n#ifndef FASTEST\n            s-\u003eprev[str \u0026 s-\u003ew_mask] = s-\u003ehead[s-\u003eins_h];\n#endif\n            s-\u003ehead[s-\u003eins_h] = (Pos)str;\n            str++;\n        } while (--n);\n        s-\u003estrstart = str;\n        s-\u003elookahead = MIN_MATCH-1;\n        fill_window(s);\n    }\n    s-\u003estrstart += s-\u003elookahead;\n    s-\u003eblock_start = (long)s-\u003estrstart;\n    s-\u003einsert = s-\u003elookahead;\n    s-\u003elookahead = 0;\n    s-\u003ematch_length = s-\u003eprev_length = MIN_MATCH-1;\n    s-\u003ematch_available = 0;\n    strm-\u003enext_in = next;\n    strm-\u003eavail_in = avail;\n    s-\u003ewrap = wrap;\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":331,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3081392":{"score":0.5918848,"function_name":"deflatePending","code":"int ZEXPORT deflatePending (strm, pending, bits)\n    unsigned *pending;\n    int *bits;\n    z_streamp strm;\n{\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    if (pending != Z_NULL)\n        *pending = strm-\u003estate-\u003epending;\n    if (bits != Z_NULL)\n        *bits = strm-\u003estate-\u003ebi_valid;\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":458,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3081632":{"score":0.7349389,"function_name":"deflateResetKeep","code":"int ZEXPORT deflateResetKeep (strm)\n    z_streamp strm;\n{\n    deflate_state *s;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL ||\n        strm-\u003ezalloc == (alloc_func)0 || strm-\u003ezfree == (free_func)0) {\n        return Z_STREAM_ERROR;\n    }\n\n    strm-\u003etotal_in = strm-\u003etotal_out = 0;\n    strm-\u003emsg = Z_NULL; /* use zfree if we ever allocate msg dynamically */\n    strm-\u003edata_type = Z_UNKNOWN;\n\n    s = (deflate_state *)strm-\u003estate;\n    s-\u003epending = 0;\n    s-\u003epending_out = s-\u003epending_buf;\n\n    if (s-\u003ewrap \u003c 0) {\n        s-\u003ewrap = -s-\u003ewrap; /* was made negative by deflate(..., Z_FINISH); */\n    }\n    s-\u003estatus = s-\u003ewrap ? INIT_STATE : BUSY_STATE;\n    strm-\u003eadler =\n#ifdef GZIP\n        s-\u003ewrap == 2 ? crc32(0L, Z_NULL, 0) :\n#endif\n        adler32(0L, Z_NULL, 0);\n    s-\u003elast_flush = Z_NO_FLUSH;\n\n    _tr_init(s);\n\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":400,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3081936":{"score":0.7543428,"function_name":"deflateResetKeep","code":"int ZEXPORT deflateResetKeep (strm)\n    z_streamp strm;\n{\n    deflate_state *s;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL ||\n        strm-\u003ezalloc == (alloc_func)0 || strm-\u003ezfree == (free_func)0) {\n        return Z_STREAM_ERROR;\n    }\n\n    strm-\u003etotal_in = strm-\u003etotal_out = 0;\n    strm-\u003emsg = Z_NULL; /* use zfree if we ever allocate msg dynamically */\n    strm-\u003edata_type = Z_UNKNOWN;\n\n    s = (deflate_state *)strm-\u003estate;\n    s-\u003epending = 0;\n    s-\u003epending_out = s-\u003epending_buf;\n\n    if (s-\u003ewrap \u003c 0) {\n        s-\u003ewrap = -s-\u003ewrap; /* was made negative by deflate(..., Z_FINISH); */\n    }\n    s-\u003estatus = s-\u003ewrap ? INIT_STATE : BUSY_STATE;\n    strm-\u003eadler =\n#ifdef GZIP\n        s-\u003ewrap == 2 ? crc32(0L, Z_NULL, 0) :\n#endif\n        adler32(0L, Z_NULL, 0);\n    s-\u003elast_flush = Z_NO_FLUSH;\n\n    _tr_init(s);\n\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":400,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3082432":{"score":0.70817775,"function_name":"deflateSetHeader","code":"int ZEXPORT deflateSetHeader (strm, head)\n    z_streamp strm;\n    gz_headerp head;\n{\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    if (strm-\u003estate-\u003ewrap != 2) return Z_STREAM_ERROR;\n    strm-\u003estate-\u003egzhead = head;\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":447,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3082576":{"score":0.6824497,"function_name":"deflatePending","code":"int ZEXPORT deflatePending (strm, pending, bits)\n    unsigned *pending;\n    int *bits;\n    z_streamp strm;\n{\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    if (pending != Z_NULL)\n        *pending = strm-\u003estate-\u003epending;\n    if (bits != Z_NULL)\n        *bits = strm-\u003estate-\u003ebi_valid;\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":458,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3082720":{"score":0.7207401,"function_name":"deflatePrime","code":"int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    s = strm-\u003estate;\n    if ((Bytef *)(s-\u003ed_buf) \u003c s-\u003epending_out + ((Buf_size + 7) \u003e\u003e 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s-\u003ebi_valid;\n        if (put \u003e bits)\n            put = bits;\n        s-\u003ebi_buf |= (ush)((value \u0026 ((1 \u003c\u003c put) - 1)) \u003c\u003c s-\u003ebi_valid);\n        s-\u003ebi_valid += put;\n        _tr_flush_bits(s);\n        value \u003e\u003e= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":472,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3082960":{"score":0.7144996,"function_name":"deflateParams","code":"int ZEXPORT deflateParams(strm, level, strategy)\n    z_streamp strm;\n    int level;\n    int strategy;\n{\n    deflate_state *s;\n    compress_func func;\n    int err = Z_OK;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    s = strm-\u003estate;\n\n#ifdef FASTEST\n    if (level != 0) level = 1;\n#else\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#endif\n    if (level \u003c 0 || level \u003e 9 || strategy \u003c 0 || strategy \u003e Z_FIXED) {\n        return Z_STREAM_ERROR;\n    }\n    func = configuration_table[s-\u003elevel].func;\n\n    if ((strategy != s-\u003estrategy || func != configuration_table[level].func) \u0026\u0026\n        strm-\u003etotal_in != 0) {\n        /* Flush the last buffer: */\n        err = deflate(strm, Z_BLOCK);\n        if (err == Z_BUF_ERROR \u0026\u0026 s-\u003epending == 0)\n            err = Z_OK;\n    }\n    if (s-\u003elevel != level) {\n        s-\u003elevel = level;\n        s-\u003emax_lazy_match   = configuration_table[level].max_lazy;\n        s-\u003egood_match       = configuration_table[level].good_length;\n        s-\u003enice_match       = configuration_table[level].nice_length;\n        s-\u003emax_chain_length = configuration_table[level].max_chain;\n    }\n    s-\u003estrategy = strategy;\n    return err;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":498,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3083744":{"score":0.7536972,"function_name":"deflateTune","code":"int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)\n    z_streamp strm;\n    int good_length;\n    int max_lazy;\n    int nice_length;\n    int max_chain;\n{\n    deflate_state *s;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    s = strm-\u003estate;\n    s-\u003egood_match = good_length;\n    s-\u003emax_lazy_match = max_lazy;\n    s-\u003enice_match = nice_length;\n    s-\u003emax_chain_length = max_chain;\n    return Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":539,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3083904":{"score":0.79535913,"function_name":"deflateBound","code":"uLong ZEXPORT deflateBound(strm, sourceLen)\n    z_streamp strm;\n    uLong sourceLen;\n{\n    deflate_state *s;\n    uLong complen, wraplen;\n    Bytef *str;\n\n    /* conservative upper bound for compressed data */\n    complen = sourceLen +\n              ((sourceLen + 7) \u003e\u003e 3) + ((sourceLen + 63) \u003e\u003e 6) + 5;\n\n    /* if can't get parameters, return conservative bound plus zlib wrapper */\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL)\n        return complen + 6;\n\n    /* compute wrapper length */\n    s = strm-\u003estate;\n    switch (s-\u003ewrap) {\n    case 0:                                 /* raw deflate */\n        wraplen = 0;\n        break;\n    case 1:                                 /* zlib wrapper */\n        wraplen = 6 + (s-\u003estrstart ? 4 : 0);\n        break;\n    case 2:                                 /* gzip wrapper */\n        wraplen = 18;\n        if (s-\u003egzhead != Z_NULL) {          /* user-supplied gzip header */\n            if (s-\u003egzhead-\u003eextra != Z_NULL)\n                wraplen += 2 + s-\u003egzhead-\u003eextra_len;\n            str = s-\u003egzhead-\u003ename;\n            if (str != Z_NULL)\n                do {\n                    wraplen++;\n                } while (*str++);\n            str = s-\u003egzhead-\u003ecomment;\n            if (str != Z_NULL)\n                do {\n                    wraplen++;\n                } while (*str++);\n            if (s-\u003egzhead-\u003ehcrc)\n                wraplen += 2;\n        }\n        break;\n    default:                                /* for compiler happiness */\n        wraplen = 6;\n    }\n\n    /* if not default parameters, return conservative bound */\n    if (s-\u003ew_bits != 15 || s-\u003ehash_bits != 8 + 7)\n        return complen + wraplen;\n\n    /* default settings: return tight bound for that case */\n    return sourceLen + (sourceLen \u003e\u003e 12) + (sourceLen \u003e\u003e 14) +\n           (sourceLen \u003e\u003e 25) + 13 - 6 + wraplen;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":574,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3084384":{"score":0.6949202,"function_name":"deflateEnd","code":"int ZEXPORT deflateEnd (strm)\n    z_streamp strm;\n{\n    int status;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n\n    status = strm-\u003estate-\u003estatus;\n    if (status != INIT_STATE \u0026\u0026\n        status != EXTRA_STATE \u0026\u0026\n        status != NAME_STATE \u0026\u0026\n        status != COMMENT_STATE \u0026\u0026\n        status != HCRC_STATE \u0026\u0026\n        status != BUSY_STATE \u0026\u0026\n        status != FINISH_STATE) {\n      return Z_STREAM_ERROR;\n    }\n\n    /* Deallocate in reverse order of allocations: */\n    TRY_FREE(strm, strm-\u003estate-\u003epending_buf);\n    TRY_FREE(strm, strm-\u003estate-\u003ehead);\n    TRY_FREE(strm, strm-\u003estate-\u003eprev);\n    TRY_FREE(strm, strm-\u003estate-\u003ewindow);\n\n    ZFREE(strm, strm-\u003estate);\n    strm-\u003estate = Z_NULL;\n\n    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":987,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3086416":{"score":0.6932858,"function_name":"deflateCopy","code":"int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n\n\n    if (source == Z_NULL || dest == Z_NULL || source-\u003estate == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source-\u003estate;\n\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest-\u003estate = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds-\u003estrm = dest;\n\n    ds-\u003ewindow = (Bytef *) ZALLOC(dest, ds-\u003ew_size, 2*sizeof(Byte));\n    ds-\u003eprev   = (Posf *)  ZALLOC(dest, ds-\u003ew_size, sizeof(Pos));\n    ds-\u003ehead   = (Posf *)  ZALLOC(dest, ds-\u003ehash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds-\u003elit_bufsize, sizeof(ush)+2);\n    ds-\u003epending_buf = (uchf *) overlay;\n\n    if (ds-\u003ewindow == Z_NULL || ds-\u003eprev == Z_NULL || ds-\u003ehead == Z_NULL ||\n        ds-\u003epending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    /* following zmemcpy do not work for 16-bit MSDOS */\n    zmemcpy(ds-\u003ewindow, ss-\u003ewindow, ds-\u003ew_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds-\u003eprev, (voidpf)ss-\u003eprev, ds-\u003ew_size * sizeof(Pos));\n    zmemcpy((voidpf)ds-\u003ehead, (voidpf)ss-\u003ehead, ds-\u003ehash_size * sizeof(Pos));\n    zmemcpy(ds-\u003epending_buf, ss-\u003epending_buf, (uInt)ds-\u003epending_buf_size);\n\n    ds-\u003epending_out = ds-\u003epending_buf + (ss-\u003epending_out - ss-\u003epending_buf);\n    ds-\u003ed_buf = overlay + ds-\u003elit_bufsize/sizeof(ush);\n    ds-\u003el_buf = ds-\u003epending_buf + (1+sizeof(ush))*ds-\u003elit_bufsize;\n\n    ds-\u003el_desc.dyn_tree = ds-\u003edyn_ltree;\n    ds-\u003ed_desc.dyn_tree = ds-\u003edyn_dtree;\n    ds-\u003ebl_desc.dyn_tree = ds-\u003ebl_tree;\n\n    return Z_OK;\n#endif /* MAXSEG_64K */\n}","filepath":"src/contrib/libs/zlib/deflate.c","line_number":1022,"entry_url":"https://github.com/yandex/tomita-parser.git","slot_name":"v1.0"},"3095376":{"score":0.77664596,"function_name":"updatewindow","code":"local int updatewindow(strm, end, copy)\nz_streamp strm;\nconst Bytef *end;\nunsigned copy;\n{\n    struct inflate_state FAR *state;\n    unsigned dist;\n\n    state = (struct inflate_state FAR *)strm-\u003estate;\n\n    /* if it hasn't been done already, allocate space for the window */\n    if (state-\u003ewindow == Z_NULL) {\n        state-\u003ewindow = (unsigned char FAR *)\n                        ZALLOC(strm, 1U \u003c\u003c state-\u003ewbits,\n                               sizeof(unsigned char));\n        if (state-\u003ewindow == Z_NULL) return 1;\n    }\n\n    /* if window not in use yet, initialize */\n    if (state-\u003ewsize == 0) {\n        state-\u003ewsize = 1U \u003c\u003c state-\u003ewbits;\n        state-\u003ewnext = 0;\n        state-\u003ewhave = 0;\n    }\n\n    /* copy state-\u003ewsize or less output bytes into the circular window */\n    if (copy \u003e= state-\u003ewsize) {\n        zmemcpy(state-\u003ewindow, end - state-\u003ewsize, state-\u003ewsize);\n        state-\u003ewnext = 0;\n        state-\u003ewhave = state-\u003ewsize;\n    }\n    else {\n        dist = state-\u003ewsize - state-\u003ewnext;\n        if (dist \u003e copy) dist = copy;\n        zmemcpy(state-\u003ewindow + state-\u003ewnext, end - copy, dist);\n        copy -= dist;\n        if (copy) {\n            zmemcpy(state-\u003ewindow, end - copy, copy);\n            state-\u003ewnext = copy;\n            state-\u003ewhave = state-\u003ewsize;\n        }\n        else {\n            state-\u003ewnext += dist;\n            if (state-\u003ewnext == state-\u003ewsize) state-\u003ewnext = 0;\n            if (state-\u003ewhave \u003c state-\u003ewsize) state-\u003ewhave += dist;\n        }\n    }\n    return 0;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":381,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3095696":{"score":0.7547045,"function_name":"inflateResetKeep","code":"int ZEXPORT inflateResetKeep(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n    strm-\u003etotal_in = strm-\u003etotal_out = state-\u003etotal = 0;\n    strm-\u003emsg = Z_NULL;\n    if (state-\u003ewrap)        /* to support ill-conceived Java test suite */\n        strm-\u003eadler = state-\u003ewrap \u0026 1;\n    state-\u003emode = HEAD;\n    state-\u003elast = 0;\n    state-\u003ehavedict = 0;\n    state-\u003edmax = 32768U;\n    state-\u003ehead = Z_NULL;\n    state-\u003ehold = 0;\n    state-\u003ebits = 0;\n    state-\u003elencode = state-\u003edistcode = state-\u003enext = state-\u003ecodes;\n    state-\u003esane = 1;\n    state-\u003eback = -1;\n    Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":106,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3095936":{"score":0.7663799,"function_name":"inflateResetKeep","code":"int ZEXPORT inflateResetKeep(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n    strm-\u003etotal_in = strm-\u003etotal_out = state-\u003etotal = 0;\n    strm-\u003emsg = Z_NULL;\n    if (state-\u003ewrap)        /* to support ill-conceived Java test suite */\n        strm-\u003eadler = state-\u003ewrap \u0026 1;\n    state-\u003emode = HEAD;\n    state-\u003elast = 0;\n    state-\u003ehavedict = 0;\n    state-\u003edmax = 32768U;\n    state-\u003ehead = Z_NULL;\n    state-\u003ehold = 0;\n    state-\u003ebits = 0;\n    state-\u003elencode = state-\u003edistcode = state-\u003enext = state-\u003ecodes;\n    state-\u003esane = 1;\n    state-\u003eback = -1;\n    Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":106,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3096192":{"score":0.7268073,"function_name":"inflateReset2","code":"int ZEXPORT inflateReset2(strm, windowBits)\nz_streamp strm;\nint windowBits;\n{\n    int wrap;\n    struct inflate_state FAR *state;\n\n    /* get the state */\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n\n    /* extract wrap request from windowBits parameter */\n    if (windowBits \u003c 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    }\n    else {\n        wrap = (windowBits \u003e\u003e 4) + 1;\n#ifdef GUNZIP\n        if (windowBits \u003c 48)\n            windowBits \u0026= 15;\n#endif\n    }\n\n    /* set number of window bits, free window if different */\n    if (windowBits \u0026\u0026 (windowBits \u003c 8 || windowBits \u003e 15))\n        return Z_STREAM_ERROR;\n    if (state-\u003ewindow != Z_NULL \u0026\u0026 state-\u003ewbits != (unsigned)windowBits) {\n        ZFREE(strm, state-\u003ewindow);\n        state-\u003ewindow = Z_NULL;\n    }\n\n    /* update state and reset the rest of it */\n    state-\u003ewrap = wrap;\n    state-\u003ewbits = (unsigned)windowBits;\n    return inflateReset(strm);\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":144,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3097344":{"score":0.7598008,"function_name":"inflatePrime","code":"int ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n    if (bits \u003c 0) {\n        state-\u003ehold = 0;\n        state-\u003ebits = 0;\n        return Z_OK;\n    }\n    if (bits \u003e 16 || state-\u003ebits + bits \u003e 32) return Z_STREAM_ERROR;\n    value \u0026= (1L \u003c\u003c bits) - 1;\n    state-\u003ehold += value \u003c\u003c state-\u003ebits;\n    state-\u003ebits += bits;\n    return Z_OK;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":232,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3106704":{"score":0.7372038,"function_name":"inflateGetDictionary","code":"int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)\nz_streamp strm;\nBytef *dictionary;\nuInt *dictLength;\n{\n    struct inflate_state FAR *state;\n\n    /* check state */\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n\n    /* copy dictionary */\n    if (state-\u003ewhave \u0026\u0026 dictionary != Z_NULL) {\n        zmemcpy(dictionary, state-\u003ewindow + state-\u003ewnext,\n                state-\u003ewhave - state-\u003ewnext);\n        zmemcpy(dictionary + state-\u003ewhave - state-\u003ewnext,\n                state-\u003ewindow, state-\u003ewnext);\n    }\n    if (dictLength != Z_NULL)\n        *dictLength = state-\u003ewhave;\n    return Z_OK;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":1270,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3106880":{"score":0.69455993,"function_name":"inflateSetDictionary","code":"int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)\nz_streamp strm;\nconst Bytef *dictionary;\nuInt dictLength;\n{\n    struct inflate_state FAR *state;\n    unsigned long dictid;\n    int ret;\n\n    /* check state */\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n    if (state-\u003ewrap != 0 \u0026\u0026 state-\u003emode != DICT)\n        return Z_STREAM_ERROR;\n\n    /* check for correct dictionary identifier */\n    if (state-\u003emode == DICT) {\n        dictid = adler32(0L, Z_NULL, 0);\n        dictid = adler32(dictid, dictionary, dictLength);\n        if (dictid != state-\u003echeck)\n            return Z_DATA_ERROR;\n    }\n\n    /* copy dictionary to window using updatewindow(), which will amend the\n       existing dictionary if appropriate */\n    ret = updatewindow(strm, dictionary + dictLength, dictLength);\n    if (ret) {\n        state-\u003emode = MEM;\n        return Z_MEM_ERROR;\n    }\n    state-\u003ehavedict = 1;\n    Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":1293,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3107152":{"score":0.7594578,"function_name":"inflateGetHeader","code":"int ZEXPORT inflateGetHeader(strm, head)\nz_streamp strm;\ngz_headerp head;\n{\n    struct inflate_state FAR *state;\n\n    /* check state */\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n    if ((state-\u003ewrap \u0026 2) == 0) return Z_STREAM_ERROR;\n\n    /* save header structure */\n    state-\u003ehead = head;\n    head-\u003edone = 0;\n    return Z_OK;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":1328,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3107264":{"score":0.7992439,"function_name":"inflateSync","code":"int ZEXPORT inflateSync(strm)\nz_streamp strm;\n{\n    unsigned len;               /* number of bytes to look at or looked at */\n    unsigned long in, out;      /* temporary to save total_in and total_out */\n    unsigned char buf[4];       /* to restore bit buffer to byte string */\n    struct inflate_state FAR *state;\n\n    /* check parameters */\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n    if (strm-\u003eavail_in == 0 \u0026\u0026 state-\u003ebits \u003c 8) return Z_BUF_ERROR;\n\n    /* if first time, start search in bit buffer */\n    if (state-\u003emode != SYNC) {\n        state-\u003emode = SYNC;\n        state-\u003ehold \u003c\u003c= state-\u003ebits \u0026 7;\n        state-\u003ebits -= state-\u003ebits \u0026 7;\n        len = 0;\n        while (state-\u003ebits \u003e= 8) {\n            buf[len++] = (unsigned char)(state-\u003ehold);\n            state-\u003ehold \u003e\u003e= 8;\n            state-\u003ebits -= 8;\n        }\n        state-\u003ehave = 0;\n        syncsearch(\u0026(state-\u003ehave), buf, len);\n    }\n\n    /* search available input */\n    len = syncsearch(\u0026(state-\u003ehave), strm-\u003enext_in, strm-\u003eavail_in);\n    strm-\u003eavail_in -= len;\n    strm-\u003enext_in += len;\n    strm-\u003etotal_in += len;\n\n    /* return no joy or set up to restart inflate() on a new block */\n    if (state-\u003ehave != 4) return Z_DATA_ERROR;\n    in = strm-\u003etotal_in;  out = strm-\u003etotal_out;\n    inflateReset(strm);\n    strm-\u003etotal_in = in;  strm-\u003etotal_out = out;\n    state-\u003emode = TYPE;\n    return Z_OK;\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":1379,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3108960":{"score":0.61967516,"function_name":"inflateReset2","code":"int ZEXPORT inflateReset2(strm, windowBits)\nz_streamp strm;\nint windowBits;\n{\n    int wrap;\n    struct inflate_state FAR *state;\n\n    /* get the state */\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n\n    /* extract wrap request from windowBits parameter */\n    if (windowBits \u003c 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    }\n    else {\n        wrap = (windowBits \u003e\u003e 4) + 1;\n#ifdef GUNZIP\n        if (windowBits \u003c 48)\n            windowBits \u0026= 15;\n#endif\n    }\n\n    /* set number of window bits, free window if different */\n    if (windowBits \u0026\u0026 (windowBits \u003c 8 || windowBits \u003e 15))\n        return Z_STREAM_ERROR;\n    if (state-\u003ewindow != Z_NULL \u0026\u0026 state-\u003ewbits != (unsigned)windowBits) {\n        ZFREE(strm, state-\u003ewindow);\n        state-\u003ewindow = Z_NULL;\n    }\n\n    /* update state and reset the rest of it */\n    state-\u003ewrap = wrap;\n    state-\u003ewbits = (unsigned)windowBits;\n    return inflateReset(strm);\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":144,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3109088":{"score":0.69876665,"function_name":"inflateMark","code":"long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm-\u003estate == Z_NULL) return -1L \u003c\u003c 16;\n    state = (struct inflate_state FAR *)strm-\u003estate;\n    return ((long)(state-\u003eback) \u003c\u003c 16) +\n        (state-\u003emode == COPY ? state-\u003elength :\n            (state-\u003emode == MATCH ? state-\u003ewas - state-\u003elength : 0));\n}","filepath":"Code/Engine/ThirdParty/zlib/inflate.c","line_number":1504,"entry_url":"https://github.com/ezEngine/ezEngine.git","slot_name":"ms9"},"3123408":{"score":0.77273107,"function_name":"ZopfliBlockSplitLZ77","code":"void ZopfliBlockSplitLZ77(const ZopfliOptions* options,\n                          const ZopfliLZ77Store* lz77, size_t maxblocks,\n                          size_t** splitpoints, size_t* npoints) {\n  size_t lstart, lend;\n  size_t i;\n  size_t llpos = 0;\n  size_t numblocks = 1;\n  unsigned char* done;\n  double splitcost, origcost;\n\n  if (lz77-\u003esize \u003c 10) return;  /* This code fails on tiny files. */\n\n  done = (unsigned char*)malloc(lz77-\u003esize);\n  if (!done) exit(-1); /* Allocation failed. */\n  for (i = 0; i \u003c lz77-\u003esize; i++) done[i] = 0;\n\n  lstart = 0;\n  lend = lz77-\u003esize;\n  for (;;) {\n    SplitCostContext c;\n\n    if (maxblocks \u003e 0 \u0026\u0026 numblocks \u003e= maxblocks) {\n      break;\n    }\n\n    c.lz77 = lz77;\n    c.start = lstart;\n    c.end = lend;\n    assert(lstart \u003c lend);\n    llpos = FindMinimum(SplitCost, \u0026c, lstart + 1, lend, \u0026splitcost);\n\n    assert(llpos \u003e lstart);\n    assert(llpos \u003c lend);\n\n    origcost = EstimateCost(lz77, lstart, lend);\n\n    if (splitcost \u003e origcost || llpos == lstart + 1 || llpos == lend) {\n      done[lstart] = 1;\n    } else {\n      AddSorted(llpos, splitpoints, npoints);\n      numblocks++;\n    }\n\n    if (!FindLargestSplittableBlock(\n        lz77-\u003esize, done, *splitpoints, *npoints, \u0026lstart, \u0026lend)) {\n      break;  /* No further split will probably reduce compression. */\n    }\n\n    if (lend - lstart \u003c 10) {\n      break;\n    }\n  }\n\n  if (options-\u003everbose) {\n    PrintBlockSplitPoints(lz77, *splitpoints, *npoints);\n  }\n\n  free(done);\n}","filepath":"src/zopfli/blocksplitter.c","line_number":215,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3125408":{"score":0.80222356,"function_name":"ZopfliBlockSplit","code":"void ZopfliBlockSplit(const ZopfliOptions* options,\n                      const unsigned char* in, size_t instart, size_t inend,\n                      size_t maxblocks, size_t** splitpoints, size_t* npoints) {\n  size_t pos = 0;\n  size_t i;\n  ZopfliBlockState s;\n  size_t* lz77splitpoints = 0;\n  size_t nlz77points = 0;\n  ZopfliLZ77Store store;\n  ZopfliHash hash;\n  ZopfliHash* h = \u0026hash;\n\n  ZopfliInitLZ77Store(in, \u0026store);\n  ZopfliInitBlockState(options, instart, inend, 0, \u0026s);\n  ZopfliAllocHash(ZOPFLI_WINDOW_SIZE, h);\n\n  *npoints = 0;\n  *splitpoints = 0;\n\n  /* Unintuitively, Using a simple LZ77 method here instead of ZopfliLZ77Optimal\n  results in better blocks. */\n  ZopfliLZ77Greedy(\u0026s, in, instart, inend, \u0026store, h);\n\n  ZopfliBlockSplitLZ77(options,\n                       \u0026store, maxblocks,\n                       \u0026lz77splitpoints, \u0026nlz77points);\n\n  /* Convert LZ77 positions to positions in the uncompressed input. */\n  pos = instart;\n  if (nlz77points \u003e 0) {\n    for (i = 0; i \u003c store.size; i++) {\n      size_t length = store.dists[i] == 0 ? 1 : store.litlens[i];\n      if (lz77splitpoints[*npoints] == i) {\n        ZOPFLI_APPEND_DATA(pos, splitpoints, npoints);\n        if (*npoints == nlz77points) break;\n      }\n      pos += length;\n    }\n  }\n  assert(*npoints == nlz77points);\n\n  free(lz77splitpoints);\n  ZopfliCleanBlockState(\u0026s);\n  ZopfliCleanLZ77Store(\u0026store);\n  ZopfliCleanHash(h);\n}","filepath":"src/zopfli/blocksplitter.c","line_number":275,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3126016":{"score":0.8236977,"function_name":"ZopfliBlockSplitSimple","code":"void ZopfliBlockSplitSimple(const unsigned char* in,\n                            size_t instart, size_t inend,\n                            size_t blocksize,\n                            size_t** splitpoints, size_t* npoints) {\n  size_t i = instart;\n  while (i \u003c inend) {\n    ZOPFLI_APPEND_DATA(i, splitpoints, npoints);\n    i += blocksize;\n  }\n  (void)in;\n}","filepath":"src/zopfli/blocksplitter.c","line_number":322,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3126192":{"score":0.88971937,"function_name":"ZopfliInitCache","code":"void ZopfliInitCache(size_t blocksize, ZopfliLongestMatchCache* lmc) {\n  size_t i;\n  lmc-\u003elength = (unsigned short*)malloc(sizeof(unsigned short) * blocksize);\n  lmc-\u003edist = (unsigned short*)malloc(sizeof(unsigned short) * blocksize);\n  /* Rather large amount of memory. */\n  lmc-\u003esublen = (unsigned char*)malloc(ZOPFLI_CACHE_LENGTH * 3 * blocksize);\n  if(lmc-\u003esublen == NULL) {\n    fprintf(stderr,\"Error: Out of memory. Tried allocating %lu bytes of memory.\\n\",(unsigned long)(ZOPFLI_CACHE_LENGTH * 3 * blocksize));\n    exit (EXIT_FAILURE);\n  }\n\n  /* length \u003e 0 and dist 0 is invalid combination, which indicates on purpose\n  that this cache value is not filled in yet. */\n  for (i = 0; i \u003c blocksize; i++) lmc-\u003elength[i] = 1;\n  for (i = 0; i \u003c blocksize; i++) lmc-\u003edist[i] = 0;\n  for (i = 0; i \u003c ZOPFLI_CACHE_LENGTH * blocksize * 3; i++) lmc-\u003esublen[i] = 0;\n}","filepath":"src/zopfli/cache.c","line_number":28,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.1"},"3126576":{"score":0.7310598,"function_name":"ZopfliSublenToCache","code":"void ZopfliSublenToCache(const unsigned short* sublen,\n                         size_t pos, size_t length,\n                         ZopfliLongestMatchCache* lmc) {\n  size_t i;\n  size_t j = 0;\n  unsigned bestlength = 0;\n  unsigned char* cache;\n\n#if ZOPFLI_CACHE_LENGTH == 0\n  return;\n#endif\n\n  cache = \u0026lmc-\u003esublen[ZOPFLI_CACHE_LENGTH * pos * 3];\n  if (length \u003c 3) return;\n  for (i = 3; i \u003c= length; i++) {\n    if (i == length || sublen[i] != sublen[i + 1]) {\n      cache[j * 3] = i - 3;\n      cache[j * 3 + 1] = sublen[i] % 256;\n      cache[j * 3 + 2] = (sublen[i] \u003e\u003e 8) % 256;\n      bestlength = i;\n      j++;\n      if (j \u003e= ZOPFLI_CACHE_LENGTH) break;\n    }\n  }\n  if (j \u003c ZOPFLI_CACHE_LENGTH) {\n    assert(bestlength == length);\n    cache[(ZOPFLI_CACHE_LENGTH - 1) * 3] = bestlength - 3;\n  } else {\n    assert(bestlength \u003c= length);\n  }\n  assert(bestlength == ZopfliMaxCachedSublen(lmc, pos, length));\n}","filepath":"src/zopfli/cache.c","line_number":52,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.1"},"3126720":{"score":0.6922842,"function_name":"ZopfliCacheToSublen","code":"void ZopfliCacheToSublen(const ZopfliLongestMatchCache* lmc,\n                         size_t pos, size_t length,\n                         unsigned short* sublen) {\n  size_t i, j;\n  unsigned maxlength = ZopfliMaxCachedSublen(lmc, pos, length);\n  unsigned prevlength = 0;\n  unsigned char* cache;\n#if ZOPFLI_CACHE_LENGTH == 0\n  return;\n#endif\n  if (length \u003c 3) return;\n  cache = \u0026lmc-\u003esublen[ZOPFLI_CACHE_LENGTH * pos * 3];\n  for (j = 0; j \u003c ZOPFLI_CACHE_LENGTH; j++) {\n    unsigned length = cache[j * 3] + 3;\n    unsigned dist = cache[j * 3 + 1] + 256 * cache[j * 3 + 2];\n    for (i = prevlength; i \u003c= length; i++) {\n      sublen[i] = dist;\n    }\n    if (length == maxlength) break;\n    prevlength = length + 1;\n  }\n}","filepath":"src/zopfli/cache.c","line_number":85,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.1"},"3127104":{"score":0.69242144,"function_name":"ZopfliMaxCachedSublen","code":"unsigned ZopfliMaxCachedSublen(const ZopfliLongestMatchCache* lmc,\n                               size_t pos, size_t length) {\n  unsigned char* cache;\n#if ZOPFLI_CACHE_LENGTH == 0\n  return 0;\n#endif\n  cache = \u0026lmc-\u003esublen[ZOPFLI_CACHE_LENGTH * pos * 3];\n  (void)length;\n  if (cache[1] == 0 \u0026\u0026 cache[2] == 0) return 0;  /* No sublen cached. */\n  return cache[(ZOPFLI_CACHE_LENGTH - 1) * 3] + 3;\n}","filepath":"src/zopfli/cache.c","line_number":111,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.1"},"3127152":{"score":0.9013636,"function_name":"AddHuffmanBits","code":"static void AddHuffmanBits(unsigned symbol, unsigned length,\n                           unsigned char* bp, unsigned char** out,\n                           size_t* outsize) {\n  /* TODO(lode): make more efficient (add more bits at once). */\n  unsigned i;\n  for (i = 0; i \u003c length; i++) {\n    unsigned bit = (symbol \u003e\u003e (length - i - 1)) \u0026 1;\n    if (*bp == 0) ZOPFLI_APPEND_DATA(0, out, outsize);\n    (*out)[*outsize - 1] |= bit \u003c\u003c *bp;\n    *bp = (*bp + 1) \u0026 7;\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":61,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3127360":{"score":0.8746616,"function_name":"AddBits","code":"static void AddBits(unsigned symbol, unsigned length,\n                    unsigned char* bp, unsigned char** out, size_t* outsize) {\n  /* TODO(lode): make more efficient (add more bits at once). */\n  unsigned i;\n  for (i = 0; i \u003c length; i++) {\n    unsigned bit = (symbol \u003e\u003e i) \u0026 1;\n    if (*bp == 0) ZOPFLI_APPEND_DATA(0, out, outsize);\n    (*out)[*outsize - 1] |= bit \u003c\u003c *bp;\n    *bp = (*bp + 1) \u0026 7;\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":45,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3131328":{"score":0.6627087,"function_name":"AddHuffmanBits","code":"static void AddHuffmanBits(unsigned symbol, unsigned length,\n                           unsigned char* bp, unsigned char** out,\n                           size_t* outsize) {\n  /* TODO(lode): make more efficient (add more bits at once). */\n  unsigned i;\n  for (i = 0; i \u003c length; i++) {\n    unsigned bit = (symbol \u003e\u003e (length - i - 1)) \u0026 1;\n    if (*bp == 0) ZOPFLI_APPEND_DATA(0, out, outsize);\n    (*out)[*outsize - 1] |= bit \u003c\u003c *bp;\n    *bp = (*bp + 1) \u0026 7;\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":61,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3131536":{"score":0.6889224,"function_name":"AddHuffmanBits","code":"static void AddHuffmanBits(unsigned symbol, unsigned length,\n                           unsigned char* bp, unsigned char** out,\n                           size_t* outsize) {\n  /* TODO(lode): make more efficient (add more bits at once). */\n  unsigned i;\n  for (i = 0; i \u003c length; i++) {\n    unsigned bit = (symbol \u003e\u003e (length - i - 1)) \u0026 1;\n    if (*bp == 0) ZOPFLI_APPEND_DATA(0, out, outsize);\n    (*out)[*outsize - 1] |= bit \u003c\u003c *bp;\n    *bp = (*bp + 1) \u0026 7;\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":61,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3131744":{"score":0.6613748,"function_name":"AddHuffmanBits","code":"static void AddHuffmanBits(unsigned symbol, unsigned length,\n                           unsigned char* bp, unsigned char** out,\n                           size_t* outsize) {\n  /* TODO(lode): make more efficient (add more bits at once). */\n  unsigned i;\n  for (i = 0; i \u003c length; i++) {\n    unsigned bit = (symbol \u003e\u003e (length - i - 1)) \u0026 1;\n    if (*bp == 0) ZOPFLI_APPEND_DATA(0, out, outsize);\n    (*out)[*outsize - 1] |= bit \u003c\u003c *bp;\n    *bp = (*bp + 1) \u0026 7;\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":61,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3131952":{"score":0.6657102,"function_name":"AddHuffmanBits","code":"static void AddHuffmanBits(unsigned symbol, unsigned length,\n                           unsigned char* bp, unsigned char** out,\n                           size_t* outsize) {\n  /* TODO(lode): make more efficient (add more bits at once). */\n  unsigned i;\n  for (i = 0; i \u003c length; i++) {\n    unsigned bit = (symbol \u003e\u003e (length - i - 1)) \u0026 1;\n    if (*bp == 0) ZOPFLI_APPEND_DATA(0, out, outsize);\n    (*out)[*outsize - 1] |= bit \u003c\u003c *bp;\n    *bp = (*bp + 1) \u0026 7;\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":61,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3132496":{"score":0.66754955,"function_name":"GetDynamicLengths","code":"static double GetDynamicLengths(const ZopfliLZ77Store* lz77,\n                                size_t lstart, size_t lend,\n                                unsigned* ll_lengths, unsigned* d_lengths) {\n  size_t ll_counts[ZOPFLI_NUM_LL];\n  size_t d_counts[ZOPFLI_NUM_D];\n\n  ZopfliLZ77GetHistogram(lz77, lstart, lend, ll_counts, d_counts);\n  ll_counts[256] = 1;  /* End symbol. */\n  ZopfliCalculateBitLengths(ll_counts, ZOPFLI_NUM_LL, 15, ll_lengths);\n  ZopfliCalculateBitLengths(d_counts, ZOPFLI_NUM_D, 15, d_lengths);\n  PatchDistanceCodesForBuggyDecoders(d_lengths);\n  return TryOptimizeHuffmanForRle(\n      lz77, lstart, lend, ll_counts, d_counts, ll_lengths, d_lengths);\n}","filepath":"src/zopfli/deflate.c","line_number":569,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3136480":{"score":0.8020942,"function_name":"AddNonCompressedBlock","code":"static void AddNonCompressedBlock(const ZopfliOptions* options, int final,\n                                  const unsigned char* in, size_t instart,\n                                  size_t inend,\n                                  unsigned char* bp,\n                                  unsigned char** out, size_t* outsize) {\n  size_t pos = instart;\n  (void)options;\n  for (;;) {\n    size_t i;\n    unsigned short blocksize = 65535;\n    unsigned short nlen;\n    int currentfinal;\n\n    if (pos + blocksize \u003e inend) blocksize = inend - pos;\n    currentfinal = pos + blocksize \u003e= inend;\n\n    nlen = ~blocksize;\n\n    AddBit(final \u0026\u0026 currentfinal, bp, out, outsize);\n    /* BTYPE 00 */\n    AddBit(0, bp, out, outsize);\n    AddBit(0, bp, out, outsize);\n\n    /* Any bits of input up to the next byte boundary are ignored. */\n    *bp = 0;\n\n    ZOPFLI_APPEND_DATA(blocksize % 256, out, outsize);\n    ZOPFLI_APPEND_DATA((blocksize / 256) % 256, out, outsize);\n    ZOPFLI_APPEND_DATA(nlen % 256, out, outsize);\n    ZOPFLI_APPEND_DATA((nlen / 256) % 256, out, outsize);\n\n    for (i = 0; i \u003c blocksize; i++) {\n      ZOPFLI_APPEND_DATA(in[pos + i], out, outsize);\n    }\n\n    if (currentfinal) break;\n    pos += blocksize;\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":625,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3137504":{"score":0.6845045,"function_name":"AddLZ77Block","code":"static void AddLZ77Block(const ZopfliOptions* options, int btype, int final,\n                         const ZopfliLZ77Store* lz77,\n                         size_t lstart, size_t lend,\n                         size_t expected_data_size,\n                         unsigned char* bp,\n                         unsigned char** out, size_t* outsize) {\n  unsigned ll_lengths[ZOPFLI_NUM_LL];\n  unsigned d_lengths[ZOPFLI_NUM_D];\n  unsigned ll_symbols[ZOPFLI_NUM_LL];\n  unsigned d_symbols[ZOPFLI_NUM_D];\n  size_t detect_block_size = *outsize;\n  size_t compressed_size;\n  size_t uncompressed_size = 0;\n  size_t i;\n  if (btype == 0) {\n    size_t length = ZopfliLZ77GetByteRange(lz77, lstart, lend);\n    size_t pos = lstart == lend ? 0 : lz77-\u003epos[lstart];\n    size_t end = pos + length;\n    AddNonCompressedBlock(options, final,\n                          lz77-\u003edata, pos, end, bp, out, outsize);\n    return;\n  }\n\n  AddBit(final, bp, out, outsize);\n  AddBit(btype \u0026 1, bp, out, outsize);\n  AddBit((btype \u0026 2) \u003e\u003e 1, bp, out, outsize);\n\n  if (btype == 1) {\n    /* Fixed block. */\n    GetFixedTree(ll_lengths, d_lengths);\n  } else {\n    /* Dynamic block. */\n    unsigned detect_tree_size;\n    assert(btype == 2);\n\n    GetDynamicLengths(lz77, lstart, lend, ll_lengths, d_lengths);\n\n    detect_tree_size = *outsize;\n    AddDynamicTree(ll_lengths, d_lengths, bp, out, outsize);\n    if (options-\u003everbose) {\n      fprintf(stderr, \"treesize: %d\\n\", (int)(*outsize - detect_tree_size));\n    }\n  }\n\n  ZopfliLengthsToSymbols(ll_lengths, ZOPFLI_NUM_LL, 15, ll_symbols);\n  ZopfliLengthsToSymbols(d_lengths, ZOPFLI_NUM_D, 15, d_symbols);\n\n  detect_block_size = *outsize;\n  AddLZ77Data(lz77, lstart, lend, expected_data_size,\n              ll_symbols, ll_lengths, d_symbols, d_lengths,\n              bp, out, outsize);\n  /* End symbol. */\n  AddHuffmanBits(ll_symbols[256], ll_lengths[256], bp, out, outsize);\n\n  for (i = lstart; i \u003c lend; i++) {\n    uncompressed_size += lz77-\u003edists[i] == 0 ? 1 : lz77-\u003elitlens[i];\n  }\n  compressed_size = *outsize - detect_block_size;\n  if (options-\u003everbose) {\n    fprintf(stderr, \"compressed block size: %d (%dk) (unc: %d)\\n\",\n           (int)compressed_size, (int)(compressed_size / 1024),\n           (int)(uncompressed_size));\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":682,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3142304":{"score":0.9179534,"function_name":"OptimizeHuffmanForRle","code":"void OptimizeHuffmanForRle(int length, size_t* counts) {\n  int i, k, stride;\n  size_t symbol, sum, limit;\n  int* good_for_rle;\n\n  /* 1) We don't want to touch the trailing zeros. We may break the\n  rules of the format by adding more data in the distance codes. */\n  for (; length \u003e= 0; --length) {\n    if (length == 0) {\n      return;\n    }\n    if (counts[length - 1] != 0) {\n      /* Now counts[0..length - 1] does not have trailing zeros. */\n      break;\n    }\n  }\n  /* 2) Let's mark all population counts that already can be encoded\n  with an rle code.*/\n  good_for_rle = (int*)malloc((unsigned)length * sizeof(int));\n  for (i = 0; i \u003c length; ++i) good_for_rle[i] = 0;\n\n  /* Let's not spoil any of the existing good rle codes.\n  Mark any seq of 0's that is longer than 5 as a good_for_rle.\n  Mark any seq of non-0's that is longer than 7 as a good_for_rle.*/\n  symbol = counts[0];\n  stride = 0;\n  for (i = 0; i \u003c length + 1; ++i) {\n    if (i == length || counts[i] != symbol) {\n      if ((symbol == 0 \u0026\u0026 stride \u003e= 5) || (symbol != 0 \u0026\u0026 stride \u003e= 7)) {\n        for (k = 0; k \u003c stride; ++k) {\n          good_for_rle[i - k - 1] = 1;\n        }\n      }\n      stride = 1;\n      if (i != length) {\n        symbol = counts[i];\n      }\n    } else {\n      ++stride;\n    }\n  }\n\n  /* 3) Let's replace those population counts that lead to more rle codes. */\n  stride = 0;\n  limit = counts[0];\n  sum = 0;\n  for (i = 0; i \u003c length + 1; ++i) {\n    if (i == length || good_for_rle[i]\n        /* Heuristic for selecting the stride ranges to collapse. */\n        || AbsDiff(counts[i], limit) \u003e= 4) {\n      if (stride \u003e= 4 || (stride \u003e= 3 \u0026\u0026 sum == 0)) {\n        /* The stride must end, collapse what we have, if we have enough (4). */\n        int count = (sum + stride / 2) / stride;\n        if (count \u003c 1) count = 1;\n        if (sum == 0) {\n          /* Don't make an all zeros stride to be upgraded to ones. */\n          count = 0;\n        }\n        for (k = 0; k \u003c stride; ++k) {\n          /* We don't want to change value at counts[i],\n          that is already belonging to the next stride. Thus - 1. */\n          counts[i - k - 1] = count;\n        }\n      }\n      stride = 0;\n      sum = 0;\n      if (i \u003c length - 3) {\n        /* All interesting strides have a count of at least 4,\n        at least when non-zeros. */\n        limit = (counts[i] + counts[i + 1] +\n                 counts[i + 2] + counts[i + 3] + 2) / 4;\n      } else if (i \u003c length) {\n        limit = counts[i];\n      } else {\n        limit = 0;\n      }\n    }\n    ++stride;\n    if (i != length) {\n      sum += counts[i];\n    }\n  }\n\n  free(good_for_rle);\n}","filepath":"src/zopfli/deflate.c","line_number":434,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3143472":{"score":0.6656772,"function_name":"ZopfliCalculateBlockSize","code":"double ZopfliCalculateBlockSize(const ZopfliLZ77Store* lz77,\n                                size_t lstart, size_t lend, int btype) {\n  unsigned ll_lengths[ZOPFLI_NUM_LL];\n  unsigned d_lengths[ZOPFLI_NUM_D];\n\n  double result = 3; /* bfinal and btype bits */\n\n  if (btype == 0) {\n    size_t length = ZopfliLZ77GetByteRange(lz77, lstart, lend);\n    size_t rem = length % 65535;\n    size_t blocks = length / 65535 + (rem ? 1 : 0);\n    /* An uncompressed block must actually be split into multiple blocks if it's\n       larger than 65535 bytes long. Eeach block header is 5 bytes: 3 bits,\n       padding, LEN and NLEN (potential less padding for first one ignored). */\n    return blocks * 5 * 8 + length * 8;\n  } if (btype == 1) {\n    GetFixedTree(ll_lengths, d_lengths);\n    result += CalculateBlockSymbolSize(\n        ll_lengths, d_lengths, lz77, lstart, lend);\n  } else {\n    result += GetDynamicLengths(lz77, lstart, lend, ll_lengths, d_lengths);\n  }\n\n  return result;\n}","filepath":"src/zopfli/deflate.c","line_number":584,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3144016":{"score":0.7728681,"function_name":"ZopfliCalculateBlockSizeAutoType","code":"double ZopfliCalculateBlockSizeAutoType(const ZopfliLZ77Store* lz77,\n                                        size_t lstart, size_t lend) {\n  double uncompressedcost = ZopfliCalculateBlockSize(lz77, lstart, lend, 0);\n  /* Don't do the expensive fixed cost calculation for larger blocks that are\n     unlikely to use it. */\n  double fixedcost = (lz77-\u003esize \u003e 1000) ?\n      uncompressedcost : ZopfliCalculateBlockSize(lz77, lstart, lend, 1);\n  double dyncost = ZopfliCalculateBlockSize(lz77, lstart, lend, 2);\n  return (uncompressedcost \u003c fixedcost \u0026\u0026 uncompressedcost \u003c dyncost)\n      ? uncompressedcost\n      : (fixedcost \u003c dyncost ? fixedcost : dyncost);\n}","filepath":"src/zopfli/deflate.c","line_number":610,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3144192":{"score":0.88341814,"function_name":"ZopfliDeflatePart","code":"void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,\n                       const unsigned char* in, size_t instart, size_t inend,\n                       unsigned char* bp, unsigned char** out,\n                       size_t* outsize) {\n  size_t i;\n  /* byte coordinates rather than lz77 index */\n  size_t* splitpoints_uncompressed = 0;\n  size_t npoints = 0;\n  size_t* splitpoints = 0;\n  double totalcost = 0;\n  ZopfliLZ77Store lz77;\n\n  /* If btype=2 is specified, it tries all block types. If a lesser btype is\n  given, then however it forces that one. Neither of the lesser types needs\n  block splitting as they have no dynamic huffman trees. */\n  if (btype == 0) {\n    AddNonCompressedBlock(options, final, in, instart, inend, bp, out, outsize);\n    return;\n  } else if (btype == 1) {\n    ZopfliLZ77Store store;\n    ZopfliBlockState s;\n    ZopfliInitLZ77Store(in, \u0026store);\n    ZopfliInitBlockState(options, instart, inend, 1, \u0026s);\n\n    ZopfliLZ77OptimalFixed(\u0026s, in, instart, inend, \u0026store);\n    AddLZ77Block(options, btype, final, \u0026store, 0, store.size, 0,\n                 bp, out, outsize);\n\n    ZopfliCleanBlockState(\u0026s);\n    ZopfliCleanLZ77Store(\u0026store);\n    return;\n  }\n\n\n  if (options-\u003eblocksplitting) {\n    ZopfliBlockSplit(options, in, instart, inend,\n                     options-\u003eblocksplittingmax,\n                     \u0026splitpoints_uncompressed, \u0026npoints);\n    splitpoints = (size_t*)malloc(sizeof(*splitpoints) * npoints);\n  }\n\n  ZopfliInitLZ77Store(in, \u0026lz77);\n\n  for (i = 0; i \u003c= npoints; i++) {\n    size_t start = i == 0 ? instart : splitpoints_uncompressed[i - 1];\n    size_t end = i == npoints ? inend : splitpoints_uncompressed[i];\n    ZopfliBlockState s;\n    ZopfliLZ77Store store;\n    ZopfliInitLZ77Store(in, \u0026store);\n    ZopfliInitBlockState(options, start, end, 1, \u0026s);\n    ZopfliLZ77Optimal(\u0026s, in, start, end, options-\u003enumiterations, \u0026store);\n    totalcost += ZopfliCalculateBlockSizeAutoType(\u0026store, 0, store.size);\n\n    ZopfliAppendLZ77Store(\u0026store, \u0026lz77);\n    if (i \u003c npoints) splitpoints[i] = lz77.size;\n\n    ZopfliCleanBlockState(\u0026s);\n    ZopfliCleanLZ77Store(\u0026store);\n  }\n\n  /* Second block splitting attempt */\n  if (options-\u003eblocksplitting \u0026\u0026 npoints \u003e 1) {\n    size_t* splitpoints2 = 0;\n    size_t npoints2 = 0;\n    double totalcost2 = 0;\n\n    ZopfliBlockSplitLZ77(options, \u0026lz77,\n                         options-\u003eblocksplittingmax, \u0026splitpoints2, \u0026npoints2);\n\n    for (i = 0; i \u003c= npoints2; i++) {\n      size_t start = i == 0 ? 0 : splitpoints2[i - 1];\n      size_t end = i == npoints2 ? lz77.size : splitpoints2[i];\n      totalcost2 += ZopfliCalculateBlockSizeAutoType(\u0026lz77, start, end);\n    }\n\n    if (totalcost2 \u003c totalcost) {\n      free(splitpoints);\n      splitpoints = splitpoints2;\n      npoints = npoints2;\n    } else {\n      free(splitpoints2);\n    }\n  }\n\n  for (i = 0; i \u003c= npoints; i++) {\n    size_t start = i == 0 ? 0 : splitpoints[i - 1];\n    size_t end = i == npoints ? lz77.size : splitpoints[i];\n    AddLZ77BlockAutoType(options, i == npoints \u0026\u0026 final,\n                         \u0026lz77, start, end, 0,\n                         bp, out, outsize);\n  }\n\n  ZopfliCleanLZ77Store(\u0026lz77);\n  free(splitpoints);\n  free(splitpoints_uncompressed);\n}","filepath":"src/zopfli/deflate.c","line_number":811,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3147040":{"score":0.7978529,"function_name":"ZopfliDeflate","code":"void ZopfliDeflate(const ZopfliOptions* options, int btype, int final,\n                   const unsigned char* in, size_t insize,\n                   unsigned char* bp, unsigned char** out, size_t* outsize) {\n size_t offset = *outsize;\n#if ZOPFLI_MASTER_BLOCK_SIZE == 0\n  ZopfliDeflatePart(options, btype, final, in, 0, insize, bp, out, outsize);\n#else\n  size_t i = 0;\n  do {\n    int masterfinal = (i + ZOPFLI_MASTER_BLOCK_SIZE \u003e= insize);\n    int final2 = final \u0026\u0026 masterfinal;\n    size_t size = masterfinal ? insize - i : ZOPFLI_MASTER_BLOCK_SIZE;\n    ZopfliDeflatePart(options, btype, final2,\n                      in, i, i + size, bp, out, outsize);\n    i += size;\n  } while (i \u003c insize);\n#endif\n  if (options-\u003everbose) {\n    fprintf(stderr,\n            \"Original Size: %lu, Deflate: %lu, Compression: %f%% Removed\\n\",\n            (unsigned long)insize, (unsigned long)(*outsize - offset),\n            100.0 * (double)(insize - (*outsize - offset)) / (double)insize);\n  }\n}","filepath":"src/zopfli/deflate.c","line_number":908,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.3"},"3149584":{"score":0.7664278,"function_name":"ZopfliAllocHash","code":"void ZopfliAllocHash(size_t window_size, ZopfliHash* h) {\n  h-\u003ehead = (int*)malloc(sizeof(*h-\u003ehead) * 65536);\n  h-\u003eprev = (unsigned short*)malloc(sizeof(*h-\u003eprev) * window_size);\n  h-\u003ehashval = (int*)malloc(sizeof(*h-\u003ehashval) * window_size);\n\n#ifdef ZOPFLI_HASH_SAME\n  h-\u003esame = (unsigned short*)malloc(sizeof(*h-\u003esame) * window_size);\n#endif\n\n#ifdef ZOPFLI_HASH_SAME_HASH\n  h-\u003ehead2 = (int*)malloc(sizeof(*h-\u003ehead2) * 65536);\n  h-\u003eprev2 = (unsigned short*)malloc(sizeof(*h-\u003eprev2) * window_size);\n  h-\u003ehashval2 = (int*)malloc(sizeof(*h-\u003ehashval2) * window_size);\n#endif\n}","filepath":"src/zopfli/hash.c","line_number":29,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3149696":{"score":0.77538127,"function_name":"ZopfliResetHash","code":"void ZopfliResetHash(size_t window_size, ZopfliHash* h) {\n  size_t i;\n\n  h-\u003eval = 0;\n  for (i = 0; i \u003c 65536; i++) {\n    h-\u003ehead[i] = -1;  /* -1 indicates no head so far. */\n  }\n  for (i = 0; i \u003c window_size; i++) {\n    h-\u003eprev[i] = i;  /* If prev[j] == j, then prev[j] is uninitialized. */\n    h-\u003ehashval[i] = -1;\n  }\n\n#ifdef ZOPFLI_HASH_SAME\n  for (i = 0; i \u003c window_size; i++) {\n    h-\u003esame[i] = 0;\n  }\n#endif\n\n#ifdef ZOPFLI_HASH_SAME_HASH\n  h-\u003eval2 = 0;\n  for (i = 0; i \u003c 65536; i++) {\n    h-\u003ehead2[i] = -1;\n  }\n  for (i = 0; i \u003c window_size; i++) {\n    h-\u003eprev2[i] = i;\n    h-\u003ehashval2[i] = -1;\n  }\n#endif\n}","filepath":"src/zopfli/hash.c","line_number":45,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3150672":{"score":0.8870678,"function_name":"ZopfliCleanLZ77Store","code":"void ZopfliCleanLZ77Store(ZopfliLZ77Store* store) {\n  free(store-\u003elitlens);\n  free(store-\u003edists);\n  free(store-\u003epos);\n  free(store-\u003ell_symbol);\n  free(store-\u003ed_symbol);\n  free(store-\u003ell_counts);\n  free(store-\u003ed_counts);\n}","filepath":"src/zopfli/lz77.c","line_number":40,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3150752":{"score":0.78757,"function_name":"ZopfliUpdateHash","code":"void ZopfliUpdateHash(const unsigned char* array, size_t pos, size_t end,\n                ZopfliHash* h) {\n  unsigned short hpos = pos \u0026 ZOPFLI_WINDOW_MASK;\n#ifdef ZOPFLI_HASH_SAME\n  size_t amount = 0;\n#endif\n\n  UpdateHashValue(h, pos + ZOPFLI_MIN_MATCH \u003c= end ?\n      array[pos + ZOPFLI_MIN_MATCH - 1] : 0);\n  h-\u003ehashval[hpos] = h-\u003eval;\n  if (h-\u003ehead[h-\u003eval] != -1 \u0026\u0026 h-\u003ehashval[h-\u003ehead[h-\u003eval]] == h-\u003eval) {\n    h-\u003eprev[hpos] = h-\u003ehead[h-\u003eval];\n  }\n  else h-\u003eprev[hpos] = hpos;\n  h-\u003ehead[h-\u003eval] = hpos;\n\n#ifdef ZOPFLI_HASH_SAME\n  /* Update \"same\". */\n  if (h-\u003esame[(pos - 1) \u0026 ZOPFLI_WINDOW_MASK] \u003e 1) {\n    amount = h-\u003esame[(pos - 1) \u0026 ZOPFLI_WINDOW_MASK] - 1;\n  }\n  while (pos + amount + 1 \u003c end \u0026\u0026\n      array[pos] == array[pos + amount + 1] \u0026\u0026 amount \u003c (unsigned short)(-1)) {\n    amount++;\n  }\n  h-\u003esame[hpos] = amount;\n#endif\n\n#ifdef ZOPFLI_HASH_SAME_HASH\n  h-\u003eval2 = ((h-\u003esame[hpos] - ZOPFLI_MIN_MATCH) \u0026 255) ^ h-\u003eval;\n  h-\u003ehashval2[hpos] = h-\u003eval2;\n  if (h-\u003ehead2[h-\u003eval2] != -1 \u0026\u0026 h-\u003ehashval2[h-\u003ehead2[h-\u003eval2]] == h-\u003eval2) {\n    h-\u003eprev2[hpos] = h-\u003ehead2[h-\u003eval2];\n  }\n  else h-\u003eprev2[hpos] = hpos;\n  h-\u003ehead2[h-\u003eval2] = hpos;\n#endif\n}","filepath":"src/zopfli/hash.c","line_number":100,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3151184":{"score":0.68146515,"function_name":"ZopfliLZ77GetHistogramAt","code":"static void ZopfliLZ77GetHistogramAt(const ZopfliLZ77Store* lz77, size_t lpos,\n                                     size_t* ll_counts, size_t* d_counts) {\n  /* The real histogram is created by using the histogram for this chunk, but\n  all superfluous values of this chunk subtracted. */\n  size_t llpos = ZOPFLI_NUM_LL * (lpos / ZOPFLI_NUM_LL);\n  size_t dpos = ZOPFLI_NUM_D * (lpos / ZOPFLI_NUM_D);\n  size_t i;\n  for (i = 0; i \u003c ZOPFLI_NUM_LL; i++) {\n    ll_counts[i] = lz77-\u003ell_counts[llpos + i];\n  }\n  for (i = lpos + 1; i \u003c llpos + ZOPFLI_NUM_LL \u0026\u0026 i \u003c lz77-\u003esize; i++) {\n    ll_counts[lz77-\u003ell_symbol[i]]--;\n  }\n  for (i = 0; i \u003c ZOPFLI_NUM_D; i++) {\n    d_counts[i] = lz77-\u003ed_counts[dpos + i];\n  }\n  for (i = lpos + 1; i \u003c dpos + ZOPFLI_NUM_D \u0026\u0026 i \u003c lz77-\u003esize; i++) {\n    if (lz77-\u003edists[i] != 0) d_counts[lz77-\u003ed_symbol[i]]--;\n  }\n}","filepath":"src/zopfli/lz77.c","line_number":168,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3151696":{"score":0.81868774,"function_name":"ZopfliInitLZ77Store","code":"void ZopfliInitLZ77Store(const unsigned char* data, ZopfliLZ77Store* store) {\n  store-\u003esize = 0;\n  store-\u003elitlens = 0;\n  store-\u003edists = 0;\n  store-\u003epos = 0;\n  store-\u003edata = data;\n  store-\u003ell_symbol = 0;\n  store-\u003ed_symbol = 0;\n  store-\u003ell_counts = 0;\n  store-\u003ed_counts = 0;\n}","filepath":"src/zopfli/lz77.c","line_number":28,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3151760":{"score":0.8861286,"function_name":"ZopfliCleanLZ77Store","code":"void ZopfliCleanLZ77Store(ZopfliLZ77Store* store) {\n  free(store-\u003elitlens);\n  free(store-\u003edists);\n  free(store-\u003epos);\n  free(store-\u003ell_symbol);\n  free(store-\u003ed_symbol);\n  free(store-\u003ell_counts);\n  free(store-\u003ed_counts);\n}","filepath":"src/zopfli/lz77.c","line_number":40,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3151840":{"score":0.7999985,"function_name":"ZopfliCopyLZ77Store","code":"void ZopfliCopyLZ77Store(\n    const ZopfliLZ77Store* source, ZopfliLZ77Store* dest) {\n  size_t i;\n  size_t llsize = ZOPFLI_NUM_LL * CeilDiv(source-\u003esize, ZOPFLI_NUM_LL);\n  size_t dsize = ZOPFLI_NUM_D * CeilDiv(source-\u003esize, ZOPFLI_NUM_D);\n  ZopfliCleanLZ77Store(dest);\n  ZopfliInitLZ77Store(source-\u003edata, dest);\n  dest-\u003elitlens =\n      (unsigned short*)malloc(sizeof(*dest-\u003elitlens) * source-\u003esize);\n  dest-\u003edists = (unsigned short*)malloc(sizeof(*dest-\u003edists) * source-\u003esize);\n  dest-\u003epos = (size_t*)malloc(sizeof(*dest-\u003epos) * source-\u003esize);\n  dest-\u003ell_symbol =\n      (unsigned short*)malloc(sizeof(*dest-\u003ell_symbol) * source-\u003esize);\n  dest-\u003ed_symbol =\n      (unsigned short*)malloc(sizeof(*dest-\u003ed_symbol) * source-\u003esize);\n  dest-\u003ell_counts = (size_t*)malloc(sizeof(*dest-\u003ell_counts) * llsize);\n  dest-\u003ed_counts = (size_t*)malloc(sizeof(*dest-\u003ed_counts) * dsize);\n\n  /* Allocation failed. */\n  if (!dest-\u003elitlens || !dest-\u003edists) exit(-1);\n  if (!dest-\u003epos) exit(-1);\n  if (!dest-\u003ell_symbol || !dest-\u003ed_symbol) exit(-1);\n  if (!dest-\u003ell_counts || !dest-\u003ed_counts) exit(-1);\n\n  dest-\u003esize = source-\u003esize;\n  for (i = 0; i \u003c source-\u003esize; i++) {\n    dest-\u003elitlens[i] = source-\u003elitlens[i];\n    dest-\u003edists[i] = source-\u003edists[i];\n    dest-\u003epos[i] = source-\u003epos[i];\n    dest-\u003ell_symbol[i] = source-\u003ell_symbol[i];\n    dest-\u003ed_symbol[i] = source-\u003ed_symbol[i];\n  }\n  for (i = 0; i \u003c llsize; i++) {\n    dest-\u003ell_counts[i] = source-\u003ell_counts[i];\n  }\n  for (i = 0; i \u003c dsize; i++) {\n    dest-\u003ed_counts[i] = source-\u003ed_counts[i];\n  }\n}","filepath":"src/zopfli/lz77.c","line_number":54,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3152592":{"score":0.72101384,"function_name":"ZopfliStoreLitLenDist","code":"void ZopfliStoreLitLenDist(unsigned short length, unsigned short dist,\n                           size_t pos, ZopfliLZ77Store* store) {\n  size_t i;\n  /* Needed for using ZOPFLI_APPEND_DATA multiple times. */\n  size_t origsize = store-\u003esize;\n  size_t llstart = ZOPFLI_NUM_LL * (origsize / ZOPFLI_NUM_LL);\n  size_t dstart = ZOPFLI_NUM_D * (origsize / ZOPFLI_NUM_D);\n\n  /* Everytime the index wraps around, a new cumulative histogram is made: we're\n  keeping one histogram value per LZ77 symbol rather than a full histogram for\n  each to save memory. */\n  if (origsize % ZOPFLI_NUM_LL == 0) {\n    size_t llsize = origsize;\n    for (i = 0; i \u003c ZOPFLI_NUM_LL; i++) {\n      ZOPFLI_APPEND_DATA(\n          origsize == 0 ? 0 : store-\u003ell_counts[origsize - ZOPFLI_NUM_LL + i],\n          \u0026store-\u003ell_counts, \u0026llsize);\n    }\n  }\n  if (origsize % ZOPFLI_NUM_D == 0) {\n    size_t dsize = origsize;\n    for (i = 0; i \u003c ZOPFLI_NUM_D; i++) {\n      ZOPFLI_APPEND_DATA(\n          origsize == 0 ? 0 : store-\u003ed_counts[origsize - ZOPFLI_NUM_D + i],\n          \u0026store-\u003ed_counts, \u0026dsize);\n    }\n  }\n\n  ZOPFLI_APPEND_DATA(length, \u0026store-\u003elitlens, \u0026store-\u003esize);\n  store-\u003esize = origsize;\n  ZOPFLI_APPEND_DATA(dist, \u0026store-\u003edists, \u0026store-\u003esize);\n  store-\u003esize = origsize;\n  ZOPFLI_APPEND_DATA(pos, \u0026store-\u003epos, \u0026store-\u003esize);\n  assert(length \u003c 259);\n\n  if (dist == 0) {\n    store-\u003esize = origsize;\n    ZOPFLI_APPEND_DATA(length, \u0026store-\u003ell_symbol, \u0026store-\u003esize);\n    store-\u003esize = origsize;\n    ZOPFLI_APPEND_DATA(0, \u0026store-\u003ed_symbol, \u0026store-\u003esize);\n    store-\u003ell_counts[llstart + length]++;\n  } else {\n    store-\u003esize = origsize;\n    ZOPFLI_APPEND_DATA(ZopfliGetLengthSymbol(length),\n                       \u0026store-\u003ell_symbol, \u0026store-\u003esize);\n    store-\u003esize = origsize;\n    ZOPFLI_APPEND_DATA(ZopfliGetDistSymbol(dist),\n                       \u0026store-\u003ed_symbol, \u0026store-\u003esize);\n    store-\u003ell_counts[llstart + ZopfliGetLengthSymbol(length)]++;\n    store-\u003ed_counts[dstart + ZopfliGetDistSymbol(dist)]++;\n  }\n}","filepath":"src/zopfli/lz77.c","line_number":98,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3153744":{"score":0.7670635,"function_name":"ZopfliAppendLZ77Store","code":"void ZopfliAppendLZ77Store(const ZopfliLZ77Store* store,\n                           ZopfliLZ77Store* target) {\n  size_t i;\n  for (i = 0; i \u003c store-\u003esize; i++) {\n    ZopfliStoreLitLenDist(store-\u003elitlens[i], store-\u003edists[i],\n                          store-\u003epos[i], target);\n  }\n}","filepath":"src/zopfli/lz77.c","line_number":151,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3153904":{"score":0.8047179,"function_name":"ZopfliLZ77GetHistogram","code":"void ZopfliLZ77GetHistogram(const ZopfliLZ77Store* lz77,\n                           size_t lstart, size_t lend,\n                           size_t* ll_counts, size_t* d_counts) {\n  size_t i;\n  if (lstart + ZOPFLI_NUM_LL * 3 \u003e lend) {\n    memset(ll_counts, 0, sizeof(*ll_counts) * ZOPFLI_NUM_LL);\n    memset(d_counts, 0, sizeof(*d_counts) * ZOPFLI_NUM_D);\n    for (i = lstart; i \u003c lend; i++) {\n      ll_counts[lz77-\u003ell_symbol[i]]++;\n      if (lz77-\u003edists[i] != 0) d_counts[lz77-\u003ed_symbol[i]]++;\n    }\n  } else {\n    /* Subtract the cumulative histograms at the end and the start to get the\n    histogram for this range. */\n    ZopfliLZ77GetHistogramAt(lz77, lend - 1, ll_counts, d_counts);\n    if (lstart \u003e 0) {\n      size_t ll_counts2[ZOPFLI_NUM_LL];\n      size_t d_counts2[ZOPFLI_NUM_D];\n      ZopfliLZ77GetHistogramAt(lz77, lstart - 1, ll_counts2, d_counts2);\n\n      for (i = 0; i \u003c ZOPFLI_NUM_LL; i++) {\n        ll_counts[i] -= ll_counts2[i];\n      }\n      for (i = 0; i \u003c ZOPFLI_NUM_D; i++) {\n        d_counts[i] -= d_counts2[i];\n      }\n    }\n  }\n}","filepath":"src/zopfli/lz77.c","line_number":189,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3154624":{"score":0.8097232,"function_name":"ZopfliInitBlockState","code":"void ZopfliInitBlockState(const ZopfliOptions* options,\n                          size_t blockstart, size_t blockend, int add_lmc,\n                          ZopfliBlockState* s) {\n  s-\u003eoptions = options;\n  s-\u003eblockstart = blockstart;\n  s-\u003eblockend = blockend;\n#ifdef ZOPFLI_LONGEST_MATCH_CACHE\n  if (add_lmc) {\n    s-\u003elmc = (ZopfliLongestMatchCache*)malloc(sizeof(ZopfliLongestMatchCache));\n    ZopfliInitCache(blockend - blockstart, s-\u003elmc);\n  } else {\n    s-\u003elmc = 0;\n  }\n#endif\n}","filepath":"src/zopfli/lz77.c","line_number":219,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3154720":{"score":0.76776886,"function_name":"ZopfliCleanBlockState","code":"void ZopfliCleanBlockState(ZopfliBlockState* s) {\n#ifdef ZOPFLI_LONGEST_MATCH_CACHE\n  if (s-\u003elmc) {\n    ZopfliCleanCache(s-\u003elmc);\n    free(s-\u003elmc);\n  }\n#endif\n}","filepath":"src/zopfli/lz77.c","line_number":235,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3154784":{"score":0.72009414,"function_name":"ZopfliFindLongestMatch","code":"void ZopfliFindLongestMatch(ZopfliBlockState* s, const ZopfliHash* h,\n    const unsigned char* array,\n    size_t pos, size_t size, size_t limit,\n    unsigned short* sublen, unsigned short* distance, unsigned short* length) {\n  unsigned short hpos = pos \u0026 ZOPFLI_WINDOW_MASK, p, pp;\n  unsigned short bestdist = 0;\n  unsigned short bestlength = 1;\n  const unsigned char* scan;\n  const unsigned char* match;\n  const unsigned char* arrayend;\n  const unsigned char* arrayend_safe;\n#if ZOPFLI_MAX_CHAIN_HITS \u003c ZOPFLI_WINDOW_SIZE\n  int chain_counter = ZOPFLI_MAX_CHAIN_HITS;  /* For quitting early. */\n#endif\n\n  unsigned dist = 0;  /* Not unsigned short on purpose. */\n\n  int* hhead = h-\u003ehead;\n  unsigned short* hprev = h-\u003eprev;\n  int* hhashval = h-\u003ehashval;\n  int hval = h-\u003eval;\n\n#ifdef ZOPFLI_LONGEST_MATCH_CACHE\n  if (TryGetFromLongestMatchCache(s, pos, \u0026limit, sublen, distance, length)) {\n    assert(pos + *length \u003c= size);\n    return;\n  }\n#endif\n\n  assert(limit \u003c= ZOPFLI_MAX_MATCH);\n  assert(limit \u003e= ZOPFLI_MIN_MATCH);\n  assert(pos \u003c size);\n\n  if (size - pos \u003c ZOPFLI_MIN_MATCH) {\n    /* The rest of the code assumes there are at least ZOPFLI_MIN_MATCH bytes to\n       try. */\n    *length = 0;\n    *distance = 0;\n    return;\n  }\n\n  if (pos + limit \u003e size) {\n    limit = size - pos;\n  }\n  arrayend = \u0026array[pos] + limit;\n  arrayend_safe = arrayend - 8;\n\n  assert(hval \u003c 65536);\n\n  pp = hhead[hval];  /* During the whole loop, p == hprev[pp]. */\n  p = hprev[pp];\n\n  assert(pp == hpos);\n\n  dist = p \u003c pp ? pp - p : ((ZOPFLI_WINDOW_SIZE - p) + pp);\n\n  /* Go through all distances. */\n  while (dist \u003c ZOPFLI_WINDOW_SIZE) {\n    unsigned short currentlength = 0;\n\n    assert(p \u003c ZOPFLI_WINDOW_SIZE);\n    assert(p == hprev[pp]);\n    assert(hhashval[p] == hval);\n\n    if (dist \u003e 0) {\n      assert(pos \u003c size);\n      assert(dist \u003c= pos);\n      scan = \u0026array[pos];\n      match = \u0026array[pos - dist];\n\n      /* Testing the byte at position bestlength first, goes slightly faster. */\n      if (pos + bestlength \u003e= size\n          || *(scan + bestlength) == *(match + bestlength)) {\n\n#ifdef ZOPFLI_HASH_SAME\n        unsigned short same0 = h-\u003esame[pos \u0026 ZOPFLI_WINDOW_MASK];\n        if (same0 \u003e 2 \u0026\u0026 *scan == *match) {\n          unsigned short same1 = h-\u003esame[(pos - dist) \u0026 ZOPFLI_WINDOW_MASK];\n          unsigned short same = same0 \u003c same1 ? same0 : same1;\n          if (same \u003e limit) same = limit;\n          scan += same;\n          match += same;\n        }\n#endif\n        scan = GetMatch(scan, match, arrayend, arrayend_safe);\n        currentlength = scan - \u0026array[pos];  /* The found length. */\n      }\n\n      if (currentlength \u003e bestlength) {\n        if (sublen) {\n          unsigned short j;\n          for (j = bestlength + 1; j \u003c= currentlength; j++) {\n            sublen[j] = dist;\n          }\n        }\n        bestdist = dist;\n        bestlength = currentlength;\n        if (currentlength \u003e= limit) break;\n      }\n    }\n\n\n#ifdef ZOPFLI_HASH_SAME_HASH\n    /* Switch to the other hash once this will be more efficient. */\n    if (hhead != h-\u003ehead2 \u0026\u0026 bestlength \u003e= h-\u003esame[hpos] \u0026\u0026\n        h-\u003eval2 == h-\u003ehashval2[p]) {\n      /* Now use the hash that encodes the length and first byte. */\n      hhead = h-\u003ehead2;\n      hprev = h-\u003eprev2;\n      hhashval = h-\u003ehashval2;\n      hval = h-\u003eval2;\n    }\n#endif\n\n    pp = p;\n    p = hprev[p];\n    if (p == pp) break;  /* Uninited prev value. */\n\n    dist += p \u003c pp ? pp - p : ((ZOPFLI_WINDOW_SIZE - p) + pp);\n\n#if ZOPFLI_MAX_CHAIN_HITS \u003c ZOPFLI_WINDOW_SIZE\n    chain_counter--;\n    if (chain_counter \u003c= 0) break;\n#endif\n  }\n\n#ifdef ZOPFLI_LONGEST_MATCH_CACHE\n  StoreInLongestMatchCache(s, pos, limit, sublen, bestdist, bestlength);\n#endif\n\n  assert(bestlength \u003c= limit);\n\n  *distance = bestdist;\n  *length = bestlength;\n  assert(pos + *length \u003c= size);\n}","filepath":"src/zopfli/lz77.c","line_number":407,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3156080":{"score":0.6946597,"function_name":"FollowPath","code":"static void FollowPath(ZopfliBlockState* s,\n                       const unsigned char* in, size_t instart, size_t inend,\n                       unsigned short* path, size_t pathsize,\n                       ZopfliLZ77Store* store, ZopfliHash *h) {\n  size_t i, j, pos = 0;\n  size_t windowstart = instart \u003e ZOPFLI_WINDOW_SIZE\n      ? instart - ZOPFLI_WINDOW_SIZE : 0;\n\n  size_t total_length_test = 0;\n\n  if (instart == inend) return;\n\n  ZopfliResetHash(ZOPFLI_WINDOW_SIZE, h);\n  ZopfliWarmupHash(in, windowstart, inend, h);\n  for (i = windowstart; i \u003c instart; i++) {\n    ZopfliUpdateHash(in, i, inend, h);\n  }\n\n  pos = instart;\n  for (i = 0; i \u003c pathsize; i++) {\n    unsigned short length = path[i];\n    unsigned short dummy_length;\n    unsigned short dist;\n    assert(pos \u003c inend);\n\n    ZopfliUpdateHash(in, pos, inend, h);\n\n    /* Add to output. */\n    if (length \u003e= ZOPFLI_MIN_MATCH) {\n      /* Get the distance by recalculating longest match. The found length\n      should match the length from the path. */\n      ZopfliFindLongestMatch(s, h, in, pos, inend, length, 0,\n                             \u0026dist, \u0026dummy_length);\n      assert(!(dummy_length != length \u0026\u0026 length \u003e 2 \u0026\u0026 dummy_length \u003e 2));\n      ZopfliVerifyLenDist(in, inend, pos, dist, length);\n      ZopfliStoreLitLenDist(length, dist, pos, store);\n      total_length_test += length;\n    } else {\n      length = 1;\n      ZopfliStoreLitLenDist(in[pos], 0, pos, store);\n      total_length_test++;\n    }\n\n\n    assert(pos + length \u003c= inend);\n    for (j = 1; j \u003c length; j++) {\n      ZopfliUpdateHash(in, pos + j, inend, h);\n    }\n\n    pos += length;\n  }\n}","filepath":"src/zopfli/squeeze.c","line_number":338,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3157712":{"score":0.8344761,"function_name":"FollowPath","code":"static void FollowPath(ZopfliBlockState* s,\n                       const unsigned char* in, size_t instart, size_t inend,\n                       unsigned short* path, size_t pathsize,\n                       ZopfliLZ77Store* store, ZopfliHash *h) {\n  size_t i, j, pos = 0;\n  size_t windowstart = instart \u003e ZOPFLI_WINDOW_SIZE\n      ? instart - ZOPFLI_WINDOW_SIZE : 0;\n\n  size_t total_length_test = 0;\n\n  if (instart == inend) return;\n\n  ZopfliResetHash(ZOPFLI_WINDOW_SIZE, h);\n  ZopfliWarmupHash(in, windowstart, inend, h);\n  for (i = windowstart; i \u003c instart; i++) {\n    ZopfliUpdateHash(in, i, inend, h);\n  }\n\n  pos = instart;\n  for (i = 0; i \u003c pathsize; i++) {\n    unsigned short length = path[i];\n    unsigned short dummy_length;\n    unsigned short dist;\n    assert(pos \u003c inend);\n\n    ZopfliUpdateHash(in, pos, inend, h);\n\n    /* Add to output. */\n    if (length \u003e= ZOPFLI_MIN_MATCH) {\n      /* Get the distance by recalculating longest match. The found length\n      should match the length from the path. */\n      ZopfliFindLongestMatch(s, h, in, pos, inend, length, 0,\n                             \u0026dist, \u0026dummy_length);\n      assert(!(dummy_length != length \u0026\u0026 length \u003e 2 \u0026\u0026 dummy_length \u003e 2));\n      ZopfliVerifyLenDist(in, inend, pos, dist, length);\n      ZopfliStoreLitLenDist(length, dist, pos, store);\n      total_length_test += length;\n    } else {\n      length = 1;\n      ZopfliStoreLitLenDist(in[pos], 0, pos, store);\n      total_length_test++;\n    }\n\n\n    assert(pos + length \u003c= inend);\n    for (j = 1; j \u003c length; j++) {\n      ZopfliUpdateHash(in, pos + j, inend, h);\n    }\n\n    pos += length;\n  }\n}","filepath":"src/zopfli/squeeze.c","line_number":338,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3158320":{"score":0.85175467,"function_name":"TraceBackwards","code":"static void TraceBackwards(size_t size, const unsigned short* length_array,\n                           unsigned short** path, size_t* pathsize) {\n  size_t index = size;\n  if (size == 0) return;\n  for (;;) {\n    ZOPFLI_APPEND_DATA(length_array[index], path, pathsize);\n    assert(length_array[index] \u003c= index);\n    assert(length_array[index] \u003c= ZOPFLI_MAX_MATCH);\n    assert(length_array[index] != 0);\n    index -= length_array[index];\n    if (index == 0) break;\n  }\n\n  /* Mirror result. */\n  for (index = 0; index \u003c *pathsize / 2; index++) {\n    unsigned short temp = (*path)[index];\n    (*path)[index] = (*path)[*pathsize - index - 1];\n    (*path)[*pathsize - index - 1] = temp;\n  }\n}","filepath":"src/zopfli/squeeze.c","line_number":317,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3158800":{"score":0.6283695,"function_name":"GetStatistics","code":"static void GetStatistics(const ZopfliLZ77Store* store, SymbolStats* stats) {\n  size_t i;\n  for (i = 0; i \u003c store-\u003esize; i++) {\n    if (store-\u003edists[i] == 0) {\n      stats-\u003elitlens[store-\u003elitlens[i]]++;\n    } else {\n      stats-\u003elitlens[ZopfliGetLengthSymbol(store-\u003elitlens[i])]++;\n      stats-\u003edists[ZopfliGetDistSymbol(store-\u003edists[i])]++;\n    }\n  }\n  stats-\u003elitlens[256] = 1;  /* End symbol. */\n\n  CalculateStatistics(stats);\n}","filepath":"src/zopfli/squeeze.c","line_number":398,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3158976":{"score":0.57652056,"function_name":"ZopfliLZ77Optimal","code":"void ZopfliLZ77Optimal(ZopfliBlockState *s,\n                       const unsigned char* in, size_t instart, size_t inend,\n                       int numiterations,\n                       ZopfliLZ77Store* store) {\n  /* Dist to get to here with smallest cost. */\n  size_t blocksize = inend - instart;\n  unsigned short* length_array =\n      (unsigned short*)malloc(sizeof(unsigned short) * (blocksize + 1));\n  unsigned short* path = 0;\n  size_t pathsize = 0;\n  ZopfliLZ77Store currentstore;\n  ZopfliHash hash;\n  ZopfliHash* h = \u0026hash;\n  SymbolStats stats, beststats, laststats;\n  int i;\n  float* costs = (float*)malloc(sizeof(float) * (blocksize + 1));\n  double cost;\n  double bestcost = ZOPFLI_LARGE_FLOAT;\n  double lastcost = 0;\n  /* Try randomizing the costs a bit once the size stabilizes. */\n  RanState ran_state;\n  int lastrandomstep = -1;\n\n  if (!costs) exit(-1); /* Allocation failed. */\n  if (!length_array) exit(-1); /* Allocation failed. */\n\n  InitRanState(\u0026ran_state);\n  InitStats(\u0026stats);\n  ZopfliInitLZ77Store(in, \u0026currentstore);\n  ZopfliAllocHash(ZOPFLI_WINDOW_SIZE, h);\n\n  /* Do regular deflate, then loop multiple shortest path runs, each time using\n  the statistics of the previous run. */\n\n  /* Initial run. */\n  ZopfliLZ77Greedy(s, in, instart, inend, \u0026currentstore, h);\n  GetStatistics(\u0026currentstore, \u0026stats);\n\n  /* Repeat statistics with each time the cost model from the previous stat\n  run. */\n  for (i = 0; i \u003c numiterations; i++) {\n    ZopfliCleanLZ77Store(\u0026currentstore);\n    ZopfliInitLZ77Store(in, \u0026currentstore);\n    LZ77OptimalRun(s, in, instart, inend, \u0026path, \u0026pathsize,\n                   length_array, GetCostStat, (void*)\u0026stats,\n                   \u0026currentstore, h, costs);\n    cost = ZopfliCalculateBlockSize(\u0026currentstore, 0, currentstore.size, 2);\n    if (s-\u003eoptions-\u003everbose_more || (s-\u003eoptions-\u003everbose \u0026\u0026 cost \u003c bestcost)) {\n      fprintf(stderr, \"Iteration %d: %d bit\\n\", i, (int) cost);\n    }\n    if (cost \u003c bestcost) {\n      /* Copy to the output store. */\n      ZopfliCopyLZ77Store(\u0026currentstore, store);\n      CopyStats(\u0026stats, \u0026beststats);\n      bestcost = cost;\n    }\n    CopyStats(\u0026stats, \u0026laststats);\n    ClearStatFreqs(\u0026stats);\n    GetStatistics(\u0026currentstore, \u0026stats);\n    if (lastrandomstep != -1) {\n      /* This makes it converge slower but better. Do it only once the\n      randomness kicks in so that if the user does few iterations, it gives a\n      better result sooner. */\n      AddWeighedStatFreqs(\u0026stats, 1.0, \u0026laststats, 0.5, \u0026stats);\n      CalculateStatistics(\u0026stats);\n    }\n    if (i \u003e 5 \u0026\u0026 cost == lastcost) {\n      CopyStats(\u0026beststats, \u0026stats);\n      RandomizeStatFreqs(\u0026ran_state, \u0026stats);\n      CalculateStatistics(\u0026stats);\n      lastrandomstep = i;\n    }\n    lastcost = cost;\n  }\n\n  free(length_array);\n  free(path);\n  free(costs);\n  ZopfliCleanLZ77Store(\u0026currentstore);\n  ZopfliCleanHash(h);\n}","filepath":"src/zopfli/squeeze.c","line_number":446,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3164112":{"score":0.6494966,"function_name":"ZopfliLZ77OptimalFixed","code":"void ZopfliLZ77OptimalFixed(ZopfliBlockState *s,\n                            const unsigned char* in,\n                            size_t instart, size_t inend,\n                            ZopfliLZ77Store* store)\n{\n  /* Dist to get to here with smallest cost. */\n  size_t blocksize = inend - instart;\n  unsigned short* length_array =\n      (unsigned short*)malloc(sizeof(unsigned short) * (blocksize + 1));\n  unsigned short* path = 0;\n  size_t pathsize = 0;\n  ZopfliHash hash;\n  ZopfliHash* h = \u0026hash;\n  float* costs = (float*)malloc(sizeof(float) * (blocksize + 1));\n\n  if (!costs) exit(-1); /* Allocation failed. */\n  if (!length_array) exit(-1); /* Allocation failed. */\n\n  ZopfliAllocHash(ZOPFLI_WINDOW_SIZE, h);\n\n  s-\u003eblockstart = instart;\n  s-\u003eblockend = inend;\n\n  /* Shortest path for fixed tree This one should give the shortest possible\n  result for fixed tree, no repeated runs are needed since the tree is known. */\n  LZ77OptimalRun(s, in, instart, inend, \u0026path, \u0026pathsize,\n                 length_array, GetCostFixed, 0, store, h, costs);\n\n  free(length_array);\n  free(path);\n  free(costs);\n  ZopfliCleanHash(h);\n}","filepath":"src/zopfli/squeeze.c","line_number":528,"entry_url":"https://github.com/google/zopfli.git","slot_name":"zopfli-1.0.2"},"3169056":{"score":0.9203197,"function_name":"DICT_construct","code":"int DICT_construct(DICT_buffer * const buf, int const async)\n{\n    buf-\u003edata[0] = NULL;\n    buf-\u003edata[1] = NULL;\n    buf-\u003esize = 0;\n\n    buf-\u003easync = (async != 0);\n\n#ifndef NO_XXHASH\n    buf-\u003exxh = NULL;\n#endif\n\n    return 0;\n}","filepath":"dict_buffer.c","line_number":20,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3169104":{"score":0.8354332,"function_name":"DICT_init","code":"int DICT_init(DICT_buffer * const buf, size_t const dict_size, size_t const overlap, unsigned const reset_multiplier, int const do_hash)\n{\n    /* Allocate if not yet allocated or existing dict too small */\n    if (buf-\u003edata[0] == NULL || dict_size \u003e buf-\u003esize) {\n        /* Free any existing buffers */\n        DICT_destruct(buf);\n\n        buf-\u003edata[0] = malloc(dict_size);\n\n        buf-\u003edata[1] = NULL;\n        if (buf-\u003easync)\n            buf-\u003edata[1] = malloc(dict_size);\n\n        if (buf-\u003edata[0] == NULL || (buf-\u003easync \u0026\u0026 buf-\u003edata[1] == NULL)) {\n            DICT_destruct(buf);\n            return 1;\n        }\n    }\n    buf-\u003eindex = 0;\n    buf-\u003eoverlap = overlap;\n    buf-\u003estart = 0;\n    buf-\u003eend = 0;\n    buf-\u003esize = dict_size;\n    buf-\u003etotal = 0;\n    buf-\u003ereset_interval = (reset_multiplier != 0) ? dict_size * reset_multiplier : ((size_t)1 \u003c\u003c 31);\n\n#ifndef NO_XXHASH\n    if (do_hash) {\n        if (buf-\u003exxh == NULL) {\n            buf-\u003exxh = XXH32_createState();\n            if (buf-\u003exxh == NULL) {\n                DICT_destruct(buf);\n                return 1;\n            }\n        }\n        XXH32_reset(buf-\u003exxh, 0);\n    }\n    else {\n        XXH32_freeState(buf-\u003exxh);\n        buf-\u003exxh = NULL;\n    }\n#else\n    (void)do_hash;\n#endif\n\n    return 0;\n}","filepath":"dict_buffer.c","line_number":35,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3169504":{"score":0.8204489,"function_name":"DICT_destruct","code":"void DICT_destruct(DICT_buffer * const buf)\n{\n    free(buf-\u003edata[0]);\n    free(buf-\u003edata[1]);\n    buf-\u003edata[0] = NULL;\n    buf-\u003edata[1] = NULL;\n    buf-\u003esize = 0;\n#ifndef NO_XXHASH\n    XXH32_freeState(buf-\u003exxh);\n    buf-\u003exxh = NULL;\n#endif\n}","filepath":"dict_buffer.c","line_number":83,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3169584":{"score":0.5866084,"function_name":"DICT_put","code":"void DICT_put(DICT_buffer * const buf, FL2_inBuffer * const input)\n{\n    size_t const to_read = MIN(buf-\u003esize - buf-\u003eend, input-\u003esize - input-\u003epos);\n\n    DEBUGLOG(5, \"CStream : reading %u bytes\", (U32)to_read);\n\n    memcpy(buf-\u003edata[buf-\u003eindex] + buf-\u003eend, (BYTE*)input-\u003esrc + input-\u003epos, to_read);\n\n    input-\u003epos += to_read;\n    buf-\u003eend += to_read;\n}","filepath":"dict_buffer.c","line_number":121,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3169936":{"score":0.80786324,"function_name":"DICT_put","code":"void DICT_put(DICT_buffer * const buf, FL2_inBuffer * const input)\n{\n    size_t const to_read = MIN(buf-\u003esize - buf-\u003eend, input-\u003esize - input-\u003epos);\n\n    DEBUGLOG(5, \"CStream : reading %u bytes\", (U32)to_read);\n\n    memcpy(buf-\u003edata[buf-\u003eindex] + buf-\u003eend, (BYTE*)input-\u003esrc + input-\u003epos, to_read);\n\n    input-\u003epos += to_read;\n    buf-\u003eend += to_read;\n}","filepath":"dict_buffer.c","line_number":121,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3170048":{"score":0.7442981,"function_name":"DICT_getBlock","code":"void DICT_getBlock(DICT_buffer * const buf, FL2_dataBlock * const block)\n{\n    block-\u003edata = buf-\u003edata[buf-\u003eindex];\n    block-\u003estart = buf-\u003estart;\n    block-\u003eend = buf-\u003eend;\n\n#ifndef NO_XXHASH\n    if (buf-\u003exxh != NULL)\n        XXH32_update(buf-\u003exxh, buf-\u003edata[buf-\u003eindex] + buf-\u003estart, buf-\u003eend - buf-\u003estart);\n#endif\n\n    buf-\u003etotal += buf-\u003eend - buf-\u003estart;\n    buf-\u003estart = buf-\u003eend;\n}","filepath":"dict_buffer.c","line_number":145,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3170256":{"score":0.85861325,"function_name":"DICT_shift","code":"void DICT_shift(DICT_buffer * const buf)\n{\n    if (buf-\u003estart \u003c buf-\u003eend)\n        return;\n\n    size_t overlap = buf-\u003eoverlap;\n    /* Reset the dict if the next compression cycle would exceed the reset interval */\n    if (buf-\u003etotal + buf-\u003esize - buf-\u003eoverlap \u003e buf-\u003ereset_interval) {\n        DEBUGLOG(4, \"Resetting dictionary after %u bytes\", (unsigned)buf-\u003etotal);\n        overlap = 0;\n    }\n\n    if (overlap == 0) {\n        /* No overlap means a simple buffer switch */\n        buf-\u003estart = 0;\n        buf-\u003eend = 0;\n        buf-\u003eindex ^= buf-\u003easync;\n        buf-\u003etotal = 0;\n    }\n    else if (buf-\u003eend \u003e= overlap + ALIGNMENT_SIZE) {\n        size_t const from = (buf-\u003eend - overlap) \u0026 ALIGNMENT_MASK;\n        const BYTE *const src = buf-\u003edata[buf-\u003eindex];\n        /* Copy to the alternate if one exists */\n        BYTE *const dst = buf-\u003edata[buf-\u003eindex ^ buf-\u003easync];\n\n        overlap = buf-\u003eend - from;\n\n        if (overlap \u003c= from || dst != src) {\n            DEBUGLOG(5, \"Copy overlap data : %u bytes from %u\", (unsigned)overlap, (unsigned)from);\n            memcpy(dst, src + from, overlap);\n        }\n        else if (from != 0) {\n            DEBUGLOG(5, \"Move overlap data : %u bytes from %u\", (unsigned)overlap, (unsigned)from);\n            memmove(dst, src + from, overlap);\n        }\n        /* New data will be written after the overlap */\n        buf-\u003estart = overlap;\n        buf-\u003eend = overlap;\n        /* Switch buffers */\n        buf-\u003eindex ^= buf-\u003easync;\n    }\n}","filepath":"dict_buffer.c","line_number":177,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3171200":{"score":0.68487823,"function_name":"FL2_beginFrame","code":"static size_t FL2_beginFrame(FL2_CCtx* const cctx, size_t const dictReduce)\n{\n    if (FL2_initEncoders(cctx) != 0) /* Create hash objects together, leaving the (large) match table last */\n        return FL2_ERROR(memory_allocation);\n\n    if (cctx-\u003ematchTable == NULL) {\n        cctx-\u003ematchTable = RMF_createMatchTable(\u0026cctx-\u003eparams.rParams, dictReduce, cctx-\u003ejobCount);\n        if (cctx-\u003ematchTable == NULL)\n            return FL2_ERROR(memory_allocation);\n    }\n    else {\n        DEBUGLOG(5, \"Have compatible match table\");\n        RMF_applyParameters(cctx-\u003ematchTable, \u0026cctx-\u003eparams.rParams, dictReduce);\n    }\n\n    cctx-\u003edictMax = 0;\n    cctx-\u003estreamTotal = 0;\n    cctx-\u003estreamCsize = 0;\n    cctx-\u003eprogressIn = 0;\n    cctx-\u003eprogressOut = 0;\n    RMF_initProgress(cctx-\u003ematchTable);\n    cctx-\u003easyncRes = 0;\n    cctx-\u003eoutThread = 0;\n    cctx-\u003ethreadCount = 0;\n    cctx-\u003eoutPos = 0;\n    cctx-\u003ecurBlock.start = 0;\n    cctx-\u003ecurBlock.end = 0;\n    cctx-\u003elockParams = 1;\n\n    return FL2_error_no_error;\n}","filepath":"fl2_compress.c","line_number":444,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3171504":{"score":0.8228479,"function_name":"FL2_compressCurBlock_blocking","code":"static size_t FL2_compressCurBlock_blocking(FL2_CCtx* const cctx, int const streamProp)\n{\n    size_t const encodeSize = (cctx-\u003ecurBlock.end - cctx-\u003ecurBlock.start);\n#ifndef FL2_SINGLETHREAD\n    size_t mfThreads = cctx-\u003ecurBlock.end / RMF_MIN_BYTES_PER_THREAD;\n    size_t nbThreads = MIN(cctx-\u003ejobCount, encodeSize / ENC_MIN_BYTES_PER_THREAD);\n    nbThreads += !nbThreads;\n#else\n    size_t mfThreads = 1;\n    size_t nbThreads = 1;\n#endif\n\n    DEBUGLOG(5, \"FL2_compressCurBlock : %u threads, %u start, %u bytes\", (U32)nbThreads, (U32)cctx-\u003ecurBlock.start, (U32)encodeSize);\n\n    size_t sliceStart = cctx-\u003ecurBlock.start;\n    size_t const sliceSize = encodeSize / nbThreads;\n    cctx-\u003ejobs[0].block.data = cctx-\u003ecurBlock.data;\n    cctx-\u003ejobs[0].block.start = sliceStart;\n    cctx-\u003ejobs[0].block.end = sliceStart + sliceSize;\n\n    for (size_t u = 1; u \u003c nbThreads; ++u) {\n        sliceStart += sliceSize;\n        cctx-\u003ejobs[u].block.data = cctx-\u003ecurBlock.data;\n        cctx-\u003ejobs[u].block.start = sliceStart;\n        cctx-\u003ejobs[u].block.end = sliceStart + sliceSize;\n    }\n    cctx-\u003ejobs[nbThreads - 1].block.end = cctx-\u003ecurBlock.end;\n\n    /* initialize to length 2 */\n    RMF_initTable(cctx-\u003ematchTable, cctx-\u003ecurBlock.data, cctx-\u003ecurBlock.end);\n\n    if (cctx-\u003ecanceled) {\n        RMF_resetIncompleteBuild(cctx-\u003ematchTable);\n        return FL2_ERROR(canceled);\n    }\n\n#ifndef FL2_SINGLETHREAD\n\n    mfThreads = MIN(RMF_threadCount(cctx-\u003ematchTable), mfThreads);\n    FL2POOL_addRange(cctx-\u003efactory, FL2_buildRadixTable, cctx, 1, mfThreads);\n\n#endif\n\n    int err = RMF_buildTable(cctx-\u003ematchTable, 0, mfThreads \u003e 1, cctx-\u003ecurBlock);\n\n#ifndef FL2_SINGLETHREAD\n\n    FL2POOL_waitAll(cctx-\u003efactory, 0);\n\n    if (err)\n        return FL2_ERROR(canceled);\n\n#ifdef RMF_CHECK_INTEGRITY\n    err = RMF_integrityCheck(cctx-\u003ematchTable, cctx-\u003ecurBlock.data, cctx-\u003ecurBlock.start, cctx-\u003ecurBlock.end, cctx-\u003eparams.rParams.depth);\n    if (err)\n        return FL2_ERROR(internal);\n#endif\n\n    FL2POOL_addRange(cctx-\u003efactory, FL2_compressRadixChunk, cctx, 1, nbThreads);\n\n    cctx-\u003ejobs[0].cSize = LZMA2_encode(cctx-\u003ejobs[0].enc, cctx-\u003ematchTable,\n        cctx-\u003ejobs[0].block,\n        \u0026cctx-\u003eparams.cParams, streamProp,\n        \u0026cctx-\u003eprogressIn, \u0026cctx-\u003eprogressOut, \u0026cctx-\u003ecanceled);\n\n    FL2POOL_waitAll(cctx-\u003efactory, 0);\n\n#else /* FL2_SINGLETHREAD */\n\n    if (err)\n        return FL2_ERROR(canceled);\n\n#ifdef RMF_CHECK_INTEGRITY\n    err = RMF_integrityCheck(cctx-\u003ematchTable, cctx-\u003ecurBlock.data, cctx-\u003ecurBlock.start, cctx-\u003ecurBlock.end, cctx-\u003eparams.rParams.depth);\n    if (err)\n        return FL2_ERROR(internal);\n#endif\n    cctx-\u003ejobs[0].cSize = LZMA2_encode(cctx-\u003ejobs[0].enc, cctx-\u003ematchTable,\n        cctx-\u003ejobs[0].block,\n        \u0026cctx-\u003eparams.cParams, streamProp,\n        \u0026cctx-\u003eprogressIn, \u0026cctx-\u003eprogressOut, \u0026cctx-\u003ecanceled);\n\n#endif\n\n    for (size_t u = 0; u \u003c nbThreads; ++u)\n        if (FL2_isError(cctx-\u003ejobs[u].cSize))\n            return cctx-\u003ejobs[u].cSize;\n\n    cctx-\u003ethreadCount = nbThreads;\n\n    return FL2_error_no_error;\n}","filepath":"fl2_compress.c","line_number":268,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3172160":{"score":0.76905787,"function_name":"FL2_compressCurBlock","code":"static size_t FL2_compressCurBlock(FL2_CCtx* const cctx, int const streamProp)\n{\n    FL2_initProgress(cctx);\n\n    if (cctx-\u003ecurBlock.start == cctx-\u003ecurBlock.end)\n        return FL2_error_no_error;\n\n    /* update largest dict size used */\n    cctx-\u003edictMax = MAX(cctx-\u003edictMax, cctx-\u003ecurBlock.end);\n\n    cctx-\u003eoutThread = 0;\n    cctx-\u003ethreadCount = 0;\n    cctx-\u003eoutPos = 0;\n\n    U32 rmfWeight = ZSTD_highbit32((U32)cctx-\u003ecurBlock.end);\n    U32 depthWeight = 2 + (cctx-\u003eparams.rParams.depth \u003e= 12) + (cctx-\u003eparams.rParams.depth \u003e= 28);\n    U32 encWeight;\n\n    if (rmfWeight \u003e= 20) {\n        rmfWeight = depthWeight * (rmfWeight - 10) + (rmfWeight - 19) * 12;\n        if (cctx-\u003eparams.cParams.strategy == 0)\n            encWeight = 20;\n        else if (cctx-\u003eparams.cParams.strategy == 1)\n            encWeight = 50;\n        else\n            encWeight = 60 + cctx-\u003eparams.cParams.second_dict_bits + ZSTD_highbit32(cctx-\u003eparams.cParams.fast_length) * 3U;\n        rmfWeight = (rmfWeight \u003c\u003c 4) / (rmfWeight + encWeight);\n        encWeight = 16 - rmfWeight;\n    }\n    else {\n        rmfWeight = 8;\n        encWeight = 8;\n    }\n\n    cctx-\u003ermfWeight = rmfWeight;\n    cctx-\u003eencWeight = encWeight;\n\n#ifndef FL2_SINGLETHREAD\n    if(cctx-\u003ecompressThread != NULL)\n        FL2POOL_add(cctx-\u003ecompressThread, FL2_compressCurBlock_async, cctx, streamProp);\n    else\n#endif\n        cctx-\u003easyncRes = FL2_compressCurBlock_blocking(cctx, streamProp);\n\n    return cctx-\u003easyncRes;\n}","filepath":"fl2_compress.c","line_number":375,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3172560":{"score":0.8145191,"function_name":"FL2_compressRadixChunk","code":"static void FL2_compressRadixChunk(void* const jobDescription, ptrdiff_t const n)\n{\n    FL2_CCtx* const cctx = (FL2_CCtx*)jobDescription;\n\n    cctx-\u003ejobs[n].cSize = LZMA2_encode(cctx-\u003ejobs[n].enc, cctx-\u003ematchTable,\n        cctx-\u003ejobs[n].block,\n        \u0026cctx-\u003eparams.cParams,\n        -1,\n        \u0026cctx-\u003eprogressIn, \u0026cctx-\u003eprogressOut, \u0026cctx-\u003ecanceled);\n}","filepath":"fl2_compress.c","line_number":235,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3172656":{"score":0.8225446,"function_name":"FL2_compressStream_internal","code":"static size_t FL2_compressStream_internal(FL2_CStream* const fcs, int const ending)\n{\n    CHECK_F(FL2_waitCStream(fcs));\n\n    DICT_buffer *const buf = \u0026fcs-\u003ebuf;\n\n    /* no compression can occur while compressed output exists */\n    if (fcs-\u003eoutThread == fcs-\u003ethreadCount \u0026\u0026 DICT_hasUnprocessed(buf)) {\n        fcs-\u003estreamTotal += fcs-\u003ecurBlock.end - fcs-\u003ecurBlock.start;\n\n        DICT_getBlock(buf, \u0026fcs-\u003ecurBlock);\n\n        int streamProp = -1;\n\n        if (!fcs-\u003ewroteProp \u0026\u0026 !fcs-\u003eparams.omitProp) {\n            /* If the LZMA2 property byte is required and not already written,\n             * pass it to the compression function \n             */\n            size_t dictionarySize = ending ? MAX(fcs-\u003edictMax, fcs-\u003ecurBlock.end)\n                : fcs-\u003eparams.rParams.dictionary_size;\n            streamProp = FL2_getProp(fcs, dictionarySize);\n            DEBUGLOG(4, \"Writing property byte : 0x%X\", streamProp);\n            fcs-\u003ewroteProp = 1;\n        }\n\n        CHECK_F(FL2_compressCurBlock(fcs, streamProp));\n    }\n    return FL2_error_no_error;\n}","filepath":"fl2_compress.c","line_number":908,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3173168":{"score":0.7948705,"function_name":"FL2_CCtx_setParameter","code":"FL2LIB_CALL FL2_CCtx_setParameter(FL2_CCtx* cctx, FL2_cParameter param, size_t value)\n{\n    if (cctx-\u003elockParams\n        \u0026\u0026 param != FL2_p_literalCtxBits \u0026\u0026 param != FL2_p_literalPosBits \u0026\u0026 param != FL2_p_posBits)\n        return FL2_ERROR(stage_wrong);\n\n    switch (param)\n    {\n    case FL2_p_compressionLevel:\n        if (cctx-\u003eparams.highCompression) {\n            CLAMPCHECK(value, 1, FL2_MAX_HIGH_CLEVEL);\n            FL2_fillParameters(cctx, \u0026FL2_highCParameters[value]);\n        }\n        else {\n            CLAMPCHECK(value, 1, FL2_MAX_CLEVEL);\n            FL2_fillParameters(cctx, \u0026FL2_defaultCParameters[value]);\n        }\n        cctx-\u003eparams.compressionLevel = (unsigned)value;\n        break;\n\n    case FL2_p_highCompression:\n        cctx-\u003eparams.highCompression = value != 0;\n        FL2_CCtx_setParameter(cctx, FL2_p_compressionLevel, cctx-\u003eparams.compressionLevel);\n        break;\n\n    case FL2_p_dictionaryLog:\n        CLAMPCHECK(value, FL2_DICTLOG_MIN, FL2_DICTLOG_MAX);\n        cctx-\u003eparams.rParams.dictionary_size = (size_t)1 \u003c\u003c value;\n        break;\n\n    case FL2_p_dictionarySize:\n        CLAMPCHECK(value, FL2_DICTSIZE_MIN, FL2_DICTSIZE_MAX);\n        cctx-\u003eparams.rParams.dictionary_size = value;\n        break;\n\n    case FL2_p_overlapFraction:\n        MAXCHECK(value, FL2_BLOCK_OVERLAP_MAX);\n        cctx-\u003eparams.rParams.overlap_fraction = (unsigned)value;\n        break;\n\n    case FL2_p_resetInterval:\n        if (value != 0)\n            CLAMPCHECK(value, FL2_RESET_INTERVAL_MIN, FL2_RESET_INTERVAL_MAX);\n        cctx-\u003eparams.cParams.reset_interval = (unsigned)value;\n        break;\n\n    case FL2_p_bufferResize:\n        MAXCHECK(value, FL2_BUFFER_RESIZE_MAX);\n        cctx-\u003eparams.rParams.match_buffer_resize = (unsigned)value;\n        break;\n\n    case FL2_p_hybridChainLog:\n        CLAMPCHECK(value, FL2_CHAINLOG_MIN, FL2_CHAINLOG_MAX);\n        cctx-\u003eparams.cParams.second_dict_bits = (unsigned)value;\n        break;\n\n    case FL2_p_hybridCycles:\n        CLAMPCHECK(value, FL2_HYBRIDCYCLES_MIN, FL2_HYBRIDCYCLES_MAX);\n        cctx-\u003eparams.cParams.match_cycles = (unsigned)value;\n        break;\n\n    case FL2_p_searchDepth:\n        CLAMPCHECK(value, FL2_SEARCH_DEPTH_MIN, FL2_SEARCH_DEPTH_MAX);\n        cctx-\u003eparams.rParams.depth = (unsigned)value;\n        break;\n\n    case FL2_p_fastLength:\n        CLAMPCHECK(value, FL2_FASTLENGTH_MIN, FL2_FASTLENGTH_MAX);\n        cctx-\u003eparams.cParams.fast_length = (unsigned)value;\n        break;\n\n    case FL2_p_divideAndConquer:\n        cctx-\u003eparams.rParams.divide_and_conquer = value != 0;\n        break;\n\n    case FL2_p_strategy:\n        MAXCHECK(value, (unsigned)FL2_ultra);\n        cctx-\u003eparams.cParams.strategy = (FL2_strategy)value;\n        break;\n\n        /* lc, lp, pb can be changed between encoder chunks.\n         * A condition where lc+lp \u003e 4 is permitted to allow sequential setting,\n         * but will return an error code to alert the calling function.\n         * If lc+lp is still \u003e4 when encoding begins, lc will be reduced. */\n    case FL2_p_literalCtxBits:\n        MAXCHECK(value, FL2_LC_MAX);\n        cctx-\u003eparams.cParams.lc = (unsigned)value;\n        if (value + cctx-\u003eparams.cParams.lp \u003e FL2_LCLP_MAX)\n            return FL2_ERROR(lclpMax_exceeded);\n        break;\n\n    case FL2_p_literalPosBits:\n        MAXCHECK(value, FL2_LP_MAX);\n        cctx-\u003eparams.cParams.lp = (unsigned)value;\n        if (cctx-\u003eparams.cParams.lc + value \u003e FL2_LCLP_MAX)\n            return FL2_ERROR(lclpMax_exceeded);\n        break;\n\n    case FL2_p_posBits:\n        MAXCHECK(value, FL2_PB_MAX);\n        cctx-\u003eparams.cParams.pb = (unsigned)value;\n        break;\n\n#ifndef NO_XXHASH\n    case FL2_p_doXXHash:\n        cctx-\u003eparams.doXXH = value != 0;\n        break;\n#endif\n\n    case FL2_p_omitProperties:\n        cctx-\u003eparams.omitProp = value != 0;\n        break;\n#ifdef RMF_REFERENCE\n    case FL2_p_useReferenceMF:\n        cctx-\u003eparams.rParams.use_ref_mf = value != 0;\n        break;\n#endif\n    default: return FL2_ERROR(parameter_unsupported);\n    }\n    return value;\n}","filepath":"fl2_compress.c","line_number":636,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3174064":{"score":0.7908718,"function_name":"FL2_createCCtx_internal","code":"static FL2_CCtx* FL2_createCCtx_internal(unsigned nbThreads, int const dualBuffer)\n{\n    nbThreads = FL2_checkNbThreads(nbThreads);\n\n    DEBUGLOG(3, \"FL2_createCCtxMt : %u threads\", nbThreads);\n\n    FL2_CCtx* const cctx = calloc(1, sizeof(FL2_CCtx) + (nbThreads - 1) * sizeof(FL2_job));\n    if (cctx == NULL)\n        return NULL;\n\n    cctx-\u003ejobCount = nbThreads;\n    for (unsigned u = 0; u \u003c nbThreads; ++u)\n        cctx-\u003ejobs[u].enc = NULL;\n\n#ifndef NO_XXHASH\n    cctx-\u003eparams.doXXH = 1;\n#endif\n\n    cctx-\u003ematchTable = NULL;\n\n#ifndef FL2_SINGLETHREAD\n    cctx-\u003ecompressThread = NULL;\n    cctx-\u003efactory = FL2POOL_create(nbThreads - 1);\n    if (nbThreads \u003e 1 \u0026\u0026 cctx-\u003efactory == NULL) {\n        FL2_freeCCtx(cctx);\n        return NULL;\n    }\n    if (dualBuffer) {\n      cctx-\u003ecompressThread = FL2POOL_create(1);\n      if (cctx-\u003ecompressThread == NULL)\n        return NULL;\n    }\n#endif\n\n    for (unsigned u = 0; u \u003c nbThreads; ++u) {\n        cctx-\u003ejobs[u].enc = LZMA2_createECtx();\n        if (cctx-\u003ejobs[u].enc == NULL) {\n            FL2_freeCCtx(cctx);\n            return NULL;\n        }\n        cctx-\u003ejobs[u].cctx = cctx;\n    }","filepath":"fl2_compress.c","line_number":138,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3174704":{"score":0.8616641,"function_name":"FL2_compressCCtx","code":"FL2LIB_CALL FL2_compressCCtx(FL2_CCtx* cctx,\n    void* dst, size_t dstCapacity,\n    const void* src, size_t srcSize,\n    int compressionLevel)\n{\n    if (dstCapacity \u003c 2U - cctx-\u003eparams.omitProp) /* empty LZMA2 stream is byte sequence {0, 0} */\n        return FL2_ERROR(dstSize_tooSmall);\n\n    if (compressionLevel \u003e 0)\n        FL2_CCtx_setParameter(cctx, FL2_p_compressionLevel, compressionLevel);\n\n    DEBUGLOG(4, \"FL2_compressCCtx : level %u, %u src =\u003e %u avail\", cctx-\u003eparams.compressionLevel, (U32)srcSize, (U32)dstCapacity);\n\n#ifndef FL2_SINGLETHREAD\n    /* No async compression for in-memory function */\n    FL2POOL_free(cctx-\u003ecompressThread);\n    cctx-\u003ecompressThread = NULL;\n    cctx-\u003etimeout = 0;\n#endif\n\n    FL2_preBeginFrame(cctx, srcSize);\n    CHECK_F(FL2_beginFrame(cctx, srcSize));\n\n    size_t const cSize = FL2_compressBuffer(cctx, src, srcSize, dst, dstCapacity);\n\n    if (FL2_isError(cSize))\n        return cSize;\n\n    BYTE* dstBuf = dst;\n    BYTE* const end = dstBuf + dstCapacity;\n\n    dstBuf += cSize;\n    if(dstBuf \u003e= end)\n        return FL2_ERROR(dstSize_tooSmall);\n\n    if (cSize == 0)\n        *dstBuf++ = FL2_getProp(cctx, 0);\n\n    *dstBuf++ = LZMA2_END_MARKER;\n\n#ifndef NO_XXHASH\n    if (cctx-\u003eparams.doXXH \u0026\u0026 !cctx-\u003eparams.omitProp) {\n        XXH32_canonical_t canonical;\n        DEBUGLOG(5, \"Writing hash\");\n        if(end - dstBuf \u003c XXHASH_SIZEOF)\n            return FL2_ERROR(dstSize_tooSmall);\n        XXH32_canonicalFromHash(\u0026canonical, XXH32(src, srcSize, 0));\n        memcpy(dstBuf, \u0026canonical, XXHASH_SIZEOF);\n        dstBuf += XXHASH_SIZEOF;\n    }\n#endif\n    \n    FL2_endFrame(cctx);\n\n    return dstBuf - (BYTE*)dst;\n}","filepath":"fl2_compress.c","line_number":540,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3175712":{"score":0.8582841,"function_name":"FL2_compressMt","code":"FL2LIB_CALL FL2_compressMt(void* dst, size_t dstCapacity,\n    const void* src, size_t srcSize,\n    int compressionLevel,\n    unsigned nbThreads)\n{\n    size_t cSize;\n    FL2_CCtx* const cctx = FL2_createCCtxMt(nbThreads);\n    if (cctx == NULL)\n        return FL2_ERROR(memory_allocation);\n\n    cSize = FL2_compressCCtx(cctx, dst, dstCapacity, src, srcSize, compressionLevel);\n\n    FL2_freeCCtx(cctx);\n    return cSize;\n}","filepath":"fl2_compress.c","line_number":509,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.1"},"3175936":{"score":0.66215444,"function_name":"FL2_compressMt","code":"FL2LIB_CALL FL2_compressMt(void* dst, size_t dstCapacity,\n    const void* src, size_t srcSize,\n    int compressionLevel,\n    unsigned nbThreads)\n{\n    FL2_CCtx* const cctx = FL2_createCCtxMt(nbThreads);\n    if (cctx == NULL)\n        return FL2_ERROR(memory_allocation);\n\n    size_t const cSize = FL2_compressCCtx(cctx, dst, dstCapacity, src, srcSize, compressionLevel);\n\n    FL2_freeCCtx(cctx);\n\n    return cSize;\n}","filepath":"fl2_compress.c","line_number":597,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3176160":{"score":0.6896739,"function_name":"FL2_CCtx_getParameter","code":"FL2LIB_CALL FL2_CCtx_getParameter(FL2_CCtx* cctx, FL2_cParameter param)\n{\n    switch (param)\n    {\n    case FL2_p_compressionLevel:\n        return cctx-\u003eparams.compressionLevel;\n\n    case FL2_p_highCompression:\n        return cctx-\u003eparams.highCompression;\n\n    case FL2_p_dictionaryLog: {\n        size_t dictLog = FL2_DICTLOG_MIN;\n        while (((size_t)1 \u003c\u003c dictLog) \u003c cctx-\u003eparams.rParams.dictionary_size)\n            ++dictLog;\n        return dictLog;\n    }\n\n    case FL2_p_dictionarySize:\n        return cctx-\u003eparams.rParams.dictionary_size;\n\n    case FL2_p_overlapFraction:\n        return cctx-\u003eparams.rParams.overlap_fraction;\n\n    case FL2_p_resetInterval:\n        return cctx-\u003eparams.cParams.reset_interval;\n\n    case FL2_p_bufferResize:\n        return cctx-\u003eparams.rParams.match_buffer_resize;\n\n    case FL2_p_hybridChainLog:\n        return cctx-\u003eparams.cParams.second_dict_bits;\n\n    case FL2_p_hybridCycles:\n        return cctx-\u003eparams.cParams.match_cycles;\n\n    case FL2_p_literalCtxBits:\n        return cctx-\u003eparams.cParams.lc;\n\n    case FL2_p_literalPosBits:\n        return cctx-\u003eparams.cParams.lp;\n\n    case FL2_p_posBits:\n        return cctx-\u003eparams.cParams.pb;\n\n    case FL2_p_searchDepth:\n        return cctx-\u003eparams.rParams.depth;\n\n    case FL2_p_fastLength:\n        return cctx-\u003eparams.cParams.fast_length;\n\n    case FL2_p_divideAndConquer:\n        return cctx-\u003eparams.rParams.divide_and_conquer;\n\n    case FL2_p_strategy:\n        return (size_t)cctx-\u003eparams.cParams.strategy;\n\n#ifndef NO_XXHASH\n    case FL2_p_doXXHash:\n        return cctx-\u003eparams.doXXH;\n#endif\n\n    case FL2_p_omitProperties:\n        return cctx-\u003eparams.omitProp;\n#ifdef RMF_REFERENCE\n    case FL2_p_useReferenceMF:\n        return cctx-\u003eparams.rParams.use_ref_mf;\n#endif\n    default: return FL2_ERROR(parameter_unsupported);\n    }\n}","filepath":"fl2_compress.c","line_number":758,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3176432":{"score":0.8050851,"function_name":"FL2_CCtx_setParameter","code":"FL2LIB_CALL FL2_CCtx_setParameter(FL2_CCtx* cctx, FL2_cParameter param, size_t value)\n{\n    if (cctx-\u003elockParams\n        \u0026\u0026 param != FL2_p_literalCtxBits \u0026\u0026 param != FL2_p_literalPosBits \u0026\u0026 param != FL2_p_posBits)\n        return FL2_ERROR(stage_wrong);\n\n    switch (param)\n    {\n    case FL2_p_compressionLevel:\n        if (cctx-\u003eparams.highCompression) {\n            CLAMPCHECK(value, 1, FL2_MAX_HIGH_CLEVEL);\n            FL2_fillParameters(cctx, \u0026FL2_highCParameters[value]);\n        }\n        else {\n            CLAMPCHECK(value, 1, FL2_MAX_CLEVEL);\n            FL2_fillParameters(cctx, \u0026FL2_defaultCParameters[value]);\n        }\n        cctx-\u003eparams.compressionLevel = (unsigned)value;\n        break;\n\n    case FL2_p_highCompression:\n        cctx-\u003eparams.highCompression = value != 0;\n        FL2_CCtx_setParameter(cctx, FL2_p_compressionLevel, cctx-\u003eparams.compressionLevel);\n        break;\n\n    case FL2_p_dictionaryLog:\n        CLAMPCHECK(value, FL2_DICTLOG_MIN, FL2_DICTLOG_MAX);\n        cctx-\u003eparams.rParams.dictionary_size = (size_t)1 \u003c\u003c value;\n        break;\n\n    case FL2_p_dictionarySize:\n        CLAMPCHECK(value, FL2_DICTSIZE_MIN, FL2_DICTSIZE_MAX);\n        cctx-\u003eparams.rParams.dictionary_size = value;\n        break;\n\n    case FL2_p_overlapFraction:\n        MAXCHECK(value, FL2_BLOCK_OVERLAP_MAX);\n        cctx-\u003eparams.rParams.overlap_fraction = (unsigned)value;\n        break;\n\n    case FL2_p_resetInterval:\n        if (value != 0)\n            CLAMPCHECK(value, FL2_RESET_INTERVAL_MIN, FL2_RESET_INTERVAL_MAX);\n        cctx-\u003eparams.cParams.reset_interval = (unsigned)value;\n        break;\n\n    case FL2_p_bufferResize:\n        MAXCHECK(value, FL2_BUFFER_RESIZE_MAX);\n        cctx-\u003eparams.rParams.match_buffer_resize = (unsigned)value;\n        break;\n\n    case FL2_p_hybridChainLog:\n        CLAMPCHECK(value, FL2_CHAINLOG_MIN, FL2_CHAINLOG_MAX);\n        cctx-\u003eparams.cParams.second_dict_bits = (unsigned)value;\n        break;\n\n    case FL2_p_hybridCycles:\n        CLAMPCHECK(value, FL2_HYBRIDCYCLES_MIN, FL2_HYBRIDCYCLES_MAX);\n        cctx-\u003eparams.cParams.match_cycles = (unsigned)value;\n        break;\n\n    case FL2_p_searchDepth:\n        CLAMPCHECK(value, FL2_SEARCH_DEPTH_MIN, FL2_SEARCH_DEPTH_MAX);\n        cctx-\u003eparams.rParams.depth = (unsigned)value;\n        break;\n\n    case FL2_p_fastLength:\n        CLAMPCHECK(value, FL2_FASTLENGTH_MIN, FL2_FASTLENGTH_MAX);\n        cctx-\u003eparams.cParams.fast_length = (unsigned)value;\n        break;\n\n    case FL2_p_divideAndConquer:\n        cctx-\u003eparams.rParams.divide_and_conquer = value != 0;\n        break;\n\n    case FL2_p_strategy:\n        MAXCHECK(value, (unsigned)FL2_ultra);\n        cctx-\u003eparams.cParams.strategy = (FL2_strategy)value;\n        break;\n\n        /* lc, lp, pb can be changed between encoder chunks.\n         * A condition where lc+lp \u003e 4 is permitted to allow sequential setting,\n         * but will return an error code to alert the calling function.\n         * If lc+lp is still \u003e4 when encoding begins, lc will be reduced. */\n    case FL2_p_literalCtxBits:\n        MAXCHECK(value, FL2_LC_MAX);\n        cctx-\u003eparams.cParams.lc = (unsigned)value;\n        if (value + cctx-\u003eparams.cParams.lp \u003e FL2_LCLP_MAX)\n            return FL2_ERROR(lclpMax_exceeded);\n        break;\n\n    case FL2_p_literalPosBits:\n        MAXCHECK(value, FL2_LP_MAX);\n        cctx-\u003eparams.cParams.lp = (unsigned)value;\n        if (cctx-\u003eparams.cParams.lc + value \u003e FL2_LCLP_MAX)\n            return FL2_ERROR(lclpMax_exceeded);\n        break;\n\n    case FL2_p_posBits:\n        MAXCHECK(value, FL2_PB_MAX);\n        cctx-\u003eparams.cParams.pb = (unsigned)value;\n        break;\n\n#ifndef NO_XXHASH\n    case FL2_p_doXXHash:\n        cctx-\u003eparams.doXXH = value != 0;\n        break;\n#endif\n\n    case FL2_p_omitProperties:\n        cctx-\u003eparams.omitProp = value != 0;\n        break;\n#ifdef RMF_REFERENCE\n    case FL2_p_useReferenceMF:\n        cctx-\u003eparams.rParams.use_ref_mf = value != 0;\n        break;\n#endif\n    default: return FL2_ERROR(parameter_unsupported);\n    }\n    return value;\n}","filepath":"fl2_compress.c","line_number":636,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3177392":{"score":0.6922426,"function_name":"FL2_CCtx_getParameter","code":"FL2LIB_CALL FL2_CCtx_getParameter(FL2_CCtx* cctx, FL2_cParameter param)\n{\n    switch (param)\n    {\n    case FL2_p_compressionLevel:\n        return cctx-\u003eparams.compressionLevel;\n\n    case FL2_p_highCompression:\n        return cctx-\u003eparams.highCompression;\n\n    case FL2_p_dictionaryLog: {\n        size_t dictLog = FL2_DICTLOG_MIN;\n        while (((size_t)1 \u003c\u003c dictLog) \u003c cctx-\u003eparams.rParams.dictionary_size)\n            ++dictLog;\n        return dictLog;\n    }\n\n    case FL2_p_dictionarySize:\n        return cctx-\u003eparams.rParams.dictionary_size;\n\n    case FL2_p_overlapFraction:\n        return cctx-\u003eparams.rParams.overlap_fraction;\n\n    case FL2_p_resetInterval:\n        return cctx-\u003eparams.cParams.reset_interval;\n\n    case FL2_p_bufferResize:\n        return cctx-\u003eparams.rParams.match_buffer_resize;\n\n    case FL2_p_hybridChainLog:\n        return cctx-\u003eparams.cParams.second_dict_bits;\n\n    case FL2_p_hybridCycles:\n        return cctx-\u003eparams.cParams.match_cycles;\n\n    case FL2_p_literalCtxBits:\n        return cctx-\u003eparams.cParams.lc;\n\n    case FL2_p_literalPosBits:\n        return cctx-\u003eparams.cParams.lp;\n\n    case FL2_p_posBits:\n        return cctx-\u003eparams.cParams.pb;\n\n    case FL2_p_searchDepth:\n        return cctx-\u003eparams.rParams.depth;\n\n    case FL2_p_fastLength:\n        return cctx-\u003eparams.cParams.fast_length;\n\n    case FL2_p_divideAndConquer:\n        return cctx-\u003eparams.rParams.divide_and_conquer;\n\n    case FL2_p_strategy:\n        return (size_t)cctx-\u003eparams.cParams.strategy;\n\n#ifndef NO_XXHASH\n    case FL2_p_doXXHash:\n        return cctx-\u003eparams.doXXH;\n#endif\n\n    case FL2_p_omitProperties:\n        return cctx-\u003eparams.omitProp;\n#ifdef RMF_REFERENCE\n    case FL2_p_useReferenceMF:\n        return cctx-\u003eparams.rParams.use_ref_mf;\n#endif\n    default: return FL2_ERROR(parameter_unsupported);\n    }\n}","filepath":"fl2_compress.c","line_number":758,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3177696":{"score":0.63979256,"function_name":"FL2_freeCCtx","code":"FL2LIB_CALL FL2_freeCCtx(FL2_CCtx* cctx)\n{\n    if (cctx == NULL) \n        return;\n\n    DEBUGLOG(3, \"FL2_freeCCtx : %u threads\", cctx-\u003ejobCount);\n\n    DICT_destruct(\u0026cctx-\u003ebuf);\n\n    for (unsigned u = 0; u \u003c cctx-\u003ejobCount; ++u) {\n        LZMA2_freeECtx(cctx-\u003ejobs[u].enc);\n    }\n\n#ifndef FL2_SINGLETHREAD\n    FL2POOL_free(cctx-\u003efactory);\n    FL2POOL_free(cctx-\u003ecompressThread);\n#endif\n\n    RMF_freeMatchTable(cctx-\u003ematchTable);\n    free(cctx);\n}","filepath":"fl2_compress.c","line_number":199,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3177824":{"score":0.6161265,"function_name":"FL2_initCStream","code":"FL2LIB_CALL FL2_initCStream(FL2_CStream* fcs, int compressionLevel)\n{\n    DEBUGLOG(4, \"FL2_initCStream level %d\", compressionLevel);\n\n    fcs-\u003einBuff.start = 0;\n    fcs-\u003einBuff.end = 0;\n    fcs-\u003eout_thread = 0;\n    fcs-\u003ethread_count = 0;\n    fcs-\u003eout_pos = 0;\n    fcs-\u003ehash_pos = 0;\n    fcs-\u003eend_marked = 0;\n    fcs-\u003ewrote_prop = 0;\n\n    FL2_CCtx_setParameter(fcs-\u003ecctx, FL2_p_compressionLevel, compressionLevel);\n\n    if (fcs-\u003ecctx-\u003eparams.doXXH \u0026\u0026 !fcs-\u003ecctx-\u003eparams.omitProp) {\n        if (fcs-\u003exxh == NULL) {\n            fcs-\u003exxh = XXH32_createState();\n            if (fcs-\u003exxh == NULL)\n                return FL2_ERROR(memory_allocation);\n        }\n        XXH32_reset(fcs-\u003exxh, 0);\n    }\n    FL2_beginFrame(fcs-\u003ecctx);\n    return 0;\n}","filepath":"fl2_compress.c","line_number":720,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.1"},"3178080":{"score":0.8243972,"function_name":"FL2_setDStreamTimeout","code":"FL2LIB_CALL FL2_setDStreamTimeout(FL2_DStream * fds, unsigned timeout)\n{\n#ifndef FL2_SINGLETHREAD\n    /* decompressThread is only used if a timeout is specified */\n    if (timeout != 0) {\n        if (fds-\u003edecompressThread == NULL) {\n            fds-\u003edecompressThread = FL2POOL_create(1);\n            if (fds-\u003edecompressThread == NULL)\n                return FL2_ERROR(memory_allocation);\n        }\n    }\n    else if (!fds-\u003ewait) {\n        /* Only free the thread if decompression not underway */\n        FL2POOL_free(fds-\u003edecompressThread);\n        fds-\u003edecompressThread = NULL;\n    }\n    fds-\u003etimeout = timeout;\n#endif\n    return FL2_error_no_error;\n}","filepath":"fl2_decompress.c","line_number":1107,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3178208":{"score":0.76083946,"function_name":"FL2_writeStreamBlocks","code":"static size_t FL2_writeStreamBlocks(FL2_DStream* const fds, FL2_outBuffer* const output)\n{\n    FL2_decMt *const decmt = fds-\u003edecmt;\n\n    for (; decmt-\u003esrcThread \u003c fds-\u003edecmt-\u003enumThreads; ++decmt-\u003esrcThread) {\n        FL2_decJob *thread = decmt-\u003ethreads + decmt-\u003esrcThread;\n        size_t to_write = MIN(thread-\u003ebufSize - decmt-\u003esrcPos, output-\u003esize - output-\u003epos);\n        memcpy((BYTE*)output-\u003edst + output-\u003epos, thread-\u003eoutBuf + decmt-\u003esrcPos, to_write);\n\n#ifndef NO_XXHASH\n        if (fds-\u003edoHash)\n            XXH32_update(fds-\u003exxh, (BYTE*)output-\u003edst + output-\u003epos, to_write);\n#endif\n        decmt-\u003esrcPos += to_write;\n        output-\u003epos += to_write;\n\n        if (decmt-\u003esrcPos \u003c thread-\u003ebufSize)\n            break;\n\n        decmt-\u003esrcPos = 0;\n    }\n    if (decmt-\u003esrcThread \u003c fds-\u003edecmt-\u003enumThreads)\n        return 0;\n\n    FL2_freeOutputBuffers(fds-\u003edecmt);\n    fds-\u003edecmt-\u003enumThreads = 0;\n\n    return 1;\n}","filepath":"fl2_decompress.c","line_number":770,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3178464":{"score":0.7234762,"function_name":"FL2_compressStream","code":"FL2LIB_CALL FL2_compressStream(FL2_CStream* fcs, FL2_outBuffer *output, FL2_inBuffer* input)\n{\n    if (!fcs-\u003elockParams)\n        return FL2_ERROR(init_missing);\n\n    size_t const prevIn = input-\u003epos;\n    size_t const prevOut = (output != NULL) ? output-\u003epos : 0;\n\n    if (output != NULL \u0026\u0026 fcs-\u003eoutThread \u003c fcs-\u003ethreadCount)\n        FL2_copyCStreamOutput(fcs, output);\n\n    CHECK_F(FL2_compressStream_input(fcs, input));\n\n    if(output != NULL \u0026\u0026 fcs-\u003eoutThread \u003c fcs-\u003ethreadCount)\n        FL2_copyCStreamOutput(fcs, output);\n\n    CHECK_F(FL2_loopCheck(fcs, prevIn == input-\u003epos \u0026\u0026 (output == NULL || prevOut == output-\u003epos)));\n\n    return fcs-\u003eoutThread \u003c fcs-\u003ethreadCount;\n}","filepath":"fl2_compress.c","line_number":1014,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3179728":{"score":0.7276372,"function_name":"FL2_getDictionaryBuffer","code":"FL2LIB_CALL FL2_getDictionaryBuffer(FL2_CStream * fcs, FL2_dictBuffer * dict)\n{\n    if (!fcs-\u003elockParams)\n        return FL2_ERROR(init_missing);\n\n    CHECK_F(fcs-\u003easyncRes);\n\n    DICT_buffer *buf = \u0026fcs-\u003ebuf;\n\n    if (!DICT_availSpace(buf) \u0026\u0026 DICT_hasUnprocessed(buf))\n        CHECK_F(FL2_compressStream_internal(fcs, 0));\n\n    if (DICT_needShift(buf) \u0026\u0026 !DICT_async(buf))\n        CHECK_F(FL2_waitCStream(fcs));\n\n    dict-\u003esize = (unsigned long)DICT_get(buf, \u0026dict-\u003edst);\n\n    return FL2_error_no_error;\n}","filepath":"fl2_compress.c","line_number":1035,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3180080":{"score":0.7255671,"function_name":"FL2_getNextCompressedBuffer","code":"FL2LIB_CALL FL2_getNextCompressedBuffer(FL2_CStream* fcs, FL2_cBuffer* cbuf)\n{\n    cbuf-\u003esrc = NULL;\n    cbuf-\u003esize = 0;\n\n#ifndef FL2_SINGLETHREAD\n    CHECK_F(FL2_waitCStream(fcs));\n#endif\n\n    if (fcs-\u003eoutThread \u003c fcs-\u003ethreadCount) {\n        cbuf-\u003esrc = RMF_getTableAsOutputBuffer(fcs-\u003ematchTable, fcs-\u003ejobs[fcs-\u003eoutThread].block.start) + fcs-\u003eoutPos;\n        cbuf-\u003esize = fcs-\u003ejobs[fcs-\u003eoutThread].cSize - fcs-\u003eoutPos;\n        ++fcs-\u003eoutThread;\n        fcs-\u003eoutPos = 0;\n    }","filepath":"fl2_compress.c","line_number":1063,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3180336":{"score":0.87932146,"function_name":"FL2_getCStreamProgress","code":"long long FL2LIB_CALL FL2_getCStreamProgress(const FL2_CStream * fcs, unsigned long long *outputSize)\n{\n    if (outputSize != NULL)\n        *outputSize = fcs-\u003estreamCsize + fcs-\u003eprogressOut;\n\n    U64 const encodeSize = fcs-\u003ecurBlock.end - fcs-\u003ecurBlock.start;\n\n    if (fcs-\u003eprogressIn == 0 \u0026\u0026 fcs-\u003ecurBlock.end != 0)\n        return fcs-\u003estreamTotal + ((fcs-\u003ematchTable-\u003eprogress * encodeSize / fcs-\u003ecurBlock.end * fcs-\u003ermfWeight) \u003e\u003e 4);\n\n    return fcs-\u003estreamTotal + ((fcs-\u003ermfWeight * encodeSize) \u003e\u003e 4) + ((fcs-\u003eprogressIn * fcs-\u003eencWeight) \u003e\u003e 4);\n}","filepath":"fl2_compress.c","line_number":1081,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3180480":{"score":0.59003913,"function_name":"FL2_waitDStream","code":"FL2LIB_CALL FL2_waitDStream(FL2_DStream * fds)\n{\n#ifndef FL2_SINGLETHREAD\n    if (FL2POOL_waitAll(fds-\u003edecompressThread, fds-\u003etimeout) != 0)\n        return FL2_ERROR(timedOut);\n#endif\n    /* decompressThread writes the result into asyncRes before sleeping */\n    return fds-\u003easyncRes;\n}","filepath":"fl2_decompress.c","line_number":1128,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3180576":{"score":0.6010461,"function_name":"FL2_cancelDStream","code":"FL2LIB_CALL FL2_cancelDStream(FL2_DStream *fds)\n{\n#ifndef FL2_SINGLETHREAD\n    if (fds-\u003edecompressThread != NULL) {\n        fds-\u003edecmt-\u003ecanceled = 1;\n\n        FL2POOL_waitAll(fds-\u003edecompressThread, 0);\n\n        fds-\u003edecmt-\u003ecanceled = 0;\n    }\n    FL2_lzma2DecMt_cleanup(fds-\u003edecmt);\n#endif\n}","filepath":"fl2_decompress.c","line_number":1138,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3180672":{"score":0.69001514,"function_name":"FL2_remainingOutputSize","code":"static size_t FL2_remainingOutputSize(FL2_CStream* const fcs)\n{\n    FL2_CCtx* const cctx = fcs-\u003ecctx;\n    size_t pos = fcs-\u003eout_pos;\n    size_t total = 0;\n\n    if (FL2_isError(fcs-\u003ethread_count))\n        return fcs-\u003ethread_count;\n\n    for (size_t u = fcs-\u003eout_thread; u \u003c fcs-\u003ethread_count; ++u) {\n        total += cctx-\u003ejobs[fcs-\u003eout_thread].cSize - pos;\n        pos = 0;\n    }\n    return total;\n}","filepath":"fl2_compress.c","line_number":804,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.1"},"3180784":{"score":0.65529585,"function_name":"FL2_flushStream","code":"FL2LIB_CALL FL2_flushStream(FL2_CStream* fcs, FL2_outBuffer *output)\n{\n    if (!fcs-\u003elockParams)\n        return FL2_ERROR(init_missing);\n\n    size_t const prevOut = (output != NULL) ? output-\u003epos : 0;\n\n    if (output != NULL \u0026\u0026 fcs-\u003eoutThread \u003c fcs-\u003ethreadCount)\n        FL2_copyCStreamOutput(fcs, output);\n\n    size_t res = FL2_flushStream_internal(fcs, 0);\n    CHECK_F(res);\n\n    if (output != NULL \u0026\u0026 res != 0) {\n        FL2_copyCStreamOutput(fcs, output);\n        res = fcs-\u003eoutThread \u003c fcs-\u003ethreadCount;\n    }\n\n    CHECK_F(FL2_loopCheck(fcs, output != NULL \u0026\u0026 prevOut == output-\u003epos));\n\n    return res;\n}","filepath":"fl2_compress.c","line_number":1188,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3181600":{"score":0.6239526,"function_name":"FL2_endStream","code":"FL2LIB_CALL FL2_endStream(FL2_CStream* fcs, FL2_outBuffer *output)\n{\n    if (!fcs-\u003eendMarked \u0026\u0026 !fcs-\u003elockParams)\n        return FL2_ERROR(init_missing);\n\n    size_t const prevOut = (output != NULL) ? output-\u003epos : 0;\n    \n    if (output != NULL \u0026\u0026 fcs-\u003eoutThread \u003c fcs-\u003ethreadCount)\n        FL2_copyCStreamOutput(fcs, output);\n\n    CHECK_F(FL2_flushStream_internal(fcs, 1));\n\n    size_t res = FL2_waitCStream(fcs);\n    CHECK_F(res);\n\n    if (!fcs-\u003eendMarked \u0026\u0026 !DICT_hasUnprocessed(\u0026fcs-\u003ebuf)) {\n        FL2_writeEnd(fcs);\n        res = 1;\n    }\n\n    if (output != NULL \u0026\u0026 res != 0) {\n        FL2_copyCStreamOutput(fcs, output);\n        res = fcs-\u003eoutThread \u003c fcs-\u003ethreadCount || DICT_hasUnprocessed(\u0026fcs-\u003ebuf);\n    }\n\n    CHECK_F(FL2_loopCheck(fcs, output != NULL \u0026\u0026 prevOut == output-\u003epos));\n\n    return res;\n}","filepath":"fl2_compress.c","line_number":1211,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3182976":{"score":0.744657,"function_name":"FL2_getLevelParameters","code":"FL2LIB_CALL FL2_getLevelParameters(int compressionLevel, int high, FL2_compressionParameters * params)\n{\n    if (high) {\n        if (compressionLevel \u003c 0 || compressionLevel \u003e FL2_MAX_HIGH_CLEVEL)\n            return FL2_ERROR(parameter_outOfBound);\n        *params = FL2_highCParameters[compressionLevel];\n    }\n    else {\n        if (compressionLevel \u003c 0 || compressionLevel \u003e FL2_MAX_CLEVEL)\n            return FL2_ERROR(parameter_outOfBound);\n        *params = FL2_defaultCParameters[compressionLevel];\n    }\n    return FL2_error_no_error;\n}","filepath":"fl2_compress.c","line_number":1241,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3183328":{"score":0.6009325,"function_name":"FL2_estimateCCtxSize_usingCCtx","code":"FL2LIB_CALL FL2_estimateCCtxSize_usingCCtx(const FL2_CCtx * cctx)\n{\n    return FL2_memoryUsage_internal(cctx-\u003eparams.rParams.dictionary_size,\n        cctx-\u003eparams.rParams.match_buffer_resize,\n        cctx-\u003eparams.cParams.second_dict_bits,\n        cctx-\u003eparams.cParams.strategy,\n        cctx-\u003ejobCount) + DICT_memUsage(\u0026cctx-\u003ebuf);\n}","filepath":"fl2_compress.c","line_number":1285,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3183824":{"score":0.8203474,"function_name":"FL2_decompressCtxBlock","code":"static void FL2_decompressCtxBlock(void* const jobDescription, ptrdiff_t const n)\n{\n    BlockDecMt* const blocks = (BlockDecMt*)jobDescription;\n    size_t srcLen = blocks[n].packSize;\n\n    DEBUGLOG(4, \"Thread %u: decoding block of input size %u, output size %u\", (unsigned)n, (unsigned)srcLen, (unsigned)blocks[n].unpackSize);\n\n    blocks[n].res = LZMA2_decodeToDic(blocks[n].dec, blocks[n].unpackSize, blocks[n].src, \u0026srcLen, blocks[n].finish);\n\n    /* If no error occurred, store into res the dic_pos value, which is the end of the decompressed data in the buffer */\n    if (!FL2_isError(blocks[n].res))\n        blocks[n].res = blocks[n].dec-\u003edic_pos;\n}","filepath":"fl2_decompress.c","line_number":169,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3183952":{"score":0.7548765,"function_name":"FL2_decompressBlockMt","code":"static size_t FL2_decompressBlockMt(FL2_DStream* const fds, size_t const thread)\n{\n    FL2_decMt *const decmt = fds-\u003edecmt;\n    FL2_decJob *const ti = \u0026decmt-\u003ethreads[thread];\n    LZMA2_DCtx *const dec = \u0026ti-\u003edec;\n\n    DEBUGLOG(4, \"Thread %u: decoding block of size %u\", (unsigned)thread, (unsigned)ti-\u003ebufSize);\n\n    CHECK_F(LZMA2_initDecoder(dec, decmt-\u003eprop, ti-\u003eoutBuf, ti-\u003ebufSize));\n\n    /* Input buffer node containing the starting chunk. If thread \u003e 0 this is usually\n     * the last input buffer node of the previous thread. */\n    FL2_decInbuf *cur = ti-\u003einBlock.first;\n    /* Position of the starting chunk. */\n    size_t inPos = ti-\u003einBlock.startPos;\n    /* Flag to indicate this block ends with the terminator */\n    BYTE const last = decmt-\u003eisFinal \u0026\u0026 (thread == decmt-\u003enumThreads - 1);\n\n    while (!decmt-\u003ecanceled) {\n        size_t srcSize = cur-\u003elength - inPos;\n        size_t const dicPos = dec-\u003edic_pos;\n\n        size_t const res = LZMA2_decodeToDic(dec,\n            ti-\u003ebufSize,\n            cur-\u003einBuf + inPos, \u0026srcSize,\n            last \u0026\u0026 cur == ti-\u003einBlock.last ? LZMA_FINISH_END : LZMA_FINISH_ANY);\n\n        CHECK_F(res);\n\n        FL2_atomic_add(fds-\u003eprogress, (long)(dec-\u003edic_pos - dicPos));\n\n        if (res == LZMA_STATUS_FINISHED)\n            DEBUGLOG(4, \"Found end mark\");\n\n        if (cur == ti-\u003einBlock.last)\n            break;\n\n        /* Advance the position and switch to the next input buffer in the chain if necessary */\n        inPos += srcSize;\n        if (inPos + LZMA_REQUIRED_INPUT_MAX \u003e= cur-\u003elength) {\n            inPos -= cur-\u003elength - LZMA_REQUIRED_INPUT_MAX;\n            cur = cur-\u003enext;\n        }\n    }\n\n    if (decmt-\u003ecanceled)\n        return FL2_ERROR(canceled);\n\n    return FL2_error_no_error;\n}","filepath":"fl2_decompress.c","line_number":716,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3184624":{"score":0.8051306,"function_name":"FL2_initDStream_prop","code":"static size_t FL2_initDStream_prop(FL2_DStream* const fds, BYTE prop)\n{\n    fds-\u003edoHash = prop \u003e\u003e FL2_PROP_HASH_BIT;\n    prop \u0026= FL2_LZMA_PROP_MASK;\n\n    /* If MT decoding is enabled and the dict is not too large, decoder init will occur elsewhere */\n#ifndef FL2_SINGLETHREAD\n    if (fds-\u003edecmt == NULL || FL2_lzma2DecMt_initProp(fds-\u003edecmt, prop))\n#endif\n        CHECK_F(LZMA2_initDecoder(\u0026fds-\u003edec, prop, NULL, 0));\n\n#ifndef NO_XXHASH\n    if (fds-\u003edoHash) {\n        if (fds-\u003exxh == NULL) {\n            DEBUGLOG(3, \"Creating hash state\");\n            fds-\u003exxh = XXH32_createState();\n            if (fds-\u003exxh == NULL)\n                return FL2_ERROR(memory_allocation);\n        }\n        XXH32_reset(fds-\u003exxh, 0);\n    }\n#endif\n    return FL2_error_no_error;\n}","filepath":"fl2_decompress.c","line_number":1157,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3184832":{"score":0.69200844,"function_name":"FL2_decompressInput","code":"static size_t FL2_decompressInput(FL2_DStream* fds, FL2_outBuffer* output, FL2_inBuffer* input)\n{\n    if (fds-\u003estage == FL2DEC_STAGE_DECOMP) {\n        size_t destSize = output-\u003esize - output-\u003epos;\n        size_t srcSize = input-\u003esize - input-\u003epos;\n        size_t const res = LZMA2_decodeToBuf(\u0026fds-\u003edec, (BYTE*)output-\u003edst + output-\u003epos, \u0026destSize, (const BYTE*)input-\u003esrc + input-\u003epos, \u0026srcSize, LZMA_FINISH_ANY);\n\n        DEBUGLOG(5, \"Decoded %u bytes\", (U32)destSize);\n\n#ifndef NO_XXHASH\n        if (fds-\u003edoHash)\n            XXH32_update(fds-\u003exxh, (BYTE*)output-\u003edst + output-\u003epos, destSize);\n#endif\n        FL2_atomic_add(fds-\u003eprogress, (long)destSize);\n\n        output-\u003epos += destSize;\n        input-\u003epos += srcSize;\n\n        if (FL2_isError(res))\n            return res;\n        if (res == LZMA_STATUS_FINISHED) {\n            DEBUGLOG(4, \"Found end mark\");\n            fds-\u003estage = fds-\u003edoHash ? FL2DEC_STAGE_HASH : FL2DEC_STAGE_FINISHED;\n        }\n    }\n    return FL2_error_no_error;\n}","filepath":"fl2_decompress.c","line_number":475,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3185104":{"score":0.7769846,"function_name":"FL2_decompressOverlappedInput","code":"static size_t FL2_decompressOverlappedInput(FL2_DStream* fds, FL2_outBuffer* output, FL2_inBuffer* input)\n{\n    if (fds-\u003eoverlapSize != 0) {\n        size_t toRead = MIN(input-\u003esize - input-\u003epos, LZMA_OVERLAP_SIZE - fds-\u003eoverlapSize);\n        memcpy(fds-\u003eoverlap + fds-\u003eoverlapSize, (BYTE*)input-\u003esrc + input-\u003epos, toRead);\n        FL2_inBuffer temp = { fds-\u003eoverlap, fds-\u003eoverlapSize + toRead, 0 };\n        CHECK_F(FL2_decompressInput(fds, output, \u0026temp));\n        if (temp.pos \u003e= fds-\u003eoverlapSize) {\n            input-\u003epos += temp.pos - fds-\u003eoverlapSize;\n            fds-\u003eoverlapSize = 0;\n        }\n        else {\n            fds-\u003eoverlapSize -= temp.pos;\n            memmove(fds-\u003eoverlap, fds-\u003eoverlap + temp.pos, fds-\u003eoverlapSize);\n        }\n    }\n    if(input-\u003epos == input-\u003esize)\n        return FL2_error_no_error;\n\n    if(fds-\u003eoverlapSize == 0)\n        CHECK_F(FL2_decompressInput(fds, output, input));\n\n    size_t toRead = input-\u003esize - input-\u003epos;\n    /* More input needed if not finished, output not full and input is below minimum.\n     * Safe to take all input because stream will be beyond decomp stage if the terminator is present. */\n    if (fds-\u003estage == FL2DEC_STAGE_DECOMP \u0026\u0026 output-\u003epos \u003c output-\u003esize \u0026\u0026 toRead \u003c= LZMA_REQUIRED_INPUT_MAX) {\n        toRead = MIN(toRead, LZMA_OVERLAP_SIZE - fds-\u003eoverlapSize);\n        memcpy(fds-\u003eoverlap + fds-\u003eoverlapSize, (BYTE*)input-\u003esrc + input-\u003epos, toRead);\n        input-\u003epos += toRead;\n        fds-\u003eoverlapSize += toRead;\n    }\n    return FL2_error_no_error;\n}","filepath":"fl2_decompress.c","line_number":503,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3185776":{"score":0.71411353,"function_name":"FL2_decompressFailedMt","code":"static size_t FL2_decompressFailedMt(FL2_DStream* const fds, FL2_outBuffer* const output, FL2_inBuffer* const input)\n{\n    FL2_decMt *const decmt = fds-\u003edecmt;\n\n    if(decmt-\u003ehead-\u003elength == 0)\n        return FL2_decompressOverlappedInput(fds, output, input);\n\n    if (!decmt-\u003efailState) {\n        /* On first call of this function, free any output buffers already allocated,\n         * and set up the read position in the input buffer chain. The main thread's decoder needs initialization too. */\n        DEBUGLOG(3, \"Switching to ST decompression. Memory: %u, limit %u\", (unsigned)decmt-\u003ememTotal, (unsigned)decmt-\u003ememLimit);\n\n        FL2_freeOutputBuffers(decmt);\n\n        decmt-\u003ecur = decmt-\u003ethreads[0].inBlock.first;\n        decmt-\u003ecurPos = decmt-\u003ethreads[0].inBlock.startPos;\n\n        decmt-\u003efailState = 1;\n\n        CHECK_F(LZMA2_initDecoder(\u0026fds-\u003edec, decmt-\u003eprop, NULL, 0));\n    }\n    FL2_decInbuf *const cur = decmt-\u003ecur;\n\n    FL2_inBuffer temp;\n    temp.src = cur-\u003einBuf;\n    temp.pos = decmt-\u003ecurPos;\n    temp.size = cur-\u003elength;\n\n    CHECK_F(FL2_decompressInput(fds, output, \u0026temp));\n\n    decmt-\u003ecurPos = temp.pos;\n\n    if (temp.pos + LZMA_REQUIRED_INPUT_MAX \u003e= temp.size) {\n        if (cur-\u003enext == NULL) {\n            /* The last buffer in the chain */\n            fds-\u003eoverlapSize = temp.size - temp.pos;\n            memcpy(fds-\u003eoverlap, cur-\u003einBuf + temp.pos, fds-\u003eoverlapSize);\n            decmt-\u003ecur = NULL;\n            LZMA2_freeExtraInbufNodes(decmt);\n        }\n        else {\n            decmt-\u003ecurPos -= cur-\u003elength - LZMA_REQUIRED_INPUT_MAX;\n            decmt-\u003ecur = cur-\u003enext;\n        }\n    }\n\n    return FL2_error_no_error;\n}","filepath":"fl2_decompress.c","line_number":939,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3186400":{"score":0.79081464,"function_name":"FL2_createDCtxMt","code":"FL2LIB_API FL2_DCtx *FL2LIB_CALL FL2_createDCtxMt(unsigned nbThreads)\n{\n    DEBUGLOG(3, \"FL2_createDCtx\");\n\n    FL2_DCtx* const dctx = malloc(sizeof(FL2_DCtx));\n\n    if (dctx == NULL)\n        return NULL;\n\n    LZMA_constructDCtx(\u0026dctx-\u003edec);\n\n    dctx-\u003elzma2prop = LZMA2_PROP_UNINITIALIZED;\n\n    nbThreads = FL2_checkNbThreads(nbThreads);\n\n#ifndef FL2_SINGLETHREAD\n    dctx-\u003enbThreads = 1;\n    dctx-\u003eblocks = NULL;\n    dctx-\u003efactory = NULL;\n\n    if (nbThreads \u003e 1) {\n        dctx-\u003eblocks = malloc(nbThreads * sizeof(BlockDecMt));\n        dctx-\u003efactory = FL2POOL_create(nbThreads - 1);\n\n        if (dctx-\u003eblocks == NULL || dctx-\u003efactory == NULL) {\n            FL2_freeDCtx(dctx);\n            return NULL;\n        }\n        dctx-\u003eblocks[0].dec = \u0026dctx-\u003edec;\n\n        for (; dctx-\u003enbThreads \u003c nbThreads; ++dctx-\u003enbThreads) {\n\n            dctx-\u003eblocks[dctx-\u003enbThreads].dec = malloc(sizeof(LZMA2_DCtx));\n\n            if (dctx-\u003eblocks[dctx-\u003enbThreads].dec == NULL) {\n                FL2_freeDCtx(dctx);\n                return NULL;\n            }\n            LZMA_constructDCtx(dctx-\u003eblocks[dctx-\u003enbThreads].dec);\n        }\n    }\n#endif\n\n    return dctx;\n}","filepath":"fl2_decompress.c","line_number":91,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3187168":{"score":0.75378263,"function_name":"FL2_decompressDCtx","code":"FL2LIB_CALL FL2_decompressDCtx(FL2_DCtx* dctx,\n    void* dst, size_t dstCapacity,\n    const void* src, size_t srcSize)\n{\n    BYTE prop = dctx-\u003elzma2prop;\n    const BYTE *srcBuf = src;\n\n    if (prop == LZMA2_PROP_UNINITIALIZED) {\n        prop = *(const BYTE*)src;\n        ++srcBuf;\n        --srcSize;\n    }\n\n#ifndef NO_XXHASH\n    BYTE const doHash = prop \u003e\u003e FL2_PROP_HASH_BIT;\n#endif\n    prop \u0026= FL2_LZMA_PROP_MASK;\n\n    DEBUGLOG(4, \"FL2_decompressDCtx : dict prop 0x%X, do hash %u\", prop, doHash);\n\n    size_t srcPos = srcSize;\n\n    size_t dicPos = 0;\n    size_t res;\n#ifndef FL2_SINGLETHREAD\n    if (dctx-\u003eblocks != NULL) {\n        dctx-\u003elzma2prop = prop;\n        res = FL2_decompressDCtxMt(dctx, dst, dstCapacity, srcBuf, \u0026srcPos);\n    }\n    else \n#endif\n    {\n        CHECK_F(LZMA2_initDecoder(\u0026dctx-\u003edec, prop, dst, dstCapacity));\n\n        dicPos = dctx-\u003edec.dic_pos;\n\n        res = LZMA2_decodeToDic(\u0026dctx-\u003edec, dstCapacity, srcBuf, \u0026srcPos, LZMA_FINISH_END);\n    }\n\n    dctx-\u003elzma2prop = LZMA2_PROP_UNINITIALIZED;\n\n    if (FL2_isError(res))\n        return res;\n    /* All src data must be in memory */\n    if (res == LZMA_STATUS_NEEDS_MORE_INPUT)\n        return FL2_ERROR(srcSize_wrong);\n\n    dicPos = dctx-\u003edec.dic_pos - dicPos;\n\n#ifndef NO_XXHASH\n    if (doHash) {\n        XXH32_canonical_t canonical;\n        U32 hash;\n\n        DEBUGLOG(4, \"Checking hash\");\n\n        if (srcSize - srcPos \u003c XXHASH_SIZEOF)\n            return FL2_ERROR(srcSize_wrong);\n\n        memcpy(\u0026canonical, srcBuf + srcPos, XXHASH_SIZEOF);\n        hash = XXH32_hashFromCanonical(\u0026canonical);\n        if (hash != XXH32(dst, dicPos, 0))\n            return FL2_ERROR(checksum_wrong);\n    }\n#endif\n    return dicPos;\n}","filepath":"fl2_decompress.c","line_number":315,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3188752":{"score":0.8621899,"function_name":"FL2_decompressMt","code":"FL2LIB_CALL FL2_decompressMt(void* dst, size_t dstCapacity,\n    const void* src, size_t compressedSize,\n    unsigned nbThreads)\n{\n    FL2_DCtx* const dctx = FL2_createDCtxMt(nbThreads);\n    if(dctx == NULL)\n        return FL2_ERROR(memory_allocation);\n\n    size_t const dSize = FL2_decompressDCtx(dctx,\n        dst, dstCapacity,\n        src, compressedSize);\n\n    FL2_freeDCtx(dctx);\n\n    return dSize;\n}","filepath":"fl2_decompress.c","line_number":69,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3189232":{"score":0.76353467,"function_name":"FL2_createDCtxMt","code":"FL2LIB_API FL2_DCtx *FL2LIB_CALL FL2_createDCtxMt(unsigned nbThreads)\n{\n    DEBUGLOG(3, \"FL2_createDCtx\");\n\n    FL2_DCtx* const dctx = malloc(sizeof(FL2_DCtx));\n\n    if (dctx == NULL)\n        return NULL;\n\n    LZMA_constructDCtx(\u0026dctx-\u003edec);\n\n    dctx-\u003elzma2prop = LZMA2_PROP_UNINITIALIZED;\n\n    nbThreads = FL2_checkNbThreads(nbThreads);\n\n#ifndef FL2_SINGLETHREAD\n    dctx-\u003enbThreads = 1;\n    dctx-\u003eblocks = NULL;\n    dctx-\u003efactory = NULL;\n\n    if (nbThreads \u003e 1) {\n        dctx-\u003eblocks = malloc(nbThreads * sizeof(BlockDecMt));\n        dctx-\u003efactory = FL2POOL_create(nbThreads - 1);\n\n        if (dctx-\u003eblocks == NULL || dctx-\u003efactory == NULL) {\n            FL2_freeDCtx(dctx);\n            return NULL;\n        }\n        dctx-\u003eblocks[0].dec = \u0026dctx-\u003edec;\n\n        for (; dctx-\u003enbThreads \u003c nbThreads; ++dctx-\u003enbThreads) {\n\n            dctx-\u003eblocks[dctx-\u003enbThreads].dec = malloc(sizeof(LZMA2_DCtx));\n\n            if (dctx-\u003eblocks[dctx-\u003enbThreads].dec == NULL) {\n                FL2_freeDCtx(dctx);\n                return NULL;\n            }\n            LZMA_constructDCtx(dctx-\u003eblocks[dctx-\u003enbThreads].dec);\n        }\n    }\n#endif\n\n    return dctx;\n}","filepath":"fl2_decompress.c","line_number":91,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3190736":{"score":0.85125005,"function_name":"FL2_setDStreamTimeout","code":"FL2LIB_CALL FL2_setDStreamTimeout(FL2_DStream * fds, unsigned timeout)\n{\n#ifndef FL2_SINGLETHREAD\n    /* decompressThread is only used if a timeout is specified */\n    if (timeout != 0) {\n        if (fds-\u003edecompressThread == NULL) {\n            fds-\u003edecompressThread = FL2POOL_create(1);\n            if (fds-\u003edecompressThread == NULL)\n                return FL2_ERROR(memory_allocation);\n        }\n    }\n    else if (!fds-\u003ewait) {\n        /* Only free the thread if decompression not underway */\n        FL2POOL_free(fds-\u003edecompressThread);\n        fds-\u003edecompressThread = NULL;\n    }\n    fds-\u003etimeout = timeout;\n#endif\n    return FL2_error_no_error;\n}","filepath":"fl2_decompress.c","line_number":1107,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3190848":{"score":0.7950812,"function_name":"FL2_waitDStream","code":"FL2LIB_CALL FL2_waitDStream(FL2_DStream * fds)\n{\n#ifndef FL2_SINGLETHREAD\n    if (FL2POOL_waitAll(fds-\u003edecompressThread, fds-\u003etimeout) != 0)\n        return FL2_ERROR(timedOut);\n#endif\n    /* decompressThread writes the result into asyncRes before sleeping */\n    return fds-\u003easyncRes;\n}","filepath":"fl2_decompress.c","line_number":1128,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3190896":{"score":0.5701,"function_name":"FL2_cancelDStream","code":"FL2LIB_CALL FL2_cancelDStream(FL2_DStream *fds)\n{\n#ifndef FL2_SINGLETHREAD\n    if (fds-\u003edecompressThread != NULL) {\n        fds-\u003edecmt-\u003ecanceled = 1;\n\n        FL2POOL_waitAll(fds-\u003edecompressThread, 0);\n\n        fds-\u003edecmt-\u003ecanceled = 0;\n    }\n    FL2_lzma2DecMt_cleanup(fds-\u003edecmt);\n#endif\n}","filepath":"fl2_decompress.c","line_number":1138,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3194784":{"score":0.81744236,"function_name":"FL2_decompressStream","code":"FL2LIB_CALL FL2_decompressStream(FL2_DStream* fds, FL2_outBuffer* output, FL2_inBuffer* input)\n{\n    fds-\u003estreamTotal += fds-\u003eprogress;\n    fds-\u003eprogress = 0;\n\n#ifndef FL2_SINGLETHREAD\n    if (fds-\u003edecompressThread != NULL) {\n        /* Calling FL2_decompressStream() while waiting for decompressThread to fall idle is not allowed */\n        if (fds-\u003ewait)\n            return FL2_ERROR(stage_wrong);\n\n        fds-\u003easyncOutput = output;\n        fds-\u003easyncInput = input;\n        /* FL2_decompressStream_async will reset fds-\u003ewait upon completion */\n        fds-\u003ewait = 1;\n\n        FL2POOL_add(fds-\u003edecompressThread, FL2_decompressStream_async, fds, 0);\n\n        /* Wait for completion or a timeout */\n        CHECK_F(FL2_waitDStream(fds));\n\n        /* FL2_decompressStream_async() stores result in asyncRes */\n        return fds-\u003easyncRes;\n    }\n    else\n#endif\n    {\n        return FL2_decompressStream_blocking(fds, output, input);\n    }\n}","filepath":"fl2_decompress.c","line_number":1283,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3195056":{"score":0.77856505,"function_name":"FL2_estimateDStreamSize","code":"FL2LIB_CALL FL2_estimateDStreamSize(size_t dictSize, unsigned nbThreads)\n{\n    nbThreads = FL2_checkNbThreads(nbThreads);\n    if (nbThreads \u003e 1) {\n        /* Estimate 50% compression and a block size of 4 * dictSize */\n        return nbThreads * sizeof(FL2_DCtx) + (dictSize + dictSize / 2) * 4 * nbThreads;\n    }\n    return LZMA2_decMemoryUsage(dictSize);\n}","filepath":"fl2_decompress.c","line_number":1323,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3195120":{"score":0.6197591,"function_name":"LZMA_tryDummy","code":"static BYTE LZMA_tryDummy(const LZMA2_DCtx *const p)\n{\n    const Probability *probs = GET_PROBS;\n\tunsigned state = p-\u003estate;\n\tU32 range = p-\u003erange;\n\tU32 code = p-\u003ecode;\n\n    const Probability *prob;\n    U32 bound;\n    unsigned ttt;\n    unsigned pos_state = CALC_POS_STATE(p-\u003eprocessed_pos, (1 \u003c\u003c p-\u003eprop.pb) - 1);\n\n    prob = probs + IsMatch + COMBINED_PS_STATE;\n    IF_BIT_0_CHECK(prob)\n    {\n        UPDATE_0_CHECK\n\n            prob = probs + Literal;\n        if (p-\u003echeck_dic_size != 0 || p-\u003eprocessed_pos != 0)\n            prob += ((U32)kLzmaLitSize *\n            ((((p-\u003eprocessed_pos) \u0026 ((1 \u003c\u003c (p-\u003eprop.lp)) - 1)) \u003c\u003c p-\u003eprop.lc) +\n                (p-\u003edic[(p-\u003edic_pos == 0 ? p-\u003edic_buf_size : p-\u003edic_pos) - 1] \u003e\u003e (8 - p-\u003eprop.lc))));\n\n        if (state \u003c kNumLitStates)\n        {\n            unsigned symbol = 1;\n            do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol \u003c 0x100);\n        }\n        else\n        {\n            unsigned match_byte = p-\u003edic[p-\u003edic_pos - p-\u003ereps[0] +\n                (p-\u003edic_pos \u003c p-\u003ereps[0] ? p-\u003edic_buf_size : 0)];\n            unsigned offs = 0x100;\n            unsigned symbol = 1;\n            do\n            {\n                unsigned bit;\n                const Probability *prob_lit;\n                match_byte += match_byte;\n                bit = offs;\n                offs \u0026= match_byte;\n                prob_lit = prob + (offs + bit + symbol);\n                GET_BIT2_CHECK(prob_lit, symbol, offs ^= bit; , ; )\n            } while (symbol \u003c 0x100);\n        }\n    }\n    else\n    {\n        unsigned len;\n        UPDATE_1_CHECK;\n\n        prob = probs + IsRep + state;\n        IF_BIT_0_CHECK(prob)\n        {\n            UPDATE_0_CHECK;\n            state = 0;\n            prob = probs + LenCoder;\n        }\n        else\n        {\n            UPDATE_1_CHECK;\n            prob = probs + IsRepG0 + state;\n            IF_BIT_0_CHECK(prob)\n            {\n                UPDATE_0_CHECK;\n                prob = probs + IsRep0Long + COMBINED_PS_STATE;\n                IF_BIT_0_CHECK(prob)\n                {\n                    UPDATE_0_CHECK;\n                    NORMALIZE_CHECK;\n                    return 1;\n                }\n                else\n                {\n                    UPDATE_1_CHECK;\n                }\n            }\n            else\n            {\n                UPDATE_1_CHECK;\n                prob = probs + IsRepG1 + state;\n                IF_BIT_0_CHECK(prob)\n                {\n                    UPDATE_0_CHECK;\n                }\n                else\n                {\n                    UPDATE_1_CHECK;\n                    prob = probs + IsRepG2 + state;\n                    IF_BIT_0_CHECK(prob)\n                    {\n                        UPDATE_0_CHECK;\n                    }\n                    else\n                    {\n                        UPDATE_1_CHECK;\n                    }\n                }","filepath":"lzma2_dec.c","line_number":182,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3196416":{"score":0.7062262,"function_name":"LZMA2_getDictSizeFromProp","code":"size_t LZMA2_getDictSizeFromProp(BYTE const dict_prop)\n{\n    if (dict_prop \u003e 40)\n        return FL2_ERROR(corruption_detected);\n\n    size_t const dict_size = (dict_prop == 40)\n        ? (size_t)-1\n        : (((size_t)2 | (dict_prop \u0026 1)) \u003c\u003c (dict_prop / 2 + 11));\n    return dict_size;\n}","filepath":"lzma2_dec.c","line_number":907,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3196464":{"score":0.8293566,"function_name":"LZMA2_dictBufSize","code":"static size_t LZMA2_dictBufSize(size_t const dict_size)\n{\n    size_t mask = ((size_t)1 \u003c\u003c 12) - 1;\n    if (dict_size \u003e= ((size_t)1 \u003c\u003c 30)) mask = ((size_t)1 \u003c\u003c 22) - 1;\n    else if (dict_size \u003e= ((size_t)1 \u003c\u003c 22)) mask = ((size_t)1 \u003c\u003c 20) - 1;\n\n    size_t dic_buf_size = ((size_t)dict_size + mask) \u0026 ~mask;\n    if (dic_buf_size \u003c dict_size)\n        dic_buf_size = dict_size;\n\n    return dic_buf_size;\n}","filepath":"lzma2_dec.c","line_number":918,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3196560":{"score":0.67995065,"function_name":"LZMA2_initDecoder","code":"size_t LZMA2_initDecoder(LZMA2_DCtx *const p, BYTE const dict_prop, BYTE *const dic, size_t dic_buf_size)\n{\n    size_t const dict_size = LZMA2_getDictSizeFromProp(dict_prop);\n    if (FL2_isError(dict_size))\n        return dict_size;\n\n    if (dic == NULL) {\n        dic_buf_size = LZMA2_dictBufSize(dict_size);\n\n        if (p-\u003edic == NULL || dic_buf_size != p-\u003edic_buf_size) {\n            LZMA_freeDict(p);\n            p-\u003edic = malloc(dic_buf_size);\n            if (p-\u003edic == NULL)\n                return FL2_ERROR(memory_allocation);\n            p-\u003eext_dic = 0;\n        }\n    }\n    else {\n        LZMA_freeDict(p);\n        p-\u003edic = dic;\n        p-\u003eext_dic = 1;\n    }\n    p-\u003edic_buf_size = dic_buf_size;\n    p-\u003eprop.lc = 3;\n    p-\u003eprop.lp = 0;\n    p-\u003eprop.lc = 2;\n    p-\u003eprop.dic_size = (U32)dict_size;\n\n    p-\u003estate2 = LZMA2_STATE_CONTROL;\n    p-\u003eneed_init_dic = 1;\n    p-\u003eneed_init_state2 = 1;\n    p-\u003eneed_init_prop = 1;\n    LZMA_init(p);\n    return FL2_error_no_error;\n}","filepath":"lzma2_dec.c","line_number":936,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3197008":{"score":0.74487466,"function_name":"LZMA2_decodeToDic","code":"size_t LZMA2_decodeToDic(LZMA2_DCtx *const p, size_t const dic_limit,\n    const BYTE *const src, size_t *const src_len, ELzmaFinishMode const finish_mode)\n{\n    if (p-\u003estate2 == LZMA2_STATE_ERROR)\n        return FL2_ERROR(corruption_detected);\n    \n    size_t const in_size = *src_len;\n    size_t in_pos = 0;\n    size_t res;\n\n    do {\n        size_t len = in_size - in_pos;\n        res = LZMA2_decodeChunkToDic(p, dic_limit, src + in_pos, \u0026len, finish_mode);\n        in_pos += len;\n        if (FL2_isError(res)) {\n            p-\u003estate2 = LZMA2_STATE_ERROR;\n            break;\n        }\n    } while (res != LZMA_STATUS_FINISHED\n        \u0026\u0026 res != LZMA_STATUS_NEEDS_MORE_INPUT\n        \u0026\u0026 res != LZMA_STATUS_OUTPUT_FULL);\n\n    *src_len = in_pos;\n    return res;\n}","filepath":"lzma2_dec.c","line_number":1137,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3206288":{"score":0.7716944,"function_name":"LZMA2_decodeToBuf","code":"size_t LZMA2_decodeToBuf(LZMA2_DCtx *const p, BYTE *dest, size_t *const dest_len, const BYTE *src, size_t *const src_len, ELzmaFinishMode const finish_mode)\n{\n    size_t out_size = *dest_len, in_size = *src_len;\n    *src_len = *dest_len = 0;\n\n    for (;;)\n    {\n        if (p-\u003edic_pos == p-\u003edic_buf_size)\n            p-\u003edic_pos = 0;\n\n        size_t const dic_pos = p-\u003edic_pos;\n        ELzmaFinishMode cur_finish_mode = LZMA_FINISH_ANY;\n        size_t out_cur = p-\u003edic_buf_size - dic_pos;\n\n        if (out_cur \u003e= out_size) {\n            out_cur = out_size;\n            cur_finish_mode = finish_mode;\n        }\n\n        size_t in_cur = in_size;\n        size_t const res = LZMA2_decodeToDic(p, dic_pos + out_cur, src, \u0026in_cur, cur_finish_mode);\n\n        src += in_cur;\n        in_size -= in_cur;\n        *src_len += in_cur;\n        out_cur = p-\u003edic_pos - dic_pos;\n        memcpy(dest, p-\u003edic + dic_pos, out_cur);\n        dest += out_cur;\n        out_size -= out_cur;\n        *dest_len += out_cur;\n        if (FL2_isError(res) || res == LZMA_STATUS_FINISHED)\n            return res;\n        if (out_cur == 0 || out_size == 0)\n            return FL2_error_no_error;\n    }\n}","filepath":"lzma2_dec.c","line_number":1296,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3206832":{"score":0.84659815,"function_name":"LZMA2_parseInput","code":"LZMA2_parseRes LZMA2_parseInput(const BYTE* const in_buf, size_t const pos, ptrdiff_t const len, LZMA2_chunk *const inf)\n{\n    inf-\u003epack_size = 0;\n    inf-\u003eunpack_size = 0;\n\n    if (len \u003c= 0)\n        return CHUNK_ERROR;\n\n    BYTE const control = in_buf[pos];\n    if (control == 0) {\n        inf-\u003epack_size = 1;\n        return CHUNK_FINAL;\n    }\n    if (len \u003c 3)\n        return CHUNK_MORE_DATA;\n    if (LZMA2_IS_UNCOMPRESSED_STATE(control)) {\n        if (control \u003e 2)\n            return CHUNK_ERROR;\n        inf-\u003eunpack_size = (((U32)in_buf[pos + 1] \u003c\u003c 8) | in_buf[pos + 2]) + 1;\n        inf-\u003epack_size = 3 + inf-\u003eunpack_size;\n    }\n    else {\n        S32 const has_prop = LZMA2_IS_THERE_PROP(LZMA2_GET_LZMA_MODE(control));\n        if (len \u003c 5 + has_prop)\n            return CHUNK_MORE_DATA;\n        inf-\u003eunpack_size = ((U32)(control \u0026 0x1F) \u003c\u003c 16) + ((U32)in_buf[pos + 1] \u003c\u003c 8) + in_buf[pos + 2] + 1;\n        inf-\u003epack_size = 5 + has_prop + ((U32)in_buf[pos + 3] \u003c\u003c 8) + in_buf[pos + 4] + 1;\n        if (LZMA2_GET_LZMA_MODE(control) == 3)\n            return CHUNK_DICT_RESET;\n    }\n    return CHUNK_CONTINUE;\n}","filepath":"lzma2_dec.c","line_number":1350,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3207104":{"score":0.5718631,"function_name":"LZMA_lengthStates_SetPrices","code":"static void LZMA_lengthStates_SetPrices(const LZMA2_prob *probs, U32 start_price, unsigned *prices)\n{\n    for (size_t i = 0; i \u003c 8; i += 2) {\n        U32 prob = probs[4 + (i \u003e\u003e 1)];\n        U32 price = start_price + GET_PRICE(probs[1], (i \u003e\u003e 2))\n            + GET_PRICE(probs[2 + (i \u003e\u003e 2)], (i \u003e\u003e 1) \u0026 1);\n        prices[i] = price + GET_PRICE_0(prob);\n        prices[i + 1] = price + GET_PRICE_1(prob);\n    }\n}","filepath":"lzma2_enc.c","line_number":382,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3207376":{"score":0.84128684,"function_name":"LZMA_reverseOptimalChain","code":"FORCE_NOINLINE\nstatic void LZMA_reverseOptimalChain(LZMA2_node* const opt_buf, size_t cur)\n{\n    unsigned len = (unsigned)opt_buf[cur].len;\n    U32 dist = opt_buf[cur].dist;\n\n    for(;;) {\n        unsigned const extra = (unsigned)opt_buf[cur].extra;\n        cur -= len;\n\n        if (extra) {\n            opt_buf[cur].len = (U32)len;\n            len = extra;\n            if (extra == 1) {\n                opt_buf[cur].dist = dist;\n                dist = kNullDist;\n                --cur;\n            }\n            else {\n                opt_buf[cur].dist = 0;\n                --cur;\n                --len;\n                opt_buf[cur].dist = kNullDist;\n                opt_buf[cur].len = 1;\n                cur -= len;\n            }\n        }\n\n        unsigned const next_len = opt_buf[cur].len;\n        U32 const next_dist = opt_buf[cur].dist;\n\n        opt_buf[cur].dist = dist;\n        opt_buf[cur].len = (U32)len;\n\n        if (cur == 0)\n            break;\n\n        len = next_len;\n        dist = next_dist;\n    }\n}","filepath":"lzma2_enc.c","line_number":775,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3208320":{"score":0.75639075,"function_name":"LZMA_fillDistancesPrices","code":"static void FORCE_NOINLINE LZMA_fillDistancesPrices(LZMA2_ECtx *const enc)\n{\n    U32 * const temp_prices = enc-\u003edistance_prices[kNumLenToPosStates - 1];\n\n    enc-\u003ematch_price_count = 0;\n\n    for (size_t i = kStartPosModelIndex / 2; i \u003c kNumFullDistances / 2; i++) {\n        unsigned const dist_slot = distance_table[i];\n        unsigned footer_bits = (dist_slot \u003e\u003e 1) - 1;\n        size_t base = ((2 | (dist_slot \u0026 1)) \u003c\u003c footer_bits);\n        const LZMA2_prob *probs = enc-\u003estates.dist_encoders + base * 2U;\n        base += i;\n        probs = probs - distance_table[base] - 1;\n        U32 price = 0;\n        unsigned m = 1;\n        unsigned sym = (unsigned)i;\n        unsigned const offset = (unsigned)1 \u003c\u003c footer_bits;\n\n        for (; footer_bits != 0; --footer_bits) {\n            unsigned bit = sym \u0026 1;\n            sym \u003e\u003e= 1;\n            price += GET_PRICE(probs[m], bit);\n            m = (m \u003c\u003c 1) + bit;\n        };\n\n        unsigned const prob = probs[m];\n        temp_prices[base] = price + GET_PRICE_0(prob);\n        temp_prices[base + offset] = price + GET_PRICE_1(prob);\n    }\n\n    for (unsigned lps = 0; lps \u003c kNumLenToPosStates; lps++) {\n        size_t slot;\n        size_t const dist_table_size2 = (enc-\u003edist_price_table_size + 1) \u003e\u003e 1;\n        U32 *const dist_slot_prices = enc-\u003edist_slot_prices[lps];\n        const LZMA2_prob *const probs = enc-\u003estates.dist_slot_encoders[lps];\n\n        for (slot = 0; slot \u003c dist_table_size2; slot++) {\n            /* dist_slot_prices[slot] = RcTree_GetPrice(encoder, kNumPosSlotBits, slot, p-\u003eProbPrices); */\n            U32 price;\n            unsigned bit;\n            unsigned sym = (unsigned)slot + (1 \u003c\u003c (kNumPosSlotBits - 1));\n            bit = sym \u0026 1; sym \u003e\u003e= 1; price = GET_PRICE(probs[sym], bit);\n            bit = sym \u0026 1; sym \u003e\u003e= 1; price += GET_PRICE(probs[sym], bit);\n            bit = sym \u0026 1; sym \u003e\u003e= 1; price += GET_PRICE(probs[sym], bit);\n            bit = sym \u0026 1; sym \u003e\u003e= 1; price += GET_PRICE(probs[sym], bit);\n            bit = sym \u0026 1; sym \u003e\u003e= 1; price += GET_PRICE(probs[sym], bit);\n            unsigned const prob = probs[slot + (1 \u003c\u003c (kNumPosSlotBits - 1))];\n            dist_slot_prices[slot * 2] = price + GET_PRICE_0(prob);\n            dist_slot_prices[slot * 2 + 1] = price + GET_PRICE_1(prob);\n        }\n\n        {\n            U32 delta = ((U32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits) \u003c\u003c kNumBitPriceShiftBits);\n            for (slot = kEndPosModelIndex / 2; slot \u003c dist_table_size2; slot++) {\n                dist_slot_prices[slot * 2] += delta;\n                dist_slot_prices[slot * 2 + 1] += delta;\n                delta += ((U32)1 \u003c\u003c kNumBitPriceShiftBits);\n            }\n        }\n\n        {\n            U32 *const dp = enc-\u003edistance_prices[lps];\n\n            dp[0] = dist_slot_prices[0];\n            dp[1] = dist_slot_prices[1];\n            dp[2] = dist_slot_prices[2];\n            dp[3] = dist_slot_prices[3];\n\n            for (size_t i = 4; i \u003c kNumFullDistances; i += 2) {\n                U32 slot_price = dist_slot_prices[distance_table[i]];\n                dp[i] = slot_price + temp_prices[i];\n                dp[i + 1] = slot_price + temp_prices[i + 1];\n            }\n        }\n    }\n}","filepath":"lzma2_enc.c","line_number":1573,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3209264":{"score":0.6305617,"function_name":"LZMA_lengthStates_updatePrices","code":"FORCE_NOINLINE\nstatic void LZMA_lengthStates_updatePrices(LZMA2_ECtx *const enc, LZMA2_lenStates* const ls)\n{\n    U32 b;\n\n    {\n        unsigned const prob = ls-\u003echoice;\n        U32 a, c;\n        b = GET_PRICE_1(prob);\n        a = GET_PRICE_0(prob);\n        c = b + GET_PRICE_0(ls-\u003elow[0]);\n        for (size_t pos_state = 0; pos_state \u003c= enc-\u003epos_mask; pos_state++) {\n            unsigned *const prices = ls-\u003eprices[pos_state];\n            const LZMA2_prob *const probs = ls-\u003elow + (pos_state \u003c\u003c (1 + kLenNumLowBits));\n            LZMA_lengthStates_SetPrices(probs, a, prices);\n            LZMA_lengthStates_SetPrices(probs + kLenNumLowSymbols, c, prices + kLenNumLowSymbols);\n        }\n    }\n\n    size_t i = ls-\u003etable_size;\n\n    if (i \u003e kLenNumLowSymbols * 2) {\n        const LZMA2_prob *const probs = ls-\u003ehigh;\n        unsigned *const prices = ls-\u003eprices[0] + kLenNumLowSymbols * 2;\n        i = (i - (kLenNumLowSymbols * 2 - 1)) \u003e\u003e 1;\n        b += GET_PRICE_1(ls-\u003elow[0]);\n        do {\n            --i;\n            size_t sym = i + (1 \u003c\u003c (kLenNumHighBits - 1));\n            U32 price = b;\n            do {\n                size_t bit = sym \u0026 1;\n                sym \u003e\u003e= 1;\n                price += GET_PRICE(probs[sym], bit);\n            } while (sym \u003e= 2);\n\n            unsigned const prob = probs[i + (1 \u003c\u003c (kLenNumHighBits - 1))];\n            prices[i * 2] = price + GET_PRICE_0(prob);\n            prices[i * 2 + 1] = price + GET_PRICE_1(prob);\n        } while (i);\n\n        size_t const size = (ls-\u003etable_size - kLenNumLowSymbols * 2) * sizeof(ls-\u003eprices[0][0]);\n        for (size_t pos_state = 1; pos_state \u003c= enc-\u003epos_mask; pos_state++)\n            memcpy(ls-\u003eprices[pos_state] + kLenNumLowSymbols * 2, ls-\u003eprices[0] + kLenNumLowSymbols * 2, size);\n    }\n}","filepath":"lzma2_enc.c","line_number":393,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3209712":{"score":0.62906706,"function_name":"LZMA_encodeRepMatchShort","code":"FORCE_NOINLINE\nstatic void LZMA_encodeRepMatchShort(LZMA2_ECtx *const enc, size_t const pos_state)\n{\n    DEBUGLOG(7, \"LZMA_encodeRepMatchShort\");\n    RC_encodeBit1(\u0026enc-\u003erc, \u0026enc-\u003estates.is_match[enc-\u003estates.state][pos_state]);\n    RC_encodeBit1(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep[enc-\u003estates.state]);\n    RC_encodeBit0(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep_G0[enc-\u003estates.state]);\n    RC_encodeBit0(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep0_long[enc-\u003estates.state][pos_state]);\n    enc-\u003estates.state = SHORT_REP_NEXT_STATE(enc-\u003estates.state);\n}","filepath":"lzma2_enc.c","line_number":468,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3210336":{"score":0.64854664,"function_name":"LZMA_encodeLength","code":"HINT_INLINE\nvoid LZMA_encodeLength(LZMA2_ECtx *const enc, LZMA2_lenStates* const len_prob_table, unsigned len, size_t const pos_state)\n{\n    len -= kMatchLenMin;\n    if (len \u003c kLenNumLowSymbols) {\n        RC_encodeBit0(\u0026enc-\u003erc, \u0026len_prob_table-\u003echoice);\n        RC_encodeBitTree(\u0026enc-\u003erc, len_prob_table-\u003elow + (pos_state \u003c\u003c (1 + kLenNumLowBits)), kLenNumLowBits, len);\n    }\n    else {\n        LZMA_encodeLength_MidHigh(enc, len_prob_table, len, pos_state);\n    }\n}","filepath":"lzma2_enc.c","line_number":455,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3210656":{"score":0.7620755,"function_name":"LZMA_encodeRepMatchLong","code":"FORCE_NOINLINE\nstatic void LZMA_encodeRepMatchLong(LZMA2_ECtx *const enc, unsigned const len, unsigned const rep, size_t const pos_state)\n{\n    DEBUGLOG(7, \"LZMA_encodeRepMatchLong : length %u, rep %u\", len, rep);\n    RC_encodeBit1(\u0026enc-\u003erc, \u0026enc-\u003estates.is_match[enc-\u003estates.state][pos_state]);\n    RC_encodeBit1(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep[enc-\u003estates.state]);\n    if (rep == 0) {\n        RC_encodeBit0(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep_G0[enc-\u003estates.state]);\n        RC_encodeBit1(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep0_long[enc-\u003estates.state][pos_state]);\n    }\n    else {\n        U32 const distance = enc-\u003estates.reps[rep];\n        RC_encodeBit1(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep_G0[enc-\u003estates.state]);\n        if (rep == 1) {\n            RC_encodeBit0(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep_G1[enc-\u003estates.state]);\n        }\n        else {\n            RC_encodeBit1(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep_G1[enc-\u003estates.state]);\n            RC_encodeBit(\u0026enc-\u003erc, \u0026enc-\u003estates.is_rep_G2[enc-\u003estates.state], rep - 2);\n            if (rep == 3)\n                enc-\u003estates.reps[3] = enc-\u003estates.reps[2];\n            enc-\u003estates.reps[2] = enc-\u003estates.reps[1];\n        }\n        enc-\u003estates.reps[1] = enc-\u003estates.reps[0];\n        enc-\u003estates.reps[0] = distance;\n    }\n    LZMA_encodeLength(enc, \u0026enc-\u003estates.rep_len_states, len, pos_state);\n    enc-\u003estates.state = REP_NEXT_STATE(enc-\u003estates.state);\n    ++enc-\u003erep_len_price_count;\n}","filepath":"lzma2_enc.c","line_number":479,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3211696":{"score":0.77791435,"function_name":"LZMA_initMatchesPos0","code":"FORCE_NOINLINE\nstatic void LZMA_initMatchesPos0(LZMA2_ECtx *const enc,\n    RMF_match const match,\n    size_t const pos_state,\n    size_t len,\n    unsigned const normal_match_price)\n{\n    if ((unsigned)len \u003c= match.length) {\n        size_t const distance = match.dist;\n        size_t const slot = LZMA_getDistSlot(match.dist);\n        /* Test every available length of the match */\n        do {\n            unsigned cur_and_len_price = normal_match_price + enc-\u003estates.len_states.prices[pos_state][len - kMatchLenMin];\n            size_t const len_to_dist_state = LEN_TO_DIST_STATE(len);\n\n            if (distance \u003c kNumFullDistances)\n                cur_and_len_price += enc-\u003edistance_prices[len_to_dist_state][distance];\n            else\n                cur_and_len_price += enc-\u003ealign_prices[distance \u0026 kAlignMask] + enc-\u003edist_slot_prices[len_to_dist_state][slot];\n\n            if (cur_and_len_price \u003c enc-\u003eopt_buf[len].price) {\n                enc-\u003eopt_buf[len].price = cur_and_len_price;\n                enc-\u003eopt_buf[len].len = (unsigned)len;\n                enc-\u003eopt_buf[len].dist = (U32)(distance + kNumReps);\n                enc-\u003eopt_buf[len].extra = 0;\n            }\n            ++len;\n        } while ((U32)len \u003c= match.length);\n    }\n}","filepath":"lzma2_enc.c","line_number":1256,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3212096":{"score":0.79306644,"function_name":"LZMA_initMatchesPos0Best","code":"FORCE_NOINLINE\nstatic size_t LZMA_initMatchesPos0Best(LZMA2_ECtx *const enc, FL2_dataBlock const block,\n    RMF_match const match,\n    size_t const pos,\n    size_t start_len,\n    unsigned const normal_match_price)\n{\n    if (start_len \u003c= match.length) {\n        size_t main_len;\n        if (match.length \u003c 3 || block.end - pos \u003c 4) {\n            enc-\u003ematches[0] = match;\n            enc-\u003ematch_count = 1;\n            main_len = match.length;\n        }\n        else {\n            main_len = LZMA_hashGetMatches(enc, block, pos, MIN(block.end - pos, enc-\u003efast_length), match);\n        }\n\n        ptrdiff_t start_match = 0;\n        while (start_len \u003e enc-\u003ematches[start_match].length)\n            ++start_match;\n\n        enc-\u003ematches[start_match - 1].length = (U32)start_len - 1; /* Avoids an if..else branch in the loop. [-1] is ok */\n\n        size_t pos_state = pos \u0026 enc-\u003epos_mask;\n\n        for (ptrdiff_t match_index = enc-\u003ematch_count - 1; match_index \u003e= start_match; --match_index) {\n            size_t len_test = enc-\u003ematches[match_index].length;\n            size_t const distance = enc-\u003ematches[match_index].dist;\n            size_t const slot = LZMA_getDistSlot((U32)distance);\n            size_t const base_len = enc-\u003ematches[match_index - 1].length + 1;\n            /* Test every available match length at the shortest distance. The buffer is sorted */\n            /* in order of increasing length, and therefore increasing distance too. */\n            for (; len_test \u003e= base_len; --len_test) {\n                unsigned cur_and_len_price = normal_match_price\n                    + enc-\u003estates.len_states.prices[pos_state][len_test - kMatchLenMin];\n                size_t const len_to_dist_state = LEN_TO_DIST_STATE(len_test);\n\n                if (distance \u003c kNumFullDistances)\n                    cur_and_len_price += enc-\u003edistance_prices[len_to_dist_state][distance];\n                else\n                    cur_and_len_price += enc-\u003ealign_prices[distance \u0026 kAlignMask] + enc-\u003edist_slot_prices[len_to_dist_state][slot];\n\n                if (cur_and_len_price \u003c enc-\u003eopt_buf[len_test].price) {\n                    enc-\u003eopt_buf[len_test].price = cur_and_len_price;\n                    enc-\u003eopt_buf[len_test].len = (unsigned)len_test;\n                    enc-\u003eopt_buf[len_test].dist = (U32)(distance + kNumReps);\n                    enc-\u003eopt_buf[len_test].extra = 0;\n                }\n                else break;\n            }\n        }\n        return main_len;\n    }\n    return 0;\n}","filepath":"lzma2_enc.c","line_number":1287,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3213360":{"score":0.74860835,"function_name":"LZMA_getLiteralPrice","code":"static unsigned LZMA_getLiteralPrice(LZMA2_ECtx *const enc, size_t const pos, size_t const state, unsigned const prev_symbol, U32 symbol, unsigned const match_byte)\n{\n    const LZMA2_prob* const prob_table = LITERAL_PROBS(enc, pos, prev_symbol);\n    if (IS_LIT_STATE(state)) {\n        unsigned price = 0;\n        symbol |= 0x100;\n        do {\n            price += GET_PRICE(prob_table[symbol \u003e\u003e 8], (symbol \u003e\u003e 7) \u0026 1);\n            symbol \u003c\u003c= 1;\n        } while (symbol \u003c 0x10000);\n        return price;\n    }\n    return LZMA_getLiteralPriceMatched(prob_table, symbol, match_byte);\n}","filepath":"lzma2_enc.c","line_number":817,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3257008":{"score":0.8681612,"function_name":"LZMA2_createECtx","code":"LZMA2_ECtx* LZMA2_createECtx(void)\n{\n    LZMA2_ECtx *const enc = malloc(sizeof(LZMA2_ECtx));\n    DEBUGLOG(3, \"LZMA2_createECtx\");\n    if (enc == NULL)\n        return NULL;\n\n    enc-\u003elc = 3;\n    enc-\u003elp = 0;\n    enc-\u003epb = 2;\n    enc-\u003efast_length = 48;\n    enc-\u003elen_end_max = kOptimizerBufferSize - 1;\n    enc-\u003elit_pos_mask = (1 \u003c\u003c enc-\u003elp) - 1;\n    enc-\u003epos_mask = (1 \u003c\u003c enc-\u003epb) - 1;\n    enc-\u003ematch_cycles = 1;\n    enc-\u003estrategy = FL2_ultra;\n    enc-\u003ematch_price_count = 0;\n    enc-\u003erep_len_price_count = 0;\n    enc-\u003edist_price_table_size = kDistTableSizeMax;\n    enc-\u003ehash_buf = NULL;\n    enc-\u003ehash_dict_3 = 0;\n    enc-\u003echain_mask_3 = 0;\n    enc-\u003ehash_alloc_3 = 0;\n    return enc;\n}","filepath":"lzma2_enc.c","line_number":241,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3257344":{"score":0.7455994,"function_name":"LZMA2_getDictSizeProp","code":"BYTE LZMA2_getDictSizeProp(size_t const dictionary_size)\n{\n    BYTE dict_size_prop = 0;\n    for (BYTE bit = 11; bit \u003c 32; ++bit) {\n        if (((size_t)2 \u003c\u003c bit) \u003e= dictionary_size) {\n            dict_size_prop = (bit - 11) \u003c\u003c 1;\n            break;\n        }\n        if (((size_t)3 \u003c\u003c bit) \u003e= dictionary_size) {\n            dict_size_prop = ((bit - 11) \u003c\u003c 1) | 1;\n            break;\n        }\n    }\n    return dict_size_prop;\n}","filepath":"lzma2_enc.c","line_number":1748,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3257520":{"score":0.6372719,"function_name":"LZMA2_encode","code":"size_t LZMA2_encode(LZMA2_ECtx *const enc,\n    FL2_matchTable* const tbl,\n    FL2_dataBlock const block,\n    const FL2_lzma2Parameters* const options,\n    int stream_prop,\n    FL2_atomic *const progress_in,\n    FL2_atomic *const progress_out,\n    int *const canceled)\n{\n    size_t const start = block.start;\n\n    /* Output starts in the temp buffer */\n    BYTE* out_dest = enc-\u003eout_buf;\n    enc-\u003echunk_size = kTempMinOutput;\n    enc-\u003echunk_limit = kTempBufferSize - kMaxMatchEncodeSize * 2;\n\n    /* Each encoder writes a properties byte because the upstream encoder(s) could */\n\t/* write only uncompressed chunks with no properties. */\n\tBYTE encode_properties = 1;\n    BYTE incompressible = 0;\n\n    if (block.end \u003c= block.start)\n        return 0;\n\n    enc-\u003elc = options-\u003elc;\n    enc-\u003elp = MIN(options-\u003elp, kNumLiteralPosBitsMax);\n\n    if (enc-\u003elc + enc-\u003elp \u003e kLcLpMax)\n        enc-\u003elc = kLcLpMax - enc-\u003elp;\n\n    enc-\u003epb = MIN(options-\u003epb, kNumPositionBitsMax);\n    enc-\u003estrategy = options-\u003estrategy;\n    enc-\u003efast_length = MIN(options-\u003efast_length, kMatchLenMax);\n    enc-\u003ematch_cycles = MIN(options-\u003ematch_cycles, kMatchesMax - 1);\n\n    LZMA2_reset(enc, block.end);\n\n    if (enc-\u003estrategy == FL2_ultra) {\n        /* Create a hash chain to put the encoder into hybrid mode */\n        if (enc-\u003ehash_alloc_3 \u003c ((ptrdiff_t)1 \u003c\u003c options-\u003esecond_dict_bits)) {\n            if(LZMA_hashCreate(enc, options-\u003esecond_dict_bits) != 0)\n                return FL2_ERROR(memory_allocation);\n        }\n        else {\n            LZMA_hashReset(enc, options-\u003esecond_dict_bits);\n        }\n        enc-\u003ehash_prev_index = (start \u003e= (size_t)enc-\u003ehash_dict_3) ? (ptrdiff_t)(start - enc-\u003ehash_dict_3) : (ptrdiff_t)-1;\n    }\n    enc-\u003elen_end_max = kOptimizerBufferSize - 1;\n\n    /* Limit the matches near the end of this slice to not exceed block.end */\n    RMF_limitLengths(tbl, block.end);\n\n    for (size_t pos = start; pos \u003c block.end;) {\n        size_t header_size = (stream_prop \u003e= 0) + (encode_properties ? kChunkHeaderSize + 1 : kChunkHeaderSize);\n        LZMA2_encStates saved_states;\n        size_t next_index;\n\n        RC_reset(\u0026enc-\u003erc);\n        RC_setOutputBuffer(\u0026enc-\u003erc, out_dest + header_size);\n\n        if (!incompressible) {\n            size_t cur = pos;\n            size_t const end = (enc-\u003estrategy == FL2_fast) ? MIN(block.end, pos + kMaxChunkUncompressedSize - kMatchLenMax + 1)\n                : MIN(block.end, pos + kMaxChunkUncompressedSize - kOptimizerBufferSize + 2); /* last byte of opt_buf unused */\n\n            /* Copy states in case chunk is incompressible */\n            saved_states = enc-\u003estates;\n\n            if (pos == 0) {\n                /* First byte of the dictionary */\n                LZMA_encodeLiteral(enc, 0, block.data[0], 0);\n                ++cur;\n            }\n            if (pos == start) {\n                /* After kTempMinOutput bytes we can write data to the match table because the */\n                /* compressed data will never catch up with the table position being read. */\n                cur = LZMA2_encodeChunk(enc, tbl, block, cur, end);\n\n\t\t\t\tif (header_size + enc-\u003erc.out_index \u003e kTempBufferSize)\n\t\t\t\t\treturn FL2_ERROR(internal);\n\n                /* Switch to the match table as output buffer */\n                out_dest = RMF_getTableAsOutputBuffer(tbl, start);\n                memcpy(out_dest, enc-\u003eout_buf, header_size + enc-\u003erc.out_index);\n                enc-\u003erc.out_buffer = out_dest + header_size;\n\n                /* Now encode up to the full chunk size */\n                enc-\u003echunk_size = kChunkSize;\n                enc-\u003echunk_limit = kMaxChunkCompressedSize - kMaxMatchEncodeSize * 2;\n            }\n            next_index = LZMA2_encodeChunk(enc, tbl, block, cur, end);\n            RC_flush(\u0026enc-\u003erc);\n        }\n        else {\n            next_index = MIN(pos + kChunkSize, block.end);\n        }\n        size_t compressed_size = enc-\u003erc.out_index;\n        size_t uncompressed_size = next_index - pos;\n\n        if (compressed_size \u003e kMaxChunkCompressedSize || uncompressed_size \u003e kMaxChunkUncompressedSize)\n            return FL2_ERROR(internal);\n\n        BYTE* header = out_dest;\n\n        if (stream_prop \u003e= 0) {\n            *header++ = (BYTE)stream_prop;\n            stream_prop = -1;\n        }\n\n        header[1] = (BYTE)((uncompressed_size - 1) \u003e\u003e 8);\n        header[2] = (BYTE)(uncompressed_size - 1);\n        /* Output an uncompressed chunk if necessary */\n        if (incompressible || uncompressed_size + 3 \u003c= compressed_size + header_size) {\n            DEBUGLOG(6, \"Storing chunk : was %u =\u003e %u\", (unsigned)uncompressed_size, (unsigned)compressed_size);\n\n            header[0] = (pos == 0) ? kChunkUncompressedDictReset : kChunkUncompressed;\n\n            /* Copy uncompressed data into the output */\n            memcpy(header + 3, block.data + pos, uncompressed_size);\n\n            compressed_size = uncompressed_size;\n            header_size = 3 + (header - out_dest);\n\n            /* Restore states if compression was attempted */\n            if (!incompressible)\n                enc-\u003estates = saved_states;\n        }\n        else {\n            DEBUGLOG(6, \"Compressed chunk : %u =\u003e %u\", (unsigned)uncompressed_size, (unsigned)compressed_size);\n\n            if (pos == 0)\n                header[0] = kChunkCompressedFlag | kChunkAllReset;\n            else if (encode_properties)\n                header[0] = kChunkCompressedFlag | kChunkStatePropertiesReset;\n            else\n                header[0] = kChunkCompressedFlag | kChunkNothingReset;\n\n            header[0] |= (BYTE)((uncompressed_size - 1) \u003e\u003e 16);\n            header[3] = (BYTE)((compressed_size - 1) \u003e\u003e 8);\n            header[4] = (BYTE)(compressed_size - 1);\n            if (encode_properties) {\n                header[5] = LZMA_getLcLpPbCode(enc);\n                encode_properties = 0;\n            }\n        }\n        if (incompressible || uncompressed_size + 3 \u003c= compressed_size + (compressed_size \u003e\u003e kRandomFilterMarginBits) + header_size) {\n            /* Test the next chunk for compressibility */\n            incompressible = LZMA2_isChunkIncompressible(tbl, block, next_index, enc-\u003estrategy);\n        }\n        out_dest += compressed_size + header_size;\n\n        /* Update progress concurrently with other encoder threads */\n        FL2_atomic_add(*progress_in, (long)(next_index - pos));\n        FL2_atomic_add(*progress_out, (long)(compressed_size + header_size));\n\n        pos = next_index;\n\n        if (*canceled)\n            return FL2_ERROR(canceled);\n    }\n    return out_dest - RMF_getTableAsOutputBuffer(tbl, start);\n}","filepath":"lzma2_enc.c","line_number":1937,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3261728":{"score":0.5893897,"function_name":"RMF_getNextList_mt","code":"static ptrdiff_t RMF_getNextList_mt(FL2_matchTable* const tbl)\n{\n    if (tbl-\u003est_index \u003c tbl-\u003eend_index) {\n        long pos = FL2_atomic_increment(tbl-\u003est_index);\n        if (pos \u003c tbl-\u003eend_index)\n            return pos;\n    }\n    return -1;\n}","filepath":"radix_engine.h","line_number":898,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3261760":{"score":0.693841,"function_name":"RMF_getNextList_mt","code":"static ptrdiff_t RMF_getNextList_mt(FL2_matchTable* const tbl)\n{\n    if (tbl-\u003est_index \u003c tbl-\u003eend_index) {\n        long pos = FL2_atomic_increment(tbl-\u003est_index);\n        if (pos \u003c tbl-\u003eend_index)\n            return pos;\n    }\n    return -1;\n}","filepath":"radix_engine.h","line_number":898,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3261808":{"score":0.67981726,"function_name":"RMF_recurseListsBuffered","code":"static void RMF_recurseListsBuffered(RMF_builder* const tbl,\n    const BYTE* const data_block,\n    size_t const block_start,\n    size_t link,\n    U32 depth,\n    U32 const max_depth,\n    U32 orig_list_count,\n    size_t const stack_base)\n{\n    if (orig_list_count \u003c 2 || tbl-\u003ematch_buffer_limit \u003c 2)\n        return;\n\n    /* Create an offset data buffer pointer for reading the next bytes */\n    const BYTE* data_src = data_block + depth;\n    size_t start = 0;\n\n    do {\n        U32 list_count = (U32)(start + orig_list_count);\n\n        if (list_count \u003e tbl-\u003ematch_buffer_limit)\n            list_count = (U32)tbl-\u003ematch_buffer_limit;\n\n        size_t count = start;\n        size_t prev_link = (size_t)-1;\n        size_t rpt = 0;\n        size_t rpt_tail = link;\n        for (; count \u003c list_count; ++count) {\n            /* Pre-load next link */\n            size_t const next_link = GetMatchLink(link);\n            size_t dist = prev_link - link;\n            if (dist \u003e 2) {\n                /* Get 4 data characters for later. This doesn't block on a cache miss. */\n                tbl-\u003ematch_buffer[count].src.u32 = MEM_read32(data_src + link);\n                /* Record the actual location of this suffix */\n                tbl-\u003ematch_buffer[count].from = (U32)link;\n                /* Initialize the next link */\n                tbl-\u003ematch_buffer[count].next = (U32)(count + 1) | (depth \u003c\u003c 24);\n                rpt = 0;\n                prev_link = link;\n                rpt_tail = link;\n                link = next_link;\n            }\n            else {\n                rpt += 3 - dist;\n                /* Do the usual if the repeat is too short */\n                if (rpt \u003c MAX_REPEAT - 2) {\n                    /* Get 4 data characters for later. This doesn't block on a cache miss. */\n                    tbl-\u003ematch_buffer[count].src.u32 = MEM_read32(data_src + link);\n                    /* Record the actual location of this suffix */\n                    tbl-\u003ematch_buffer[count].from = (U32)link;\n                    /* Initialize the next link */\n                    tbl-\u003ematch_buffer[count].next = (U32)(count + 1) | (depth \u003c\u003c 24);\n                    prev_link = link;\n                    link = next_link;\n                }\n                else {\n                    /* Eliminate the repeat from the linked list to save time */\n                    if (dist == 1) {\n                        link = RMF_handleRepeat(tbl, data_block, block_start, link, depth);\n                        count -= MAX_REPEAT / 2;\n                        orig_list_count -= (U32)(rpt_tail - link);\n                    }\n                    else {\n                        link = RMF_handleRepeat2(tbl, data_block, block_start, link, depth);\n                        count -= MAX_REPEAT - 1;\n                        orig_list_count -= (U32)(rpt_tail - link) \u003e\u003e 1;\n                    }\n                    rpt = 0;\n                    list_count = (U32)(start + orig_list_count);\n\n                    if (list_count \u003e tbl-\u003ematch_buffer_limit)\n                        list_count = (U32)tbl-\u003ematch_buffer_limit;\n                }\n            }\n        }\n        count = list_count;\n        /* Make the last element circular so pre-loading doesn't read past the end. */\n        tbl-\u003ematch_buffer[count - 1].next = (U32)(count - 1) | (depth \u003c\u003c 24);\n        U32 overlap = 0;\n        if (list_count \u003c (U32)(start + orig_list_count)) {\n            overlap = list_count \u003e\u003e MATCH_BUFFER_OVERLAP;\n            overlap += !overlap;\n        }\n        RMF_recurseListChunk(tbl, data_block, block_start, depth, max_depth, list_count, stack_base);\n        orig_list_count -= (U32)(list_count - start);\n        /* Copy everything back, except the last link which never changes, and any extra overlap */\n        count -= overlap + (overlap == 0);\n#ifdef RMF_BITPACK\n        if (max_depth \u003e RADIX_MAX_LENGTH) for (size_t pos = 0; pos \u003c count; ++pos) {\n            size_t const from = tbl-\u003ematch_buffer[pos].from;\n            if (from \u003c block_start)\n                return;\n            U32 length = tbl-\u003ematch_buffer[pos].next \u003e\u003e 24;\n            length = (length \u003e RADIX_MAX_LENGTH) ? RADIX_MAX_LENGTH : length;\n            size_t const next = tbl-\u003ematch_buffer[pos].next \u0026 BUFFER_LINK_MASK;\n            SetMatchLinkAndLength(from, tbl-\u003ematch_buffer[next].from, length);\n        }\n        else\n#endif\n            for (size_t pos = 0; pos \u003c count; ++pos) {\n            size_t const from = tbl-\u003ematch_buffer[pos].from;\n            if (from \u003c block_start)\n                return;\n            U32 const length = tbl-\u003ematch_buffer[pos].next \u003e\u003e 24;\n            size_t const next = tbl-\u003ematch_buffer[pos].next \u0026 BUFFER_LINK_MASK;\n            SetMatchLinkAndLength(from, tbl-\u003ematch_buffer[next].from, length);\n        }\n        start = 0;\n        if (overlap) {\n            size_t dest = 0;\n            for (size_t src = list_count - overlap; src \u003c list_count; ++src) {\n                tbl-\u003ematch_buffer[dest].from = tbl-\u003ematch_buffer[src].from;\n                tbl-\u003ematch_buffer[dest].src.u32 = MEM_read32(data_src + tbl-\u003ematch_buffer[src].from);\n                tbl-\u003ematch_buffer[dest].next = (U32)(dest + 1) | (depth \u003c\u003c 24);\n                ++dest;\n            }\n            start = dest;\n        }\n    } while (orig_list_count != 0);\n}","filepath":"radix_engine.h","line_number":176,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3263808":{"score":0.8050374,"function_name":"RMF_recurseLists16","code":"static void RMF_recurseLists16(RMF_builder* const tbl,\n    const BYTE* const data_block,\n    size_t const block_start,\n    size_t link,\n    U32 count,\n    U32 const max_depth)\n{\n    U32 const table_max_depth = MIN(max_depth, RADIX_MAX_LENGTH);\n    /* Offset data pointer. This function is only called at depth 2 */\n    const BYTE* const data_src = data_block + 2;\n    /* Load radix values from the data chars */\n    size_t next_radix_8 = data_src[link];\n    size_t next_radix_16 = next_radix_8 + ((size_t)(data_src[link + 1]) \u003c\u003c 8);\n    size_t reset_list[RADIX8_TABLE_SIZE];\n    size_t reset_count = 0;\n    size_t st_index = 0;\n    /* Last one is done separately */\n    --count;\n    do\n    {\n        /* Pre-load the next link */\n        size_t const next_link = GetInitialMatchLink(link);\n        size_t const radix_8 = next_radix_8;\n        size_t const radix_16 = next_radix_16;\n        /* Initialization doesn't set lengths to 2 because it's a waste of time if buffering is used */\n        SetMatchLength(link, (U32)next_link, 2);\n\n        next_radix_8 = data_src[next_link];\n        next_radix_16 = next_radix_8 + ((size_t)(data_src[next_link + 1]) \u003c\u003c 8);\n\n        U32 prev = tbl-\u003etails_8[radix_8].prev_index;\n        tbl-\u003etails_8[radix_8].prev_index = (U32)link;\n        if (prev != RADIX_NULL_LINK) {\n            /* Link the previous occurrence to this one at length 3. */\n            /* This will be overwritten if a 4 is found. */\n            SetMatchLinkAndLength(prev, (U32)link, 3);\n        }\n        else {\n            reset_list[reset_count++] = radix_8;\n        }\n\n        prev = tbl-\u003etails_16[radix_16].prev_index;\n        tbl-\u003etails_16[radix_16].prev_index = (U32)link;\n        if (prev != RADIX_NULL_LINK) {\n            ++tbl-\u003etails_16[radix_16].list_count;\n            /* Link at length 4, overwriting the 3 */\n            SetMatchLinkAndLength(prev, (U32)link, 4);\n        }\n        else {\n            tbl-\u003etails_16[radix_16].list_count = 1;\n            tbl-\u003estack[st_index].head = (U32)link;\n            /* Store a reference to this table location to retrieve the count at the end */\n            tbl-\u003estack[st_index].count = (U32)radix_16;\n            ++st_index;\n        }\n        link = next_link;\n    } while (--count \u003e 0);\n\n    /* Do the last location */\n    U32 prev = tbl-\u003etails_8[next_radix_8].prev_index;\n    if (prev != RADIX_NULL_LINK)\n        SetMatchLinkAndLength(prev, (U32)link, 3);\n\n    prev = tbl-\u003etails_16[next_radix_16].prev_index;\n    if (prev != RADIX_NULL_LINK) {\n        ++tbl-\u003etails_16[next_radix_16].list_count;\n        SetMatchLinkAndLength(prev, (U32)link, 4);\n    }\n\n    for (size_t i = 0; i \u003c reset_count; ++i)\n        tbl-\u003etails_8[reset_list[i]].prev_index = RADIX_NULL_LINK;\n\n    for (size_t i = 0; i \u003c st_index; ++i) {\n        tbl-\u003etails_16[tbl-\u003estack[i].count].prev_index = RADIX_NULL_LINK;\n        tbl-\u003estack[i].count = tbl-\u003etails_16[tbl-\u003estack[i].count].list_count;\n    }\n\n    while (st_index \u003e 0) {\n        --st_index;\n        U32 const list_count = tbl-\u003estack[st_index].count;\n        if (list_count \u003c 2) {\n            /* Nothing to do */\n            continue;\n        }\n        link = tbl-\u003estack[st_index].head;\n        if (link \u003c block_start)\n            continue;\n        if (st_index \u003e STACK_SIZE - RADIX16_TABLE_SIZE\n            \u0026\u0026 st_index \u003e STACK_SIZE - list_count)\n        {\n            /* Potential stack overflow. Rare. */\n            continue;\n        }\n        /* The current depth */\n        U32 const depth = GetMatchLength(link);\n        if (list_count \u003c= MAX_BRUTE_FORCE_LIST_SIZE) {\n            /* Quicker to use brute force, each string compared with all previous strings */\n            RMF_bruteForce(tbl, data_block,\n                block_start,\n                link,\n                list_count,\n                depth,\n                table_max_depth);\n            continue;\n        }\n        /* Send to the buffer at depth 4 */\n        RMF_recurseListsBuffered(tbl,\n            data_block,\n            block_start,\n            link,\n            (BYTE)depth,\n            (BYTE)max_depth,\n            list_count,\n            st_index);\n    }\n}","filepath":"radix_engine.h","line_number":483,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3264896":{"score":0.738206,"function_name":"#endif","code":"RMF_bitpackInit\n#else\nRMF_structuredInit\n#endif\n(FL2_matchTable* const tbl, const void* const data, size_t const end)\n{\n    if (end \u003c= 2) {\n        for (size_t i = 0; i \u003c end; ++i)\n            SetNull(i);\n        tbl-\u003eend_index = 0;\n        return;\n    }\n#ifdef RMF_REFERENCE\n    if (tbl-\u003eparams.use_ref_mf) {\n        RMF_initReference(tbl, data, end);\n        return;\n    }\n#endif\n\n    SetNull(0);\n\n    const BYTE* const data_block = (const BYTE*)data;\n    size_t st_index = 0;\n    /* Initial 2-byte radix value */\n    size_t radix_16 = ((size_t)data_block[0] \u003c\u003c 8) | data_block[1];\n    tbl-\u003estack[st_index++] = (U32)radix_16;\n    tbl-\u003elist_heads[radix_16].head = 0;\n    tbl-\u003elist_heads[radix_16].count = 1;\n\n    radix_16 = ((size_t)((BYTE)radix_16) \u003c\u003c 8) | data_block[2];\n\n    ptrdiff_t i = 1;\n    ptrdiff_t const block_size = end - 2;\n    for (; i \u003c block_size; ++i) {\n        /* Pre-load the next value for speed increase on some hardware. Execution can continue while memory read is pending */\n        size_t const next_radix = ((size_t)((BYTE)radix_16) \u003c\u003c 8) | data_block[i + 2];\n\n        U32 const prev = tbl-\u003elist_heads[radix_16].head;\n        if (prev != RADIX_NULL_LINK) {\n            /* Link this position to the previous occurrence */\n            InitMatchLink(i, prev);\n            /* Set the previous to this position */\n            tbl-\u003elist_heads[radix_16].head = (U32)i;\n            ++tbl-\u003elist_heads[radix_16].count;\n            radix_16 = next_radix;\n        }\n        else {\n            SetNull(i);\n            tbl-\u003elist_heads[radix_16].head = (U32)i;\n            tbl-\u003elist_heads[radix_16].count = 1;\n            tbl-\u003estack[st_index++] = (U32)radix_16;\n            radix_16 = next_radix;\n        }\n    }\n    /* Handle the last value */\n    if (tbl-\u003elist_heads[radix_16].head != RADIX_NULL_LINK)\n        SetMatchLinkAndLength(block_size, tbl-\u003elist_heads[radix_16].head, 2);\n    else\n        SetNull(block_size);\n\n    /* Never a match at the last byte */\n    SetNull(end - 1);\n\n    tbl-\u003eend_index = (U32)st_index;\n}","filepath":"radix_engine.h","line_number":108,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3265232":{"score":0.6578252,"function_name":"#endif","code":"RMF_bitpackBuildTable\n#else\nRMF_structuredBuildTable\n#endif\n(FL2_matchTable* const tbl,\n    size_t const job,\n    unsigned const multi_thread,\n    FL2_dataBlock const block)\n{\n    if (block.end == 0)\n        return;\n\n    unsigned const best = !tbl-\u003eparams.divide_and_conquer;\n    unsigned const max_depth = MIN(tbl-\u003eparams.depth, STRUCTURED_MAX_LENGTH) \u0026 ~1;\n    size_t bounded_start = max_depth + MAX_READ_BEYOND_DEPTH;\n    bounded_start = block.end - MIN(block.end, bounded_start);\n    ptrdiff_t next_progress = (job == 0) ? 0 : RADIX16_TABLE_SIZE;\n    ptrdiff_t(*getNextList)(FL2_matchTable* const tbl)\n        = multi_thread ? RMF_getNextList_mt : RMF_getNextList_st;\n\n    for (;;)\n    {\n        /* Get the next to process */\n        ptrdiff_t pos = getNextList(tbl);\n\n        if (pos \u003c 0)\n            break;\n\n        while (next_progress \u003c pos) {\n            /* initial value of next_progress ensures only thread 0 executes this */\n            tbl-\u003eprogress += tbl-\u003elist_heads[tbl-\u003estack[next_progress]].count;\n            ++next_progress;\n        }\n        pos = tbl-\u003estack[pos];\n        RMF_tableHead list_head = tbl-\u003elist_heads[pos];\n        tbl-\u003elist_heads[pos].head = RADIX_NULL_LINK;\n        if (list_head.count \u003c 2 || list_head.head \u003c block.start)\n            continue;\n\n#ifdef RMF_REFERENCE\n        if (tbl-\u003eparams.use_ref_mf) {\n            RMF_recurseListsReference(tbl-\u003ebuilders[job], block.data, block.end, list_head.head, list_head.count, max_depth);\n            continue;\n        }\n#endif\n        if (list_head.head \u003e= bounded_start) {\n            RMF_recurseListsBound(tbl-\u003ebuilders[job], block.data, block.end, \u0026list_head, max_depth);\n            if (list_head.count \u003c 2 || list_head.head \u003c block.start)\n                continue;\n        }\n        if (best \u0026\u0026 list_head.count \u003e tbl-\u003ebuilders[job]-\u003ematch_buffer_limit)\n        {\n            /* Not worth buffering or too long */\n            RMF_recurseLists16(tbl-\u003ebuilders[job], block.data, block.start, list_head.head, list_head.count, max_depth);\n        }\n        else {\n            RMF_recurseListsBuffered(tbl-\u003ebuilders[job], block.data, block.start, list_head.head, 2, (BYTE)max_depth, list_head.count, 0);\n        }\n    }\n}","filepath":"radix_engine.h","line_number":922,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3266640":{"score":0.88758445,"function_name":"#endif","code":"RMF_bitpackIntegrityCheck\n#else\nRMF_structuredIntegrityCheck\n#endif\n(const FL2_matchTable* const tbl, const BYTE* const data, size_t pos, size_t const end, unsigned max_depth)\n{\n    max_depth \u0026= ~1;\n    int err = 0;\n    for (pos += !pos; pos \u003c end; ++pos) {\n        if (IsNull(pos))\n            continue;\n        U32 const link = GetMatchLink(pos);\n        if (link \u003e= pos) {\n            printf(\"Forward link at %X to %u\\r\\n\", (U32)pos, link);\n            err = 1;\n            continue;\n        }\n        U32 const length = GetMatchLength(pos);\n        if (pos \u0026\u0026 length \u003c RADIX_MAX_LENGTH \u0026\u0026 link - 1 == GetMatchLink(pos - 1) \u0026\u0026 length + 1 == GetMatchLength(pos - 1))\n            continue;\n        U32 len_test = 0;\n        U32 const limit = MIN((U32)(end - pos), RADIX_MAX_LENGTH);\n        for (; len_test \u003c limit \u0026\u0026 data[link + len_test] == data[pos + len_test]; ++len_test) {\n        }\n        if (len_test \u003c length) {\n            printf(\"Failed integrity check: pos %X, length %u, actual %u\\r\\n\", (U32)pos, length, len_test);\n            err = 1;\n        }\n        if (length \u003c max_depth \u0026\u0026 len_test \u003e length)\n            /* These occur occasionally due to splitting of chains in the buffer when long repeats are present */\n            printf(\"Shortened match at %X: %u of %u\\r\\n\", (U32)pos, length, len_test);\n    }\n    return err;\n}","filepath":"radix_engine.h","line_number":985,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.1"},"3267088":{"score":0.8627723,"function_name":"HandleRepeat","code":"static void HandleRepeat(RMF_buildMatch* const match_buffer,\n    const BYTE* const data_block,\n    size_t const next,\n    U32 count,\n    U32 const rpt_len,\n    U32 const depth,\n    U32 const max_len)\n{\n    size_t index = next;\n    size_t next_i;\n    U32 length = depth + rpt_len;\n    const BYTE* const data = data_block + match_buffer[index].from;\n    const BYTE* const data_2 = data - rpt_len;\n    while (data[length] == data_2[length] \u0026\u0026 length \u003c max_len)\n        ++length;\n    for (; length \u003c= max_len \u0026\u0026 count; --count) {\n        next_i = match_buffer[index].next \u0026 0xFFFFFF;\n        match_buffer[index].next = (U32)next_i | (length \u003c\u003c 24);\n        length += rpt_len;\n        index = next_i;\n    }\n    for (; count; --count) {\n        next_i = match_buffer[index].next \u0026 0xFFFFFF;\n        match_buffer[index].next = (U32)next_i | (max_len \u003c\u003c 24);\n        index = next_i;\n    }\n}","filepath":"radix_mf.c","line_number":229,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.2"},"3267280":{"score":0.7624215,"function_name":"BruteForceBuffered","code":"static void BruteForceBuffered(RMF_builder* const tbl,\n    const BYTE* const data_block,\n    size_t const block_start,\n    size_t index,\n    size_t list_count,\n    size_t const slot,\n    size_t const depth,\n    size_t const max_depth)\n{\n    BruteForceMatch buffer[MAX_BRUTE_FORCE_LIST_SIZE + 1];\n    const BYTE* data_src = data_block + depth;\n    size_t limit = max_depth - depth;\n    const BYTE* start = data_src + block_start;\n    size_t i = 0;\n    for (;;) {\n        buffer[i].index = index;\n        buffer[i].data_src = data_src + tbl-\u003ematch_buffer[index].from;\n        buffer[i].src.u32 = tbl-\u003ematch_buffer[index].src.u32;\n        if (++i \u003e= list_count) {\n            break;\n        }\n        index = tbl-\u003ematch_buffer[index].next \u0026 0xFFFFFF;\n    }\n    i = 0;\n    do {\n        size_t longest = 0;\n        size_t j = i + 1;\n        size_t longest_index = j;\n        const BYTE* data = buffer[i].data_src;\n        do {\n            size_t len_test = slot;\n            while (len_test \u003c 4 \u0026\u0026 buffer[i].src.chars[len_test] == buffer[j].src.chars[len_test] \u0026\u0026 len_test - slot \u003c limit) {\n                ++len_test;\n            }\n            len_test -= slot;\n            if (len_test) {\n                const BYTE* data_2 = buffer[j].data_src;\n                while (data[len_test] == data_2[len_test] \u0026\u0026 len_test \u003c limit) {\n                    ++len_test;\n                }\n            }\n            if (len_test \u003e longest) {\n                longest_index = j;\n                longest = len_test;\n                if (len_test \u003e= limit) {\n                    break;\n                }\n            }\n        } while (++j \u003c list_count);\n        if (longest \u003e 0) {\n            index = buffer[i].index;\n            tbl-\u003ematch_buffer[index].next = (U32)(buffer[longest_index].index | ((depth + longest) \u003c\u003c 24));\n        }\n        ++i;\n    } while (i \u003c list_count - 1 \u0026\u0026 buffer[i].data_src \u003e= start);\n}","filepath":"radix_mf.c","line_number":264,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.2"},"3268112":{"score":0.7402859,"function_name":"RMF_applyParameters_internal","code":"static size_t RMF_applyParameters_internal(FL2_matchTable* const tbl, const RMF_parameters* const params)\n{\n    int const isStruct = RMF_isStructParam(params);\n    unsigned const dictionary_log = tbl-\u003eparams.dictionary_log;\n    /* dictionary is allocated with the struct and is immutable */\n    if (params-\u003edictionary_log \u003e tbl-\u003eparams.dictionary_log\n        || (params-\u003edictionary_log == tbl-\u003eparams.dictionary_log \u0026\u0026 isStruct \u003e tbl-\u003eallocStruct))\n        return FL2_ERROR(parameter_unsupported);\n\n    {   size_t const match_buffer_size = (size_t)1 \u003c\u003c (params-\u003edictionary_log - params-\u003ematch_buffer_log);\n        tbl-\u003eparams = *params;\n        tbl-\u003eparams.dictionary_log = dictionary_log;\n        tbl-\u003eisStruct = isStruct;\n        if (tbl-\u003ebuilders == NULL\n            || match_buffer_size \u003e tbl-\u003ebuilders[0]-\u003ematch_buffer_size)\n        {\n            RMF_freeBuilderTable(tbl-\u003ebuilders, tbl-\u003ethread_count);\n            tbl-\u003ebuilders = RMF_createBuilderTable(tbl-\u003etable, match_buffer_size, tbl-\u003eisStruct ? STRUCTURED_MAX_LENGTH : BITPACK_MAX_LENGTH, tbl-\u003ethread_count);\n            if (tbl-\u003ebuilders == NULL) {\n                return FL2_ERROR(memory_allocation);\n            }\n        }\n        else {\n            for (unsigned i = 0; i \u003c tbl-\u003ethread_count; ++i) {\n                tbl-\u003ebuilders[i]-\u003ematch_buffer_limit = match_buffer_size;\n                tbl-\u003ebuilders[i]-\u003emax_len = tbl-\u003eisStruct ? STRUCTURED_MAX_LENGTH : BITPACK_MAX_LENGTH;\n            }\n        }\n    }\n    return 0;\n}","filepath":"radix_mf.c","line_number":111,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.2"},"3268896":{"score":0.7198943,"function_name":"RMF_createMatchTable","code":"FL2_matchTable* RMF_createMatchTable(const RMF_parameters* const p, size_t const dict_reduce, unsigned const thread_count)\n{\n    int isStruct;\n    size_t dictionary_size;\n\tsize_t table_bytes;\n    FL2_matchTable* tbl;\n    RMF_parameters params = RMF_clampParams(*p);\n\n    RMF_reduceDict(\u0026params, dict_reduce);\n    isStruct = RMF_isStructParam(\u0026params);\n    dictionary_size = (size_t)1 \u003c\u003c params.dictionary_log;\n\n    DEBUGLOG(3, \"RMF_createMatchTable : isStruct %d, dict %u\", isStruct, (U32)dictionary_size);\n\n\ttable_bytes = isStruct ? ((dictionary_size + 3U) / 4U) * sizeof(RMF_unit)\n\t\t: dictionary_size * sizeof(U32);\n    tbl = (FL2_matchTable*)malloc(\n        sizeof(FL2_matchTable) + table_bytes - sizeof(U32));\n    if (!tbl) return NULL;\n\n    tbl-\u003eisStruct = isStruct;\n    tbl-\u003eallocStruct = isStruct;\n    tbl-\u003ethread_count = thread_count;\n    tbl-\u003eparams = params;\n    tbl-\u003ebuilders = NULL;\n\n    RMF_applyParameters_internal(tbl, \u0026params);\n\n    for (size_t i = 0; i \u003c RADIX16_TABLE_SIZE; i += 2) {\n        tbl-\u003elist_heads[i].head = RADIX_NULL_LINK;\n        tbl-\u003elist_heads[i].count = 0;\n        tbl-\u003elist_heads[i + 1].head = RADIX_NULL_LINK;\n        tbl-\u003elist_heads[i + 1].count = 0;\n    }\n    return tbl;\n}","filepath":"radix_mf.c","line_number":152,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.2"},"3269312":{"score":0.5686539,"function_name":"RMF_freeMatchTable","code":"void RMF_freeMatchTable(FL2_matchTable* const tbl)\n{\n    if (tbl == NULL)\n        return;\n    DEBUGLOG(3, \"RMF_freeMatchTable\");\n    RMF_freeBuilderTable(tbl-\u003ebuilders, tbl-\u003ethread_count);\n    free(tbl);\n}","filepath":"radix_mf.c","line_number":189,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.2"},"3273744":{"score":0.69938594,"function_name":"COVER_best_start","code":"void COVER_best_start(COVER_best_t *best) {\n  if (!best) {\n    return;\n  }\n  ZSTD_pthread_mutex_lock(\u0026best-\u003emutex);\n  ++best-\u003eliveJobs;\n  ZSTD_pthread_mutex_unlock(\u0026best-\u003emutex);\n}","filepath":"lib/dictBuilder/cover.c","line_number":835,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v1.3.6"},"3273760":{"score":0.62587714,"function_name":"RMF_initTailTable","code":"static void RMF_initTailTable(RMF_builder* const tbl)\n{\n    for (size_t i = 0; i \u003c RADIX8_TABLE_SIZE; i += 2) {\n        tbl-\u003etails_8[i].prev_index = RADIX_NULL_LINK;\n        tbl-\u003etails_8[i + 1].prev_index = RADIX_NULL_LINK;\n    }\n    for (size_t i = 0; i \u003c RADIX16_TABLE_SIZE; i += 2) {\n        tbl-\u003etails_16[i].prev_index = RADIX_NULL_LINK;\n        tbl-\u003etails_16[i + 1].prev_index = RADIX_NULL_LINK;\n    }\n}","filepath":"radix_mf.c","line_number":29,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.2"},"3273808":{"score":0.6165283,"function_name":"RMF_getTableAsOutputBuffer","code":"BYTE* RMF_getTableAsOutputBuffer(FL2_matchTable* const tbl, size_t const index)\n{\n    if (tbl-\u003eisStruct) {\n        return RMF_structuredAsOutputBuffer(tbl, index);\n    }\n    else {\n        return RMF_bitpackAsOutputBuffer(tbl, index);\n    }\n}","filepath":"radix_mf.c","line_number":656,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v0.9.2"},"3280384":{"score":0.89569205,"function_name":"FL2POOL_thread","code":"static void* FL2POOL_thread(void* opaque)\n{\n    FL2POOL_ctx* const ctx = (FL2POOL_ctx*)opaque;\n    if (!ctx) { return NULL; }\n    FL2_pthread_mutex_lock(\u0026ctx-\u003equeueMutex);\n    for (;;) {\n\n        /* While the mutex is locked, wait for a non-empty queue or until shutdown */\n        while (ctx-\u003equeueIndex \u003e= ctx-\u003equeueEnd \u0026\u0026 !ctx-\u003eshutdown) {\n            FL2_pthread_cond_wait(\u0026ctx-\u003enewJobsCond, \u0026ctx-\u003equeueMutex);\n        }\n        /* empty =\u003e shutting down: so stop */\n        if (ctx-\u003eshutdown) {\n            FL2_pthread_mutex_unlock(\u0026ctx-\u003equeueMutex);\n            return opaque;\n        }\n        /* Pop a job off the queue */\n        size_t n = ctx-\u003equeueIndex;\n        ++ctx-\u003equeueIndex;\n        ++ctx-\u003enumThreadsBusy;\n        /* Unlock the mutex and run the job */\n        FL2_pthread_mutex_unlock(\u0026ctx-\u003equeueMutex);\n\n        ctx-\u003efunction(ctx-\u003eopaque, n);\n\n        FL2_pthread_mutex_lock(\u0026ctx-\u003equeueMutex);\n        --ctx-\u003enumThreadsBusy;\n        /* Signal the master thread waiting for jobs to complete */\n        FL2_pthread_cond_signal(\u0026ctx-\u003ebusyCond);\n    }  /* for (;;) */\n    /* Unreachable */\n}","filepath":"fl2_pool.c","line_number":56,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3280576":{"score":0.7557032,"function_name":"FL2POOL_create","code":"FL2POOL_ctx* FL2POOL_create(size_t numThreads)\n{\n    FL2POOL_ctx* ctx;\n    /* Check the parameters */\n    if (!numThreads) { return NULL; }\n    /* Allocate the context and zero initialize */\n    ctx = calloc(1, sizeof(FL2POOL_ctx) + (numThreads - 1) * sizeof(FL2_pthread_t));\n    if (!ctx) { return NULL; }\n    /* Initialize the busy count and jobs range */\n    ctx-\u003enumThreadsBusy = 0;\n    ctx-\u003equeueIndex = 0;\n    ctx-\u003equeueEnd = 0;\n    (void)FL2_pthread_mutex_init(\u0026ctx-\u003equeueMutex, NULL);\n    (void)FL2_pthread_cond_init(\u0026ctx-\u003ebusyCond, NULL);\n    (void)FL2_pthread_cond_init(\u0026ctx-\u003enewJobsCond, NULL);\n    ctx-\u003eshutdown = 0;\n    ctx-\u003enumThreads = 0;\n    /* Initialize the threads */\n    {   size_t i;\n        for (i = 0; i \u003c numThreads; ++i) {\n            if (FL2_pthread_create(\u0026ctx-\u003ethreads[i], NULL, \u0026FL2POOL_thread, ctx)) {\n                ctx-\u003enumThreads = i;\n                FL2POOL_free(ctx);\n                return NULL;\n        }   }\n        ctx-\u003enumThreads = numThreads;\n    }\n    return ctx;\n}","filepath":"fl2_pool.c","line_number":89,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3280944":{"score":0.70603377,"function_name":"FL2POOL_free","code":"void FL2POOL_free(FL2POOL_ctx *ctx)\n{\n    if (!ctx) { return; }\n    FL2POOL_join(ctx);\n    FL2_pthread_mutex_destroy(\u0026ctx-\u003equeueMutex);\n    FL2_pthread_cond_destroy(\u0026ctx-\u003ebusyCond);\n    FL2_pthread_cond_destroy(\u0026ctx-\u003enewJobsCond);\n    free(ctx);\n}","filepath":"fl2_pool.c","line_number":135,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3281136":{"score":0.8055706,"function_name":"FL2POOL_addRange","code":"void FL2POOL_addRange(void* ctxVoid, FL2POOL_function function, void *opaque, ptrdiff_t first, ptrdiff_t end)\n{\n    FL2POOL_ctx* const ctx = (FL2POOL_ctx*)ctxVoid;\n    if (!ctx)\n\t\treturn; \n\n    /* Callers always wait for jobs to complete before adding a new set */\n    assert(!ctx-\u003enumThreadsBusy);\n\n    FL2_pthread_mutex_lock(\u0026ctx-\u003equeueMutex);\n    ctx-\u003efunction = function;\n    ctx-\u003eopaque = opaque;\n    ctx-\u003equeueIndex = first;\n    ctx-\u003equeueEnd = end;\n    FL2_pthread_cond_broadcast(\u0026ctx-\u003enewJobsCond);\n    FL2_pthread_mutex_unlock(\u0026ctx-\u003equeueMutex);\n}","filepath":"fl2_pool.c","line_number":151,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3281264":{"score":0.6943913,"function_name":"FL2POOL_addRange","code":"void FL2POOL_addRange(void* ctxVoid, FL2POOL_function function, void *opaque, ptrdiff_t first, ptrdiff_t end)\n{\n    FL2POOL_ctx* const ctx = (FL2POOL_ctx*)ctxVoid;\n    if (!ctx)\n\t\treturn; \n\n    /* Callers always wait for jobs to complete before adding a new set */\n    assert(!ctx-\u003enumThreadsBusy);\n\n    FL2_pthread_mutex_lock(\u0026ctx-\u003equeueMutex);\n    ctx-\u003efunction = function;\n    ctx-\u003eopaque = opaque;\n    ctx-\u003equeueIndex = first;\n    ctx-\u003equeueEnd = end;\n    FL2_pthread_cond_broadcast(\u0026ctx-\u003enewJobsCond);\n    FL2_pthread_mutex_unlock(\u0026ctx-\u003equeueMutex);\n}","filepath":"fl2_pool.c","line_number":151,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3281376":{"score":0.8098731,"function_name":"FL2POOL_waitAll","code":"int FL2POOL_waitAll(void *ctxVoid, unsigned timeout)\n{\n    FL2POOL_ctx* const ctx = (FL2POOL_ctx*)ctxVoid;\n    if (!ctx || (!ctx-\u003enumThreadsBusy \u0026\u0026 ctx-\u003equeueIndex \u003e= ctx-\u003equeueEnd) || ctx-\u003eshutdown) { return 0; }\n\n    FL2_pthread_mutex_lock(\u0026ctx-\u003equeueMutex);\n    /* Need to test for ctx-\u003equeueIndex \u003c ctx-\u003equeueEnd in case not all jobs have started */\n    if (timeout != 0) {\n        if ((ctx-\u003enumThreadsBusy || ctx-\u003equeueIndex \u003c ctx-\u003equeueEnd) \u0026\u0026 !ctx-\u003eshutdown)\n            FL2_pthread_cond_timedwait(\u0026ctx-\u003ebusyCond, \u0026ctx-\u003equeueMutex, timeout);\n    }\n    else {\n        while ((ctx-\u003enumThreadsBusy || ctx-\u003equeueIndex \u003c ctx-\u003equeueEnd) \u0026\u0026 !ctx-\u003eshutdown)\n            FL2_pthread_cond_wait(\u0026ctx-\u003ebusyCond, \u0026ctx-\u003equeueMutex);\n    }\n    FL2_pthread_mutex_unlock(\u0026ctx-\u003equeueMutex);\n    return ctx-\u003enumThreadsBusy \u0026\u0026 !ctx-\u003eshutdown;\n}","filepath":"fl2_pool.c","line_number":174,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3281792":{"score":0.93793595,"function_name":"UTIL_fileExist","code":"int UTIL_fileExist(const char* filename)\n{\n    stat_t statbuf;\n#if defined(_MSC_VER)\n    int const stat_error = _stat64(filename, \u0026statbuf);\n#else\n    int const stat_error = stat(filename, \u0026statbuf);\n#endif\n    return !stat_error;\n}","filepath":"util.c","line_number":24,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3281872":{"score":0.8741228,"function_name":"UTIL_isLink","code":"U32 UTIL_isLink(const char* infilename)\n{\n/* macro guards, as defined in : https://linux.die.net/man/2/lstat */\n#ifndef __STRICT_ANSI__\n#if defined(_BSD_SOURCE) \\\n    || (defined(_XOPEN_SOURCE) \u0026\u0026 (_XOPEN_SOURCE \u003e= 500)) \\\n    || (defined(_XOPEN_SOURCE) \u0026\u0026 defined(_XOPEN_SOURCE_EXTENDED)) \\\n    || (defined(_POSIX_C_SOURCE) \u0026\u0026 (_POSIX_C_SOURCE \u003e= 200112L)) \\\n    || (defined(__APPLE__) \u0026\u0026 defined(__MACH__)) \\\n    || defined(__OpenBSD__) \\\n    || defined(__FreeBSD__)\n    int r;\n    stat_t statbuf;\n    r = lstat(infilename, \u0026statbuf);\n    if (!r \u0026\u0026 S_ISLNK(statbuf.st_mode)) return 1;\n#endif\n#endif\n    (void)infilename;\n    return 0;\n}","filepath":"util.c","line_number":90,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3281968":{"score":0.8435762,"function_name":"UTIL_getFileStat","code":"int UTIL_getFileStat(const char* infilename, stat_t *statbuf)\n{\n    int r;\n#if defined(_MSC_VER)\n    r = _stat64(infilename, statbuf);\n    if (r || !(statbuf-\u003est_mode \u0026 S_IFREG)) return 0;   /* No good... */\n#else\n    r = stat(infilename, statbuf);\n    if (r || !S_ISREG(statbuf-\u003est_mode)) return 0;   /* No good... */\n#endif\n    return 1;\n}","filepath":"util.c","line_number":41,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3282016":{"score":0.89373606,"function_name":"UTIL_setFileStat","code":"int UTIL_setFileStat(const char *filename, stat_t *statbuf)\n{\n    int res = 0;\n    struct utimbuf timebuf;\n\n    if (!UTIL_isRegularFile(filename))\n        return -1;\n\n    timebuf.actime = time(NULL);\n    timebuf.modtime = statbuf-\u003est_mtime;\n    res += utime(filename, \u0026timebuf);  /* set access and modification times */\n\n#if !defined(_WIN32)\n    res += chown(filename, statbuf-\u003est_uid, statbuf-\u003est_gid);  /* Copy ownership */\n#endif\n\n    res += chmod(filename, statbuf-\u003est_mode \u0026 07777);  /* Copy file permissions */\n\n    errno = 0;\n    return -res; /* number of errors is returned */\n}","filepath":"util.c","line_number":54,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3282240":{"score":0.8744149,"function_name":"UTIL_isLink","code":"U32 UTIL_isLink(const char* infilename)\n{\n/* macro guards, as defined in : https://linux.die.net/man/2/lstat */\n#ifndef __STRICT_ANSI__\n#if defined(_BSD_SOURCE) \\\n    || (defined(_XOPEN_SOURCE) \u0026\u0026 (_XOPEN_SOURCE \u003e= 500)) \\\n    || (defined(_XOPEN_SOURCE) \u0026\u0026 defined(_XOPEN_SOURCE_EXTENDED)) \\\n    || (defined(_POSIX_C_SOURCE) \u0026\u0026 (_POSIX_C_SOURCE \u003e= 200112L)) \\\n    || (defined(__APPLE__) \u0026\u0026 defined(__MACH__)) \\\n    || defined(__OpenBSD__) \\\n    || defined(__FreeBSD__)\n    int r;\n    stat_t statbuf;\n    r = lstat(infilename, \u0026statbuf);\n    if (!r \u0026\u0026 S_ISLNK(statbuf.st_mode)) return 1;\n#endif\n#endif\n    (void)infilename;\n    return 0;\n}","filepath":"util.c","line_number":90,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3282336":{"score":0.9000414,"function_name":"UTIL_isLink","code":"U32 UTIL_isLink(const char* infilename)\n{\n/* macro guards, as defined in : https://linux.die.net/man/2/lstat */\n#ifndef __STRICT_ANSI__\n#if defined(_BSD_SOURCE) \\\n    || (defined(_XOPEN_SOURCE) \u0026\u0026 (_XOPEN_SOURCE \u003e= 500)) \\\n    || (defined(_XOPEN_SOURCE) \u0026\u0026 defined(_XOPEN_SOURCE_EXTENDED)) \\\n    || (defined(_POSIX_C_SOURCE) \u0026\u0026 (_POSIX_C_SOURCE \u003e= 200112L)) \\\n    || (defined(__APPLE__) \u0026\u0026 defined(__MACH__)) \\\n    || defined(__OpenBSD__) \\\n    || defined(__FreeBSD__)\n    int r;\n    stat_t statbuf;\n    r = lstat(infilename, \u0026statbuf);\n    if (!r \u0026\u0026 S_ISLNK(statbuf.st_mode)) return 1;\n#endif\n#endif\n    (void)infilename;\n    return 0;\n}","filepath":"util.c","line_number":90,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3282432":{"score":0.6771072,"function_name":"UTIL_getFileSize","code":"U64 UTIL_getFileSize(const char* infilename)\n{\n    if (!UTIL_isRegularFile(infilename)) return UTIL_FILESIZE_UNKNOWN;\n    {   int r;\n#if defined(_MSC_VER)\n        struct __stat64 statbuf;\n        r = _stat64(infilename, \u0026statbuf);\n        if (r || !(statbuf.st_mode \u0026 S_IFREG)) return UTIL_FILESIZE_UNKNOWN;\n#elif defined(__MINGW32__) \u0026\u0026 defined (__MSVCRT__)\n        struct _stati64 statbuf;\n        r = _stati64(infilename, \u0026statbuf);\n        if (r || !(statbuf.st_mode \u0026 S_IFREG)) return UTIL_FILESIZE_UNKNOWN;\n#else\n        struct stat statbuf;\n        r = stat(infilename, \u0026statbuf);\n        if (r || !S_ISREG(statbuf.st_mode)) return UTIL_FILESIZE_UNKNOWN;\n#endif\n        return (U64)statbuf.st_size;\n    }\n}","filepath":"util.c","line_number":111,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3282608":{"score":0.7959334,"function_name":"UTIL_getTotalFileSize","code":"U64 UTIL_getTotalFileSize(const char* const * const fileNamesTable, unsigned nbFiles)\n{\n    U64 total = 0;\n    int error = 0;\n    unsigned n;\n    for (n=0; n\u003cnbFiles; n++) {\n        U64 const size = UTIL_getFileSize(fileNamesTable[n]);\n        error |= (size == UTIL_FILESIZE_UNKNOWN);\n        total += size;\n    }\n    return error ? UTIL_FILESIZE_UNKNOWN : total;\n}","filepath":"util.c","line_number":133,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3282736":{"score":0.9222223,"function_name":"UTIL_prepareFileList","code":"int UTIL_prepareFileList(const char *dirName, char** bufStart, size_t* pos, char** bufEnd, int followLinks)\n{\n    DIR *dir;\n    struct dirent *entry;\n    char* path;\n    int dirLength, fnameLength, pathLength, nbFiles = 0;\n\n    if (!(dir = opendir(dirName))) {\n        UTIL_DISPLAYLEVEL(1, \"Cannot open directory '%s': %s\\n\", dirName, strerror(errno));\n        return 0;\n    }\n\n    dirLength = (int)strlen(dirName);\n    errno = 0;\n    while ((entry = readdir(dir)) != NULL) {\n        if (strcmp (entry-\u003ed_name, \"..\") == 0 ||\n            strcmp (entry-\u003ed_name, \".\") == 0) continue;\n        fnameLength = (int)strlen(entry-\u003ed_name);\n        path = (char*) malloc(dirLength + fnameLength + 2);\n        if (!path) { closedir(dir); return 0; }\n        memcpy(path, dirName, dirLength);\n\n        path[dirLength] = '/';\n        memcpy(path+dirLength+1, entry-\u003ed_name, fnameLength);\n        pathLength = dirLength+1+fnameLength;\n        path[pathLength] = 0;\n\n        if (!followLinks \u0026\u0026 UTIL_isLink(path)) {\n            UTIL_DISPLAYLEVEL(2, \"Warning : %s is a symbolic link, ignoring\\n\", path);\n            continue;\n        }\n\n        if (UTIL_isDirectory(path)) {\n            nbFiles += UTIL_prepareFileList(path, bufStart, pos, bufEnd, followLinks);  /* Recursively call \"UTIL_prepareFileList\" with the new path. */\n            if (*bufStart == NULL) { free(path); closedir(dir); return 0; }\n        } else {\n            if (*bufStart + *pos + pathLength \u003e= *bufEnd) {\n                ptrdiff_t newListSize = (*bufEnd - *bufStart) + LIST_SIZE_INCREASE;\n                *bufStart = (char*)UTIL_realloc(*bufStart, newListSize);\n                *bufEnd = *bufStart + newListSize;\n                if (*bufStart == NULL) { free(path); closedir(dir); return 0; }\n            }\n            if (*bufStart + *pos + pathLength \u003c *bufEnd) {\n                memcpy(*bufStart + *pos, path, pathLength + 1);  /* with final \\0 */\n                *pos += pathLength + 1;\n                nbFiles++;\n            }\n        }\n        free(path);\n        errno = 0; /* clear errno after UTIL_isDirectory, UTIL_prepareFileList */\n    }\n\n    if (errno != 0) {\n        UTIL_DISPLAYLEVEL(1, \"readdir(%s) error: %s\\n\", dirName, strerror(errno));\n        free(*bufStart);\n        *bufStart = NULL;\n    }\n    closedir(dir);\n    return nbFiles;\n}","filepath":"util.c","line_number":210,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3283696":{"score":0.8786909,"function_name":"UTIL_createFileList","code":"const char**\nUTIL_createFileList(const char **inputNames, unsigned inputNamesNb,\n                    char** allocatedBuffer, unsigned* allocatedNamesNb,\n                    int followLinks)\n{\n    size_t pos;\n    unsigned i, nbFiles;\n    char* buf = (char*)malloc(LIST_SIZE_INCREASE);\n    char* bufend = buf + LIST_SIZE_INCREASE;\n    const char** fileTable;\n\n    if (!buf) return NULL;\n\n    for (i=0, pos=0, nbFiles=0; i\u003cinputNamesNb; i++) {\n        if (!UTIL_isDirectory(inputNames[i])) {\n            size_t const len = strlen(inputNames[i]);\n            if (buf + pos + len \u003e= bufend) {\n                ptrdiff_t newListSize = (bufend - buf) + LIST_SIZE_INCREASE;\n                buf = (char*)UTIL_realloc(buf, newListSize);\n                bufend = buf + newListSize;\n                if (!buf) return NULL;\n            }\n            if (buf + pos + len \u003c bufend) {\n                memcpy(buf+pos, inputNames[i], len+1);  /* with final \\0 */\n                pos += len + 1;\n                nbFiles++;\n            }\n        } else {\n            nbFiles += UTIL_prepareFileList(inputNames[i], \u0026buf, \u0026pos, \u0026bufend, followLinks);\n            if (buf == NULL) return NULL;\n    }   }\n\n    if (nbFiles == 0) { free(buf); return NULL; }\n\n    fileTable = (const char**)malloc((nbFiles+1) * sizeof(const char*));\n    if (!fileTable) { free(buf); return NULL; }\n\n    for (i=0, pos=0; i\u003cnbFiles; i++) {\n        fileTable[i] = buf + pos;\n        pos += strlen(fileTable[i]) + 1;\n    }\n\n    if (buf + pos \u003e bufend) { free(buf); free((void*)fileTable); return NULL; }\n\n    *allocatedBuffer = buf;\n    *allocatedNamesNb = nbFiles;\n\n    return fileTable;\n}","filepath":"util.c","line_number":288,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3284512":{"score":0.79484725,"function_name":"UTIL_getSpanTime","code":"UTIL_time_t UTIL_getSpanTime(UTIL_time_t begin, UTIL_time_t end)\n{\n    UTIL_time_t diff;\n    if (end.tv_nsec \u003c begin.tv_nsec) {\n        diff.tv_sec = (end.tv_sec - 1) - begin.tv_sec;\n        diff.tv_nsec = (end.tv_nsec + 1000000000ULL) - begin.tv_nsec;\n    } else {\n        diff.tv_sec = end.tv_sec - begin.tv_sec;\n        diff.tv_nsec = end.tv_nsec - begin.tv_nsec;\n    }\n    return diff;\n}","filepath":"util.c","line_number":415,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3284656":{"score":0.7557037,"function_name":"UTIL_getSpanTimeMicro","code":"U64 UTIL_getSpanTimeMicro(UTIL_time_t begin, UTIL_time_t end)\n{\n    UTIL_time_t const diff = UTIL_getSpanTime(begin, end);\n    U64 micro = 0;\n    micro += 1000000ULL * diff.tv_sec;\n    micro += diff.tv_nsec / 1000ULL;\n    return micro;\n}","filepath":"util.c","line_number":428,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3284864":{"score":0.71616215,"function_name":"UTIL_getSpanTimeNano","code":"U64 UTIL_getSpanTimeNano(UTIL_time_t begin, UTIL_time_t end)\n{\n    UTIL_time_t const diff = UTIL_getSpanTime(begin, end);\n    U64 nano = 0;\n    nano += 1000000000ULL * diff.tv_sec;\n    nano += diff.tv_nsec;\n    return nano;\n}","filepath":"util.c","line_number":437,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3285056":{"score":0.7282923,"function_name":"UTIL_waitForNextTick","code":"void UTIL_waitForNextTick(void)\n{\n    UTIL_time_t const clockStart = UTIL_getTime();\n    UTIL_time_t clockEnd;\n    do {\n        clockEnd = UTIL_getTime();\n    } while (UTIL_getSpanTimeNano(clockStart, clockEnd) == 0);\n}","filepath":"util.c","line_number":468,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3285344":{"score":0.8708246,"function_name":"UTIL_countPhysicalCores","code":"int UTIL_countPhysicalCores(void)\n{\n    static int numPhysicalCores = 0;\n\n    if (numPhysicalCores != 0) return numPhysicalCores;\n\n    numPhysicalCores = (int)sysconf(_SC_NPROCESSORS_ONLN);\n    if (numPhysicalCores == -1) {\n        /* value not queryable, fall back on 1 */\n        return numPhysicalCores = 1;\n    }\n\n    /* try to determine if there's hyperthreading */\n    {   FILE* const cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n#define BUF_SIZE 80\n        char buff[BUF_SIZE];\n\n        int siblings = 0;\n        int cpu_cores = 0;\n        int ratio = 1;\n\n        if (cpuinfo == NULL) {\n            /* fall back on the sysconf value */\n            return numPhysicalCores;\n        }\n\n        /* assume the cpu cores/siblings values will be constant across all\n         * present processors */\n        while (!feof(cpuinfo)) {\n            if (fgets(buff, BUF_SIZE, cpuinfo) != NULL) {\n                if (strncmp(buff, \"siblings\", 8) == 0) {\n                    const char* const sep = strchr(buff, ':');\n                    if (*sep == '\\0') {\n                        /* formatting was broken? */\n                        goto failed;\n                    }\n\n                    siblings = atoi(sep + 1);\n                }\n                if (strncmp(buff, \"cpu cores\", 9) == 0) {\n                    const char* const sep = strchr(buff, ':');\n                    if (*sep == '\\0') {\n                        /* formatting was broken? */\n                        goto failed;\n                    }\n\n                    cpu_cores = atoi(sep + 1);\n                }\n            } else if (ferror(cpuinfo)) {\n                /* fall back on the sysconf value */\n                goto failed;\n            }\n        }\n        if (siblings \u0026\u0026 cpu_cores) {\n            ratio = siblings / cpu_cores;\n        }\nfailed:\n        fclose(cpuinfo);\n        return numPhysicalCores = numPhysicalCores / ratio;\n    }\n}","filepath":"util.c","line_number":583,"entry_url":"https://github.com/conor42/fast-lzma2.git","slot_name":"v1.0.0"},"3286112":{"score":0.62695104,"function_name":"clear_counts","code":"void clear_counts(uint32_t symbol_counts[0x100], uint32_t order_1_counts[0x100][0x100]) {\r\n  uint8_t i = 0xFF;\r\n  do {\r\n    symbol_counts[i] = 0;\r\n    uint8_t j = 0xFF;\r\n    do {\r\n      order_1_counts[i][j] = 0;\r\n    } while (j-- != 0);\r\n  } while (i-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAformat.c","line_number":33,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3286208":{"score":0.7644856,"function_name":"calculate_order_1_entropy","code":"double calculate_order_1_entropy(uint32_t symbol_counts[0x100], uint32_t order_1_counts[0x100][0x100]) {\r\n  uint16_t i, j;\r\n  uint16_t num_symbols = 0;\r\n  double entropy = 0.0;\r\n  for (i = 0 ; i \u003c 0x100 ; i++) {\r\n    if (symbol_counts[i] != 0) {\r\n      num_symbols++;\r\n      entropy += (double)symbol_counts[i] * log2((double)symbol_counts[i]);\r\n      for (j = 0 ; j \u003c 0x100 ; j++) {\r\n        if (order_1_counts[i][j]) {\r\n          double d_count = (double)order_1_counts[i][j];\r\n          entropy -= d_count * log2(d_count);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  entropy += (double)num_symbols * (log2((double)num_symbols) + 11.0);\r\n  return(entropy);\r\n}","filepath":"glza/GLZAformat.c","line_number":46,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3286480":{"score":0.83787125,"function_name":"GLZAformat","code":"uint8_t GLZAformat(size_t insize, uint8_t * inbuf, size_t * outsize_ptr, uint8_t ** outbuf, struct param_data * params) {\r\n  const uint32_t CHARS_TO_WRITE = 0x40000;\r\n  uint8_t this_char, prev_char, next_char, cap_encoded, cap_lock_disabled, delta_disabled, stride;\r\n  uint8_t *in_char_ptr, *end_char_ptr, *out_char_ptr;\r\n  uint32_t i, j, k;\r\n  uint32_t num_AZ, num_az_pre_AZ, num_az_post_AZ, num_spaces;\r\n  uint32_t order_1_counts[0x100][0x100];\r\n  uint32_t symbol_counts[0x100];\r\n  double order_1_entropy, best_stride_entropy, saved_entropy[4];\r\n\r\n  // format byte: B0: cap encoded, B3:B1 = stride (0 - 4), B5:B4 = log2 delta length (0 - 2), B6: little endian\r\n\r\n  cap_encoded = 0;\r\n  cap_lock_disabled = 0;\r\n  delta_disabled = 0;\r\n  if (params != 0) {\r\n    cap_encoded = params-\u003ecap_encoded;\r\n    cap_lock_disabled = params-\u003ecap_lock_disabled;\r\n    delta_disabled = params-\u003edelta_disabled;\r\n  }\r\n\r\n  *outbuf = (uint8_t *)malloc(2 * insize + 1);\r\n  if (*outbuf == 0)\r\n    return(0);\r\n\r\n  end_char_ptr = inbuf + insize;\r\n  num_AZ = 0;\r\n  num_az_pre_AZ = 0;\r\n  num_az_post_AZ = 0;\r\n  num_spaces = 0;\r\n\r\n  if (insize \u003e 4) {\r\n    in_char_ptr = inbuf;\r\n    this_char = *in_char_ptr++;\r\n    if (this_char == 0x20)\r\n      num_spaces++;\r\n    if ((this_char \u003e= 'A') \u0026\u0026 (this_char \u003c= 'Z')) {\r\n      num_AZ++;\r\n      next_char = *in_char_ptr \u0026 0xDF;\r\n      if ((next_char \u003e= 'A') \u0026\u0026 (next_char \u003c= 'Z'))\r\n        num_az_post_AZ++;\r\n    }\r\n\r\n    while (in_char_ptr != end_char_ptr) {\r\n      this_char = *in_char_ptr++;\r\n      if (this_char == 0x20)\r\n        num_spaces++;\r\n      if ((this_char \u003e= 'A') \u0026\u0026 (this_char \u003c= 'Z')) {\r\n        num_AZ++;\r\n        prev_char = *(in_char_ptr - 2) \u0026 0xDF;\r\n        next_char = *in_char_ptr \u0026 0xDF;\r\n        if ((next_char \u003e= 'A') \u0026\u0026 (next_char \u003c= 'Z'))\r\n          num_az_post_AZ++;\r\n        if ((prev_char \u003e= 'A') \u0026\u0026 (prev_char \u003c= 'Z'))\r\n          num_az_pre_AZ++;\r\n      }\r\n    }\r\n  }\r\n\r\n  out_char_ptr = *outbuf;\r\n\r\n  if (((4 * num_az_post_AZ \u003e num_AZ) \u0026\u0026 (num_az_post_AZ \u003e num_az_pre_AZ) \u0026\u0026 (num_spaces \u003e insize / 50)\r\n      \u0026\u0026 (cap_encoded != 2)) || (cap_encoded == 1)) {\r\n#ifdef PRINTON\r\n    fprintf(stderr, \"Converting textual data\\n\");\r\n#endif\r\n    *out_char_ptr++ = 1;\r\n    in_char_ptr = inbuf;\r\n    while (in_char_ptr != end_char_ptr) {\r\n      if ((*in_char_ptr \u003e= 'A') \u0026\u0026 (*in_char_ptr \u003c= 'Z')) {\r\n        if (((*(in_char_ptr + 1) \u003e= 'A') \u0026\u0026 (*(in_char_ptr + 1) \u003c= 'Z') \u0026\u0026 (cap_lock_disabled == 0))\r\n            \u0026\u0026 ((*(in_char_ptr + 2) \u003c 'a') || (*(in_char_ptr + 2) \u003e 'z'))) {\r\n          *out_char_ptr++ = 'B';\r\n          *out_char_ptr++ = *in_char_ptr++ + 0x20;\r\n          *out_char_ptr++ = *in_char_ptr++ + 0x20;\r\n          while ((*in_char_ptr \u003e= 'A') \u0026\u0026 (*in_char_ptr \u003c= 'Z'))\r\n            *out_char_ptr++ = *in_char_ptr++ + 0x20;\r\n          if ((*in_char_ptr \u003e= 'a') \u0026\u0026 (*in_char_ptr \u003c= 'z'))\r\n            *out_char_ptr++ = 'C';\r\n        }\r\n        else {\r\n          *out_char_ptr++ = 'C';\r\n          *out_char_ptr++ = *in_char_ptr++ + 0x20;\r\n        }\r\n      }\r\n      else if (*in_char_ptr == 0xA) {\r\n        in_char_ptr++;\r\n        *out_char_ptr++ = 0xA;\r\n        *out_char_ptr++ = ' ';\r\n      }\r\n      else\r\n        *out_char_ptr++ = *in_char_ptr++;\r\n    }\r\n  }\r\n  else if ((delta_disabled != 1) \u0026\u0026 (insize \u003e 4)) {\r\n    clear_counts(symbol_counts, order_1_counts);\r\n    for (i = 0 ; i \u003c insize - 1 ; i++) {\r\n      symbol_counts[inbuf[i]]++;\r\n      order_1_counts[inbuf[i]][inbuf[i + 1]]++;\r\n    }\r\n    symbol_counts[inbuf[insize - 1]]++;\r\n    order_1_counts[inbuf[insize - 1]][0x80]++;\r\n    order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n    best_stride_entropy = order_1_entropy;\r\n    stride = 0;\r\n\r\n    j = insize \u003c 100 ? insize : 100;\r\n      \r\n    for (k = 1 ; k \u003c= j ; k++) {\r\n      clear_counts(symbol_counts, order_1_counts);\r\n      if ((k == 2) | (k == 4)) {\r\n        i = 0;\r\n        while (i \u003c k) {\r\n          symbol_counts[inbuf[i]]++;\r\n          order_1_counts[inbuf[i]][0xFF \u0026 (inbuf[i + k] - inbuf[i])]++;\r\n          i++;\r\n        }\r\n        while (i \u003c (uint32_t)insize - k) {\r\n          symbol_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])]++;\r\n          order_1_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])][0xFF \u0026 (inbuf[i + k] - inbuf[i])]++;\r\n          i++;\r\n        }\r\n        while (i \u003c insize) {\r\n          symbol_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])]++;\r\n          order_1_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])][0x80]++;\r\n          i++;\r\n        }\r\n        order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n        if ((order_1_entropy \u003c 0.95 * best_stride_entropy)\r\n            || ((stride != 0) \u0026\u0026 (order_1_entropy \u003c best_stride_entropy))) {\r\n          stride = k;\r\n          best_stride_entropy = order_1_entropy;\r\n        }\r\n      }\r\n      else {\r\n        for (i = 0 ; i \u003c k - 1 ; i++) {\r\n          symbol_counts[inbuf[i]]++;\r\n          order_1_counts[inbuf[i]][inbuf[i + 1]]++;\r\n        }\r\n        symbol_counts[inbuf[k - 1]]++;\r\n        order_1_counts[inbuf[k - 1]][0xFF \u0026 (inbuf[k]-inbuf[0])]++;\r\n        uint8_t failed_test = 0;\r\n        i = k;\r\n        if (insize \u003e 100000) {\r\n          uint32_t initial_test_size = 100000 + ((insize - 100000) \u003e\u003e 3);\r\n          while (i \u003c initial_test_size) {\r\n            symbol_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])]++;\r\n            order_1_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])][0xFF \u0026 (inbuf[i + 1] - inbuf[i + 1 - k])]++;\r\n            i++;\r\n          }\r\n          order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n          if (order_1_entropy \u003e= 1.05 * best_stride_entropy * (double)initial_test_size / (double)insize)\r\n            failed_test = 1;\r\n        }\r\n        if (failed_test == 0) {\r\n          while (i \u003c insize - 1) {\r\n            symbol_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])]++;\r\n            order_1_counts[0xFF \u0026 (inbuf[i] - inbuf[i - k])][0xFF \u0026 (inbuf[i + 1] - inbuf[i + 1 - k])]++;\r\n            i++;\r\n          }\r\n          symbol_counts[0xFF \u0026 (inbuf[insize - 1] - inbuf[insize - 1 - k])]++;\r\n          order_1_counts[0xFF \u0026 (inbuf[insize - 1] - inbuf[insize - 1- k])][0x80]++;\r\n          order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n          if ((order_1_entropy \u003c 0.9 * best_stride_entropy)\r\n              || ((stride != 0) \u0026\u0026 (order_1_entropy \u003c best_stride_entropy))) {\r\n            stride = k;\r\n            best_stride_entropy = order_1_entropy;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    double min_entropy = best_stride_entropy;\r\n\r\n#ifdef PRINTON\r\n    if (stride != 0)\r\n      fprintf(stderr, \"Applying %u byte delta transformation\\n\", (unsigned int)stride);\r\n    else\r\n      fprintf(stderr, \"Converting data\\n\");\r\n#endif\r\n\r\n    if (stride == 0)\r\n      *out_char_ptr++ = 0;\r\n    else if (stride == 1) {\r\n      *out_char_ptr++ = 2;\r\n      in_char_ptr = end_char_ptr - 1;\r\n      while (--in_char_ptr \u003e= inbuf)\r\n        *(in_char_ptr + 1) -= *in_char_ptr;\r\n    }\r\n    else if (stride == 2) {\r\n      for (j = 0 ; j \u003c 2 ; j++) {\r\n        clear_counts(symbol_counts, order_1_counts);\r\n        uint8_t delta_symbol;\r\n        uint8_t prior_delta_symbol = inbuf[j];\r\n        for (i = j ; i \u003c (insize \u0026 ~1) - 2 ; i += 2) {\r\n          delta_symbol = inbuf[i + 2] - inbuf[i];\r\n          symbol_counts[prior_delta_symbol]++;\r\n          order_1_counts[prior_delta_symbol][delta_symbol]++;\r\n          prior_delta_symbol = delta_symbol;\r\n        }\r\n        symbol_counts[prior_delta_symbol]++;\r\n        order_1_counts[prior_delta_symbol][0]++;\r\n        saved_entropy[j] = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n      }\r\n\r\n      clear_counts(symbol_counts, order_1_counts);\r\n      if (saved_entropy[0] \u003c saved_entropy[1]) {\r\n        // big endian\r\n        uint16_t symbol, delta_symbol;\r\n        uint16_t prior_symbol = (inbuf[0] \u003c\u003c 8) + inbuf[1];\r\n        uint16_t prior_delta_symbol = prior_symbol;\r\n        for (i = 0 ; i \u003c insize - 3 ; i += 2) {\r\n          symbol = (inbuf[i + 2] \u003c\u003c 8) + inbuf[i + 3];\r\n          delta_symbol = symbol - prior_symbol + 0x8080;\r\n          symbol_counts[prior_delta_symbol \u003e\u003e 8]++;\r\n          order_1_counts[prior_delta_symbol \u003e\u003e 8][delta_symbol \u003e\u003e 8]++;\r\n          symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n          order_1_counts[0xFF \u0026 prior_delta_symbol][0xFF \u0026 delta_symbol]++;\r\n          prior_symbol = symbol;\r\n          prior_delta_symbol = delta_symbol;\r\n        }\r\n        if (i == insize - 3) {\r\n          symbol = (inbuf[i + 2] \u003c\u003c 8);\r\n          delta_symbol = (inbuf[i + 2] \u003c\u003c 8) - prior_symbol + 0x8080;\r\n          symbol_counts[delta_symbol \u003e\u003e 8]++;\r\n          order_1_counts[delta_symbol \u003e\u003e 8][0]++;\r\n        }\r\n        else\r\n          delta_symbol = 0;\r\n        symbol_counts[prior_delta_symbol \u003e\u003e 8]++;\r\n        order_1_counts[prior_delta_symbol \u003e\u003e 8][delta_symbol \u003e\u003e 8]++;\r\n        symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n        order_1_counts[0xFF \u0026 prior_delta_symbol][0]++;\r\n        order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n        if (order_1_entropy \u003c best_stride_entropy) {\r\n#ifdef PRINTON\r\n          fprintf(stderr, \"Big endian\\n\");\r\n#endif\r\n          *out_char_ptr++ = 0x14;\r\n          in_char_ptr = inbuf + ((end_char_ptr - inbuf - 4) \u0026 ~1);\r\n          uint16_t value = (*(in_char_ptr + 2) \u003c\u003c 8) + *(in_char_ptr + 3);\r\n          while (in_char_ptr \u003e= inbuf) {\r\n            uint16_t prior_value = (*in_char_ptr \u003c\u003c 8) + *(in_char_ptr + 1);\r\n            uint16_t delta_value = value - prior_value + 0x80;\r\n            *(in_char_ptr + 2) = delta_value \u003e\u003e 8;\r\n            *(in_char_ptr + 3) = delta_value \u0026 0xFF;\r\n            value = prior_value;\r\n            in_char_ptr -= 2;\r\n          }\r\n        }\r\n        else {\r\n#ifdef PRINTON\r\n          fprintf(stderr, \"No carry\\n\");\r\n#endif\r\n          *out_char_ptr++ = 4;\r\n          in_char_ptr = end_char_ptr - 2;\r\n          while (--in_char_ptr \u003e= inbuf)\r\n            *(in_char_ptr + 2) -= *in_char_ptr;\r\n        }\r\n      }\r\n      else {\r\n        uint16_t symbol, delta_symbol;\r\n        uint16_t prior_symbol = (inbuf[1] \u003c\u003c 8) + inbuf[0];\r\n        uint16_t prior_delta_symbol = prior_symbol;\r\n        for (i = 0 ; i \u003c insize - 3 ; i += 2) {\r\n          symbol = (inbuf[i + 3] \u003c\u003c 8) + inbuf[i + 2];\r\n          delta_symbol = symbol - prior_symbol + 0x8080;\r\n          symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n          order_1_counts[0xFF \u0026 prior_delta_symbol][0xFF \u0026 delta_symbol]++;\r\n          symbol_counts[prior_delta_symbol \u003e\u003e 8]++;\r\n          order_1_counts[prior_delta_symbol \u003e\u003e 8][delta_symbol \u003e\u003e 8]++;\r\n          prior_symbol = symbol;\r\n          prior_delta_symbol = delta_symbol;\r\n        }\r\n        if (i == insize - 3) {\r\n          delta_symbol = inbuf[i + 2] - prior_symbol + 0x8080;\r\n          symbol_counts[0xFF \u0026 delta_symbol]++;\r\n          order_1_counts[0xFF \u0026 delta_symbol][0]++;\r\n        }\r\n        else\r\n          delta_symbol = 0;\r\n        symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n        order_1_counts[0xFF \u0026 prior_delta_symbol][0xFF \u0026 delta_symbol]++;\r\n        symbol_counts[prior_delta_symbol \u003e\u003e 8]++;\r\n        order_1_counts[prior_delta_symbol \u003e\u003e 8][0]++;\r\n        order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n        if (order_1_entropy \u003c best_stride_entropy) {\r\n#ifdef PRINTON\r\n          fprintf(stderr, \"Little endian\\n\");\r\n#endif\r\n          *out_char_ptr++ = 0x34;\r\n          in_char_ptr = inbuf + ((end_char_ptr - inbuf - 4) \u0026 ~1);\r\n          uint16_t value = (*(in_char_ptr + 3) \u003c\u003c 8) + *(in_char_ptr + 2);\r\n          while (in_char_ptr \u003e= inbuf) {\r\n            uint16_t prior_value = (*(in_char_ptr + 1) \u003c\u003c 8) + *in_char_ptr;\r\n            uint16_t delta_value = value - prior_value + 0x80;\r\n            *(in_char_ptr + 2) = delta_value \u0026 0xFF;\r\n            *(in_char_ptr + 3) = (delta_value \u003e\u003e 8);\r\n            value = prior_value;\r\n            in_char_ptr -= 2;\r\n          }\r\n        }\r\n        else {\r\n#ifdef PRINTON\r\n          fprintf(stderr, \"No carry\\n\");\r\n#endif\r\n          *out_char_ptr++ = 4;\r\n          in_char_ptr = end_char_ptr - 2;\r\n          while (--in_char_ptr \u003e= inbuf)\r\n            *(in_char_ptr + 2) -= *in_char_ptr;\r\n        }\r\n      }\r\n    }\r\n    else if (stride == 4) {\r\n      for (k = 0 ; k \u003c 4 ; k++) {\r\n        clear_counts(symbol_counts, order_1_counts);\r\n        symbol_counts[inbuf[k]]++;\r\n        order_1_counts[inbuf[k]][0xFF \u0026 (inbuf[k+stride] - inbuf[k])]++;\r\n        i = k + stride;\r\n        while (i \u003c insize - stride) {\r\n          symbol_counts[0xFF \u0026 (inbuf[i] - inbuf[i - stride])]++;\r\n          order_1_counts[0xFF \u0026 (inbuf[i] - inbuf[i - stride])][0xFF \u0026 (inbuf[i + stride] - inbuf[i])]++;\r\n          i += stride;\r\n        }\r\n        symbol_counts[0xFF \u0026 (inbuf[i] - inbuf[i - stride])]++;\r\n        order_1_counts[0xFF \u0026 (inbuf[i] - inbuf[i - stride])][0]++;\r\n        saved_entropy[k] = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n      }\r\n      double best_entropy[4];\r\n      uint8_t best_entropy_position[4];\r\n      for (i = 0 ; i \u003c 4 ; i++) {\r\n        best_entropy[i] = saved_entropy[i];\r\n        best_entropy_position[i] = i;\r\n        int8_t j;\r\n        for (j = i - 1 ; j \u003e= 0 ; j--) {\r\n          if (saved_entropy[i] \u003c best_entropy[j]) {\r\n            best_entropy[j + 1] = best_entropy[j];\r\n            best_entropy_position[j + 1] = best_entropy_position[j];\r\n            best_entropy[j] = saved_entropy[i];\r\n            best_entropy_position[j] = i;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (best_entropy[3] \u003e 1.05 * best_entropy[0]) {\r\n        if ((3.0 * best_entropy[1] \u003c best_entropy[0] + best_entropy[2] + best_entropy[3])\r\n            \u0026\u0026 (((best_entropy_position[0] - best_entropy_position[1]) \u0026 3) == 2)) {\r\n          clear_counts(symbol_counts, order_1_counts);\r\n          if (best_entropy[0] + best_entropy[2] \u003c best_entropy[1] + best_entropy[3]) {\r\n            // big endian\r\n            uint16_t symbol1, symbol2, delta_symbol1, delta_symbol2;\r\n            uint16_t prior_symbol1 = (inbuf[0] \u003c\u003c 8) + inbuf[1];\r\n            uint16_t prior_symbol2 = (inbuf[2] \u003c\u003c 8) + inbuf[3];\r\n            uint16_t prior_delta_symbol1 = prior_symbol1;\r\n            uint16_t prior_delta_symbol2 = prior_symbol2;\r\n            for (i = 0 ; i \u003c insize - 7 ; i += 4) {\r\n              symbol1 = (inbuf[i + 4] \u003c\u003c 8) + inbuf[i + 5];\r\n              symbol2 = (inbuf[i + 6] \u003c\u003c 8) + inbuf[i + 7];\r\n              delta_symbol1 = symbol1 - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = symbol2 - prior_symbol2 + 0x8080;\r\n              symbol_counts[prior_delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[prior_delta_symbol1 \u003e\u003e 8][delta_symbol1 \u003e\u003e 8]++;\r\n              symbol_counts[0xFF \u0026 prior_delta_symbol1]++;\r\n              order_1_counts[0xFF \u0026 prior_delta_symbol1][0xFF \u0026 delta_symbol1]++;\r\n              symbol_counts[prior_delta_symbol2 \u003e\u003e 8]++;\r\n              order_1_counts[prior_delta_symbol2 \u003e\u003e 8][delta_symbol2 \u003e\u003e 8]++;\r\n              symbol_counts[0xFF \u0026 prior_delta_symbol2]++;\r\n              order_1_counts[0xFF \u0026 prior_delta_symbol2][0xFF \u0026 delta_symbol2]++;\r\n              prior_symbol1 = symbol1;\r\n              prior_symbol2 = symbol2;\r\n              prior_delta_symbol1 = delta_symbol1;\r\n              prior_delta_symbol2 = delta_symbol2;\r\n            }\r\n            if (i == insize - 7) {\r\n              delta_symbol1 = (inbuf[i + 4] \u003c\u003c 8) + inbuf[i + 5] - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = (inbuf[i + 6] \u003c\u003c 8) - prior_symbol2 + 0x8080;\r\n              symbol_counts[delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[delta_symbol1 \u003e\u003e 8][0x80]++;\r\n              symbol_counts[0xFF \u0026 delta_symbol1]++;\r\n              order_1_counts[0xFF \u0026 delta_symbol1][0x80]++;\r\n              symbol_counts[delta_symbol2 \u003e\u003e 8]++;\r\n              order_1_counts[delta_symbol2 \u003e\u003e 8][0x80]++;\r\n            }\r\n            else if (i == insize - 6) {\r\n              delta_symbol1 = (inbuf[i + 4] \u003c\u003c 8) + inbuf[i + 5] - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = 0x8080;\r\n              symbol_counts[delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[delta_symbol1 \u003e\u003e 8][0x80]++;\r\n              symbol_counts[0xFF \u0026 delta_symbol1]++;\r\n              order_1_counts[0xFF \u0026 delta_symbol1][0x80]++;\r\n            }\r\n            else if (i == insize - 5) {\r\n              delta_symbol1 = (inbuf[i + 4] \u003c\u003c 8) - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = 0x8080;\r\n              symbol_counts[delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[delta_symbol1 \u003e\u003e 8][0x80]++;\r\n            }\r\n            else {\r\n              delta_symbol1 = 0x8080;\r\n              delta_symbol2 = 0x8080;\r\n            }\r\n            symbol_counts[prior_delta_symbol1 \u003e\u003e 8]++;\r\n            order_1_counts[prior_delta_symbol1 \u003e\u003e 8][delta_symbol1 \u003e\u003e 8]++;\r\n            symbol_counts[0xFF \u0026 prior_delta_symbol1]++;\r\n            order_1_counts[0xFF \u0026 prior_delta_symbol1][0xFF \u0026 delta_symbol1]++;\r\n            symbol_counts[prior_delta_symbol2 \u003e\u003e 8]++;\r\n            order_1_counts[prior_delta_symbol2 \u003e\u003e 8][delta_symbol2 \u003e\u003e 8]++;\r\n            symbol_counts[0xFF \u0026 prior_delta_symbol2]++;\r\n            order_1_counts[0xFF \u0026 prior_delta_symbol2][0x80]++;\r\n            order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n            if (order_1_entropy \u003c min_entropy) {\r\n#ifdef PRINTON\r\n              fprintf(stderr, \"Two channel big endian\\n\");\r\n#endif\r\n              *out_char_ptr++ = 0x58;\r\n              in_char_ptr = inbuf + ((end_char_ptr - inbuf - 6) \u0026 ~1);\r\n              while (in_char_ptr \u003e= inbuf) {\r\n                uint16_t delta_value = (*(in_char_ptr + 4) \u003c\u003c 8) + *(in_char_ptr + 5)\r\n                    - ((*in_char_ptr \u003c\u003c 8) + *(in_char_ptr + 1)) + 0x80;\r\n                *(in_char_ptr + 4) = delta_value \u003e\u003e 8;\r\n                *(in_char_ptr + 5) = delta_value \u0026 0xFF;\r\n                in_char_ptr -= 2;\r\n              }\r\n            }\r\n            else {\r\n#ifdef PRINTON\r\n              fprintf(stderr, \"No carry\\n\");\r\n#endif\r\n              *out_char_ptr++ = 8;\r\n              in_char_ptr = end_char_ptr - 4;\r\n              while (--in_char_ptr \u003e= inbuf)\r\n                *(in_char_ptr + 4) -= *in_char_ptr;\r\n            }\r\n          }\r\n          else {\r\n            // little endian\r\n            uint16_t symbol1, symbol2, delta_symbol1, delta_symbol2;\r\n            uint16_t prior_symbol1 = (inbuf[1] \u003c\u003c 8) + inbuf[0];\r\n            uint16_t prior_symbol2 = (inbuf[3] \u003c\u003c 8) + inbuf[2];\r\n            uint16_t prior_delta_symbol1 = prior_symbol1;\r\n            uint16_t prior_delta_symbol2 = prior_symbol2;\r\n            for (i = 0 ; i \u003c insize - 7 ; i += 4) {\r\n              symbol1 = (inbuf[i + 5] \u003c\u003c 8) + inbuf[i + 4];\r\n              symbol2 = (inbuf[i + 7] \u003c\u003c 8) + inbuf[i + 6];\r\n              delta_symbol1 = symbol1 - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = symbol2 - prior_symbol2 + 0x8080;\r\n              symbol_counts[0xFF \u0026 prior_delta_symbol1]++;\r\n              order_1_counts[0xFF \u0026 prior_delta_symbol1][0xFF \u0026 delta_symbol1]++;\r\n              symbol_counts[prior_delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[prior_delta_symbol1 \u003e\u003e 8][delta_symbol1 \u003e\u003e 8]++;\r\n              symbol_counts[0xFF \u0026 prior_delta_symbol2]++;\r\n              order_1_counts[0xFF \u0026 prior_delta_symbol2][0xFF \u0026 delta_symbol2]++;\r\n              symbol_counts[prior_delta_symbol2 \u003e\u003e 8]++;\r\n              order_1_counts[prior_delta_symbol2 \u003e\u003e 8][delta_symbol2 \u003e\u003e 8]++;\r\n              prior_symbol1 = symbol1;\r\n              prior_symbol2 = symbol2;\r\n              prior_delta_symbol1 = delta_symbol1;\r\n              prior_delta_symbol2 = delta_symbol2;\r\n            }\r\n            if (i == insize - 7) {\r\n              delta_symbol1 = (inbuf[i + 5] \u003c\u003c 8) + inbuf[i + 4] - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = inbuf[i + 6] - prior_symbol2 + 0x8080;\r\n              symbol_counts[0xFF \u0026 delta_symbol1]++;\r\n              order_1_counts[0xFF \u0026 delta_symbol1][0x80]++;\r\n              symbol_counts[delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[delta_symbol1 \u003e\u003e 8][0x80]++;\r\n              symbol_counts[0xFF \u0026 delta_symbol2]++;\r\n              order_1_counts[0xFF \u0026 delta_symbol2][0x80]++;\r\n            }\r\n            else if (i == insize - 6) {\r\n              delta_symbol1 = (inbuf[i + 4] \u003c\u003c 8) + inbuf[i + 5] - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = 0x8080;\r\n              symbol_counts[0xFF \u0026 delta_symbol1]++;\r\n              order_1_counts[0xFF \u0026 delta_symbol1][0x80]++;\r\n              symbol_counts[delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[delta_symbol1 \u003e\u003e 8][0x80]++;\r\n            }\r\n            else if (i == insize - 5) {\r\n              delta_symbol1 = (inbuf[i + 4] \u003c\u003c 8) - prior_symbol1 + 0x8080;\r\n              delta_symbol2 = 0x8080;\r\n              symbol_counts[delta_symbol1 \u003e\u003e 8]++;\r\n              order_1_counts[delta_symbol1 \u003e\u003e 8][0x80]++;\r\n            }\r\n            else {\r\n              delta_symbol1 = 0x8080;\r\n              delta_symbol2 = 0x8080;\r\n            }\r\n            symbol_counts[0xFF \u0026 prior_delta_symbol1]++;\r\n            order_1_counts[0xFF \u0026 prior_delta_symbol1][0xFF \u0026 delta_symbol1]++;\r\n            symbol_counts[prior_delta_symbol1 \u003e\u003e 8]++;\r\n            order_1_counts[prior_delta_symbol1 \u003e\u003e 8][delta_symbol1 \u003e\u003e 8]++;\r\n            symbol_counts[0xFF \u0026 prior_delta_symbol2]++;\r\n            order_1_counts[0xFF \u0026 prior_delta_symbol2][0xFF \u0026 delta_symbol1]++;\r\n            symbol_counts[prior_delta_symbol2 \u003e\u003e 8]++;\r\n            order_1_counts[prior_delta_symbol2 \u003e\u003e 8][0x80]++;\r\n            order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n            if (order_1_entropy \u003c min_entropy) {\r\n#ifdef PRINTON\r\n              fprintf(stderr, \"Two channel little endian\\n\");\r\n#endif\r\n              *out_char_ptr++ = 0x78;\r\n              in_char_ptr = inbuf + ((end_char_ptr - inbuf - 6) \u0026 ~1);\r\n              while (in_char_ptr \u003e= inbuf) {\r\n                uint16_t delta_value = (*(in_char_ptr + 5) \u003c\u003c 8) + *(in_char_ptr + 4)\r\n                    - ((*(in_char_ptr + 1) \u003c\u003c 8) + *in_char_ptr) + 0x80;\r\n                *(in_char_ptr + 4) = delta_value \u0026 0xFF;\r\n                *(in_char_ptr + 5) = (delta_value \u003e\u003e 8) \u0026 0xFF;\r\n                in_char_ptr -= 2;\r\n              }\r\n            }\r\n            else {\r\n#ifdef PRINTON\r\n              fprintf(stderr, \"No carry\\n\");\r\n#endif\r\n              *out_char_ptr++ = 8;\r\n              in_char_ptr = end_char_ptr - 4;\r\n              while (--in_char_ptr \u003e= inbuf)\r\n                *(in_char_ptr + 4) -= *in_char_ptr;\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          // try big endian first\r\n          clear_counts(symbol_counts, order_1_counts);\r\n          uint32_t symbol, delta_symbol;\r\n          uint32_t prior_symbol = (inbuf[0] \u003c\u003c 24) + (inbuf[1] \u003c\u003c 16) + (inbuf[2] \u003c\u003c 8) + inbuf[3];\r\n          uint32_t prior_delta_symbol = prior_symbol;\r\n          for (i = 0 ; i \u003c insize - 7 ; i += 4) {\r\n            symbol = (inbuf[i + 4] \u003c\u003c 24) + (inbuf[i + 5] \u003c\u003c 16) + (inbuf[i + 6] \u003c\u003c 8) + inbuf[i + 7];\r\n            delta_symbol = symbol - prior_symbol + 0x80808080;\r\n            symbol_counts[prior_delta_symbol \u003e\u003e 24]++;\r\n            order_1_counts[prior_delta_symbol \u003e\u003e 24][delta_symbol \u003e\u003e 24]++;\r\n            symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)]++;\r\n            order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)][0xFF \u0026 (delta_symbol \u003e\u003e 16)]++;\r\n            symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)]++;\r\n            order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)][0xFF \u0026 (delta_symbol \u003e\u003e 8)]++;\r\n            symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n            order_1_counts[0xFF \u0026 prior_delta_symbol][0xFF \u0026 delta_symbol]++;\r\n            prior_symbol = symbol;\r\n            prior_delta_symbol = delta_symbol;\r\n          }\r\n          if (i == insize - 7) {\r\n            delta_symbol = (inbuf[i + 4] \u003c\u003c 24) + (inbuf[i + 5] \u003c\u003c 16) + (inbuf[i + 6] \u003c\u003c 8) - prior_symbol + 0x80808080;\r\n            symbol_counts[delta_symbol \u003e\u003e 24]++;\r\n            order_1_counts[delta_symbol \u003e\u003e 24][0x80]++;\r\n            symbol_counts[0xFF \u0026 (delta_symbol \u003e\u003e 16)]++;\r\n            order_1_counts[0xFF \u0026 (delta_symbol \u003e\u003e 16)][0x80]++;\r\n            symbol_counts[0xFF \u0026 (delta_symbol \u003e\u003e 8)]++;\r\n            order_1_counts[0xFF \u0026 (delta_symbol \u003e\u003e 8)][0x80]++;\r\n          }\r\n          else if (i == insize - 6) {\r\n            delta_symbol = (inbuf[i + 4] \u003c\u003c 24) + (inbuf[i + 5] \u003c\u003c 16) - prior_symbol + 0x80808080;\r\n            symbol_counts[delta_symbol \u003e\u003e 24]++;\r\n            order_1_counts[delta_symbol \u003e\u003e 24][0x80]++;\r\n            symbol_counts[0xFF \u0026 (delta_symbol \u003e\u003e 16)]++;\r\n            order_1_counts[0xFF \u0026 (delta_symbol \u003e\u003e 16)][0x80]++;\r\n          }\r\n          else if (i == insize - 5) {\r\n            delta_symbol = (inbuf[i + 4] \u003c\u003c 24) - prior_symbol + 0x80808080;\r\n            symbol_counts[delta_symbol \u003e\u003e 24]++;\r\n            order_1_counts[delta_symbol \u003e\u003e 24][0x80]++;\r\n          }\r\n          else\r\n            delta_symbol = 0x80808080;\r\n          symbol_counts[prior_delta_symbol \u003e\u003e 24]++;\r\n          order_1_counts[prior_delta_symbol \u003e\u003e 24][delta_symbol \u003e\u003e 24]++;\r\n          symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)]++;\r\n          order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)][0xFF \u0026 (delta_symbol \u003e\u003e 16)]++;\r\n          symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)]++;\r\n          order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)][0xFF \u0026 (delta_symbol \u003e\u003e 8)]++;\r\n          symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n          order_1_counts[0xFF \u0026 prior_delta_symbol][0x80]++;\r\n          saved_entropy[0] = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n\r\n          clear_counts(symbol_counts, order_1_counts);\r\n          prior_symbol = (inbuf[3] \u003c\u003c 24) + (inbuf[2] \u003c\u003c 16) + (inbuf[1] \u003c\u003c 8) + inbuf[0];\r\n          prior_delta_symbol = prior_symbol;\r\n          for (i = 0 ; i \u003c insize - 7 ; i += 4) {\r\n            symbol = (inbuf[i + 7] \u003c\u003c 24) + (inbuf[i + 6] \u003c\u003c 16) + (inbuf[i + 5] \u003c\u003c 8) + inbuf[i + 4];\r\n            delta_symbol = symbol - prior_symbol + 0x80808080;\r\n            symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n            order_1_counts[0xFF \u0026 prior_delta_symbol][0xFF \u0026 delta_symbol]++;\r\n            symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)]++;\r\n            order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)][0xFF \u0026 (delta_symbol \u003e\u003e 8)]++;\r\n            symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)]++;\r\n            order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)][0xFF \u0026 (delta_symbol \u003e\u003e 16)]++;\r\n            symbol_counts[prior_delta_symbol \u003e\u003e 24]++;\r\n            order_1_counts[prior_delta_symbol \u003e\u003e 24][delta_symbol \u003e\u003e 24]++;\r\n            prior_symbol = symbol;\r\n            prior_delta_symbol = delta_symbol;\r\n          }\r\n          if (i == insize - 7) {\r\n            delta_symbol = (inbuf[i + 6] \u003c\u003c 16) + (inbuf[i + 5] \u003c\u003c 8) + inbuf[i + 4] - prior_symbol + 0x80808080;\r\n            symbol_counts[0xFF \u0026 delta_symbol]++;\r\n            order_1_counts[0xFF \u0026 delta_symbol][0]++;\r\n            symbol_counts[0xFF \u0026 (delta_symbol \u003e\u003e 8)]++;\r\n            order_1_counts[0xFF \u0026 (delta_symbol \u003e\u003e 8)][0]++;\r\n            symbol_counts[0xFF \u0026 (delta_symbol \u003e\u003e 16)]++;\r\n            order_1_counts[0xFF \u0026 (delta_symbol \u003e\u003e 16)][0]++;\r\n          }\r\n          else if (i == insize - 6) {\r\n            delta_symbol = (inbuf[i + 5] \u003c\u003c 8) + inbuf[i + 4] - prior_symbol + 0x80808080;\r\n            symbol_counts[0xFF \u0026 delta_symbol]++;\r\n            order_1_counts[0xFF \u0026 delta_symbol][0]++;\r\n            symbol_counts[0xFF \u0026 (delta_symbol \u003e\u003e 8)]++;\r\n            order_1_counts[0xFF \u0026 (delta_symbol \u003e\u003e 8)][0]++;\r\n          }\r\n          else if (i == insize - 5) {\r\n            delta_symbol = inbuf[i + 4] - prior_symbol + 0x80808080;\r\n            symbol_counts[0xFF \u0026 delta_symbol]++;\r\n            order_1_counts[0xFF \u0026 delta_symbol][0]++;\r\n          }\r\n          else\r\n            delta_symbol = 0x80808080;\r\n          symbol_counts[0xFF \u0026 prior_delta_symbol]++;\r\n          order_1_counts[0xFF \u0026 prior_delta_symbol][0xFF \u0026 delta_symbol]++;\r\n          symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)]++;\r\n          order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 8)][0xFF \u0026 (delta_symbol \u003e\u003e 8)]++;\r\n          symbol_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)]++;\r\n          order_1_counts[0xFF \u0026 (prior_delta_symbol \u003e\u003e 16)][0xFF \u0026 (delta_symbol \u003e\u003e 16)]++;\r\n          symbol_counts[prior_delta_symbol \u003e\u003e 24]++;\r\n          order_1_counts[prior_delta_symbol \u003e\u003e 24][0]++;\r\n          order_1_entropy = calculate_order_1_entropy(symbol_counts, order_1_counts);\r\n\r\n          if ((saved_entropy[0] \u003c min_entropy) \u0026\u0026 (saved_entropy[0] \u003c order_1_entropy)) {\r\n#ifdef PRINTON\r\n            fprintf(stderr, \"Big endian\\n\");\r\n#endif\r\n            *out_char_ptr++ = 0x18;\r\n            in_char_ptr = inbuf + ((end_char_ptr - inbuf - 8) \u0026 ~3);\r\n            uint32_t value = (*(in_char_ptr + 4) \u003c\u003c 24) + (*(in_char_ptr + 5) \u003c\u003c 16)\r\n                + (*(in_char_ptr + 6) \u003c\u003c 8) + *(in_char_ptr + 7);\r\n            while (in_char_ptr \u003e= inbuf) {\r\n              uint32_t prior_value = (*in_char_ptr \u003c\u003c 24) + (*(in_char_ptr + 1) \u003c\u003c 16)\r\n                  + (*(in_char_ptr + 2) \u003c\u003c 8) + *(in_char_ptr + 3);\r\n              uint32_t delta_value = value - prior_value + 0x808080;\r\n              *(in_char_ptr + 4) = delta_value \u003e\u003e 24;\r\n              *(in_char_ptr + 5) = (delta_value \u003e\u003e 16) \u0026 0xFF;\r\n              *(in_char_ptr + 6) = (delta_value \u003e\u003e 8) \u0026 0xFF;\r\n              *(in_char_ptr + 7) = delta_value \u0026 0xFF;\r\n              value = prior_value;\r\n              in_char_ptr -= 4;\r\n            }\r\n          }\r\n          else if (order_1_entropy \u003c min_entropy) {\r\n#ifdef PRINTON\r\n            fprintf(stderr, \"Little endian\\n\");\r\n#endif\r\n            *out_char_ptr++ = 0x38;\r\n            in_char_ptr = inbuf + ((end_char_ptr - inbuf - 8) \u0026 ~3);\r\n            uint32_t value = (*(in_char_ptr + 7) \u003c\u003c 24) + (*(in_char_ptr + 6) \u003c\u003c 16)\r\n                + (*(in_char_ptr + 5) \u003c\u003c 8) + *(in_char_ptr + 4);\r\n            while (in_char_ptr \u003e= inbuf) {\r\n              uint32_t prior_value = (*(in_char_ptr + 3) \u003c\u003c 24) + (*(in_char_ptr + 2) \u003c\u003c 16)\r\n                  + (*(in_char_ptr + 1) \u003c\u003c 8) + *in_char_ptr;\r\n              uint32_t delta_value = value - prior_value + 0x808080;\r\n              *(in_char_ptr + 7) = delta_value \u003e\u003e 24;\r\n              *(in_char_ptr + 6) = (delta_value \u003e\u003e 16) \u0026 0xFF;\r\n              *(in_char_ptr + 5) = (delta_value \u003e\u003e 8) \u0026 0xFF;\r\n              *(in_char_ptr + 4) = delta_value \u0026 0xFF;\r\n              value = prior_value;\r\n              in_char_ptr -= 4;\r\n            }\r\n          }\r\n          else {\r\n#ifdef PRINTON\r\n            fprintf(stderr, \"No carry\\n\");\r\n#endif\r\n            *out_char_ptr++ = 8;\r\n            in_char_ptr = end_char_ptr - 4;\r\n            while (--in_char_ptr \u003e= inbuf)\r\n              *(in_char_ptr + 4) -= *in_char_ptr;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n#ifdef PRINTON\r\n        fprintf(stderr, \"No carry\\n\");\r\n#endif\r\n        *out_char_ptr++ = 8;\r\n        in_char_ptr = end_char_ptr - 4;\r\n        while (--in_char_ptr \u003e= inbuf)\r\n          *(in_char_ptr + 4) -= *in_char_ptr;\r\n      }\r\n    }\r\n    else if (stride == 3) {\r\n      *out_char_ptr++ = 6;\r\n      in_char_ptr = end_char_ptr - 3;\r\n      while (--in_char_ptr \u003e= inbuf)\r\n        *(in_char_ptr + 3) -= *in_char_ptr;\r\n    }\r\n    else {\r\n      *out_char_ptr++ = 0x80 + stride;\r\n      in_char_ptr = end_char_ptr - stride;\r\n      while (--in_char_ptr \u003e= inbuf)\r\n        *(in_char_ptr + stride) -= *in_char_ptr;\r\n      in_char_ptr = inbuf + stride - 1;\r\n      while (--in_char_ptr \u003e= inbuf)\r\n        *(in_char_ptr + 1) -= *in_char_ptr;\r\n    }\r\n\r\n    if ((stride == 2) || (stride == 4)) {\r\n      uint8_t * in_char2 = (uint8_t *)malloc(CHARS_TO_WRITE);\r\n      uint8_t * in_char2_ptr;\r\n      uint8_t * start_block_ptr = inbuf;\r\n      uint8_t * end_block_ptr = start_block_ptr + CHARS_TO_WRITE;\r\n      if (stride == 2) {\r\n        while (end_block_ptr \u003c end_char_ptr) {\r\n          in_char2_ptr = in_char2;\r\n          in_char_ptr = start_block_ptr + 1;\r\n          while (in_char_ptr \u003c end_block_ptr) {\r\n            *in_char2_ptr++ = *in_char_ptr;\r\n            in_char_ptr += 2;\r\n          }\r\n          in_char2_ptr = start_block_ptr;\r\n          in_char_ptr = start_block_ptr;\r\n          while (in_char_ptr \u003c end_block_ptr) {\r\n            *in_char2_ptr++ = *in_char_ptr;\r\n            in_char_ptr += 2;\r\n          }\r\n          in_char_ptr = in_char2;\r\n          while (in_char2_ptr \u003c end_block_ptr)\r\n            *in_char2_ptr++ = *in_char_ptr++;\r\n          start_block_ptr = end_block_ptr;\r\n          end_block_ptr += CHARS_TO_WRITE;\r\n        }\r\n        in_char2_ptr = in_char2;\r\n        in_char_ptr = start_block_ptr + 1;\r\n        while (in_char_ptr \u003c end_char_ptr) {\r\n          *in_char2_ptr++ = *in_char_ptr;\r\n          in_char_ptr += 2;\r\n        }\r\n        in_char2_ptr = start_block_ptr;\r\n        in_char_ptr = start_block_ptr;\r\n        while (in_char_ptr \u003c end_char_ptr) {\r\n          *in_char2_ptr++ = *in_char_ptr;\r\n          in_char_ptr += 2;\r\n        }\r\n        in_char_ptr = in_char2;\r\n        while (in_char2_ptr \u003c end_char_ptr)\r\n          *in_char2_ptr++ = *in_char_ptr++;\r\n      }\r\n      else {\r\n        while (end_block_ptr \u003c end_char_ptr) {\r\n          in_char2_ptr = in_char2;\r\n          in_char_ptr = start_block_ptr + 1;\r\n          while (in_char_ptr \u003c end_block_ptr) {\r\n            *in_char2_ptr++ = *in_char_ptr;\r\n            in_char_ptr += 4;\r\n          }\r\n          in_char_ptr = start_block_ptr + 2;\r\n          while (in_char_ptr \u003c end_block_ptr) {\r\n            *in_char2_ptr++ = *in_char_ptr;\r\n            in_char_ptr += 4;\r\n          }\r\n          in_char_ptr = start_block_ptr + 3;\r\n          while (in_char_ptr \u003c end_block_ptr) {\r\n            *in_char2_ptr++ = *in_char_ptr;\r\n            in_char_ptr += 4;\r\n          }\r\n          in_char2_ptr = start_block_ptr;\r\n          in_char_ptr = start_block_ptr;\r\n          while (in_char_ptr \u003c end_block_ptr) {\r\n            *in_char2_ptr++ = *in_char_ptr;\r\n            in_char_ptr += 4;\r\n          }\r\n          in_char_ptr = in_char2;\r\n          while (in_char2_ptr \u003c end_block_ptr)\r\n            *in_char2_ptr++ = *in_char_ptr++;\r\n          start_block_ptr = end_block_ptr;\r\n          end_block_ptr += CHARS_TO_WRITE;\r\n        }\r\n        in_char2_ptr = in_char2;\r\n        in_char_ptr = start_block_ptr + 1;\r\n        while (in_char_ptr \u003c end_char_ptr) {\r\n          *in_char2_ptr++ = *in_char_ptr;\r\n          in_char_ptr += 4;\r\n        }\r\n        in_char_ptr = start_block_ptr + 2;\r\n        while (in_char_ptr \u003c end_char_ptr) {\r\n          *in_char2_ptr++ = *in_char_ptr;\r\n          in_char_ptr += 4;\r\n        }\r\n        in_char_ptr = start_block_ptr + 3;\r\n        while (in_char_ptr \u003c end_char_ptr) {\r\n          *in_char2_ptr++ = *in_char_ptr;\r\n          in_char_ptr += 4;\r\n        }\r\n        in_char_ptr = start_block_ptr;\r\n        in_char2_ptr = start_block_ptr;\r\n        while (in_char_ptr \u003c end_char_ptr) {\r\n          *in_char2_ptr++ = *in_char_ptr;\r\n          in_char_ptr += 4;\r\n        }\r\n        in_char_ptr = in_char2;\r\n        while (in_char2_ptr \u003c end_char_ptr)\r\n          *in_char2_ptr++ = *in_char_ptr++;\r\n      }\r\n\r\n      in_char_ptr = inbuf;\r\n      while (in_char_ptr != end_char_ptr)\r\n        *out_char_ptr++ = *in_char_ptr++;\r\n      free(in_char2);\r\n    }\r\n    else {\r\n      in_char_ptr = inbuf;\r\n      while (in_char_ptr != end_char_ptr)\r\n        *out_char_ptr++ = *in_char_ptr++;\r\n    }\r\n  }\r\n  else {\r\n#ifdef PRINTON\r\n    fprintf(stderr, \"Converting data\\n\");\r\n#endif\r\n    *out_char_ptr++ = 0;\r\n    in_char_ptr = inbuf;\r\n    while (in_char_ptr != end_char_ptr)\r\n      *out_char_ptr++ = *in_char_ptr++;\r\n  }\r\n\r\n  *outsize_ptr = out_char_ptr - *outbuf;\r\n  if ((*outbuf = (uint8_t *)realloc(*outbuf, *outsize_ptr)) == 0) {\r\n    fprintf(stderr, \"ERROR - Compressed output buffer memory reallocation failed\\n\");\r\n    return(0);\r\n  }\r\n  return(1);\r\n}","filepath":"glza/GLZAformat.c","line_number":67,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3295488":{"score":0.8037435,"function_name":"rank_scores_thread","code":"void *rank_scores_thread(void *arg) {\r\n  struct rank_scores_thread_data * thread_data_ptr = (struct rank_scores_thread_data *)arg;\r\n  uint32_t max_scores = thread_data_ptr-\u003emax_scores;\r\n  uint16_t * candidates_index = thread_data_ptr-\u003ecandidates_index;\r\n  struct node_score_data * rank_scores_buffer = \u0026thread_data_ptr-\u003erank_scores_buffer[0];\r\n  struct node_score_data * candidates = \u0026thread_data_ptr-\u003ecandidates[0];\r\n  uint16_t score_index, node_score_num_symbols;\r\n  uint16_t local_write_index = 0;\r\n  uint16_t node_ptrs_num = 0;\r\n  uint16_t num_candidates = 0;\r\n\r\n  while (1) {\r\n    while ((local_write_index == node_ptrs_num)\r\n        \u0026\u0026 ((local_write_index = atomic_load_explicit(\u0026rank_scores_write_index, memory_order_acquire))\r\n          == node_ptrs_num)); // wait\r\n    if (rank_scores_buffer[node_ptrs_num].last_match_index1 == 0)\r\n      break;\r\n    float score = rank_scores_buffer[node_ptrs_num].score;\r\n    if (score \u003e min_score) {\r\n      if (num_candidates == 0) {\r\n        candidates_index[0] = 0;\r\n        num_candidates = 1;\r\n        candidates_index[0] = 0;\r\n        candidates[0].score = score;\r\n        candidates[0].num_symbols = rank_scores_buffer[node_ptrs_num].num_symbols;\r\n        candidates[0].last_match_index1 = rank_scores_buffer[node_ptrs_num].last_match_index1;\r\n        candidates[0].last_match_index2 = rank_scores_buffer[node_ptrs_num].last_match_index2;\r\n        goto rank_scores_thread_node_done;\r\n      }\r\n\r\n      // find the rank of the score\r\n      uint16_t new_score_rank = 0;\r\n      uint16_t max_rank = num_candidates;\r\n      do {\r\n        uint16_t temp_rank = (new_score_rank + max_rank) \u003e\u003e 1;\r\n        if (score \u003e candidates[candidates_index[temp_rank]].score)\r\n          max_rank = temp_rank;\r\n        else\r\n          new_score_rank = temp_rank + 1;\r\n      } while (new_score_rank != max_rank);\r\n\r\n      // check for overlaps with candidates with better scores\r\n      uint16_t num_symbols = rank_scores_buffer[node_ptrs_num].num_symbols;\r\n      uint32_t new_score_lmi1 = rank_scores_buffer[node_ptrs_num].last_match_index1;\r\n      uint32_t new_score_lmi2 = rank_scores_buffer[node_ptrs_num].last_match_index2;\r\n      uint16_t rank = 0;\r\n      while (rank \u003c new_score_rank) {\r\n        score_index = candidates_index[rank];\r\n        node_score_num_symbols = candidates[score_index].num_symbols;\r\n        uint32_t slmi1 = candidates[score_index].last_match_index1;\r\n        if (new_score_lmi2 + node_score_num_symbols \u003c= slmi1)\r\n          rank++;\r\n        else {\r\n          uint32_t slmi2 = candidates[score_index].last_match_index2;\r\n          if (slmi2 + num_symbols \u003c= new_score_lmi1)\r\n            rank++;\r\n          else if (slmi1 + num_symbols \u003c= new_score_lmi2) {\r\n            if (new_score_lmi1 + node_score_num_symbols \u003c= slmi1) {\r\n              if ((new_score_lmi2 + node_score_num_symbols \u003c= slmi2) || (slmi2 + num_symbols \u003c= new_score_lmi2))\r\n                rank++;\r\n              else\r\n                goto rank_scores_thread_node_done;\r\n            }\r\n            else if ((slmi1 + num_symbols \u003c= new_score_lmi1)\r\n                \u0026\u0026 ((new_score_lmi2 + node_score_num_symbols \u003c= slmi2)\r\n                  || ((slmi2 + num_symbols \u003c= new_score_lmi2) \u0026\u0026 (new_score_lmi1 + node_score_num_symbols \u003c= slmi2))))\r\n              rank++;\r\n            else\r\n              goto rank_scores_thread_node_done;\r\n          }\r\n          else\r\n            goto rank_scores_thread_node_done;\r\n        }\r\n      }\r\n      // no better candidate overlaps so node will be put on the list\r\n      // look for overlaps with lower scoring candidates that should be removed (only looks for one to avoid min score reduction)\r\n      if (rank != num_candidates) {\r\n        do {\r\n          score_index = candidates_index[rank];\r\n          uint32_t slmi1 = candidates[score_index].last_match_index1;\r\n          node_score_num_symbols = candidates[score_index].num_symbols;\r\n          if (new_score_lmi2 + node_score_num_symbols \u003e slmi1) {\r\n            uint32_t slmi2 = candidates[score_index].last_match_index2;\r\n            if (slmi2 + num_symbols \u003e new_score_lmi1) {\r\n              if (new_score_lmi1 + node_score_num_symbols \u003e slmi1) {\r\n                if ((slmi1 + num_symbols \u003e new_score_lmi1) || (new_score_lmi1 + node_score_num_symbols \u003e slmi2)\r\n                    || ((new_score_lmi2 + node_score_num_symbols \u003e slmi2) \u0026\u0026 (slmi2 + num_symbols \u003e new_score_lmi2)))\r\n                  goto rank_scores_thread_move_down;\r\n              }\r\n              else if ((slmi1 + num_symbols \u003e new_score_lmi2)\r\n                  || ((new_score_lmi2 + node_score_num_symbols \u003e slmi2) \u0026\u0026 (slmi2 + num_symbols \u003e new_score_lmi2)))\r\n                goto rank_scores_thread_move_down;\r\n            }\r\n\r\n          }\r\n        } while (++rank != num_candidates);\r\n      }\r\n\r\n      if (num_candidates != max_scores) { // increment the list length if not at limit\r\n        candidates_index[num_candidates] = num_candidates;\r\n        num_candidates++;\r\n      }\r\n      else // otherwise throw away the lowest score instead of moving it\r\n        rank--;\r\n\r\nrank_scores_thread_move_down:\r\n      // move the lower scoring nodes down one location\r\n      score_index = candidates_index[rank];\r\n      uint16_t * score_ptr = \u0026candidates_index[new_score_rank];\r\n      uint16_t * candidate_ptr = \u0026candidates_index[rank];\r\n      while (candidate_ptr \u003e= score_ptr + 8) {\r\n        *candidate_ptr = *(candidate_ptr - 1);\r\n        *(candidate_ptr - 1) = *(candidate_ptr - 2);\r\n        *(candidate_ptr - 2) = *(candidate_ptr - 3);\r\n        *(candidate_ptr - 3) = *(candidate_ptr - 4);\r\n        *(candidate_ptr - 4) = *(candidate_ptr - 5);\r\n        *(candidate_ptr - 5) = *(candidate_ptr - 6);\r\n        *(candidate_ptr - 6) = *(candidate_ptr - 7);\r\n        *(candidate_ptr - 7) = *(candidate_ptr - 8);\r\n        candidate_ptr -= 8;\r\n      }\r\n      while (candidate_ptr \u003e score_ptr) {\r\n        *candidate_ptr = *(candidate_ptr - 1);\r\n        candidate_ptr--;\r\n      }\r\n      // save the new score\r\n      candidates_index[new_score_rank] = score_index;\r\n      candidates[score_index].score = score;\r\n      candidates[score_index].num_symbols = num_symbols;\r\n      candidates[score_index].last_match_index1 = new_score_lmi1;\r\n      candidates[score_index].last_match_index2 = new_score_lmi2;\r\n      if (num_candidates == max_scores)\r\n        min_score = candidates[candidates_index[max_scores - 1]].score;\r\n    }\r\nrank_scores_thread_node_done:\r\n    atomic_store_explicit(\u0026rank_scores_read_index, ++node_ptrs_num, memory_order_relaxed);\r\n  }\r\n  thread_data_ptr-\u003enum_candidates = num_candidates;\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":755,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3296528":{"score":0.7997451,"function_name":"rank_word_scores_thread","code":"void *rank_word_scores_thread(void *arg) {\r\n  struct rank_scores_thread_data * thread_data_ptr = (struct rank_scores_thread_data *)arg;\r\n  uint32_t max_scores = thread_data_ptr-\u003emax_scores;\r\n  uint16_t * candidates_index = thread_data_ptr-\u003ecandidates_index;\r\n  struct node_score_data * rank_scores_buffer = \u0026thread_data_ptr-\u003erank_scores_buffer[0];\r\n  struct node_score_data * candidates = \u0026thread_data_ptr-\u003ecandidates[0];\r\n  uint16_t score_index;\r\n  uint16_t local_write_index = 0;\r\n  uint16_t node_ptrs_num = 0;\r\n  uint16_t num_candidates = 0;\r\n\r\n  while (1) {\r\n    while ((local_write_index == node_ptrs_num)\r\n        \u0026\u0026 ((local_write_index = atomic_load_explicit(\u0026rank_scores_write_index, memory_order_acquire))\r\n          == node_ptrs_num)) /* wait */ ;\r\n    if (rank_scores_buffer[node_ptrs_num].last_match_index1 == 0)\r\n      break;\r\n    float score = rank_scores_buffer[node_ptrs_num].score;\r\n    if (score \u003e min_score) {\r\n      // find the position in the score list this node would go in\r\n      uint16_t rank, new_score_rank, candidate_search_size;\r\n      new_score_rank = num_candidates;\r\n      candidate_search_size = num_candidates + 1;\r\n      do {\r\n        candidate_search_size = (candidate_search_size + 1) \u003e\u003e 1;\r\n        if (candidate_search_size \u003e new_score_rank)\r\n          candidate_search_size = new_score_rank;\r\n        if (score \u003e candidates[candidates_index[new_score_rank - candidate_search_size]].score)\r\n          new_score_rank -= candidate_search_size;\r\n      } while (candidate_search_size \u003e 1);\r\n\r\n      if (num_candidates != max_scores) { // increment the list length if not at limit\r\n        candidates_index[num_candidates] = num_candidates;\r\n        rank = num_candidates++;\r\n      }\r\n      else // otherwise throw away the lowest score instead of moving it\r\n        rank = num_candidates - 1;\r\n\r\n      // move the lower scoring nodes down one location\r\n      score_index = candidates_index[rank];\r\n      while (rank \u003e new_score_rank) {\r\n        candidates_index[rank] = candidates_index[rank - 1];\r\n        rank--;\r\n      }\r\n      // save the new score\r\n      candidates_index[rank] = score_index;\r\n      candidates[score_index].score = score;\r\n      candidates[score_index].num_symbols = rank_scores_buffer[node_ptrs_num].num_symbols;\r\n      candidates[score_index].last_match_index1 = rank_scores_buffer[node_ptrs_num].last_match_index1;\r\n      if (num_candidates == max_scores)\r\n        min_score = candidates[candidates_index[max_scores - 1]].score;\r\n    }\r\n    atomic_store_explicit(\u0026rank_scores_read_index, ++node_ptrs_num, memory_order_relaxed);\r\n  }\r\n  thread_data_ptr-\u003enum_candidates = num_candidates;\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":1142,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3297072":{"score":0.81087035,"function_name":"rank_word_scores_thread","code":"void *rank_word_scores_thread(void *arg) {\r\n  struct rank_scores_thread_data * thread_data_ptr = (struct rank_scores_thread_data *)arg;\r\n  uint32_t max_scores = thread_data_ptr-\u003emax_scores;\r\n  uint16_t * candidates_index = thread_data_ptr-\u003ecandidates_index;\r\n  struct node_score_data * rank_scores_buffer = \u0026thread_data_ptr-\u003erank_scores_buffer[0];\r\n  struct node_score_data * candidates = \u0026thread_data_ptr-\u003ecandidates[0];\r\n  uint16_t score_index;\r\n  uint16_t local_write_index = 0;\r\n  uint16_t node_ptrs_num = 0;\r\n  uint16_t num_candidates = 0;\r\n\r\n  while (1) {\r\n    while ((local_write_index == node_ptrs_num)\r\n        \u0026\u0026 ((local_write_index = atomic_load_explicit(\u0026rank_scores_write_index, memory_order_acquire))\r\n          == node_ptrs_num)) /* wait */ ;\r\n    if (rank_scores_buffer[node_ptrs_num].last_match_index1 == 0)\r\n      break;\r\n    float score = rank_scores_buffer[node_ptrs_num].score;\r\n    if (score \u003e min_score) {\r\n      // find the position in the score list this node would go in\r\n      uint16_t rank, new_score_rank, candidate_search_size;\r\n      new_score_rank = num_candidates;\r\n      candidate_search_size = num_candidates + 1;\r\n      do {\r\n        candidate_search_size = (candidate_search_size + 1) \u003e\u003e 1;\r\n        if (candidate_search_size \u003e new_score_rank)\r\n          candidate_search_size = new_score_rank;\r\n        if (score \u003e candidates[candidates_index[new_score_rank - candidate_search_size]].score)\r\n          new_score_rank -= candidate_search_size;\r\n      } while (candidate_search_size \u003e 1);\r\n\r\n      if (num_candidates != max_scores) { // increment the list length if not at limit\r\n        candidates_index[num_candidates] = num_candidates;\r\n        rank = num_candidates++;\r\n      }\r\n      else // otherwise throw away the lowest score instead of moving it\r\n        rank = num_candidates - 1;\r\n\r\n      // move the lower scoring nodes down one location\r\n      score_index = candidates_index[rank];\r\n      while (rank \u003e new_score_rank) {\r\n        candidates_index[rank] = candidates_index[rank - 1];\r\n        rank--;\r\n      }\r\n      // save the new score\r\n      candidates_index[rank] = score_index;\r\n      candidates[score_index].score = score;\r\n      candidates[score_index].num_symbols = rank_scores_buffer[node_ptrs_num].num_symbols;\r\n      candidates[score_index].last_match_index1 = rank_scores_buffer[node_ptrs_num].last_match_index1;\r\n      if (num_candidates == max_scores)\r\n        min_score = candidates[candidates_index[max_scores - 1]].score;\r\n    }\r\n    atomic_store_explicit(\u0026rank_scores_read_index, ++node_ptrs_num, memory_order_relaxed);\r\n  }\r\n  thread_data_ptr-\u003enum_candidates = num_candidates;\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":1142,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3297584":{"score":0.81609845,"function_name":"rank_scores_thread_fast","code":"void *rank_scores_thread_fast(void *arg) {\r\n  struct rank_scores_thread_data_fast * thread_data_ptr = (struct rank_scores_thread_data_fast *)arg;\r\n  uint32_t max_scores = thread_data_ptr-\u003emax_scores;\r\n  uint32_t new_score_lmi, slmi, i;\r\n  uint16_t * candidates_index = thread_data_ptr-\u003ecandidates_index;\r\n  uint16_t * candidates_position = thread_data_ptr-\u003ecandidates_position;\r\n  struct node_score_data_fast * rank_scores_buffer = \u0026thread_data_ptr-\u003erank_scores_buffer[0];\r\n  struct node_score_data_fast * candidates = \u0026thread_data_ptr-\u003ecandidates[0];\r\n  uint16_t num_symbols, score_index, num_found_overlaps, prior_score;\r\n  uint16_t position, next_position, min_position, max_position, first_unused_position;\r\n  uint16_t section, min_section, max_section;\r\n  uint16_t new_score_rank, max_new_score_rank, num_candidates, candidate_index;\r\n  uint16_t found_overlaps[MAX_SCORES_FAST];\r\n  uint16_t local_write_index = 0;\r\n  uint16_t node_ptrs_num = 0;\r\n  uint8_t candidates_index_starts[0x80];\r\n  float score;\r\n\r\n  for (i = 0 ; i \u003c 0x80 ; i++)\r\n    candidates_index_starts[i] = 0;\r\n  for (i = 0 ; i \u003c thread_data_ptr-\u003enum_file_symbols ; i++)\r\n    score_map[i] = 0;\r\n  for (i = 0 ; i \u003c MAX_SCORES_FAST ; i++)\r\n    candidates_index[i] = i;\r\n  num_candidates = 0;\r\n\r\n  while (1) {\r\n    while ((local_write_index == node_ptrs_num)\r\n        \u0026\u0026 ((local_write_index = atomic_load_explicit(\u0026rank_scores_write_index, memory_order_acquire))\r\n          == node_ptrs_num)) /* wait */ ;\r\n    if (rank_scores_buffer[node_ptrs_num].last_match_index == 0)\r\n      break;\r\n    score = rank_scores_buffer[node_ptrs_num].score;\r\n    if (score \u003e min_score) {\r\n      if (num_candidates == 0) {\r\n        // save the new score\r\n        num_candidates = 1;\r\n        candidates_position[0] = 0;\r\n        candidates[0].score = score;\r\n        candidates[0].num_symbols = rank_scores_buffer[node_ptrs_num].num_symbols;\r\n        candidates[0].last_match_index = rank_scores_buffer[node_ptrs_num].last_match_index;\r\n        for (i = candidates[0].last_match_index - candidates[0].num_symbols + 1 ;\r\n            i \u003c= candidates[0].last_match_index ; i++)\r\n          score_map[i] = 1;\r\n        goto rank_scores_thread_fast_node_done;\r\n      }\r\n\r\n      // find the rank of the score\r\n      max_section = num_candidates \u003e\u003e 8;\r\n      min_section = 0;\r\n      while (min_section != max_section) {\r\n        section = (min_section + max_section) \u003e\u003e 1;\r\n        if (score \u003e candidates[candidates_index[0x100 * section\r\n            + (uint16_t)((uint8_t)(candidates_index_starts[section] - 1))]].score)\r\n          max_section = section;\r\n        else\r\n          min_section = section + 1;\r\n      }\r\n      section = max_section;\r\n      if (num_candidates \u003e 0x100 * section + 0xFF)\r\n        max_new_score_rank = 0x100 * section + 0xFF;\r\n      else\r\n        max_new_score_rank = num_candidates;\r\n      new_score_rank = 0x100 * section;\r\n      while (max_new_score_rank != new_score_rank) {\r\n        uint16_t temp_rank = (max_new_score_rank + new_score_rank) \u003e\u003e 1;\r\n        if (score \u003e candidates[candidates_index[0x100 * section\r\n            + (uint16_t)((uint8_t)(temp_rank + candidates_index_starts[section]))]].score)\r\n          max_new_score_rank = temp_rank;\r\n        else\r\n          new_score_rank = temp_rank + 1;\r\n      }\r\n\r\n      // make overlap list and check for overlaps with candidates with better scores\r\n      num_symbols = rank_scores_buffer[node_ptrs_num].num_symbols;\r\n      new_score_lmi = rank_scores_buffer[node_ptrs_num].last_match_index;\r\n      num_found_overlaps = 0;\r\n      prior_score = 0;\r\n      for (i = new_score_lmi - num_symbols + 1 ; i \u003c= new_score_lmi ; i++) {\r\n        if ((score_map[i] != 0) \u0026\u0026 (score_map[i] != prior_score)) {\r\n          prior_score = score_map[i];\r\n          uint8_t duplicate = 0;\r\n          uint16_t j;\r\n          for (j = 0 ; j \u003c num_found_overlaps ; j++)\r\n            if (found_overlaps[j] == score_map[i] - 1)\r\n              duplicate = 1;\r\n          if (duplicate == 0) {\r\n            section = candidates_position[score_map[i] - 1] \u003e\u003e 8;\r\n            if (new_score_rank\r\n                \u003e 0x100 * section + (uint8_t)(candidates_position[score_map[i] - 1] - candidates_index_starts[section]))\r\n              goto rank_scores_thread_fast_node_done;\r\n            found_overlaps[num_found_overlaps++] = score_map[i] - 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (num_found_overlaps != 0) { // sort overlap list\r\n        uint16_t j, k;\r\n        for (j = 0 ; j \u003c num_found_overlaps - 1 ; j++) {\r\n          for (k = j + 1 ; k \u003c num_found_overlaps ; k++) {\r\n            section = candidates_position[found_overlaps[j]] \u003e\u003e 8;\r\n            uint16_t rank_j = 0x100 * section\r\n              + (uint8_t)(candidates_position[found_overlaps[j]] - candidates_index_starts[section]);\r\n            section = candidates_position[found_overlaps[k]] \u003e\u003e 8;\r\n            uint16_t rank_k = 0x100 * section\r\n              + (uint8_t)(candidates_position[found_overlaps[k]] - candidates_index_starts[section]);\r\n            if (rank_k \u003c rank_j) {\r\n              uint16_t temp_found_overlap = found_overlaps[j];\r\n              found_overlaps[j] = found_overlaps[k];\r\n              found_overlaps[k] = temp_found_overlap;\r\n            }\r\n          }\r\n        }\r\n\r\n        score_index = found_overlaps[0];\r\n        first_unused_position = candidates_position[score_index];\r\n        slmi = candidates[score_index].last_match_index;\r\n        for (i = slmi - candidates[score_index].num_symbols + 1 ; i \u003c= slmi ; i++)\r\n          score_map[i] = 0;\r\n        section = first_unused_position \u003e\u003e 8;\r\n\r\n        while (--num_found_overlaps != 0) { // remove lower scoring overlaps\r\n          score_index = found_overlaps[num_found_overlaps];\r\n          position = candidates_position[score_index];\r\n          slmi = candidates[score_index].last_match_index;\r\n          for (i = slmi - candidates[score_index].num_symbols + 1 ; i \u003c= slmi ; i++)\r\n            score_map[i] = 0;\r\n          section = position \u003e\u003e 8;\r\n          max_section = --num_candidates \u003e\u003e 8;\r\n          if (section != max_section) {\r\n            max_position = 0x100 * section + (uint8_t)(candidates_index_starts[section] - 1);\r\n            while (position != max_position) {\r\n              next_position = (position \u0026 0xFF00) + (uint8_t)(position + 1);\r\n              candidates_index[position] = candidates_index[next_position];\r\n              candidates_position[candidates_index[position]] = position;\r\n              position = next_position;\r\n            }\r\n            section++;\r\n            next_position = 0x100 * section + candidates_index_starts[section];\r\n            candidates_index[position] = candidates_index[next_position];\r\n            candidates_position[candidates_index[position]] = position;\r\n            while (section != max_section) {\r\n              candidates_index_starts[section++]++;\r\n              position = next_position;\r\n              next_position = 0x100 * section + candidates_index_starts[section];\r\n              candidates_index[position] = candidates_index[next_position];\r\n              candidates_position[candidates_index[position]] = position;\r\n            }\r\n            position = next_position;\r\n          }\r\n          max_position = (num_candidates \u0026 0xFF00) + (uint8_t)(num_candidates + candidates_index_starts[section]);\r\n          while (position != max_position) {\r\n            next_position = (position \u0026 0xFF00) + (uint8_t)(position + 1);\r\n            candidates_index[position] = candidates_index[next_position];\r\n            candidates_position[candidates_index[position]] = position;\r\n            position = next_position;\r\n          }\r\n          candidates_index[position] = score_index;\r\n        }\r\n        section = first_unused_position \u003e\u003e 8;\r\n      }\r\n      else if (num_candidates != max_scores) { // increment the list length if not at limit\r\n        section = num_candidates \u003e\u003e 8;\r\n        first_unused_position = 0x100 * section + ((uint8_t)(num_candidates + candidates_index_starts[section]));\r\n        num_candidates++;\r\n      }\r\n      else { // otherwise remove the lowest score\r\n        section = (num_candidates - 1) \u003e\u003e 8;\r\n        first_unused_position = 0x100 * section + ((uint8_t)(num_candidates - 1 + candidates_index_starts[section]));\r\n        candidate_index = candidates_index[first_unused_position];\r\n        for (i = candidates[candidate_index].last_match_index - candidates[candidate_index].num_symbols + 1 ;\r\n            i \u003c= candidates[candidate_index].last_match_index ; i++)\r\n          score_map[i] = 0;\r\n      }\r\n\r\n      // move the lower scoring nodes down one location\r\n      position = first_unused_position;\r\n      score_index = candidates_index[position];  // save the index - use later to hold new score\r\n      min_section = new_score_rank \u003e\u003e 8;\r\n      if (section != min_section) {\r\n        min_position = 0x100 * section + candidates_index_starts[section];\r\n        while (position != min_position) {\r\n          next_position = (position \u0026 0xFF00) + (uint8_t)(position - 1);\r\n          candidates_index[position] = candidates_index[next_position];\r\n          candidates_position[candidates_index[position]] = position;\r\n          position = next_position;\r\n        }\r\n        section--;\r\n        next_position = 0x100 * section + (uint8_t)(candidates_index_starts[section] - 1);\r\n        candidates_index[position] = candidates_index[next_position];\r\n        candidates_position[candidates_index[position]] = position;\r\n        position = next_position;\r\n        while (section != min_section) {\r\n          --candidates_index_starts[section--];\r\n          next_position = 0x100 * section + (uint8_t)(candidates_index_starts[section] - 1);\r\n          candidates_index[position] = candidates_index[next_position];\r\n          candidates_position[candidates_index[position]] = position;\r\n          position = next_position;\r\n        }\r\n      }\r\n      min_position = (0xFF00 \u0026 new_score_rank) + (uint8_t)(new_score_rank + candidates_index_starts[section]);\r\n      while (position != min_position) {\r\n        next_position = (position \u0026 0xFF00) + (uint8_t)(position - 1);\r\n        candidates_index[position] = candidates_index[next_position];\r\n        candidates_position[candidates_index[position]] = position;\r\n        position = next_position;\r\n      }\r\n\r\n      // save the new score\r\n      candidates_index[position] = score_index;\r\n      candidates_position[score_index] = position;\r\n      candidates[score_index].score = score;\r\n      candidates[score_index].num_symbols = num_symbols;\r\n      candidates[score_index].last_match_index = new_score_lmi;\r\n      for (i = new_score_lmi - num_symbols + 1 ; i \u003c= new_score_lmi ; i++)\r\n        score_map[i] = score_index + 1;\r\n      if (num_candidates == max_scores) {\r\n        section = (max_scores - 1) \u003e\u003e 8;\r\n        position = 0x100 * section + (uint16_t)((uint8_t)(max_scores - 1 + candidates_index_starts[section]));\r\n        min_score = candidates[candidates_index[position]].score;\r\n      }\r\n    }\r\nrank_scores_thread_fast_node_done:\r\n    atomic_store_explicit(\u0026rank_scores_read_index, ++node_ptrs_num, memory_order_relaxed);\r\n  }\r\n  thread_data_ptr-\u003enum_candidates = num_candidates;\r\n  if (num_candidates != 0) {\r\n    max_section = (num_candidates - 1) \u003e\u003e 8;\r\n    section = 1;\r\n    uint16_t temp[0x100];\r\n    while (section \u003c max_section) {\r\n      if (candidates_index_starts[section] != 0) {\r\n        memcpy(\u0026temp[0], \u0026candidates_index[0x100 * section], 0x100 * sizeof(uint16_t));\r\n        memcpy(\u0026candidates_index[0x100 * section], \u0026temp[candidates_index_starts[section]],\r\n            (0x100 - candidates_index_starts[section]) * sizeof(uint16_t));\r\n        memcpy(\u0026candidates_index[0x100 * section] + (0x100 - candidates_index_starts[section]),\r\n            \u0026temp[0], candidates_index_starts[section] * sizeof(uint16_t));\r\n      }\r\n      section++;\r\n    }\r\n  }\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":897,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3301024":{"score":0.8121475,"function_name":"overlap_check_thread","code":"void *overlap_check_thread(void *arg) {\r\n  struct overlap_check * thread_data_ptr = (struct overlap_check *)arg;\r\n  uint32_t * in_symbol_ptr = thread_data_ptr-\u003estart_symbol_ptr;\r\n  uint32_t * end_symbol_ptr = thread_data_ptr-\u003estop_symbol_ptr;\r\n  uint8_t * candidate_bad = thread_data_ptr-\u003ecandidate_bad;\r\n  struct match_node * match_nodes = thread_data_ptr-\u003ematch_nodes;\r\n  uint32_t num_overlaps = thread_data_ptr-\u003enum_overlaps;\r\n  uint32_t symbol, prior_match_score_number[MAX_PRIOR_MATCHES], *prior_match_end_ptr[MAX_PRIOR_MATCHES];\r\n  uint32_t num_prior_matches = 0;\r\n  struct match_node *match_node_ptr;\r\n\r\n  for (symbol = 0 ; symbol \u003c num_overlaps ; symbol++)\r\n    thread_data_ptr-\u003enext[symbol] = -1;\r\n\r\nthread_overlap_check_loop_no_match:\r\n  symbol = *in_symbol_ptr++;\r\n  if (in_symbol_ptr \u003e= end_symbol_ptr)\r\n    return(0);\r\n  if (((int32_t)symbol \u003c 0) || (base_child_ptr_array[symbol] == 0))\r\n    goto thread_overlap_check_loop_no_match;\r\n  match_node_ptr = base_child_ptr_array[symbol];\r\nthread_overlap_check_loop_match:\r\n  symbol = *in_symbol_ptr++;\r\n  if (symbol != match_node_ptr-\u003esymbol) {\r\n    uint32_t shifted_symbol = symbol;\r\n    do {\r\n      if (match_node_ptr-\u003esibling_node_num[shifted_symbol \u0026 0xF] != 0) {\r\n        match_node_ptr = \u0026match_nodes[match_node_ptr-\u003esibling_node_num[shifted_symbol \u0026 0xF]];\r\n        shifted_symbol \u003e\u003e= 4;\r\n      }\r\n      else {\r\n        if (match_node_ptr-\u003emiss_ptr == 0) {\r\n          if (((int32_t)symbol \u003c 0) || (base_child_ptr_array[symbol] == 0))\r\n            goto thread_overlap_check_loop_no_match;\r\n          match_node_ptr = base_child_ptr_array[symbol];\r\n          goto thread_overlap_check_loop_match;\r\n        }\r\n        else {\r\n          match_node_ptr = match_node_ptr-\u003emiss_ptr;\r\n          shifted_symbol = symbol;\r\n        }\r\n      }\r\n    } while (symbol != match_node_ptr-\u003esymbol);\r\n  }\r\n  if (match_node_ptr-\u003echild_ptr != 0) {\r\n    match_node_ptr = match_node_ptr-\u003echild_ptr;\r\n    goto thread_overlap_check_loop_match;\r\n  }\r\n\r\n  // no child, so found a match - check for overlaps\r\n  uint32_t node_score_number = match_node_ptr-\u003escore_number;\r\n  if ((num_prior_matches != 0) \u0026\u0026 (in_symbol_ptr - match_node_ptr-\u003enum_symbols\r\n      \u003c= prior_match_end_ptr[num_prior_matches - 1])) {\r\n    if (num_prior_matches == 1) {\r\n      if (prior_match_score_number[0] != node_score_number) {\r\n        if (fast_mode == 0) {\r\n          if (prior_match_score_number[0] \u003e node_score_number)\r\n            candidate_bad[prior_match_score_number[0]] = 1;\r\n          else\r\n            candidate_bad[node_score_number] = 1;\r\n        }\r\n        else {\r\n          uint32_t low_score, high_score;\r\n          if (node_score_number \u003c prior_match_score_number[0]) {\r\n            low_score = node_score_number;\r\n            high_score = prior_match_score_number[0];\r\n          }\r\n          else {\r\n            low_score = prior_match_score_number[0];\r\n            high_score = node_score_number;\r\n          }\r\n          int32_t * next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[low_score];\r\n          while ((*next_overlap_num_ptr != -1) \u0026\u0026 (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] \u003c high_score))\r\n            next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[*next_overlap_num_ptr];\r\n          if ((*next_overlap_num_ptr == -1) || (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] != high_score)) {\r\n            if (num_overlaps \u003c 150000) {\r\n              thread_data_ptr-\u003esecond[num_overlaps] = high_score;\r\n              thread_data_ptr-\u003enext[num_overlaps] = *next_overlap_num_ptr;\r\n              *next_overlap_num_ptr = num_overlaps++;\r\n            }\r\n            else\r\n              candidate_bad[high_score] = 1;\r\n          }\r\n        }\r\n        prior_match_end_ptr[1] = in_symbol_ptr - 1;\r\n        prior_match_score_number[1] = node_score_number;\r\n        num_prior_matches = 2;\r\n      }\r\n    }\r\n    else {\r\n      uint32_t prior_match_number = 0;\r\n      uint8_t found_same_score_prior_match = 0;\r\n      do {\r\n        if (in_symbol_ptr - match_node_ptr-\u003enum_symbols \u003e prior_match_end_ptr[prior_match_number]) {\r\n          num_prior_matches--;\r\n          uint32_t i;\r\n          for (i = prior_match_number ; i \u003c num_prior_matches ; i++) {\r\n            prior_match_end_ptr[i] = prior_match_end_ptr[i + 1];\r\n            prior_match_score_number[i] = prior_match_score_number[i + 1];\r\n          }\r\n        }\r\n        else { // overlapping candidates - invalidate the lower score\r\n          if (prior_match_score_number[prior_match_number] == node_score_number)\r\n            found_same_score_prior_match = 1;\r\n          else {\r\n            if (fast_mode == 0) {\r\n              if (prior_match_score_number[prior_match_number] \u003e node_score_number)\r\n               candidate_bad[prior_match_score_number[prior_match_number]] = 1;\r\n              else\r\n                candidate_bad[node_score_number] = 1;\r\n            }\r\n            else {\r\n              uint32_t low_score, high_score;\r\n              if (node_score_number \u003c prior_match_score_number[prior_match_number]) {\r\n                low_score = node_score_number;\r\n                high_score = prior_match_score_number[prior_match_number];\r\n              }\r\n              else {\r\n                low_score = prior_match_score_number[prior_match_number];\r\n                high_score = node_score_number;\r\n              }\r\n              int32_t * next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[low_score];\r\n              while ((*next_overlap_num_ptr != -1) \u0026\u0026 (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] \u003c high_score))\r\n                next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[*next_overlap_num_ptr];\r\n              if ((*next_overlap_num_ptr == -1) || (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] != high_score)) {\r\n                if (num_overlaps \u003c 150000) {\r\n                  thread_data_ptr-\u003esecond[num_overlaps] = high_score;\r\n                  thread_data_ptr-\u003enext[num_overlaps] = *next_overlap_num_ptr;\r\n                  *next_overlap_num_ptr = num_overlaps++;\r\n                }\r\n                else\r\n                  candidate_bad[high_score] = 1;\r\n              }\r\n            }\r\n          }\r\n          prior_match_number++;\r\n        }\r\n      } while (prior_match_number \u003c num_prior_matches);\r\n      if (found_same_score_prior_match == 0) {\r\n        prior_match_end_ptr[num_prior_matches] = in_symbol_ptr - 1;\r\n        prior_match_score_number[num_prior_matches++] = node_score_number;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    num_prior_matches = 1;\r\n    prior_match_end_ptr[0] = in_symbol_ptr - 1;\r\n    prior_match_score_number[0] = node_score_number;\r\n  }\r\n  match_node_ptr = match_node_ptr-\u003ehit_ptr;\r\n\r\n  if (match_node_ptr == 0) {\r\n    if (base_child_ptr_array[symbol] == 0)\r\n      goto thread_overlap_check_loop_no_match;\r\n    match_node_ptr = base_child_ptr_array[symbol];\r\n    goto thread_overlap_check_loop_match;\r\n  }\r\n  match_node_ptr = match_node_ptr-\u003echild_ptr;\r\n  goto thread_overlap_check_loop_match;\r\n}","filepath":"glza/GLZAcompress.c","line_number":3822,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3302176":{"score":0.78269875,"function_name":"overlap_check_no_defs_thread","code":"void *overlap_check_no_defs_thread(void *arg) {\r\n  struct overlap_check * thread_data_ptr = (struct overlap_check *)arg;\r\n  uint32_t * in_symbol_ptr = thread_data_ptr-\u003estart_symbol_ptr;\r\n  uint32_t * end_symbol_ptr = thread_data_ptr-\u003estop_symbol_ptr;\r\n  uint8_t * candidate_bad = thread_data_ptr-\u003ecandidate_bad;\r\n  struct match_node * match_nodes = thread_data_ptr-\u003ematch_nodes;\r\n  uint32_t num_overlaps = thread_data_ptr-\u003enum_overlaps;\r\n  uint32_t symbol, prior_match_score_number[MAX_PRIOR_MATCHES], *prior_match_end_ptr[MAX_PRIOR_MATCHES];\r\n  uint32_t num_prior_matches = 0;\r\n  struct match_node *match_node_ptr;\r\n\r\n  for (symbol = 0 ; symbol \u003c num_overlaps ; symbol++)\r\n    thread_data_ptr-\u003enext[symbol] = -1;\r\n\r\nthread_overlap_check_no_defs_loop_no_match:\r\n  symbol = *in_symbol_ptr++;\r\n  if (in_symbol_ptr \u003e= end_symbol_ptr)\r\n    return(0);\r\n  if (base_child_ptr_array[symbol] == 0)\r\n    goto thread_overlap_check_no_defs_loop_no_match;\r\n  match_node_ptr = base_child_ptr_array[symbol];\r\nthread_overlap_check_no_defs_loop_match:\r\n  symbol = *in_symbol_ptr++;\r\n  if (symbol != match_node_ptr-\u003esymbol) {\r\n    uint32_t shifted_symbol = symbol;\r\n    do {\r\n      if (match_node_ptr-\u003esibling_node_num[shifted_symbol \u0026 0xF] != 0) {\r\n        match_node_ptr = \u0026match_nodes[match_node_ptr-\u003esibling_node_num[shifted_symbol \u0026 0xF]];\r\n        shifted_symbol \u003e\u003e= 4;\r\n      }\r\n      else {\r\n        if (match_node_ptr-\u003emiss_ptr == 0) {\r\n          if (base_child_ptr_array[symbol] == 0)\r\n            goto thread_overlap_check_no_defs_loop_no_match;\r\n          if (in_symbol_ptr \u003e end_symbol_ptr)\r\n            return(0);\r\n          match_node_ptr = base_child_ptr_array[symbol];\r\n          goto thread_overlap_check_no_defs_loop_match;\r\n        }\r\n        else {\r\n          match_node_ptr = match_node_ptr-\u003emiss_ptr;\r\n          shifted_symbol = symbol;\r\n        }\r\n      }\r\n    } while (symbol != match_node_ptr-\u003esymbol);\r\n  }\r\n  if (match_node_ptr-\u003echild_ptr != 0) {\r\n    if (in_symbol_ptr \u003e end_symbol_ptr)\r\n      if (in_symbol_ptr - match_node_ptr-\u003enum_symbols \u003e= end_symbol_ptr)\r\n        return(0);\r\n    match_node_ptr = match_node_ptr-\u003echild_ptr;\r\n    goto thread_overlap_check_no_defs_loop_match;\r\n  }\r\n\r\n  // no child, so found a match - check for overlaps\r\n  uint32_t node_score_number = match_node_ptr-\u003escore_number;\r\n  if ((num_prior_matches != 0) \u0026\u0026 (in_symbol_ptr - match_node_ptr-\u003enum_symbols\r\n      \u003c= prior_match_end_ptr[num_prior_matches - 1])) {\r\n    if (num_prior_matches == 1) {\r\n      if (prior_match_score_number[0] != node_score_number) {\r\n        if (fast_mode == 0) {\r\n          if (prior_match_score_number[0] \u003e node_score_number)\r\n            candidate_bad[prior_match_score_number[0]] = 1;\r\n          else\r\n            candidate_bad[node_score_number] = 1;\r\n        }\r\n        else {\r\n          uint32_t low_score, high_score;\r\n          if (node_score_number \u003c prior_match_score_number[0]) {\r\n            low_score = node_score_number;\r\n            high_score = prior_match_score_number[0];\r\n          }\r\n          else {\r\n            low_score = prior_match_score_number[0];\r\n            high_score = node_score_number;\r\n          }\r\n          int32_t * next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[low_score];\r\n          while ((*next_overlap_num_ptr != -1) \u0026\u0026 (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] \u003c high_score))\r\n            next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[*next_overlap_num_ptr];\r\n          if ((*next_overlap_num_ptr == -1) || (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] != high_score)) {\r\n            if (num_overlaps \u003c 150000) {\r\n              thread_data_ptr-\u003esecond[num_overlaps] = high_score;\r\n              thread_data_ptr-\u003enext[num_overlaps] = *next_overlap_num_ptr;\r\n              *next_overlap_num_ptr = num_overlaps++;\r\n            }\r\n            else\r\n              candidate_bad[high_score] = 1;\r\n          }\r\n        }\r\n        prior_match_end_ptr[1] = in_symbol_ptr - 1;\r\n        prior_match_score_number[1] = node_score_number;\r\n        num_prior_matches = 2;\r\n      }\r\n    }\r\n    else {\r\n      uint32_t prior_match_number = 0;\r\n      uint8_t found_same_score_prior_match = 0;\r\n      do {\r\n        if (in_symbol_ptr - match_node_ptr-\u003enum_symbols \u003e prior_match_end_ptr[prior_match_number]) {\r\n          num_prior_matches--;\r\n          uint32_t i;\r\n          for (i = prior_match_number ; i \u003c num_prior_matches ; i++) {\r\n            prior_match_end_ptr[i] = prior_match_end_ptr[i + 1];\r\n            prior_match_score_number[i] = prior_match_score_number[i + 1];\r\n          }\r\n        }\r\n        else { // overlapping candidates - invalidate the lower score\r\n          if (prior_match_score_number[prior_match_number] == node_score_number)\r\n            found_same_score_prior_match = 1;\r\n          else {\r\n            if (fast_mode == 0) {\r\n              if (prior_match_score_number[prior_match_number] \u003e node_score_number)\r\n                candidate_bad[prior_match_score_number[prior_match_number]] = 1;\r\n              else\r\n               candidate_bad[node_score_number] = 1;\r\n            }\r\n            else {\r\n              uint32_t low_score, high_score;\r\n              if (node_score_number \u003c prior_match_score_number[prior_match_number]) {\r\n                low_score = node_score_number;\r\n                high_score = prior_match_score_number[prior_match_number];\r\n              }\r\n              else {\r\n                low_score = prior_match_score_number[prior_match_number];\r\n                high_score = node_score_number;\r\n              }\r\n              int32_t * next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[low_score];\r\n              while ((*next_overlap_num_ptr != -1) \u0026\u0026 (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] \u003c high_score))\r\n                next_overlap_num_ptr = \u0026thread_data_ptr-\u003enext[*next_overlap_num_ptr];\r\n              if ((*next_overlap_num_ptr == -1) || (thread_data_ptr-\u003esecond[*next_overlap_num_ptr] != high_score)) {\r\n                if (num_overlaps \u003c 150000) {\r\n                  thread_data_ptr-\u003esecond[num_overlaps] = high_score;\r\n                  thread_data_ptr-\u003enext[num_overlaps] = *next_overlap_num_ptr;\r\n                  *next_overlap_num_ptr = num_overlaps++;\r\n                }\r\n                else\r\n                  candidate_bad[high_score] = 1;\r\n              }\r\n            }\r\n          }\r\n          prior_match_number++;\r\n        }\r\n      } while (prior_match_number \u003c num_prior_matches);\r\n      if (found_same_score_prior_match == 0) {\r\n        prior_match_end_ptr[num_prior_matches] = in_symbol_ptr - 1;\r\n        prior_match_score_number[num_prior_matches++] = node_score_number;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    num_prior_matches = 1;\r\n    prior_match_end_ptr[0] = in_symbol_ptr - 1;\r\n    prior_match_score_number[0] = node_score_number;\r\n  }\r\n  match_node_ptr = match_node_ptr-\u003ehit_ptr;\r\n  if (match_node_ptr == 0) {\r\n    if (base_child_ptr_array[symbol] == 0)\r\n      goto thread_overlap_check_no_defs_loop_no_match;\r\n    match_node_ptr = base_child_ptr_array[symbol];\r\n    goto thread_overlap_check_no_defs_loop_match;\r\n  }\r\n  if ((in_symbol_ptr \u003c= end_symbol_ptr) || (in_symbol_ptr - match_node_ptr-\u003enum_symbols \u003c end_symbol_ptr)) {\r\n    match_node_ptr = match_node_ptr-\u003echild_ptr;\r\n    goto thread_overlap_check_no_defs_loop_match;\r\n  }\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":3984,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3303408":{"score":0.81430054,"function_name":"find_substitutions_no_defs_thread","code":"void *find_substitutions_no_defs_thread(void *arg) {\r\n  struct find_substitutions_thread_data * thread_data_ptr = (struct find_substitutions_thread_data *)arg;\r\n  uint32_t * in_symbol_ptr = thread_data_ptr-\u003estart_symbol_ptr;\r\n  uint32_t * previous_in_symbol_ptr = in_symbol_ptr;\r\n  uint32_t * end_symbol_ptr = thread_data_ptr-\u003estop_symbol_ptr;\r\n  struct match_node * match_nodes = thread_data_ptr-\u003ematch_nodes;\r\n  uint32_t substitute_index = 0;\r\n  uint32_t local_read_index = 0;\r\n  uint32_t symbol;\r\n  struct match_node *match_node_ptr;\r\n\r\n  thread_data_ptr-\u003eextra_match_symbols = 0;\r\nthread_symbol_substitution_no_defs_loop_top:\r\n  symbol = *in_symbol_ptr++;\r\n  if (base_child_ptr_array[symbol] != 0) {\r\n    match_node_ptr = base_child_ptr_array[symbol];\r\nthread_symbol_substitution_no_defs_loop_match:\r\n    symbol = *in_symbol_ptr++;\r\n    if (symbol != match_node_ptr-\u003esymbol) {\r\n      uint32_t sibling_nibble = symbol;\r\n      do {\r\n        if (match_node_ptr-\u003esibling_node_num[sibling_nibble \u0026 0xF] != 0) {\r\n          match_node_ptr = \u0026match_nodes[match_node_ptr-\u003esibling_node_num[sibling_nibble \u0026 0xF]];\r\n          sibling_nibble = sibling_nibble \u003e\u003e 4;\r\n        }\r\n        else { // no match, so use miss node and output missed symbols\r\n          if (match_node_ptr-\u003emiss_ptr == 0) {\r\n            if (base_child_ptr_array[symbol] != 0) {\r\n              if (in_symbol_ptr \u003e end_symbol_ptr)\r\n                goto thread_symbol_substitution_no_defs_loop_end;\r\n              match_node_ptr = base_child_ptr_array[symbol];\r\n              goto thread_symbol_substitution_no_defs_loop_match;\r\n            }\r\n            if (in_symbol_ptr \u003c end_symbol_ptr)\r\n              goto thread_symbol_substitution_no_defs_loop_top;\r\n            goto thread_symbol_substitution_no_defs_loop_end;\r\n          }\r\n          if ((in_symbol_ptr \u003e end_symbol_ptr)\r\n              \u0026\u0026 (in_symbol_ptr - match_node_ptr-\u003emiss_ptr-\u003enum_symbols \u003e= end_symbol_ptr))\r\n            goto thread_symbol_substitution_no_defs_loop_end;\r\n          match_node_ptr = match_node_ptr-\u003emiss_ptr;\r\n          sibling_nibble = symbol;\r\n        }\r\n      } while (symbol != match_node_ptr-\u003esymbol);\r\n    }\r\n    if (match_node_ptr-\u003echild_ptr != 0) {\r\n      match_node_ptr = match_node_ptr-\u003echild_ptr;\r\n      goto thread_symbol_substitution_no_defs_loop_match;\r\n    }\r\n    // found a match\r\n    while ((((substitute_index - local_read_index) \u0026 0x7FFFFC) == 0x7FFFFC)\r\n        \u0026\u0026 (((substitute_index - (local_read_index = atomic_load_explicit(\u0026thread_data_ptr-\u003eread_index,\r\n          memory_order_acquire))) \u0026 0x7FFFFC) == 0x7FFFFC))\r\n      sched_yield();\r\n    if (in_symbol_ptr - previous_in_symbol_ptr - match_node_ptr-\u003enum_symbols != 0) {\r\n      thread_data_ptr-\u003edata[substitute_index] = in_symbol_ptr - previous_in_symbol_ptr - match_node_ptr-\u003enum_symbols;\r\n      substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n    }\r\n    thread_data_ptr-\u003edata[substitute_index] = 0x80000000 + match_node_ptr-\u003enum_symbols;\r\n    substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n    thread_data_ptr-\u003edata[substitute_index] = match_node_ptr-\u003escore_number;\r\n    substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n    atomic_store_explicit(\u0026thread_data_ptr-\u003ewrite_index, substitute_index, memory_order_release);\r\n    previous_in_symbol_ptr = in_symbol_ptr;\r\n    if (in_symbol_ptr \u003c end_symbol_ptr)\r\n      goto thread_symbol_substitution_no_defs_loop_top;\r\n    thread_data_ptr-\u003eextra_match_symbols = in_symbol_ptr - end_symbol_ptr;\r\n    goto thread_symbol_substitution_no_defs_loop_end2;\r\n  }\r\n  if (in_symbol_ptr \u003c end_symbol_ptr)\r\n    goto thread_symbol_substitution_no_defs_loop_top;\r\n\r\nthread_symbol_substitution_no_defs_loop_end:\r\n  while ((((substitute_index - local_read_index) \u0026 0x7FFFFF) == 0x7FFFFF)\r\n     \u0026\u0026 (((substitute_index - (local_read_index = atomic_load_explicit(\u0026thread_data_ptr-\u003eread_index,\r\n          memory_order_acquire))) \u0026 0x7FFFFF) == 0x7FFFFF))\r\n    sched_yield();\r\n  thread_data_ptr-\u003edata[substitute_index] = end_symbol_ptr - previous_in_symbol_ptr;\r\n  substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n  atomic_store_explicit(\u0026thread_data_ptr-\u003ewrite_index, substitute_index, memory_order_release);\r\nthread_symbol_substitution_no_defs_loop_end2:\r\n  atomic_store_explicit(\u0026thread_data_ptr-\u003edone, 1, memory_order_relaxed);\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":4263,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3304064":{"score":0.8431631,"function_name":"find_substitutions_no_defs_thread","code":"void *find_substitutions_no_defs_thread(void *arg) {\r\n  struct find_substitutions_thread_data * thread_data_ptr = (struct find_substitutions_thread_data *)arg;\r\n  uint32_t * in_symbol_ptr = thread_data_ptr-\u003estart_symbol_ptr;\r\n  uint32_t * previous_in_symbol_ptr = in_symbol_ptr;\r\n  uint32_t * end_symbol_ptr = thread_data_ptr-\u003estop_symbol_ptr;\r\n  struct match_node * match_nodes = thread_data_ptr-\u003ematch_nodes;\r\n  uint32_t substitute_index = 0;\r\n  uint32_t local_read_index = 0;\r\n  uint32_t symbol;\r\n  struct match_node *match_node_ptr;\r\n\r\n  thread_data_ptr-\u003eextra_match_symbols = 0;\r\nthread_symbol_substitution_no_defs_loop_top:\r\n  symbol = *in_symbol_ptr++;\r\n  if (base_child_ptr_array[symbol] != 0) {\r\n    match_node_ptr = base_child_ptr_array[symbol];\r\nthread_symbol_substitution_no_defs_loop_match:\r\n    symbol = *in_symbol_ptr++;\r\n    if (symbol != match_node_ptr-\u003esymbol) {\r\n      uint32_t sibling_nibble = symbol;\r\n      do {\r\n        if (match_node_ptr-\u003esibling_node_num[sibling_nibble \u0026 0xF] != 0) {\r\n          match_node_ptr = \u0026match_nodes[match_node_ptr-\u003esibling_node_num[sibling_nibble \u0026 0xF]];\r\n          sibling_nibble = sibling_nibble \u003e\u003e 4;\r\n        }\r\n        else { // no match, so use miss node and output missed symbols\r\n          if (match_node_ptr-\u003emiss_ptr == 0) {\r\n            if (base_child_ptr_array[symbol] != 0) {\r\n              if (in_symbol_ptr \u003e end_symbol_ptr)\r\n                goto thread_symbol_substitution_no_defs_loop_end;\r\n              match_node_ptr = base_child_ptr_array[symbol];\r\n              goto thread_symbol_substitution_no_defs_loop_match;\r\n            }\r\n            if (in_symbol_ptr \u003c end_symbol_ptr)\r\n              goto thread_symbol_substitution_no_defs_loop_top;\r\n            goto thread_symbol_substitution_no_defs_loop_end;\r\n          }\r\n          if ((in_symbol_ptr \u003e end_symbol_ptr)\r\n              \u0026\u0026 (in_symbol_ptr - match_node_ptr-\u003emiss_ptr-\u003enum_symbols \u003e= end_symbol_ptr))\r\n            goto thread_symbol_substitution_no_defs_loop_end;\r\n          match_node_ptr = match_node_ptr-\u003emiss_ptr;\r\n          sibling_nibble = symbol;\r\n        }\r\n      } while (symbol != match_node_ptr-\u003esymbol);\r\n    }\r\n    if (match_node_ptr-\u003echild_ptr != 0) {\r\n      match_node_ptr = match_node_ptr-\u003echild_ptr;\r\n      goto thread_symbol_substitution_no_defs_loop_match;\r\n    }\r\n    // found a match\r\n    while ((((substitute_index - local_read_index) \u0026 0x7FFFFC) == 0x7FFFFC)\r\n        \u0026\u0026 (((substitute_index - (local_read_index = atomic_load_explicit(\u0026thread_data_ptr-\u003eread_index,\r\n          memory_order_acquire))) \u0026 0x7FFFFC) == 0x7FFFFC))\r\n      sched_yield();\r\n    if (in_symbol_ptr - previous_in_symbol_ptr - match_node_ptr-\u003enum_symbols != 0) {\r\n      thread_data_ptr-\u003edata[substitute_index] = in_symbol_ptr - previous_in_symbol_ptr - match_node_ptr-\u003enum_symbols;\r\n      substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n    }\r\n    thread_data_ptr-\u003edata[substitute_index] = 0x80000000 + match_node_ptr-\u003enum_symbols;\r\n    substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n    thread_data_ptr-\u003edata[substitute_index] = match_node_ptr-\u003escore_number;\r\n    substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n    atomic_store_explicit(\u0026thread_data_ptr-\u003ewrite_index, substitute_index, memory_order_release);\r\n    previous_in_symbol_ptr = in_symbol_ptr;\r\n    if (in_symbol_ptr \u003c end_symbol_ptr)\r\n      goto thread_symbol_substitution_no_defs_loop_top;\r\n    thread_data_ptr-\u003eextra_match_symbols = in_symbol_ptr - end_symbol_ptr;\r\n    goto thread_symbol_substitution_no_defs_loop_end2;\r\n  }\r\n  if (in_symbol_ptr \u003c end_symbol_ptr)\r\n    goto thread_symbol_substitution_no_defs_loop_top;\r\n\r\nthread_symbol_substitution_no_defs_loop_end:\r\n  while ((((substitute_index - local_read_index) \u0026 0x7FFFFF) == 0x7FFFFF)\r\n     \u0026\u0026 (((substitute_index - (local_read_index = atomic_load_explicit(\u0026thread_data_ptr-\u003eread_index,\r\n          memory_order_acquire))) \u0026 0x7FFFFF) == 0x7FFFFF))\r\n    sched_yield();\r\n  thread_data_ptr-\u003edata[substitute_index] = end_symbol_ptr - previous_in_symbol_ptr;\r\n  substitute_index = (substitute_index + 1) \u0026 0x7FFFFF;\r\n  atomic_store_explicit(\u0026thread_data_ptr-\u003ewrite_index, substitute_index, memory_order_release);\r\nthread_symbol_substitution_no_defs_loop_end2:\r\n  atomic_store_explicit(\u0026thread_data_ptr-\u003edone, 1, memory_order_relaxed);\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":4263,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3304640":{"score":0.84817445,"function_name":"substitute_thread","code":"void *substitute_thread(void *arg) {\r\n  struct substitute_thread_data * thread_data_ptr = (struct substitute_thread_data *)arg;\r\n  uint32_t data;\r\n  uint16_t substitute_data_index = 0;\r\n  uint16_t local_write_index;\r\n\r\n  thread_data_ptr-\u003eout_symbol_ptr = thread_data_ptr-\u003ein_symbol_ptr;\r\n  while (1) {\r\n    while ((local_write_index = atomic_load_explicit(\u0026substitute_data_write_index, memory_order_relaxed))\r\n        == substitute_data_index) /* wait */ ;\r\n    do {\r\n      if ((int32_t)(data = thread_data_ptr-\u003esubstitute_data[substitute_data_index++]) \u003e= 0) {\r\n        memmove(thread_data_ptr-\u003eout_symbol_ptr, thread_data_ptr-\u003ein_symbol_ptr, data * 4);\r\n        thread_data_ptr-\u003ein_symbol_ptr += data;\r\n        thread_data_ptr-\u003eout_symbol_ptr += data;\r\n      }\r\n      else if (data != 0xFFFFFFFF) {\r\n        thread_data_ptr-\u003ein_symbol_ptr += (size_t)(data + 0x80000000);\r\n        uint32_t symbol = thread_data_ptr-\u003esubstitute_data[substitute_data_index++];\r\n        *thread_data_ptr-\u003eout_symbol_ptr++ = symbol;\r\n        thread_data_ptr-\u003esymbol_counts[symbol]++;\r\n      }\r\n      else\r\n        return(0);\r\n      atomic_store_explicit(\u0026substitute_data_read_index, substitute_data_index, memory_order_relaxed);\r\n    } while (local_write_index != substitute_data_index);\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":4349,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3304832":{"score":0.8471262,"function_name":"get_UTF8_context","code":"uint8_t get_UTF8_context(uint32_t symbol) {\r\n  if (symbol \u003c 0x80)\r\n    return((uint8_t)symbol);\r\n  else if (symbol \u003c 0x250)\r\n    return(0x80);\r\n  else if (symbol \u003c 0x370)\r\n    return(0x81);\r\n  else if (symbol \u003c 0x400)\r\n    return(0x82);\r\n  else if (symbol \u003c 0x530)\r\n    return(0x83);\r\n  else if (symbol \u003c 0x590)\r\n    return(0x84);\r\n  else if (symbol \u003c 0x600)\r\n    return(0x85);\r\n  else if (symbol \u003c 0x700)\r\n    return(0x86);\r\n  else if (symbol \u003c 0x800)\r\n    return(0x87);\r\n  else if (symbol \u003c 0x1000)\r\n    return(0x88);\r\n  else if (symbol \u003c 0x2000)\r\n    return(0x89);\r\n  else if (symbol \u003c 0x3000)\r\n    return(0x8A);\r\n  else if (symbol \u003c 0x3040)\r\n    return(0x8B);\r\n  else if (symbol \u003c 0x30A0)\r\n    return(0x8C);\r\n  else if (symbol \u003c 0x3100)\r\n    return(0x8D);\r\n  else if (symbol \u003c 0x3200)\r\n    return(0x8E);\r\n  else if (symbol \u003c 0xA000)\r\n    return(0x8F);\r\n  else if (symbol \u003c 0x10000)\r\n    return(0x8E);\r\n  else\r\n    return(0x90);\r\n}","filepath":"glza/GLZAcompress.c","line_number":178,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3305104":{"score":0.8483912,"function_name":"init_match_node","code":"void init_match_node(struct match_node *match_node_ptr, uint32_t symbol, uint32_t match_num_symbols,\r\n    uint32_t match_score_number) {\r\n  match_node_ptr-\u003esymbol = symbol;\r\n  match_node_ptr-\u003enum_symbols = match_num_symbols;\r\n  match_node_ptr-\u003escore_number = match_score_number;\r\n  match_node_ptr-\u003echild_ptr = 0;\r\n  uint64_t * sibling_nodes_ptr = (uint64_t *)\u0026match_node_ptr-\u003esibling_node_num[0];\r\n  *sibling_nodes_ptr = 0;\r\n  *(sibling_nodes_ptr + 1) = 0;\r\n  *(sibling_nodes_ptr + 2) = 0;\r\n  *(sibling_nodes_ptr + 3) = 0;\r\n  *(sibling_nodes_ptr + 4) = 0;\r\n  *(sibling_nodes_ptr + 5) = 0;\r\n  *(sibling_nodes_ptr + 6) = 0;\r\n  *(sibling_nodes_ptr + 7) = 0;\r\n  match_node_ptr-\u003emiss_ptr = 0;\r\n  match_node_ptr-\u003ehit_ptr = 0;\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":220,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3305216":{"score":0.9150986,"function_name":"move_to_match_sibling","code":"uint8_t move_to_match_sibling(struct match_node *match_nodes, struct match_node **match_node_ptr_ptr,\r\n    uint32_t symbol, uint8_t * sibling_number) {\r\n  uint32_t shifted_symbol = symbol;\r\n  *sibling_number = (uint8_t)(shifted_symbol \u0026 0xF);\r\n  while (symbol != (*match_node_ptr_ptr)-\u003esymbol) {\r\n    if ((*match_node_ptr_ptr)-\u003esibling_node_num[*sibling_number] == 0)\r\n      return(0);\r\n    *match_node_ptr_ptr = \u0026match_nodes[(*match_node_ptr_ptr)-\u003esibling_node_num[*sibling_number]];\r\n    shifted_symbol \u003e\u003e= 4;\r\n    *sibling_number = (uint8_t)(shifted_symbol \u0026 0xF);\r\n  }\r\n  return(1);\r\n}","filepath":"glza/GLZAcompress.c","line_number":241,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3305312":{"score":0.8355863,"function_name":"move_to_existing_match_sibling","code":"void move_to_existing_match_sibling(struct match_node *match_nodes, struct match_node **match_node_ptr_ptr,\r\n    uint32_t symbol) {\r\n  uint32_t shifted_symbol = symbol;\r\n  uint8_t sibling_number = (uint8_t)(shifted_symbol \u0026 0xF);\r\n  while (symbol != (*match_node_ptr_ptr)-\u003esymbol) {\r\n    *match_node_ptr_ptr = \u0026match_nodes[(*match_node_ptr_ptr)-\u003esibling_node_num[sibling_number]];\r\n    shifted_symbol \u003e\u003e= 4;\r\n    sibling_number = (uint8_t)(shifted_symbol \u0026 0xF);\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":256,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3305376":{"score":0.8401422,"function_name":"move_to_search_sibling","code":"uint8_t move_to_search_sibling(struct match_node *match_nodes, uint32_t symbol, struct match_node **search_node_ptr_ptr) {\r\n  uint8_t sibling_depth = 0;\r\n  uint32_t shifted_symbol = symbol;\r\n  uint8_t sibling_nibble = (uint8_t)(shifted_symbol \u0026 0xF);\r\n  while (symbol != (*search_node_ptr_ptr)-\u003esymbol) {\r\n    if ((*search_node_ptr_ptr)-\u003esibling_node_num[sibling_nibble] == 0)\r\n      return(0);\r\n    *search_node_ptr_ptr = \u0026match_nodes[(*search_node_ptr_ptr)-\u003esibling_node_num[sibling_nibble]];\r\n    sibling_depth++;\r\n    shifted_symbol \u003e\u003e= 4;\r\n    sibling_nibble = (uint8_t)(shifted_symbol \u0026 0xF);\r\n  }\r\n  return(1);\r\n}","filepath":"glza/GLZAcompress.c","line_number":269,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3305456":{"score":0.6898316,"function_name":"move_to_base_match_child_with_make","code":"struct match_node * move_to_base_match_child_with_make(struct match_node *match_nodes, uint32_t symbol,\r\n    uint32_t score_number, uint32_t *num_match_nodes_ptr, struct match_node ** base_child_ptr_ptr) {\r\n  struct match_node * match_node_ptr;\r\n  if (*base_child_ptr_ptr == 0) {\r\n    *base_child_ptr_ptr = \u0026match_nodes[(*num_match_nodes_ptr)++];\r\n    match_node_ptr = *base_child_ptr_ptr;\r\n    init_match_node(match_node_ptr, symbol, 2, score_number);\r\n  }\r\n  else {\r\n    match_node_ptr = *base_child_ptr_ptr;\r\n    uint8_t sibling_number;\r\n    if (move_to_match_sibling(match_nodes, \u0026match_node_ptr, symbol, \u0026sibling_number) == 0) {\r\n      match_node_ptr-\u003esibling_node_num[sibling_number] = *num_match_nodes_ptr;\r\n      match_node_ptr = \u0026match_nodes[(*num_match_nodes_ptr)++];\r\n      init_match_node(match_node_ptr, symbol, 2, score_number);\r\n    }\r\n  }\r\n  return(match_node_ptr);\r\n}","filepath":"glza/GLZAcompress.c","line_number":285,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3305712":{"score":0.7108435,"function_name":"move_to_match_child_with_make","code":"void move_to_match_child_with_make(struct match_node *match_nodes, struct match_node **match_node_ptr_ptr,\r\n    uint32_t symbol, uint32_t score_number, uint32_t best_score_num_symbols, uint32_t *num_match_nodes_ptr) {\r\n  if ((*match_node_ptr_ptr)-\u003echild_ptr == 0) {\r\n    (*match_node_ptr_ptr)-\u003echild_ptr = \u0026match_nodes[(*num_match_nodes_ptr)++];\r\n    *match_node_ptr_ptr = (*match_node_ptr_ptr)-\u003echild_ptr;\r\n    init_match_node(*match_node_ptr_ptr, symbol, best_score_num_symbols, score_number);\r\n  }\r\n  else {\r\n    (*match_node_ptr_ptr) = (*match_node_ptr_ptr)-\u003echild_ptr;\r\n    uint8_t sibling_number;\r\n    if (move_to_match_sibling(match_nodes, match_node_ptr_ptr, symbol, \u0026sibling_number) == 0) {\r\n      (*match_node_ptr_ptr)-\u003esibling_node_num[sibling_number] = *num_match_nodes_ptr;\r\n      *match_node_ptr_ptr = \u0026match_nodes[(*num_match_nodes_ptr)++];\r\n      init_match_node(*match_node_ptr_ptr, symbol, best_score_num_symbols, score_number);\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":306,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3306000":{"score":0.78894,"function_name":"write_siblings_miss_ptr","code":"void write_siblings_miss_ptr(struct match_node *match_nodes, struct match_node *node_ptr, struct match_node *miss_ptr) {\r\n  uint8_t sibling_nibble;\r\n  node_ptr-\u003emiss_ptr = miss_ptr;\r\n  for (sibling_nibble = 0 ; sibling_nibble \u003c 16 ; sibling_nibble++) {\r\n    uint32_t sibling_node_number = node_ptr-\u003esibling_node_num[sibling_nibble];\r\n    if (sibling_node_number != 0)\r\n      write_siblings_miss_ptr(match_nodes, \u0026match_nodes[sibling_node_number], miss_ptr);\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":326,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3306688":{"score":0.82095873,"function_name":"invalidate_branch","code":"void invalidate_branch(struct match_node * match_node_ptr, uint8_t * candidate_bad, struct match_node * match_nodes) {\r\n  uint8_t sibling_number;\r\n  candidate_bad[match_node_ptr-\u003escore_number] = 1;\r\n  for (sibling_number = 0 ; sibling_number \u003c 16 ; sibling_number++)\r\n    if (match_node_ptr-\u003esibling_node_num[sibling_number] != 0)\r\n      invalidate_branch(\u0026match_nodes[match_node_ptr-\u003esibling_node_num[sibling_number]], candidate_bad, match_nodes);\r\n  if (match_node_ptr-\u003echild_ptr != 0)\r\n    invalidate_branch(match_node_ptr-\u003echild_ptr, candidate_bad, match_nodes);\r\n}","filepath":"glza/GLZAcompress.c","line_number":338,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3306816":{"score":0.83666366,"function_name":"create_suffix_node","code":"struct string_node * create_suffix_node(uint32_t suffix_symbol, uint32_t symbol_index,\r\n      uint32_t * next_string_node_num_ptr) {\r\n  struct string_node * node_ptr = \u0026string_nodes[(*next_string_node_num_ptr)++];\r\n  node_ptr-\u003esymbol = suffix_symbol;\r\n  node_ptr-\u003elast_match_index = symbol_index;\r\n  node_ptr-\u003esibling_node_num[0] = 0;\r\n  node_ptr-\u003esibling_node_num[1] = 0;\r\n  node_ptr-\u003echild_node_num = 0;\r\n  node_ptr-\u003enum_extra_symbols = 0;\r\n  node_ptr-\u003einstances = 1;\r\n  return(node_ptr);\r\n}","filepath":"glza/GLZAcompress.c","line_number":349,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3306880":{"score":0.8361669,"function_name":"split_node_for_overlap","code":"struct string_node * split_node_for_overlap(struct string_node * node_ptr, uint32_t split_index,\r\n    uint32_t in_symbol_index, uint32_t * next_string_node_num_ptr) {\r\n  uint32_t non_overlap_length = split_index - node_ptr-\u003elast_match_index;\r\n  struct string_node * new_node_ptr = \u0026string_nodes[*next_string_node_num_ptr];\r\n  new_node_ptr-\u003esymbol = *(start_symbol_ptr + split_index);\r\n  new_node_ptr-\u003elast_match_index = split_index;\r\n  new_node_ptr-\u003esibling_node_num[0] = 0;\r\n  new_node_ptr-\u003esibling_node_num[1] = 0;\r\n  new_node_ptr-\u003echild_node_num = node_ptr-\u003echild_node_num;\r\n  new_node_ptr-\u003enum_extra_symbols = node_ptr-\u003enum_extra_symbols - non_overlap_length;\r\n  new_node_ptr-\u003einstances = node_ptr-\u003einstances;\r\n  node_ptr-\u003elast_match_index = in_symbol_index;\r\n  node_ptr-\u003echild_node_num = (*next_string_node_num_ptr)++;\r\n  node_ptr-\u003enum_extra_symbols = non_overlap_length - 1;\r\n  node_ptr-\u003einstances++;\r\n  return(new_node_ptr);\r\n}","filepath":"glza/GLZAcompress.c","line_number":363,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3307008":{"score":0.860427,"function_name":"add_word_suffix","code":"void add_word_suffix(uint32_t *in_symbol_ptr, uint32_t *next_string_node_num_ptr) {\r\n  uint32_t search_symbol = *in_symbol_ptr;\r\n  int32_t * base_node_child_num_ptr;\r\n  if (search_symbol \u003c 0x80)\r\n    base_node_child_num_ptr = \u0026base_string_nodes_child_node_num[search_symbol];\r\n  else\r\n    base_node_child_num_ptr = \u0026base_string_nodes_child_node_num[0x80 + (search_symbol \u0026 0xF)];\r\n  if (*base_node_child_num_ptr == 0) { // first occurence of the symbol, so create a child\r\n    *base_node_child_num_ptr = in_symbol_ptr - start_symbol_ptr - 0x80000000;\r\n    return;\r\n  }\r\n  else if (*base_node_child_num_ptr \u003c 0) {\r\n    uint32_t symbol_index = *base_node_child_num_ptr + 0x80000000;\r\n    *base_node_child_num_ptr = *next_string_node_num_ptr;\r\n    (void)create_suffix_node(*(start_symbol_ptr + symbol_index), symbol_index, next_string_node_num_ptr);\r\n  }\r\n  struct string_node * node_ptr = \u0026string_nodes[*base_node_child_num_ptr];\r\n  if (search_symbol != node_ptr-\u003esymbol) {  // follow siblings until match found or end of siblings found\r\n    uint32_t shifted_search_symbol = search_symbol \u003e\u003e 4;\r\n    do {\r\n      int32_t * sibling_node_num_ptr = \u0026node_ptr-\u003esibling_node_num[shifted_search_symbol \u0026 1];\r\n      if (*sibling_node_num_ptr == 0) { // no match so add sibling\r\n        *sibling_node_num_ptr = *next_string_node_num_ptr;\r\n        (void)create_suffix_node(search_symbol, in_symbol_ptr - start_symbol_ptr, next_string_node_num_ptr);\r\n        return;\r\n      }\r\n      node_ptr = \u0026string_nodes[*sibling_node_num_ptr];\r\n      shifted_search_symbol = shifted_search_symbol \u003e\u003e 1;\r\n    } while (search_symbol != node_ptr-\u003esymbol);\r\n  }\r\n\r\n  // found a matching sibling\r\n  uint32_t * first_symbol_ptr = in_symbol_ptr - 1;\r\n  while (node_ptr-\u003echild_node_num != 0) {\r\n    // matching sibling with child so check length of match\r\n    uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n    if (num_extra_symbols != 0) {\r\n      uint32_t * node_symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n      uint32_t length = 1;\r\n      do {\r\n        if (*(node_symbol_ptr + length) != *(in_symbol_ptr + length)) { // insert node in branch\r\n          struct string_node * new_node_ptr = \u0026string_nodes[*next_string_node_num_ptr];\r\n          new_node_ptr-\u003elast_match_index = node_ptr-\u003elast_match_index + length;\r\n          new_node_ptr-\u003esymbol = *(node_symbol_ptr + length);\r\n          new_node_ptr-\u003esibling_node_num[0] = 0;\r\n          new_node_ptr-\u003esibling_node_num[1] = 0;\r\n          new_node_ptr-\u003echild_node_num = node_ptr-\u003echild_node_num;\r\n          new_node_ptr-\u003enum_extra_symbols = num_extra_symbols - length;\r\n          new_node_ptr-\u003einstances = node_ptr-\u003einstances;\r\n          node_ptr-\u003enum_extra_symbols = length - 1;\r\n          node_ptr-\u003echild_node_num = (*next_string_node_num_ptr)++;\r\n          new_node_ptr-\u003esibling_node_num[(*(in_symbol_ptr + length)) \u0026 1] = *next_string_node_num_ptr;\r\n          (void)create_suffix_node(*(in_symbol_ptr + length), in_symbol_ptr + length - start_symbol_ptr,\r\n              next_string_node_num_ptr);\r\n          node_ptr-\u003einstances++;\r\n          return;\r\n        }\r\n      } while (length++ != num_extra_symbols);\r\n    }\r\n    node_ptr-\u003einstances++;\r\n    in_symbol_ptr += num_extra_symbols + 1;\r\n    if (*(in_symbol_ptr - 1) == 0x20)\r\n      return;\r\n    search_symbol = *in_symbol_ptr;\r\n\r\n    node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    if (search_symbol != node_ptr-\u003esymbol) { // follow siblings until match found or end of siblings found\r\n      uint32_t shifted_search_symbol = search_symbol;\r\n      do {\r\n        int32_t * prior_node_num_ptr = \u0026node_ptr-\u003esibling_node_num[shifted_search_symbol \u0026 1];\r\n        if (*prior_node_num_ptr == 0) {\r\n          *prior_node_num_ptr = *next_string_node_num_ptr;\r\n          (void)create_suffix_node(search_symbol, in_symbol_ptr - start_symbol_ptr, next_string_node_num_ptr);\r\n          return;\r\n        }\r\n        node_ptr = \u0026string_nodes[*prior_node_num_ptr];\r\n        shifted_search_symbol \u003e\u003e= 1;\r\n      } while (search_symbol != node_ptr-\u003esymbol);\r\n    }\r\n  }\r\n\r\n  // Matching node without child - extend branch, add child for previous instance, add child sibling\r\n  node_ptr-\u003einstances = 2;\r\n  node_ptr-\u003echild_node_num = *next_string_node_num_ptr;\r\n  uint32_t * node_symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n  uint32_t * max_symbol_ptr = first_symbol_ptr + MAX_MATCH_LENGTH - 1;\r\n  if ((*(node_symbol_ptr + 1) == *(in_symbol_ptr + 1)) \u0026\u0026 (*in_symbol_ptr != 0x20)\r\n      \u0026\u0026 (in_symbol_ptr \u003c max_symbol_ptr)) {\r\n    uint32_t length = 2;\r\n    while ((*(node_symbol_ptr + length) == *(in_symbol_ptr + length)) \u0026\u0026 (*(in_symbol_ptr + length - 1) != 0x20)\r\n        \u0026\u0026 (in_symbol_ptr + length \u003c= max_symbol_ptr))\r\n      length++;\r\n    node_ptr-\u003enum_extra_symbols = length - 1;\r\n    node_ptr = create_suffix_node(*(node_symbol_ptr + length), node_symbol_ptr + length - start_symbol_ptr,\r\n        next_string_node_num_ptr);\r\n    node_ptr-\u003esibling_node_num[*(in_symbol_ptr + length) \u0026 1] = *next_string_node_num_ptr;\r\n    (void)create_suffix_node(*(in_symbol_ptr + length), in_symbol_ptr + length - start_symbol_ptr,\r\n        next_string_node_num_ptr);\r\n    return;\r\n  }\r\n  node_ptr = create_suffix_node(*(node_symbol_ptr + 1), node_symbol_ptr + 1 - start_symbol_ptr,\r\n      next_string_node_num_ptr);\r\n  node_ptr-\u003esibling_node_num[*(in_symbol_ptr + 1) \u0026 1] = *next_string_node_num_ptr;\r\n  (void)create_suffix_node(*(in_symbol_ptr + 1), in_symbol_ptr + 1 - start_symbol_ptr, next_string_node_num_ptr);\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":382,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3308208":{"score":0.888068,"function_name":"word_build_lcp_thread","code":"void *word_build_lcp_thread(void *arg) {\r\n  struct word_lcp_thread_data * thread_data_ptr = (struct word_lcp_thread_data *)arg;\r\n  uint32_t next_string_node_num = thread_data_ptr-\u003efirst_string_node_num;\r\n  uint8_t local_write_index;\r\n  uint8_t local_read_index = 0;\r\n\r\n  while (1) {\r\n    while ((local_write_index = (uint8_t)atomic_load_explicit(\u0026thread_data_ptr-\u003ewrite_index, memory_order_acquire))\r\n        == local_read_index)\r\n      sched_yield();\r\n    do {\r\n      if (thread_data_ptr-\u003estart_positions[local_read_index] \u003c 0)\r\n        return(0);\r\n      add_word_suffix(start_symbol_ptr + thread_data_ptr-\u003estart_positions[local_read_index], \u0026next_string_node_num);\r\n      atomic_store_explicit(\u0026thread_data_ptr-\u003eread_index, ++local_read_index, memory_order_relaxed);\r\n    } while (local_read_index != local_write_index);\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":735,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3308368":{"score":0.83239186,"function_name":"add_suffix","code":"void add_suffix(uint32_t first_symbol, uint32_t *in_symbol_ptr, uint32_t *next_string_node_num_ptr) {\r\n  struct string_node * node_ptr;\r\n  uint32_t node_start_index;\r\n  uint32_t start_index = in_symbol_ptr - start_symbol_ptr - 1;\r\n  uint32_t search_symbol = *in_symbol_ptr;\r\n  int32_t * base_node_child_num_ptr\r\n      = \u0026base_string_nodes_child_node_num[first_symbol * BASE_NODES_CHILD_ARRAY_SIZE + (search_symbol \u0026 0xF)];\r\n  if (*base_node_child_num_ptr == 0) { // first occurence of the symbol, so create a child\r\n    *base_node_child_num_ptr = start_index + 1 - 0x80000000;\r\n    return;\r\n  }\r\n  if (*base_node_child_num_ptr \u003c 0) {\r\n    uint32_t symbol_index = *base_node_child_num_ptr + 0x80000000;\r\n    uint32_t old_symbol = *(start_symbol_ptr + symbol_index);\r\n    *base_node_child_num_ptr = *next_string_node_num_ptr;\r\n    node_ptr = create_suffix_node(old_symbol, symbol_index, next_string_node_num_ptr);\r\n    if (search_symbol != old_symbol) {\r\n      node_ptr-\u003esibling_node_num[(search_symbol \u003e\u003e 4) \u0026 1] = start_index + 1 - 0x80000000;\r\n      return;\r\n    }\r\n    // Matching node without child - extend branch, add child for previous instance, add child sibling\r\n    uint32_t * node_symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n    if (*(node_symbol_ptr + 1) == *(in_symbol_ptr + 1)) {\r\n      uint32_t length = 2;\r\n      while ((*(node_symbol_ptr + length) == *(in_symbol_ptr + length)) \u0026\u0026 (length \u003c MAX_MATCH_LENGTH - 1))\r\n        length++;\r\n      node_ptr-\u003enum_extra_symbols = length - 1;\r\n      if (node_ptr-\u003elast_match_index + length \u003c= start_index) {\r\n        node_ptr-\u003elast_match_index = start_index + 1;\r\n        node_ptr-\u003einstances = 2;\r\n      }\r\n      else if (node_ptr-\u003elast_match_index \u003c start_index)\r\n        node_ptr = split_node_for_overlap(node_ptr, start_index, start_index + 1, next_string_node_num_ptr);\r\n      node_ptr-\u003echild_node_num = *next_string_node_num_ptr;\r\n      node_ptr = create_suffix_node(*(node_symbol_ptr + length), node_symbol_ptr + length - start_symbol_ptr,\r\n          next_string_node_num_ptr);\r\n      node_ptr-\u003esibling_node_num[*(in_symbol_ptr + length) \u0026 1] = start_index + 1 + length - 0x80000000;\r\n    }\r\n    else {\r\n      if (node_ptr-\u003elast_match_index \u003c start_index) {\r\n        node_ptr-\u003elast_match_index = start_index + 1;\r\n        node_ptr-\u003einstances = 2;\r\n      }\r\n      node_ptr-\u003echild_node_num = *next_string_node_num_ptr;\r\n      node_ptr = create_suffix_node(*(node_symbol_ptr + 1), node_symbol_ptr + 1 - start_symbol_ptr,\r\n          next_string_node_num_ptr);\r\n      node_ptr-\u003esibling_node_num[*(in_symbol_ptr + 1) \u0026 1] = start_index + 2 - 0x80000000;\r\n    }\r\n    return;\r\n  }\r\n\r\n  node_start_index = start_index + 1;\r\n  node_ptr = \u0026string_nodes[*base_node_child_num_ptr];\r\n  if (search_symbol != node_ptr-\u003esymbol) {  // follow siblings until match found or end of siblings found\r\n    uint32_t shifted_search_symbol = search_symbol \u003e\u003e 4;\r\n    do {\r\n      int32_t * sibling_node_num_ptr = \u0026node_ptr-\u003esibling_node_num[shifted_search_symbol \u0026 1];\r\n      if (*sibling_node_num_ptr == 0) { // no match so add sibling\r\n        *sibling_node_num_ptr = node_start_index - 0x80000000;\r\n        return;\r\n      }\r\n      if (*sibling_node_num_ptr \u003c 0) { // turn the sibling into a node\r\n        uint32_t symbol_index = *sibling_node_num_ptr + 0x80000000;\r\n        *sibling_node_num_ptr = *next_string_node_num_ptr;\r\n        node_ptr = create_suffix_node(*(start_symbol_ptr + symbol_index), symbol_index, next_string_node_num_ptr);\r\n        if (search_symbol != node_ptr-\u003esymbol) {\r\n          node_ptr-\u003esibling_node_num[(shifted_search_symbol \u003e\u003e 1) \u0026 1] = node_start_index - 0x80000000;\r\n          return;\r\n        }\r\n        // Matching node without child - extend branch, add child for previous instance, add child sibling\r\n        uint32_t * node_symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n        if (*(node_symbol_ptr + 1) == *(in_symbol_ptr + 1)) {\r\n          uint32_t length = 2;\r\n          while ((*(node_symbol_ptr + length) == *(in_symbol_ptr + length)) \u0026\u0026 (length \u003c MAX_MATCH_LENGTH - 1))\r\n            length++;\r\n          node_ptr-\u003enum_extra_symbols = length - 1;\r\n          if (node_ptr-\u003elast_match_index + length \u003c= start_index) {\r\n            node_ptr-\u003elast_match_index = node_start_index;\r\n            node_ptr-\u003einstances = 2;\r\n          }\r\n          else if (node_ptr-\u003elast_match_index \u003c start_index)\r\n            node_ptr = split_node_for_overlap(node_ptr, start_index, node_start_index, next_string_node_num_ptr);\r\n          node_ptr-\u003echild_node_num = *next_string_node_num_ptr;\r\n          node_ptr = create_suffix_node(*(node_symbol_ptr + length), node_symbol_ptr + length - start_symbol_ptr,\r\n              next_string_node_num_ptr);\r\n          node_ptr-\u003esibling_node_num[*(in_symbol_ptr + length) \u0026 1] = node_start_index + length - 0x80000000;\r\n        }\r\n        else {\r\n          if (node_ptr-\u003elast_match_index \u003c start_index) {\r\n            node_ptr-\u003elast_match_index = node_start_index;\r\n            node_ptr-\u003einstances = 2;\r\n          }\r\n          node_ptr-\u003echild_node_num = *next_string_node_num_ptr;\r\n          node_ptr = create_suffix_node(*(node_symbol_ptr + 1), node_symbol_ptr + 1 - start_symbol_ptr,\r\n              next_string_node_num_ptr);\r\n          node_ptr-\u003esibling_node_num[*(in_symbol_ptr + 1) \u0026 1] = start_index + 2 - 0x80000000;\r\n        }\r\n        return;\r\n      }\r\n      node_ptr = \u0026string_nodes[*sibling_node_num_ptr];\r\n      shifted_search_symbol = shifted_search_symbol \u003e\u003e 1;\r\n    } while (search_symbol != node_ptr-\u003esymbol);\r\n  }\r\n\r\n  // found a matching sibling\r\n  while (node_ptr-\u003echild_node_num != 0) {\r\n    // matching sibling with child so check length of match\r\n    uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n    if (num_extra_symbols != 0) {\r\n      uint32_t * node_symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n      uint32_t length = 1;\r\n      do {\r\n        if (*(node_symbol_ptr + length) != *(in_symbol_ptr + length)) { // insert node in branch\r\n          struct string_node * new_node_ptr = \u0026string_nodes[*next_string_node_num_ptr];\r\n          uint32_t new_node_lmi = node_ptr-\u003elast_match_index + length;\r\n          new_node_ptr-\u003elast_match_index = new_node_lmi;\r\n          new_node_ptr-\u003esymbol = *(node_symbol_ptr + length);\r\n          new_node_ptr-\u003esibling_node_num[0] = 0;\r\n          new_node_ptr-\u003esibling_node_num[1] = 0;\r\n          new_node_ptr-\u003echild_node_num = node_ptr-\u003echild_node_num;\r\n          new_node_ptr-\u003enum_extra_symbols = num_extra_symbols - length;\r\n          new_node_ptr-\u003einstances = node_ptr-\u003einstances;\r\n          node_ptr-\u003enum_extra_symbols = length - 1;\r\n          node_ptr-\u003echild_node_num = (*next_string_node_num_ptr)++;\r\n          new_node_ptr-\u003esibling_node_num[(*(in_symbol_ptr + length)) \u0026 1] = node_start_index + length - 0x80000000;\r\n          if (new_node_lmi \u003c= start_index) {\r\n            node_ptr-\u003elast_match_index = node_start_index;\r\n            node_ptr-\u003einstances++;\r\n          }\r\n          else if (node_ptr-\u003elast_match_index \u003c start_index)\r\n            (void)split_node_for_overlap(node_ptr, start_index, node_start_index, next_string_node_num_ptr);\r\n          return;\r\n        }\r\n      } while (length++ != num_extra_symbols);\r\n    }\r\n    if (node_ptr-\u003elast_match_index + num_extra_symbols \u003c start_index) {\r\n      node_ptr-\u003elast_match_index = node_start_index;\r\n      node_ptr-\u003einstances++;\r\n    }\r\n    else if (node_ptr-\u003elast_match_index \u003c start_index)\r\n      node_ptr = split_node_for_overlap(node_ptr, start_index, node_start_index, next_string_node_num_ptr);\r\n\r\n    in_symbol_ptr += num_extra_symbols + 1;\r\n    node_start_index += num_extra_symbols + 1;\r\n    search_symbol = *in_symbol_ptr;\r\n    node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    if (search_symbol != node_ptr-\u003esymbol) { // follow siblings until match found or end of siblings found\r\n      uint32_t shifted_search_symbol = search_symbol;\r\n      do {\r\n        int32_t * prior_node_num_ptr = \u0026node_ptr-\u003esibling_node_num[shifted_search_symbol \u0026 1];\r\n        if (*prior_node_num_ptr == 0) {\r\n          *prior_node_num_ptr = node_start_index - 0x80000000;\r\n          return;\r\n        }\r\n        if (*prior_node_num_ptr \u003c 0) { // turn the sibling into a node\r\n          uint32_t symbol_index = *prior_node_num_ptr + 0x80000000;\r\n          *prior_node_num_ptr = *next_string_node_num_ptr;\r\n          node_ptr = create_suffix_node(*(start_symbol_ptr + symbol_index), symbol_index, next_string_node_num_ptr);\r\n          if (search_symbol == node_ptr-\u003esymbol)\r\n            break;\r\n          node_ptr-\u003esibling_node_num[(shifted_search_symbol \u003e\u003e 1) \u0026 1] = node_start_index - 0x80000000;\r\n          return;\r\n        }\r\n        node_ptr = \u0026string_nodes[*prior_node_num_ptr];\r\n        shifted_search_symbol \u003e\u003e= 1;\r\n      } while (search_symbol != node_ptr-\u003esymbol);\r\n    }\r\n  }\r\n\r\n  // Matching node without child - extend branch, add child for previous instance, add child sibling\r\n  uint32_t * node_symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n  if (*(node_symbol_ptr + 1) == *(in_symbol_ptr + 1)) {\r\n    int32_t max_length = start_index + MAX_MATCH_LENGTH - 1 - node_start_index;\r\n    if (max_length \u003e 0) {\r\n      int32_t length = 2;\r\n      while ((*(node_symbol_ptr + length) == *(in_symbol_ptr + length)) \u0026\u0026 (length \u003c= max_length))\r\n        length++;\r\n      node_ptr-\u003enum_extra_symbols = length - 1;\r\n      if (node_ptr-\u003elast_match_index + length \u003c= start_index) {\r\n        node_ptr-\u003elast_match_index = node_start_index;\r\n        node_ptr-\u003einstances = 2;\r\n      }\r\n      else if (node_ptr-\u003elast_match_index \u003c start_index)\r\n        node_ptr = split_node_for_overlap(node_ptr, start_index, node_start_index, next_string_node_num_ptr);\r\n      node_ptr-\u003echild_node_num = *next_string_node_num_ptr;\r\n      node_ptr = create_suffix_node(*(node_symbol_ptr + length), node_symbol_ptr + length - start_symbol_ptr,\r\n          next_string_node_num_ptr);\r\n      node_ptr-\u003esibling_node_num[*(in_symbol_ptr + length) \u0026 1] = node_start_index + length - 0x80000000;\r\n      return;\r\n    }\r\n  }\r\n  if (node_ptr-\u003elast_match_index \u003c start_index) {\r\n    node_ptr-\u003elast_match_index = node_start_index;\r\n    node_ptr-\u003einstances = 2;\r\n  }\r\n  node_ptr-\u003echild_node_num = *next_string_node_num_ptr;\r\n  node_ptr = create_suffix_node(*(node_symbol_ptr + 1), node_symbol_ptr + 1 - start_symbol_ptr,\r\n      next_string_node_num_ptr);\r\n  node_ptr-\u003esibling_node_num[*(in_symbol_ptr + 1) \u0026 1] = node_start_index + 1 - 0x80000000;\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":490,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3310480":{"score":0.8938691,"function_name":"build_lcp_thread","code":"void *build_lcp_thread(void *arg) {\r\n  struct lcp_thread_data * thread_data_ptr = (struct lcp_thread_data *)arg;\r\n  uint32_t * in_symbol_ptr = thread_data_ptr-\u003estart_cycle_symbol_ptr;\r\n  uint32_t min_symbol = thread_data_ptr-\u003emin_symbol;\r\n  uint32_t max_symbol = thread_data_ptr-\u003emax_symbol;\r\n  uint32_t next_string_node_num = thread_data_ptr-\u003efirst_string_node_num;\r\n  uint32_t string_node_num_limit = thread_data_ptr-\u003estring_nodes_limit - 10;\r\n  int32_t * base_string_nodes_child_node_num = thread_data_ptr-\u003ebase_string_nodes_child_node_num;\r\n\r\n  int32_t * base_node_child_num_ptr = base_string_nodes_child_node_num + min_symbol * BASE_NODES_CHILD_ARRAY_SIZE;\r\n  while (base_node_child_num_ptr\r\n      \u003c= base_string_nodes_child_node_num + max_symbol * BASE_NODES_CHILD_ARRAY_SIZE) {\r\n    *((uint64_t *)base_node_child_num_ptr) = 0;\r\n    *((uint64_t *)base_node_child_num_ptr + 1) = 0;\r\n    *((uint64_t *)base_node_child_num_ptr + 2) = 0;\r\n    *((uint64_t *)base_node_child_num_ptr + 3) = 0;\r\n    *((uint64_t *)base_node_child_num_ptr + 4) = 0;\r\n    *((uint64_t *)base_node_child_num_ptr + 5) = 0;\r\n    *((uint64_t *)base_node_child_num_ptr + 6) = 0;\r\n    *((uint64_t *)base_node_child_num_ptr + 7) = 0;\r\n    base_node_child_num_ptr += BASE_NODES_CHILD_ARRAY_SIZE;\r\n  }\r\n\r\n  while ((uint32_t *)atomic_load_explicit(\u0026max_symbol_ptr, memory_order_relaxed) != in_symbol_ptr) {\r\n    uint32_t * local_scan_symbol_ptr = (uint32_t *)atomic_load_explicit(\u0026scan_symbol_ptr, memory_order_relaxed);\r\n    if (in_symbol_ptr == local_scan_symbol_ptr)\r\n      sched_yield();\r\n    else {\r\n      do {\r\n        uint32_t symbol = *in_symbol_ptr++;\r\n        if (((symbol \u003e= min_symbol) \u0026\u0026 (symbol \u003c= max_symbol)) \u0026\u0026 ((int32_t)*in_symbol_ptr \u003e= 0)) {\r\n          add_suffix(symbol, in_symbol_ptr, \u0026next_string_node_num);\r\n          if (next_string_node_num \u003e= string_node_num_limit)\r\n            return(0);\r\n        }\r\n      } while (in_symbol_ptr != local_scan_symbol_ptr);\r\n    }\r\n  }\r\n  return(0);\r\n}","filepath":"glza/GLZAcompress.c","line_number":693,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3310784":{"score":0.8051977,"function_name":"score_base_node_tree","code":"void score_base_node_tree(struct string_node *node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double profit_ratio_power, double log2_num_symbols_plus_substitution_cost,\r\n    double *log2_instances,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data *rank_scores_buffer,\r\n    float order_ratio, uint16_t *node_ptrs_num_ptr, uint8_t UTF8_compliant, uint32_t prior_symbol) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double string_entropy2 = string_entropy;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].string_entropy2 = string_entropy2;\r\n      node_data[level].prior_symbol = prior_symbol;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      uint32_t num_extra_symbols = 0;\r\n      double repeats = (double)(node_instances - 1);\r\n\r\n      string_entropy += symbol_entropy[symbol];\r\n      string_entropy2 += log2(((double)num_ends[symbol_ends[prior_symbol].end] - 0.5 * repeats)\r\n            * (double)num_starts[symbol_ends[symbol].start]\r\n          / (((double)o1c[symbol_ends[prior_symbol].end][symbol_ends[symbol].start] - 0.5 * repeats)\r\n            * (double)symbol_counts[symbol]));\r\n\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols) {\r\n        prior_symbol = symbol;\r\n        symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + ++num_extra_symbols);\r\n        string_entropy += symbol_entropy[symbol];\r\n        string_entropy2 += log2(((double)num_ends[symbol_ends[prior_symbol].end] - 0.5 * repeats)\r\n              * (double)num_starts[symbol_ends[symbol].start]\r\n            / (((double)o1c[symbol_ends[prior_symbol].end][symbol_ends[symbol].start] - 0.5 * repeats)\r\n              * (double)symbol_counts[symbol]));\r\n      }\r\n      prior_symbol = symbol;\r\n\r\n      // calculate score\r\n      double profit_per_substitution, profit_per_substitution2;\r\n      if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS) {\r\n        profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        profit_per_substitution2 = string_entropy2 + log2_instances[node_instances - 1] - log_file_symbols;\r\n      }\r\n      else {\r\n        double log2_repeats = log2(repeats);\r\n        profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2_repeats);\r\n        profit_per_substitution2 = string_entropy2 + log2_repeats - log_file_symbols;\r\n      }\r\n      double total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n      double total_bit_savings_minus_production_cost2 = repeats * profit_per_substitution2 - production_cost;\r\n\r\n      float o0_score;\r\n      if (total_bit_savings_minus_production_cost \u003e 0.0) {\r\n        double profit_ratio = profit_per_substitution / string_entropy;\r\n        o0_score = (float)(total_bit_savings_minus_production_cost * pow(profit_ratio, profit_ratio_power));\r\n      }\r\n      else\r\n        o0_score = total_bit_savings_minus_production_cost;\r\n      double profit_ratio2 = profit_per_substitution2 / string_entropy2;\r\n      float o1_score = (float)(total_bit_savings_minus_production_cost2 * pow(profit_ratio2, profit_ratio_power));\r\n      if ((UTF8_compliant != 0) \u0026\u0026 (symbol == 0x20)) {\r\n        o0_score *= 0.2;\r\n        o1_score *= 0.1;\r\n      }\r\n      if ((o0_score \u003e 0.0) \u0026\u0026 (o1_score \u003e 0.0))\r\n        o0_score = pow(o0_score, 1.0 - order_ratio) * pow(o1_score, order_ratio);\r\n      else\r\n        o0_score = 0.0;\r\n\r\n      if (o0_score \u003e min_score) {\r\n        struct string_node * child_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n        uint32_t new_score_lmi1 = child_ptr-\u003elast_match_index - 1;\r\n        uint32_t new_score_lmi2 = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n        if (new_score_lmi1 == new_score_lmi2) {\r\n          int32_t * sibling_node_num_ptr = \u0026child_ptr-\u003esibling_node_num[0];\r\n          if (*sibling_node_num_ptr \u003e 0)\r\n            new_score_lmi1 = string_nodes[*sibling_node_num_ptr].last_match_index - 1;\r\n          else if (*sibling_node_num_ptr != 0)\r\n            new_score_lmi1 = *sibling_node_num_ptr + 0x7FFFFFFF;\r\n          else if (*(sibling_node_num_ptr + 1) \u003e 0)\r\n            new_score_lmi1 = string_nodes[*(sibling_node_num_ptr + 1)].last_match_index - 1;\r\n          else if (*(sibling_node_num_ptr + 1) != 0)\r\n            new_score_lmi1 = *(sibling_node_num_ptr + 1) + 0x7FFFFFFF;\r\n        }\r\n        if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n          while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n              \u003e= 0xF000) /* wait */ ;\r\n        rank_scores_buffer[node_ptrs_num].score = o0_score;\r\n        rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi1;\r\n        rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi2;\r\n        rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n        atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n      }\r\n\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level].string_entropy2 = string_entropy2;\r\n          node_data[level].prior_symbol = prior_symbol;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          string_entropy2 = node_data[level].string_entropy2;\r\n          prior_symbol = node_data[level].prior_symbol;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":1260,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3312992":{"score":0.8220725,"function_name":"score_base_node_tree_fast","code":"void score_base_node_tree_fast(struct string_node *node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double profit_ratio_power, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data_fast *rank_scores_buffer,\r\n    uint16_t *node_ptrs_num_ptr, uint8_t UTF8_compliant, uint32_t prior_symbol) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  float max_parent_score = 0.0;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].max_parent_score = max_parent_score;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      string_entropy += symbol_entropy[symbol];\r\n      uint32_t num_extra_symbols = 0;\r\n      double repeats = (double)(node_instances - 1);\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols) {\r\n        symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + ++num_extra_symbols);\r\n        string_entropy += symbol_entropy[symbol];\r\n      }\r\n      // calculate score\r\n      double profit_per_substitution;\r\n      if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n        profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n      else\r\n        profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n      if (profit_per_substitution \u003e= 0.0) {\r\n        double total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e 0.0) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * pow(profit_ratio, profit_ratio_power));\r\n          if ((UTF8_compliant != 0) \u0026\u0026 (symbol == 0x20))\r\n            score *= 0.2;\r\n          if ((score \u003e min_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            uint32_t new_score_lmi = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = new_score_lmi;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].max_parent_score = max_parent_score;\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          max_parent_score = node_data[level].max_parent_score;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":1414,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3314224":{"score":0.87368983,"function_name":"score_base_node_tree_cap_fast","code":"void score_base_node_tree_cap_fast(struct string_node *node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double profit_ratio_power, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data_fast *rank_scores_buffer,\r\n    uint16_t *node_ptrs_num_ptr) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double profit_per_substitution, total_bit_savings_minus_production_cost;\r\n  float max_parent_score = 0.0;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      double repeats = (double)(node_instances - 1);\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].max_parent_score = max_parent_score;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n      if (num_extra_symbols == 0) {\r\n        string_entropy += symbol_entropy[symbol];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e min_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * pow(profit_ratio, profit_ratio_power));\r\n          if (symbol == 0x20)\r\n            score *= 0.2;\r\n          else if ((symbol \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e min_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n              max_parent_score = score;\r\n            uint32_t new_score_lmi = node_ptr-\u003elast_match_index;\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = new_score_lmi;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        uint32_t * symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n        uint32_t * end_symbol_ptr = symbol_ptr + num_extra_symbols;\r\n        uint8_t send_score = 0;\r\n        float score;\r\n        float short_score = min_score;\r\n\r\n        while (symbol_ptr \u003c end_symbol_ptr)\r\n          string_entropy += symbol_entropy[*symbol_ptr++];\r\n\r\n        if ((*symbol_ptr == 0x20) \u0026\u0026 (*(symbol_ptr - 1) != 0x20)) {\r\n          // calculate score\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n          if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n            double profit_ratio = profit_per_substitution / (string_entropy + symbol_entropy[0x20]);\r\n            score = 0.5 * (float)(total_bit_savings_minus_production_cost * pow(profit_ratio, profit_ratio_power));\r\n            if (score \u003e short_score) {\r\n              short_score = score;\r\n              if (score \u003e max_parent_score) {\r\n                max_parent_score = score;\r\n                send_score = 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        string_entropy += symbol_entropy[*symbol_ptr];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          score = (float)(total_bit_savings_minus_production_cost * pow(profit_ratio, profit_ratio_power));\r\n          if (*symbol_ptr == 0x20)\r\n            score *= 0.2;\r\n          else if (((*symbol_ptr) \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e short_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            send_score = 2;\r\n          }\r\n        }\r\n        if (send_score != 0) {\r\n          uint32_t new_score_lmi = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n          if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n            while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                \u003e= 0xF000); // wait\r\n          if (send_score == 2) {\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = new_score_lmi;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n          }\r\n          else {\r\n            rank_scores_buffer[node_ptrs_num].score = short_score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = new_score_lmi - 1;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n          }\r\n          atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n             \u0026\u0026((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].max_parent_score = max_parent_score;\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          max_parent_score = node_data[level].max_parent_score;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":1808,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3318544":{"score":0.8625674,"function_name":"score_base_node_tree_cap_prp1_fast","code":"void score_base_node_tree_cap_prp1_fast(struct string_node* node_ptr, struct score_data *node_data,\r\n    double string_entropy, double production_cost, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data_fast *rank_scores_buffer,\r\n    uint16_t *node_ptrs_num_ptr) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double profit_per_substitution, total_bit_savings_minus_production_cost;\r\n  float max_parent_score = 0.0;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      double repeats = (double)(node_instances - 1);\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].max_parent_score = max_parent_score;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n      if (num_extra_symbols == 0) {\r\n        string_entropy += symbol_entropy[symbol];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e min_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (symbol == 0x20)\r\n            score *= 0.2;\r\n          else if ((symbol \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e min_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        uint32_t * symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n        uint32_t * end_symbol_ptr = symbol_ptr + num_extra_symbols;\r\n        uint8_t send_score = 0;\r\n        float score;\r\n        float short_score = min_score;\r\n\r\n        while (symbol_ptr \u003c end_symbol_ptr)\r\n          string_entropy += symbol_entropy[*symbol_ptr++];\r\n\r\n        if ((*symbol_ptr == 0x20) \u0026\u0026 (*(symbol_ptr - 1) != 0x20)) {\r\n          // calculate score\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n          if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n            double profit_ratio = profit_per_substitution / (string_entropy + symbol_entropy[0x20]);\r\n            score = 0.5 * (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n            if (score \u003e short_score) {\r\n              short_score = score;\r\n              if (score \u003e max_parent_score) {\r\n                max_parent_score = score;\r\n                send_score = 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        string_entropy += symbol_entropy[*symbol_ptr];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (*symbol_ptr == 0x20)\r\n            score *= 0.2;\r\n          else if (((*symbol_ptr) \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e short_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            send_score = 2;\r\n          }\r\n        }\r\n        if (send_score != 0) {\r\n          if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n            while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                \u003e= 0xF000); // wait\r\n          if (send_score == 2) {\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n          else {\r\n            rank_scores_buffer[node_ptrs_num].score = short_score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols - 1;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n             \u0026\u0026((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].max_parent_score = max_parent_score;\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          max_parent_score = node_data[level].max_parent_score;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2949,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3320800":{"score":0.87448907,"function_name":"score_base_node_tree_cap_prp1_fast","code":"void score_base_node_tree_cap_prp1_fast(struct string_node* node_ptr, struct score_data *node_data,\r\n    double string_entropy, double production_cost, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data_fast *rank_scores_buffer,\r\n    uint16_t *node_ptrs_num_ptr) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double profit_per_substitution, total_bit_savings_minus_production_cost;\r\n  float max_parent_score = 0.0;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      double repeats = (double)(node_instances - 1);\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].max_parent_score = max_parent_score;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n      if (num_extra_symbols == 0) {\r\n        string_entropy += symbol_entropy[symbol];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e min_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (symbol == 0x20)\r\n            score *= 0.2;\r\n          else if ((symbol \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e min_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        uint32_t * symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n        uint32_t * end_symbol_ptr = symbol_ptr + num_extra_symbols;\r\n        uint8_t send_score = 0;\r\n        float score;\r\n        float short_score = min_score;\r\n\r\n        while (symbol_ptr \u003c end_symbol_ptr)\r\n          string_entropy += symbol_entropy[*symbol_ptr++];\r\n\r\n        if ((*symbol_ptr == 0x20) \u0026\u0026 (*(symbol_ptr - 1) != 0x20)) {\r\n          // calculate score\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n          if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n            double profit_ratio = profit_per_substitution / (string_entropy + symbol_entropy[0x20]);\r\n            score = 0.5 * (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n            if (score \u003e short_score) {\r\n              short_score = score;\r\n              if (score \u003e max_parent_score) {\r\n                max_parent_score = score;\r\n                send_score = 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        string_entropy += symbol_entropy[*symbol_ptr];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (*symbol_ptr == 0x20)\r\n            score *= 0.2;\r\n          else if (((*symbol_ptr) \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e short_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            send_score = 2;\r\n          }\r\n        }\r\n        if (send_score != 0) {\r\n          if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n            while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                \u003e= 0xF000); // wait\r\n          if (send_score == 2) {\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n          else {\r\n            rank_scores_buffer[node_ptrs_num].score = short_score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols - 1;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n             \u0026\u0026((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].max_parent_score = max_parent_score;\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          max_parent_score = node_data[level].max_parent_score;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2949,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3323072":{"score":0.7938629,"function_name":"score_base_node_tree_prp2","code":"void score_base_node_tree_prp2(struct string_node* node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double log2_num_symbols_plus_substitution_cost, double *new_symbol_cost,\r\n    double *symbol_entropy, struct node_score_data *rank_scores_buffer, uint16_t *node_ptrs_num_ptr,\r\n    uint8_t UTF8_compliant) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      node_data[level].string_entropy = string_entropy;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      string_entropy += symbol_entropy[symbol];\r\n      uint32_t num_extra_symbols = 0;\r\n      double repeats = (double)(node_instances - 1);\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols) {\r\n        symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + ++num_extra_symbols);\r\n        string_entropy += symbol_entropy[symbol];\r\n      }\r\n      // calculate score\r\n      double profit_per_substitution;\r\n      if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n        profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n      else\r\n        profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n      if (profit_per_substitution \u003e= 0.0) {\r\n        double total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e 0.0) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio * profit_ratio);\r\n          if ((UTF8_compliant != 0) \u0026\u0026 (symbol == 0x20))\r\n            score *= 0.2;\r\n          if (score \u003e min_score) {\r\n            struct string_node * child_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n            uint32_t new_score_lmi1 = child_ptr-\u003elast_match_index - 1;\r\n            uint32_t new_score_lmi2 = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            if (new_score_lmi1 == new_score_lmi2) {\r\n              int32_t * sibling_node_num_ptr = \u0026child_ptr-\u003esibling_node_num[0];\r\n              if (*sibling_node_num_ptr \u003e 0)\r\n                new_score_lmi1 = string_nodes[*sibling_node_num_ptr].last_match_index - 1;\r\n              else if (*sibling_node_num_ptr != 0)\r\n                new_score_lmi1 = *sibling_node_num_ptr + 0x7FFFFFFF;\r\n              else if (*(sibling_node_num_ptr + 1) \u003e 0)\r\n                new_score_lmi1 = string_nodes[*(sibling_node_num_ptr + 1)].last_match_index - 1;\r\n              else if (*(sibling_node_num_ptr + 1) != 0)\r\n                new_score_lmi1 = *(sibling_node_num_ptr + 1) + 0x7FFFFFFF;\r\n            }\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            if (new_score_lmi1 \u003c new_score_lmi2) {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi1;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi2;\r\n            }\r\n            else {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi2;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi1;\r\n            }\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2186,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3324352":{"score":0.87515575,"function_name":"score_base_node_tree_cap_prp1_fast","code":"void score_base_node_tree_cap_prp1_fast(struct string_node* node_ptr, struct score_data *node_data,\r\n    double string_entropy, double production_cost, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data_fast *rank_scores_buffer,\r\n    uint16_t *node_ptrs_num_ptr) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double profit_per_substitution, total_bit_savings_minus_production_cost;\r\n  float max_parent_score = 0.0;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      double repeats = (double)(node_instances - 1);\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].max_parent_score = max_parent_score;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n      if (num_extra_symbols == 0) {\r\n        string_entropy += symbol_entropy[symbol];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e min_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (symbol == 0x20)\r\n            score *= 0.2;\r\n          else if ((symbol \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e min_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        uint32_t * symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n        uint32_t * end_symbol_ptr = symbol_ptr + num_extra_symbols;\r\n        uint8_t send_score = 0;\r\n        float score;\r\n        float short_score = min_score;\r\n\r\n        while (symbol_ptr \u003c end_symbol_ptr)\r\n          string_entropy += symbol_entropy[*symbol_ptr++];\r\n\r\n        if ((*symbol_ptr == 0x20) \u0026\u0026 (*(symbol_ptr - 1) != 0x20)) {\r\n          // calculate score\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n          if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n            double profit_ratio = profit_per_substitution / (string_entropy + symbol_entropy[0x20]);\r\n            score = 0.5 * (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n            if (score \u003e short_score) {\r\n              short_score = score;\r\n              if (score \u003e max_parent_score) {\r\n                max_parent_score = score;\r\n                send_score = 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        string_entropy += symbol_entropy[*symbol_ptr];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (*symbol_ptr == 0x20)\r\n            score *= 0.2;\r\n          else if (((*symbol_ptr) \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e short_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            send_score = 2;\r\n          }\r\n        }\r\n        if (send_score != 0) {\r\n          if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n            while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                \u003e= 0xF000); // wait\r\n          if (send_score == 2) {\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n          else {\r\n            rank_scores_buffer[node_ptrs_num].score = short_score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols - 1;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n             \u0026\u0026((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].max_parent_score = max_parent_score;\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          max_parent_score = node_data[level].max_parent_score;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2949,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3326624":{"score":0.8091198,"function_name":"score_base_node_tree_prp2","code":"void score_base_node_tree_prp2(struct string_node* node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double log2_num_symbols_plus_substitution_cost, double *new_symbol_cost,\r\n    double *symbol_entropy, struct node_score_data *rank_scores_buffer, uint16_t *node_ptrs_num_ptr,\r\n    uint8_t UTF8_compliant) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      node_data[level].string_entropy = string_entropy;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      string_entropy += symbol_entropy[symbol];\r\n      uint32_t num_extra_symbols = 0;\r\n      double repeats = (double)(node_instances - 1);\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols) {\r\n        symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + ++num_extra_symbols);\r\n        string_entropy += symbol_entropy[symbol];\r\n      }\r\n      // calculate score\r\n      double profit_per_substitution;\r\n      if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n        profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n      else\r\n        profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n      if (profit_per_substitution \u003e= 0.0) {\r\n        double total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e 0.0) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio * profit_ratio);\r\n          if ((UTF8_compliant != 0) \u0026\u0026 (symbol == 0x20))\r\n            score *= 0.2;\r\n          if (score \u003e min_score) {\r\n            struct string_node * child_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n            uint32_t new_score_lmi1 = child_ptr-\u003elast_match_index - 1;\r\n            uint32_t new_score_lmi2 = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            if (new_score_lmi1 == new_score_lmi2) {\r\n              int32_t * sibling_node_num_ptr = \u0026child_ptr-\u003esibling_node_num[0];\r\n              if (*sibling_node_num_ptr \u003e 0)\r\n                new_score_lmi1 = string_nodes[*sibling_node_num_ptr].last_match_index - 1;\r\n              else if (*sibling_node_num_ptr != 0)\r\n                new_score_lmi1 = *sibling_node_num_ptr + 0x7FFFFFFF;\r\n              else if (*(sibling_node_num_ptr + 1) \u003e 0)\r\n                new_score_lmi1 = string_nodes[*(sibling_node_num_ptr + 1)].last_match_index - 1;\r\n              else if (*(sibling_node_num_ptr + 1) != 0)\r\n                new_score_lmi1 = *(sibling_node_num_ptr + 1) + 0x7FFFFFFF;\r\n            }\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            if (new_score_lmi1 \u003c new_score_lmi2) {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi1;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi2;\r\n            }\r\n            else {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi2;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi1;\r\n            }\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2186,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3327904":{"score":0.80749464,"function_name":"score_base_node_tree_prp2","code":"void score_base_node_tree_prp2(struct string_node* node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double log2_num_symbols_plus_substitution_cost, double *new_symbol_cost,\r\n    double *symbol_entropy, struct node_score_data *rank_scores_buffer, uint16_t *node_ptrs_num_ptr,\r\n    uint8_t UTF8_compliant) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      node_data[level].string_entropy = string_entropy;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      string_entropy += symbol_entropy[symbol];\r\n      uint32_t num_extra_symbols = 0;\r\n      double repeats = (double)(node_instances - 1);\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols) {\r\n        symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + ++num_extra_symbols);\r\n        string_entropy += symbol_entropy[symbol];\r\n      }\r\n      // calculate score\r\n      double profit_per_substitution;\r\n      if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n        profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n      else\r\n        profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n      if (profit_per_substitution \u003e= 0.0) {\r\n        double total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e 0.0) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio * profit_ratio);\r\n          if ((UTF8_compliant != 0) \u0026\u0026 (symbol == 0x20))\r\n            score *= 0.2;\r\n          if (score \u003e min_score) {\r\n            struct string_node * child_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n            uint32_t new_score_lmi1 = child_ptr-\u003elast_match_index - 1;\r\n            uint32_t new_score_lmi2 = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            if (new_score_lmi1 == new_score_lmi2) {\r\n              int32_t * sibling_node_num_ptr = \u0026child_ptr-\u003esibling_node_num[0];\r\n              if (*sibling_node_num_ptr \u003e 0)\r\n                new_score_lmi1 = string_nodes[*sibling_node_num_ptr].last_match_index - 1;\r\n              else if (*sibling_node_num_ptr != 0)\r\n                new_score_lmi1 = *sibling_node_num_ptr + 0x7FFFFFFF;\r\n              else if (*(sibling_node_num_ptr + 1) \u003e 0)\r\n                new_score_lmi1 = string_nodes[*(sibling_node_num_ptr + 1)].last_match_index - 1;\r\n              else if (*(sibling_node_num_ptr + 1) != 0)\r\n                new_score_lmi1 = *(sibling_node_num_ptr + 1) + 0x7FFFFFFF;\r\n            }\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            if (new_score_lmi1 \u003c new_score_lmi2) {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi1;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi2;\r\n            }\r\n            else {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi2;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi1;\r\n            }\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2186,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3329040":{"score":0.8702275,"function_name":"score_base_node_tree_cap_prp1_fast","code":"void score_base_node_tree_cap_prp1_fast(struct string_node* node_ptr, struct score_data *node_data,\r\n    double string_entropy, double production_cost, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data_fast *rank_scores_buffer,\r\n    uint16_t *node_ptrs_num_ptr) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double profit_per_substitution, total_bit_savings_minus_production_cost;\r\n  float max_parent_score = 0.0;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      double repeats = (double)(node_instances - 1);\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].max_parent_score = max_parent_score;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n      if (num_extra_symbols == 0) {\r\n        string_entropy += symbol_entropy[symbol];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e min_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (symbol == 0x20)\r\n            score *= 0.2;\r\n          else if ((symbol \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e min_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        uint32_t * symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n        uint32_t * end_symbol_ptr = symbol_ptr + num_extra_symbols;\r\n        uint8_t send_score = 0;\r\n        float score;\r\n        float short_score = min_score;\r\n\r\n        while (symbol_ptr \u003c end_symbol_ptr)\r\n          string_entropy += symbol_entropy[*symbol_ptr++];\r\n\r\n        if ((*symbol_ptr == 0x20) \u0026\u0026 (*(symbol_ptr - 1) != 0x20)) {\r\n          // calculate score\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n          if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n            double profit_ratio = profit_per_substitution / (string_entropy + symbol_entropy[0x20]);\r\n            score = 0.5 * (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n            if (score \u003e short_score) {\r\n              short_score = score;\r\n              if (score \u003e max_parent_score) {\r\n                max_parent_score = score;\r\n                send_score = 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        string_entropy += symbol_entropy[*symbol_ptr];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (*symbol_ptr == 0x20)\r\n            score *= 0.2;\r\n          else if (((*symbol_ptr) \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e short_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            send_score = 2;\r\n          }\r\n        }\r\n        if (send_score != 0) {\r\n          if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n            while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                \u003e= 0xF000); // wait\r\n          if (send_score == 2) {\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n          else {\r\n            rank_scores_buffer[node_ptrs_num].score = short_score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols - 1;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n             \u0026\u0026((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].max_parent_score = max_parent_score;\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          max_parent_score = node_data[level].max_parent_score;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2949,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3331344":{"score":0.8866333,"function_name":"score_base_node_tree_cap_prp1_fast","code":"void score_base_node_tree_cap_prp1_fast(struct string_node* node_ptr, struct score_data *node_data,\r\n    double string_entropy, double production_cost, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy, struct node_score_data_fast *rank_scores_buffer,\r\n    uint16_t *node_ptrs_num_ptr) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double profit_per_substitution, total_bit_savings_minus_production_cost;\r\n  float max_parent_score = 0.0;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      double repeats = (double)(node_instances - 1);\r\n      node_data[level].string_entropy = string_entropy;\r\n      node_data[level].max_parent_score = max_parent_score;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      uint32_t num_extra_symbols = node_ptr-\u003enum_extra_symbols;\r\n      if (num_extra_symbols == 0) {\r\n        string_entropy += symbol_entropy[symbol];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e min_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          float score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (symbol == 0x20)\r\n            score *= 0.2;\r\n          else if ((symbol \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e min_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        uint32_t * symbol_ptr = start_symbol_ptr + node_ptr-\u003elast_match_index;\r\n        uint32_t * end_symbol_ptr = symbol_ptr + num_extra_symbols;\r\n        uint8_t send_score = 0;\r\n        float score;\r\n        float short_score = min_score;\r\n\r\n        while (symbol_ptr \u003c end_symbol_ptr)\r\n          string_entropy += symbol_entropy[*symbol_ptr++];\r\n\r\n        if ((*symbol_ptr == 0x20) \u0026\u0026 (*(symbol_ptr - 1) != 0x20)) {\r\n          // calculate score\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n          if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n            double profit_ratio = profit_per_substitution / (string_entropy + symbol_entropy[0x20]);\r\n            score = 0.5 * (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n            if (score \u003e short_score) {\r\n              short_score = score;\r\n              if (score \u003e max_parent_score) {\r\n                max_parent_score = score;\r\n                send_score = 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        string_entropy += symbol_entropy[*symbol_ptr];\r\n        // calculate score\r\n        if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n          profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n        else\r\n          profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n        total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e short_score) {\r\n          double profit_ratio = profit_per_substitution / string_entropy;\r\n          score = (float)(total_bit_savings_minus_production_cost * profit_ratio);\r\n          if (*symbol_ptr == 0x20)\r\n            score *= 0.2;\r\n          else if (((*symbol_ptr) \u0026 0xF2) != 0x42)\r\n            score *= 0.5;\r\n          if ((score \u003e short_score) \u0026\u0026 (score \u003e max_parent_score)) {\r\n            max_parent_score = score;\r\n            send_score = 2;\r\n          }\r\n        }\r\n        if (send_score != 0) {\r\n          if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n            while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                \u003e= 0xF000); // wait\r\n          if (send_score == 2) {\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n          else {\r\n            rank_scores_buffer[node_ptrs_num].score = short_score;\r\n            rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols - 1;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n             \u0026\u0026((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].max_parent_score = max_parent_score;\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          max_parent_score = node_data[level].max_parent_score;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":2949,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3333376":{"score":0.8308878,"function_name":"score_base_node_tree_prp0","code":"void score_base_node_tree_prp0(struct string_node* node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double log2_num_symbols_plus_substitution_cost, double *new_symbol_cost,\r\n    double *symbol_entropy, struct node_score_data *rank_scores_buffer, uint16_t *node_ptrs_num_ptr,\r\n    uint8_t UTF8_compliant) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      node_data[level].string_entropy = string_entropy;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      string_entropy += symbol_entropy[symbol];\r\n      uint32_t num_extra_symbols = 0;\r\n      double repeats = (double)(node_instances - 1);\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols) {\r\n        symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + ++num_extra_symbols);\r\n        string_entropy += symbol_entropy[symbol];\r\n      }\r\n      // calculate score\r\n      double profit_per_substitution;\r\n      if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n        profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n      else\r\n        profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n      if (profit_per_substitution \u003e= 0.0) {\r\n        double total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e 0.0) {\r\n          float score = (float)total_bit_savings_minus_production_cost;\r\n          if ((UTF8_compliant != 0) \u0026\u0026 (symbol == 0x20))\r\n            score *= 0.2;\r\n          if (score \u003e min_score) {\r\n            struct string_node * child_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n            uint32_t new_score_lmi1 = child_ptr-\u003elast_match_index - 1;\r\n            uint32_t new_score_lmi2 = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            if (new_score_lmi1 == new_score_lmi2) {\r\n              int32_t * sibling_node_num_ptr = \u0026child_ptr-\u003esibling_node_num[0];\r\n              if (*sibling_node_num_ptr \u003e 0)\r\n                new_score_lmi1 = string_nodes[*sibling_node_num_ptr].last_match_index - 1;\r\n              else if (*sibling_node_num_ptr != 0)\r\n                new_score_lmi1 = *sibling_node_num_ptr + 0x7FFFFFFF;\r\n              else if (*(sibling_node_num_ptr + 1) \u003e 0)\r\n                new_score_lmi1 = string_nodes[*(sibling_node_num_ptr + 1)].last_match_index - 1;\r\n              else if (*(sibling_node_num_ptr + 1) != 0)\r\n                new_score_lmi1 = *(sibling_node_num_ptr + 1) + 0x7FFFFFFF;\r\n            }\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            if (new_score_lmi1 \u003c new_score_lmi2) {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi1;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi2;\r\n            }\r\n            else {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi2;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi1;\r\n            }\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":3119,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3334640":{"score":0.82092893,"function_name":"score_base_node_tree_prp0","code":"void score_base_node_tree_prp0(struct string_node* node_ptr, struct score_data *node_data, double string_entropy,\r\n    double production_cost, double log2_num_symbols_plus_substitution_cost, double *new_symbol_cost,\r\n    double *symbol_entropy, struct node_score_data *rank_scores_buffer, uint16_t *node_ptrs_num_ptr,\r\n    uint8_t UTF8_compliant) {\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    if (node_instances \u003e= 2)  {\r\n      node_data[level].string_entropy = string_entropy;\r\n      uint32_t symbol = node_ptr-\u003esymbol;\r\n      string_entropy += symbol_entropy[symbol];\r\n      uint32_t num_extra_symbols = 0;\r\n      double repeats = (double)(node_instances - 1);\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols) {\r\n        symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + ++num_extra_symbols);\r\n        string_entropy += symbol_entropy[symbol];\r\n      }\r\n      // calculate score\r\n      double profit_per_substitution;\r\n      if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n        profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n      else\r\n        profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n      if (profit_per_substitution \u003e= 0.0) {\r\n        double total_bit_savings_minus_production_cost = repeats * profit_per_substitution - production_cost;\r\n        if (total_bit_savings_minus_production_cost \u003e 0.0) {\r\n          float score = (float)total_bit_savings_minus_production_cost;\r\n          if ((UTF8_compliant != 0) \u0026\u0026 (symbol == 0x20))\r\n            score *= 0.2;\r\n          if (score \u003e min_score) {\r\n            struct string_node * child_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n            uint32_t new_score_lmi1 = child_ptr-\u003elast_match_index - 1;\r\n            uint32_t new_score_lmi2 = node_ptr-\u003elast_match_index + num_extra_symbols;\r\n            if (new_score_lmi1 == new_score_lmi2) {\r\n              int32_t * sibling_node_num_ptr = \u0026child_ptr-\u003esibling_node_num[0];\r\n              if (*sibling_node_num_ptr \u003e 0)\r\n                new_score_lmi1 = string_nodes[*sibling_node_num_ptr].last_match_index - 1;\r\n              else if (*sibling_node_num_ptr != 0)\r\n                new_score_lmi1 = *sibling_node_num_ptr + 0x7FFFFFFF;\r\n              else if (*(sibling_node_num_ptr + 1) \u003e 0)\r\n                new_score_lmi1 = string_nodes[*(sibling_node_num_ptr + 1)].last_match_index - 1;\r\n              else if (*(sibling_node_num_ptr + 1) != 0)\r\n                new_score_lmi1 = *(sibling_node_num_ptr + 1) + 0x7FFFFFFF;\r\n            }\r\n            if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n              while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                  \u003e= 0xF000) /* wait */ ;\r\n            rank_scores_buffer[node_ptrs_num].score = score;\r\n            rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols;\r\n            if (new_score_lmi1 \u003c new_score_lmi2) {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi1;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi2;\r\n            }\r\n            else {\r\n              rank_scores_buffer[node_ptrs_num].last_match_index1 = new_score_lmi2;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index2 = new_score_lmi1;\r\n            }\r\n            atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n          }\r\n        }\r\n      }\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\n      int32_t sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level].string_entropy = string_entropy;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        tnp = \u0026string_nodes[sib_node_num];\r\n        if ((sib_node_num \u003e 0)\r\n            \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0)))\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":3119,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3335760":{"score":0.86972725,"function_name":"score_base_node_tree_words_fast","code":"void score_base_node_tree_words_fast(struct string_node* node_ptr, struct score_data *node_data, double production_cost,\r\n    double log2_num_symbols_plus_substitution_cost, double *new_symbol_cost, double *symbol_entropy,\r\n    struct node_score_data_fast *rank_scores_buffer, uint16_t *node_ptrs_num_ptr) {\r\n  int32_t sib_node_num;\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double string_entropy = symbol_entropy[0x20];\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    node_data[level].string_entropy = string_entropy;\r\n    if (node_instances \u003e= 2) {\r\n      uint32_t num_extra_symbols = 0;\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols)\r\n        string_entropy += symbol_entropy[*(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols++)];\r\n      if (*(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols) == 0x20) {\r\n        // calculate score\r\n        uint32_t last_symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols - 1);\r\n        if (((last_symbol \u003e= (uint32_t)'a') \u0026\u0026 (last_symbol \u003c= (uint32_t)'z'))\r\n            || ((last_symbol \u003e= (uint32_t)'0') \u0026\u0026 (last_symbol \u003c= (uint32_t)'9')) || (last_symbol \u003e= 0x80)) {\r\n          double repeats = (double)(node_instances - 1);\r\n          double profit_per_substitution;\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          if (profit_per_substitution \u003e= 0.0) {\r\n            float score = (float)(repeats * profit_per_substitution - production_cost);\r\n            if (score \u003e min_score) {\r\n              if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n                while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                    \u003e= 0xF000) /* wait */ ;\r\n              rank_scores_buffer[node_ptrs_num].score = score;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols - 1;\r\n              rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n              atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n            }\r\n          }\r\n        }\r\n        goto score_siblings;\r\n      }\r\n      string_entropy += symbol_entropy[*(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols)];\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\nscore_siblings:\r\n      sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        if (sib_node_num \u003e 0)\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":3441,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3336816":{"score":0.86029136,"function_name":"score_base_node_tree_words_fast","code":"void score_base_node_tree_words_fast(struct string_node* node_ptr, struct score_data *node_data, double production_cost,\r\n    double log2_num_symbols_plus_substitution_cost, double *new_symbol_cost, double *symbol_entropy,\r\n    struct node_score_data_fast *rank_scores_buffer, uint16_t *node_ptrs_num_ptr) {\r\n  int32_t sib_node_num;\r\n  uint16_t num_symbols = 2;\r\n  uint16_t level = 0;\r\n  uint16_t node_ptrs_num = *node_ptrs_num_ptr;\r\n  double string_entropy = symbol_entropy[0x20];\r\n\r\n  while (1) {\r\n    uint32_t node_instances = node_ptr-\u003einstances;\r\n    node_data[level].string_entropy = string_entropy;\r\n    if (node_instances \u003e= 2) {\r\n      uint32_t num_extra_symbols = 0;\r\n      while (num_extra_symbols != node_ptr-\u003enum_extra_symbols)\r\n        string_entropy += symbol_entropy[*(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols++)];\r\n      if (*(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols) == 0x20) {\r\n        // calculate score\r\n        uint32_t last_symbol = *(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols - 1);\r\n        if (((last_symbol \u003e= (uint32_t)'a') \u0026\u0026 (last_symbol \u003c= (uint32_t)'z'))\r\n            || ((last_symbol \u003e= (uint32_t)'0') \u0026\u0026 (last_symbol \u003c= (uint32_t)'9')) || (last_symbol \u003e= 0x80)) {\r\n          double repeats = (double)(node_instances - 1);\r\n          double profit_per_substitution;\r\n          if (node_instances \u003c NUM_PRECALCULATED_SYMBOL_COSTS)\r\n            profit_per_substitution = string_entropy - new_symbol_cost[node_instances];\r\n          else\r\n            profit_per_substitution = string_entropy - (log2_num_symbols_plus_substitution_cost - log2(repeats));\r\n          if (profit_per_substitution \u003e= 0.0) {\r\n            float score = (float)(repeats * profit_per_substitution - production_cost);\r\n            if (score \u003e min_score) {\r\n              if ((node_ptrs_num \u0026 0xFFF) == 0)\r\n                while ((uint16_t)(node_ptrs_num - atomic_load_explicit(\u0026rank_scores_read_index, memory_order_acquire))\r\n                    \u003e= 0xF000) /* wait */ ;\r\n              rank_scores_buffer[node_ptrs_num].score = score;\r\n              rank_scores_buffer[node_ptrs_num].last_match_index = node_ptr-\u003elast_match_index + num_extra_symbols - 1;\r\n              rank_scores_buffer[node_ptrs_num].num_symbols = num_symbols + num_extra_symbols - 1;\r\n              atomic_store_explicit(\u0026rank_scores_write_index, ++node_ptrs_num, memory_order_release);\r\n            }\r\n          }\r\n        }\r\n        goto score_siblings;\r\n      }\r\n      string_entropy += symbol_entropy[*(start_symbol_ptr + node_ptr-\u003elast_match_index + num_extra_symbols)];\r\n      if (node_ptr-\u003esibling_node_num[0] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 0;\r\n      }\r\n      else if (node_ptr-\u003esibling_node_num[1] \u003e 0) {\r\n        node_data[level].node_ptr = node_ptr;\r\n        node_data[level].num_symbols = num_symbols;\r\n        node_data[level++].next_sibling = 1;\r\n      }\r\n      num_symbols += num_extra_symbols + 1;\r\n      node_ptr = \u0026string_nodes[node_ptr-\u003echild_node_num];\r\n    }\r\n    else {\r\nscore_siblings:\r\n      sib_node_num = node_ptr-\u003esibling_node_num[0];\r\n      struct string_node * tnp = \u0026string_nodes[sib_node_num];\r\n      if ((sib_node_num \u003e 0)\r\n          \u0026\u0026 ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n        tnp = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        if ((node_ptr-\u003esibling_node_num[1] \u003e 0) \u0026\u0026\r\n            ((tnp-\u003einstances \u003e 1) || (tnp-\u003esibling_node_num[0] \u003e 0) || (tnp-\u003esibling_node_num[1] \u003e 0))) {\r\n          node_data[level].node_ptr = node_ptr;\r\n          node_data[level].num_symbols = num_symbols;\r\n          node_data[level++].next_sibling = 1;\r\n        }\r\n        node_ptr = \u0026string_nodes[sib_node_num];\r\n      }\r\n      else {\r\n        sib_node_num = node_ptr-\u003esibling_node_num[1];\r\n        if (sib_node_num \u003e 0)\r\n          node_ptr = \u0026string_nodes[sib_node_num];\r\n        else {\r\n          if (level == 0) {\r\n            *node_ptrs_num_ptr = node_ptrs_num;\r\n            return;\r\n          }\r\n          string_entropy = node_data[--level].string_entropy;\r\n          num_symbols = node_data[level].num_symbols;\r\n          node_ptr = node_data[level].node_ptr;\r\n          if (node_data[level].next_sibling == 0) {\r\n            if (node_ptr-\u003esibling_node_num[1] \u003e 0)\r\n              node_data[level++].next_sibling = 1;\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[0]];\r\n          }\r\n          else\r\n            node_ptr = \u0026string_nodes[node_ptr-\u003esibling_node_num[1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAcompress.c","line_number":3441,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3337872":{"score":0.8080637,"function_name":"score_symbol_tree","code":"void score_symbol_tree(uint32_t min_symbol, uint32_t max_symbol, struct node_score_data *rank_scores_buffer,\r\n    struct score_data *node_data, uint16_t *node_ptrs_num_ptr, double production_cost, double profit_ratio_power,\r\n    double log2_num_symbols_plus_substitution_cost, double *log2_instances, double *new_symbol_cost, double *symbol_entropy,\r\n    float order_ratio, uint8_t cap_encoded, uint8_t UTF8_compliant, uint32_t * symbol_counts) {\r\n  int32_t * next_base_node_child_num_ptr;\r\n  int32_t * base_node_child_num_ptr = \u0026base_string_nodes_child_node_num[min_symbol * BASE_NODES_CHILD_ARRAY_SIZE];\r\n  uint32_t symbol = min_symbol;\r\n  if (cap_encoded != 0) {\r\n    if ((profit_ratio_power == 3.0) \u0026\u0026 (order_ratio == 0.0)) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_cap_prp3(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else if ((profit_ratio_power == 2.0) \u0026\u0026 (order_ratio == 0.0)) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_cap_prp2(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else if ((profit_ratio_power == 1.0) \u0026\u0026 (order_ratio == 0.0)) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_cap_prp1(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_cap(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, profit_ratio_power, log2_num_symbols_plus_substitution_cost, log2_instances,\r\n                  new_symbol_cost, symbol_entropy, rank_scores_buffer, order_ratio, node_ptrs_num_ptr, symbol);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    if ((profit_ratio_power == 2.0) \u0026\u0026 (order_ratio == 0.0)) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_prp2(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr, UTF8_compliant);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else if ((profit_ratio_power == 1.0) \u0026\u0026 (order_ratio == 0.0)) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_prp1(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr, UTF8_compliant);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else if ((profit_ratio_power == 0.0) \u0026\u0026 (order_ratio == 0.0)) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_prp0(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr, UTF8_compliant);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, profit_ratio_power, log2_num_symbols_plus_substitution_cost, log2_instances,\r\n                  new_symbol_cost, symbol_entropy, rank_scores_buffer, order_ratio, node_ptrs_num_ptr, UTF8_compliant,\r\n                  symbol);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":3538,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3340112":{"score":0.8435738,"function_name":"score_symbol_tree_fast","code":"void score_symbol_tree_fast(uint32_t min_symbol, uint32_t max_symbol, struct node_score_data_fast *rank_scores_buffer,\r\n    struct score_data *node_data, uint16_t *node_ptrs_num_ptr, double production_cost, double profit_ratio_power,\r\n    double log2_num_symbols_plus_substitution_cost, double *log2_instances, double *new_symbol_cost, double *symbol_entropy,\r\n    uint8_t cap_encoded, uint8_t UTF8_compliant, uint32_t * symbol_counts) {\r\n  int32_t * next_base_node_child_num_ptr;\r\n  int32_t * base_node_child_num_ptr = \u0026base_string_nodes_child_node_num[min_symbol * BASE_NODES_CHILD_ARRAY_SIZE];\r\n  uint32_t symbol = min_symbol;\r\n  if (cap_encoded != 0) {\r\n    if (profit_ratio_power == 1.0) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_cap_prp1_fast(\u0026string_nodes[*base_node_child_num_ptr], node_data,\r\n                  symbol_entropy[symbol], production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost,\r\n                  symbol_entropy, rank_scores_buffer, node_ptrs_num_ptr);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_cap_fast(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, profit_ratio_power, log2_num_symbols_plus_substitution_cost, new_symbol_cost,\r\n                  symbol_entropy, rank_scores_buffer, node_ptrs_num_ptr);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    if (profit_ratio_power == 1.0) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_prp1_fast(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr, UTF8_compliant);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else if (profit_ratio_power == 0.0) {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_prp0_fast(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy,\r\n                  rank_scores_buffer, node_ptrs_num_ptr, UTF8_compliant);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n    else {\r\n      while (symbol \u003c= max_symbol) {\r\n        if (symbol_counts[symbol] \u003e 1) {\r\n          next_base_node_child_num_ptr = base_node_child_num_ptr + BASE_NODES_CHILD_ARRAY_SIZE;\r\n          do {\r\n            if (*base_node_child_num_ptr \u003e 0)\r\n              score_base_node_tree_fast(\u0026string_nodes[*base_node_child_num_ptr], node_data, symbol_entropy[symbol],\r\n                  production_cost, profit_ratio_power, log2_num_symbols_plus_substitution_cost, new_symbol_cost,\r\n                  symbol_entropy, rank_scores_buffer, node_ptrs_num_ptr, UTF8_compliant, symbol);\r\n            base_node_child_num_ptr++;\r\n          } while (base_node_child_num_ptr != next_base_node_child_num_ptr);\r\n        }\r\n        else\r\n          base_node_child_num_ptr += 16;\r\n        symbol++;\r\n      }\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":3690,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3341488":{"score":0.6749124,"function_name":"score_symbol_tree_words_fast","code":"void score_symbol_tree_words_fast(struct node_score_data_fast *rank_scores_buffer, struct score_data *node_data,\r\n    uint16_t *node_ptrs_num_ptr, double production_cost, double log2_num_symbols_plus_substitution_cost,\r\n    double *new_symbol_cost, double *symbol_entropy) {\r\n  int32_t * base_node_child_num_ptr = \u0026base_string_nodes_child_node_num[0];\r\n  int32_t * base_node_child_num_end_ptr = \u0026base_string_nodes_child_node_num[0x90 + BASE_NODES_CHILD_ARRAY_SIZE];\r\n  do {\r\n    int32_t base_node = *base_node_child_num_ptr++;\r\n    if (base_node \u003e 0)\r\n      score_base_node_tree_words_fast(\u0026string_nodes[base_node], node_data, production_cost,\r\n          log2_num_symbols_plus_substitution_cost, new_symbol_cost, symbol_entropy, rank_scores_buffer,\r\n          node_ptrs_num_ptr);\r\n  } while (base_node_child_num_ptr != base_node_child_num_end_ptr);\r\n  return;\r\n}","filepath":"glza/GLZAcompress.c","line_number":3806,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3341808":{"score":0.63386595,"function_name":"GLZAencode","code":"uint8_t GLZAencode(size_t in_size, uint8_t * inbuf, size_t * outsize_ptr, uint8_t * outbuf, FILE * fd, size_t file_size,\r\n    struct param_data * params) {\r\n  const uint8_t INSERT_SYMBOL_CHAR = 0xFE;\r\n  const uint8_t DEFINE_SYMBOL_CHAR = 0xFF;\r\n  const size_t WRITE_SIZE = 0x40000;\r\n  uint8_t temp_char, base_bits, format, verbose, code_length, increase_length, decrease_length;\r\n  uint8_t *in_char_ptr, *end_char_ptr;\r\n  uint16_t queue_position;\r\n  uint32_t i, j, k, num_symbols_defined, num_definitions_to_code, grammar_size, dictionary_size;\r\n  uint32_t num_more_than_15_inst_definitions, num_greater_500, num_transmits_over_sqrt2, num_mtfs;\r\n  uint32_t UTF8_value, max_UTF8_value, symbol, symbol_inst, prior_repeats, next_symbol;\r\n  uint32_t min_ranked_symbols, ranked_symbols_save, num_new_symbols, num_symbols_to_code, num_rules_reversed;\r\n  uint32_t code_length_limit, mtf_miss_code_space, min_code_space, rules_reduced;\r\n  uint32_t mtf_started[MAX_INSTANCES_FOR_REMOVE + 1], mtf_hits[MAX_INSTANCES_FOR_REMOVE + 1];\r\n  uint32_t mtf_peak[MAX_INSTANCES_FOR_REMOVE + 1], mtf_peak_mtf[MAX_INSTANCES_FOR_REMOVE + 1];\r\n  uint32_t mtf_in_dictionary[MAX_INSTANCES_FOR_REMOVE + 1], mtf_active[MAX_INSTANCES_FOR_REMOVE + 1];\r\n  uint32_t *symbol_ptr, *symbol2_ptr, *symbol_array2, *end_symbol_ptr, *first_define_ptr, *max_ptr;\r\n  uint32_t *ranked_symbols, *ranked_symbols2, *ranked_symbols_ptr, *ranked_symbols2_ptr, *end_ranked_symbols_ptr;\r\n  uint32_t *min_ranked_symbols_ptr, *max_ranked_symbols_ptr, *min_one_instance_ranked_symbols_ptr, *peak_array;\r\n  int32_t remaining_symbols_to_code, remaining_code_space, max_len_adj_profit;\r\n  int32_t index_last_length[26], index_first_length[26];\r\n  double symbol_inst_factor, codes_per_code_space;\r\n\r\n\r\n  verbose = cap_encoded = UTF8_compliant = num_symbols_defined = 0;\r\n  first_define_ptr = 0;\r\n  base_bits = 8;\r\n  use_mtf = 2;\r\n  if (params != 0) {\r\n    verbose = params-\u003eprint_dictionary;\r\n    use_mtf = params-\u003euse_mtf;\r\n  }\r\n  in_char_ptr = inbuf;\r\n  end_char_ptr = inbuf + in_size;\r\n  format = *in_char_ptr++;\r\n  if ((format \u0026 0x81) == 1) {\r\n    cap_encoded = (format \u003e\u003e 1) \u0026 1;\r\n    UTF8_compliant = (format \u003e\u003e 2) \u0026 1;\r\n    format = 1;\r\n    if (UTF8_compliant != 0) {\r\n      base_bits = *in_char_ptr++;\r\n      max_UTF8_value = 0x7F;\r\n    }\r\n  }\r\n\r\n  if ((symbol_array = (uint32_t *)malloc(sizeof(uint32_t) * in_size)) == 0) {\r\n    fprintf(stderr, \"Symbol memory allocation failed\\n\");\r\n    return(0);\r\n  }\r\n  symbol_ptr = symbol_array;\r\n\r\n  if (UTF8_compliant != 0) {\r\n    num_base_symbols = 1 \u003c\u003c base_bits;\r\n    while (in_char_ptr \u003c end_char_ptr) {\r\n      temp_char = *in_char_ptr++;\r\n      if (temp_char == INSERT_SYMBOL_CHAR) {\r\n        symbol = num_base_symbols;\r\n        symbol += 0x10000 * (uint32_t)*in_char_ptr++;\r\n        symbol += 0x100 * (uint32_t)*in_char_ptr++;\r\n        symbol += (uint32_t)*in_char_ptr++;\r\n        *symbol_ptr++ = symbol;\r\n      }\r\n      else if (temp_char == DEFINE_SYMBOL_CHAR) {\r\n        if (first_define_ptr == 0)\r\n          first_define_ptr = symbol_ptr;\r\n        in_char_ptr += 3;\r\n        *symbol_ptr++ = 0x80000000 + num_symbols_defined++;\r\n      }\r\n      else if (temp_char \u003c START_UTF8_2BYTE_SYMBOLS)\r\n        *symbol_ptr++ = (uint32_t)temp_char;\r\n      else {\r\n        if (temp_char \u003e= 0xF0) { // 4 byte UTF-8 character\r\n          UTF8_value = 0x40000 * (temp_char \u0026 7);\r\n          UTF8_value += 0x1000 * (*in_char_ptr++ \u0026 0x3F);\r\n          UTF8_value += 0x40 * (*in_char_ptr++ \u0026 0x3F);\r\n        }\r\n        else if (temp_char \u003e= 0xE0) { // 3 byte UTF-8 character\r\n          UTF8_value = 0x1000 * (temp_char \u0026 0xF);\r\n          UTF8_value += 0x40 * (*in_char_ptr++ \u0026 0x3F);\r\n        }\r\n        else // 2 byte UTF-8 character\r\n          UTF8_value = 0x40 * (temp_char \u0026 0x1F);\r\n        UTF8_value += *in_char_ptr++ \u0026 0x3F;\r\n        *symbol_ptr++ = UTF8_value;\r\n        if (UTF8_value \u003e max_UTF8_value)\r\n          max_UTF8_value = UTF8_value;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    num_base_symbols = 0x100;\r\n    while (in_char_ptr \u003c end_char_ptr) {\r\n      temp_char = *in_char_ptr++;\r\n      if (temp_char \u003c INSERT_SYMBOL_CHAR)\r\n        *symbol_ptr++ = (uint32_t)temp_char;\r\n      else if (*in_char_ptr == DEFINE_SYMBOL_CHAR) {\r\n        *symbol_ptr++ = (uint32_t)temp_char;\r\n        in_char_ptr++;\r\n      }\r\n      else if (temp_char == INSERT_SYMBOL_CHAR) {\r\n        symbol = num_base_symbols;\r\n        symbol += 0x10000 * (uint32_t)*in_char_ptr++;\r\n        symbol += 0x100 * (uint32_t)*in_char_ptr++;\r\n        symbol += (uint32_t)*in_char_ptr++;\r\n        *symbol_ptr++ = symbol;\r\n      }\r\n      else {\r\n        if (first_define_ptr == 0)\r\n          first_define_ptr = symbol_ptr;\r\n        in_char_ptr += 3;\r\n        *symbol_ptr++ = 0x80000000 + num_symbols_defined++;\r\n      }\r\n    }\r\n  }\r\n\r\n  end_symbol_ptr = symbol_ptr;\r\n  *end_symbol_ptr = UNIQUE_SYMBOL;\r\n  num_codes = num_base_symbols + num_symbols_defined;\r\n  grammar_size = symbol_ptr - symbol_array;\r\n  if (first_define_ptr == 0)\r\n    first_define_ptr = symbol_ptr;\r\n\r\n  if ((0 == (symbol_array2 = (uint32_t *)malloc(sizeof(uint32_t) * (end_symbol_ptr - symbol_array))))\r\n      || (0 == (sd = (struct symbol_data *)malloc(sizeof(struct symbol_data) * (num_codes + 1))))\r\n      || (0 == (ranked_symbols = (uint32_t *)malloc(sizeof(uint32_t) * num_codes)))\r\n      || (0 == (ranked_symbols2 = (uint32_t *)malloc(sizeof(uint32_t) * num_codes)))\r\n      || (0 == (transmits = (struct transmit_symbols *)malloc(sizeof(struct transmit_symbols) * grammar_size)))) {\r\n    fprintf(stderr, \"Memory allocation failed\\n\");\r\n    return(0);\r\n  }\r\n\r\n  // count the number of instances of each symbol\r\n  for (i = 0 ; i \u003c num_codes ; i++)\r\n    sd[i].count = 0;\r\n  symbol_ptr = symbol_array;\r\n  while (symbol_ptr != end_symbol_ptr) {\r\n    symbol = *symbol_ptr++;\r\n    if ((int32_t)symbol \u003e= 0)\r\n      sd[symbol].count++;\r\n    else\r\n      sd[symbol - 0x80000000 + num_base_symbols].define_symbol_start_index = symbol_ptr - symbol_array;\r\n  }\r\n  sd[num_codes].define_symbol_start_index = symbol_ptr - symbol_array + 1;\r\n\r\n  if (cap_encoded != 0) {\r\n    i = 0;\r\n    do {\r\n      sd[i++].type = 0;\r\n    } while (i != 0x61);\r\n    do {\r\n      sd[i++].type = 1;\r\n    } while (i != 0x7B);\r\n    do {\r\n      sd[i++].type = 0;\r\n    } while (i != num_base_symbols);\r\n    sd[' '].type = 4;\r\n    sd['B'].type = 0x24;\r\n    sd['C'].type = 0x24;\r\n    while (i \u003c num_codes) {\r\n      next_symbol = symbol_array[sd[i].define_symbol_start_index];\r\n      while (next_symbol \u003e i)\r\n        next_symbol = symbol_array[sd[next_symbol].define_symbol_start_index];\r\n      sd[i].type = sd[next_symbol].type \u0026 1;\r\n      next_symbol = symbol_array[sd[i + 1].define_symbol_start_index - 2];\r\n      while (next_symbol \u003e i)\r\n        next_symbol = symbol_array[sd[next_symbol + 1].define_symbol_start_index - 2];\r\n      sd[i++].type |= sd[next_symbol].type \u0026 0x20;\r\n    }\r\n  }\r\n  else {\r\n    i = 0;\r\n    while (i \u003c num_codes)\r\n      sd[i++].type = 0;\r\n  }\r\n\r\n  ranked_symbols_ptr = ranked_symbols;\r\n  for (i = 0 ; i \u003c num_codes ; i++)\r\n    if (sd[i].count != 0)\r\n      *ranked_symbols_ptr++ = i;\r\n  end_ranked_symbols_ptr = ranked_symbols_ptr;\r\n  min_ranked_symbols_ptr = ranked_symbols_ptr;\r\n\r\n  // move single instance symbols to the end of the sorted symbols array\r\n  rules_reduced = 0;\r\n  ranked_symbols_ptr = ranked_symbols;\r\n  while (ranked_symbols_ptr \u003c min_ranked_symbols_ptr) {\r\n    if (sd[*ranked_symbols_ptr].count == 1) { // move this symbol to the top of the moved to end 1 instance symbols\r\n      ranked_symbols_save = *ranked_symbols_ptr;\r\n      if (ranked_symbols_save \u003e= num_base_symbols)\r\n        rules_reduced++;\r\n      *ranked_symbols_ptr = *--min_ranked_symbols_ptr;\r\n      *min_ranked_symbols_ptr = ranked_symbols_save;\r\n    }\r\n    else\r\n      ranked_symbols_ptr++;\r\n  }\r\n  min_one_instance_ranked_symbols_ptr = min_ranked_symbols_ptr;\r\n\r\n#ifdef PRINTON\r\n  double order_0_entropy = 0.0;\r\n  double log_file_symbols = log2((double)grammar_size);\r\n  i = 0;\r\n  do {\r\n    if (sd[i].count != 0) {\r\n      double d_symbol_count = (double)sd[i].count;\r\n      order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n    }\r\n  } while (++i \u003c num_base_symbols);\r\n  if (num_symbols_defined != 0) {\r\n    while (i \u003c num_codes) {\r\n      double d_symbol_count = (double)sd[i++].count;\r\n      order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n    }\r\n    double d_symbol_count = (double)num_symbols_defined;\r\n    order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n  }\r\n  fprintf(stderr, \"%u syms, dict. size %u, %.4f bits/sym, o0e %.2lf bytes\\n\",\r\n      (unsigned int)grammar_size, (unsigned int)num_symbols_defined,\r\n      (float)(order_0_entropy / (double)grammar_size), 0.125 * order_0_entropy);\r\n#endif\r\n\r\n  grammar_size -= 2 * rules_reduced;\r\n\r\n#ifdef PRINTON\r\n  if (rules_reduced != 0) {\r\n    order_0_entropy = 0.0;\r\n    log_file_symbols = log2((double)grammar_size);\r\n    i = 0;\r\n    do {\r\n      if (sd[i].count != 0) {\r\n        double d_symbol_count = (double)sd[i].count;\r\n        order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n      }\r\n    } while (++i \u003c num_base_symbols);\r\n    if (num_symbols_defined != 0) {\r\n      while (i \u003c num_codes) {\r\n        if (sd[i].count \u003e 1) {\r\n          double d_symbol_count = (double)sd[i].count;\r\n          order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n        }\r\n        i++;\r\n      }\r\n      double d_symbol_count = (double)(num_symbols_defined - rules_reduced);\r\n      order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n    }\r\n    fprintf(stderr, \"Eliminated %u single appearance grammar rules\\n\", rules_reduced);\r\n    fprintf(stderr, \"%u syms, dict. size %u, %.4f bits/sym, o0e %.2lf bytes\\n\",\r\n        (unsigned int)grammar_size, (unsigned int)(num_symbols_defined - rules_reduced),\r\n        (float)(order_0_entropy/(double)grammar_size), 0.125 * order_0_entropy);\r\n  }\r\n\r\n  uint32_t len_counts[16];\r\n  uint32_t extra_len_bits = 0;\r\n  for (i = 0 ; i \u003c 16 ; i++)\r\n    len_counts[i] = 0;\r\n  for (i = num_base_symbols ; i \u003c num_codes ; i++) {\r\n    if (sd[i].count \u003e 1) {\r\n      uint32_t dl = sd[i + 1].define_symbol_start_index - sd[i].define_symbol_start_index - 1;\r\n      if (dl \u003c 16)\r\n        len_counts[dl - 1]++;\r\n      else {\r\n        len_counts[15]++;\r\n        uint32_t extra_len = dl - 14;\r\n        do {\r\n          extra_len \u003e\u003e= 1;\r\n          extra_len_bits += 2;\r\n        } while (extra_len != 0);\r\n      }\r\n    }\r\n  }\r\n#endif\r\n\r\n  grammar_size -= num_symbols_defined - rules_reduced;\r\n  num_new_symbols = end_ranked_symbols_ptr - ranked_symbols - rules_reduced;\r\n\r\n#ifdef PRINTON\r\n  order_0_entropy = 0.0;\r\n  log_file_symbols = log2((double)grammar_size);\r\n  i = 0;\r\n  do {\r\n    if (sd[i].count != 0) {\r\n      double d_symbol_count = (double)sd[i].count;\r\n      order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n    }\r\n  } while (++i \u003c num_base_symbols);\r\n  if (num_symbols_defined != 0) {\r\n    while (i \u003c num_codes) {\r\n      if (sd[i].count \u003e 1) {\r\n        double d_symbol_count = (double)(sd[i].count - 1);\r\n        order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n      }\r\n      i++;\r\n    }\r\n    double d_symbol_count = (double)(num_symbols_defined - rules_reduced);\r\n    order_0_entropy += d_symbol_count * (log_file_symbols - log2(d_symbol_count));\r\n  }\r\n  double code_entropy = 0.0;\r\n  if (num_symbols_defined != 0) {\r\n    uint32_t len_codes = num_symbols_defined - rules_reduced;\r\n    double log_len_codes = log2((double)len_codes);\r\n    for (i = 0 ; i \u003c 16 ; i++) {\r\n      if (len_counts[i] != 0) {\r\n        double d_symbol_count = (double)len_counts[i];\r\n        code_entropy += d_symbol_count * (log_len_codes - log2(d_symbol_count));\r\n      }\r\n    }\r\n    code_entropy += (double)extra_len_bits;\r\n    fprintf(stderr, \"Finished embedding grammar rules\\n\");\r\n    fprintf(stderr, \"Reduced grammar size: %u (%u terminals + %u rule symbols + %u repeats)\\n\",\r\n      grammar_size, num_new_symbols + rules_reduced - num_symbols_defined, num_symbols_defined - rules_reduced,\r\n      grammar_size - num_new_symbols);\r\n    fprintf(stderr, \"%.4f bits/symbol, plus %u length codes %.4f bits/code, o0e %.2lf bytes\\n\",\r\n        (float)(order_0_entropy/(double)grammar_size), (unsigned int)(num_symbols_defined - rules_reduced),\r\n        (float)(code_entropy/(double)len_codes), 0.125 * (order_0_entropy + code_entropy));\r\n  }\r\n#endif\r\n\r\n  // sort symbols with 800 or fewer instances by putting them at the end of the sorted symbols array\r\n  for (i = 2 ; i \u003c= MAX_INSTANCES_FOR_REMOVE ; i++) {\r\n    ranked_symbols_ptr = ranked_symbols;\r\n    while (ranked_symbols_ptr \u003c min_ranked_symbols_ptr) {\r\n      if (sd[*ranked_symbols_ptr].count == i) {\r\n        ranked_symbols_save = *ranked_symbols_ptr;\r\n        *ranked_symbols_ptr = *--min_ranked_symbols_ptr;\r\n        *min_ranked_symbols_ptr = ranked_symbols_save;\r\n      }\r\n      else\r\n        ranked_symbols_ptr++;\r\n    }\r\n  }\r\n\r\n  num_more_than_15_inst_definitions = min_ranked_symbols_ptr - ranked_symbols;\r\n\r\n  for (i = MAX_INSTANCES_FOR_REMOVE ; i \u003c 801 ; i++) {\r\n    ranked_symbols_ptr = ranked_symbols;\r\n    while (ranked_symbols_ptr \u003c min_ranked_symbols_ptr) {\r\n      if (sd[*ranked_symbols_ptr].count == i) {\r\n        ranked_symbols_save = *ranked_symbols_ptr;\r\n        *ranked_symbols_ptr = *--min_ranked_symbols_ptr;\r\n        *min_ranked_symbols_ptr = ranked_symbols_save;\r\n      }\r\n      else\r\n        ranked_symbols_ptr++;\r\n    }\r\n  }\r\n\r\n  // sort the remaining symbols by moving the most frequent symbols to the top of the sorted symbols array\r\n  min_ranked_symbols = min_ranked_symbols_ptr - ranked_symbols;\r\n  for (i = 0 ; i \u003c min_ranked_symbols ; i++) {\r\n    uint32_t max_symbol_count = 0;\r\n    ranked_symbols_ptr = \u0026ranked_symbols[i];\r\n    while (ranked_symbols_ptr \u003c min_ranked_symbols_ptr) {\r\n      if (sd[*ranked_symbols_ptr].count \u003e max_symbol_count) {\r\n        max_symbol_count = sd[*ranked_symbols_ptr].count;\r\n        max_ranked_symbols_ptr = ranked_symbols_ptr;\r\n      }\r\n      ranked_symbols_ptr++;\r\n    }\r\n    if (max_symbol_count \u003e 0) {\r\n      ranked_symbols_save = ranked_symbols[i];\r\n      ranked_symbols[i] = *max_ranked_symbols_ptr;\r\n      *max_ranked_symbols_ptr = ranked_symbols_save;\r\n    }\r\n  }\r\n\r\n  num_definitions_to_code = min_one_instance_ranked_symbols_ptr - ranked_symbols;\r\n  max_regular_code_length = 2;\r\n  if (sd[ranked_symbols[0]].count \u003e MAX_INSTANCES_FOR_REMOVE)\r\n    max_regular_code_length = (uint8_t)log2((double)(grammar_size - num_new_symbols) * 0.094821); // sqrt(2) / 15\r\n\r\n  for (i = num_base_symbols ; i \u003c num_codes ; i++) {\r\n    sd[i].starts = 0;\r\n    sd[i].ends = 0;\r\n  }\r\n\r\n  if (UTF8_compliant != 0) {\r\n    i = 0;\r\n    while (i \u003c 0x80) {\r\n      sd[i].starts = (uint8_t)i;\r\n      sd[i].ends = (uint8_t)i;\r\n      i++;\r\n    }\r\n    uint32_t temp_UTF8_limit = 0x250;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x80;\r\n      sd[i].ends = 0x80;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x370;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x81;\r\n      sd[i].ends = 0x81;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x400;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x82;\r\n      sd[i].ends = 0x82;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x530;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x83;\r\n      sd[i].ends = 0x83;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x590;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x84;\r\n      sd[i].ends = 0x84;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x600;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x85;\r\n      sd[i].ends = 0x85;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x700;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x86;\r\n      sd[i].ends = 0x86;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = START_UTF8_3BYTE_SYMBOLS;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x87;\r\n      sd[i].ends = 0x87;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x1000;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x88;\r\n      sd[i].ends = 0x88;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x2000;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x89;\r\n      sd[i].ends = 0x89;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x3000;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x8A;\r\n      sd[i].ends = 0x8A;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x3040;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x8B;\r\n      sd[i].ends = 0x8B;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x30A0;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x8C;\r\n      sd[i].ends = 0x8C;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x3100;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x8D;\r\n      sd[i].ends = 0x8D;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0x3200;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x8E;\r\n      sd[i].ends = 0x8E;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = 0xA000;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x8F;\r\n      sd[i].ends = 0x8F;\r\n      i++;\r\n    }\r\n    temp_UTF8_limit = START_UTF8_4BYTE_SYMBOLS;\r\n    if (max_UTF8_value \u003c temp_UTF8_limit)\r\n      temp_UTF8_limit = max_UTF8_value + 1;\r\n    while (i \u003c temp_UTF8_limit) {\r\n      sd[i].starts = 0x8E;\r\n      sd[i].ends = 0x8E;\r\n      i++;\r\n    }\r\n    while (i \u003c= max_UTF8_value) {\r\n      sd[i].starts = 0x90;\r\n      sd[i].ends = 0x90;\r\n      i++;\r\n    }\r\n    if (cap_encoded != 0)\r\n      sd['B'].ends = 'C';\r\n    i = num_base_symbols;\r\n    while (i \u003c num_codes) {\r\n      if (sd[i].starts == 0)\r\n        sd[i].starts = find_first_UTF8(i);\r\n      if (sd[i].ends == 0)\r\n        sd[i].ends = find_last_UTF8(i);\r\n      i++;\r\n    }\r\n  }\r\n  else {\r\n    i = 0;\r\n    while (i \u003c 0x100) {\r\n      sd[i].starts = (uint8_t)i;\r\n      sd[i].ends = (uint8_t)i;\r\n      i++;\r\n    }\r\n    if (cap_encoded != 0)\r\n      sd['B'].ends = 'C';\r\n    i = num_base_symbols;\r\n    while (i \u003c num_codes) {\r\n      if (sd[i].starts == 0)\r\n        sd[i].starts = find_first(i);\r\n      if (sd[i].ends == 0)\r\n        sd[i].ends = find_last(i);\r\n      i++;\r\n    }\r\n  }\r\n\r\n  num_transmits = 0;\r\n  dictionary_size = 0;\r\n  for (i = 0 ; i \u003c num_codes ; i++) {\r\n    sd[i].hits = 0;\r\n    sd[i].previous = 0xFFFFFFFF;\r\n  }\r\n  symbol_ptr = symbol_array;\r\n\r\n  while (symbol_ptr \u003c first_define_ptr) {\r\n    symbol = *symbol_ptr++;\r\n    if (sd[symbol].previous == 0xFFFFFFFF) {\r\n      get_embedded_symbols(symbol);\r\n      dictionary_size += get_dictionary_size(symbol);\r\n    }\r\n    else {\r\n      transmits[sd[symbol].previous].distance = num_transmits - sd[symbol].previous;\r\n      transmits[num_transmits].distance = 0xFFFFFFFF;\r\n      sd[symbol].previous2 = sd[symbol].previous;\r\n      sd[symbol].previous = num_transmits++;\r\n    }\r\n  }\r\n#ifdef PRINTON\r\n  fprintf(stderr, \"Parsed %u level 0 symbols\\n\", (unsigned int)(first_define_ptr - symbol_array));\r\n#endif\r\n\r\n  num_transmits_over_sqrt2 = (uint32_t)((float)num_transmits * 0.7071);\r\n  if (((num_transmits_over_sqrt2 \u003e\u003e 10) \u003c MAX_INSTANCES_FOR_REMOVE) \u0026\u0026 (use_mtf == 2))\r\n    use_mtf = 0;\r\n\r\n  for (i = 0 ; i \u003c num_base_symbols ; i++) {\r\n    if (sd[i].count == 1)\r\n      sd[i].code_length = 2;\r\n    else\r\n      sd[i].code_length = 0;\r\n  }\r\n  for (i = num_base_symbols ; i \u003c num_codes ; i++) {\r\n    if (sd[i].count == 1)\r\n      sd[i].code_length = 1;\r\n    else\r\n      sd[i].code_length = 0;\r\n  }\r\n\r\n  i = num_more_than_15_inst_definitions;\r\n  while ((i \u003c num_definitions_to_code) \u0026\u0026 (sd[ranked_symbols[i]].count \u003e 2))\r\n    i++;\r\n  uint32_t num_2_inst_definitions = num_definitions_to_code - i;\r\n  num_rules_reversed = 0;\r\n  while (i \u003c num_definitions_to_code) {\r\n    if (sd[ranked_symbols[i] + 1].define_symbol_start_index - sd[ranked_symbols[i]].define_symbol_start_index == 3) {\r\n      uint32_t last_transmit = sd[ranked_symbols[i]].previous;\r\n      uint32_t distance = last_transmit - sd[ranked_symbols[i]].previous2;\r\n      float score = (float)log2((double)num_transmits / (2.0 * (double)distance)) - 1.5 * log2((double)distance) + 10.5;\r\n      if (score \u003c= 0.0) {\r\n        uint32_t * define_string_ptr = symbol_array + sd[ranked_symbols[i]].define_symbol_start_index;\r\n        if ((uint64_t)((4 \u003e\u003e sd[ranked_symbols[i]].hits) * (sd[*define_string_ptr].count - 1))\r\n            * (uint64_t)(sd[*(define_string_ptr + 1)].count - 1) \u003e= (uint64_t)num_2_inst_definitions) {\r\n          sd[ranked_symbols[i]].code_length = 1;\r\n          num_rules_reversed++;\r\n        }\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n\r\n  // unmark rules that contain reversed rules then update symbol array\r\n  for (i = num_definitions_to_code - num_2_inst_definitions ; i \u003c num_definitions_to_code ; i++) {\r\n    if (sd[ranked_symbols[i]].code_length != 0) {\r\n      uint32_t * define_string_ptr = symbol_array + sd[ranked_symbols[i]].define_symbol_start_index;\r\n      if ((sd[*define_string_ptr].code_length != 0) || (sd[*(define_string_ptr + 1)].code_length != 0)) {\r\n        sd[ranked_symbols[i]].code_length = 0;\r\n        num_rules_reversed--;\r\n      }\r\n    }\r\n  }\r\n  symbol2_ptr = symbol_array2;\r\n  symbol_ptr = symbol_array;\r\n  while (symbol_ptr \u003c end_symbol_ptr) {\r\n    symbol = *symbol_ptr++;\r\n    if ((symbol \u0026 0x80000000) == 0) {\r\n      if ((symbol \u003e= num_base_symbols) \u0026\u0026 (sd[symbol].code_length != 0))\r\n        replace_symbol(symbol_array, symbol, \u0026symbol2_ptr, \u0026num_more_than_15_inst_definitions);\r\n      else\r\n        *symbol2_ptr++ = symbol;\r\n    }\r\n    else if (sd[symbol - 0x80000000 + num_base_symbols].code_length != 0) {\r\n      do {\r\n        if ((sd[*symbol_ptr].code_length != 2) \u0026\u0026 (--sd[*symbol_ptr].count == MAX_INSTANCES_FOR_REMOVE))\r\n          num_more_than_15_inst_definitions--;\r\n      } while (*++symbol_ptr \u003c 0x80000000);\r\n    }\r\n    else\r\n      *symbol2_ptr++ = symbol;\r\n  }\r\n  memcpy(symbol_array, symbol_array2, sizeof(uint32_t) * (symbol2_ptr - symbol_array2));\r\n  end_symbol_ptr = symbol_array + (symbol2_ptr - symbol_array2);\r\n  *end_symbol_ptr = UNIQUE_SYMBOL;\r\n\r\n#ifdef PRINTON\r\n  fprintf(stderr, \"Eliminated %u two instance rules\\n\", num_rules_reversed);\r\n#endif\r\n\r\n  prior_symbol = num_base_symbols - 1;\r\n  symbol_ptr = first_define_ptr;\r\n  while (symbol_ptr \u003c end_symbol_ptr) {\r\n    symbol = *symbol_ptr++;\r\n    if ((symbol \u0026 0x80000000) != 0) {\r\n      symbol += num_base_symbols - 0x80000000;\r\n      sd[symbol].define_symbol_start_index = symbol_ptr - symbol_array;\r\n      if (++prior_symbol == num_base_symbols)\r\n        first_define_ptr = symbol_ptr - 1;\r\n      if (prior_symbol != symbol) {\r\n        sd[prior_symbol].define_symbol_start_index = symbol_ptr - symbol_array;\r\n        prior_symbol = symbol;\r\n      }\r\n    }\r\n  }\r\n  sd[++prior_symbol].define_symbol_start_index = symbol2_ptr - symbol_array2 + 1;\r\n\r\n  i = 0;\r\n  while (i \u003c num_definitions_to_code) {\r\n    if (sd[ranked_symbols[i]].code_length != 0) {\r\n      num_definitions_to_code--;\r\n      num_new_symbols--;\r\n      uint32_t bad_symbol = ranked_symbols[i];\r\n      ranked_symbols[i] = ranked_symbols[num_definitions_to_code];\r\n      ranked_symbols[num_definitions_to_code] = bad_symbol;\r\n    }\r\n    else {\r\n      if ((i != 0) \u0026\u0026 (sd[ranked_symbols[i]].count \u003e sd[ranked_symbols[i - 1]].count)) {\r\n        uint32_t temp_symbol = ranked_symbols[i];\r\n        uint32_t temp_count = sd[temp_symbol].count;\r\n        uint32_t new_rank = i;\r\n        while ((new_rank != 0) \u0026\u0026 (temp_count \u003e sd[ranked_symbols[new_rank - 1]].count)) {\r\n          while ((new_rank \u003e= 1001) \u0026\u0026 (sd[ranked_symbols[new_rank - 1]].count == sd[ranked_symbols[new_rank - 1001]].count)) {\r\n            ranked_symbols[new_rank] = ranked_symbols[new_rank - 1000];\r\n            new_rank -= 1000;\r\n          }\r\n          while ((new_rank \u003e= 33) \u0026\u0026 (sd[ranked_symbols[new_rank - 1]].count == sd[ranked_symbols[new_rank - 33]].count)) {\r\n            ranked_symbols[new_rank] = ranked_symbols[new_rank - 32];\r\n            new_rank -= 32;\r\n          }\r\n          while ((new_rank \u003e= 2) \u0026\u0026 (sd[ranked_symbols[new_rank - 1]].count == sd[ranked_symbols[new_rank - 2]].count)) {\r\n            ranked_symbols[new_rank] = ranked_symbols[new_rank - 1];\r\n            new_rank -= 1;\r\n          }\r\n          ranked_symbols[new_rank] = ranked_symbols[new_rank - 1];\r\n          new_rank--;\r\n        }\r\n        ranked_symbols[new_rank] = temp_symbol;\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  num_transmits = 0;\r\n  for (i = 0 ; i \u003c num_codes ; i++) {\r\n    sd[i].space_score = 0;\r\n    sd[i].previous = 0xFFFFFFFF;\r\n  }\r\n  prior_symbol = (uint32_t)-1;\r\n  symbol_ptr = symbol_array;\r\n\r\n  while (symbol_ptr \u003c first_define_ptr) {\r\n    symbol = *symbol_ptr++;\r\n    if (sd[symbol].previous == 0xFFFFFFFF)\r\n      get_embedded_symbols2(symbol);\r\n    else {\r\n      transmits[sd[symbol].previous].distance = num_transmits - sd[symbol].previous;\r\n      transmits[num_transmits].symbol = symbol;\r\n      transmits[num_transmits].distance = 0xFFFFFFFF;\r\n      sd[symbol].previous = num_transmits++;\r\n      if ((sd[prior_symbol].type \u0026 0x18) != 0) {\r\n        if (sd[symbol].starts == 0x20)\r\n          sd[prior_symbol].space_score++;\r\n        else\r\n          sd[prior_symbol].space_score -= 5;\r\n      }\r\n      prior_symbol = symbol;\r\n    }\r\n  }\r\n\r\n  num_symbols_to_code = grammar_size - num_new_symbols - rules_reduced;\r\n  num_transmits_over_sqrt2 = (uint32_t)((float)num_transmits * 0.7071);\r\n  num_mtfs = 0;\r\n\r\n  if (use_mtf != 0) {\r\n    for (i = 0 ; i \u003c num_codes ; i++) {\r\n      if ((sd[i].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 10)) || (sd[i].count \u003c= MAX_INSTANCES_FOR_REMOVE))\r\n        sd[i].type |= 2;\r\n      sd[i].hits = 0;\r\n      sd[i].array_index = 0; // temporary use as instance counter\r\n    }\r\n    queue_size = 0;\r\n\r\n    for (i = 0 ; i \u003c num_transmits ; i++) {\r\n      uint32_t symbol = transmits[i].symbol;\r\n      sd[symbol].array_index++;\r\n      if ((sd[symbol].type \u0026 0x40) != 0) {\r\n        queue_position = 0;\r\n        while (queue[queue_position] != symbol)\r\n          queue_position++;\r\n        add_mtf_hit_scores(\u0026sd[symbol], queue_position, num_transmits_over_sqrt2);\r\n        sd[symbol].previous = i;\r\n        if (transmits[i].distance != 0xFFFFFFFF) {\r\n          if (((sd[symbol].type \u0026 2) != 0)\r\n              \u0026\u0026 ((uint64_t)transmits[i].distance * 4 * (uint64_t)sd[symbol].count \u003c= num_transmits)) {\r\n            if ((sd[symbol].array_index + 1 == sd[symbol].count) \u0026\u0026 (sd[symbol].count \u003c= MAX_INSTANCES_FOR_REMOVE))\r\n              // next to last instance\r\n              sd[symbol].score = (float)((log2((double)num_transmits / ((double)sd[symbol].count\r\n                  * (double)transmits[i].distance)) - 1.5) / (double)transmits[i].distance) - 0.001;\r\n            else if (transmits[i].distance \u003e transmits[i + transmits[i].distance].distance)\r\n              sd[symbol].score = (float)((log2((double)num_transmits / ((double)sd[symbol].count\r\n                  * (double)transmits[i].distance)) - 0.0) / (double)transmits[i].distance) - 0.001;\r\n            else\r\n              sd[symbol].score = (float)((log2((double)num_transmits / ((double)sd[symbol].count\r\n                  * (double)transmits[i].distance)) - 3.0) / (double)transmits[i].distance) - 0.001;\r\n            if (sd[symbol].score \u003e= 0.0) {\r\n              num_mtfs++;\r\n              while (queue_position-- != 0)\r\n                queue[queue_position + 1] = queue[queue_position];\r\n              queue[0] = symbol;\r\n            }\r\n            else\r\n              transmits[i].distance = 0xFFFFFFFF;\r\n          }\r\n          else\r\n            transmits[i].distance = 0xFFFFFFFF;\r\n        }\r\n        if (transmits[i].distance == 0xFFFFFFFF) {\r\n          sd[symbol].type \u0026= 0xBF;\r\n          queue_size--;\r\n          while (queue_position != queue_size) {\r\n            queue[queue_position] = queue[queue_position + 1];\r\n            queue_position++;\r\n          }\r\n        }\r\n      }\r\n      else if (transmits[i].distance != 0xFFFFFFFF) {\r\n        if (((sd[symbol].type \u0026 2) != 0) \u0026\u0026 (transmits[i].distance \u003c= num_transmits / (4 * sd[symbol].count))) {\r\n          if ((sd[symbol].array_index + 1 == sd[symbol].count) \u0026\u0026 (sd[symbol].count \u003c= MAX_INSTANCES_FOR_REMOVE))\r\n            sd[symbol].score = (float)((log2((double)num_transmits / ((double)sd[symbol].count\r\n                * (double)transmits[i].distance)) - 4.0) / (double)transmits[i].distance) - 0.001;\r\n          else if (transmits[i].distance \u003e transmits[i + transmits[i].distance].distance)\r\n            sd[symbol].score = (float)((log2((double)num_transmits / ((double)sd[symbol].count\r\n                * (double)transmits[i].distance)) - 3.0) / (double)transmits[i].distance) - 0.001;\r\n          else\r\n            sd[symbol].score = (float)((log2((double)num_transmits / ((double)sd[symbol].count\r\n                * (double)transmits[i].distance)) - 5.0) / (double)transmits[i].distance) - 0.001;\r\n          if (sd[symbol].score \u003e= 0.0) {\r\n            num_mtfs++;\r\n            sd[symbol].previous = i;\r\n            if (queue_size \u003c 0x100) {\r\n              sd[symbol].type |= 0x40;\r\n              queue_position = queue_size++;\r\n              while (queue_position-- != 0)\r\n                queue[queue_position + 1] = queue[queue_position];\r\n              queue[0] = symbol;\r\n            }\r\n            else {\r\n              float low_score = sd[symbol].score;\r\n              uint16_t low_score_pos = 0x100;\r\n              for (k = 0 ; k \u003c= 0xFF ; k++) {\r\n                j = sd[queue[k]].previous;\r\n                if (sd[queue[k]].score * (float)transmits[j].distance / (float)(transmits[j].distance - (i - j))\r\n                    \u003c low_score) {\r\n                  low_score\r\n                      = sd[queue[k]].score * (float)transmits[j].distance / (float)(transmits[j].distance - (i - j));\r\n                  low_score_pos = k;\r\n                }\r\n              }\r\n              if (low_score_pos != 0x100) {\r\n                sd[symbol].type |= 0x40;\r\n                sd[queue[low_score_pos]].type \u0026= 0xBF;\r\n                j = sd[queue[low_score_pos]].previous;\r\n                queue_position = low_score_pos;\r\n                while (queue_position-- != 0)\r\n                 queue[queue_position + 1] = queue[queue_position];\r\n                queue[0] = symbol;\r\n                transmits[j].distance = 0xFFFFFFFF;\r\n              }\r\n              else\r\n                transmits[i].distance = 0xFFFFFFFF;\r\n            }\r\n          }\r\n          else\r\n            transmits[i].distance = 0xFFFFFFFF;\r\n        }\r\n        else\r\n          transmits[i].distance = 0xFFFFFFFF;\r\n      }\r\n    }\r\n#ifdef PRINTON\r\n  fprintf(stderr, \"Found %u MTF candidates, \", (unsigned int)num_mtfs);\r\n#endif\r\n\r\n    for (i = 0 ; i \u003c num_codes ; i++) {\r\n      if ((sd[i].type \u0026 2) != 0) {\r\n        if (sd[i].count \u003e MAX_INSTANCES_FOR_REMOVE) {\r\n          if ((float)sd[i].hits \u003c (float)(sd[i].count - 1)\r\n              * (1.0 + 0.03 * pow(22.0 - log2((float)num_transmits_over_sqrt2 / (float)sd[i].count), 2.5)))\r\n            sd[i].type \u0026= 0xFD;\r\n        }\r\n        else if (sd[i].hits == 0)\r\n          sd[i].type \u0026= 0xFD;\r\n      }\r\n      sd[i].hits = 0;\r\n    }\r\n\r\n    num_mtfs = 0;\r\n    for (i = 0 ; i \u003c num_transmits ; i++) {\r\n      uint32_t symbol = transmits[i].symbol;\r\n      if ((sd[symbol].type \u0026 0x40) != 0) {\r\n        sd[symbol].hits++;\r\n        num_mtfs++;\r\n        if (transmits[i].distance == 0xFFFFFFFF)\r\n          sd[symbol].type \u0026= 0xBF;\r\n      }\r\n      else if (transmits[i].distance != 0xFFFFFFFF) {\r\n        if ((sd[symbol].type \u0026 2) != 0)\r\n          sd[symbol].type |= 0x40;\r\n        else\r\n          transmits[i].distance = 0xFFFFFFFF;\r\n      }\r\n    }\r\n#ifdef PRINTON\r\n  fprintf(stderr, \"%u MTF symbols\\n\", (unsigned int)num_mtfs);\r\n#endif\r\n  }\r\n\r\n  for (i = 2 ; i \u003c= MAX_INSTANCES_FOR_REMOVE ; i++) {\r\n    mtf_started[i] = 0;\r\n    mtf_peak[i] = 0;\r\n    mtf_peak_mtf[i] = 0;\r\n    mtf_active[i] = 0;\r\n    mtf_hits[i] = 0;\r\n    mtf_in_dictionary[i] = 0;\r\n  }\r\n\r\n  for (i = 0 ; i \u003c num_codes ; i++)\r\n    sd[i].array_index = 0;  // temporary use as instance counter\r\n\r\n  for (i = 0 ; i \u003c num_transmits ; i++) {\r\n    uint32_t symbol = transmits[i].symbol;\r\n    sd[symbol].array_index++;\r\n    uint32_t count = sd[symbol].count;\r\n    if (count \u003c= MAX_INSTANCES_FOR_REMOVE) {\r\n      if (mtf_in_dictionary[count] \u003e mtf_peak_mtf[count])\r\n        mtf_peak_mtf[count] = mtf_in_dictionary[count];\r\n      if (mtf_active[count] \u003e mtf_peak[count])\r\n        mtf_peak[count] = mtf_active[count];\r\n      if (sd[symbol].array_index == 1) {\r\n        mtf_started[count]++;\r\n        mtf_active[count]++;\r\n        if (transmits[i].distance != 0xFFFFFFFF)\r\n          sd[symbol].type |= 0x40;\r\n        else\r\n          mtf_in_dictionary[count]++;\r\n      }\r\n      else if (sd[symbol].array_index == count) {\r\n        mtf_active[count]--;\r\n        if ((sd[symbol].type \u0026 0x40) != 0) {\r\n          sd[symbol].type \u0026= 0xBF;\r\n          mtf_hits[count]++;\r\n        }\r\n        else\r\n          mtf_in_dictionary[count]--;\r\n      }\r\n      else {\r\n        if ((sd[symbol].type \u0026 0x40) != 0) {\r\n          mtf_hits[count]++;\r\n          if (transmits[i].distance == 0xFFFFFFFF) {\r\n            sd[symbol].type \u0026= 0xBF;\r\n            mtf_in_dictionary[count]++;\r\n          }\r\n        }\r\n        else if (transmits[i].distance != 0xFFFFFFFF) {\r\n          sd[symbol].type |= 0x40;\r\n          mtf_in_dictionary[count]--;\r\n        }\r\n      }\r\n    }\r\n    else if ((transmits[i].distance != 0xFFFFFFFF) \u0026\u0026 ((sd[symbol].type \u0026 2) == 0))\r\n      transmits[i].distance = 0xFFFFFFFF;\r\n  }\r\n\r\n  if (use_mtf == 2) {\r\n    use_mtf = 0;\r\n    double sum_expected_peak = 0.0;\r\n    double sum_actual_peak = 0.0;\r\n    for (i = 2 ; i \u003c= 15 ; i++) {\r\n      sum_expected_peak += (double)(i - 1) * (double)mtf_started[i] * (1.0 - (1.0 / (double)(1 \u003c\u003c (i - 1))));\r\n      sum_actual_peak += (double)(i - 1) * (double)mtf_peak_mtf[i];\r\n    }\r\n    double score1, score2;\r\n    score1 = 5.75 * (double)mtf_started[2] / ((double)mtf_peak_mtf[2] * (32.8 - log2((double)num_symbols_to_code)));\r\n    score2 = sum_expected_peak / sum_actual_peak;\r\n    if (score1 + score2 \u003e 2.08)\r\n      use_mtf = 1;\r\n  }\r\n\r\n  if (use_mtf != 0) {\r\n    for (i = 0 ; i \u003c num_codes ; i++) {\r\n      if (sd[i].count \u003e MAX_INSTANCES_FOR_REMOVE) {\r\n        if ((sd[i].type \u0026 2) != 0) {\r\n          if (sd[i].count - sd[i].hits \u003c= MAX_INSTANCES_FOR_REMOVE) {\r\n            num_symbols_to_code -= sd[i].count - (MAX_INSTANCES_FOR_REMOVE + 1);\r\n            sd[i].count = MAX_INSTANCES_FOR_REMOVE + 1;\r\n          }\r\n          else {\r\n            num_symbols_to_code -= sd[i].hits;\r\n            sd[i].count -= sd[i].hits;\r\n          }\r\n        }\r\n      }\r\n      else\r\n        num_symbols_to_code -= sd[i].hits;\r\n    }\r\n#ifdef PRINTON\r\n    fprintf(stderr, \"Updating symbol ranks\\r\");\r\n#endif\r\n\r\n    // update the symbol ranks\r\n    max_ptr = ranked_symbols + num_more_than_15_inst_definitions;\r\n    ranked_symbols2_ptr = ranked_symbols2 + num_more_than_15_inst_definitions;\r\n    for (i = MAX_INSTANCES_FOR_REMOVE + 1 ; i \u003c 501 ; i++) {\r\n      ranked_symbols_ptr = max_ptr;\r\n      while ((--ranked_symbols_ptr \u003e= ranked_symbols) \u0026\u0026 (sd[*ranked_symbols_ptr].count == i))\r\n        *--ranked_symbols2_ptr = *ranked_symbols_ptr;\r\n      max_ptr = ranked_symbols_ptr + 1;\r\n      while (--ranked_symbols_ptr \u003e= ranked_symbols) {\r\n        if (sd[*ranked_symbols_ptr].count == i)\r\n          *--ranked_symbols2_ptr = *ranked_symbols_ptr;\r\n      }\r\n    }\r\n    num_greater_500 = ranked_symbols2_ptr - ranked_symbols2;\r\n    ranked_symbols_ptr = max_ptr;\r\n    while (--ranked_symbols_ptr \u003e= ranked_symbols) {\r\n      if (sd[*ranked_symbols_ptr].count \u003e= 501)\r\n        *--ranked_symbols2_ptr = *ranked_symbols_ptr;\r\n    }\r\n    for (i = 1 ; i \u003c num_greater_500 ; i++) {\r\n      uint32_t temp_symbol = ranked_symbols2[i];\r\n      uint32_t temp_count = sd[temp_symbol].count;\r\n      if (temp_count \u003e sd[ranked_symbols2[i - 1]].count) {\r\n        ranked_symbols2[i] = ranked_symbols2[i - 1];\r\n        j = i - 1;\r\n        while ((j != 0) \u0026\u0026 (temp_count \u003e sd[ranked_symbols2[j - 1]].count)) {\r\n          ranked_symbols2[j] = ranked_symbols2[j - 1];\r\n          j--;\r\n        }\r\n        ranked_symbols2[j] = temp_symbol;\r\n      }\r\n    }\r\n    for (i = 0 ; i \u003c num_more_than_15_inst_definitions ; i++)\r\n      ranked_symbols[i] = ranked_symbols2[i];\r\n    peak_array = mtf_peak_mtf;\r\n  }\r\n  else {\r\n    for (i = 0 ; i \u003c num_codes ; i++)\r\n      sd[i].type \u0026= 0xFD;\r\n    for (i = 2 ; i \u003c= MAX_INSTANCES_FOR_REMOVE ; i++)\r\n      mtf_hits[i] = 0;\r\n    peak_array = mtf_peak;\r\n  }\r\n\r\n  // Calculate dictionary code lengths\r\n  if (peak_array[2] != 0) {\r\n    queue_miss_code_length[2] = (uint32_t)(0.5 + log2((double)num_symbols_to_code\r\n        * (double)peak_array[2] / (double)(mtf_started[2] - mtf_hits[2])));\r\n    if (queue_miss_code_length[2] \u003e 25)\r\n      queue_miss_code_length[2] = 25;\r\n  }\r\n  else\r\n    queue_miss_code_length[2] = 25;\r\n  for (i = 3 ; i \u003c= MAX_INSTANCES_FOR_REMOVE ; i++) {\r\n    if (peak_array[i] != 0) {\r\n      queue_miss_code_length[i] = (uint32_t)(0.5 + log2((double)num_symbols_to_code\r\n          * (double)peak_array[i] / (double)(mtf_started[i] * (i - 1) - mtf_hits[i])));\r\n      if (queue_miss_code_length[i] \u003e queue_miss_code_length[i - 1])\r\n        queue_miss_code_length[i] = queue_miss_code_length[i - 1];\r\n      else if (queue_miss_code_length[i] \u003c queue_miss_code_length[i - 1] - 1)\r\n        queue_miss_code_length[i] = queue_miss_code_length[i - 1] - 1;\r\n    }\r\n    else\r\n      queue_miss_code_length[i] = queue_miss_code_length[i - 1];\r\n  }\r\n  if ((use_mtf != 0) \u0026\u0026 (queue_miss_code_length[12] \u003c= max_regular_code_length))\r\n    max_regular_code_length--;\r\n\r\n  remaining_symbols_to_code = 0;\r\n  for (i = 0 ; i \u003c num_more_than_15_inst_definitions ; i++)\r\n    remaining_symbols_to_code += sd[ranked_symbols[i]].count - 1;\r\n  mtf_miss_code_space = 0;\r\n  for (i = 2 ; i \u003c= MAX_INSTANCES_FOR_REMOVE; i++) {\r\n    if (queue_miss_code_length[i] \u003c= max_regular_code_length)\r\n      queue_miss_code_length[i] = max_regular_code_length + 1;\r\n    mtf_miss_code_space += (1 \u003c\u003c (30 - queue_miss_code_length[i])) * peak_array[i];\r\n  }\r\n  max_code_length = queue_miss_code_length[2];\r\n\r\n  remaining_code_space = (1 \u003c\u003c 30) - (1 \u003c\u003c (30 - max_code_length)) - mtf_miss_code_space;\r\n  min_code_space = 1 \u003c\u003c (30 - (queue_miss_code_length[MAX_INSTANCES_FOR_REMOVE] - 1));\r\n\r\n  codes_per_code_space = (double)remaining_symbols_to_code / (double)remaining_code_space;\r\n  max_regular_code_length = 1;\r\n  prior_repeats = 0;\r\n  for (i = 0 ; i \u003c= 25 ; i++)\r\n    index_last_length[i] = -1;\r\n\r\n  // recalculate code lengths\r\n  for (i = 0 ; i \u003c num_more_than_15_inst_definitions ; i++) {\r\n    symbol_inst = sd[ranked_symbols[i]].count;\r\n    if (--symbol_inst != prior_repeats) {\r\n      prior_repeats = symbol_inst;\r\n      symbol_inst_factor = (double)0x5A827999 / (double)symbol_inst; // 0x40000000 * sqrt(2.0)\r\n      code_length_limit = (uint32_t)log2(symbol_inst_factor * codes_per_code_space);\r\n      if (code_length_limit \u003c 2)\r\n        code_length_limit = 2;\r\n    }\r\n    code_length = (uint8_t)log2(symbol_inst_factor\r\n        * (1.0 + (double)(remaining_symbols_to_code - 15 * (num_more_than_15_inst_definitions - i - 1)))\r\n        / (double)(remaining_code_space - min_code_space * (num_more_than_15_inst_definitions - i - 1)));\r\n    if (code_length \u003c code_length_limit)\r\n      code_length = code_length_limit;\r\n    if (code_length \u003e= queue_miss_code_length[MAX_INSTANCES_FOR_REMOVE])\r\n      code_length = queue_miss_code_length[MAX_INSTANCES_FOR_REMOVE] - 1;\r\n    else\r\n      while ((num_more_than_15_inst_definitions - i - 1) * min_code_space \u003e remaining_code_space - (1 \u003c\u003c (30 - code_length)))\r\n        code_length++;\r\n\r\n    if (code_length \u003e max_regular_code_length)\r\n      max_regular_code_length = code_length;\r\n      \r\n    sd[ranked_symbols[i]].code_length = code_length;\r\n    remaining_code_space -= 1 \u003c\u003c (30 - code_length);\r\n    remaining_symbols_to_code -= symbol_inst;\r\n\r\n    if ((i != 0) \u0026\u0026 (sd[ranked_symbols[i - 1]].code_length \u003e code_length)) {\r\n      if (index_last_length[code_length] == -1) {\r\n        uint32_t temp_code_length = code_length - 1;\r\n        while (index_last_length[temp_code_length] == -1)\r\n          temp_code_length--;\r\n        index_last_length[code_length] = index_last_length[temp_code_length];\r\n      }\r\n      sd[ranked_symbols[++index_last_length[code_length]]].code_length = code_length;\r\n      while (index_last_length[++code_length] == -1); // do nothing\r\n      index_last_length[code_length]++;\r\n      sd[ranked_symbols[i]].code_length = code_length;\r\n    }\r\n    else\r\n      index_last_length[code_length] = i;\r\n  }\r\n\r\n  do {\r\n    uint8_t min_code_length = sd[ranked_symbols[0]].code_length;\r\n    for (i = min_code_length ; i \u003c max_regular_code_length ; i++)\r\n      if (index_last_length[i] == -1)\r\n        min_code_length = i + 1;\r\n    max_len_adj_profit = 0;  \r\n    for (i = min_code_length ; i \u003c max_regular_code_length ; i++) {\r\n      int32_t len_adj_profit = -(sd[ranked_symbols[index_last_length[i]]].count - 1);\r\n      for (j = i + 2 ; j \u003c= max_regular_code_length ; j++) {\r\n        len_adj_profit += sd[ranked_symbols[index_last_length[j - 1] + 1]].count - 1;\r\n        if (index_last_length[j] != index_last_length[j - 1] + 1) {\r\n          int32_t next_symbol_profit = sd[ranked_symbols[index_last_length[j - 1] + 2]].count - 1;\r\n          if (len_adj_profit + next_symbol_profit \u003e max_len_adj_profit) {\r\n            max_len_adj_profit = len_adj_profit + next_symbol_profit;\r\n            increase_length = i;\r\n            decrease_length = j;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (max_len_adj_profit != 0) {\r\n      sd[ranked_symbols[index_last_length[increase_length]--]].code_length++;\r\n      for (j = increase_length + 2 ; j \u003c= decrease_length ; j++)\r\n        sd[ranked_symbols[++index_last_length[j - 1]]].code_length--;\r\n      sd[ranked_symbols[++index_last_length[decrease_length - 1]]].code_length--;\r\n      if (index_last_length[decrease_length - 1] == index_last_length[decrease_length])\r\n        index_last_length[decrease_length] = -1;\r\n    }\r\n  } while (max_len_adj_profit != 0);\r\n\r\n  j = 0;\r\n  for (i = sd[ranked_symbols[0]].code_length ; i \u003c max_regular_code_length ; i++) {\r\n    if (index_last_length[i] \u003e= 0) {\r\n      index_first_length[i] = j;\r\n      j = index_last_length[i] + 1;\r\n    }\r\n    else\r\n      index_first_length[i] = -1;\r\n  }\r\n\r\n  do {\r\n    max_len_adj_profit = 0;  \r\n    for (i = sd[ranked_symbols[0]].code_length ; i \u003c max_regular_code_length ; i++) {\r\n      if (index_last_length[i] - index_first_length[i] \u003e= 2) {\r\n        int32_t len_adj_profit = sd[ranked_symbols[index_first_length[i]]].count - 1;\r\n        len_adj_profit -= sd[ranked_symbols[index_last_length[i]]].count - 1;\r\n        len_adj_profit -= sd[ranked_symbols[index_last_length[i] - 1]].count - 1;\r\n        if (len_adj_profit \u003e max_len_adj_profit) {\r\n          max_len_adj_profit = len_adj_profit;\r\n          decrease_length = i;\r\n        }\r\n      }\r\n    }\r\n    if (max_len_adj_profit != 0) {\r\n      sd[ranked_symbols[index_first_length[decrease_length]]].code_length--;\r\n      sd[ranked_symbols[index_last_length[decrease_length] - 1]].code_length++;\r\n      sd[ranked_symbols[index_last_length[decrease_length]]].code_length++;\r\n      if (index_first_length[decrease_length - 1] \u003c 0)\r\n        index_first_length[decrease_length - 1] = index_first_length[decrease_length];\r\n      index_last_length[decrease_length - 1] = index_first_length[decrease_length];\r\n      if (index_first_length[decrease_length + 1] \u003c 0)\r\n        index_last_length[decrease_length + 1] = index_last_length[decrease_length];\r\n      index_first_length[decrease_length + 1] = index_last_length[decrease_length] - 1;\r\n      if (index_last_length[i] - index_first_length[i] == 2) {\r\n        index_first_length[decrease_length] = -1;\r\n        index_last_length[decrease_length] = -1;\r\n      }\r\n      else {\r\n        index_first_length[decrease_length] += 1;\r\n        index_last_length[decrease_length] -= 2;\r\n      }\r\n    }\r\n  } while (max_len_adj_profit != 0);\r\n\r\n  for (i = 0 ; i \u003c num_more_than_15_inst_definitions ; i++)\r\n    if (sd[ranked_symbols[i]].code_length \u003c 11)\r\n      sd[ranked_symbols[i]].type \u0026= 0xFD;\r\n\r\n  for (i = num_more_than_15_inst_definitions ; i \u003c num_definitions_to_code ; i++) {\r\n    sd[ranked_symbols[i]].type \u0026= 0xBF;\r\n    sd[ranked_symbols[i]].code_length = queue_miss_code_length[sd[ranked_symbols[i]].count];\r\n  }\r\n\r\n  if (num_definitions_to_code == 0) {\r\n    max_regular_code_length = 24;\r\n    sd[ranked_symbols[0]].code_length = 25;\r\n  }\r\n  else if (sd[ranked_symbols[0]].count \u003c= MAX_INSTANCES_FOR_REMOVE)\r\n    max_regular_code_length = sd[ranked_symbols[0]].code_length - 1;\r\n\r\n  sd[num_codes].type = 0;\r\n  if (max_code_length \u003e= 14) {\r\n    i = 0;\r\n    while (i \u003c num_more_than_15_inst_definitions) {\r\n     if ((sd[ranked_symbols[i]].type \u0026 8) != 0) {\r\n        if (sd[ranked_symbols[i]].space_score \u003e 0)\r\n          sd[ranked_symbols[i]].type += 8;\r\n        else\r\n          sd[ranked_symbols[i]].type += 0x10;\r\n      }\r\n      i++;\r\n    }\r\n    for (i = num_base_symbols ; i \u003c num_codes; i++) {\r\n      if ((sd[i].type \u0026 0x10) != 0) {\r\n        uint32_t last_symbol = symbol_array[sd[i + 1].define_symbol_start_index - 2];\r\n        while (last_symbol \u003e= num_base_symbols) {\r\n          if ((sd[last_symbol].type \u0026 0x18) == 0x10) {\r\n            sd[i].type = (sd[i].type \u0026 0x6F) | 8;\r\n            break;\r\n          }\r\n          last_symbol = symbol_array[sd[last_symbol + 1].define_symbol_start_index - 2];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    for (i = 0 ; i \u003c num_definitions_to_code ; i++)\r\n      sd[ranked_symbols[i]].type \u0026= 0x63;\r\n  }\r\n\r\n#ifdef PRINTON\r\n  if (verbose != 0) {\r\n    if (verbose == 1) {\r\n      for (i = 0 ; i \u003c num_definitions_to_code ; i++) {\r\n        if (sd[ranked_symbols[i]].code_length \u003e= 11) {\r\n          if (use_mtf != 0)\r\n            printf(\"%u: #%u %u L%u D%02x: \\\"\", (unsigned int)i + 1, (unsigned int)sd[ranked_symbols[i]].array_index,\r\n                (unsigned int)sd[ranked_symbols[i]].count, (unsigned int)sd[ranked_symbols[i]].code_length,\r\n                (unsigned int)sd[ranked_symbols[i]].type \u0026 0xCE);\r\n          else\r\n            printf(\"%u: #%u L%u D%02x: \\\"\", (unsigned int)i + 1, (unsigned int)sd[ranked_symbols[i]].count,\r\n                (unsigned int)sd[ranked_symbols[i]].code_length, (unsigned int)sd[ranked_symbols[i]].type \u0026 0xCE);\r\n        }\r\n        else\r\n          printf(\"%u: #%u L%u: \\\"\", (unsigned int)i + 1, (unsigned int)sd[ranked_symbols[i]].count,\r\n              (unsigned int)sd[ranked_symbols[i]].code_length);\r\n        print_string(ranked_symbols[i]);\r\n        printf(\"\\\"\\n\");\r\n      }\r\n      uint32_t temp_rank = num_definitions_to_code;\r\n      for (i = 0 ; i \u003c num_base_symbols ; i++) {\r\n        if (sd[i].count == 1) {\r\n          printf(\"%u: #1: \\\"\", ++temp_rank);\r\n          print_string(i);\r\n          printf(\"\\\"\\n\");\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0 ; i \u003c num_codes ; i++) {\r\n        if ((sd[i].array_index != 0) \u0026\u0026 ((sd[i].array_index \u003e 1) || (i \u003c num_base_symbols))) {\r\n          if (sd[i].code_length \u003e= 11) {\r\n            if (use_mtf != 0)\r\n              printf(\"%u: #%u %u L%u D%02x: \\\"\", (unsigned int)i + 1, (unsigned int)sd[i].array_index,\r\n                  (unsigned int)sd[i].count, (unsigned int)sd[i].code_length, (unsigned int)sd[i].type \u0026 0xCE);\r\n            else\r\n              printf(\"%u: #%u L%u D%02x: \\\"\",(unsigned int)i + 1, (unsigned int)sd[i].count,\r\n                  (unsigned int)sd[i].code_length, (unsigned int)sd[i].type \u0026 0xCE);\r\n          }\r\n          else\r\n            printf(\"%u: #%u L%u: \\\"\", (unsigned int)i + 1, (unsigned int)sd[i].count, (unsigned int)sd[i].code_length);\r\n          print_string(i);\r\n          printf(\"\\\"\\n\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n#endif\r\n\r\n  symbol_ptr = symbol_array;\r\n  prior_is_cap = 0;\r\n  temp_char = 0xFF;\r\n  if (UTF8_compliant != 0)\r\n    temp_char = 0x90;\r\n  InitEncoder(max_code_length, temp_char,\r\n      MAX_INSTANCES_FOR_REMOVE + (uint32_t)(max_regular_code_length - sd[ranked_symbols[0]].code_length) + 1,\r\n      cap_encoded, UTF8_compliant, use_mtf);\r\n\r\n  if (fd != 0) {\r\n    if ((outbuf = (uint8_t *)malloc(in_size * 2 + 100000)) == 0) {\r\n      fprintf(stderr, \"Error - encoded data memory allocation failed\\n\");\r\n      return(0);\r\n    }\r\n  }\r\n\r\n  // HEADER:\r\n  // BYTE 0:  4.0 * log2(file_size)\r\n  // BYTE 1:  7=cap_encoded, 6=UTF8_compliant, 5=use_mtf, 4-0=max_code_length-1\r\n  // BYTE 2:  7=M4D, 6=M3D, 5=use_delta, 4-0=min_code_length-1\r\n  // BYTE 3:  7=M7D, 6=M6D, 5=M5D, 4-0=max_code_length-max_regular_code_length\r\n  // BYTE 4:  7=M15D, 6=M14D, 5=M13D, 4=M12D, 3=M11D, 2=M10D, 1=M9D, 0=M8D\r\n  // if UTF8_compliant\r\n  // BYTE 5:  7-5=unused, 4-0=base_bits\r\n  // else if use_delta\r\n  //   if stride \u003c= 4\r\n  // BYTE 5:  7=0, 6-5=unused, 4=two channel, 3=little endian, 2=any endian, 1-0=stride-1\r\n  //   else\r\n  // BYTE 5:  7=1, 6-0=stride\r\n\r\n  SetOutBuffer(outbuf);\r\n  WriteOutBuffer((uint8_t)(12.5 * (log2((double)(dictionary_size + 0x400)) - 10.0)) + 1);\r\n  WriteOutBuffer((cap_encoded \u003c\u003c 7) | (UTF8_compliant \u003c\u003c 6) | (use_mtf \u003c\u003c 5) | (queue_miss_code_length[2] - 1));\r\n  temp_char = (((format \u0026 0xFE) != 0) \u003c\u003c 5) | (sd[ranked_symbols[0]].code_length - 1);\r\n  if (queue_miss_code_length[3] != queue_miss_code_length[2])\r\n    temp_char |= 0x40;\r\n  if (queue_miss_code_length[4] != queue_miss_code_length[3])\r\n    temp_char |= 0x80;\r\n  WriteOutBuffer(temp_char);\r\n  i = 7;\r\n  do {\r\n    temp_char = (temp_char \u003c\u003c 1) | (queue_miss_code_length[i] != queue_miss_code_length[i - 1]);\r\n  } while (--i != 4);\r\n  WriteOutBuffer((temp_char \u003c\u003c 5) | (queue_miss_code_length[2] - max_regular_code_length));\r\n  i = 15;\r\n  do {\r\n    temp_char = (temp_char \u003c\u003c 1) | (queue_miss_code_length[i] != queue_miss_code_length[i - 1]);\r\n  } while (--i != 7);\r\n  WriteOutBuffer(temp_char);\r\n  i = 0xFF;\r\n  if (UTF8_compliant != 0) {\r\n    WriteOutBuffer(base_bits);\r\n    i = 0x90;\r\n  }\r\n  else if ((format \u0026 0xFE) != 0) {\r\n    if ((format \u0026 0x80) == 0)\r\n      WriteOutBuffer(((format \u0026 0xF0) \u003e\u003e 2) | (((format \u0026 0xE) \u003e\u003e 1) - 1));\r\n    else\r\n      WriteOutBuffer(format);\r\n  }\r\n  do {\r\n    for (j = 1 ; j \u003c= max_code_length ; j++) {\r\n      sym_list_bits[i][j] = 2;\r\n      if (0 == (sym_list_ptrs[i][j] = (uint32_t *)malloc(sizeof(uint32_t) * 4))) {\r\n        fprintf(stderr, \"Error - symbol list memory allocation failed\\n\");\r\n        return(0);\r\n      }\r\n      nsob[i][j] = 0;\r\n      nbob[i][j] = 0;\r\n      fbob[i][j] = 0;\r\n    }\r\n    sum_nbob[i] = 0;\r\n    bin_code_length[i] = max_code_length;\r\n    symbol_lengths[i] = 0;\r\n  } while (i--);\r\n\r\n#ifdef PRINTON\r\n  fprintf(stderr, \"use_mtf %u, mcl %u mrcl %u\\n\",\r\n      (unsigned int)use_mtf, (unsigned int)max_code_length, (unsigned int)max_regular_code_length);\r\n#endif\r\n\r\n  for (i = 0 ; i \u003c num_more_than_15_inst_definitions ; i++)\r\n    sd[ranked_symbols[i]].count = sd[ranked_symbols[i]].code_length + MAX_INSTANCES_FOR_REMOVE;\r\n  for (i = 0 ; i \u003c num_codes ; i++)\r\n    sd[i].hits = 0;\r\n  num_transmits = queue_size = queue_size_az = queue_size_space = queue_size_other = queue_offset = 0;\r\n  found_first_symbol = prior_end = 0;\r\n  num_grammar_rules = 1;\r\n  prior_symbol = num_codes;\r\n\r\n  if ((UTF8_compliant != 0) || (cap_encoded != 0)) {\r\n    cap_symbol_defined = 0;\r\n    cap_lock_symbol_defined = 0;\r\n    symbol = *symbol_ptr++;\r\n    sd[symbol].hits++;\r\n    if (embed_define(symbol, 0) == 0)\r\n      return(0);\r\n\r\n    while (symbol_ptr \u003c first_define_ptr) {\r\n      symbol = *symbol_ptr++;\r\n      symbol_inst = sd[symbol].hits++;\r\n      if (symbol_inst == 0) {\r\n        if (cap_encoded != 0) {\r\n          if (prior_is_cap == 0)\r\n            EncodeNewType3(0, 4 + (sd[prior_symbol].type \u0026 0x18) + 2 * (sd[prior_symbol].type \u0026 7), prior_end);\r\n          else\r\n            EncodeNewType2(2, 0x2C + (sd[prior_symbol].type \u0026 3));\r\n        }\r\n        else\r\n          EncodeNewType1(0);\r\n        if (embed_define(symbol, 0) == 0)\r\n          return(0);\r\n      }\r\n      else {\r\n        if ((sd[symbol].type \u0026 0x40) != 0) {\r\n          if (prior_is_cap == 0)\r\n            update_queue(symbol, 0);\r\n          else\r\n            update_queue_prior_cap(symbol, 0);\r\n        }\r\n        else {\r\n          if (cap_encoded != 0) {\r\n            if (prior_is_cap == 0)\r\n              EncodeDictType3(0, 4 + (sd[prior_symbol].type \u0026 0x18) + 2 * (sd[prior_symbol].type \u0026 7), prior_end);\r\n            else\r\n              EncodeDictType2(2, 0x2C + (sd[prior_symbol].type \u0026 3));\r\n          }\r\n          else\r\n            EncodeDictType1(0);\r\n\r\n          encode_dictionary_symbol(symbol);\r\n          if (sd[symbol].count \u003c= MAX_INSTANCES_FOR_REMOVE) {\r\n            if (sd[symbol].count == sd[symbol].hits)\r\n              remove_dictionary_symbol(symbol, sd[symbol].code_length);\r\n            else if (use_mtf != 0) {\r\n              if ((sd[symbol].type \u0026 2) != 0) {\r\n                if (transmits[num_transmits].distance != 0xFFFFFFFF) {\r\n                  if ((sd[symbol].hits + 1 != sd[symbol].count) || ((sd[symbol].type \u0026 0x80) != 0)) {\r\n                    if (cap_encoded != 0)\r\n                      EncodeGoMtf(6 * (sd[symbol].count - 1) + prior_is_cap + (sd[symbol].type \u0026 1)\r\n                          + 3 * (((sd[symbol].type \u003e\u003e 3) \u0026 3) == 2), 0, 1);\r\n                    else\r\n                      EncodeGoMtf(6 * (sd[symbol].count - 1), 0, 1);\r\n                  }\r\n                  remove_dictionary_symbol(symbol, sd[symbol].code_length);\r\n                  add_symbol_to_queue(symbol);\r\n                }\r\n                else {\r\n                  if (cap_encoded != 0)\r\n                    EncodeGoMtf(6 * (sd[symbol].count - 1) + prior_is_cap + (sd[symbol].type \u0026 1)\r\n                        + 3 * (((sd[symbol].type \u003e\u003e 3) \u0026 3) == 2), 0, 0);\r\n                  else\r\n                    EncodeGoMtf(6 * (sd[symbol].count - 1), 0, 0);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if ((sd[symbol].type \u0026 2) != 0) {\r\n            uint16_t context;\r\n            if (cap_encoded != 0)\r\n              context = 6 * (sd[symbol].count - 1) + prior_is_cap + (sd[symbol].type \u0026 1)\r\n                  + 3 * (((sd[symbol].type \u003e\u003e 3) \u0026 3) == 2);\r\n            else\r\n              context = 6 * (sd[symbol].count - 1);\r\n            if (transmits[num_transmits].distance != 0xFFFFFFFF) {\r\n              EncodeGoMtf(context, 0, 1);\r\n              remove_dictionary_symbol(symbol, sd[symbol].code_length);\r\n              add_symbol_to_queue(symbol);\r\n            }\r\n            else {\r\n              EncodeGoMtf(context, 0, 0);\r\n            }\r\n          }\r\n        }\r\n        prior_is_cap = (sd[symbol].type \u0026 0x20) \u003e\u003e 5;\r\n        prior_symbol = symbol;\r\n        num_transmits++;\r\n      }\r\n      prior_end = sd[symbol].ends;\r\n#ifdef PRINTON\r\n      if (((symbol_ptr - symbol_array) \u0026 0x1FFFFF) == 0)\r\n        fprintf(stderr, \"Encoded %u of %u level 0 symbols\\r\",\r\n            (unsigned int)(symbol_ptr - symbol_array), (unsigned int)(first_define_ptr - symbol_array));\r\n#endif\r\n    }\r\n  }\r\n  else {\r\n    symbol = *symbol_ptr++;\r\n    sd[symbol].hits++;\r\n    if (embed_define_binary(symbol, 0) == 0)\r\n      return(0);\r\n\r\n    while (symbol_ptr \u003c first_define_ptr) {\r\n      symbol = *symbol_ptr++;\r\n      symbol_inst = sd[symbol].hits++;\r\n      if (symbol_inst == 0) {\r\n        EncodeNewType1(0);\r\n        if (embed_define_binary(symbol, 0) == 0)\r\n          return(0);\r\n      }\r\n      else {\r\n        if ((sd[symbol].type \u0026 0x40) != 0)\r\n          update_queue(symbol, 0);\r\n        else {\r\n          EncodeDictType1(0);\r\n          encode_dictionary_symbol(symbol);\r\n          if (sd[symbol].count \u003c= MAX_INSTANCES_FOR_REMOVE) {\r\n            if (sd[symbol].count == sd[symbol].hits)\r\n              remove_dictionary_symbol(symbol, sd[symbol].code_length);\r\n            else if (use_mtf != 0) {\r\n              if ((sd[symbol].type \u0026 2) != 0) {\r\n                if (transmits[num_transmits].distance != 0xFFFFFFFF) {\r\n                  if ((sd[symbol].hits + 1 != sd[symbol].count) || ((sd[symbol].type \u0026 0x80) != 0)) {\r\n                    EncodeGoMtf(6 * (sd[symbol].count - 1), 0, 1);\r\n                  }\r\n                  remove_dictionary_symbol(symbol, sd[symbol].code_length);\r\n                  add_symbol_to_queue(symbol);\r\n                }\r\n                else {\r\n                  EncodeGoMtf(6 * (sd[symbol].count - 1), 0, 0);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if ((sd[symbol].type \u0026 2) != 0) {\r\n            if (transmits[num_transmits].distance != 0xFFFFFFFF) {\r\n              EncodeGoMtf(6 * (sd[symbol].count - 1), 0, 1);\r\n              remove_dictionary_symbol(symbol, sd[symbol].code_length);\r\n              add_symbol_to_queue(symbol);\r\n            }\r\n            else {\r\n              EncodeGoMtf(6 * (sd[symbol].count - 1), 0, 0);\r\n            }\r\n          }\r\n        }\r\n        num_transmits++;\r\n      }\r\n      prior_end = sd[symbol].ends;\r\n#ifdef PRINTON\r\n      if (((symbol_ptr - symbol_array) \u0026 0x1FFFFF) == 0)\r\n        fprintf(stderr, \"Encoded %u of %u level 0 symbols\\r\",\r\n            (unsigned int)(symbol_ptr - symbol_array), (unsigned int)(first_define_ptr - symbol_array));\r\n#endif\r\n    }\r\n  }\r\n\r\n  // send EOF and flush output\r\n  if (cap_encoded != 0) {\r\n    EncodeDictType3(0, 4 + (sd[prior_symbol].type \u0026 0x18) + 2 * (sd[prior_symbol].type \u0026 7), prior_end);\r\n    EncodeFirstChar(end_char, (sd[prior_symbol].type \u0026 0x18) \u003e\u003e 3, prior_end);\r\n  }\r\n  else {\r\n    EncodeDictType1(0);\r\n    if (UTF8_compliant != 0)\r\n      EncodeFirstChar(end_char, 0, prior_end);\r\n    else\r\n      EncodeFirstCharBinary(end_char, prior_end);\r\n  }\r\n  code_length = bin_code_length[end_char];\r\n  EncodeShortDictionarySymbol(fbob[end_char][max_code_length], sum_nbob[end_char], nbob[end_char][code_length]);\r\n  FinishEncoder();\r\n  i = 0xFF;\r\n  if (UTF8_compliant != 0)\r\n    i = 0x90;\r\n  do {\r\n    for (j = 2 ; j \u003c= max_code_length ; j++)\r\n      free(sym_list_ptrs[i][j]);\r\n  } while (i--);\r\n  free(symbol_array);\r\n  free(sd);\r\n  free(ranked_symbols);\r\n  free(ranked_symbols2);\r\n  free(transmits);\r\n  *outsize_ptr = ReadOutCharNum();\r\n  if (fd != 0) {\r\n    size_t writesize = 0;\r\n    while (*outsize_ptr - writesize \u003e WRITE_SIZE) {\r\n      fwrite(outbuf + writesize, 1, WRITE_SIZE, fd);\r\n      writesize += WRITE_SIZE;\r\n      fflush(fd);\r\n    }\r\n    fwrite(outbuf + writesize, 1, *outsize_ptr - writesize, fd);\r\n    fflush(fd);\r\n    free(outbuf);\r\n  }\r\n  return(1);\r\n}","filepath":"glza/GLZAencode.c","line_number":1351,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3372432":{"score":0.6918855,"function_name":"count_symbols","code":"uint32_t count_symbols(uint32_t this_symbol) {\r\n  uint32_t string_symbols, *symbol_string_ptr, *end_symbol_string_ptr;\r\n  if (this_symbol \u003c start_my_symbols)\r\n    return(1);\r\n  symbol_string_ptr = symbol + sd[this_symbol].define_symbol_start_index;\r\n  end_symbol_string_ptr = symbol + sd[this_symbol+1].define_symbol_start_index - 1;\r\n\r\n  string_symbols = 0;\r\n  while (symbol_string_ptr != end_symbol_string_ptr) {\r\n    if ((sd[*symbol_string_ptr].count == 1) \u0026\u0026 (*symbol_string_ptr \u003e= start_my_symbols))\r\n      string_symbols += count_symbols(*symbol_string_ptr);\r\n    else\r\n      string_symbols++;\r\n    symbol_string_ptr++;\r\n  }\r\n  return(string_symbols);\r\n}","filepath":"glza/GLZAencode.c","line_number":1503,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3372560":{"score":0.7679663,"function_name":"get_symbol_category","code":"void get_symbol_category(uint32_t symbol_number, uint8_t *sym_type_ptr) {\r\n  if (symbol_number \u003e= start_my_symbols) {\r\n    if (sd[symbol_number].type \u0026 0x20) {\r\n      *sym_type_ptr |= 0x30;\r\n      return;\r\n    }\r\n    uint32_t * string_ptr = symbol + sd[symbol_number+1].define_symbol_start_index - 2;\r\n    get_symbol_category(*string_ptr, sym_type_ptr);\r\n    while (((*sym_type_ptr \u0026 0x10) == 0) \u0026\u0026 (string_ptr != symbol + sd[symbol_number].define_symbol_start_index))\r\n      get_symbol_category(*--string_ptr, sym_type_ptr);\r\n    if ((sd[symbol_number].type \u0026 0x10) == 0)\r\n      sd[symbol_number].type |= *sym_type_ptr \u0026 0x30;\r\n  }\r\n  else if (symbol_number == (uint32_t)' ')\r\n    *sym_type_ptr |= 0x30;\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":150,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3372800":{"score":0.80057216,"function_name":"print_string","code":"void print_string(uint32_t symbol_number) {\r\n  uint32_t *symbol_ptr, *next_symbol_ptr;\r\n  if (symbol_number \u003c start_my_symbols) {\r\n    if (UTF8_compliant) {\r\n      if (symbol_number \u003c START_UTF8_2BYTE_SYMBOLS)\r\n        printf(\"%c\",(unsigned char)symbol_number);\r\n      else if (symbol_number \u003c START_UTF8_3BYTE_SYMBOLS) {\r\n        printf(\"%c\",(unsigned char)(symbol_number \u003e\u003e 6) + 0xC0);\r\n        printf(\"%c\",(unsigned char)(symbol_number \u0026 0x3F) + 0x80);\r\n      }\r\n      else if (symbol_number \u003c START_UTF8_4BYTE_SYMBOLS) {\r\n        printf(\"%c\",(unsigned char)(symbol_number \u003e\u003e 12) + 0xE0);\r\n        printf(\"%c\",(unsigned char)((symbol_number \u003e\u003e 6) \u0026 0x3F) + 0x80);\r\n        printf(\"%c\",(unsigned char)(symbol_number \u0026 0x3F) + 0x80);\r\n      }\r\n      else {\r\n        printf(\"%c\",(unsigned char)(symbol_number \u003e\u003e 18) + 0xF0);\r\n        printf(\"%c\",(unsigned char)((symbol_number \u003e\u003e 12) \u0026 0x3F) + 0x80);\r\n        printf(\"%c\",(unsigned char)((symbol_number \u003e\u003e 6) \u0026 0x3F) + 0x80);\r\n        printf(\"%c\",(unsigned char)(symbol_number \u0026 0x3F) + 0x80);\r\n      }\r\n    }\r\n    else\r\n      printf(\"%c\",(unsigned char)symbol_number);\r\n  }\r\n  else {\r\n    symbol_ptr = symbol + sd[symbol_number].define_symbol_start_index;\r\n    next_symbol_ptr = symbol + sd[symbol_number+1].define_symbol_start_index - 1;\r\n    while (symbol_ptr != next_symbol_ptr)\r\n      print_string(*symbol_ptr++);\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":80,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3373056":{"score":0.76973915,"function_name":"count_symbols","code":"uint32_t count_symbols(uint32_t this_symbol) {\r\n  uint32_t string_symbols, *symbol_string_ptr, *end_symbol_string_ptr;\r\n  if (this_symbol \u003c start_my_symbols)\r\n    return(1);\r\n  symbol_string_ptr = symbol + sd[this_symbol].define_symbol_start_index;\r\n  end_symbol_string_ptr = symbol + sd[this_symbol+1].define_symbol_start_index - 1;\r\n\r\n  string_symbols = 0;\r\n  while (symbol_string_ptr != end_symbol_string_ptr) {\r\n    if ((sd[*symbol_string_ptr].count == 1) \u0026\u0026 (*symbol_string_ptr \u003e= start_my_symbols))\r\n      string_symbols += count_symbols(*symbol_string_ptr);\r\n    else\r\n      string_symbols++;\r\n    symbol_string_ptr++;\r\n  }\r\n  return(string_symbols);\r\n}","filepath":"glza/GLZAencode.c","line_number":1503,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3373232":{"score":0.67601293,"function_name":"get_symbol_category","code":"void get_symbol_category(uint32_t symbol_number, uint8_t *sym_type_ptr) {\r\n  if (symbol_number \u003e= start_my_symbols) {\r\n    if (sd[symbol_number].type \u0026 0x20) {\r\n      *sym_type_ptr |= 0x30;\r\n      return;\r\n    }\r\n    uint32_t * string_ptr = symbol + sd[symbol_number+1].define_symbol_start_index - 2;\r\n    get_symbol_category(*string_ptr, sym_type_ptr);\r\n    while (((*sym_type_ptr \u0026 0x10) == 0) \u0026\u0026 (string_ptr != symbol + sd[symbol_number].define_symbol_start_index))\r\n      get_symbol_category(*--string_ptr, sym_type_ptr);\r\n    if ((sd[symbol_number].type \u0026 0x10) == 0)\r\n      sd[symbol_number].type |= *sym_type_ptr \u0026 0x30;\r\n  }\r\n  else if (symbol_number == (uint32_t)' ')\r\n    *sym_type_ptr |= 0x30;\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":150,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3373280":{"score":0.8151402,"function_name":"find_first","code":"uint8_t find_first(uint32_t symbol_number) {\r\n  uint8_t first_char;\r\n  uint32_t first_symbol = symbol[sd[symbol_number].define_symbol_start_index];\r\n  if (first_symbol \u003e= start_my_symbols) {\r\n    if ((first_char = sd[first_symbol].starts) == 0) {\r\n      first_char = find_first(first_symbol);\r\n      sd[first_symbol].starts = first_char;\r\n    }\r\n    return(first_char);\r\n  }\r\n  return((uint8_t)first_symbol);\r\n}","filepath":"glza/GLZAencode.c","line_number":169,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3373376":{"score":0.8391677,"function_name":"find_first_UTF8","code":"uint8_t find_first_UTF8(uint32_t symbol_number) {\r\n  uint8_t first_char;\r\n  uint32_t first_symbol = symbol[sd[symbol_number].define_symbol_start_index];\r\n  if (first_symbol \u003e= start_my_symbols) {\r\n    if ((first_char = sd[first_symbol].starts) == 0) {\r\n      first_char = find_first_UTF8(first_symbol);\r\n      sd[first_symbol].starts = first_char;\r\n    }\r\n    return(first_char);\r\n  }\r\n  if (first_symbol \u003c 0x80)\r\n    return((uint8_t)first_symbol);\r\n  return(0x80);\r\n}","filepath":"glza/GLZAencode.c","line_number":183,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3373744":{"score":0.7793009,"function_name":"find_last","code":"uint8_t find_last(uint32_t symbol_number) {\r\n  uint8_t last_char;\r\n  uint32_t last_symbol = symbol[sd[symbol_number+1].define_symbol_start_index - 2];\r\n  if (last_symbol \u003e= start_my_symbols) {\r\n    if ((last_char = sd[last_symbol].ends) == 0) {\r\n      last_char = find_last(last_symbol);\r\n      sd[last_symbol].ends = last_char;\r\n    }\r\n    return(last_char);\r\n  }\r\n  if (cap_encoded \u0026\u0026 (last_symbol == 'B'))\r\n    return('C');\r\n  return((uint8_t)last_symbol);\r\n}","filepath":"glza/GLZAencode.c","line_number":199,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3373856":{"score":0.76734746,"function_name":"find_last_UTF8","code":"uint8_t find_last_UTF8(uint32_t symbol_number) {\r\n  uint8_t last_char;\r\n  uint32_t last_symbol = symbol[sd[symbol_number+1].define_symbol_start_index - 2];\r\n  if (last_symbol \u003e= start_my_symbols) {\r\n    if ((last_char = sd[last_symbol].ends) == 0) {\r\n      last_char = find_last_UTF8(last_symbol);\r\n      sd[last_symbol].ends = last_char;\r\n    }\r\n    return(last_char);\r\n  }\r\n  if (cap_encoded \u0026\u0026 (last_symbol == 'B'))\r\n    return('C');\r\n  if (last_symbol \u003c 0x80)\r\n    return((uint8_t)last_symbol);\r\n  return(0x80);\r\n}","filepath":"glza/GLZAencode.c","line_number":215,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3374256":{"score":0.89250064,"function_name":"add_dictionary_symbol","code":"uint8_t add_dictionary_symbol(uint32_t symbol, uint8_t bits) {\r\n  uint8_t first_char = sd[symbol].starts;\r\n  if (nsob[first_char][bits] == ((uint32_t)1 \u003c\u003c sym_list_bits[first_char][bits])) {\r\n    sym_list_bits[first_char][bits]++;\r\n    if (0 == (sym_list_ptrs[first_char][bits]\r\n        = (uint32_t *)realloc(sym_list_ptrs[first_char][bits], sizeof(uint32_t) * (1 \u003c\u003c sym_list_bits[first_char][bits])))) {\r\n      fprintf(stderr,\"FATAL ERROR - symbol list realloc failure\\n\");\r\n      return(0);\r\n    }\r\n  }\r\n  sd[symbol].array_index = nsob[first_char][bits];\r\n  sym_list_ptrs[first_char][bits][nsob[first_char][bits]++] = symbol;\r\n  if ((nsob[first_char][bits] \u003c\u003c (32 - bits)) \u003e (nbob[first_char][bits] \u003c\u003c (20 - nbob_shift[first_char]))) {\r\n    if (bits \u003e= 12 + nbob_shift[first_char]) {\r\n      nbob[first_char][bits]++;\r\n      sum_nbob[first_char]++;\r\n      for (temp_bits = bits + 1 ; temp_bits \u003c= max_code_length ; temp_bits++)\r\n        fbob[first_char][temp_bits]++;\r\n    }\r\n    else {\r\n      nbob[first_char][bits] += 1 \u003c\u003c (12 + nbob_shift[first_char] - bits);\r\n      sum_nbob[first_char] += 1 \u003c\u003c (12 + nbob_shift[first_char] - bits);\r\n      for (temp_bits = bits + 1 ; temp_bits \u003c= max_code_length ; temp_bits++)\r\n        fbob[first_char][temp_bits] += 1 \u003c\u003c (12 + nbob_shift[first_char] - bits);\r\n    }\r\n    if (sum_nbob[first_char] \u003e 0x1000) {\r\n      do {\r\n        nbob_shift[first_char]--;\r\n        uint8_t code_length;\r\n        sum_nbob[first_char] = 0;\r\n        for (code_length = 1 ; code_length \u003c= max_code_length ; code_length++)\r\n          sum_nbob[first_char] += (nbob[first_char][code_length] = (nbob[first_char][code_length] + 1) \u003e\u003e 1);\r\n      } while (sum_nbob[first_char] \u003e 0x1000);\r\n      uint16_t bin = nbob[first_char][1];\r\n      for (temp_bits = 2 ; temp_bits \u003c= max_code_length ; temp_bits++) {\r\n        fbob[first_char][temp_bits] = bin;\r\n        bin += nbob[first_char][temp_bits];\r\n      }\r\n    }\r\n  }\r\n  return(1);\r\n}","filepath":"glza/GLZAencode.c","line_number":1277,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3375280":{"score":0.7297856,"function_name":"dremove_dictionary_symbol","code":"void dremove_dictionary_symbol(uint32_t symbol, uint8_t bits) {\r\n  uint8_t first_char = symbol_strings[symbol_data[symbol].string_index];\r\n  if (UTF8_compliant \u0026\u0026 (first_char \u003e 0x80))\r\n    first_char = 0x80;\r\n  uint32_t list_length = --nsob[first_char][bits];\r\n  uint32_t last_symbol = sym_list_ptrs[first_char][bits][list_length];\r\n  sym_list_ptrs[first_char][bits][symbol_data[symbol].dictionary_index] = last_symbol;\r\n  symbol_data[last_symbol].dictionary_index = symbol_data[symbol].dictionary_index;\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":691,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3375376":{"score":0.6747336,"function_name":"add_new_symbol_to_mtfg_queue","code":"void add_new_symbol_to_mtfg_queue(uint32_t symbol_number) {\r\n  symbol_data[symbol_number].type |= 8;\r\n  mtfg_queue_8_offset = (mtfg_queue_8_offset - 1) \u0026 7;\r\n  uint32_t mtfg_queue_symbol_15 = *(mtfg_queue_8 + mtfg_queue_8_offset);\r\n  mtfg_queue_0_offset = (mtfg_queue_0_offset - 1) \u0026 7;\r\n  *(mtfg_queue_8 + mtfg_queue_8_offset) = *(mtfg_queue_0 + mtfg_queue_0_offset);\r\n  *(mtfg_queue_0 + mtfg_queue_0_offset) = symbol_number;\r\n  if (symbol_data[mtfg_queue_symbol_15].instances - DMAX_INSTANCES_FOR_MTF_QUEUE \u003e 12) {\r\n    mtfg_queue_16_offset = (mtfg_queue_16_offset - 1) \u0026 0xF;\r\n    uint32_t mtfg_queue_symbol_31 = *(mtfg_queue_16 + mtfg_queue_16_offset);\r\n    *(mtfg_queue_16 + mtfg_queue_16_offset) = mtfg_queue_symbol_15;\r\n    if (symbol_data[mtfg_queue_symbol_31].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 13) {\r\n      mtfg_queue_32_offset = (mtfg_queue_32_offset - 1) \u0026 0x1F;\r\n      uint32_t mtfg_queue_symbol_63 = *(mtfg_queue_32 + mtfg_queue_32_offset);\r\n      *(mtfg_queue_32 + mtfg_queue_32_offset) = mtfg_queue_symbol_31;\r\n      if (symbol_data[mtfg_queue_symbol_63].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 14) {\r\n        mtfg_queue_64_offset = (mtfg_queue_64_offset - 1) \u0026 0x3F;\r\n        uint32_t mtfg_queue_symbol_127 = *(mtfg_queue_64 + mtfg_queue_64_offset);\r\n        *(mtfg_queue_64 + mtfg_queue_64_offset) = mtfg_queue_symbol_63;\r\n        if (symbol_data[mtfg_queue_symbol_127].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 15) {\r\n          mtfg_queue_128_offset = (mtfg_queue_128_offset - 1) \u0026 0x3F;\r\n          uint32_t mtfg_queue_symbol_191 = *(mtfg_queue_128 + mtfg_queue_128_offset);\r\n          *(mtfg_queue_128 + mtfg_queue_128_offset) = mtfg_queue_symbol_127;\r\n          if (symbol_data[mtfg_queue_symbol_191].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 16) {\r\n            mtfg_queue_192_offset = (mtfg_queue_192_offset - 1) \u0026 0x3F;\r\n            symbol_data[*(mtfg_queue_192 + mtfg_queue_192_offset)].type \u0026= 0xF7;\r\n            *(mtfg_queue_192 + mtfg_queue_192_offset) = mtfg_queue_symbol_191;\r\n          }\r\n          else\r\n            symbol_data[mtfg_queue_symbol_191].type \u0026= 0xF7;\r\n        }\r\n        else\r\n          symbol_data[mtfg_queue_symbol_127].type \u0026= 0xF7;\r\n      }\r\n      else\r\n        symbol_data[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n    }\r\n    else\r\n      symbol_data[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n  }\r\n  else\r\n    symbol_data[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":218,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3375520":{"score":0.74381244,"function_name":"manage_mtfg_queue_prior_cap","code":"void manage_mtfg_queue_prior_cap(uint32_t symbol_number, uint8_t in_definition) {\r\n  uint8_t mtfg_queue_position = 0;\r\n  uint8_t cap_queue_position = 0;\r\n  uint8_t subqueue_position;\r\n  do {\r\n    if (symbol_number == mtfg_queue_0[mtfg_queue_position]) {\r\n      if (in_definition == 0)\r\n        EncodeMtfgType(LEVEL0_CAP);\r\n      else\r\n        EncodeMtfgType(LEVEL1_CAP);\r\n      uint8_t saved_qp = mtfg_queue_position;\r\n      mtfg_queue_position = cap_queue_position;\r\n      EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n      mtfg_queue_position = saved_qp;\r\n      while (mtfg_queue_position) {\r\n        mtfg_queue_0[mtfg_queue_position] = mtfg_queue_0[mtfg_queue_position-1];\r\n        mtfg_queue_position--;\r\n      }\r\n      mtfg_queue_0[0] = symbol_number;\r\n      break;\r\n    }\r\n    else if (sd[mtfg_queue_0[mtfg_queue_position]].type \u0026 2)\r\n      cap_queue_position++;\r\n  } while (++mtfg_queue_position != 8);\r\n  if (mtfg_queue_position == 8) {\r\n    increment_mtfg_queue_0(symbol_number);\r\n    do {\r\n      if (symbol_number == *(mtfg_queue_8 + ((mtfg_queue_position + mtfg_queue_8_offset) \u0026 7))) {\r\n        if (in_definition == 0)\r\n          EncodeMtfgType(LEVEL0_CAP);\r\n        else\r\n          EncodeMtfgType(LEVEL1_CAP);\r\n        uint8_t saved_qp = mtfg_queue_position;\r\n        mtfg_queue_position = cap_queue_position;\r\n        EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n        mtfg_queue_position = saved_qp;\r\n        subqueue_position = mtfg_queue_position - 8;\r\n        while (subqueue_position) {\r\n          *(mtfg_queue_8 + ((mtfg_queue_8_offset + subqueue_position) \u0026 7))\r\n              = *(mtfg_queue_8 + ((mtfg_queue_8_offset + subqueue_position - 1) \u0026 7));\r\n          subqueue_position--;\r\n        }\r\n        *(mtfg_queue_8 + mtfg_queue_8_offset) = mtfg_queue_symbol_7;\r\n        break;\r\n      }\r\n      else if (sd[*(mtfg_queue_8 + ((mtfg_queue_position + mtfg_queue_8_offset) \u0026 7))].type \u0026 2)\r\n        cap_queue_position++;\r\n    } while (++mtfg_queue_position != 16);\r\n    if (mtfg_queue_position == 16) {\r\n      increment_mtfg_queue_8();\r\n      do {\r\n        if (symbol_number == *(mtfg_queue_16 + ((mtfg_queue_position + mtfg_queue_16_offset) \u0026 0xF))) {\r\n          if (in_definition == 0)\r\n            EncodeMtfgType(LEVEL0_CAP);\r\n          else\r\n            EncodeMtfgType(LEVEL1_CAP);\r\n          uint8_t saved_qp = mtfg_queue_position;\r\n          mtfg_queue_position = cap_queue_position;\r\n          EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n          mtfg_queue_position = saved_qp;\r\n          if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n            sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n            remove_mtfg_queue_symbol_16(mtfg_queue_position);\r\n          }\r\n          else {\r\n            subqueue_position = mtfg_queue_position - 16;\r\n            while (subqueue_position) {\r\n              *(mtfg_queue_16 + ((mtfg_queue_16_offset + subqueue_position) \u0026 0xF))\r\n                  = *(mtfg_queue_16 + ((mtfg_queue_16_offset + subqueue_position - 1) \u0026 0xF));\r\n              subqueue_position--;\r\n            }\r\n            *(mtfg_queue_16 + mtfg_queue_16_offset) = mtfg_queue_symbol_15;\r\n          }\r\n          break;\r\n        }\r\n        else if (sd[*(mtfg_queue_16 + ((mtfg_queue_position + mtfg_queue_16_offset) \u0026 0xF))].type \u0026 2)\r\n          cap_queue_position++;\r\n      } while (++mtfg_queue_position != 32);\r\n      if (mtfg_queue_position == 32) {\r\n        do {\r\n          if (symbol_number == *(mtfg_queue_32 + ((mtfg_queue_position + mtfg_queue_32_offset) \u0026 0x1F))) {\r\n            if (in_definition == 0)\r\n              EncodeMtfgType(LEVEL0_CAP);\r\n            else\r\n              EncodeMtfgType(LEVEL1_CAP);\r\n            uint8_t saved_qp = mtfg_queue_position;\r\n            mtfg_queue_position = cap_queue_position;\r\n            EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n            mtfg_queue_position = saved_qp;\r\n            if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n              sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n              remove_mtfg_queue_symbol_32(mtfg_queue_position);\r\n            }\r\n            else {\r\n              increment_mtfg_queue_16();\r\n              if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                remove_mtfg_queue_symbol_32(mtfg_queue_position);\r\n              }\r\n              else {\r\n                subqueue_position = mtfg_queue_position - 32;\r\n                while (subqueue_position) {\r\n                  *(mtfg_queue_32 + ((mtfg_queue_32_offset + subqueue_position) \u0026 0x1F))\r\n                      = *(mtfg_queue_32 + ((mtfg_queue_32_offset + subqueue_position - 1) \u0026 0x1F));\r\n                  subqueue_position--;\r\n                }\r\n                *(mtfg_queue_32 + mtfg_queue_32_offset) = mtfg_queue_symbol_31;\r\n              }\r\n            }\r\n            break;\r\n          }\r\n          else if (sd[*(mtfg_queue_32 + ((mtfg_queue_position + mtfg_queue_32_offset) \u0026 0x1F))].type \u0026 2)\r\n            cap_queue_position++;\r\n        } while (++mtfg_queue_position != 64);\r\n        if (mtfg_queue_position == 64) {\r\n          do {\r\n            if (symbol_number == *(mtfg_queue_64 + ((mtfg_queue_position + mtfg_queue_64_offset) \u0026 0x3F))) {\r\n              if (in_definition == 0)\r\n                EncodeMtfgType(LEVEL0_CAP);\r\n              else\r\n                EncodeMtfgType(LEVEL1_CAP);\r\n              uint8_t saved_qp = mtfg_queue_position;\r\n              mtfg_queue_position = cap_queue_position;\r\n              EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n              mtfg_queue_position = saved_qp;\r\n              if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n                sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n                remove_mtfg_queue_symbol_64(mtfg_queue_position);\r\n              }\r\n              else {\r\n                increment_mtfg_queue_16();\r\n                if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                  sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                  remove_mtfg_queue_symbol_64(mtfg_queue_position);\r\n                }\r\n                else {\r\n                  increment_mtfg_queue_32();\r\n                  if (sd[mtfg_queue_symbol_63].code_length == 14) {\r\n                    sd[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n                    remove_mtfg_queue_symbol_64(mtfg_queue_position);\r\n                  }\r\n                  else {\r\n                    subqueue_position = mtfg_queue_position - 64;\r\n                    while (subqueue_position) {\r\n                      *(mtfg_queue_64 + ((mtfg_queue_64_offset + subqueue_position) \u0026 0x3F))\r\n                          = *(mtfg_queue_64 + ((mtfg_queue_64_offset + subqueue_position - 1) \u0026 0x3F));\r\n                      subqueue_position--;\r\n                    }\r\n                    *(mtfg_queue_64 + mtfg_queue_64_offset) = mtfg_queue_symbol_63;\r\n                  }\r\n                }\r\n              }\r\n              break;\r\n            }\r\n            else if (sd[*(mtfg_queue_64 + ((mtfg_queue_position + mtfg_queue_64_offset) \u0026 0x3F))].type \u0026 2)\r\n              cap_queue_position++;\r\n          } while (++mtfg_queue_position != 128);\r\n          if (mtfg_queue_position == 128) {\r\n            do {\r\n              if (symbol_number == *(mtfg_queue_128 + ((mtfg_queue_position + mtfg_queue_128_offset) \u0026 0x3F))) {\r\n                if (in_definition == 0)\r\n                  EncodeMtfgType(LEVEL0_CAP);\r\n                else\r\n                  EncodeMtfgType(LEVEL1_CAP);\r\n                uint8_t saved_qp = mtfg_queue_position;\r\n                mtfg_queue_position = cap_queue_position;\r\n                EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n                mtfg_queue_position = saved_qp;\r\n                if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n                  sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n                  remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                }\r\n                else {\r\n                  increment_mtfg_queue_16();\r\n                  if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                    sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                    remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                  }\r\n                  else {\r\n                    increment_mtfg_queue_32();\r\n                    if (sd[mtfg_queue_symbol_63].code_length == 14) {\r\n                      sd[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n                      remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                    }\r\n                    else {\r\n                      increment_mtfg_queue_64();\r\n                      if (sd[mtfg_queue_symbol_127].code_length == 15) {\r\n                        sd[mtfg_queue_symbol_127].type \u0026= 0xF7;\r\n                        remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                      }\r\n                      else {\r\n                        subqueue_position = mtfg_queue_position - 128;\r\n                        while (subqueue_position) {\r\n                          *(mtfg_queue_128 + ((mtfg_queue_128_offset + subqueue_position) \u0026 0x3F))\r\n                              = *(mtfg_queue_128 + ((mtfg_queue_128_offset + subqueue_position - 1) \u0026 0x3F));\r\n                          subqueue_position--;\r\n                        }\r\n                        *(mtfg_queue_128 + mtfg_queue_128_offset) = mtfg_queue_symbol_127;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n                break;\r\n              }\r\n              else if (sd[*(mtfg_queue_128 + ((mtfg_queue_position + mtfg_queue_128_offset) \u0026 0x3F))].type \u0026 2)\r\n                cap_queue_position++;\r\n            } while (++mtfg_queue_position != 192);\r\n            if (mtfg_queue_position == 192) {\r\n              while (symbol_number != *(mtfg_queue_192 + ((mtfg_queue_position + mtfg_queue_192_offset) \u0026 0x3F))) {\r\n                if (sd[*(mtfg_queue_192 + ((mtfg_queue_position + mtfg_queue_192_offset) \u0026 0x3F))].type \u0026 2)\r\n                  cap_queue_position++;\r\n                mtfg_queue_position++;\r\n              }\r\n              if (in_definition == 0)\r\n                EncodeMtfgType(LEVEL0_CAP);\r\n              else\r\n                EncodeMtfgType(LEVEL1_CAP);\r\n              uint8_t saved_qp = mtfg_queue_position;\r\n              mtfg_queue_position = cap_queue_position;\r\n              EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n              mtfg_queue_position = saved_qp;\r\n              if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n                sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n                remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n              }\r\n              else {\r\n                increment_mtfg_queue_16();\r\n                if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                  sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                  remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                }\r\n                else {\r\n                  increment_mtfg_queue_32();\r\n                  if (sd[mtfg_queue_symbol_63].code_length == 14) {\r\n                    sd[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n                    remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                  }\r\n                  else {\r\n                    increment_mtfg_queue_64();\r\n                    if (sd[mtfg_queue_symbol_127].code_length == 15) {\r\n                      sd[mtfg_queue_symbol_127].type \u0026= 0xF7;\r\n                      remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                    }\r\n                    else {\r\n                      increment_mtfg_queue_128();\r\n                      if (sd[mtfg_queue_symbol_191].code_length == 16) {\r\n                        sd[mtfg_queue_symbol_191].type \u0026= 0xF7;\r\n                        remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                      }\r\n                      else {\r\n                        subqueue_position = mtfg_queue_position - 192;\r\n                        while (subqueue_position) {\r\n                          *(mtfg_queue_192 + ((mtfg_queue_192_offset + subqueue_position) \u0026 0x3F))\r\n                              = *(mtfg_queue_192 + ((mtfg_queue_192_offset + subqueue_position - 1) \u0026 0x3F));\r\n                          subqueue_position--;\r\n                        }\r\n                        *(mtfg_queue_192 + mtfg_queue_192_offset) = mtfg_queue_symbol_191;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":869,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3376384":{"score":0.64759016,"function_name":"manage_mtfg_queue_prior_cap","code":"void manage_mtfg_queue_prior_cap(uint32_t symbol_number, uint8_t in_definition) {\r\n  uint8_t mtfg_queue_position = 0;\r\n  uint8_t cap_queue_position = 0;\r\n  uint8_t subqueue_position;\r\n  do {\r\n    if (symbol_number == mtfg_queue_0[mtfg_queue_position]) {\r\n      if (in_definition == 0)\r\n        EncodeMtfgType(LEVEL0_CAP);\r\n      else\r\n        EncodeMtfgType(LEVEL1_CAP);\r\n      uint8_t saved_qp = mtfg_queue_position;\r\n      mtfg_queue_position = cap_queue_position;\r\n      EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n      mtfg_queue_position = saved_qp;\r\n      while (mtfg_queue_position) {\r\n        mtfg_queue_0[mtfg_queue_position] = mtfg_queue_0[mtfg_queue_position-1];\r\n        mtfg_queue_position--;\r\n      }\r\n      mtfg_queue_0[0] = symbol_number;\r\n      break;\r\n    }\r\n    else if (sd[mtfg_queue_0[mtfg_queue_position]].type \u0026 2)\r\n      cap_queue_position++;\r\n  } while (++mtfg_queue_position != 8);\r\n  if (mtfg_queue_position == 8) {\r\n    increment_mtfg_queue_0(symbol_number);\r\n    do {\r\n      if (symbol_number == *(mtfg_queue_8 + ((mtfg_queue_position + mtfg_queue_8_offset) \u0026 7))) {\r\n        if (in_definition == 0)\r\n          EncodeMtfgType(LEVEL0_CAP);\r\n        else\r\n          EncodeMtfgType(LEVEL1_CAP);\r\n        uint8_t saved_qp = mtfg_queue_position;\r\n        mtfg_queue_position = cap_queue_position;\r\n        EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n        mtfg_queue_position = saved_qp;\r\n        subqueue_position = mtfg_queue_position - 8;\r\n        while (subqueue_position) {\r\n          *(mtfg_queue_8 + ((mtfg_queue_8_offset + subqueue_position) \u0026 7))\r\n              = *(mtfg_queue_8 + ((mtfg_queue_8_offset + subqueue_position - 1) \u0026 7));\r\n          subqueue_position--;\r\n        }\r\n        *(mtfg_queue_8 + mtfg_queue_8_offset) = mtfg_queue_symbol_7;\r\n        break;\r\n      }\r\n      else if (sd[*(mtfg_queue_8 + ((mtfg_queue_position + mtfg_queue_8_offset) \u0026 7))].type \u0026 2)\r\n        cap_queue_position++;\r\n    } while (++mtfg_queue_position != 16);\r\n    if (mtfg_queue_position == 16) {\r\n      increment_mtfg_queue_8();\r\n      do {\r\n        if (symbol_number == *(mtfg_queue_16 + ((mtfg_queue_position + mtfg_queue_16_offset) \u0026 0xF))) {\r\n          if (in_definition == 0)\r\n            EncodeMtfgType(LEVEL0_CAP);\r\n          else\r\n            EncodeMtfgType(LEVEL1_CAP);\r\n          uint8_t saved_qp = mtfg_queue_position;\r\n          mtfg_queue_position = cap_queue_position;\r\n          EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n          mtfg_queue_position = saved_qp;\r\n          if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n            sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n            remove_mtfg_queue_symbol_16(mtfg_queue_position);\r\n          }\r\n          else {\r\n            subqueue_position = mtfg_queue_position - 16;\r\n            while (subqueue_position) {\r\n              *(mtfg_queue_16 + ((mtfg_queue_16_offset + subqueue_position) \u0026 0xF))\r\n                  = *(mtfg_queue_16 + ((mtfg_queue_16_offset + subqueue_position - 1) \u0026 0xF));\r\n              subqueue_position--;\r\n            }\r\n            *(mtfg_queue_16 + mtfg_queue_16_offset) = mtfg_queue_symbol_15;\r\n          }\r\n          break;\r\n        }\r\n        else if (sd[*(mtfg_queue_16 + ((mtfg_queue_position + mtfg_queue_16_offset) \u0026 0xF))].type \u0026 2)\r\n          cap_queue_position++;\r\n      } while (++mtfg_queue_position != 32);\r\n      if (mtfg_queue_position == 32) {\r\n        do {\r\n          if (symbol_number == *(mtfg_queue_32 + ((mtfg_queue_position + mtfg_queue_32_offset) \u0026 0x1F))) {\r\n            if (in_definition == 0)\r\n              EncodeMtfgType(LEVEL0_CAP);\r\n            else\r\n              EncodeMtfgType(LEVEL1_CAP);\r\n            uint8_t saved_qp = mtfg_queue_position;\r\n            mtfg_queue_position = cap_queue_position;\r\n            EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n            mtfg_queue_position = saved_qp;\r\n            if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n              sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n              remove_mtfg_queue_symbol_32(mtfg_queue_position);\r\n            }\r\n            else {\r\n              increment_mtfg_queue_16();\r\n              if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                remove_mtfg_queue_symbol_32(mtfg_queue_position);\r\n              }\r\n              else {\r\n                subqueue_position = mtfg_queue_position - 32;\r\n                while (subqueue_position) {\r\n                  *(mtfg_queue_32 + ((mtfg_queue_32_offset + subqueue_position) \u0026 0x1F))\r\n                      = *(mtfg_queue_32 + ((mtfg_queue_32_offset + subqueue_position - 1) \u0026 0x1F));\r\n                  subqueue_position--;\r\n                }\r\n                *(mtfg_queue_32 + mtfg_queue_32_offset) = mtfg_queue_symbol_31;\r\n              }\r\n            }\r\n            break;\r\n          }\r\n          else if (sd[*(mtfg_queue_32 + ((mtfg_queue_position + mtfg_queue_32_offset) \u0026 0x1F))].type \u0026 2)\r\n            cap_queue_position++;\r\n        } while (++mtfg_queue_position != 64);\r\n        if (mtfg_queue_position == 64) {\r\n          do {\r\n            if (symbol_number == *(mtfg_queue_64 + ((mtfg_queue_position + mtfg_queue_64_offset) \u0026 0x3F))) {\r\n              if (in_definition == 0)\r\n                EncodeMtfgType(LEVEL0_CAP);\r\n              else\r\n                EncodeMtfgType(LEVEL1_CAP);\r\n              uint8_t saved_qp = mtfg_queue_position;\r\n              mtfg_queue_position = cap_queue_position;\r\n              EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n              mtfg_queue_position = saved_qp;\r\n              if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n                sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n                remove_mtfg_queue_symbol_64(mtfg_queue_position);\r\n              }\r\n              else {\r\n                increment_mtfg_queue_16();\r\n                if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                  sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                  remove_mtfg_queue_symbol_64(mtfg_queue_position);\r\n                }\r\n                else {\r\n                  increment_mtfg_queue_32();\r\n                  if (sd[mtfg_queue_symbol_63].code_length == 14) {\r\n                    sd[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n                    remove_mtfg_queue_symbol_64(mtfg_queue_position);\r\n                  }\r\n                  else {\r\n                    subqueue_position = mtfg_queue_position - 64;\r\n                    while (subqueue_position) {\r\n                      *(mtfg_queue_64 + ((mtfg_queue_64_offset + subqueue_position) \u0026 0x3F))\r\n                          = *(mtfg_queue_64 + ((mtfg_queue_64_offset + subqueue_position - 1) \u0026 0x3F));\r\n                      subqueue_position--;\r\n                    }\r\n                    *(mtfg_queue_64 + mtfg_queue_64_offset) = mtfg_queue_symbol_63;\r\n                  }\r\n                }\r\n              }\r\n              break;\r\n            }\r\n            else if (sd[*(mtfg_queue_64 + ((mtfg_queue_position + mtfg_queue_64_offset) \u0026 0x3F))].type \u0026 2)\r\n              cap_queue_position++;\r\n          } while (++mtfg_queue_position != 128);\r\n          if (mtfg_queue_position == 128) {\r\n            do {\r\n              if (symbol_number == *(mtfg_queue_128 + ((mtfg_queue_position + mtfg_queue_128_offset) \u0026 0x3F))) {\r\n                if (in_definition == 0)\r\n                  EncodeMtfgType(LEVEL0_CAP);\r\n                else\r\n                  EncodeMtfgType(LEVEL1_CAP);\r\n                uint8_t saved_qp = mtfg_queue_position;\r\n                mtfg_queue_position = cap_queue_position;\r\n                EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n                mtfg_queue_position = saved_qp;\r\n                if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n                  sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n                  remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                }\r\n                else {\r\n                  increment_mtfg_queue_16();\r\n                  if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                    sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                    remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                  }\r\n                  else {\r\n                    increment_mtfg_queue_32();\r\n                    if (sd[mtfg_queue_symbol_63].code_length == 14) {\r\n                      sd[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n                      remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                    }\r\n                    else {\r\n                      increment_mtfg_queue_64();\r\n                      if (sd[mtfg_queue_symbol_127].code_length == 15) {\r\n                        sd[mtfg_queue_symbol_127].type \u0026= 0xF7;\r\n                        remove_mtfg_queue_symbol_128(mtfg_queue_position);\r\n                      }\r\n                      else {\r\n                        subqueue_position = mtfg_queue_position - 128;\r\n                        while (subqueue_position) {\r\n                          *(mtfg_queue_128 + ((mtfg_queue_128_offset + subqueue_position) \u0026 0x3F))\r\n                              = *(mtfg_queue_128 + ((mtfg_queue_128_offset + subqueue_position - 1) \u0026 0x3F));\r\n                          subqueue_position--;\r\n                        }\r\n                        *(mtfg_queue_128 + mtfg_queue_128_offset) = mtfg_queue_symbol_127;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n                break;\r\n              }\r\n              else if (sd[*(mtfg_queue_128 + ((mtfg_queue_position + mtfg_queue_128_offset) \u0026 0x3F))].type \u0026 2)\r\n                cap_queue_position++;\r\n            } while (++mtfg_queue_position != 192);\r\n            if (mtfg_queue_position == 192) {\r\n              while (symbol_number != *(mtfg_queue_192 + ((mtfg_queue_position + mtfg_queue_192_offset) \u0026 0x3F))) {\r\n                if (sd[*(mtfg_queue_192 + ((mtfg_queue_position + mtfg_queue_192_offset) \u0026 0x3F))].type \u0026 2)\r\n                  cap_queue_position++;\r\n                mtfg_queue_position++;\r\n              }\r\n              if (in_definition == 0)\r\n                EncodeMtfgType(LEVEL0_CAP);\r\n              else\r\n                EncodeMtfgType(LEVEL1_CAP);\r\n              uint8_t saved_qp = mtfg_queue_position;\r\n              mtfg_queue_position = cap_queue_position;\r\n              EncodeMtfgQueuePos(CAP, mtfg_queue_position);\r\n              mtfg_queue_position = saved_qp;\r\n              if (sd[mtfg_queue_symbol_15].code_length \u003c= 12) {\r\n                sd[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n                remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n              }\r\n              else {\r\n                increment_mtfg_queue_16();\r\n                if (sd[mtfg_queue_symbol_31].code_length == 13) {\r\n                  sd[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n                  remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                }\r\n                else {\r\n                  increment_mtfg_queue_32();\r\n                  if (sd[mtfg_queue_symbol_63].code_length == 14) {\r\n                    sd[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n                    remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                  }\r\n                  else {\r\n                    increment_mtfg_queue_64();\r\n                    if (sd[mtfg_queue_symbol_127].code_length == 15) {\r\n                      sd[mtfg_queue_symbol_127].type \u0026= 0xF7;\r\n                      remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                    }\r\n                    else {\r\n                      increment_mtfg_queue_128();\r\n                      if (sd[mtfg_queue_symbol_191].code_length == 16) {\r\n                        sd[mtfg_queue_symbol_191].type \u0026= 0xF7;\r\n                        remove_mtfg_queue_symbol_192(mtfg_queue_position);\r\n                      }\r\n                      else {\r\n                        subqueue_position = mtfg_queue_position - 192;\r\n                        while (subqueue_position) {\r\n                          *(mtfg_queue_192 + ((mtfg_queue_192_offset + subqueue_position) \u0026 0x3F))\r\n                              = *(mtfg_queue_192 + ((mtfg_queue_192_offset + subqueue_position - 1) \u0026 0x3F));\r\n                          subqueue_position--;\r\n                        }\r\n                        *(mtfg_queue_192 + mtfg_queue_192_offset) = mtfg_queue_symbol_191;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":869,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3376816":{"score":0.87661994,"function_name":"get_mtf_overflow_position","code":"uint16_t get_mtf_overflow_position(struct symbol_data * sd, uint32_t * queue, uint16_t queue_position,\r\n    uint32_t num_transmits_over_sqrt2) {\r\n  uint16_t limit_position = 0;\r\n  if ((queue_position \u003e 0x1C) \u0026\u0026 ((sd[queue[0x1C]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 10))\r\n      \u0026\u0026 (sd[queue[0x1C]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 11))))\r\n    limit_position = 0x1C;\r\n  else if ((queue_position \u003e 0x30) \u0026\u0026 ((sd[queue[0x30]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 11))\r\n      \u0026\u0026 (sd[queue[0x30]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 12))))\r\n    limit_position = 0x30;\r\n  else if ((queue_position \u003e 0x44) \u0026\u0026 ((sd[queue[0x44]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 12))\r\n      \u0026\u0026 (sd[queue[0x44]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 13))))\r\n    limit_position = 0x44;\r\n  else if ((queue_position \u003e 0x48) \u0026\u0026 ((sd[queue[0x48]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 13))\r\n      \u0026\u0026 (sd[queue[0x48]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 14))))\r\n    limit_position = 0x48;\r\n  else if ((queue_position \u003e 0x88) \u0026\u0026 ((sd[queue[0x88]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 14))\r\n      \u0026\u0026 (sd[queue[0x88]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 15))))\r\n    limit_position = 0x88;\r\n  else if ((queue_position \u003e 0xB0) \u0026\u0026 ((sd[queue[0xB0]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 15))\r\n      \u0026\u0026 (sd[queue[0xB0]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 16))))\r\n    limit_position = 0xB0;\r\n  else if ((queue_position \u003e 0xD8) \u0026\u0026 ((sd[queue[0xD8]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 16))\r\n      \u0026\u0026 (sd[queue[0xD8]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 17))))\r\n    limit_position = 0xD8;\r\n  else if ((queue_position \u003e 0xF0) \u0026\u0026 ((sd[queue[0xF0]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 17))\r\n      \u0026\u0026 (sd[queue[0xF0]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 18))))\r\n    limit_position = 0xF0;\r\n  else if ((queue_position \u003e 0x108) \u0026\u0026 ((sd[queue[0x108]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 18))\r\n      \u0026\u0026 (sd[queue[0x108]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 19))))\r\n    limit_position = 0x108;\r\n  else if ((queue_position \u003e 0x120) \u0026\u0026 ((sd[queue[0x120]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 19))\r\n      \u0026\u0026 (sd[queue[0x120]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 20))))\r\n    limit_position = 0x120;\r\n  else if ((queue_position \u003e 0x138) \u0026\u0026 ((sd[queue[0x138]].count \u003c= (num_transmits_over_sqrt2 \u003e\u003e 20))\r\n      \u0026\u0026 (sd[queue[0x138]].count \u003e (num_transmits_over_sqrt2 \u003e\u003e 21))))\r\n    limit_position = 0x138;\r\n  return(limit_position);\r\n}","filepath":"glza/GLZAencode.c","line_number":488,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3377584":{"score":0.86727166,"function_name":"add_mtf_hit_scores","code":"void add_mtf_hit_scores(struct symbol_data * sd, uint16_t queue_position, uint32_t num_transmits_over_sqrt2) {\r\n  if (queue_position \u003c= 1)\r\n    sd-\u003ehits += 65;\r\n  else if (queue_position \u003c= 4)\r\n    sd-\u003ehits += 67 - 3 * queue_position;\r\n  else if (queue_position \u003c= 8)\r\n    sd-\u003ehits += 62 - 2 * queue_position;\r\n  else if (queue_position \u003c= 0xF)\r\n    sd-\u003ehits += 53 - queue_position;\r\n  else if (queue_position \u003c= 0x1F) {\r\n    if (sd-\u003ecount \u003c= (num_transmits_over_sqrt2 \u003e\u003e 12))\r\n      sd-\u003ehits += 45 - (queue_position \u003e\u003e 1);\r\n  }\r\n  else if (queue_position \u003c= 0x3F) {\r\n    if (sd-\u003ecount \u003c= (num_transmits_over_sqrt2 \u003e\u003e 13))\r\n      sd-\u003ehits += 37 - (queue_position \u003e\u003e 2);\r\n  }\r\n  else if (queue_position \u003c= 0x7F) {\r\n    if (sd-\u003ecount \u003c= (num_transmits_over_sqrt2 \u003e\u003e 14))\r\n      sd-\u003ehits += 29 - (queue_position \u003e\u003e 3);\r\n  }\r\n  else {\r\n    if (sd-\u003ecount \u003c= (num_transmits_over_sqrt2 \u003e\u003e 15))\r\n      sd-\u003ehits += 21 - (queue_position \u003e\u003e 4);\r\n  }\r\n}","filepath":"glza/GLZAencode.c","line_number":528,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3377840":{"score":0.6566037,"function_name":"encode_dictionary_symbol","code":"void encode_dictionary_symbol(uint32_t dsymbol) {\r\n  uint8_t first_char = sd[dsymbol].starts;\r\n  symbol_index = sd[dsymbol].array_index;\r\n  if (cap_encoded) {\r\n    if (prior_end != 0xA) {\r\n      if (sd[prior_symbol].type \u0026 0x20) {\r\n        if (sd[prior_symbol].type \u0026 0x80)\r\n          EncodeFirstChar(first_char, 2, prior_end);\r\n        else if (sd[prior_symbol].type \u0026 0x40)\r\n          EncodeFirstChar(first_char, 3, prior_end);\r\n        else\r\n          EncodeFirstChar(first_char, 1, prior_end);\r\n      }\r\n      else\r\n        EncodeFirstChar(first_char, 0, prior_end);\r\n    }\r\n  }\r\n  else if (UTF8_compliant)\r\n    EncodeFirstChar(first_char, 0, prior_end);\r\n  else \r\n    EncodeFirstCharBinary(first_char, prior_end);\r\n  if (CodeLength \u003e 12 + nbob_shift[first_char]) {\r\n    uint32_t max_codes_in_bins, mcib;\r\n    uint8_t reduce_bits = 0;\r\n    max_codes_in_bins = nbob[first_char][CodeLength] \u003c\u003c (CodeLength - (12 + nbob_shift[first_char]));\r\n    mcib = max_codes_in_bins \u003e\u003e 1;\r\n    while (mcib \u003e= nsob[first_char][CodeLength]) {\r\n      reduce_bits++;\r\n      mcib = mcib \u003e\u003e 1;\r\n    }\r\n    if (CodeLength - reduce_bits \u003e 12 + nbob_shift[first_char]) {\r\n      BinNum = fbob[first_char][CodeLength];\r\n      min_extra_reduce_index = 2 * nsob[first_char][CodeLength] - (max_codes_in_bins \u003e\u003e reduce_bits);\r\n      if (symbol_index \u003e= min_extra_reduce_index) {\r\n        uint16_t symbol_bins = 2;\r\n        BinCode = 2 * symbol_index - min_extra_reduce_index;\r\n        uint16_t code_bin = (uint16_t)(BinCode \u003e\u003e (CodeLength - (12 + nbob_shift[first_char]) - reduce_bits));\r\n        BinNum += code_bin;\r\n        BinCode -= (uint32_t)code_bin \u003c\u003c (CodeLength - (12 + nbob_shift[first_char]) - reduce_bits);\r\n        while (BinCode \u0026\u0026 (sd[sym_list_ptrs[first_char][CodeLength][--symbol_index]].type \u0026 8)) {\r\n          if (symbol_index \u003e= min_extra_reduce_index) {\r\n            symbol_bins += 2;\r\n            BinCode -= 2;\r\n          }\r\n          else {\r\n            symbol_bins++;\r\n            BinCode--;\r\n          }\r\n        }\r\n        CodeLength -= reduce_bits + nbob_shift[first_char];\r\n        EncodeLongDictionarySymbol(BinCode, BinNum, sum_nbob[first_char], CodeLength, symbol_bins);\r\n      }\r\n      else {\r\n        BinCode = symbol_index;\r\n        uint16_t symbol_bins = 1;\r\n        while ((BinCode \u0026 ((1 \u003c\u003c (CodeLength - (12 + nbob_shift[first_char]) - reduce_bits)) - 1))\r\n            \u0026\u0026 (sd[sym_list_ptrs[first_char][CodeLength][BinCode - 1]].type \u0026 8)) {\r\n          symbol_bins++;\r\n          BinCode--;\r\n        }\r\n        CodeLength -= reduce_bits + nbob_shift[first_char];\r\n        uint16_t code_bin = (uint16_t)(symbol_index \u003e\u003e (CodeLength - 12));\r\n        BinNum += code_bin;\r\n        BinCode -= (uint32_t)code_bin \u003c\u003c (CodeLength - 12);\r\n        EncodeLongDictionarySymbol(BinCode, BinNum, sum_nbob[first_char], CodeLength, symbol_bins);\r\n      }\r\n    }\r\n    else {\r\n      uint16_t symbol_bins = 1;\r\n      while (symbol_index \u0026\u0026 (sd[sym_list_ptrs[first_char][CodeLength][symbol_index - 1]].type \u0026 8)) {\r\n        symbol_bins++;\r\n        symbol_index--;\r\n      }\r\n      BinNum = fbob[first_char][CodeLength] + symbol_index;\r\n      EncodeShortDictionarySymbol(12, BinNum, sum_nbob[first_char], symbol_bins);\r\n    }\r\n  }\r\n  else {\r\n    uint16_t symbol_bins = 1;\r\n    while (symbol_index \u0026\u0026 (sd[sym_list_ptrs[first_char][CodeLength][symbol_index - 1]].type \u0026 8)) {\r\n      symbol_bins++;\r\n      symbol_index--;\r\n    }\r\n    BinNum = fbob[first_char][CodeLength] + (symbol_index \u003c\u003c (12 + nbob_shift[first_char] - CodeLength));\r\n    EncodeShortDictionarySymbol(CodeLength - nbob_shift[first_char], BinNum, sum_nbob[first_char], symbol_bins);\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":1141,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3378384":{"score":0.84392107,"function_name":"get_embedded_symbols","code":"void get_embedded_symbols(uint32_t define_symbol) {\r\n  uint32_t symbol, *define_string_ptr, *define_string_end_ptr;\r\n\r\n  if (define_symbol \u003e= num_base_symbols) {\r\n    define_string_ptr = symbol_array + sd[define_symbol].define_symbol_start_index;\r\n    define_string_end_ptr = symbol_array + sd[define_symbol + 1].define_symbol_start_index - 1;\r\n    do {\r\n      symbol = *define_string_ptr++;\r\n      sd[symbol].hits++;\r\n      if (sd[symbol].previous == 0xFFFFFFFF)\r\n        get_embedded_symbols(symbol);\r\n      else {\r\n        transmits[sd[symbol].previous].distance = num_transmits - sd[symbol].previous;\r\n        transmits[num_transmits].distance = 0xFFFFFFFF;\r\n        sd[symbol].previous2 = sd[symbol].previous;\r\n        sd[symbol].previous = num_transmits++;\r\n      }\r\n    } while (define_string_ptr != define_string_end_ptr);\r\n  }\r\n  if (sd[define_symbol].count != 1)\r\n    sd[define_symbol].previous = num_transmits++;\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":637,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3378592":{"score":0.5685346,"function_name":"add_new_symbol_to_mtfg_queue","code":"void add_new_symbol_to_mtfg_queue(uint32_t symbol_number) {\r\n  symbol_data[symbol_number].type |= 8;\r\n  mtfg_queue_8_offset = (mtfg_queue_8_offset - 1) \u0026 7;\r\n  uint32_t mtfg_queue_symbol_15 = *(mtfg_queue_8 + mtfg_queue_8_offset);\r\n  mtfg_queue_0_offset = (mtfg_queue_0_offset - 1) \u0026 7;\r\n  *(mtfg_queue_8 + mtfg_queue_8_offset) = *(mtfg_queue_0 + mtfg_queue_0_offset);\r\n  *(mtfg_queue_0 + mtfg_queue_0_offset) = symbol_number;\r\n  if (symbol_data[mtfg_queue_symbol_15].instances - DMAX_INSTANCES_FOR_MTF_QUEUE \u003e 12) {\r\n    mtfg_queue_16_offset = (mtfg_queue_16_offset - 1) \u0026 0xF;\r\n    uint32_t mtfg_queue_symbol_31 = *(mtfg_queue_16 + mtfg_queue_16_offset);\r\n    *(mtfg_queue_16 + mtfg_queue_16_offset) = mtfg_queue_symbol_15;\r\n    if (symbol_data[mtfg_queue_symbol_31].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 13) {\r\n      mtfg_queue_32_offset = (mtfg_queue_32_offset - 1) \u0026 0x1F;\r\n      uint32_t mtfg_queue_symbol_63 = *(mtfg_queue_32 + mtfg_queue_32_offset);\r\n      *(mtfg_queue_32 + mtfg_queue_32_offset) = mtfg_queue_symbol_31;\r\n      if (symbol_data[mtfg_queue_symbol_63].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 14) {\r\n        mtfg_queue_64_offset = (mtfg_queue_64_offset - 1) \u0026 0x3F;\r\n        uint32_t mtfg_queue_symbol_127 = *(mtfg_queue_64 + mtfg_queue_64_offset);\r\n        *(mtfg_queue_64 + mtfg_queue_64_offset) = mtfg_queue_symbol_63;\r\n        if (symbol_data[mtfg_queue_symbol_127].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 15) {\r\n          mtfg_queue_128_offset = (mtfg_queue_128_offset - 1) \u0026 0x3F;\r\n          uint32_t mtfg_queue_symbol_191 = *(mtfg_queue_128 + mtfg_queue_128_offset);\r\n          *(mtfg_queue_128 + mtfg_queue_128_offset) = mtfg_queue_symbol_127;\r\n          if (symbol_data[mtfg_queue_symbol_191].instances - DMAX_INSTANCES_FOR_MTF_QUEUE != 16) {\r\n            mtfg_queue_192_offset = (mtfg_queue_192_offset - 1) \u0026 0x3F;\r\n            symbol_data[*(mtfg_queue_192 + mtfg_queue_192_offset)].type \u0026= 0xF7;\r\n            *(mtfg_queue_192 + mtfg_queue_192_offset) = mtfg_queue_symbol_191;\r\n          }\r\n          else\r\n            symbol_data[mtfg_queue_symbol_191].type \u0026= 0xF7;\r\n        }\r\n        else\r\n          symbol_data[mtfg_queue_symbol_127].type \u0026= 0xF7;\r\n      }\r\n      else\r\n        symbol_data[mtfg_queue_symbol_63].type \u0026= 0xF7;\r\n    }\r\n    else\r\n      symbol_data[mtfg_queue_symbol_31].type \u0026= 0xF7;\r\n  }\r\n  else\r\n    symbol_data[mtfg_queue_symbol_15].type \u0026= 0xF7;\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":218,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3379088":{"score":0.6421125,"function_name":"count_embedded_definition_symbols","code":"void count_embedded_definition_symbols(uint32_t define_symbol) {\r\n  uint32_t *define_string_ptr, *define_string_end_ptr;\r\n  uint32_t define_symbol_instances, symbol_inst, i1, this_symbol, this_symbol_count;\r\n\r\n  if ((sd[define_symbol].count == 1) \u0026\u0026 (define_symbol \u003e= start_my_symbols)) {\r\n    // count the symbols in the string instead of creating a single instance symbol (artifacts of TreeCompress)\r\n    define_string_ptr = symbol + sd[define_symbol].define_symbol_start_index;\r\n    define_string_end_ptr = symbol + sd[define_symbol+1].define_symbol_start_index - 1;\r\n    do {\r\n      this_symbol = *define_string_ptr++;\r\n      if (define_string_ptr != symbol + sd[define_symbol].define_symbol_start_index) {\r\n        if (sd[prior_symbol].type \u0026 0x20) {\r\n          if (sd[this_symbol].starts == 0x20)\r\n            sd[prior_symbol].space_score += 2;\r\n          else\r\n            sd[prior_symbol].space_score -= 9;\r\n        }\r\n      }\r\n      symbol_inst = sd[this_symbol].inst_found++;\r\n      define_symbol_instances = sd[this_symbol].count;\r\n      if (symbol_inst == 0)\r\n        count_embedded_definition_symbols(this_symbol);\r\n      else if (define_symbol_instances \u003c= MAX_INSTANCES_FOR_MTF_QUEUE) {\r\n        update_mtf_queue(this_symbol, symbol_inst, define_symbol_instances);\r\n        prior_symbol = this_symbol;\r\n      }\r\n      else {\r\n        CodeLength = sd[this_symbol].code_length;\r\n        if (CodeLength \u003e= 11) {\r\n          if (sd[this_symbol].type \u0026 8) {\r\n            manage_mtfg_queue1(this_symbol);\r\n            sd[this_symbol].mtfg_hits++;\r\n          }\r\n          else\r\n            add_symbol_to_mtfg_queue(this_symbol);\r\n        }\r\n        prior_symbol = this_symbol;\r\n      }\r\n    } while (define_string_ptr != define_string_end_ptr);\r\n    define_string_ptr--;\r\n    sd[define_symbol].type |= sd[this_symbol].type \u0026 0x30;\r\n    while (((sd[define_symbol].type \u0026 0x10) == 0)\r\n        \u0026\u0026 (define_string_ptr-- != symbol + sd[define_symbol].define_symbol_start_index))\r\n      get_symbol_category(*define_string_ptr, \u0026sd[define_symbol].type);\r\n    return;\r\n  }\r\n\r\n  // get the symbol code length\r\n  define_symbol_instances = sd[define_symbol].count;\r\n  if (define_symbol_instances != 1) { // calculate the new code\r\n    if (define_symbol_instances \u003c= MAX_INSTANCES_FOR_MTF_QUEUE)\r\n      symbol_code_length = mtf_queue_overflow_code_length[define_symbol_instances];\r\n    else\r\n      symbol_code_length = sd[define_symbol].code_length;\r\n  }\r\n\r\n  // count the symbols in the definition\r\n  if (define_symbol \u003e= start_my_symbols) {\r\n    define_string_ptr = symbol + sd[define_symbol].define_symbol_start_index;\r\n    define_string_end_ptr = symbol + sd[define_symbol+1].define_symbol_start_index - 1;\r\n    do {\r\n      this_symbol = *define_string_ptr;\r\n      if (define_string_ptr != symbol + sd[define_symbol].define_symbol_start_index) {\r\n        if (sd[prior_symbol].type \u0026 0x20) {\r\n          if (sd[this_symbol].starts == 0x20)\r\n            sd[prior_symbol].space_score += 2;\r\n          else\r\n            sd[prior_symbol].space_score -= 9;\r\n        }\r\n      }\r\n      define_string_ptr++;\r\n      symbol_inst = sd[this_symbol].inst_found++;\r\n      this_symbol_count = sd[this_symbol].count;\r\n      if (symbol_inst == 0)\r\n        count_embedded_definition_symbols(this_symbol);\r\n      else if (this_symbol_count \u003c= MAX_INSTANCES_FOR_MTF_QUEUE) {\r\n        update_mtf_queue(this_symbol, symbol_inst, this_symbol_count);\r\n        prior_symbol = this_symbol;\r\n      }\r\n      else {\r\n        CodeLength = sd[this_symbol].code_length;\r\n        if (CodeLength \u003e= 11) {\r\n          if (sd[this_symbol].type \u0026 8) {\r\n            manage_mtfg_queue1(this_symbol);\r\n            sd[this_symbol].mtfg_hits++;\r\n          }\r\n          else\r\n            add_symbol_to_mtfg_queue(this_symbol);\r\n        }\r\n        prior_symbol = this_symbol;\r\n      }\r\n    } while (define_string_ptr != define_string_end_ptr);\r\n    define_string_ptr--;\r\n    sd[define_symbol].type |= sd[this_symbol].type \u0026 0x30;\r\n    while (((sd[define_symbol].type \u0026 0x10) == 0)\r\n        \u0026\u0026 (define_string_ptr-- != symbol + sd[define_symbol].define_symbol_start_index))\r\n      get_symbol_category(*define_string_ptr, \u0026sd[define_symbol].type);\r\n  }\r\n  else if ((define_symbol == (uint32_t)' ') || (define_symbol == (uint32_t)'C') || (define_symbol == (uint32_t)'B'))\r\n    sd[define_symbol].type |= 0x10;\r\n  prior_symbol = define_symbol;\r\n\r\n  if (define_symbol_instances != 1) { // assign symbol code\r\n    if (define_symbol_instances \u003c= MAX_INSTANCES_FOR_MTF_QUEUE) { // Handle initial mtf instance\r\n      sd[define_symbol].type |= 8;\r\n      mtf_queue_started[define_symbol_instances]++;\r\n      if (mtf_queue_started[define_symbol_instances] - mtf_queue_done[define_symbol_instances]\r\n          \u003e mtf_queue_peak[define_symbol_instances])\r\n        mtf_queue_peak[define_symbol_instances]++;\r\n      if (mtf_queue_size[define_symbol_instances] \u003c EMTF_QUEUE_SIZE)\r\n        mtf_queue[define_symbol_instances][mtf_queue_size[define_symbol_instances]++] = define_symbol;\r\n      else {\r\n        sd[mtf_queue[define_symbol_instances][0]].type \u0026= 0xF7;\r\n        for (i1=0 ; i1\u003c63 ; i1++)\r\n          mtf_queue[define_symbol_instances][i1] = mtf_queue[define_symbol_instances][i1+1];\r\n        mtf_queue[define_symbol_instances][63] = define_symbol;\r\n      }\r\n    }\r\n    else {\r\n      sd[define_symbol].mtfg_hits = 0;\r\n      sd[define_symbol].hit_score = 0;\r\n      CodeLength = sd[define_symbol].code_length;\r\n      if (CodeLength \u003e= 11)\r\n        add_symbol_to_mtfg_queue(define_symbol);\r\n    }\r\n  }\r\n  num_define_symbols_written++;\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":1522,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3381120":{"score":0.67486143,"function_name":"count_embedded_definition_symbols","code":"void count_embedded_definition_symbols(uint32_t define_symbol) {\r\n  uint32_t *define_string_ptr, *define_string_end_ptr;\r\n  uint32_t define_symbol_instances, symbol_inst, i1, this_symbol, this_symbol_count;\r\n\r\n  if ((sd[define_symbol].count == 1) \u0026\u0026 (define_symbol \u003e= start_my_symbols)) {\r\n    // count the symbols in the string instead of creating a single instance symbol (artifacts of TreeCompress)\r\n    define_string_ptr = symbol + sd[define_symbol].define_symbol_start_index;\r\n    define_string_end_ptr = symbol + sd[define_symbol+1].define_symbol_start_index - 1;\r\n    do {\r\n      this_symbol = *define_string_ptr++;\r\n      if (define_string_ptr != symbol + sd[define_symbol].define_symbol_start_index) {\r\n        if (sd[prior_symbol].type \u0026 0x20) {\r\n          if (sd[this_symbol].starts == 0x20)\r\n            sd[prior_symbol].space_score += 2;\r\n          else\r\n            sd[prior_symbol].space_score -= 9;\r\n        }\r\n      }\r\n      symbol_inst = sd[this_symbol].inst_found++;\r\n      define_symbol_instances = sd[this_symbol].count;\r\n      if (symbol_inst == 0)\r\n        count_embedded_definition_symbols(this_symbol);\r\n      else if (define_symbol_instances \u003c= MAX_INSTANCES_FOR_MTF_QUEUE) {\r\n        update_mtf_queue(this_symbol, symbol_inst, define_symbol_instances);\r\n        prior_symbol = this_symbol;\r\n      }\r\n      else {\r\n        CodeLength = sd[this_symbol].code_length;\r\n        if (CodeLength \u003e= 11) {\r\n          if (sd[this_symbol].type \u0026 8) {\r\n            manage_mtfg_queue1(this_symbol);\r\n            sd[this_symbol].mtfg_hits++;\r\n          }\r\n          else\r\n            add_symbol_to_mtfg_queue(this_symbol);\r\n        }\r\n        prior_symbol = this_symbol;\r\n      }\r\n    } while (define_string_ptr != define_string_end_ptr);\r\n    define_string_ptr--;\r\n    sd[define_symbol].type |= sd[this_symbol].type \u0026 0x30;\r\n    while (((sd[define_symbol].type \u0026 0x10) == 0)\r\n        \u0026\u0026 (define_string_ptr-- != symbol + sd[define_symbol].define_symbol_start_index))\r\n      get_symbol_category(*define_string_ptr, \u0026sd[define_symbol].type);\r\n    return;\r\n  }\r\n\r\n  // get the symbol code length\r\n  define_symbol_instances = sd[define_symbol].count;\r\n  if (define_symbol_instances != 1) { // calculate the new code\r\n    if (define_symbol_instances \u003c= MAX_INSTANCES_FOR_MTF_QUEUE)\r\n      symbol_code_length = mtf_queue_overflow_code_length[define_symbol_instances];\r\n    else\r\n      symbol_code_length = sd[define_symbol].code_length;\r\n  }\r\n\r\n  // count the symbols in the definition\r\n  if (define_symbol \u003e= start_my_symbols) {\r\n    define_string_ptr = symbol + sd[define_symbol].define_symbol_start_index;\r\n    define_string_end_ptr = symbol + sd[define_symbol+1].define_symbol_start_index - 1;\r\n    do {\r\n      this_symbol = *define_string_ptr;\r\n      if (define_string_ptr != symbol + sd[define_symbol].define_symbol_start_index) {\r\n        if (sd[prior_symbol].type \u0026 0x20) {\r\n          if (sd[this_symbol].starts == 0x20)\r\n            sd[prior_symbol].space_score += 2;\r\n          else\r\n            sd[prior_symbol].space_score -= 9;\r\n        }\r\n      }\r\n      define_string_ptr++;\r\n      symbol_inst = sd[this_symbol].inst_found++;\r\n      this_symbol_count = sd[this_symbol].count;\r\n      if (symbol_inst == 0)\r\n        count_embedded_definition_symbols(this_symbol);\r\n      else if (this_symbol_count \u003c= MAX_INSTANCES_FOR_MTF_QUEUE) {\r\n        update_mtf_queue(this_symbol, symbol_inst, this_symbol_count);\r\n        prior_symbol = this_symbol;\r\n      }\r\n      else {\r\n        CodeLength = sd[this_symbol].code_length;\r\n        if (CodeLength \u003e= 11) {\r\n          if (sd[this_symbol].type \u0026 8) {\r\n            manage_mtfg_queue1(this_symbol);\r\n            sd[this_symbol].mtfg_hits++;\r\n          }\r\n          else\r\n            add_symbol_to_mtfg_queue(this_symbol);\r\n        }\r\n        prior_symbol = this_symbol;\r\n      }\r\n    } while (define_string_ptr != define_string_end_ptr);\r\n    define_string_ptr--;\r\n    sd[define_symbol].type |= sd[this_symbol].type \u0026 0x30;\r\n    while (((sd[define_symbol].type \u0026 0x10) == 0)\r\n        \u0026\u0026 (define_string_ptr-- != symbol + sd[define_symbol].define_symbol_start_index))\r\n      get_symbol_category(*define_string_ptr, \u0026sd[define_symbol].type);\r\n  }\r\n  else if ((define_symbol == (uint32_t)' ') || (define_symbol == (uint32_t)'C') || (define_symbol == (uint32_t)'B'))\r\n    sd[define_symbol].type |= 0x10;\r\n  prior_symbol = define_symbol;\r\n\r\n  if (define_symbol_instances != 1) { // assign symbol code\r\n    if (define_symbol_instances \u003c= MAX_INSTANCES_FOR_MTF_QUEUE) { // Handle initial mtf instance\r\n      sd[define_symbol].type |= 8;\r\n      mtf_queue_started[define_symbol_instances]++;\r\n      if (mtf_queue_started[define_symbol_instances] - mtf_queue_done[define_symbol_instances]\r\n          \u003e mtf_queue_peak[define_symbol_instances])\r\n        mtf_queue_peak[define_symbol_instances]++;\r\n      if (mtf_queue_size[define_symbol_instances] \u003c EMTF_QUEUE_SIZE)\r\n        mtf_queue[define_symbol_instances][mtf_queue_size[define_symbol_instances]++] = define_symbol;\r\n      else {\r\n        sd[mtf_queue[define_symbol_instances][0]].type \u0026= 0xF7;\r\n        for (i1=0 ; i1\u003c63 ; i1++)\r\n          mtf_queue[define_symbol_instances][i1] = mtf_queue[define_symbol_instances][i1+1];\r\n        mtf_queue[define_symbol_instances][63] = define_symbol;\r\n      }\r\n    }\r\n    else {\r\n      sd[define_symbol].mtfg_hits = 0;\r\n      sd[define_symbol].hit_score = 0;\r\n      CodeLength = sd[define_symbol].code_length;\r\n      if (CodeLength \u003e= 11)\r\n        add_symbol_to_mtfg_queue(define_symbol);\r\n    }\r\n  }\r\n  num_define_symbols_written++;\r\n  return;\r\n}","filepath":"glza/GLZAencode.c","line_number":1522,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"3386208":{"score":0.71897084,"function_name":"GLZAdecode","code":"uint8_t * GLZAdecode(size_t in_size, uint8_t * inbuf, size_t * outsize_ptr, uint8_t * outbuf, FILE * fd_out,\r\n    struct param_data * params) {\r\n  uint8_t sym_type, next_write_buffer, i, j;\r\n  uint32_t new_string_index;\r\n  struct sym_data * sym_data_ptr;\r\n  pthread_t output_thread;\r\n\r\n  fd = fd_out;\r\n  stride = outbuf_index = out_buffers_sent = next_write_buffer = two_threads = 0;\r\n  dictionary_size = (uint32_t)(pow(2.0, 10.0 + 0.08 * (double)inbuf[0]));\r\n  cap_encoded = inbuf[1] \u003e\u003e 7;\r\n  UTF8_compliant = (inbuf[1] \u003e\u003e 6) \u0026 1;\r\n  use_mtf = (inbuf[1] \u003e\u003e 5) \u0026 1;\r\n  max_code_length = (inbuf[1] \u0026 0x1F) + 1;\r\n  queue_miss_code_length[1] = max_code_length;\r\n  min_code_length = (inbuf[2] \u0026 0x1F) + 1;\r\n  max_regular_code_length = max_code_length - (inbuf[3] \u0026 0x1F);\r\n  i = 2;\r\n  do {\r\n    queue_miss_code_length[i] = queue_miss_code_length[i - 1] - ((inbuf[2] \u003e\u003e (i + 4)) \u0026 1);\r\n  } while (++i != 4);\r\n  do {\r\n    queue_miss_code_length[i] = queue_miss_code_length[i - 1] - ((inbuf[3] \u003e\u003e (i + 1)) \u0026 1);\r\n  } while (++i != 7);\r\n  do {\r\n    queue_miss_code_length[i] = queue_miss_code_length[i - 1] - ((inbuf[4] \u003e\u003e (i - 7)) \u0026 1);\r\n  } while (++i != 15);\r\n  if (UTF8_compliant != 0) {\r\n    if (in_size \u003c 6) {\r\n      *outsize_ptr = 0;\r\n      return(outbuf);\r\n    }\r\n    WriteInCharNum(6);\r\n    num_base_symbols = 1 \u003c\u003c inbuf[5];\r\n    i = 0x90;\r\n  }\r\n  else {\r\n    num_base_symbols = 0x100;\r\n    delta_format = (inbuf[2] \u0026 0x20) \u003e\u003e 5;\r\n    if (delta_format != 0) {\r\n      if (in_size \u003c 6) {\r\n        *outsize_ptr = 0;\r\n        return(outbuf);\r\n      }\r\n      WriteInCharNum(6);\r\n      delta_format = inbuf[5];\r\n      if ((delta_format \u0026 0x80) == 0)\r\n        stride = (delta_format \u0026 0x3) + 1;\r\n      else\r\n        stride = delta_format \u0026 0x7F;\r\n    }\r\n    else {\r\n      if (in_size \u003c 5) {\r\n        *outsize_ptr = 0;\r\n        return(outbuf);\r\n      }\r\n      WriteInCharNum(5);\r\n    }\r\n    i = 0xFF;\r\n  }\r\n\r\n  if ((0 == (symbol_strings = (uint8_t *)malloc(dictionary_size)))\r\n      || (0 == (queue_data = (struct sym_data2 *)malloc(0x100 * sizeof(struct sym_data2))))) {\r\n    fprintf(stderr, \"ERROR - memory allocation failed\\n\");\r\n    return(0);\r\n  }\r\n\r\n  do {\r\n    for (j = max_code_length + 1 ; j \u003e= min_code_length ; j--) {\r\n      bin_data[i][j].nsob = bin_data[i][j].nbob = bin_data[i][j].fbob = 0;\r\n      bin_data[i][j].sym_list_size = 4;\r\n      if (0 == (bin_data[i][j].symbol_data = (struct sym_data *)malloc(sizeof(struct sym_data) * 4))) {\r\n        fprintf(stderr, \"ERROR - memory allocation failed\\n\");\r\n        return(0);\r\n      }\r\n    }\r\n    sum_nbob[i] = 0;\r\n    symbol_lengths[i] = 0;\r\n    bin_code_length[i] = max_code_length;\r\n  } while (i-- != 0);\r\n\r\n  uint8_t * lookup_bits_ptr = \u0026lookup_bits[0][0] + 0x100000;\r\n  while (lookup_bits_ptr-- != \u0026lookup_bits[0][0])\r\n    *lookup_bits_ptr = max_code_length;\r\n\r\n  symbol_buffer_write_ptr = symbol_buffer;\r\n  symbol_buffer_end_write_ptr = symbol_buffer_write_ptr + 0x400;\r\n  find_first_symbol = 1;\r\n  queue_offset = queue_size = queue_size_az = queue_size_space = queue_size_other = prior_is_cap = 0;\r\n  new_string_index = 0;\r\n\r\n  InitDecoder(max_code_length, i, MAX_INSTANCES_FOR_REMOVE + 1 + max_regular_code_length - min_code_length,\r\n      cap_encoded, UTF8_compliant, use_mtf, inbuf);\r\n\r\n  if ((params == 0) || (params-\u003etwo_threads != 0)) {\r\n    two_threads = 1;\r\n    atomic_init(\u0026done_parsing, 0);\r\n    atomic_init(\u0026symbol_buffer_owner[0], 0);\r\n    atomic_init(\u0026symbol_buffer_owner[1], 0);\r\n    pthread_create(\u0026output_thread, NULL, write_output_thread, outbuf);\r\n  }\r\n  else {\r\n    write_cap_on = write_cap_lock_on = skip_space_on = 0;\r\n    if (fd != 0)\r\n      out_char_ptr = out_char0 + 100;\r\n    else\r\n      out_char_ptr = outbuf;\r\n    start_char_ptr = out_char_ptr;\r\n    end_outbuf = out_char_ptr + CHARS_TO_WRITE;\r\n  }\r\n\r\n  sym_data_ptr = bin_data[0][min_code_length].symbol_data;\r\n  sym_data_ptr-\u003ebytes.type = 0;\r\n  prior_end = 0;\r\n  prior_type = 0;\r\n\r\n  if (use_mtf != 0) {\r\n    uint16_t i;\r\n    for (i = 0 ; i \u003c 0x100 ; i++)\r\n      queue_data_free_list[i] = i;\r\n  }\r\n\r\n  // main decoding loop\r\n  if (cap_encoded != 0) {\r\n    cap_symbol_defined = cap_lock_symbol_defined = 0;\r\n    sym_data_ptr = decode_new_cap_encoded(\u0026new_string_index);\r\n    *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n    while (1) {\r\n      if (symbol_buffer_write_ptr == symbol_buffer_end_write_ptr)\r\n        write_symbol_buffer(\u0026next_write_buffer);\r\n      if (prior_is_cap == 0) {\r\n        if ((sym_type = DecodeSymType3(0, 4 + 8 * (prior_type \u003e\u003e 4)\r\n            + 2 * (prior_type \u0026 7), prior_end)) == 0) { // dictionary symbol\r\n          uint8_t first_char = ' ';\r\n          if (prior_end != 0xA)\r\n            first_char = DecodeFirstChar(prior_type \u003e\u003e 4, prior_end);\r\n          uint16_t bin_num = DecodeBin(sum_nbob[first_char]);\r\n          uint8_t code_length = lookup_bits[first_char][bin_num];\r\n          if (bin_data[first_char][code_length].nsob == 0)\r\n            break; // EOF\r\n          uint32_t index = get_dictionary_symbol(bin_num, code_length, first_char);\r\n          sym_data_ptr = \u0026bin_data[first_char][code_length].symbol_data[index];\r\n          *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n          prior_is_cap = ((prior_end = sym_data_ptr-\u003ebytes.ends) == 'C');\r\n          prior_type = sym_data_ptr-\u003ebytes.type;\r\n          if (sym_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) {\r\n            if (--sym_data_ptr-\u003ebytes.remaining == 0)\r\n              dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n            else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n              if ((sym_data_ptr-\u003ebytes.remaining == 1) \u0026\u0026 ((sym_data_ptr-\u003ebytes.type \u0026 8) == 0)) {\r\n                (void)dadd_symbol_to_queue_cap_encoded(sym_data_ptr, code_length, first_char);\r\n                dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n              }\r\n              else {\r\n                uint16_t context = 6 * sym_data_ptr-\u003ebytes.repeats + (sym_data_ptr-\u003ebytes.type \u0026 1)\r\n                    + 3 * ((sym_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n                if (DecodeGoMtf(context, 0) != 0) {\r\n                  (void)dadd_symbol_to_queue_cap_encoded(sym_data_ptr, code_length, first_char);\r\n                  dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n            uint16_t context = 6 * sym_data_ptr-\u003ebytes.remaining + (sym_data_ptr-\u003ebytes.type \u0026 1)\r\n                + 3 * ((sym_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n            if (DecodeGoMtf(context, 0) != 0) {\r\n              (void)dadd_symbol_to_queue_cap_encoded(sym_data_ptr, code_length, first_char);\r\n              dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n            }\r\n          }\r\n        }\r\n        else if (sym_type == 1) {\r\n          sym_data_ptr = decode_new_cap_encoded(\u0026new_string_index);\r\n          *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n        }\r\n        else {\r\n          uint8_t mtf_first;\r\n          if (prior_end != 0xA)\r\n            mtf_first = DecodeMtfFirst((prior_type \u0026 0x30) == 0x20);\r\n          else\r\n            mtf_first = 1;\r\n          if (mtf_first == 0)\r\n            sym_data_ptr = dupdate_other_queue(DecodeMtfPosOther(queue_size_other));\r\n          else if (mtf_first == 1)\r\n            sym_data_ptr = dupdate_space_queue(DecodeMtfPosSpace(queue_size_space));\r\n          else\r\n            sym_data_ptr = dupdate_az_queue(DecodeMtfPosAz(queue_size_az));\r\n          prior_is_cap = ((prior_end = sym_data_ptr-\u003ebytes.ends) == 'C');\r\n          prior_type = sym_data_ptr-\u003ebytes.type;\r\n          *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n        }\r\n      }\r\n      else { // prior_is_cap\r\n        if ((sym_type = DecodeSymType2(2, 0x2C + (prior_type \u0026 3))) == 0) { // dictionary symbol\r\n          uint8_t first_char = DecodeFirstChar(0, 'C');\r\n          uint16_t bin_num = DecodeBin(sum_nbob[first_char]);\r\n          uint8_t code_length = lookup_bits[first_char][bin_num];\r\n          uint32_t index = get_dictionary_symbol(bin_num, code_length, first_char);\r\n          sym_data_ptr = \u0026bin_data[first_char][code_length].symbol_data[index];\r\n          *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n          prior_is_cap = ((prior_end = sym_data_ptr-\u003ebytes.ends) == 'C');\r\n          prior_type = sym_data_ptr-\u003ebytes.type;\r\n          if (sym_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) {\r\n            if (--sym_data_ptr-\u003ebytes.remaining == 0)\r\n              dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n            else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n              if ((sym_data_ptr-\u003ebytes.remaining == 1) \u0026\u0026 ((sym_data_ptr-\u003ebytes.type \u0026 8) == 0)) {\r\n                (void)dadd_symbol_to_queue_cap_encoded(sym_data_ptr, code_length, first_char);\r\n                dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n              }\r\n              else {\r\n                uint16_t context = 6 * sym_data_ptr-\u003ebytes.repeats + 1 + (sym_data_ptr-\u003ebytes.type \u0026 1)\r\n                     + 3 * ((sym_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n                if (DecodeGoMtf(context, 0) != 0) {\r\n                  (void)dadd_symbol_to_queue_cap_encoded(sym_data_ptr, code_length, first_char);\r\n                  dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n            uint16_t context = 6 * sym_data_ptr-\u003ebytes.remaining + 1 + (sym_data_ptr-\u003ebytes.type \u0026 1)\r\n                + 3 * ((sym_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n            if (DecodeGoMtf(context, 0) != 0) {\r\n              (void)dadd_symbol_to_queue_cap_encoded(sym_data_ptr, code_length, first_char);\r\n              dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n            }\r\n          }\r\n        }\r\n        else if (sym_type == 1) {\r\n          sym_data_ptr = decode_new_cap_encoded(\u0026new_string_index);\r\n          *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n        }\r\n        else {\r\n          sym_data_ptr = dupdate_az_queue(DecodeMtfPosAz(queue_size_az));\r\n          prior_is_cap = ((prior_end = sym_data_ptr-\u003ebytes.ends) == 'C');\r\n          prior_type = sym_data_ptr-\u003ebytes.type;\r\n          *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else { // not cap encoded\r\n    sym_data_ptr = decode_new(\u0026new_string_index);\r\n    *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n    while (1) {\r\n      if (symbol_buffer_write_ptr == symbol_buffer_end_write_ptr)\r\n        write_symbol_buffer(\u0026next_write_buffer);\r\n      if ((sym_type = DecodeSymType1(0)) == 0) { // dictionary symbol\r\n        uint8_t first_char;\r\n        if (UTF8_compliant != 0)\r\n          first_char = DecodeFirstChar(0, prior_end);\r\n        else\r\n          first_char = DecodeFirstCharBinary(prior_end);\r\n        uint16_t bin_num = DecodeBin(sum_nbob[first_char]);\r\n        uint8_t code_length = lookup_bits[first_char][bin_num];\r\n        if (bin_data[first_char][code_length].nsob == 0)\r\n          break; // EOF\r\n        uint32_t index = get_dictionary_symbol(bin_num, code_length, first_char);\r\n        sym_data_ptr = \u0026bin_data[first_char][code_length].symbol_data[index];\r\n        *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n        prior_end = sym_data_ptr-\u003ebytes.ends;\r\n        if (sym_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) {\r\n          if (--sym_data_ptr-\u003ebytes.remaining == 0)\r\n            dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n          else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n            if ((sym_data_ptr-\u003ebytes.remaining == 1) \u0026\u0026 ((sym_data_ptr-\u003ebytes.type \u0026 8) == 0)) {\r\n              (void)dadd_symbol_to_queue(sym_data_ptr, code_length, first_char);\r\n              dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n            }\r\n            else {\r\n              uint16_t context = 6 * sym_data_ptr-\u003ebytes.repeats;\r\n              if (DecodeGoMtf(context, 0) != 0) {\r\n                (void)dadd_symbol_to_queue(sym_data_ptr, code_length, first_char);\r\n                dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n              }\r\n            }\r\n          }\r\n\r\n        }\r\n        else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n          uint16_t context = 6 * sym_data_ptr-\u003ebytes.remaining;\r\n          if (DecodeGoMtf(context, 0) != 0) {\r\n            (void)dadd_symbol_to_queue(sym_data_ptr, code_length, first_char);\r\n            dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n          }\r\n        }\r\n      }\r\n      else if (sym_type == 1) {\r\n        sym_data_ptr = decode_new(\u0026new_string_index);\r\n        *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n      }\r\n      else {\r\n        sym_data_ptr = dupdate_queue(DecodeMtfPos(queue_size));\r\n        prior_end = sym_data_ptr-\u003ebytes.ends;\r\n        *(uint64_t *)symbol_buffer_write_ptr++ = *(uint64_t *)\u0026sym_data_ptr-\u003estring_index;\r\n      }\r\n    }\r\n  }\r\n\r\n  *symbol_buffer_write_ptr = MAX_U64_VALUE;\r\n  if (two_threads != 0)\r\n    atomic_store_explicit(\u0026done_parsing, 1, memory_order_release);\r\n  i = 0xFF;\r\n  if (UTF8_compliant != 0)\r\n    i = 0x90;\r\n  do {\r\n    for (j = max_code_length + 1 ; j \u003e= min_code_length ; j--)\r\n      free(bin_data[i][j].symbol_data);\r\n  } while (i--);\r\n  if (two_threads != 0)\r\n    pthread_join(output_thread, NULL);\r\n  else {\r\n    write_single_threaded_output();\r\n    uint32_t chars_to_write = out_char_ptr - start_char_ptr;\r\n    if (stride != 0) {\r\n      if (stride == 4)\r\n        transpose4(start_char_ptr, chars_to_write);\r\n      else if (stride == 2)\r\n        transpose2(start_char_ptr, chars_to_write);\r\n      delta_transform(start_char_ptr, chars_to_write);\r\n    }\r\n    if (fd != 0)\r\n      fwrite(start_char_ptr, 1, chars_to_write, fd);\r\n    outbuf_index += chars_to_write;\r\n  }\r\n  free(symbol_strings);\r\n  *outsize_ptr = outbuf_index;\r\n  return(outbuf);\r\n}","filepath":"glza/GLZAdecode.c","line_number":1843,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3403744":{"score":0.9024066,"function_name":"dadd_dictionary_symbol","code":"struct sym_data * dadd_dictionary_symbol(uint8_t bits, uint8_t first_char) {\r\n  struct bin_data * bin_info = \u0026bin_data[first_char][bits];\r\n  if (bin_info-\u003ensob == bin_info-\u003esym_list_size) {\r\n    bin_info-\u003esym_list_size \u003c\u003c= 1;\r\n    if (0 == (bin_info-\u003esymbol_data\r\n          = (struct sym_data *)realloc(bin_info-\u003esymbol_data, sizeof(struct sym_data) * bin_info-\u003esym_list_size))) {\r\n      fprintf(stderr, \"ERROR - memory allocation failed\\n\");\r\n      exit(EXIT_FAILURE);\r\n    }\r\n  }\r\n  if ((bin_info-\u003ensob \u003c\u003c (32 - bits)) == ((uint32_t)bin_info-\u003enbob \u003c\u003c (32 - bin_code_length[first_char]))) {\r\n    if (bits \u003e= bin_code_length[first_char]) { /* add one bin */\r\n      bin_info-\u003enbob++;\r\n      if (sum_nbob[first_char] \u003c 0x1000) {\r\n        sum_nbob[first_char]++;\r\n        if (bits != max_code_length) {\r\n          lookup_bits[first_char][bin_data[first_char][bits + 1].fbob] = bits;\r\n          while (++bits != max_code_length) {\r\n            if (bin_data[first_char][bits].nbob != 0)\r\n              lookup_bits[first_char][bin_data[first_char][bits + 1].fbob] = bits;\r\n            bin_data[first_char][bits].fbob++;\r\n          }\r\n          bin_data[first_char][max_code_length].fbob++;\r\n        }\r\n      }\r\n      else {\r\n        bin_code_length[first_char]--;\r\n        uint16_t first_max_code_length = bin_data[first_char][max_code_length].fbob;\r\n        sum_nbob[first_char]\r\n            = (bin_data[first_char][min_code_length].nbob = (bin_data[first_char][min_code_length].nbob + 1) \u003e\u003e 1);\r\n        for (bits = min_code_length + 1 ; bits \u003c= max_code_length ; bits++) {\r\n          bin_data[first_char][bits].fbob = sum_nbob[first_char];\r\n          sum_nbob[first_char] += (bin_data[first_char][bits].nbob = (bin_data[first_char][bits].nbob + 1) \u003e\u003e 1);\r\n        }\r\n        uint16_t bin = 0;\r\n        for (bits = min_code_length ; bits \u003c max_code_length ; bits++)\r\n          while (bin \u003c bin_data[first_char][bits + 1].fbob)\r\n            lookup_bits[first_char][bin++] = bits;\r\n        while (bin \u003c first_max_code_length)\r\n          lookup_bits[first_char][bin++] = max_code_length;\r\n      }\r\n    }\r\n    else { /* add multiple bins */\r\n      uint32_t new_bins = 1 \u003c\u003c (bin_code_length[first_char] - bits);\r\n      if (sum_nbob[first_char] + new_bins \u003c= 0x1000) {\r\n        bin_info-\u003enbob += new_bins;\r\n        sum_nbob[first_char] += new_bins;\r\n        if (bits != max_code_length) {\r\n          uint8_t code_length = max_code_length;\r\n          do {\r\n            bin_data[first_char][code_length--].fbob += new_bins;\r\n            uint16_t bin;\r\n            if (bin_data[first_char][code_length].nbob \u003e= new_bins)\r\n              for (bin = bin_data[first_char][code_length + 1].fbob - new_bins ;\r\n                  bin \u003c bin_data[first_char][code_length + 1].fbob ; bin++)\r\n                lookup_bits[first_char][bin] = code_length;\r\n            else\r\n              for (bin = bin_data[first_char][code_length].fbob + new_bins ;\r\n                  bin \u003c bin_data[first_char][code_length].fbob + new_bins + bin_data[first_char][code_length].nbob ; bin++)\r\n                lookup_bits[first_char][bin] = code_length;\r\n          } while (code_length \u003e bits);\r\n        }\r\n      }\r\n      else if (new_bins \u003c= 0x1000) {\r\n        bin_info-\u003enbob += new_bins;\r\n        uint16_t first_max_code_length = bin_data[first_char][max_code_length].fbob;\r\n        do {\r\n          bin_code_length[first_char]--;\r\n          sum_nbob[first_char]\r\n              = (bin_data[first_char][min_code_length].nbob = (bin_data[first_char][min_code_length].nbob + 1) \u003e\u003e 1);\r\n          for (bits = min_code_length + 1 ; bits \u003c= max_code_length ; bits++)\r\n            sum_nbob[first_char] += (bin_data[first_char][bits].nbob = (bin_data[first_char][bits].nbob + 1) \u003e\u003e 1);\r\n        } while (sum_nbob[first_char] \u003e 0x1000);\r\n        uint16_t bin = bin_data[first_char][min_code_length].nbob;\r\n        for (bits = min_code_length + 1 ; bits \u003c= max_code_length ; bits++) {\r\n          bin_data[first_char][bits].fbob = bin;\r\n          bin += bin_data[first_char][bits].nbob;\r\n        }\r\n        bin = 0;\r\n        for (bits = min_code_length ; bits \u003c max_code_length ; bits++)\r\n          while (bin \u003c bin_data[first_char][bits + 1].fbob)\r\n            lookup_bits[first_char][bin++] = bits;\r\n        while (bin \u003c first_max_code_length)\r\n          lookup_bits[first_char][bin++] = max_code_length;\r\n      }\r\n      else if (sum_nbob[first_char] == 0) {\r\n        uint8_t bin_shift = bin_code_length[first_char] - 12 - bits;\r\n        bin_code_length[first_char] -= bin_shift;\r\n        bin_info-\u003enbob = (new_bins \u003e\u003e= bin_shift);\r\n        sum_nbob[first_char] = new_bins;\r\n        uint16_t bin = 0;\r\n        while (bin \u003c sum_nbob[first_char])\r\n          lookup_bits[first_char][bin++] = bits;\r\n        while (++bits \u003c= max_code_length)\r\n          bin_data[first_char][bits].fbob = sum_nbob[first_char];\r\n      }\r\n      else {\r\n        uint16_t first_max_code_length = bin_data[first_char][max_code_length].fbob;\r\n        uint8_t bin_shift = bin_code_length[first_char] - 11 - bits;\r\n        bin_code_length[first_char] -= bin_shift;\r\n        bin_data[first_char][min_code_length].nbob = ((bin_data[first_char][min_code_length].nbob - 1) \u003e\u003e bin_shift) + 1;\r\n        sum_nbob[first_char] = bin_data[first_char][min_code_length].nbob;\r\n        uint8_t code_length;\r\n        for (code_length = min_code_length + 1 ; code_length \u003c= max_code_length ; code_length++)\r\n          sum_nbob[first_char]\r\n              += bin_data[first_char][code_length].nbob = ((bin_data[first_char][code_length].nbob - 1) \u003e\u003e bin_shift) + 1;\r\n        bin_info-\u003enbob += (new_bins \u003e\u003e= bin_shift);\r\n        sum_nbob[first_char] += new_bins;\r\n        uint16_t bin = 0;\r\n        for (bits = min_code_length + 1 ; bits \u003c= max_code_length ; bits++)\r\n          bin_data[first_char][bits].fbob = (bin += bin_data[first_char][bits - 1].nbob);\r\n        bin = 0;\r\n        for (bits = min_code_length ; bits \u003c max_code_length ; bits++)\r\n          while (bin \u003c bin_data[first_char][bits + 1].fbob)\r\n            lookup_bits[first_char][bin++] = bits;\r\n        while (bin \u003c first_max_code_length)\r\n          lookup_bits[first_char][bin++] = max_code_length;\r\n      }\r\n    }\r\n  }\r\n  return(\u0026bin_info-\u003esymbol_data[bin_info-\u003ensob++]);\r\n}","filepath":"glza/GLZAdecode.c","line_number":93,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3406144":{"score":0.804088,"function_name":"dadd_single_dictionary_symbol","code":"struct sym_data * dadd_single_dictionary_symbol(uint8_t first_char) {\r\n  struct bin_data * bin_info = \u0026bin_data[first_char][max_code_length + 1];\r\n  if (bin_info-\u003ensob == bin_info-\u003esym_list_size) {\r\n    bin_info-\u003esym_list_size \u003c\u003c= 1;\r\n    if (0 == (bin_info-\u003esymbol_data\r\n          = (struct sym_data *)realloc(bin_info-\u003esymbol_data, sizeof(struct sym_data) * bin_info-\u003esym_list_size))) {\r\n      fprintf(stderr, \"ERROR - memory allocation failed\\n\");\r\n      exit(EXIT_FAILURE);\r\n    }\r\n  }\r\n  return(\u0026bin_info-\u003esymbol_data[bin_info-\u003ensob++]);\r\n}","filepath":"glza/GLZAdecode.c","line_number":217,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3406400":{"score":0.8282895,"function_name":"dadd_symbol_to_queue","code":"struct sym_data2 * dadd_symbol_to_queue(struct sym_data *sym_data_ptr, uint8_t code_length, uint8_t first_char) {\r\n  uint8_t queue_data_index = queue_data_free_list[queue_size];\r\n  queue[(uint8_t)--queue_offset] = queue_data_index;\r\n  queue_size++;\r\n  sym_data_ptr-\u003ebytes.type |= 8;\r\n  struct sym_data2 * queue_data_ptr = \u0026queue_data[queue_data_index];\r\n  queue_data_ptr-\u003estring_index = sym_data_ptr-\u003estring_index;\r\n  queue_data_ptr-\u003estring_length = sym_data_ptr-\u003estring_length;\r\n  queue_data_ptr-\u003efour_bytes = sym_data_ptr-\u003efour_bytes;\r\n  queue_data_ptr-\u003estarts = first_char;\r\n  queue_data_ptr-\u003ecode_length = code_length;\r\n  return(queue_data_ptr);\r\n}","filepath":"glza/GLZAdecode.c","line_number":239,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3406512":{"score":0.8478879,"function_name":"dadd_symbol_to_queue_cap_encoded","code":"struct sym_data2 * dadd_symbol_to_queue_cap_encoded(struct sym_data *sym_data_ptr, uint8_t code_length,\r\n    uint8_t first_char) {\r\n  uint8_t queue_data_index = queue_data_free_list[queue_size];\r\n  queue_size++;\r\n  if ((sym_data_ptr-\u003ebytes.type \u0026 1) != 0) {\r\n    queue_az[(uint8_t)--queue_offset_az] = queue_data_index;\r\n    queue_size_az++;\r\n  }\r\n  else if (first_char == 0x20) {\r\n    queue_space[(uint8_t)--queue_offset_space] = queue_data_index;\r\n    queue_size_space++;\r\n  }\r\n  else {\r\n    queue_other[(uint8_t)--queue_offset_other] = queue_data_index;\r\n    queue_size_other++;\r\n  }\r\n  sym_data_ptr-\u003ebytes.type |= 8;\r\n  struct sym_data2 * queue_data_ptr = \u0026queue_data[queue_data_index];\r\n  queue_data_ptr-\u003estring_index = sym_data_ptr-\u003estring_index;\r\n  queue_data_ptr-\u003estring_length = sym_data_ptr-\u003estring_length;\r\n  queue_data_ptr-\u003efour_bytes = sym_data_ptr-\u003efour_bytes;\r\n  queue_data_ptr-\u003estarts = first_char;\r\n  queue_data_ptr-\u003ecode_length = code_length;\r\n  return(queue_data_ptr);\r\n}","filepath":"glza/GLZAdecode.c","line_number":254,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3406736":{"score":0.77951443,"function_name":"dupdate_az_queue","code":"struct sym_data * dupdate_az_queue(uint8_t queue_position) {\r\n  struct sym_data2 * queue_data_ptr;\r\n  uint8_t queue_data_index = queue_az[(uint8_t)(queue_position + queue_offset_az)];\r\n  queue_data_ptr = \u0026queue_data[queue_data_index];\r\n  if ((queue_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) \u0026\u0026 (--queue_data_ptr-\u003ebytes.remaining == 0)) {\r\n    queue_size--;\r\n    queue_size_az--;\r\n    queue_data_free_list[queue_size] = queue_data_index;\r\n    if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n      while (queue_position != 0) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position - 1));\r\n        queue_position--;\r\n      }\r\n      queue_offset_az++;\r\n    }\r\n    else {\r\n      while (queue_position != queue_size_az) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position + 1));\r\n        queue_position++;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    uint16_t context = 6 * queue_data_ptr-\u003ebytes.repeats + prior_is_cap + (queue_data_ptr-\u003ebytes.type \u0026 1)\r\n        + 3 * ((queue_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n    if (DecodeGoMtf(context, 1) == 0) {\r\n      queue_size--;\r\n      queue_size_az--;\r\n      queue_data_free_list[queue_size] = queue_data_index;\r\n      struct sym_data * dict_data_ptr = dadd_dictionary_symbol(queue_data_ptr-\u003ecode_length, queue_data_ptr-\u003estarts);\r\n      dict_data_ptr-\u003estring_index = queue_data_ptr-\u003estring_index;\r\n      dict_data_ptr-\u003estring_length = queue_data_ptr-\u003estring_length;\r\n      dict_data_ptr-\u003efour_bytes = queue_data_ptr-\u003efour_bytes;\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        queue_offset_az++;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        *(queue_az + queue_offset_az) = queue_data_index;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n        *(queue_az + --queue_offset_az) = queue_data_index;\r\n      }\r\n    }\r\n  }\r\n  return((struct sym_data *)queue_data_ptr);\r\n}","filepath":"glza/GLZAdecode.c","line_number":351,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3407376":{"score":0.7797786,"function_name":"dupdate_az_queue","code":"struct sym_data * dupdate_az_queue(uint8_t queue_position) {\r\n  struct sym_data2 * queue_data_ptr;\r\n  uint8_t queue_data_index = queue_az[(uint8_t)(queue_position + queue_offset_az)];\r\n  queue_data_ptr = \u0026queue_data[queue_data_index];\r\n  if ((queue_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) \u0026\u0026 (--queue_data_ptr-\u003ebytes.remaining == 0)) {\r\n    queue_size--;\r\n    queue_size_az--;\r\n    queue_data_free_list[queue_size] = queue_data_index;\r\n    if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n      while (queue_position != 0) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position - 1));\r\n        queue_position--;\r\n      }\r\n      queue_offset_az++;\r\n    }\r\n    else {\r\n      while (queue_position != queue_size_az) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position + 1));\r\n        queue_position++;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    uint16_t context = 6 * queue_data_ptr-\u003ebytes.repeats + prior_is_cap + (queue_data_ptr-\u003ebytes.type \u0026 1)\r\n        + 3 * ((queue_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n    if (DecodeGoMtf(context, 1) == 0) {\r\n      queue_size--;\r\n      queue_size_az--;\r\n      queue_data_free_list[queue_size] = queue_data_index;\r\n      struct sym_data * dict_data_ptr = dadd_dictionary_symbol(queue_data_ptr-\u003ecode_length, queue_data_ptr-\u003estarts);\r\n      dict_data_ptr-\u003estring_index = queue_data_ptr-\u003estring_index;\r\n      dict_data_ptr-\u003estring_length = queue_data_ptr-\u003estring_length;\r\n      dict_data_ptr-\u003efour_bytes = queue_data_ptr-\u003efour_bytes;\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        queue_offset_az++;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        *(queue_az + queue_offset_az) = queue_data_index;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n        *(queue_az + --queue_offset_az) = queue_data_index;\r\n      }\r\n    }\r\n  }\r\n  return((struct sym_data *)queue_data_ptr);\r\n}","filepath":"glza/GLZAdecode.c","line_number":351,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3408048":{"score":0.7767182,"function_name":"dupdate_az_queue","code":"struct sym_data * dupdate_az_queue(uint8_t queue_position) {\r\n  struct sym_data2 * queue_data_ptr;\r\n  uint8_t queue_data_index = queue_az[(uint8_t)(queue_position + queue_offset_az)];\r\n  queue_data_ptr = \u0026queue_data[queue_data_index];\r\n  if ((queue_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) \u0026\u0026 (--queue_data_ptr-\u003ebytes.remaining == 0)) {\r\n    queue_size--;\r\n    queue_size_az--;\r\n    queue_data_free_list[queue_size] = queue_data_index;\r\n    if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n      while (queue_position != 0) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position - 1));\r\n        queue_position--;\r\n      }\r\n      queue_offset_az++;\r\n    }\r\n    else {\r\n      while (queue_position != queue_size_az) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position + 1));\r\n        queue_position++;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    uint16_t context = 6 * queue_data_ptr-\u003ebytes.repeats + prior_is_cap + (queue_data_ptr-\u003ebytes.type \u0026 1)\r\n        + 3 * ((queue_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n    if (DecodeGoMtf(context, 1) == 0) {\r\n      queue_size--;\r\n      queue_size_az--;\r\n      queue_data_free_list[queue_size] = queue_data_index;\r\n      struct sym_data * dict_data_ptr = dadd_dictionary_symbol(queue_data_ptr-\u003ecode_length, queue_data_ptr-\u003estarts);\r\n      dict_data_ptr-\u003estring_index = queue_data_ptr-\u003estring_index;\r\n      dict_data_ptr-\u003estring_length = queue_data_ptr-\u003estring_length;\r\n      dict_data_ptr-\u003efour_bytes = queue_data_ptr-\u003efour_bytes;\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        queue_offset_az++;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        *(queue_az + queue_offset_az) = queue_data_index;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n        *(queue_az + --queue_offset_az) = queue_data_index;\r\n      }\r\n    }\r\n  }\r\n  return((struct sym_data *)queue_data_ptr);\r\n}","filepath":"glza/GLZAdecode.c","line_number":351,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3408720":{"score":0.7847594,"function_name":"dupdate_az_queue","code":"struct sym_data * dupdate_az_queue(uint8_t queue_position) {\r\n  struct sym_data2 * queue_data_ptr;\r\n  uint8_t queue_data_index = queue_az[(uint8_t)(queue_position + queue_offset_az)];\r\n  queue_data_ptr = \u0026queue_data[queue_data_index];\r\n  if ((queue_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) \u0026\u0026 (--queue_data_ptr-\u003ebytes.remaining == 0)) {\r\n    queue_size--;\r\n    queue_size_az--;\r\n    queue_data_free_list[queue_size] = queue_data_index;\r\n    if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n      while (queue_position != 0) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position - 1));\r\n        queue_position--;\r\n      }\r\n      queue_offset_az++;\r\n    }\r\n    else {\r\n      while (queue_position != queue_size_az) {\r\n        *(queue_az + (uint8_t)(queue_offset_az + queue_position))\r\n            = *(queue_az + (uint8_t)(queue_offset_az + queue_position + 1));\r\n        queue_position++;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    uint16_t context = 6 * queue_data_ptr-\u003ebytes.repeats + prior_is_cap + (queue_data_ptr-\u003ebytes.type \u0026 1)\r\n        + 3 * ((queue_data_ptr-\u003ebytes.type \u003e\u003e 4) == 2);\r\n    if (DecodeGoMtf(context, 1) == 0) {\r\n      queue_size--;\r\n      queue_size_az--;\r\n      queue_data_free_list[queue_size] = queue_data_index;\r\n      struct sym_data * dict_data_ptr = dadd_dictionary_symbol(queue_data_ptr-\u003ecode_length, queue_data_ptr-\u003estarts);\r\n      dict_data_ptr-\u003estring_index = queue_data_ptr-\u003estring_index;\r\n      dict_data_ptr-\u003estring_length = queue_data_ptr-\u003estring_length;\r\n      dict_data_ptr-\u003efour_bytes = queue_data_ptr-\u003efour_bytes;\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        queue_offset_az++;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (queue_position \u003c= (queue_size_az \u003e\u003e 1)) {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != queue_offset_az) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position - 1));\r\n          queue_position--;\r\n        }\r\n        *(queue_az + queue_offset_az) = queue_data_index;\r\n      }\r\n      else {\r\n        queue_position += queue_offset_az;\r\n        while (queue_position != (uint8_t)(queue_offset_az + queue_size_az)) {\r\n          *(queue_az + queue_position) = *(queue_az + (uint8_t)(queue_position + 1));\r\n          queue_position++;\r\n        }\r\n        *(queue_az + --queue_offset_az) = queue_data_index;\r\n      }\r\n    }\r\n  }\r\n  return((struct sym_data *)queue_data_ptr);\r\n}","filepath":"glza/GLZAdecode.c","line_number":351,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3409392":{"score":0.8250365,"function_name":"get_dictionary_symbol","code":"uint32_t get_dictionary_symbol(uint16_t bin_num, uint8_t code_length, uint8_t first_char) {\r\n  uint32_t temp_index;\r\n  uint16_t bins_per_symbol, extra_bins, end_extra_index;\r\n  struct bin_data * bin_info = \u0026bin_data[first_char][code_length];\r\n  uint32_t num_symbols = bin_info-\u003ensob;\r\n  uint16_t num_bins = bin_info-\u003enbob;\r\n  uint32_t index = bin_num - bin_info-\u003efbob;\r\n  if (code_length \u003e bin_code_length[first_char]) {\r\n    uint32_t min_extra_reduce_index;\r\n    int8_t index_bits = code_length - bin_code_length[first_char];\r\n    uint32_t shifted_max_symbols = num_bins \u003c\u003c (index_bits - 1);\r\n    if (shifted_max_symbols \u003e= num_symbols) {\r\n      shifted_max_symbols \u003e\u003e= 1;\r\n      while (shifted_max_symbols \u003e= num_symbols) {\r\n        shifted_max_symbols \u003e\u003e= 1;\r\n        index_bits--;\r\n      }\r\n      if (--index_bits \u003c= 0) {\r\n        if (index_bits == 0) {\r\n          extra_bins = num_bins - num_symbols;\r\n          if (index \u003e= 2 * extra_bins)\r\n            index -= extra_bins;\r\n          else {\r\n            IncreaseRange(index \u0026 1, 2);\r\n            index \u003e\u003e= 1;\r\n          }\r\n        }\r\n        else {\r\n          bins_per_symbol = num_bins / num_symbols;\r\n          extra_bins = num_bins - num_symbols * bins_per_symbol;\r\n          end_extra_index = extra_bins * (bins_per_symbol + 1);\r\n          if (index \u003e= end_extra_index) {\r\n            temp_index = index - end_extra_index;\r\n            index = temp_index / bins_per_symbol;\r\n            IncreaseRange(temp_index - index * bins_per_symbol, bins_per_symbol);\r\n            index += extra_bins;\r\n          }\r\n          else {\r\n            temp_index = index;\r\n            index = temp_index / ++bins_per_symbol;\r\n            IncreaseRange(temp_index - index * bins_per_symbol, bins_per_symbol);\r\n          }\r\n        }\r\n        return(index);\r\n      }\r\n    }\r\n    min_extra_reduce_index = (num_symbols - shifted_max_symbols) \u003c\u003c 1;\r\n    index \u003c\u003c= index_bits;\r\n    uint32_t bin_code = DecodeBinCode(index_bits);\r\n    index += bin_code;\r\n    if (index \u003e= min_extra_reduce_index) {\r\n      index = (index + min_extra_reduce_index) \u003e\u003e 1;\r\n      IncreaseRange(bin_code \u0026 1, 2);\r\n    }\r\n    return(index);\r\n  }\r\n  uint8_t bin_shift = bin_code_length[first_char] - code_length;\r\n  if ((num_symbols \u003c\u003c bin_shift) == num_bins) {  // the bins are full\r\n    temp_index = index;\r\n    IncreaseRange(temp_index - ((index \u003e\u003e= bin_shift) \u003c\u003c bin_shift), 1 \u003c\u003c bin_shift);\r\n    return(index);\r\n  }\r\n  if (num_bins \u003c 2 * num_symbols) {\r\n    extra_bins = num_bins - num_symbols;\r\n    if (index \u003e= 2 * extra_bins) {\r\n      index -= extra_bins;\r\n      return(index);\r\n    }\r\n    IncreaseRange(index \u0026 1, 2);\r\n    return(index \u003e\u003e 1);\r\n  }\r\n  bins_per_symbol = num_bins / num_symbols;\r\n  extra_bins = num_bins - num_symbols * bins_per_symbol;\r\n  end_extra_index = extra_bins * (bins_per_symbol + 1);\r\n  if (index \u003e= end_extra_index) {\r\n    temp_index = index - end_extra_index;\r\n    index = temp_index / bins_per_symbol;\r\n    IncreaseRange(temp_index - index * bins_per_symbol, bins_per_symbol);\r\n    index += extra_bins;\r\n    return(index);\r\n  }\r\n  else {\r\n    temp_index = index;\r\n    index /= ++bins_per_symbol;\r\n    IncreaseRange(temp_index - index * bins_per_symbol, bins_per_symbol);\r\n  }\r\n  return(index);\r\n}","filepath":"glza/GLZAdecode.c","line_number":573,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3409920":{"score":0.89885724,"function_name":"get_extra_length","code":"uint32_t get_extra_length() {\r\n  uint8_t extras = 0;\r\n  uint32_t SymsInDef;\r\n  uint8_t code;\r\n  do {\r\n    extras++;\r\n    code = DecodeExtraLength();\r\n  } while (code == 3);\r\n  if (code == 2) {\r\n    extras++;\r\n    SymsInDef = 1;\r\n  }\r\n  else\r\n    SymsInDef = 2 + code;\r\n  while (--extras != 0)\r\n    SymsInDef = (SymsInDef \u003c\u003c 2) + DecodeExtraLength();\r\n  return(SymsInDef + 14);\r\n}","filepath":"glza/GLZAdecode.c","line_number":663,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3410016":{"score":0.91654164,"function_name":"delta_transform","code":"void delta_transform(uint8_t * buffer, uint32_t len) {\r\n  uint8_t * char_ptr = buffer;\r\n  if (out_buffers_sent == 0) {\r\n    if (stride \u003e 4) {\r\n      char_ptr = buffer + 1;\r\n      do {\r\n        *char_ptr += *(char_ptr - 1);\r\n      } while (++char_ptr \u003c buffer + stride);\r\n    }\r\n    char_ptr = buffer + stride;\r\n    len -= stride;\r\n  }\r\n  if (stride == 1) {\r\n    while (len-- != 0) {\r\n      *char_ptr += *(char_ptr - 1);\r\n      char_ptr++;\r\n    }\r\n  }\r\n  else if (stride == 2) {\r\n    while (len-- != 0) {\r\n      if ((delta_format \u0026 4) == 0) {\r\n        *char_ptr += *(char_ptr - 2);\r\n        char_ptr++;\r\n      }\r\n      else {\r\n        char_ptr++;\r\n        if (((char_ptr - buffer) \u0026 1) == 0) {\r\n          if ((delta_format \u0026 8) == 0) {\r\n            uint32_t value = (*(char_ptr - 4) \u003c\u003c 8) + *(char_ptr - 3) + (*(char_ptr - 2) \u003c\u003c 8) + *(char_ptr - 1) - 0x80;\r\n            *(char_ptr - 2) = (value \u003e\u003e 8) \u0026 0xFF;\r\n            *(char_ptr - 1) = value \u0026 0xFF;\r\n          }\r\n          else {\r\n            uint32_t value = (*(char_ptr - 3) \u003c\u003c 8) + *(char_ptr - 4) + (*(char_ptr - 1) \u003c\u003c 8) + *(char_ptr - 2) - 0x80;\r\n            *(char_ptr - 1) = (value \u003e\u003e 8) \u0026 0xFF;\r\n            *(char_ptr - 2) = value \u0026 0xFF;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else if (stride == 3) {\r\n    while (len-- != 0) {\r\n      *char_ptr += *(char_ptr - 3);\r\n      char_ptr++;\r\n    }\r\n  }\r\n  else if (stride == 4) {\r\n    while (len-- != 0) {\r\n      char_ptr++;\r\n      if ((delta_format \u0026 4) == 0) {\r\n        *(char_ptr - 1) += *(char_ptr - 5);\r\n      }\r\n      else if ((delta_format \u0026 0x10) != 0) {\r\n        if (((char_ptr - buffer) \u0026 1) == 0) {\r\n          if ((delta_format \u0026 8) == 0) {\r\n            uint32_t value = (*(char_ptr - 6) \u003c\u003c 8) + *(char_ptr - 5) + (*(char_ptr - 2) \u003c\u003c 8) + *(char_ptr - 1) - 0x80;\r\n            *(char_ptr - 2) = (value \u003e\u003e 8) \u0026 0xFF;\r\n            *(char_ptr - 1) = value \u0026 0xFF;\r\n          }\r\n          else {\r\n            uint32_t value = (*(char_ptr - 5) \u003c\u003c 8) + *(char_ptr - 6) + (*(char_ptr - 1) \u003c\u003c 8) + *(char_ptr - 2) - 0x80;\r\n            *(char_ptr - 1) = (value \u003e\u003e 8) \u0026 0xFF;\r\n            *(char_ptr - 2) = value \u0026 0xFF;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        if (((char_ptr - buffer) \u0026 3) == 0) {\r\n          if ((delta_format \u0026 8) == 0) {\r\n            uint32_t value = (*(char_ptr - 8) \u003c\u003c 24) + (*(char_ptr - 7) \u003c\u003c 16) + (*(char_ptr - 6) \u003c\u003c 8) + *(char_ptr - 5)\r\n                + (*(char_ptr - 4) \u003c\u003c 24) + (*(char_ptr - 3) \u003c\u003c 16) + (*(char_ptr - 2) \u003c\u003c 8) + *(char_ptr - 1) - 0x808080;\r\n            *(char_ptr - 4) = value \u003e\u003e 24;\r\n            *(char_ptr - 3) = (value \u003e\u003e 16) \u0026 0xFF;\r\n            *(char_ptr - 2) = (value \u003e\u003e 8) \u0026 0xFF;\r\n            *(char_ptr - 1) = value \u0026 0xFF;\r\n          }\r\n          else {\r\n            uint32_t value = (*(char_ptr - 5) \u003c\u003c 24) + (*(char_ptr - 6) \u003c\u003c 16) + (*(char_ptr - 7) \u003c\u003c 8) + *(char_ptr - 8)\r\n                + (*(char_ptr - 1) \u003c\u003c 24) + (*(char_ptr - 2) \u003c\u003c 16) + (*(char_ptr - 3) \u003c\u003c 8) + *(char_ptr - 4) - 0x808080;\r\n            *(char_ptr - 1) = value \u003e\u003e 24;\r\n            *(char_ptr - 2) = (value \u003e\u003e 16) \u0026 0xFF;\r\n            *(char_ptr - 3) = (value \u003e\u003e 8) \u0026 0xFF;\r\n            *(char_ptr - 4) = value \u0026 0xFF;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    while (len-- != 0) {\r\n      *char_ptr += *(char_ptr - stride);\r\n      char_ptr++;\r\n    }\r\n  }\r\n}","filepath":"glza/GLZAdecode.c","line_number":683,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3410864":{"score":0.794354,"function_name":"create_extended_UTF8_symbol","code":"uint8_t create_extended_UTF8_symbol(uint32_t base_symbol, uint32_t * string_index_ptr) {\r\n  if (base_symbol \u003c START_UTF8_3BYTE_SYMBOLS) {\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)(base_symbol \u003e\u003e 6) + 0xC0;\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)(base_symbol \u0026 0x3F) + 0x80;\r\n    if (base_symbol \u003c 0x250)\r\n      return(0x80);\r\n    else if (base_symbol \u003c 0x370)\r\n      return(0x81);\r\n    else if (base_symbol \u003c 0x400)\r\n      return(0x82);\r\n    else if (base_symbol \u003c 0x530)\r\n      return(0x83);\r\n    else if (base_symbol \u003c 0x590)\r\n      return(0x84);\r\n    else if (base_symbol \u003c 0x600)\r\n      return(0x85);\r\n    else if (base_symbol \u003c 0x700)\r\n      return(0x86);\r\n    else\r\n      return(0x87);\r\n  }\r\n  else if (base_symbol \u003c START_UTF8_4BYTE_SYMBOLS) {\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)(base_symbol \u003e\u003e 12) + 0xE0;\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)((base_symbol \u003e\u003e 6) \u0026 0x3F) + 0x80;\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)(base_symbol \u0026 0x3F) + 0x80;\r\n    if (base_symbol \u003c 0x1000)\r\n      return(0x88);\r\n    else if (base_symbol \u003c 0x2000)\r\n      return(0x89);\r\n    else if (base_symbol \u003c 0x3000)\r\n      return(0x8A);\r\n    else if (base_symbol \u003c 0x3040)\r\n      return(0x8B);\r\n    else if (base_symbol \u003c 0x30A0)\r\n      return(0x8C);\r\n    else if (base_symbol \u003c 0x3100)\r\n      return(0x8D);\r\n    else if (base_symbol \u003c 0x3200)\r\n      return(0x8E);\r\n    else if (base_symbol \u003c 0xA000)\r\n      return(0x8F);\r\n    else\r\n      return(0x8E);\r\n  }\r\n  else {\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)(base_symbol \u003e\u003e 18) + 0xF0;\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)((base_symbol \u003e\u003e 12) \u0026 0x3F) + 0x80;\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)((base_symbol \u003e\u003e 6) \u0026 0x3F) + 0x80;\r\n    symbol_strings[(*string_index_ptr)++] = (uint8_t)(base_symbol \u0026 0x3F) + 0x80;\r\n    return(0x90);\r\n  }\r\n}","filepath":"glza/GLZAdecode.c","line_number":781,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3411264":{"score":0.8744292,"function_name":"get_first_char","code":"uint8_t get_first_char(uint32_t index) {\r\n  uint32_t UTF8_chars = (symbol_strings[index] \u003c\u003c 8) + symbol_strings[index + 1];\r\n  if (UTF8_chars \u003c 0xE000) {\r\n    if (UTF8_chars \u003c 0xC990)\r\n      return(0x80);\r\n    else if (UTF8_chars \u003c 0xCDB0)\r\n      return(0x81);\r\n    else if (UTF8_chars \u003c 0xD000)\r\n      return(0x82);\r\n    else if (UTF8_chars \u003c 0xD4B0)\r\n      return(0x83);\r\n    else if (UTF8_chars \u003c 0xD690)\r\n      return(0x84);\r\n    else if (UTF8_chars \u003c 0xD800)\r\n      return(0x85);\r\n    else if (UTF8_chars \u003c 0xDC00)\r\n      return(0x86);\r\n    else\r\n      return(0x87);\r\n  }\r\n  else if (UTF8_chars \u003c 0xE100)\r\n    return(0x88);\r\n  else if (UTF8_chars \u003c 0xE200)\r\n    return(0x89);\r\n  else if (UTF8_chars \u003c 0xE300)\r\n    return(0x8A);\r\n  else if (UTF8_chars \u003c 0xE381)\r\n    return(0x8B);\r\n  else {\r\n    UTF8_chars = (UTF8_chars \u003c\u003c 8) + symbol_strings[index + 2];\r\n    if (UTF8_chars \u003c 0xE382A0)\r\n      return(0x8C);\r\n    else if (UTF8_chars \u003c 0xE38400)\r\n      return(0x8D);\r\n    else if (UTF8_chars \u003c 0xE38800)\r\n      return(0x8E);\r\n    else if (UTF8_chars \u003c 0xEA0000)\r\n      return(0x8F);\r\n    else if (UTF8_chars \u003c 0xF00000)\r\n      return(0x8E);\r\n    else\r\n      return(0x90);\r\n  }\r\n}","filepath":"glza/GLZAdecode.c","line_number":835,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3411536":{"score":0.6371763,"function_name":"decode_new","code":"struct sym_data * decode_new(uint32_t * string_index_ptr) {\r\n  uint8_t SID_symbol, sym_type, first_char;\r\n  uint8_t put_in_mtf = 0;\r\n  uint32_t symbols_in_definition, end_string_index;\r\n  struct sym_data * sym_data_ptr;\r\n  struct sym_data2 temp_sym_data;\r\n\r\n  temp_sym_data.string_index = *string_index_ptr;\r\n  end_string_index = *string_index_ptr;\r\n  SID_symbol = DecodeSID(NOT_CAP);\r\n  if (SID_symbol == 0) {\r\n    temp_sym_data.bytes.repeats = DecodeINST(NOT_CAP, SID_symbol);\r\n    if (temp_sym_data.bytes.repeats \u003c MAX_INSTANCES_FOR_REMOVE - 1)\r\n      temp_sym_data.code_length = queue_miss_code_length[++temp_sym_data.bytes.repeats];\r\n    else if (temp_sym_data.bytes.repeats \u003e= MAX_INSTANCES_FOR_REMOVE) {\r\n      temp_sym_data.code_length = max_regular_code_length + MAX_INSTANCES_FOR_REMOVE - temp_sym_data.bytes.repeats;\r\n      temp_sym_data.bytes.repeats = temp_sym_data.code_length + MAX_INSTANCES_FOR_REMOVE - 1;\r\n    }\r\n    else {\r\n      temp_sym_data.bytes.repeats = 0;\r\n      temp_sym_data.code_length = max_code_length + 1;\r\n    }\r\n    uint32_t base_symbol = DecodeBaseSymbol(num_base_symbols);\r\n    if ((UTF8_compliant == 0) || (base_symbol \u003c START_UTF8_2BYTE_SYMBOLS)) {\r\n      if ((base_symbol \u0026 1) != 0) {\r\n        if (symbol_lengths[base_symbol] != 0) {\r\n          base_symbol--;\r\n          DoubleRangeDown();\r\n        }\r\n        else if (symbol_lengths[base_symbol - 1] != 0)\r\n          DoubleRangeDown();\r\n      }\r\n      else if (symbol_lengths[base_symbol] != 0) {\r\n        base_symbol++;\r\n        DoubleRange();\r\n      }\r\n      else if (symbol_lengths[base_symbol + 1] != 0)\r\n        DoubleRange();\r\n    }\r\n    temp_sym_data.bytes.type = 0;\r\n\r\n    if (UTF8_compliant != 0) {\r\n      if (base_symbol \u003c START_UTF8_2BYTE_SYMBOLS) {\r\n        symbol_strings[end_string_index++] = prior_end = (uint8_t)base_symbol;\r\n        temp_sym_data.string_length = 1;\r\n      }\r\n      else {\r\n        prior_end = create_extended_UTF8_symbol(base_symbol, \u0026end_string_index);\r\n        temp_sym_data.string_length = end_string_index - temp_sym_data.string_index;\r\n      }\r\n      if (symbol_lengths[prior_end] == 0) {\r\n        symbol_lengths[prior_end] = temp_sym_data.code_length;\r\n        uint8_t j1 = 0x90;\r\n        do {\r\n          InitFirstCharBin(j1, prior_end, temp_sym_data.code_length, cap_symbol_defined, cap_lock_symbol_defined);\r\n        } while (j1-- != 0);\r\n        j1 = 0x90;\r\n        do {\r\n          if (symbol_lengths[j1] != 0)\r\n            InitTrailingCharBin(prior_end, j1, symbol_lengths[j1]);\r\n        } while (j1-- != 0);\r\n        InitFreqFirstChar(prior_end, prior_end);\r\n      }\r\n    }\r\n    else {\r\n      symbol_strings[end_string_index++] = prior_end = (uint8_t)base_symbol;\r\n      temp_sym_data.string_length = 1;\r\n      symbol_lengths[prior_end] = temp_sym_data.code_length;\r\n      uint8_t j1 = 0xFF;\r\n      do {\r\n        InitFirstCharBinBinary(j1, prior_end, temp_sym_data.code_length);\r\n      } while (j1-- != 0);\r\n      InitTrailingCharBinary(prior_end, symbol_lengths);\r\n    }\r\n    temp_sym_data.starts = temp_sym_data.bytes.ends = prior_end;\r\n\r\n    if (find_first_symbol != 0) {\r\n      find_first_symbol = 0;\r\n      sum_nbob[prior_end] = bin_data[prior_end][max_code_length].nbob = 1;\r\n    }\r\n    if (temp_sym_data.bytes.repeats == 0) {\r\n      sym_data_ptr = dadd_single_dictionary_symbol(temp_sym_data.starts);\r\n      sym_data_ptr-\u003ebytes.type = 0;\r\n      sym_data_ptr-\u003estring_index = temp_sym_data.string_index;\r\n      sym_data_ptr-\u003estring_length = temp_sym_data.string_length;\r\n      *string_index_ptr = end_string_index;\r\n      return(sym_data_ptr);\r\n    }\r\n\r\n    temp_sym_data.bytes.remaining = temp_sym_data.bytes.repeats;\r\n    if (temp_sym_data.bytes.repeats \u003c MAX_INSTANCES_FOR_REMOVE) {\r\n      uint16_t context = temp_sym_data.bytes.repeats;\r\n      uint16_t context2 = 240 + temp_sym_data.code_length;\r\n      if ((use_mtf != 0) \u0026\u0026 (DecodeERG(context, context2) != 0)) {\r\n        temp_sym_data.bytes.type = 2;\r\n        if ((temp_sym_data.bytes.repeats == 1) || (DecodeGoMtf(context, 2) != 0))\r\n          put_in_mtf = 1;\r\n      }\r\n    }\r\n    else {\r\n      uint16_t context = temp_sym_data.bytes.repeats;\r\n      uint16_t context2 = 240;\r\n      if ((temp_sym_data.code_length \u003e= 11) \u0026\u0026 (use_mtf != 0) \u0026\u0026 (DecodeERG(context, context2) != 0)) {\r\n        temp_sym_data.bytes.type = 2;\r\n        if (DecodeGoMtf(context, 2) != 0)\r\n          put_in_mtf = 1;\r\n      }\r\n    }\r\n    if (put_in_mtf == 0) {\r\n      sym_data_ptr = dadd_dictionary_symbol(temp_sym_data.code_length, prior_end);\r\n      sym_data_ptr-\u003estring_index = temp_sym_data.string_index;\r\n      sym_data_ptr-\u003estring_length = temp_sym_data.string_length;\r\n      sym_data_ptr-\u003efour_bytes = temp_sym_data.four_bytes;\r\n    }\r\n    else\r\n      sym_data_ptr = (struct sym_data *)dadd_symbol_to_queue((struct sym_data *)\u0026temp_sym_data,\r\n          temp_sym_data.code_length, temp_sym_data.starts);\r\n  }\r\n  else {\r\n    symbols_in_definition = SID_symbol + 1;\r\n    if (symbols_in_definition == 16)\r\n      symbols_in_definition = get_extra_length();\r\n\r\n    do { // Build the symbol string from the next symbols_in_definition symbols\r\n      if ((sym_type = DecodeSymType1(1)) == 0) {\r\n        if (UTF8_compliant != 0)\r\n          first_char = DecodeFirstChar(0, prior_end);\r\n        else\r\n          first_char = DecodeFirstCharBinary(prior_end);\r\n        uint16_t bin_num = DecodeBin(sum_nbob[first_char]);\r\n        uint8_t code_length = lookup_bits[first_char][bin_num];\r\n        uint32_t index = get_dictionary_symbol(bin_num, code_length, first_char);\r\n        sym_data_ptr = \u0026bin_data[first_char][code_length].symbol_data[index];\r\n        prior_end = sym_data_ptr-\u003ebytes.ends;\r\n        uint8_t * symbol_string_ptr = \u0026symbol_strings[sym_data_ptr-\u003estring_index];\r\n        uint8_t * end_symbol_string_ptr = symbol_string_ptr + sym_data_ptr-\u003estring_length;\r\n        do {\r\n          symbol_strings[end_string_index++] = *symbol_string_ptr++;\r\n        } while (symbol_string_ptr != end_symbol_string_ptr);\r\n        if (sym_data_ptr-\u003ebytes.remaining \u003c MAX_INSTANCES_FOR_REMOVE) {\r\n          if (--sym_data_ptr-\u003ebytes.remaining == 0)\r\n            dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n          else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n            if ((sym_data_ptr-\u003ebytes.remaining == 1) \u0026\u0026 ((sym_data_ptr-\u003ebytes.type \u0026 8) == 0)) {\r\n              sym_data_ptr = (struct sym_data *)dadd_symbol_to_queue(sym_data_ptr, code_length, first_char);\r\n              dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n            }\r\n            else {\r\n              uint16_t context = 6 * sym_data_ptr-\u003ebytes.repeats;\r\n              if (DecodeGoMtf(context, 0) != 0) {\r\n                sym_data_ptr = (struct sym_data *)dadd_symbol_to_queue(sym_data_ptr, code_length, first_char);\r\n                dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n              }\r\n            }\r\n          }\r\n\r\n        }\r\n        else if ((sym_data_ptr-\u003ebytes.type \u0026 2) != 0) {\r\n          uint16_t context = 6 * sym_data_ptr-\u003ebytes.remaining;\r\n          if (DecodeGoMtf(context, 0) != 0) {\r\n            sym_data_ptr = (struct sym_data *)dadd_symbol_to_queue(sym_data_ptr, code_length, first_char);\r\n            dremove_dictionary_symbol(\u0026bin_data[first_char][code_length], index);\r\n          }\r\n        }\r\n      }\r\n      else if (sym_type == 1)\r\n        sym_data_ptr = decode_new(\u0026end_string_index);\r\n      else {\r\n        sym_data_ptr = dupdate_queue(DecodeMtfPos(queue_size));\r\n        prior_end = sym_data_ptr-\u003ebytes.ends;\r\n        uint8_t * symbol_string_ptr = \u0026symbol_strings[sym_data_ptr-\u003estring_index];\r\n        uint8_t * end_symbol_string_ptr = symbol_string_ptr + sym_data_ptr-\u003estring_length;\r\n        do {\r\n          symbol_strings[end_string_index++] = *symbol_string_ptr++;\r\n        } while (symbol_string_ptr != end_symbol_string_ptr);\r\n      }\r\n    } while (--symbols_in_definition != 0);\r\n    if ((symbol_strings[*string_index_ptr] \u003c 0x80) || (UTF8_compliant == 0))\r\n      temp_sym_data.starts = symbol_strings[*string_index_ptr];\r\n    else\r\n      temp_sym_data.starts = get_first_char(temp_sym_data.string_index);\r\n    temp_sym_data.bytes.ends = prior_end;\r\n    temp_sym_data.string_length = end_string_index - temp_sym_data.string_index;\r\n\r\n    temp_sym_data.bytes.repeats = DecodeINST(NOT_CAP, SID_symbol);\r\n    if (temp_sym_data.bytes.repeats \u003c= MAX_INSTANCES_FOR_REMOVE - 2) {\r\n      temp_sym_data.code_length = queue_miss_code_length[++temp_sym_data.bytes.repeats];\r\n      uint16_t context = temp_sym_data.bytes.repeats;\r\n      uint16_t context2 = 240 + temp_sym_data.code_length;\r\n      if ((use_mtf != 0) \u0026\u0026 (DecodeERG(context, context2) != 0)) {\r\n        temp_sym_data.bytes.type = 2;\r\n        if ((temp_sym_data.bytes.repeats == 1) || (DecodeGoMtf(context, 2) != 0))\r\n          put_in_mtf = 1;\r\n      }\r\n      else\r\n        temp_sym_data.bytes.type = 0;\r\n    }\r\n    else {\r\n      temp_sym_data.code_length = max_regular_code_length + MAX_INSTANCES_FOR_REMOVE - 1 - temp_sym_data.bytes.repeats;\r\n      temp_sym_data.bytes.repeats = temp_sym_data.code_length + MAX_INSTANCES_FOR_REMOVE - 1;\r\n      uint16_t context = temp_sym_data.bytes.repeats;\r\n      uint16_t context2 = 240;\r\n      if ((temp_sym_data.code_length \u003e= 11) \u0026\u0026 (use_mtf != 0) \u0026\u0026 (DecodeERG(context, context2) != 0)) {\r\n        temp_sym_data.bytes.type = 2;\r\n        if (DecodeGoMtf(context, 2) != 0)\r\n          put_in_mtf = 1;\r\n      }\r\n      else\r\n        temp_sym_data.bytes.type = 0;\r\n    }\r\n    temp_sym_data.bytes.remaining = temp_sym_data.bytes.repeats;\r\n    if (put_in_mtf == 0) {\r\n      sym_data_ptr = dadd_dictionary_symbol(temp_sym_data.code_length, temp_sym_data.starts);\r\n      sym_data_ptr-\u003estring_index = temp_sym_data.string_index;\r\n      sym_data_ptr-\u003estring_length = temp_sym_data.string_length;\r\n      sym_data_ptr-\u003efour_bytes = temp_sym_data.four_bytes;\r\n    }\r\n    else\r\n      sym_data_ptr = (struct sym_data *)dadd_symbol_to_queue((struct sym_data *)\u0026temp_sym_data,\r\n          temp_sym_data.code_length, temp_sym_data.starts);\r\n  }\r\n  *string_index_ptr = end_string_index;\r\n  return(sym_data_ptr);\r\n}","filepath":"glza/GLZAdecode.c","line_number":881,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3417776":{"score":0.90075743,"function_name":"transpose2","code":"void transpose2(uint8_t * buffer, uint32_t len) {\r\n  uint8_t temp_buf[0x30000];\r\n  uint8_t *char_ptr, *char2_ptr;\r\n  uint32_t block1_len = len - (len \u003e\u003e 1);\r\n  memcpy(temp_buf, buffer + block1_len, len - block1_len);\r\n  char2_ptr = buffer + 2 * block1_len;\r\n  char_ptr = buffer + block1_len;\r\n  while (char_ptr != buffer) {\r\n    char2_ptr -= 2;\r\n    *char2_ptr = *--char_ptr;\r\n  }\r\n  char2_ptr = buffer + 1;\r\n  char_ptr = temp_buf;\r\n  while (char2_ptr \u003c buffer + len) {\r\n    *char2_ptr = *char_ptr++;\r\n    char2_ptr += 2;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":1472,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3417984":{"score":0.9240332,"function_name":"transpose4","code":"void transpose4(uint8_t * buffer, uint32_t len) {\r\n  uint8_t temp_buf[0x30000];\r\n  uint8_t *char_ptr, *char2_ptr;\r\n  uint32_t block1_len = (len + 3) \u003e\u003e 2;\r\n  memcpy(temp_buf, buffer + block1_len, len - block1_len);\r\n  char2_ptr = buffer + 4 * block1_len;\r\n  char_ptr = buffer + block1_len;\r\n  while (char_ptr != buffer) {\r\n    char2_ptr -= 4;\r\n    *char2_ptr = *--char_ptr;\r\n  }\r\n  char2_ptr = buffer + 1;\r\n  char_ptr = temp_buf;\r\n  while (char2_ptr \u003c buffer + len) {\r\n    *char2_ptr = *char_ptr++;\r\n    char2_ptr += 4;\r\n  }\r\n  char2_ptr = buffer + 2;\r\n  while (char2_ptr \u003c buffer + len) {\r\n    *char2_ptr = *char_ptr++;\r\n    char2_ptr += 4;\r\n  }\r\n  char2_ptr = buffer + 3;\r\n  while (char2_ptr \u003c buffer + len) {\r\n    *char2_ptr = *char_ptr++;\r\n    char2_ptr += 4;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":1493,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3418304":{"score":0.9027739,"function_name":"write_output_buffer","code":"void write_output_buffer() {\r\n  uint32_t chars_to_write = out_char_ptr - start_char_ptr;\r\n  if (fd != 0) {\r\n    fflush(fd);\r\n    fwrite(start_char_ptr, 1, chars_to_write, fd);\r\n    if ((out_buffers_sent \u0026 1) == 0)\r\n      out_char_ptr = out_char1;\r\n    else\r\n      out_char_ptr = out_char0;\r\n  }\r\n  outbuf_index += chars_to_write;\r\n  start_char_ptr = out_char_ptr;\r\n  end_outbuf = out_char_ptr + CHARS_TO_WRITE;\r\n#ifdef PRINTON\r\n  if ((out_buffers_sent \u0026 0x7F) == 0)\r\n    fprintf(stderr, \"%u\\r\", (unsigned int)outbuf_index);\r\n#endif\r\n  out_buffers_sent++;\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":1524,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3418464":{"score":0.87075794,"function_name":"write_output_buffer_delta","code":"void write_output_buffer_delta() {\r\n  uint32_t chars_to_write = out_char_ptr - start_char_ptr;\r\n  uint32_t len = out_char_ptr - start_char_ptr;\r\n  if (stride == 4) {\r\n    transpose4(start_char_ptr, len);\r\n    len = out_char_ptr - start_char_ptr;\r\n  }\r\n  else if (stride == 2) {\r\n    transpose2(start_char_ptr, len);\r\n    len = out_char_ptr - start_char_ptr;\r\n  }\r\n  delta_transform(start_char_ptr, len);\r\n  if (fd != 0) {\r\n    fflush(fd);\r\n    fwrite(start_char_ptr, 1, chars_to_write, fd);\r\n    if ((out_buffers_sent \u0026 1) == 0) {\r\n      uint8_t k;\r\n      for (k = 1 ; k \u003c= stride ; k++)\r\n        out_char1[100 - k] = *(out_char_ptr - k);\r\n      out_char_ptr = out_char1 + 100;\r\n    }\r\n    else {\r\n      uint8_t k;\r\n      for (k = 1 ; k \u003c= stride ; k++)\r\n        out_char0[100 - k] = *(out_char_ptr - k);\r\n      out_char_ptr = out_char0 + 100;\r\n    }\r\n  }\r\n  outbuf_index += chars_to_write;\r\n  start_char_ptr = out_char_ptr;\r\n  end_outbuf = out_char_ptr + CHARS_TO_WRITE;\r\n#ifdef PRINTON\r\n  if ((out_buffers_sent \u0026 0x7F) == 0)\r\n    fprintf(stderr, \"%u\\r\", (unsigned int)outbuf_index);\r\n#endif\r\n  out_buffers_sent++;\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":1546,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3421568":{"score":0.5841889,"function_name":"write_single_threaded_output","code":"void write_single_threaded_output() {\r\n  uint8_t * symbol_string_ptr;\r\n  uint32_t * read_ptr = (uint32_t *)symbol_buffer;\r\n  if (cap_encoded != 0) {\r\n    while (read_ptr != (uint32_t *)symbol_buffer_write_ptr) {\r\n      symbol_string_ptr = \u0026symbol_strings[*read_ptr++];\r\n      uint32_t length = *read_ptr++;\r\n      write_string_cap_encoded(length);\r\n    }\r\n  }\r\n  else if (stride == 0) {\r\n    while (read_ptr != (uint32_t *)symbol_buffer_write_ptr) {\r\n      symbol_string_ptr = \u0026symbol_strings[*read_ptr++];\r\n      uint32_t length = *read_ptr++;\r\n      write_string(length);\r\n    }\r\n  }\r\n  else {\r\n    while (read_ptr != (uint32_t *)symbol_buffer_write_ptr) {\r\n      symbol_string_ptr = \u0026symbol_strings[*read_ptr++];\r\n      uint32_t length = *read_ptr++;\r\n      write_string_delta(length);\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":1706,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3422928":{"score":0.82307523,"function_name":"write_symbol_buffer","code":"void write_symbol_buffer(uint8_t * buffer_number_ptr) {\r\n  if (two_threads == 0) {\r\n    write_single_threaded_output();\r\n    symbol_buffer_write_ptr = symbol_buffer;\r\n  }\r\n  else {\r\n    if (*buffer_number_ptr != 0)\r\n      symbol_buffer_write_ptr = symbol_buffer;\r\n    symbol_buffer_end_write_ptr = symbol_buffer_write_ptr + 0x400;\r\n    atomic_store_explicit(\u0026symbol_buffer_owner[*buffer_number_ptr], 1, memory_order_release);\r\n    *buffer_number_ptr ^= 1;\r\n    while (atomic_load_explicit(\u0026symbol_buffer_owner[*buffer_number_ptr], memory_order_acquire) != 0) ;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAdecode.c","line_number":1734,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3427472":{"score":0.8619504,"function_name":"StartModelSymType","code":"void StartModelSymType(uint8_t use_mtf, uint8_t cap_encoded) {\r\n  if (cap_encoded == 0) {\r\n    uint8_t i = 1;\r\n    do {\r\n      if (use_mtf != 0) {\r\n        FreqSymTypePriorType[i][0] = 0x1C00;\r\n        FreqSymTypePriorType[i][1] = 0x2000;\r\n      }\r\n      else {\r\n        FreqSymTypePriorType[i][0] = 0x2000;\r\n        FreqSymTypePriorType[i][1] = 0x2000;\r\n      }\r\n    } while (i-- != 0);\r\n  }\r\n  else {\r\n    uint8_t i = 0x33;\r\n    do {\r\n      if (use_mtf != 0) {\r\n        FreqSymTypePriorType[i][0] = 0xE00;\r\n        FreqSymTypePriorType[i][1] = 0x1000;\r\n      }\r\n      else {\r\n        FreqSymTypePriorType[i][0] = 0x1000;\r\n        FreqSymTypePriorType[i][1] = 0x1000;\r\n      }\r\n    } while (i-- != 0x2C);\r\n    do {\r\n      if (use_mtf != 0) {\r\n        FreqSymTypePriorType[i][0] = 0x1500;\r\n        FreqSymTypePriorType[i][1] = 0x1800;\r\n      }\r\n      else {\r\n        FreqSymTypePriorType[i][0] = 0x1800;\r\n        FreqSymTypePriorType[i][1] = 0x1800;\r\n      }\r\n    } while (i-- != 4);\r\n    do {\r\n      if (use_mtf != 0) {\r\n        FreqSymTypePriorType[i][0] = 0xE00;\r\n        FreqSymTypePriorType[i][1] = 0x1000;\r\n      }\r\n      else {\r\n        FreqSymTypePriorType[i][0] = 0x1000;\r\n        FreqSymTypePriorType[i][1] = 0x1000;\r\n      }\r\n    } while (i-- != 2);\r\n    do {\r\n      if (use_mtf != 0) {\r\n        FreqSymTypePriorType[i][0] = 0x1500;\r\n        FreqSymTypePriorType[i][1] = 0x1800;\r\n      }\r\n      else {\r\n        FreqSymTypePriorType[i][0] = 0x1800;\r\n        FreqSymTypePriorType[i][1] = 0x1800;\r\n      }\r\n    } while (i-- != 0);\r\n    i = 0xFF;\r\n    do {\r\n      if (use_mtf != 0) {\r\n        FreqSymTypePriorEnd[i][0] = 0xE00;\r\n        FreqSymTypePriorEnd[i][1] = 0x1000;\r\n      }\r\n      else {\r\n        FreqSymTypePriorEnd[i][0] = 0x1000;\r\n        FreqSymTypePriorEnd[i][1] = 0x1000;\r\n      }\r\n    } while (i-- != 0);\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":38,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3427824":{"score":0.76277333,"function_name":"StartModelMtfQueuePos","code":"void StartModelMtfQueuePos(uint8_t max_code_length) {\r\n  RangeScaleMtfPos[0] = 0;\r\n  uint16_t j = 0;\r\n  do {\r\n    FreqMtfPos[0][j] = FreqMtfPos[1][j] = FreqMtfPos[2][j] = FreqMtfPos[3][j] = 0x200 / (j + 2);\r\n    RangeScaleMtfPos[0] += FreqMtfPos[0][j];\r\n  } while (++j != 0x100);\r\n  RangeScaleMtfPos[1] = RangeScaleMtfPos[2] = RangeScaleMtfPos[3] = RangeScaleMtfPos[0];\r\n  unused_queue_freq = unused_queue_freq_az = unused_queue_freq_space = unused_queue_freq_other = RangeScaleMtfPos[0];\r\n  last_queue_size = last_queue_size_az = last_queue_size_space = last_queue_size_other = 0;\r\n  rescale_queue_size = rescale_queue_size_az = rescale_queue_size_space = rescale_queue_size_other = 0;\r\n\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":118,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3428048":{"score":0.7424538,"function_name":"StartModelERG","code":"void StartModelERG() {\r\n  uint16_t i = 340;\r\n  do {\r\n    FreqERG[i] = 0x600;\r\n  } while (i-- != 240);\r\n  do {\r\n    FreqERG[i] = 0x800;\r\n  } while (i-- != 1);\r\n  FreqERG[i] = 0x200;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":173,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3428208":{"score":0.81220037,"function_name":"StartModelINST","code":"void StartModelINST(uint8_t num_inst_codes) {\r\n  uint8_t i = 1;\r\n  do {\r\n    uint8_t j = 15;\r\n    do {\r\n      uint8_t k = num_inst_codes;\r\n      if (j != 0)\r\n        k--;\r\n      RangeScaleINST[i][j] = k--;\r\n      do {\r\n        FreqINST[i][j][k] = 1;\r\n      } while (k-- != 0);\r\n    } while (j-- != 0);\r\n  } while (i-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":156,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3428384":{"score":0.80657834,"function_name":"StartModelERG","code":"void StartModelERG() {\r\n  uint16_t i = 340;\r\n  do {\r\n    FreqERG[i] = 0x600;\r\n  } while (i-- != 240);\r\n  do {\r\n    FreqERG[i] = 0x800;\r\n  } while (i-- != 1);\r\n  FreqERG[i] = 0x200;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":173,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3428576":{"score":0.6473943,"function_name":"StartModelFirstCharBinary","code":"void StartModelFirstCharBinary() {\r\n  uint8_t i = 0xFF;\r\n  do {\r\n    uint8_t j = 0xFF;\r\n    do {\r\n      FreqFirstCharBinary[i][j] = 0;\r\n    } while (j-- != 0);\r\n    j = 6;\r\n    do {\r\n      RangeScaleFirstCharSection[i][j] = 0;\r\n    } while (j-- != 0);\r\n    RangeScaleFirstChar[0][i] = 0;\r\n  } while (i-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":223,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3428720":{"score":0.621093,"function_name":"StartModelFirstChar","code":"void StartModelFirstChar() {\r\n  uint8_t i = 0xFF;\r\n  do {\r\n    uint8_t j = 0xFF;\r\n    do {\r\n      FreqFirstChar[0][i][j] = 0;\r\n      FreqFirstChar[1][i][j] = 0;\r\n      FreqFirstChar[2][i][j] = 0;\r\n      FreqFirstChar[3][i][j] = 0;\r\n      SymbolFirstChar[0][i][j] = j;\r\n      SymbolFirstChar[1][i][j] = j;\r\n      SymbolFirstChar[2][i][j] = j;\r\n      SymbolFirstChar[3][i][j] = j;\r\n    } while (j-- != 0);\r\n    RangeScaleFirstChar[0][i] = 0;\r\n    RangeScaleFirstChar[1][i] = 0;\r\n    RangeScaleFirstChar[2][i] = 0;\r\n    RangeScaleFirstChar[3][i] = 0;\r\n  } while (i-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":201,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3428848":{"score":0.9066001,"function_name":"rescaleMtfQueuePos","code":"void rescaleMtfQueuePos(uint8_t Context) {\r\n  uint8_t i = 1;\r\n  RangeScaleMtfPos[Context] = FreqMtfPos[Context][0] = (FreqMtfPos[Context][0] + 1) \u003e\u003e 1;\r\n  do {\r\n    RangeScaleMtfPos[Context] += FreqMtfPos[Context][i] = (FreqMtfPos[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0);\r\n  uint8_t qp = 0xFF;\r\n  if (Context == 0) {\r\n    rescale_queue_size = last_queue_size;\r\n    unused_queue_freq = 0;\r\n    while (qp \u003e= last_queue_size)\r\n      unused_queue_freq += FreqMtfPos[0][qp--];\r\n  }\r\n  else if (Context == 1) {\r\n    rescale_queue_size_az = last_queue_size_az;\r\n    unused_queue_freq_az = 0;\r\n    while (qp \u003e= last_queue_size_az)\r\n      unused_queue_freq_az += FreqMtfPos[1][qp--];\r\n  }\r\n  else if (Context == 2) {\r\n    rescale_queue_size_space = last_queue_size_space;\r\n    unused_queue_freq_space = 0;\r\n    while (qp \u003e= last_queue_size_space)\r\n      unused_queue_freq_space += FreqMtfPos[2][qp--];\r\n  }\r\n  else {\r\n    rescale_queue_size_other = last_queue_size_other;\r\n    unused_queue_freq_other = 0;\r\n    while (qp \u003e= last_queue_size_other)\r\n      unused_queue_freq_other += FreqMtfPos[3][qp--];\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":239,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3429248":{"score":0.8475838,"function_name":"rescaleSID","code":"void rescaleSID(uint8_t Context) {\r\n  uint8_t i = 14;\r\n  RangeScaleSID[Context] = FreqSID[Context][15] = (FreqSID[Context][15] + 1) \u003e\u003e 1;\r\n  do {\r\n    RangeScaleSID[Context] += FreqSID[Context][i] = (FreqSID[Context][i] + 1) \u003e\u003e 1;\r\n  } while (i-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":273,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3429360":{"score":0.8136487,"function_name":"rescaleFirstChar","code":"void rescaleFirstChar(uint8_t SymType, uint8_t Context) {\r\n  uint8_t i = MaxBaseCode;\r\n  RangeScaleFirstChar[SymType][Context] = 0;\r\n  do {\r\n    RangeScaleFirstChar[SymType][Context] += FreqFirstChar[SymType][Context][i]\r\n        = (FreqFirstChar[SymType][Context][i] + 1) \u003e\u003e 1;\r\n  } while (i-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":291,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3429504":{"score":0.78696394,"function_name":"rescaleFirstChar","code":"void rescaleFirstChar(uint8_t SymType, uint8_t Context) {\r\n  uint8_t i = MaxBaseCode;\r\n  RangeScaleFirstChar[SymType][Context] = 0;\r\n  do {\r\n    RangeScaleFirstChar[SymType][Context] += FreqFirstChar[SymType][Context][i]\r\n        = (FreqFirstChar[SymType][Context][i] + 1) \u003e\u003e 1;\r\n  } while (i-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":291,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3429632":{"score":0.8831605,"function_name":"rescaleFirstCharBinary","code":"void rescaleFirstCharBinary(uint8_t Context) {\r\n  RangeScaleFirstChar[0][Context] = FreqFirstCharBinary[Context][0] = (FreqFirstCharBinary[Context][0] + 1) \u003e\u003e 1;\r\n  uint8_t i = 1;\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0x20);\r\n  RangeScaleFirstCharSection[Context][0] = RangeScaleFirstChar[0][Context];\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0x40);\r\n  RangeScaleFirstCharSection[Context][1] = RangeScaleFirstChar[0][Context];\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0x60);\r\n  RangeScaleFirstCharSection[Context][2] = RangeScaleFirstChar[0][Context] - RangeScaleFirstCharSection[Context][1];\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0x80);\r\n  RangeScaleFirstCharSection[Context][3] = RangeScaleFirstChar[0][Context];\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0xA0);\r\n  RangeScaleFirstCharSection[Context][4] = RangeScaleFirstChar[0][Context] - RangeScaleFirstCharSection[Context][3];\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0xC0);\r\n  RangeScaleFirstCharSection[Context][5] = RangeScaleFirstChar[0][Context] - RangeScaleFirstCharSection[Context][3];\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0xE0);\r\n  RangeScaleFirstCharSection[Context][6] = RangeScaleFirstChar[0][Context] - RangeScaleFirstCharSection[Context][5]\r\n      - RangeScaleFirstCharSection[Context][3];\r\n  do {\r\n    RangeScaleFirstChar[0][Context] += FreqFirstCharBinary[Context][i] = (FreqFirstCharBinary[Context][i] + 1) \u003e\u003e 1;\r\n  } while (++i != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":301,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3430224":{"score":0.91253245,"function_name":"InitFirstCharBin","code":"void InitFirstCharBin(uint8_t trailing_char, uint8_t leading_char, uint8_t code_length, uint8_t cap_symbol_defined,\r\n    uint8_t cap_lock_symbol_defined) {\r\n  if ((RangeScaleFirstChar[0][trailing_char] != 0)\r\n      || ((trailing_char == 'C') \u0026\u0026 (cap_symbol_defined || cap_lock_symbol_defined))) {\r\n    uint16_t freq = 1;\r\n    if (code_length \u003c 8)\r\n      freq = 1 \u003c\u003c (8 - code_length);\r\n    uint8_t k;\r\n    for (k = 0 ; k \u003c 4 ; k++) {\r\n      uint8_t j2 = leading_char;\r\n      while (SymbolFirstChar[k][trailing_char][j2] != (uint8_t)leading_char)\r\n        j2++;\r\n      FreqFirstChar[k][trailing_char][j2] = freq;\r\n      RangeScaleFirstChar[k][trailing_char] += freq;\r\n      if (RangeScaleFirstChar[k][trailing_char] \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(k, trailing_char);\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":351,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3430544":{"score":0.9050914,"function_name":"InitFirstCharBinBinary","code":"void InitFirstCharBinBinary(uint8_t trailing_char, uint8_t leading_char, uint8_t code_length) {\r\n  if (RangeScaleFirstChar[0][trailing_char]) {\r\n    if (code_length \u003c 8) {\r\n      FreqFirstCharBinary[trailing_char][leading_char] = 1 \u003c\u003c (8 - code_length);\r\n      RangeScaleFirstChar[0][trailing_char] += 1 \u003c\u003c (8 - code_length);\r\n      if (leading_char \u003c 0x80) {\r\n        RangeScaleFirstCharSection[trailing_char][3] += 1 \u003c\u003c (8 - code_length);\r\n        if (leading_char \u003c 0x40) {\r\n          RangeScaleFirstCharSection[trailing_char][1] += 1 \u003c\u003c (8 - code_length);\r\n          if (leading_char \u003c 0x20)\r\n            RangeScaleFirstCharSection[trailing_char][0] += 1 \u003c\u003c (8 - code_length);\r\n        }\r\n        else if (leading_char \u003c 0x60)\r\n          RangeScaleFirstCharSection[trailing_char][2] += 1 \u003c\u003c (8 - code_length);\r\n      }\r\n      else if (leading_char \u003c 0xC0) {\r\n        RangeScaleFirstCharSection[trailing_char][5] += 1 \u003c\u003c (8 - code_length);\r\n        if (leading_char \u003c 0xA0)\r\n          RangeScaleFirstCharSection[trailing_char][4] += 1 \u003c\u003c (8 - code_length);\r\n      }\r\n      else if (leading_char \u003c 0xE0)\r\n        RangeScaleFirstCharSection[trailing_char][6] += 1 \u003c\u003c (8 - code_length);\r\n    }\r\n    else {\r\n      FreqFirstCharBinary[trailing_char][leading_char] = 1;\r\n      RangeScaleFirstChar[0][trailing_char] += 1;\r\n      if (leading_char \u003c 0x80) {\r\n        RangeScaleFirstCharSection[trailing_char][3] += 1;\r\n        if (leading_char \u003c 0x40) {\r\n          RangeScaleFirstCharSection[trailing_char][1] += 1;\r\n          if (leading_char \u003c 0x20)\r\n            RangeScaleFirstCharSection[trailing_char][0] += 1;\r\n        }\r\n        else if (leading_char \u003c 0x60)\r\n          RangeScaleFirstCharSection[trailing_char][2] += 1;\r\n      }\r\n      else if (leading_char \u003c 0xC0) {\r\n        RangeScaleFirstCharSection[trailing_char][5] += 1;\r\n        if (leading_char \u003c 0xA0)\r\n          RangeScaleFirstCharSection[trailing_char][4] += 1;\r\n      }\r\n      else if (leading_char \u003c 0xE0)\r\n        RangeScaleFirstCharSection[trailing_char][6] += 1;\r\n    }\r\n    if (RangeScaleFirstChar[0][trailing_char] \u003e FREQ_FIRST_CHAR_BOT)\r\n      rescaleFirstCharBinary(trailing_char);\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":372,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3431088":{"score":0.906616,"function_name":"InitTrailingCharBin","code":"void InitTrailingCharBin(uint8_t trailing_char, uint8_t leading_char, uint8_t code_length) {\r\n  uint16_t freq = 1;\r\n  if (code_length \u003c 8)\r\n    freq = 1 \u003c\u003c (8 - code_length);\r\n  FreqFirstChar[0][trailing_char][leading_char] = freq;\r\n  RangeScaleFirstChar[0][trailing_char] += freq;\r\n  FreqFirstChar[1][trailing_char][leading_char] = freq;\r\n  RangeScaleFirstChar[1][trailing_char] += freq;\r\n  FreqFirstChar[2][trailing_char][leading_char] = freq;\r\n  RangeScaleFirstChar[2][trailing_char] += freq;\r\n  FreqFirstChar[3][trailing_char][leading_char] = freq;\r\n  RangeScaleFirstChar[3][trailing_char] += freq;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":422,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3431216":{"score":0.8962205,"function_name":"InitTrailingCharBinary","code":"void InitTrailingCharBinary(uint8_t trailing_char, uint8_t * symbol_lengths) {\r\n  uint8_t leading_char = 0xFF;\r\n  do {\r\n    uint16_t freq = 1;\r\n    if (symbol_lengths[leading_char] \u003c 8)\r\n      freq = 1 \u003c\u003c (8 - symbol_lengths[leading_char]);\r\n    if (RangeScaleFirstChar[0][leading_char] || (leading_char == trailing_char)) {\r\n      FreqFirstCharBinary[trailing_char][leading_char] = freq;\r\n      RangeScaleFirstChar[0][trailing_char] += freq;\r\n      if (leading_char \u003c 0x80) {\r\n        RangeScaleFirstCharSection[trailing_char][3] += freq;\r\n        if (leading_char \u003c 0x40) {\r\n          RangeScaleFirstCharSection[trailing_char][1] += freq;\r\n          if (leading_char \u003c 0x20)\r\n            RangeScaleFirstCharSection[trailing_char][0] += freq;\r\n        }\r\n        else if (leading_char \u003c 0x60)\r\n          RangeScaleFirstCharSection[trailing_char][2] += freq;\r\n      }\r\n      else if (leading_char \u003c 0xC0) {\r\n        RangeScaleFirstCharSection[trailing_char][5] += freq;\r\n        if (leading_char \u003c 0xA0)\r\n          RangeScaleFirstCharSection[trailing_char][4] += freq;\r\n      }\r\n      else if (leading_char \u003c 0xE0)\r\n        RangeScaleFirstCharSection[trailing_char][6] += freq;\r\n    }\r\n  } while (leading_char-- != 0);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":437,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3431472":{"score":0.9014584,"function_name":"InitBaseSymbolCap","code":"void InitBaseSymbolCap(uint8_t BaseSymbol, uint8_t new_symbol_code_length, uint8_t * cap_symbol_defined_ptr,\r\n    uint8_t * cap_lock_symbol_defined_ptr, uint8_t * symbol_lengths) {\r\n  uint8_t j1 = MaxBaseCode;\r\n  do {\r\n    InitFirstCharBin(j1, BaseSymbol, new_symbol_code_length, *cap_symbol_defined_ptr, *cap_lock_symbol_defined_ptr);\r\n  } while (--j1 != 'Z');\r\n  j1 = 'A' - 1;\r\n  do {\r\n    InitFirstCharBin(j1, BaseSymbol, new_symbol_code_length, *cap_symbol_defined_ptr, *cap_lock_symbol_defined_ptr);\r\n  } while (j1--);\r\n  if ((BaseSymbol \u0026 0xFE) == 0x42) {\r\n    j1 = 'z';\r\n    if ((*cap_symbol_defined_ptr | *cap_lock_symbol_defined_ptr) == 0) {\r\n      do {\r\n        if (RangeScaleFirstChar[0][j1] != 0)\r\n          InitTrailingCharBin('C', j1, symbol_lengths[j1]);\r\n      } while (j1-- != 'a');\r\n    }\r\n    if (BaseSymbol == 'C')\r\n      *cap_symbol_defined_ptr = 1;\r\n    else\r\n      *cap_lock_symbol_defined_ptr = 1;\r\n  }\r\n  else {\r\n    if ((BaseSymbol \u003e= 'a') \u0026\u0026 (BaseSymbol \u003c= 'z'))\r\n      InitFirstCharBin('C', BaseSymbol, new_symbol_code_length, *cap_symbol_defined_ptr, *cap_lock_symbol_defined_ptr);\r\n    j1 = MaxBaseCode;\r\n    do {\r\n      if (symbol_lengths[j1] != 0)\r\n        InitTrailingCharBin(BaseSymbol, j1, symbol_lengths[j1]);\r\n    } while (j1--);\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":468,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3431984":{"score":0.826309,"function_name":"NormalizeEncoder","code":"void NormalizeEncoder(uint32_t bot) {\r\n  while ((low ^ (low + range)) \u003c TOP || (range \u003c bot \u0026\u0026 ((range = -low \u0026 (bot - 1)), 1))) {\r\n    OutBuffer[OutCharNum++] = (uint8_t)(low \u003e\u003e 24);\r\n    range \u003c\u003c= 8;\r\n    low \u003c\u003c= 8;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":525,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3432096":{"score":0.8207607,"function_name":"EncodeDictType1","code":"void EncodeDictType1(uint8_t Context1) {\r\n  NormalizeEncoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  range = FreqSymTypePriorType[Context1][0] * (range \u003e\u003e 14) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":534,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3432208":{"score":0.8090203,"function_name":"EncodeDictType2","code":"void EncodeDictType2(uint8_t Context1, uint8_t Context2) {\r\n  NormalizeEncoder(2 * FREQ_SYM_TYPE_BOT2);\r\n  uint32_t extra_range = range \u0026 (2 * FREQ_SYM_TYPE_BOT2 - 1);\r\n  range = (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0]) * (range \u003e\u003e 14) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  sum = FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n  FreqSymTypePriorType[Context2][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n  FreqSymTypePriorType[Context2][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":545,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3432400":{"score":0.78974986,"function_name":"EncodeDictType3","code":"void EncodeDictType3(uint8_t Context1, uint8_t Context2, uint8_t Context3) {\r\n  NormalizeEncoder(8 * FREQ_SYM_TYPE_BOT3);\r\n  uint32_t extra_range = range \u0026 (8 * FREQ_SYM_TYPE_BOT3 - 1);\r\n  range = (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0] + FreqSymTypePriorEnd[Context3][0])\r\n      * (range \u003e\u003e 15) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  sum = FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n  FreqSymTypePriorType[Context2][0]\r\n      += sum + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n  FreqSymTypePriorType[Context2][1] -= sum;\r\n  sum = FreqSymTypePriorEnd[Context3][1] \u003e\u003e 3;\r\n  FreqSymTypePriorEnd[Context3][0]\r\n      += sum + ((2 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorEnd[Context3][0] - FreqSymTypePriorEnd[Context3][1]) \u003e\u003e 3);\r\n  FreqSymTypePriorEnd[Context3][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":560,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3432672":{"score":0.81594455,"function_name":"EncodeDictType1","code":"void EncodeDictType1(uint8_t Context1) {\r\n  NormalizeEncoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  range = FreqSymTypePriorType[Context1][0] * (range \u003e\u003e 14) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":534,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3432800":{"score":0.82727695,"function_name":"EncodeNewType2","code":"void EncodeNewType2(uint8_t Context1, uint8_t Context2) {\r\n  NormalizeEncoder(2 * FREQ_SYM_TYPE_BOT2);\r\n  uint32_t extra_range = range \u0026 (2 * FREQ_SYM_TYPE_BOT2 - 1);\r\n  low += (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0]) * (range \u003e\u003e= 14) + extra_range;\r\n  range *= (FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1]);\r\n  uint16_t sum = FreqSymTypePriorType[Context1][0] \u003e\u003e 4;\r\n  FreqSymTypePriorType[Context1][1]\r\n      += sum + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n  FreqSymTypePriorType[Context1][0] -= sum;\r\n  sum = FreqSymTypePriorType[Context2][0] \u003e\u003e 7;\r\n  FreqSymTypePriorType[Context2][1]\r\n      += sum + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n  FreqSymTypePriorType[Context2][0] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":592,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3433008":{"score":0.77683616,"function_name":"EncodeDictType3","code":"void EncodeDictType3(uint8_t Context1, uint8_t Context2, uint8_t Context3) {\r\n  NormalizeEncoder(8 * FREQ_SYM_TYPE_BOT3);\r\n  uint32_t extra_range = range \u0026 (8 * FREQ_SYM_TYPE_BOT3 - 1);\r\n  range = (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0] + FreqSymTypePriorEnd[Context3][0])\r\n      * (range \u003e\u003e 15) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  sum = FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n  FreqSymTypePriorType[Context2][0]\r\n      += sum + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n  FreqSymTypePriorType[Context2][1] -= sum;\r\n  sum = FreqSymTypePriorEnd[Context3][1] \u003e\u003e 3;\r\n  FreqSymTypePriorEnd[Context3][0]\r\n      += sum + ((2 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorEnd[Context3][0] - FreqSymTypePriorEnd[Context3][1]) \u003e\u003e 3);\r\n  FreqSymTypePriorEnd[Context3][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":560,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3433312":{"score":0.83249605,"function_name":"EncodeDictType1","code":"void EncodeDictType1(uint8_t Context1) {\r\n  NormalizeEncoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  range = FreqSymTypePriorType[Context1][0] * (range \u003e\u003e 14) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":534,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3433440":{"score":0.8148631,"function_name":"EncodeNewType2","code":"void EncodeNewType2(uint8_t Context1, uint8_t Context2) {\r\n  NormalizeEncoder(2 * FREQ_SYM_TYPE_BOT2);\r\n  uint32_t extra_range = range \u0026 (2 * FREQ_SYM_TYPE_BOT2 - 1);\r\n  low += (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0]) * (range \u003e\u003e= 14) + extra_range;\r\n  range *= (FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1]);\r\n  uint16_t sum = FreqSymTypePriorType[Context1][0] \u003e\u003e 4;\r\n  FreqSymTypePriorType[Context1][1]\r\n      += sum + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n  FreqSymTypePriorType[Context1][0] -= sum;\r\n  sum = FreqSymTypePriorType[Context2][0] \u003e\u003e 7;\r\n  FreqSymTypePriorType[Context2][1]\r\n      += sum + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n  FreqSymTypePriorType[Context2][0] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":592,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3433632":{"score":0.80237085,"function_name":"EncodeDictType3","code":"void EncodeDictType3(uint8_t Context1, uint8_t Context2, uint8_t Context3) {\r\n  NormalizeEncoder(8 * FREQ_SYM_TYPE_BOT3);\r\n  uint32_t extra_range = range \u0026 (8 * FREQ_SYM_TYPE_BOT3 - 1);\r\n  range = (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0] + FreqSymTypePriorEnd[Context3][0])\r\n      * (range \u003e\u003e 15) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  sum = FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n  FreqSymTypePriorType[Context2][0]\r\n      += sum + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n  FreqSymTypePriorType[Context2][1] -= sum;\r\n  sum = FreqSymTypePriorEnd[Context3][1] \u003e\u003e 3;\r\n  FreqSymTypePriorEnd[Context3][0]\r\n      += sum + ((2 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorEnd[Context3][0] - FreqSymTypePriorEnd[Context3][1]) \u003e\u003e 3);\r\n  FreqSymTypePriorEnd[Context3][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":560,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3433904":{"score":0.83301735,"function_name":"EncodeMtfFirst","code":"void EncodeMtfFirst(uint8_t Context, uint8_t First) {\r\n  uint32_t delta;\r\n  NormalizeEncoder(0x1000);\r\n  uint32_t extra_range = range \u0026 0xFFF;\r\n  if (First == 0) {\r\n    range = FreqMtfFirst[Context][0] * (range \u003e\u003e 12) + extra_range;\r\n    delta = FreqMtfFirst[Context][1] \u003e\u003e 7;\r\n    FreqMtfFirst[Context][1] -= delta;\r\n    FreqMtfFirst[Context][0] += delta;\r\n    delta = FreqMtfFirst[Context][2] \u003e\u003e 7;\r\n    FreqMtfFirst[Context][2] -= delta;\r\n    FreqMtfFirst[Context][0] += delta;\r\n  }\r\n  else if (First == 1) {\r\n    low += FreqMtfFirst[Context][0] * (range \u003e\u003e= 12) + extra_range;\r\n    range *= FreqMtfFirst[Context][1];\r\n    delta = FreqMtfFirst[Context][0] \u003e\u003e 7;\r\n    FreqMtfFirst[Context][0] -= delta;\r\n    FreqMtfFirst[Context][1] += delta;\r\n    delta = FreqMtfFirst[Context][2] \u003e\u003e 7;\r\n    FreqMtfFirst[Context][2] -= delta;\r\n    FreqMtfFirst[Context][1] += delta;\r\n  }\r\n  else {\r\n    low += (FreqMtfFirst[Context][0] + FreqMtfFirst[Context][1]) * (range \u003e\u003e= 12) + extra_range;\r\n    range *= FreqMtfFirst[Context][2];\r\n    delta = FreqMtfFirst[Context][0] \u003e\u003e 7;\r\n    FreqMtfFirst[Context][0] -= delta;\r\n    FreqMtfFirst[Context][2] += delta;\r\n    delta = FreqMtfFirst[Context][1] \u003e\u003e 7;\r\n    FreqMtfFirst[Context][1] -= delta;\r\n    FreqMtfFirst[Context][2] += delta;\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":671,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3434192":{"score":0.88365036,"function_name":"EncodeMtfPosAz","code":"void EncodeMtfPosAz(uint8_t position, uint16_t QueueSize) {\r\n  NormalizeEncoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_az \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_az += FreqMtfPos[1][--last_queue_size_az];\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  else if (last_queue_size_az \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_az -= FreqMtfPos[1][last_queue_size_az++];\r\n      if (last_queue_size_az \u003e rescale_queue_size_az) {\r\n        rescale_queue_size_az++;\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 16;\r\n        RangeScaleMtfPos[1] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 4;\r\n        RangeScaleMtfPos[1] += 4;\r\n      }\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  if (RangeScaleMtfPos[1] \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n\r\n  if (position == 0) {\r\n    range = FreqMtfPos[1][0] * (range / (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    FreqMtfPos[1][0] += UP_FREQ_MTF_POS;\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[1][0];\r\n    uint16_t * StopFreqPtr = \u0026FreqMtfPos[1][position];\r\n    RangeLow = *FreqPtr++;\r\n    while (FreqPtr != StopFreqPtr)\r\n      RangeLow += *FreqPtr++;\r\n    low += RangeLow * (range /= (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    range *= *FreqPtr;\r\n\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n    }\r\n    else\r\n      *FreqPtr += UP_FREQ_MTF_POS;\r\n  }\r\n  if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":770,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3434816":{"score":0.8798475,"function_name":"EncodeMtfPosAz","code":"void EncodeMtfPosAz(uint8_t position, uint16_t QueueSize) {\r\n  NormalizeEncoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_az \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_az += FreqMtfPos[1][--last_queue_size_az];\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  else if (last_queue_size_az \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_az -= FreqMtfPos[1][last_queue_size_az++];\r\n      if (last_queue_size_az \u003e rescale_queue_size_az) {\r\n        rescale_queue_size_az++;\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 16;\r\n        RangeScaleMtfPos[1] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 4;\r\n        RangeScaleMtfPos[1] += 4;\r\n      }\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  if (RangeScaleMtfPos[1] \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n\r\n  if (position == 0) {\r\n    range = FreqMtfPos[1][0] * (range / (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    FreqMtfPos[1][0] += UP_FREQ_MTF_POS;\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[1][0];\r\n    uint16_t * StopFreqPtr = \u0026FreqMtfPos[1][position];\r\n    RangeLow = *FreqPtr++;\r\n    while (FreqPtr != StopFreqPtr)\r\n      RangeLow += *FreqPtr++;\r\n    low += RangeLow * (range /= (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    range *= *FreqPtr;\r\n\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n    }\r\n    else\r\n      *FreqPtr += UP_FREQ_MTF_POS;\r\n  }\r\n  if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":770,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3435472":{"score":0.87230885,"function_name":"EncodeMtfPosAz","code":"void EncodeMtfPosAz(uint8_t position, uint16_t QueueSize) {\r\n  NormalizeEncoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_az \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_az += FreqMtfPos[1][--last_queue_size_az];\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  else if (last_queue_size_az \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_az -= FreqMtfPos[1][last_queue_size_az++];\r\n      if (last_queue_size_az \u003e rescale_queue_size_az) {\r\n        rescale_queue_size_az++;\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 16;\r\n        RangeScaleMtfPos[1] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 4;\r\n        RangeScaleMtfPos[1] += 4;\r\n      }\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  if (RangeScaleMtfPos[1] \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n\r\n  if (position == 0) {\r\n    range = FreqMtfPos[1][0] * (range / (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    FreqMtfPos[1][0] += UP_FREQ_MTF_POS;\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[1][0];\r\n    uint16_t * StopFreqPtr = \u0026FreqMtfPos[1][position];\r\n    RangeLow = *FreqPtr++;\r\n    while (FreqPtr != StopFreqPtr)\r\n      RangeLow += *FreqPtr++;\r\n    low += RangeLow * (range /= (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    range *= *FreqPtr;\r\n\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n    }\r\n    else\r\n      *FreqPtr += UP_FREQ_MTF_POS;\r\n  }\r\n  if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":770,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3436128":{"score":0.86675406,"function_name":"EncodeMtfPosAz","code":"void EncodeMtfPosAz(uint8_t position, uint16_t QueueSize) {\r\n  NormalizeEncoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_az \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_az += FreqMtfPos[1][--last_queue_size_az];\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  else if (last_queue_size_az \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_az -= FreqMtfPos[1][last_queue_size_az++];\r\n      if (last_queue_size_az \u003e rescale_queue_size_az) {\r\n        rescale_queue_size_az++;\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 16;\r\n        RangeScaleMtfPos[1] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 4;\r\n        RangeScaleMtfPos[1] += 4;\r\n      }\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  if (RangeScaleMtfPos[1] \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n\r\n  if (position == 0) {\r\n    range = FreqMtfPos[1][0] * (range / (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    FreqMtfPos[1][0] += UP_FREQ_MTF_POS;\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[1][0];\r\n    uint16_t * StopFreqPtr = \u0026FreqMtfPos[1][position];\r\n    RangeLow = *FreqPtr++;\r\n    while (FreqPtr != StopFreqPtr)\r\n      RangeLow += *FreqPtr++;\r\n    low += RangeLow * (range /= (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n    range *= *FreqPtr;\r\n\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n    }\r\n    else\r\n      *FreqPtr += UP_FREQ_MTF_POS;\r\n  }\r\n  if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":770,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3436784":{"score":0.78073585,"function_name":"EncodeSID","code":"void EncodeSID(uint8_t Context, uint8_t SIDSymbol) {\r\n  NormalizeEncoder(FREQ_SID_BOT);\r\n  if (SIDSymbol == 0) {\r\n    range = FreqSID[Context][0] * (range / RangeScaleSID[Context]);\r\n    FreqSID[Context][0] += UP_FREQ_SID;\r\n  }\r\n  else {\r\n    RangeLow = FreqSID[Context][0];\r\n    uint8_t Symbol = 1;\r\n    while (Symbol != SIDSymbol)\r\n      RangeLow += FreqSID[Context][Symbol++];\r\n    low += RangeLow * (range /= RangeScaleSID[Context]);\r\n    range *= FreqSID[Context][SIDSymbol];\r\n    FreqSID[Context][SIDSymbol] += UP_FREQ_SID;\r\n  }\r\n  if ((RangeScaleSID[Context] += UP_FREQ_SID) \u003e FREQ_SID_BOT)\r\n    rescaleSID(Context);\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":959,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3437168":{"score":0.7093802,"function_name":"EncodeINST","code":"void EncodeINST(uint8_t Context, uint8_t SIDSymbol, uint8_t Symbol) {\r\n  NormalizeEncoder(FREQ_INST_BOT);\r\n  uint32_t old_range = range;\r\n  range /= RangeScaleINST[Context][SIDSymbol];\r\n  if (Symbol == 0) {\r\n    range = old_range - range * (RangeScaleINST[Context][SIDSymbol] - FreqINST[Context][SIDSymbol][0]);\r\n    if (RangeScaleINST[Context][SIDSymbol] \u003e= (FREQ_INST_BOT \u003e\u003e 1)) {\r\n      FreqINST[Context][SIDSymbol][0] += RangeScaleINST[Context][SIDSymbol] \u003e\u003e 11;\r\n      if ((RangeScaleINST[Context][SIDSymbol] += (RangeScaleINST[Context][SIDSymbol]) \u003e\u003e 11) \u003e FREQ_INST_BOT)\r\n        rescaleINST(Context, SIDSymbol);\r\n    }\r\n    else {\r\n      FreqINST[Context][SIDSymbol][0] += UP_FREQ_INST;\r\n      RangeScaleINST[Context][SIDSymbol] += UP_FREQ_INST;\r\n    }\r\n  }\r\n  else {\r\n    RangeLow = FreqINST[Context][SIDSymbol][0];\r\n    uint8_t FoundIndex = 1;\r\n    while (FoundIndex != Symbol)\r\n      RangeLow += FreqINST[Context][SIDSymbol][FoundIndex++];\r\n    low += range * RangeLow + old_range - range * RangeScaleINST[Context][SIDSymbol];\r\n    range *= FreqINST[Context][SIDSymbol][FoundIndex];\r\n    if (RangeScaleINST[Context][SIDSymbol] \u003e= (FREQ_INST_BOT \u003e\u003e 1)) {\r\n      FreqINST[Context][SIDSymbol][FoundIndex] += RangeScaleINST[Context][SIDSymbol] \u003e\u003e 11;\r\n      if ((RangeScaleINST[Context][SIDSymbol] += (RangeScaleINST[Context][SIDSymbol]) \u003e\u003e 11) \u003e FREQ_INST_BOT)\r\n        rescaleINST(Context, SIDSymbol);\r\n    }\r\n    else {\r\n      FreqINST[Context][SIDSymbol][FoundIndex] += UP_FREQ_INST;\r\n      RangeScaleINST[Context][SIDSymbol] += UP_FREQ_INST;\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":987,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3437744":{"score":0.8219305,"function_name":"EncodeERG","code":"void EncodeERG(uint16_t Context1, uint16_t Context2, uint8_t Symbol) {\r\n  NormalizeEncoder(FREQ_ERG_BOT);\r\n  uint32_t extra_range = range \u0026 (FREQ_ERG_BOT - 1);\r\n  if (Symbol == 0) {\r\n    range = (FreqERG[0] + FreqERG[Context1] + FreqERG[Context2]) * (range \u003e\u003e 13) + extra_range;\r\n    FreqERG[0] += (0x400 - FreqERG[0]) \u003e\u003e 2;\r\n    FreqERG[Context1] += (0x1000 - FreqERG[Context1]) \u003e\u003e 4;\r\n    FreqERG[Context2] += (0xC00 - FreqERG[Context2]) \u003e\u003e 3;\r\n  }\r\n  else {\r\n    low += (FreqERG[0] + FreqERG[Context1] + FreqERG[Context2]) * (range \u003e\u003e= 13) + extra_range;\r\n    range *= 0x2000 - (FreqERG[0] + FreqERG[Context1] + FreqERG[Context2]);\r\n    FreqERG[0] -= FreqERG[0] \u003e\u003e 2;\r\n    FreqERG[Context1] -= FreqERG[Context1] \u003e\u003e 4;\r\n    FreqERG[Context2] -= FreqERG[Context2] \u003e\u003e 3;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":1023,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3438032":{"score":0.86850655,"function_name":"EncodeGoMtf","code":"void EncodeGoMtf(uint16_t Context1, uint8_t Context2, uint8_t Symbol) {\r\n  NormalizeEncoder(FREQ_GO_MTF_BOT);\r\n  uint32_t extra_range = range \u0026 (FREQ_GO_MTF_BOT - 1);\r\n  Context1 += 0xF0 * Context2;\r\n  uint16_t Context3 = Context1 + 0x2D0;\r\n  if (Symbol == 0) {\r\n    range = (FreqGoMtf[Context1] + FreqGoMtf[Context2] + 2 * FreqGoMtf[Context3]) * (range \u003e\u003e 13) + extra_range;\r\n    FreqGoMtf[Context1] += (0x800 - FreqGoMtf[Context1]) \u003e\u003e 2;\r\n    FreqGoMtf[Context2] += (0x800 - FreqGoMtf[Context2]) \u003e\u003e 2;\r\n    FreqGoMtf[Context3] += (0x800 - FreqGoMtf[Context3]) \u003e\u003e 6;\r\n  }\r\n  else {\r\n    low += (FreqGoMtf[Context1] + FreqGoMtf[Context2] + 2 * FreqGoMtf[Context3]) * (range \u003e\u003e= 13) + extra_range;\r\n    range *= 0x2000 - (FreqGoMtf[Context1] + FreqGoMtf[Context2] + 2 * FreqGoMtf[Context3]);\r\n    FreqGoMtf[Context1] -= FreqGoMtf[Context1] \u003e\u003e 2;\r\n    FreqGoMtf[Context2] -= FreqGoMtf[Context2] \u003e\u003e 2;\r\n    FreqGoMtf[Context3] -= FreqGoMtf[Context3] \u003e\u003e 6;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":1042,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3438320":{"score":0.8726941,"function_name":"EncodeWordTag","code":"void EncodeWordTag(uint8_t Symbol, uint8_t Context) {\r\n  NormalizeEncoder(FREQ_WORD_TAG_BOT);\r\n  uint32_t extra_range = range \u0026 (FREQ_WORD_TAG_BOT - 1);\r\n  if (Symbol == 0) {\r\n    range = FreqWordTag[Context] * (range \u003e\u003e 12) + extra_range;\r\n    FreqWordTag[Context] += (0x1000 - FreqWordTag[Context]) \u003e\u003e 4;\r\n  }\r\n  else {\r\n    low += FreqWordTag[Context] * (range \u003e\u003e= 12) + extra_range;\r\n    range *= 0x1000 - FreqWordTag[Context];\r\n    FreqWordTag[Context] -= FreqWordTag[Context] \u003e\u003e 4;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":1063,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3438528":{"score":0.8642196,"function_name":"EncodeLongDictionarySymbol","code":"void EncodeLongDictionarySymbol(uint32_t BinCode, uint16_t BinNum, uint16_t DictionaryBins, uint8_t CodeLength,\r\n    uint16_t CodeBins) {\r\n  NormalizeEncoder((uint32_t)1 \u003c\u003c 12);\r\n  low += BinNum * (range /= DictionaryBins);\r\n  NormalizeEncoder((uint32_t)1 \u003c\u003c CodeLength);\r\n  low += BinCode * (range \u003e\u003e= CodeLength);\r\n  range *= (uint32_t)CodeBins;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":1085,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3438704":{"score":0.8963911,"function_name":"EncodeFirstChar","code":"void EncodeFirstChar(uint8_t Symbol, uint8_t SymType, uint8_t LastChar) {\r\n  NormalizeEncoder(FREQ_FIRST_CHAR_BOT);\r\n  if (Symbol == SymbolFirstChar[SymType][LastChar][0]) {\r\n    range = FreqFirstChar[SymType][LastChar][0] * (range / RangeScaleFirstChar[SymType][LastChar]);\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      FreqFirstChar[SymType][LastChar][0] += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      FreqFirstChar[SymType][LastChar][0] += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n  }\r\n  else {\r\n    RangeLow = FreqFirstChar[SymType][LastChar][0];\r\n    uint8_t FoundIndex = 1;\r\n    while (SymbolFirstChar[SymType][LastChar][FoundIndex] != Symbol)\r\n      RangeLow += FreqFirstChar[SymType][LastChar][FoundIndex++];\r\n    low += RangeLow * (range /= RangeScaleFirstChar[SymType][LastChar]);\r\n    range *= FreqFirstChar[SymType][LastChar][FoundIndex];\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      FreqFirstChar[SymType][LastChar][FoundIndex] += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      FreqFirstChar[SymType][LastChar][FoundIndex] += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n    if (FreqFirstChar[SymType][LastChar][FoundIndex] \u003e FreqFirstChar[SymType][LastChar][FoundIndex - 1]) {\r\n      uint16_t SavedFreq = FreqFirstChar[SymType][LastChar][FoundIndex];\r\n      do {\r\n        FreqFirstChar[SymType][LastChar][FoundIndex] = FreqFirstChar[SymType][LastChar][FoundIndex - 1];\r\n        SymbolFirstChar[SymType][LastChar][FoundIndex] = SymbolFirstChar[SymType][LastChar][FoundIndex - 1];\r\n      } while ((--FoundIndex) \u0026\u0026 (SavedFreq \u003e FreqFirstChar[SymType][LastChar][FoundIndex - 1]));\r\n      FreqFirstChar[SymType][LastChar][FoundIndex] = SavedFreq;\r\n      SymbolFirstChar[SymType][LastChar][FoundIndex] = Symbol;\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":1101,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3439392":{"score":0.8787484,"function_name":"UpdateFirstChar","code":"void UpdateFirstChar(uint8_t Symbol, uint8_t SymType, uint8_t LastChar) {\r\n  NormalizeEncoder(FREQ_FIRST_CHAR_BOT);\r\n  if (Symbol == SymbolFirstChar[SymType][LastChar][0]) {\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      FreqFirstChar[SymType][LastChar][0] += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      FreqFirstChar[SymType][LastChar][0] += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n  }\r\n  else {\r\n    uint8_t FoundIndex = 1;\r\n    while (SymbolFirstChar[SymType][LastChar][FoundIndex] != Symbol)\r\n      FoundIndex++;\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      FreqFirstChar[SymType][LastChar][FoundIndex] += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      FreqFirstChar[SymType][LastChar][FoundIndex] += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n    if (FreqFirstChar[SymType][LastChar][FoundIndex] \u003e FreqFirstChar[SymType][LastChar][FoundIndex - 1]) {\r\n      uint16_t SavedFreq = FreqFirstChar[SymType][LastChar][FoundIndex];\r\n      do {\r\n        FreqFirstChar[SymType][LastChar][FoundIndex] = FreqFirstChar[SymType][LastChar][FoundIndex - 1];\r\n        SymbolFirstChar[SymType][LastChar][FoundIndex] = SymbolFirstChar[SymType][LastChar][FoundIndex - 1];\r\n      } while ((--FoundIndex) \u0026\u0026 (SavedFreq \u003e FreqFirstChar[SymType][LastChar][FoundIndex - 1]));\r\n      FreqFirstChar[SymType][LastChar][FoundIndex] = SavedFreq;\r\n      SymbolFirstChar[SymType][LastChar][FoundIndex] = Symbol;\r\n    }\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":1144,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3439920":{"score":0.74743587,"function_name":"EncodeMtfPosOther","code":"void EncodeMtfPosOther(uint8_t position, uint16_t QueueSize) {\r\n  NormalizeEncoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_other \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_other += FreqMtfPos[3][--last_queue_size_other];\r\n    } while (last_queue_size_other != QueueSize);\r\n  }\r\n  else if (last_queue_size_other \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_other -= FreqMtfPos[3][last_queue_size_other++];\r\n      if (last_queue_size_other \u003e rescale_queue_size_other) {\r\n        rescale_queue_size_other++;\r\n        FreqMtfPos[3][last_queue_size_other - 1] += 16;\r\n        RangeScaleMtfPos[3] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[3][last_queue_size_other - 1] += 4;\r\n        RangeScaleMtfPos[3] += 4;\r\n      }\r\n    } while (last_queue_size_other != QueueSize);\r\n  }\r\n  if (RangeScaleMtfPos[3] \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(3);\r\n  if (position == 0) {\r\n    range = FreqMtfPos[3][0] * (range / (RangeScaleMtfPos[3] - unused_queue_freq_other));\r\n    FreqMtfPos[3][0] += UP_FREQ_MTF_POS;\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[3][0];\r\n    uint16_t * StopFreqPtr = \u0026FreqMtfPos[3][position];\r\n    RangeLow = *FreqPtr++;\r\n    while (FreqPtr != StopFreqPtr)\r\n      RangeLow += *FreqPtr++;\r\n    low += RangeLow * (range /= (RangeScaleMtfPos[3] - unused_queue_freq_other));\r\n    range *= *FreqPtr;\r\n\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_other += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position + 1 == QueueSize)\r\n          unused_queue_freq_other += 1;\r\n      }\r\n    }\r\n    else\r\n      *FreqPtr += UP_FREQ_MTF_POS;\r\n  }\r\n  if ((RangeScaleMtfPos[3] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(3);\r\n}","filepath":"glza/GLZAmodel.c","line_number":897,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3441376":{"score":0.8898265,"function_name":"InitEncoder","code":"void InitEncoder(uint8_t max_code_length, uint8_t max_base_code, uint8_t num_inst_codes, uint8_t cap_encoded,\r\n    uint8_t UTF8_compliant, uint8_t use_mtf) {\r\n  MaxBaseCode = max_base_code;\r\n  MaxInstCode = num_inst_codes - 1;\r\n  OutCharNum = 0;\r\n  low = 0, range = -1;\r\n  StartModelSymType(use_mtf, cap_encoded);\r\n  StartModelMtfFirst();\r\n  StartModelMtfQueuePos(max_code_length);\r\n  StartModelSID();\r\n  StartModelINST(num_inst_codes);\r\n  StartModelERG();\r\n  StartModelGoQueue();\r\n  StartModelWordTag();\r\n  if (cap_encoded || UTF8_compliant)\r\n    StartModelFirstChar();\r\n  else\r\n    StartModelFirstCharBinary();\r\n}","filepath":"glza/GLZAmodel.c","line_number":1295,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3441792":{"score":0.74901783,"function_name":"NormalizeEncoder","code":"void NormalizeEncoder(uint32_t bot) {\r\n  while ((low ^ (low + range)) \u003c TOP || (range \u003c bot \u0026\u0026 ((range = -low \u0026 (bot - 1)), 1))) {\r\n    OutBuffer[OutCharNum++] = (uint8_t)(low \u003e\u003e 24);\r\n    range \u003c\u003c= 8;\r\n    low \u003c\u003c= 8;\r\n  }\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":525,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3441920":{"score":0.7913995,"function_name":"DecodeSymType1","code":"uint8_t DecodeSymType1(uint8_t Context1) {\r\n  uint32_t dict_range;\r\n  NormalizeDecoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  if ((dict_range = (range \u003e\u003e= 14) * FreqSymTypePriorType[Context1][0] + extra_range) \u003e code - low) {\r\n    range = dict_range;\r\n    uint16_t delta = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n    FreqSymTypePriorType[Context1][0]\r\n        += delta + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n    FreqSymTypePriorType[Context1][1] -= delta;\r\n    return(0);\r\n  }\r\n  else if (dict_range + range * FreqSymTypePriorType[Context1][1] \u003e code - low) {\r\n    low += dict_range;\r\n    range *= FreqSymTypePriorType[Context1][1];\r\n    uint16_t delta = FreqSymTypePriorType[Context1][0] \u003e\u003e 6;\r\n    FreqSymTypePriorType[Context1][1]\r\n        += delta + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n    FreqSymTypePriorType[Context1][0] -= delta;\r\n    return(1);\r\n  }\r\n  else {\r\n    low += dict_range + range * FreqSymTypePriorType[Context1][1];\r\n    range *= (FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]);\r\n    FreqSymTypePriorType[Context1][0] -= FreqSymTypePriorType[Context1][0] \u003e\u003e 6;\r\n    FreqSymTypePriorType[Context1][1] -= FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n    return(2);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1330,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3442224":{"score":0.7695618,"function_name":"DecodeSymType2","code":"uint8_t DecodeSymType2(uint8_t Context1, uint8_t Context2) {\r\n  uint32_t dict_range;\r\n  NormalizeDecoder(2 * FREQ_SYM_TYPE_BOT2);\r\n  uint32_t extra_range = range \u0026 (2 * FREQ_SYM_TYPE_BOT2 - 1);\r\n  if ((dict_range = (range \u003e\u003e= 14)\r\n      * (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0]) + extra_range) \u003e code - low) {\r\n    range = dict_range;\r\n    uint16_t delta = FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context1][0]\r\n        += delta + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n    FreqSymTypePriorType[Context1][1] -= delta;\r\n    delta = FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n    FreqSymTypePriorType[Context2][0]\r\n        += delta + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n    FreqSymTypePriorType[Context2][1] -= delta;\r\n    return(0);\r\n  }\r\n  else if (dict_range + range * (FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1]) \u003e code - low) {\r\n    low += dict_range;\r\n    range *= (FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1]);\r\n    uint16_t delta = FreqSymTypePriorType[Context1][0] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context1][1]\r\n        += delta + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n    FreqSymTypePriorType[Context1][0] -= delta;\r\n    delta = FreqSymTypePriorType[Context2][0] \u003e\u003e 7;\r\n    FreqSymTypePriorType[Context2][1]\r\n        += delta + ((FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n    FreqSymTypePriorType[Context2][0] -= delta;\r\n    return(1);\r\n  }\r\n  else {\r\n    low += dict_range + range * (FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1]);\r\n    range *= (2 * FREQ_SYM_TYPE_BOT2 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context2][0]\r\n        - FreqSymTypePriorType[Context1][1] - FreqSymTypePriorType[Context2][1]);\r\n    FreqSymTypePriorType[Context1][0] -= FreqSymTypePriorType[Context1][0] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context1][1] -= FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context2][0] -= FreqSymTypePriorType[Context2][0] \u003e\u003e 7;\r\n    FreqSymTypePriorType[Context2][1] -= FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n    return(2);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1360,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3442752":{"score":0.75254655,"function_name":"DecodeSymType3","code":"uint8_t DecodeSymType3(uint8_t Context1, uint8_t Context2, uint8_t Context3) {\r\n  uint32_t dict_range;\r\n  NormalizeDecoder(8 * FREQ_SYM_TYPE_BOT3);\r\n  uint32_t extra_range = range \u0026 (8 * FREQ_SYM_TYPE_BOT3 - 1);\r\n  if ((dict_range = (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context2][0]\r\n      + FreqSymTypePriorEnd[Context3][0]) * (range \u003e\u003e= 15) + extra_range) \u003e code - low) {\r\n    range = dict_range;\r\n    uint16_t delta = FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context1][0]\r\n        += delta + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n    FreqSymTypePriorType[Context1][1] -= delta;\r\n    delta = FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n    FreqSymTypePriorType[Context2][0]\r\n        += delta + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n    FreqSymTypePriorType[Context2][1] -= delta;\r\n    delta = FreqSymTypePriorEnd[Context3][1] \u003e\u003e 3;\r\n    FreqSymTypePriorEnd[Context3][0]\r\n        += delta + ((2 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorEnd[Context3][0] - FreqSymTypePriorEnd[Context3][1]) \u003e\u003e 3);\r\n    FreqSymTypePriorEnd[Context3][1] -= delta;\r\n    return(0);\r\n  }\r\n  else if (dict_range + range * (FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1]\r\n      + FreqSymTypePriorEnd[Context3][1]) \u003e code - low) {\r\n    low += dict_range;\r\n    range *= FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1] + FreqSymTypePriorEnd[Context3][1];\r\n    uint16_t delta = FreqSymTypePriorType[Context1][0] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context1][1]\r\n        += delta + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 4);\r\n    FreqSymTypePriorType[Context1][0] -= delta;\r\n    delta = FreqSymTypePriorType[Context2][0] \u003e\u003e 7;\r\n    FreqSymTypePriorType[Context2][1]\r\n        += delta + ((3 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorType[Context2][0] - FreqSymTypePriorType[Context2][1]) \u003e\u003e 7);\r\n    FreqSymTypePriorType[Context2][0] -= delta;\r\n    delta = FreqSymTypePriorEnd[Context3][0] \u003e\u003e 3;\r\n    FreqSymTypePriorEnd[Context3][1]\r\n        += delta + ((2 * FREQ_SYM_TYPE_BOT3 - FreqSymTypePriorEnd[Context3][0] - FreqSymTypePriorEnd[Context3][1]) \u003e\u003e 3);\r\n    FreqSymTypePriorEnd[Context3][0] -= delta;\r\n    return(1);\r\n  }\r\n  else {\r\n    low += dict_range + range * (FreqSymTypePriorType[Context1][1] + FreqSymTypePriorType[Context2][1]\r\n        + FreqSymTypePriorEnd[Context3][1]);\r\n    range *= 8 * FREQ_SYM_TYPE_BOT3 - (FreqSymTypePriorType[Context1][0] + FreqSymTypePriorType[Context1][1])\r\n        - (FreqSymTypePriorType[Context2][0] + FreqSymTypePriorType[Context2][1])\r\n        - (FreqSymTypePriorEnd[Context3][0] + FreqSymTypePriorEnd[Context3][1]);\r\n    FreqSymTypePriorType[Context1][0] -= FreqSymTypePriorType[Context1][0] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context1][1] -= FreqSymTypePriorType[Context1][1] \u003e\u003e 4;\r\n    FreqSymTypePriorType[Context2][0] -= FreqSymTypePriorType[Context2][0] \u003e\u003e 7;\r\n    FreqSymTypePriorType[Context2][1] -= FreqSymTypePriorType[Context2][1] \u003e\u003e 7;\r\n    FreqSymTypePriorEnd[Context3][0] -= FreqSymTypePriorEnd[Context3][0] \u003e\u003e 3;\r\n    FreqSymTypePriorEnd[Context3][1] -= FreqSymTypePriorEnd[Context3][1] \u003e\u003e 3;\r\n    return(2);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1402,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3443504":{"score":0.8010485,"function_name":"DecodeSymType1","code":"uint8_t DecodeSymType1(uint8_t Context1) {\r\n  uint32_t dict_range;\r\n  NormalizeDecoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  if ((dict_range = (range \u003e\u003e= 14) * FreqSymTypePriorType[Context1][0] + extra_range) \u003e code - low) {\r\n    range = dict_range;\r\n    uint16_t delta = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n    FreqSymTypePriorType[Context1][0]\r\n        += delta + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n    FreqSymTypePriorType[Context1][1] -= delta;\r\n    return(0);\r\n  }\r\n  else if (dict_range + range * FreqSymTypePriorType[Context1][1] \u003e code - low) {\r\n    low += dict_range;\r\n    range *= FreqSymTypePriorType[Context1][1];\r\n    uint16_t delta = FreqSymTypePriorType[Context1][0] \u003e\u003e 6;\r\n    FreqSymTypePriorType[Context1][1]\r\n        += delta + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n    FreqSymTypePriorType[Context1][0] -= delta;\r\n    return(1);\r\n  }\r\n  else {\r\n    low += dict_range + range * FreqSymTypePriorType[Context1][1];\r\n    range *= (FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]);\r\n    FreqSymTypePriorType[Context1][0] -= FreqSymTypePriorType[Context1][0] \u003e\u003e 6;\r\n    FreqSymTypePriorType[Context1][1] -= FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n    return(2);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1330,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3443808":{"score":0.7815186,"function_name":"DecodeMtfPosAz","code":"uint8_t DecodeMtfPosAz(uint16_t QueueSize) {\r\n  NormalizeDecoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_az \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_az += FreqMtfPos[1][--last_queue_size_az];\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  else if (last_queue_size_az \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_az -= FreqMtfPos[1][last_queue_size_az++];\r\n      if (last_queue_size_az \u003e rescale_queue_size_az) {\r\n        rescale_queue_size_az++;\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 16;\r\n        RangeScaleMtfPos[1] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 4;\r\n        RangeScaleMtfPos[1] += 4;\r\n      }\r\n    } while (last_queue_size_az != QueueSize);\r\n    if (RangeScaleMtfPos[1] \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(1);\r\n  }\r\n  count = (code - low) / (range /= (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n  if ((RangeHigh = FreqMtfPos[1][0]) \u003e count) {\r\n    range *= RangeHigh;\r\n    FreqMtfPos[1][0] = RangeHigh + UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n    return(0);\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[1][1];\r\n    while ((RangeHigh += *FreqPtr) \u003c= count)\r\n      FreqPtr++;\r\n    uint8_t position = FreqPtr - \u0026FreqMtfPos[1][0];\r\n    low += range * (RangeHigh - *FreqPtr);\r\n    range *= *FreqPtr;\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n    }\r\n    else\r\n       *FreqPtr += UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(1);\r\n    return(position);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1561,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3444544":{"score":0.79833627,"function_name":"DecodeMtfPosAz","code":"uint8_t DecodeMtfPosAz(uint16_t QueueSize) {\r\n  NormalizeDecoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_az \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_az += FreqMtfPos[1][--last_queue_size_az];\r\n    } while (last_queue_size_az != QueueSize);\r\n  }\r\n  else if (last_queue_size_az \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_az -= FreqMtfPos[1][last_queue_size_az++];\r\n      if (last_queue_size_az \u003e rescale_queue_size_az) {\r\n        rescale_queue_size_az++;\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 16;\r\n        RangeScaleMtfPos[1] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[1][last_queue_size_az - 1] += 4;\r\n        RangeScaleMtfPos[1] += 4;\r\n      }\r\n    } while (last_queue_size_az != QueueSize);\r\n    if (RangeScaleMtfPos[1] \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(1);\r\n  }\r\n  count = (code - low) / (range /= (RangeScaleMtfPos[1] - unused_queue_freq_az));\r\n  if ((RangeHigh = FreqMtfPos[1][0]) \u003e count) {\r\n    range *= RangeHigh;\r\n    FreqMtfPos[1][0] = RangeHigh + UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(1);\r\n    return(0);\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[1][1];\r\n    while ((RangeHigh += *FreqPtr) \u003c= count)\r\n      FreqPtr++;\r\n    uint8_t position = FreqPtr - \u0026FreqMtfPos[1][0];\r\n    low += range * (RangeHigh - *FreqPtr);\r\n    range *= *FreqPtr;\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_az += 1;\r\n      }\r\n    }\r\n    else\r\n       *FreqPtr += UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[1] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(1);\r\n    return(position);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1561,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3445296":{"score":0.80098665,"function_name":"DecodeMtfPosSpace","code":"uint8_t DecodeMtfPosSpace(uint16_t QueueSize) {\r\n  NormalizeDecoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_space \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_space += FreqMtfPos[2][--last_queue_size_space];\r\n    } while (last_queue_size_space != QueueSize);\r\n  }\r\n  else if (last_queue_size_space \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_space -= FreqMtfPos[2][last_queue_size_space++];\r\n      if (last_queue_size_space \u003e rescale_queue_size_space) {\r\n        rescale_queue_size_space++;\r\n        FreqMtfPos[2][last_queue_size_space - 1] += 16;\r\n        RangeScaleMtfPos[2] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[2][last_queue_size_space - 1] += 4;\r\n        RangeScaleMtfPos[2] += 4;\r\n      }\r\n    } while (last_queue_size_space != QueueSize);\r\n    if (RangeScaleMtfPos[2] \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(2);\r\n  }\r\n  count = (code - low) / (range /= (RangeScaleMtfPos[2] - unused_queue_freq_space));\r\n  if ((RangeHigh = FreqMtfPos[2][0]) \u003e count) {\r\n    range *= RangeHigh;\r\n    FreqMtfPos[2][0] = RangeHigh + UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[2] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(2);\r\n    return(0);\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[2][1];\r\n    while ((RangeHigh += *FreqPtr) \u003c= count)\r\n      FreqPtr++;\r\n    uint8_t position = FreqPtr - \u0026FreqMtfPos[2][0];\r\n    low += range * (RangeHigh - *FreqPtr);\r\n    range *= *FreqPtr;\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_space += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_space += 1;\r\n      }\r\n    }\r\n    else\r\n       *FreqPtr += UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[2] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(2);\r\n    return(position);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1626,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3446048":{"score":0.7904174,"function_name":"DecodeMtfPosSpace","code":"uint8_t DecodeMtfPosSpace(uint16_t QueueSize) {\r\n  NormalizeDecoder(FREQ_MTF_POS_BOT);\r\n  if (last_queue_size_space \u003e QueueSize) {\r\n    do {\r\n      unused_queue_freq_space += FreqMtfPos[2][--last_queue_size_space];\r\n    } while (last_queue_size_space != QueueSize);\r\n  }\r\n  else if (last_queue_size_space \u003c QueueSize) {\r\n    do {\r\n      unused_queue_freq_space -= FreqMtfPos[2][last_queue_size_space++];\r\n      if (last_queue_size_space \u003e rescale_queue_size_space) {\r\n        rescale_queue_size_space++;\r\n        FreqMtfPos[2][last_queue_size_space - 1] += 16;\r\n        RangeScaleMtfPos[2] += 16;\r\n      }\r\n      else {\r\n        FreqMtfPos[2][last_queue_size_space - 1] += 4;\r\n        RangeScaleMtfPos[2] += 4;\r\n      }\r\n    } while (last_queue_size_space != QueueSize);\r\n    if (RangeScaleMtfPos[2] \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(2);\r\n  }\r\n  count = (code - low) / (range /= (RangeScaleMtfPos[2] - unused_queue_freq_space));\r\n  if ((RangeHigh = FreqMtfPos[2][0]) \u003e count) {\r\n    range *= RangeHigh;\r\n    FreqMtfPos[2][0] = RangeHigh + UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[2] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n    rescaleMtfQueuePos(2);\r\n    return(0);\r\n  }\r\n  else {\r\n    uint16_t * FreqPtr = \u0026FreqMtfPos[2][1];\r\n    while ((RangeHigh += *FreqPtr) \u003c= count)\r\n      FreqPtr++;\r\n    uint8_t position = FreqPtr - \u0026FreqMtfPos[2][0];\r\n    low += range * (RangeHigh - *FreqPtr);\r\n    range *= *FreqPtr;\r\n    if (position \u003e= 4) {\r\n      if (position == 4) {\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_space += 1;\r\n      }\r\n      else if (position == 255) {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 1;\r\n      }\r\n      else {\r\n        *(FreqPtr - 1) += 1;\r\n        *FreqPtr += UP_FREQ_MTF_POS - 2;\r\n        *(FreqPtr + 1) += 1;\r\n        if (position == QueueSize - 1)\r\n          unused_queue_freq_space += 1;\r\n      }\r\n    }\r\n    else\r\n       *FreqPtr += UP_FREQ_MTF_POS;\r\n    if ((RangeScaleMtfPos[2] += UP_FREQ_MTF_POS) \u003e FREQ_MTF_POS_BOT)\r\n      rescaleMtfQueuePos(2);\r\n    return(position);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1626,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3446800":{"score":0.73554623,"function_name":"DecodeFirstCharBinary","code":"uint8_t DecodeFirstCharBinary(uint8_t LastChar) {\r\n  NormalizeDecoder(FREQ_FIRST_CHAR_BOT);\r\n  count = (code - low) / (range /= RangeScaleFirstChar[0][LastChar]);\r\n  uint16_t * FreqPtr;\r\n  if (RangeScaleFirstCharSection[LastChar][3] \u003e count) {\r\n    RangeScaleFirstCharSection[LastChar][3] += UP_FREQ_FIRST_CHAR;\r\n    if (RangeScaleFirstCharSection[LastChar][1] \u003e count) {\r\n      RangeScaleFirstCharSection[LastChar][1] += UP_FREQ_FIRST_CHAR;\r\n      if (RangeScaleFirstCharSection[LastChar][0] \u003e count) {\r\n        RangeHigh = 0;\r\n        RangeScaleFirstCharSection[LastChar][0] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0];\r\n      }\r\n      else {\r\n        RangeHigh = RangeScaleFirstCharSection[LastChar][0];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x20];\r\n      }\r\n    }\r\n    else {\r\n      RangeHigh = RangeScaleFirstCharSection[LastChar][1];\r\n      if (RangeHigh + RangeScaleFirstCharSection[LastChar][2] \u003e count) {\r\n        RangeScaleFirstCharSection[LastChar][2] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x40];\r\n      }\r\n      else {\r\n        RangeHigh += RangeScaleFirstCharSection[LastChar][2];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x60];\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    RangeHigh = RangeScaleFirstCharSection[LastChar][3];\r\n    if (RangeHigh + RangeScaleFirstCharSection[LastChar][5] \u003e count) {\r\n      RangeScaleFirstCharSection[LastChar][5] += UP_FREQ_FIRST_CHAR;\r\n      if (RangeHigh + RangeScaleFirstCharSection[LastChar][4] \u003e count) {\r\n        RangeScaleFirstCharSection[LastChar][4] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x80];\r\n      }\r\n      else {\r\n        RangeHigh += RangeScaleFirstCharSection[LastChar][4];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0xA0];\r\n      }\r\n    }\r\n    else {\r\n      RangeHigh += RangeScaleFirstCharSection[LastChar][5];\r\n      if (RangeHigh + RangeScaleFirstCharSection[LastChar][6] \u003e count) {\r\n        RangeScaleFirstCharSection[LastChar][6] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0xC0];\r\n      }\r\n      else {\r\n        RangeHigh += RangeScaleFirstCharSection[LastChar][6];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0xE0];\r\n      }\r\n    }\r\n  }\r\n  while ((RangeHigh += *FreqPtr) \u003c= count)\r\n    FreqPtr++;\r\n  uint32_t FirstChar = FreqPtr - \u0026FreqFirstCharBinary[LastChar][0];\r\n  low += range * (RangeHigh - *FreqPtr);\r\n  range *= *FreqPtr;\r\n  *FreqPtr += UP_FREQ_FIRST_CHAR;\r\n  if ((RangeScaleFirstChar[0][LastChar] += UP_FREQ_FIRST_CHAR) \u003e FREQ_FIRST_CHAR_BOT)\r\n    rescaleFirstCharBinary(LastChar);\r\n  return(FirstChar);\r\n}","filepath":"glza/GLZAmodel.c","line_number":1970,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3447200":{"score":0.8216193,"function_name":"DecodeFirstChar","code":"uint8_t DecodeFirstChar(uint8_t SymType, uint8_t LastChar) {\r\n  NormalizeDecoder(FREQ_FIRST_CHAR_BOT);\r\n  range /= RangeScaleFirstChar[SymType][LastChar];\r\n  uint16_t * FreqPtr = \u0026FreqFirstChar[SymType][LastChar][0];\r\n  if ((RangeHigh = *FreqPtr) * range \u003e code - low) {\r\n    range *= RangeHigh;\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      *FreqPtr += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      *FreqPtr += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n    return(SymbolFirstChar[SymType][LastChar][0]);\r\n  }\r\n  else {\r\n    count = (code - low) / range;\r\n    uint16_t temp_range;\r\n    while ((temp_range = RangeHigh + *++FreqPtr) \u003c= count)\r\n      RangeHigh = temp_range;\r\n    low += range * RangeHigh;\r\n    range *= *FreqPtr;\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      *FreqPtr += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      *FreqPtr += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n    uint8_t FoundIndex = FreqPtr - \u0026FreqFirstChar[SymType][LastChar][0];\r\n    uint32_t FirstChar = SymbolFirstChar[SymType][LastChar][FoundIndex];\r\n    if (*FreqPtr \u003e *(FreqPtr - 1)) {\r\n      uint16_t SavedFreq = *FreqPtr;\r\n      uint8_t * SymbolPtr = \u0026SymbolFirstChar[SymType][LastChar][FoundIndex];\r\n      do {\r\n        *FreqPtr = *(FreqPtr - 1);\r\n        FreqPtr--;\r\n        *SymbolPtr = *(SymbolPtr - 1);\r\n        SymbolPtr--;\r\n      } while ((FreqPtr != \u0026FreqFirstChar[SymType][LastChar][0]) \u0026\u0026 (SavedFreq \u003e *(FreqPtr - 1)));\r\n      *FreqPtr = SavedFreq;\r\n      *SymbolPtr = FirstChar;\r\n    }\r\n    return(FirstChar);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1919,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3447824":{"score":0.76882315,"function_name":"DecodeERG","code":"uint8_t DecodeERG(uint16_t Context1, uint16_t Context2) {\r\n  NormalizeDecoder(FREQ_ERG_BOT);\r\n  uint32_t extra_range = range \u0026 (FREQ_ERG_BOT - 1);\r\n  if ((FreqERG[0] + FreqERG[Context1] + FreqERG[Context2]) * (range \u003e\u003e= 13) + extra_range \u003e code - low) {\r\n    range = range * (FreqERG[0] + FreqERG[Context1] + FreqERG[Context2]) + extra_range;\r\n    FreqERG[0] += (0x400 - FreqERG[0]) \u003e\u003e 2;\r\n    FreqERG[Context1] += (0x1000 - FreqERG[Context1]) \u003e\u003e 4;\r\n    FreqERG[Context2] += (0xC00 - FreqERG[Context2]) \u003e\u003e 3;\r\n    return(0);\r\n  }\r\n  else {\r\n    low += range * (FreqERG[0] + FreqERG[Context1] + FreqERG[Context2]) + extra_range;\r\n    range *= 0x2000 - (FreqERG[0] + FreqERG[Context1] + FreqERG[Context2]);\r\n    FreqERG[0] -= FreqERG[0] \u003e\u003e 2;\r\n    FreqERG[Context1] -= FreqERG[Context1] \u003e\u003e 4;\r\n    FreqERG[Context2] -= FreqERG[Context2] \u003e\u003e 3;\r\n    return(1);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1826,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3448112":{"score":0.8882395,"function_name":"DecodeGoMtf","code":"uint8_t DecodeGoMtf(uint16_t Context1, uint8_t Context2) {\r\n  uint8_t go_mtf;\r\n  NormalizeDecoder(FREQ_GO_MTF_BOT);\r\n  uint32_t extra_range = range \u0026 (FREQ_GO_MTF_BOT - 1);\r\n  Context1 += 0xF0 * Context2;\r\n  uint16_t Context3 = Context1 + 0x2D0;\r\n  if ((FreqGoMtf[Context1] + FreqGoMtf[Context2] + 2 * FreqGoMtf[Context3]) * (range \u003e\u003e= 13) + extra_range \u003e code - low) {\r\n    range = range * (FreqGoMtf[Context1] + FreqGoMtf[Context2] + 2 * FreqGoMtf[Context3]) + extra_range;\r\n    FreqGoMtf[Context1] += (0x800 - FreqGoMtf[Context1]) \u003e\u003e 2;\r\n    FreqGoMtf[Context2] += (0x800 - FreqGoMtf[Context2]) \u003e\u003e 2;\r\n    FreqGoMtf[Context3] += (0x800 - FreqGoMtf[Context3]) \u003e\u003e 6;\r\n    go_mtf = 0;\r\n  }\r\n  else {\r\n    low += range * (FreqGoMtf[Context1] + FreqGoMtf[Context2] + 2 * FreqGoMtf[Context3]) + extra_range;\r\n    range *= 0x2000 - (FreqGoMtf[Context1] + FreqGoMtf[Context2] + 2 * FreqGoMtf[Context3]);\r\n    FreqGoMtf[Context1] -= FreqGoMtf[Context1] \u003e\u003e 2;\r\n    FreqGoMtf[Context2] -= FreqGoMtf[Context2] \u003e\u003e 2;\r\n    FreqGoMtf[Context3] -= FreqGoMtf[Context3] \u003e\u003e 6;\r\n    go_mtf = 1;\r\n  }\r\n  return(go_mtf);\r\n}","filepath":"glza/GLZAmodel.c","line_number":1846,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3448416":{"score":0.78144836,"function_name":"DecodeWordTag","code":"uint8_t DecodeWordTag(uint8_t Context) {\r\n  uint8_t Tag;\r\n  NormalizeDecoder(FREQ_WORD_TAG_BOT);\r\n  uint32_t extra_range = range \u0026 (FREQ_WORD_TAG_BOT - 1);\r\n  if (FreqWordTag[Context] * (range \u003e\u003e= 12) + extra_range \u003e code - low) {\r\n    range = range * FreqWordTag[Context] + extra_range;\r\n    FreqWordTag[Context] += (0x1000 - FreqWordTag[Context]) \u003e\u003e 4;\r\n    Tag = 0;\r\n  }\r\n  else {\r\n    low += FreqWordTag[Context] * range + extra_range;\r\n    range *= 0x1000 - FreqWordTag[Context];\r\n    FreqWordTag[Context] -= FreqWordTag[Context] \u003e\u003e 4;\r\n    Tag = 1;\r\n  }\r\n  return(Tag);\r\n}","filepath":"glza/GLZAmodel.c","line_number":1870,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3448592":{"score":0.62156546,"function_name":"EncodeDictType1","code":"void EncodeDictType1(uint8_t Context1) {\r\n  NormalizeEncoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  range = FreqSymTypePriorType[Context1][0] * (range \u003e\u003e 14) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":534,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3448752":{"score":0.6014224,"function_name":"EncodeDictType1","code":"void EncodeDictType1(uint8_t Context1) {\r\n  NormalizeEncoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  range = FreqSymTypePriorType[Context1][0] * (range \u003e\u003e 14) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":534,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3448816":{"score":0.5993223,"function_name":"EncodeDictType1","code":"void EncodeDictType1(uint8_t Context1) {\r\n  NormalizeEncoder(FREQ_SYM_TYPE_BOT1);\r\n  uint32_t extra_range = range \u0026 (FREQ_SYM_TYPE_BOT1 - 1);\r\n  range = FreqSymTypePriorType[Context1][0] * (range \u003e\u003e 14) + extra_range;\r\n  uint16_t sum = FreqSymTypePriorType[Context1][1] \u003e\u003e 6;\r\n  FreqSymTypePriorType[Context1][0]\r\n      += sum + ((FREQ_SYM_TYPE_BOT1 - FreqSymTypePriorType[Context1][0] - FreqSymTypePriorType[Context1][1]) \u003e\u003e 6);\r\n  FreqSymTypePriorType[Context1][1] -= sum;\r\n  return;\r\n}","filepath":"glza/GLZAmodel.c","line_number":534,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3448880":{"score":0.8315775,"function_name":"DecodeFirstChar","code":"uint8_t DecodeFirstChar(uint8_t SymType, uint8_t LastChar) {\r\n  NormalizeDecoder(FREQ_FIRST_CHAR_BOT);\r\n  range /= RangeScaleFirstChar[SymType][LastChar];\r\n  uint16_t * FreqPtr = \u0026FreqFirstChar[SymType][LastChar][0];\r\n  if ((RangeHigh = *FreqPtr) * range \u003e code - low) {\r\n    range *= RangeHigh;\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      *FreqPtr += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      *FreqPtr += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n    return(SymbolFirstChar[SymType][LastChar][0]);\r\n  }\r\n  else {\r\n    count = (code - low) / range;\r\n    uint16_t temp_range;\r\n    while ((temp_range = RangeHigh + *++FreqPtr) \u003c= count)\r\n      RangeHigh = temp_range;\r\n    low += range * RangeHigh;\r\n    range *= *FreqPtr;\r\n    if (RangeScaleFirstChar[SymType][LastChar] \u003e= (FREQ_FIRST_CHAR_BOT \u003e\u003e 1)) {\r\n      *FreqPtr += RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9;\r\n      if ((RangeScaleFirstChar[SymType][LastChar] += (RangeScaleFirstChar[SymType][LastChar] \u003e\u003e 9)) \u003e FREQ_FIRST_CHAR_BOT)\r\n        rescaleFirstChar(SymType, LastChar);\r\n    }\r\n    else {\r\n      *FreqPtr += UP_FREQ_FIRST_CHAR;\r\n      RangeScaleFirstChar[SymType][LastChar] += UP_FREQ_FIRST_CHAR;\r\n    }\r\n    uint8_t FoundIndex = FreqPtr - \u0026FreqFirstChar[SymType][LastChar][0];\r\n    uint32_t FirstChar = SymbolFirstChar[SymType][LastChar][FoundIndex];\r\n    if (*FreqPtr \u003e *(FreqPtr - 1)) {\r\n      uint16_t SavedFreq = *FreqPtr;\r\n      uint8_t * SymbolPtr = \u0026SymbolFirstChar[SymType][LastChar][FoundIndex];\r\n      do {\r\n        *FreqPtr = *(FreqPtr - 1);\r\n        FreqPtr--;\r\n        *SymbolPtr = *(SymbolPtr - 1);\r\n        SymbolPtr--;\r\n      } while ((FreqPtr != \u0026FreqFirstChar[SymType][LastChar][0]) \u0026\u0026 (SavedFreq \u003e *(FreqPtr - 1)));\r\n      *FreqPtr = SavedFreq;\r\n      *SymbolPtr = FirstChar;\r\n    }\r\n    return(FirstChar);\r\n  }\r\n}","filepath":"glza/GLZAmodel.c","line_number":1919,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3449536":{"score":0.81072885,"function_name":"DecodeFirstCharBinary","code":"uint8_t DecodeFirstCharBinary(uint8_t LastChar) {\r\n  NormalizeDecoder(FREQ_FIRST_CHAR_BOT);\r\n  count = (code - low) / (range /= RangeScaleFirstChar[0][LastChar]);\r\n  uint16_t * FreqPtr;\r\n  if (RangeScaleFirstCharSection[LastChar][3] \u003e count) {\r\n    RangeScaleFirstCharSection[LastChar][3] += UP_FREQ_FIRST_CHAR;\r\n    if (RangeScaleFirstCharSection[LastChar][1] \u003e count) {\r\n      RangeScaleFirstCharSection[LastChar][1] += UP_FREQ_FIRST_CHAR;\r\n      if (RangeScaleFirstCharSection[LastChar][0] \u003e count) {\r\n        RangeHigh = 0;\r\n        RangeScaleFirstCharSection[LastChar][0] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0];\r\n      }\r\n      else {\r\n        RangeHigh = RangeScaleFirstCharSection[LastChar][0];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x20];\r\n      }\r\n    }\r\n    else {\r\n      RangeHigh = RangeScaleFirstCharSection[LastChar][1];\r\n      if (RangeHigh + RangeScaleFirstCharSection[LastChar][2] \u003e count) {\r\n        RangeScaleFirstCharSection[LastChar][2] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x40];\r\n      }\r\n      else {\r\n        RangeHigh += RangeScaleFirstCharSection[LastChar][2];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x60];\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    RangeHigh = RangeScaleFirstCharSection[LastChar][3];\r\n    if (RangeHigh + RangeScaleFirstCharSection[LastChar][5] \u003e count) {\r\n      RangeScaleFirstCharSection[LastChar][5] += UP_FREQ_FIRST_CHAR;\r\n      if (RangeHigh + RangeScaleFirstCharSection[LastChar][4] \u003e count) {\r\n        RangeScaleFirstCharSection[LastChar][4] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0x80];\r\n      }\r\n      else {\r\n        RangeHigh += RangeScaleFirstCharSection[LastChar][4];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0xA0];\r\n      }\r\n    }\r\n    else {\r\n      RangeHigh += RangeScaleFirstCharSection[LastChar][5];\r\n      if (RangeHigh + RangeScaleFirstCharSection[LastChar][6] \u003e count) {\r\n        RangeScaleFirstCharSection[LastChar][6] += UP_FREQ_FIRST_CHAR;\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0xC0];\r\n      }\r\n      else {\r\n        RangeHigh += RangeScaleFirstCharSection[LastChar][6];\r\n        FreqPtr = \u0026FreqFirstCharBinary[LastChar][0xE0];\r\n      }\r\n    }\r\n  }\r\n  while ((RangeHigh += *FreqPtr) \u003c= count)\r\n    FreqPtr++;\r\n  uint32_t FirstChar = FreqPtr - \u0026FreqFirstCharBinary[LastChar][0];\r\n  low += range * (RangeHigh - *FreqPtr);\r\n  range *= *FreqPtr;\r\n  *FreqPtr += UP_FREQ_FIRST_CHAR;\r\n  if ((RangeScaleFirstChar[0][LastChar] += UP_FREQ_FIRST_CHAR) \u003e FREQ_FIRST_CHAR_BOT)\r\n    rescaleFirstCharBinary(LastChar);\r\n  return(FirstChar);\r\n}","filepath":"glza/GLZAmodel.c","line_number":1970,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3450080":{"score":0.85128117,"function_name":"InitDecoder","code":"void InitDecoder(uint8_t max_code_length, uint8_t max_base_code, uint8_t num_inst_codes, uint8_t cap_encoded,\r\n    uint8_t UTF8_compliant, uint8_t use_mtf, uint8_t * inbuf) {\r\n  MaxBaseCode = max_base_code;\r\n  MaxInstCode = num_inst_codes - 1;\r\n  InBuffer = inbuf;\r\n  code = 0, range = -1;\r\n  for (low = 4; low != 0; low--)\r\n    code = (code \u003c\u003c 8) | InBuffer[InCharNum++];\r\n  StartModelSymType(use_mtf, cap_encoded);\r\n  StartModelMtfFirst();\r\n  StartModelMtfQueuePos(max_code_length);\r\n  StartModelSID();\r\n  StartModelINST(num_inst_codes);\r\n  StartModelERG();\r\n  StartModelGoQueue();\r\n  StartModelWordTag();\r\n  if (cap_encoded || UTF8_compliant)\r\n    StartModelFirstChar();\r\n  else\r\n    StartModelFirstCharBinary();\r\n}","filepath":"glza/GLZAmodel.c","line_number":2036,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"3467456":{"score":0.7830316,"function_name":"LZe_sequence_optimizer","code":"static int LZe_sequence_optimizer( struct LZ_encoder * const e,\n                                   const int reps[num_rep_distances],\n                                   const State state )\n  {\n  int main_len, num_pairs, i, rep, num_trials, len;\n  int rep_index = 0, cur = 0;\n  int replens[num_rep_distances];\n\n  if( e-\u003epending_num_pairs \u003e 0 )\t\t/* from previous call */\n    {\n    num_pairs = e-\u003epending_num_pairs;\n    e-\u003epending_num_pairs = 0;\n    }\n  else\n    num_pairs = LZe_read_match_distances( e );\n  main_len = ( num_pairs \u003e 0 ) ? e-\u003epairs[num_pairs-1].len : 0;\n\n  for( i = 0; i \u003c num_rep_distances; ++i )\n    {\n    replens[i] = Mb_true_match_len( \u0026e-\u003eeb.mb, 0, reps[i] + 1 );\n    if( replens[i] \u003e replens[rep_index] ) rep_index = i;\n    }\n  if( replens[rep_index] \u003e= e-\u003ematch_len_limit )\n    {\n    e-\u003etrials[0].price = replens[rep_index];\n    e-\u003etrials[0].dis4 = rep_index;\n    if( !LZe_move_and_update( e, replens[rep_index] ) ) return 0;\n    return replens[rep_index];\n    }\n\n  if( main_len \u003e= e-\u003ematch_len_limit )\n    {\n    e-\u003etrials[0].price = main_len;\n    e-\u003etrials[0].dis4 = e-\u003epairs[num_pairs-1].dis + num_rep_distances;\n    if( !LZe_move_and_update( e, main_len ) ) return 0;\n    return main_len;\n    }\n\n  {\n  const int pos_state = Mb_data_position( \u0026e-\u003eeb.mb ) \u0026 pos_state_mask;\n  const int match_price = price1( e-\u003eeb.bm_match[state][pos_state] );\n  const int rep_match_price = match_price + price1( e-\u003eeb.bm_rep[state] );\n  const uint8_t prev_byte = Mb_peek( \u0026e-\u003eeb.mb, 1 );\n  const uint8_t cur_byte = Mb_peek( \u0026e-\u003eeb.mb, 0 );\n  const uint8_t match_byte = Mb_peek( \u0026e-\u003eeb.mb, reps[0] + 1 );\n\n  e-\u003etrials[1].price = price0( e-\u003eeb.bm_match[state][pos_state] );\n  if( St_is_char( state ) )\n    e-\u003etrials[1].price += LZeb_price_literal( \u0026e-\u003eeb, prev_byte, cur_byte );\n  else\n    e-\u003etrials[1].price += LZeb_price_matched( \u0026e-\u003eeb, prev_byte, cur_byte, match_byte );\n  e-\u003etrials[1].dis4 = -1;\t\t\t\t/* literal */\n\n  if( match_byte == cur_byte )\n    Tr_update( \u0026e-\u003etrials[1], rep_match_price +\n               LZeb_price_shortrep( \u0026e-\u003eeb, state, pos_state ), 0, 0 );\n\n  num_trials = max( main_len, replens[rep_index] );\n\n  if( num_trials \u003c min_match_len )\n    {\n    e-\u003etrials[0].price = 1;\n    e-\u003etrials[0].dis4 = e-\u003etrials[1].dis4;\n    if( !Mb_move_pos( \u0026e-\u003eeb.mb ) ) return 0;\n    return 1;\n    }\n\n  e-\u003etrials[0].state = state;\n  for( i = 0; i \u003c num_rep_distances; ++i )\n    e-\u003etrials[0].reps[i] = reps[i];\n\n  for( len = min_match_len; len \u003c= num_trials; ++len )\n    e-\u003etrials[len].price = infinite_price;\n\n  for( rep = 0; rep \u003c num_rep_distances; ++rep )\n    {\n    int price;\n    if( replens[rep] \u003c min_match_len ) continue;\n    price = rep_match_price + LZeb_price_rep( \u0026e-\u003eeb, rep, state, pos_state );\n    for( len = min_match_len; len \u003c= replens[rep]; ++len )\n      Tr_update( \u0026e-\u003etrials[len], price +\n                 Lp_price( \u0026e-\u003erep_len_prices, len, pos_state ), rep, 0 );\n    }\n\n  if( main_len \u003e replens[0] )\n    {\n    const int normal_match_price = match_price + price0( e-\u003eeb.bm_rep[state] );\n    int i = 0, len = max( replens[0] + 1, min_match_len );\n    while( len \u003e e-\u003epairs[i].len ) ++i;\n    while( true )\n      {\n      const int dis = e-\u003epairs[i].dis;\n      Tr_update( \u0026e-\u003etrials[len], normal_match_price +\n                 LZe_price_pair( e, dis, len, pos_state ),\n                 dis + num_rep_distances, 0 );\n      if( ++len \u003e e-\u003epairs[i].len \u0026\u0026 ++i \u003e= num_pairs ) break;\n      }\n    }\n  }\n\n  while( true )\t\t\t\t/* price optimization loop */\n    {\n    struct Trial *cur_trial, *next_trial;\n    int newlen, pos_state, triable_bytes, len_limit;\n    int start_len = min_match_len;\n    int next_price, match_price, rep_match_price;\n    State cur_state;\n    uint8_t prev_byte, cur_byte, match_byte;\n\n    if( !Mb_move_pos( \u0026e-\u003eeb.mb ) ) return 0;\n    if( ++cur \u003e= num_trials )\t\t/* no more initialized trials */\n      {\n      LZe_backward( e, cur );\n      return cur;\n      }\n\n    num_pairs = LZe_read_match_distances( e );\n    newlen = ( num_pairs \u003e 0 ) ? e-\u003epairs[num_pairs-1].len : 0;\n    if( newlen \u003e= e-\u003ematch_len_limit )\n      {\n      e-\u003epending_num_pairs = num_pairs;\n      LZe_backward( e, cur );\n      return cur;\n      }\n\n    /* give final values to current trial */\n    cur_trial = \u0026e-\u003etrials[cur];\n    {\n    const int dis4 = cur_trial-\u003edis4;\n    int prev_index = cur_trial-\u003eprev_index;\n    const int prev_index2 = cur_trial-\u003eprev_index2;\n\n    if( prev_index2 == single_step_trial )\n      {\n      cur_state = e-\u003etrials[prev_index].state;\n      if( prev_index + 1 == cur )\t\t\t/* len == 1 */\n        {\n        if( dis4 == 0 ) cur_state = St_set_short_rep( cur_state );\n        else cur_state = St_set_char( cur_state );\t/* literal */\n        }\n      else if( dis4 \u003c num_rep_distances ) cur_state = St_set_rep( cur_state );\n      else cur_state = St_set_match( cur_state );\n      }\n    else\n      {\n      if( prev_index2 == dual_step_trial )\t/* dis4 == 0 (rep0) */\n        --prev_index;\n      else\t\t\t\t\t/* prev_index2 \u003e= 0 */\n        prev_index = prev_index2;\n      cur_state = St_set_char_rep();\n      }\n    cur_trial-\u003estate = cur_state;\n    for( i = 0; i \u003c num_rep_distances; ++i )\n      cur_trial-\u003ereps[i] = e-\u003etrials[prev_index].reps[i];\n    mtf_reps( dis4, cur_trial-\u003ereps );\t\t/* literal is ignored */\n    }\n\n    pos_state = Mb_data_position( \u0026e-\u003eeb.mb ) \u0026 pos_state_mask;\n    prev_byte = Mb_peek( \u0026e-\u003eeb.mb, 1 );\n    cur_byte = Mb_peek( \u0026e-\u003eeb.mb, 0 );\n    match_byte = Mb_peek( \u0026e-\u003eeb.mb, cur_trial-\u003ereps[0] + 1 );\n\n    next_price = cur_trial-\u003eprice +\n                 price0( e-\u003eeb.bm_match[cur_state][pos_state] );\n    if( St_is_char( cur_state ) )\n      next_price += LZeb_price_literal( \u0026e-\u003eeb, prev_byte, cur_byte );\n    else\n      next_price += LZeb_price_matched( \u0026e-\u003eeb, prev_byte, cur_byte, match_byte );\n\n    /* try last updates to next trial */\n    next_trial = \u0026e-\u003etrials[cur+1];\n\n    Tr_update( next_trial, next_price, -1, cur );\t/* literal */\n\n    match_price = cur_trial-\u003eprice + price1( e-\u003eeb.bm_match[cur_state][pos_state] );\n    rep_match_price = match_price + price1( e-\u003eeb.bm_rep[cur_state] );\n\n    if( match_byte == cur_byte \u0026\u0026 next_trial-\u003edis4 != 0 \u0026\u0026\n        next_trial-\u003eprev_index2 == single_step_trial )\n      {\n      const int price = rep_match_price +\n                        LZeb_price_shortrep( \u0026e-\u003eeb, cur_state, pos_state );\n      if( price \u003c= next_trial-\u003eprice )\n        {\n        next_trial-\u003eprice = price;\n        next_trial-\u003edis4 = 0;\t\t\t\t/* rep0 */\n        next_trial-\u003eprev_index = cur;\n        }\n      }\n\n    triable_bytes =\n      min( Mb_available_bytes( \u0026e-\u003eeb.mb ), max_num_trials - 1 - cur );\n    if( triable_bytes \u003c min_match_len ) continue;\n\n    len_limit = min( e-\u003ematch_len_limit, triable_bytes );\n\n    /* try literal + rep0 */\n    if( match_byte != cur_byte \u0026\u0026 next_trial-\u003eprev_index != cur )\n      {\n      const uint8_t * const data = Mb_ptr_to_current_pos( \u0026e-\u003eeb.mb );\n      const int dis = cur_trial-\u003ereps[0] + 1;\n      const int limit = min( e-\u003ematch_len_limit + 1, triable_bytes );\n      int len = 1;\n      while( len \u003c limit \u0026\u0026 data[len-dis] == data[len] ) ++len;\n      if( --len \u003e= min_match_len )\n        {\n        const int pos_state2 = ( pos_state + 1 ) \u0026 pos_state_mask;\n        const State state2 = St_set_char( cur_state );\n        const int price = next_price +\n                          price1( e-\u003eeb.bm_match[state2][pos_state2] ) +\n                          price1( e-\u003eeb.bm_rep[state2] ) +\n                          LZe_price_rep0_len( e, len, state2, pos_state2 );\n        while( num_trials \u003c cur + 1 + len )\n          e-\u003etrials[++num_trials].price = infinite_price;\n        Tr_update2( \u0026e-\u003etrials[cur+1+len], price, cur + 1 );\n        }\n      }\n\n    /* try rep distances */\n    for( rep = 0; rep \u003c num_rep_distances; ++rep )\n      {\n      const uint8_t * const data = Mb_ptr_to_current_pos( \u0026e-\u003eeb.mb );\n      const int dis = cur_trial-\u003ereps[rep] + 1;\n      int price;\n\n      if( data[0-dis] != data[0] || data[1-dis] != data[1] ) continue;\n      for( len = min_match_len; len \u003c len_limit; ++len )\n        if( data[len-dis] != data[len] ) break;\n      while( num_trials \u003c cur + len )\n        e-\u003etrials[++num_trials].price = infinite_price;\n      price = rep_match_price + LZeb_price_rep( \u0026e-\u003eeb, rep, cur_state, pos_state );\n      for( i = min_match_len; i \u003c= len; ++i )\n        Tr_update( \u0026e-\u003etrials[cur+i], price +\n                   Lp_price( \u0026e-\u003erep_len_prices, i, pos_state ), rep, cur );\n\n      if( rep == 0 ) start_len = len + 1;\t/* discard shorter matches */\n\n      /* try rep + literal + rep0 */\n      {\n      int len2 = len + 1;\n      const int limit = min( e-\u003ematch_len_limit + len2, triable_bytes );\n      int pos_state2;\n      State state2;\n      while( len2 \u003c limit \u0026\u0026 data[len2-dis] == data[len2] ) ++len2;\n      len2 -= len + 1;\n      if( len2 \u003c min_match_len ) continue;\n\n      pos_state2 = ( pos_state + len ) \u0026 pos_state_mask;\n      state2 = St_set_rep( cur_state );\n      price += Lp_price( \u0026e-\u003erep_len_prices, len, pos_state ) +\n               price0( e-\u003eeb.bm_match[state2][pos_state2] ) +\n               LZeb_price_matched( \u0026e-\u003eeb, data[len-1], data[len], data[len-dis] );\n      pos_state2 = ( pos_state2 + 1 ) \u0026 pos_state_mask;\n      state2 = St_set_char( state2 );\n      price += price1( e-\u003eeb.bm_match[state2][pos_state2] ) +\n               price1( e-\u003eeb.bm_rep[state2] ) +\n               LZe_price_rep0_len( e, len2, state2, pos_state2 );\n      while( num_trials \u003c cur + len + 1 + len2 )\n        e-\u003etrials[++num_trials].price = infinite_price;\n      Tr_update3( \u0026e-\u003etrials[cur+len+1+len2], price, rep, cur + len + 1, cur );\n      }\n      }\n\n    /* try matches */\n    if( newlen \u003e= start_len \u0026\u0026 newlen \u003c= len_limit )\n      {\n      int dis;\n      const int normal_match_price = match_price +\n                                     price0( e-\u003eeb.bm_rep[cur_state] );\n\n      while( num_trials \u003c cur + newlen )\n        e-\u003etrials[++num_trials].price = infinite_price;\n\n      i = 0;\n      while( e-\u003epairs[i].len \u003c start_len ) ++i;\n      dis = e-\u003epairs[i].dis;\n      for( len = start_len; ; ++len )\n        {\n        int price = normal_match_price + LZe_price_pair( e, dis, len, pos_state );\n        Tr_update( \u0026e-\u003etrials[cur+len], price, dis + num_rep_distances, cur );\n\n        /* try match + literal + rep0 */\n        if( len == e-\u003epairs[i].len )\n          {\n          const uint8_t * const data = Mb_ptr_to_current_pos( \u0026e-\u003eeb.mb );\n          const int dis2 = dis + 1;\n          int len2 = len + 1;\n          const int limit = min( e-\u003ematch_len_limit + len2, triable_bytes );\n          while( len2 \u003c limit \u0026\u0026 data[len2-dis2] == data[len2] ) ++len2;\n          len2 -= len + 1;\n          if( len2 \u003e= min_match_len )\n            {\n            int pos_state2 = ( pos_state + len ) \u0026 pos_state_mask;\n            State state2 = St_set_match( cur_state );\n            price += price0( e-\u003eeb.bm_match[state2][pos_state2] ) +\n                     LZeb_price_matched( \u0026e-\u003eeb, data[len-1], data[len], data[len-dis2] );\n            pos_state2 = ( pos_state2 + 1 ) \u0026 pos_state_mask;\n            state2 = St_set_char( state2 );\n            price += price1( e-\u003eeb.bm_match[state2][pos_state2] ) +\n                     price1( e-\u003eeb.bm_rep[state2] ) +\n                     LZe_price_rep0_len( e, len2, state2, pos_state2 );\n\n            while( num_trials \u003c cur + len + 1 + len2 )\n              e-\u003etrials[++num_trials].price = infinite_price;\n            Tr_update3( \u0026e-\u003etrials[cur+len+1+len2], price,\n                        dis + num_rep_distances, cur + len + 1, cur );\n            }\n          if( ++i \u003e= num_pairs ) break;\n          dis = e-\u003epairs[i].dis;\n          }\n        }\n      }\n    }\n  }","filepath":"lzlib-1.11/encoder.c","line_number":167,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3475776":{"score":0.76565635,"function_name":"LZe_encode_member","code":"static bool LZe_encode_member( struct LZ_encoder * const e )\n  {\n  const bool best = ( e-\u003ematch_len_limit \u003e 12 );\n  const int dis_price_count = best ? 1 : 512;\n  const int align_price_count = best ? 1 : dis_align_size;\n  const int price_count = ( e-\u003ematch_len_limit \u003e 36 ) ? 1013 : 4093;\n  int ahead, i;\n  State * const state = \u0026e-\u003eeb.state;\n\n  if( e-\u003eeb.member_finished ) return true;\n  if( Re_member_position( \u0026e-\u003eeb.renc ) \u003e= e-\u003eeb.member_size_limit )\n    { LZeb_try_full_flush( \u0026e-\u003eeb ); return true; }\n\n  if( Mb_data_position( \u0026e-\u003eeb.mb ) == 0 \u0026\u0026\n      !Mb_data_finished( \u0026e-\u003eeb.mb ) )\t\t/* encode first byte */\n    {\n    const uint8_t prev_byte = 0;\n    uint8_t cur_byte;\n    if( !Mb_enough_available_bytes( \u0026e-\u003eeb.mb ) ||\n        !Re_enough_free_bytes( \u0026e-\u003eeb.renc ) ) return true;\n    cur_byte = Mb_peek( \u0026e-\u003eeb.mb, 0 );\n    Re_encode_bit( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.bm_match[*state][0], 0 );\n    LZeb_encode_literal( \u0026e-\u003eeb, prev_byte, cur_byte );\n    CRC32_update_byte( \u0026e-\u003eeb.crc, cur_byte );\n    LZe_get_match_pairs( e, 0 );\n    if( !Mb_move_pos( \u0026e-\u003eeb.mb ) ) return false;\n    }\n\n  while( !Mb_data_finished( \u0026e-\u003eeb.mb ) )\n    {\n    if( !Mb_enough_available_bytes( \u0026e-\u003eeb.mb ) ||\n        !Re_enough_free_bytes( \u0026e-\u003eeb.renc ) ) return true;\n    if( e-\u003eprice_counter \u003c= 0 \u0026\u0026 e-\u003epending_num_pairs == 0 )\n      {\n      e-\u003eprice_counter = price_count;\t/* recalculate prices every these bytes */\n      if( e-\u003edis_price_counter \u003c= 0 )\n        { e-\u003edis_price_counter = dis_price_count; LZe_update_distance_prices( e ); }\n      if( e-\u003ealign_price_counter \u003c= 0 )\n        {\n        e-\u003ealign_price_counter = align_price_count;\n        for( i = 0; i \u003c dis_align_size; ++i )\n          e-\u003ealign_prices[i] = price_symbol_reversed( e-\u003eeb.bm_align, i, dis_align_bits );\n        }\n      Lp_update_prices( \u0026e-\u003ematch_len_prices );\n      Lp_update_prices( \u0026e-\u003erep_len_prices );\n      }\n\n    ahead = LZe_sequence_optimizer( e, e-\u003eeb.reps, *state );\n    e-\u003eprice_counter -= ahead;\n\n    for( i = 0; ahead \u003e 0; )\n      {\n      const int pos_state =\n        ( Mb_data_position( \u0026e-\u003eeb.mb ) - ahead ) \u0026 pos_state_mask;\n      const int len = e-\u003etrials[i].price;\n      int dis = e-\u003etrials[i].dis4;\n\n      bool bit = ( dis \u003c 0 );\n      Re_encode_bit( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.bm_match[*state][pos_state], !bit );\n      if( bit )\t\t\t\t\t/* literal byte */\n        {\n        const uint8_t prev_byte = Mb_peek( \u0026e-\u003eeb.mb, ahead + 1 );\n        const uint8_t cur_byte = Mb_peek( \u0026e-\u003eeb.mb, ahead );\n        CRC32_update_byte( \u0026e-\u003eeb.crc, cur_byte );\n        if( St_is_char( *state ) )\n          LZeb_encode_literal( \u0026e-\u003eeb, prev_byte, cur_byte );\n        else\n          {\n          const uint8_t match_byte = Mb_peek( \u0026e-\u003eeb.mb, ahead + e-\u003eeb.reps[0] + 1 );\n          LZeb_encode_matched( \u0026e-\u003eeb, prev_byte, cur_byte, match_byte );\n          }\n        *state = St_set_char( *state );\n        }\n      else\t\t\t\t\t/* match or repeated match */\n        {\n        CRC32_update_buf( \u0026e-\u003eeb.crc, Mb_ptr_to_current_pos( \u0026e-\u003eeb.mb ) - ahead, len );\n        mtf_reps( dis, e-\u003eeb.reps );\n        bit = ( dis \u003c num_rep_distances );\n        Re_encode_bit( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.bm_rep[*state], bit );\n        if( bit )\t\t\t\t/* repeated match */\n          {\n          bit = ( dis == 0 );\n          Re_encode_bit( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.bm_rep0[*state], !bit );\n          if( bit )\n            Re_encode_bit( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.bm_len[*state][pos_state], len \u003e 1 );\n          else\n            {\n            Re_encode_bit( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.bm_rep1[*state], dis \u003e 1 );\n            if( dis \u003e 1 )\n              Re_encode_bit( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.bm_rep2[*state], dis \u003e 2 );\n            }\n          if( len == 1 ) *state = St_set_short_rep( *state );\n          else\n            {\n            Re_encode_len( \u0026e-\u003eeb.renc, \u0026e-\u003eeb.rep_len_model, len, pos_state );\n            Lp_decrement_counter( \u0026e-\u003erep_len_prices, pos_state );\n            *state = St_set_rep( *state );\n            }\n          }\n        else\t\t\t\t\t/* match */\n          {\n          dis -= num_rep_distances;\n          LZeb_encode_pair( \u0026e-\u003eeb, dis, len, pos_state );\n          if( dis \u003e= modeled_distances ) --e-\u003ealign_price_counter;\n          --e-\u003edis_price_counter;\n          Lp_decrement_counter( \u0026e-\u003ematch_len_prices, pos_state );\n          *state = St_set_match( *state );\n          }\n        }\n      ahead -= len; i += len;\n      if( Re_member_position( \u0026e-\u003eeb.renc ) \u003e= e-\u003eeb.member_size_limit )\n        {\n        if( !Mb_dec_pos( \u0026e-\u003eeb.mb, ahead ) ) return false;\n        LZeb_try_full_flush( \u0026e-\u003eeb );\n        return true;\n        }\n      }\n    }\n  LZeb_try_full_flush( \u0026e-\u003eeb );\n  return true;\n  }","filepath":"lzlib-1.11/encoder.c","line_number":483,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3489024":{"score":0.7392125,"function_name":"LZe_get_match_pairs","code":"static int LZe_get_match_pairs( struct LZ_encoder * const e, struct Pair * pairs )\n  {\n  int32_t * ptr0 = e-\u003eeb.mb.pos_array + ( e-\u003eeb.mb.cyclic_pos \u003c\u003c 1 );\n  int32_t * ptr1 = ptr0 + 1;\n  int32_t * newptr;\n  int len = 0, len0 = 0, len1 = 0;\n  int maxlen = 0;\n  int num_pairs = 0;\n  const int pos1 = e-\u003eeb.mb.pos + 1;\n  const int min_pos = ( e-\u003eeb.mb.pos \u003e e-\u003eeb.mb.dictionary_size ) ?\n                        e-\u003eeb.mb.pos - e-\u003eeb.mb.dictionary_size : 0;\n  const uint8_t * const data = Mb_ptr_to_current_pos( \u0026e-\u003eeb.mb );\n  int count, key2, key3, key4, newpos1;\n  unsigned tmp;\n  int len_limit = e-\u003ematch_len_limit;\n\n  if( len_limit \u003e Mb_available_bytes( \u0026e-\u003eeb.mb ) )\n    {\n    e-\u003ebeen_flushed = true;\n    len_limit = Mb_available_bytes( \u0026e-\u003eeb.mb );\n    if( len_limit \u003c 4 ) { *ptr0 = *ptr1 = 0; return 0; }\n    }\n\n  tmp = crc32[data[0]] ^ data[1];\n  key2 = tmp \u0026 ( num_prev_positions2 - 1 );\n  tmp ^= (unsigned)data[2] \u003c\u003c 8;\n  key3 = num_prev_positions2 + ( tmp \u0026 ( num_prev_positions3 - 1 ) );\n  key4 = num_prev_positions2 + num_prev_positions3 +\n         ( ( tmp ^ ( crc32[data[3]] \u003c\u003c 5 ) ) \u0026 e-\u003eeb.mb.key4_mask );\n\n  if( pairs )\n    {\n    int np2 = e-\u003eeb.mb.prev_positions[key2];\n    int np3 = e-\u003eeb.mb.prev_positions[key3];\n    if( np2 \u003e min_pos \u0026\u0026 e-\u003eeb.mb.buffer[np2-1] == data[0] )\n      {\n      pairs[0].dis = e-\u003eeb.mb.pos - np2;\n      pairs[0].len = maxlen = 2;\n      num_pairs = 1;\n      }\n    if( np2 != np3 \u0026\u0026 np3 \u003e min_pos \u0026\u0026 e-\u003eeb.mb.buffer[np3-1] == data[0] )\n      {\n      maxlen = 3;\n      np2 = np3;\n      pairs[num_pairs].dis = e-\u003eeb.mb.pos - np2;\n      ++num_pairs;\n      }\n    if( num_pairs \u003e 0 )\n      {\n      const int delta = pos1 - np2;\n      while( maxlen \u003c len_limit \u0026\u0026 data[maxlen-delta] == data[maxlen] )\n        ++maxlen;\n      pairs[num_pairs-1].len = maxlen;\n      if( maxlen \u003e= len_limit ) pairs = 0;\t/* done. now just skip */\n      }\n    if( maxlen \u003c 3 ) maxlen = 3;\n    }\n\n  e-\u003eeb.mb.prev_positions[key2] = pos1;\n  e-\u003eeb.mb.prev_positions[key3] = pos1;\n  newpos1 = e-\u003eeb.mb.prev_positions[key4];\n  e-\u003eeb.mb.prev_positions[key4] = pos1;\n\n  for( count = e-\u003ecycles; ; )\n    {\n    int delta;\n    if( newpos1 \u003c= min_pos || --count \u003c 0 ) { *ptr0 = *ptr1 = 0; break; }\n\n    if( e-\u003ebeen_flushed ) len = 0;\n    delta = pos1 - newpos1;\n    newptr = e-\u003eeb.mb.pos_array +\n      ( ( e-\u003eeb.mb.cyclic_pos - delta +\n          ( (e-\u003eeb.mb.cyclic_pos \u003e= delta) ? 0 : e-\u003eeb.mb.dictionary_size + 1 ) ) \u003c\u003c 1 );\n    if( data[len-delta] == data[len] )\n      {\n      while( ++len \u003c len_limit \u0026\u0026 data[len-delta] == data[len] ) {}\n      if( pairs \u0026\u0026 maxlen \u003c len )\n        {\n        pairs[num_pairs].dis = delta - 1;\n        pairs[num_pairs].len = maxlen = len;\n        ++num_pairs;\n        }\n      if( len \u003e= len_limit )\n        {\n        *ptr0 = newptr[0];\n        *ptr1 = newptr[1];\n        break;\n        }\n      }\n    if( data[len-delta] \u003c data[len] )\n      {\n      *ptr0 = newpos1;\n      ptr0 = newptr + 1;\n      newpos1 = *ptr0;\n      len0 = len; if( len1 \u003c len ) len = len1;\n      }\n    else\n      {\n      *ptr1 = newpos1;\n      ptr1 = newptr;\n      newpos1 = *ptr1;\n      len1 = len; if( len0 \u003c len ) len = len0;\n      }\n    }\n  return num_pairs;\n  }","filepath":"lzlib-1.11/encoder.c","line_number":20,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3501600":{"score":0.9540101,"function_name":"LZ_strerror","code":"const char * LZ_strerror( const enum LZ_Errno lz_errno )\n  {\n  switch( lz_errno )\n    {\n    case LZ_ok            : return \"ok\";\n    case LZ_bad_argument  : return \"Bad argument\";\n    case LZ_mem_error     : return \"Not enough memory\";\n    case LZ_sequence_error: return \"Sequence error\";\n    case LZ_header_error  : return \"Header error\";\n    case LZ_unexpected_eof: return \"Unexpected EOF\";\n    case LZ_data_error    : return \"Data error\";\n    case LZ_library_error : return \"Library error\";\n    }\n  return \"Invalid error code\";\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":113,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3501856":{"score":0.66081166,"function_name":"LZ_compress_open","code":"struct LZ_Encoder * LZ_compress_open( const int dictionary_size,\n                                      const int match_len_limit,\n                                      const unsigned long long member_size )\n  {\n  Lzip_header header;\n  struct LZ_Encoder * const e =\n    (struct LZ_Encoder *)malloc( sizeof (struct LZ_Encoder) );\n  if( !e ) return 0;\n  LZ_Encoder_init( e );\n  if( !Lh_set_dictionary_size( header, dictionary_size ) ||\n      match_len_limit \u003c min_match_len_limit ||\n      match_len_limit \u003e max_match_len ||\n      member_size \u003c min_dictionary_size )\n    e-\u003elz_errno = LZ_bad_argument;\n  else\n    {\n    if( dictionary_size == 65535 \u0026\u0026 match_len_limit == 16 )\n      {\n      e-\u003eflz_encoder = (struct FLZ_encoder *)malloc( sizeof (struct FLZ_encoder) );\n      if( e-\u003eflz_encoder \u0026\u0026 FLZe_init( e-\u003eflz_encoder, member_size ) )\n        { e-\u003elz_encoder_base = \u0026e-\u003eflz_encoder-\u003eeb; return e; }\n      free( e-\u003eflz_encoder ); e-\u003eflz_encoder = 0;\n      }\n    else\n      {\n      e-\u003elz_encoder = (struct LZ_encoder *)malloc( sizeof (struct LZ_encoder) );\n      if( e-\u003elz_encoder \u0026\u0026 LZe_init( e-\u003elz_encoder, Lh_get_dictionary_size( header ),\n                                     match_len_limit, member_size ) )\n        { e-\u003elz_encoder_base = \u0026e-\u003elz_encoder-\u003eeb; return e; }\n      free( e-\u003elz_encoder ); e-\u003elz_encoder = 0;\n      }\n    e-\u003elz_errno = LZ_mem_error;\n    }\n  e-\u003efatal = true;\n  return e;\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":140,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3504064":{"score":0.783247,"function_name":"LZ_compress_close","code":"int LZ_compress_close( struct LZ_Encoder * const e )\n  {\n  if( !e ) return -1;\n  if( e-\u003elz_encoder_base )\n    { LZeb_free( e-\u003elz_encoder_base );\n      free( e-\u003elz_encoder ); free( e-\u003eflz_encoder ); }\n  free( e );\n  return 0;\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":178,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3504768":{"score":0.6364341,"function_name":"LZ_compress_restart_member","code":"int LZ_compress_restart_member( struct LZ_Encoder * const e,\n                                const unsigned long long member_size )\n  {\n  if( !verify_encoder( e ) || e-\u003efatal ) return -1;\n  if( !LZeb_member_finished( e-\u003elz_encoder_base ) )\n    { e-\u003elz_errno = LZ_sequence_error; return -1; }\n  if( member_size \u003c min_dictionary_size )\n    { e-\u003elz_errno = LZ_bad_argument; return -1; }\n\n  e-\u003epartial_in_size += Mb_data_position( \u0026e-\u003elz_encoder_base-\u003emb );\n  e-\u003epartial_out_size += Re_member_position( \u0026e-\u003elz_encoder_base-\u003erenc );\n\n  if( e-\u003elz_encoder ) LZe_reset( e-\u003elz_encoder, member_size );\n  else FLZe_reset( e-\u003eflz_encoder, member_size );\n  e-\u003elz_errno = LZ_ok;\n  return 0;\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":207,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3505216":{"score":0.6723676,"function_name":"LZ_compress_read","code":"int LZ_compress_read( struct LZ_Encoder * const e,\n                      uint8_t * const buffer, const int size )\n  {\n  int out_size = 0;\n  if( !verify_encoder( e ) || e-\u003efatal ) return -1;\n  if( size \u003c 0 ) return 0;\n  do {\n    if( ( e-\u003eflz_encoder \u0026\u0026 !FLZe_encode_member( e-\u003eflz_encoder ) ) ||\n        ( e-\u003elz_encoder \u0026\u0026 !LZe_encode_member( e-\u003elz_encoder ) ) )\n      { e-\u003elz_errno = LZ_library_error; e-\u003efatal = true; return -1; }\n    if( e-\u003elz_encoder_base-\u003emb.flushing \u0026\u0026\n        Mb_available_bytes( \u0026e-\u003elz_encoder_base-\u003emb ) \u003c= 0 \u0026\u0026\n        LZeb_sync_flush( e-\u003elz_encoder_base ) )\n      e-\u003elz_encoder_base-\u003emb.flushing = false;\n    out_size += Re_read_data( \u0026e-\u003elz_encoder_base-\u003erenc,\n                              buffer + out_size, size - out_size );\n    }\n  while( e-\u003elz_encoder_base-\u003emb.flushing \u0026\u0026 out_size \u003c size \u0026\u0026\n         Mb_enough_available_bytes( \u0026e-\u003elz_encoder_base-\u003emb ) \u0026\u0026\n         Re_enough_free_bytes( \u0026e-\u003elz_encoder_base-\u003erenc ) );\n  return out_size;\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":235,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3510240":{"score":0.57609105,"function_name":"LZ_compress_read","code":"int LZ_compress_read( struct LZ_Encoder * const e,\n                      uint8_t * const buffer, const int size )\n  {\n  int out_size = 0;\n  if( !verify_encoder( e ) || e-\u003efatal ) return -1;\n  if( size \u003c 0 ) return 0;\n  do {\n    if( ( e-\u003eflz_encoder \u0026\u0026 !FLZe_encode_member( e-\u003eflz_encoder ) ) ||\n        ( e-\u003elz_encoder \u0026\u0026 !LZe_encode_member( e-\u003elz_encoder ) ) )\n      { e-\u003elz_errno = LZ_library_error; e-\u003efatal = true; return -1; }\n    if( e-\u003elz_encoder_base-\u003emb.flushing \u0026\u0026\n        Mb_available_bytes( \u0026e-\u003elz_encoder_base-\u003emb ) \u003c= 0 \u0026\u0026\n        LZeb_sync_flush( e-\u003elz_encoder_base ) )\n      e-\u003elz_encoder_base-\u003emb.flushing = false;\n    out_size += Re_read_data( \u0026e-\u003elz_encoder_base-\u003erenc,\n                              buffer + out_size, size - out_size );\n    }\n  while( e-\u003elz_encoder_base-\u003emb.flushing \u0026\u0026 out_size \u003c size \u0026\u0026\n         Mb_enough_available_bytes( \u0026e-\u003elz_encoder_base-\u003emb ) \u0026\u0026\n         Re_enough_free_bytes( \u0026e-\u003elz_encoder_base-\u003erenc ) );\n  return out_size;\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":235,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3511440":{"score":0.7930089,"function_name":"LZ_decompress_close","code":"int LZ_decompress_close( struct LZ_Decoder * const d )\n  {\n  if( !d ) return -1;\n  if( d-\u003elz_decoder )\n    { LZd_free( d-\u003elz_decoder ); free( d-\u003elz_decoder ); }\n  if( d-\u003erdec ) { Rd_free( d-\u003erdec ); free( d-\u003erdec ); }\n  free( d );\n  return 0;\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":343,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3511856":{"score":0.5990024,"function_name":"LZ_decompress_sync_to_member","code":"int LZ_decompress_sync_to_member( struct LZ_Decoder * const d )\n  {\n  unsigned skipped = 0;\n  if( !verify_decoder( d ) ) return -1;\n  if( d-\u003elz_decoder )\n    { LZd_free( d-\u003elz_decoder ); free( d-\u003elz_decoder ); d-\u003elz_decoder = 0; }\n  if( Rd_find_header( d-\u003erdec, \u0026skipped ) ) d-\u003eseeking = false;\n  else\n    {\n    if( !d-\u003erdec-\u003eat_stream_end ) d-\u003eseeking = true;\n    else { d-\u003eseeking = false; d-\u003epartial_in_size += Rd_purge( d-\u003erdec ); }\n    }\n  d-\u003epartial_in_size += skipped;\n  d-\u003elz_errno = LZ_ok;\n  d-\u003efatal = false;\n  return 0;\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":380,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3512496":{"score":0.7442713,"function_name":"LZ_decompress_read","code":"int LZ_decompress_read( struct LZ_Decoder * const d,\n                        uint8_t * const buffer, const int size )\n  {\n  int result;\n  if( !verify_decoder( d ) ) return -1;\n  if( d-\u003efatal )\t/* don't return error until pending bytes are read */\n    { if( d-\u003elz_decoder \u0026\u0026 !Cb_empty( \u0026d-\u003elz_decoder-\u003ecb ) ) goto get_data;\n      return -1; }\n  if( d-\u003eseeking || size \u003c 0 ) return 0;\n\n  if( d-\u003elz_decoder \u0026\u0026 LZd_member_finished( d-\u003elz_decoder ) )\n    {\n    d-\u003epartial_out_size += LZd_data_position( d-\u003elz_decoder );\n    LZd_free( d-\u003elz_decoder ); free( d-\u003elz_decoder ); d-\u003elz_decoder = 0;\n    }\n  if( !d-\u003elz_decoder )\n    {\n    int rd;\n    d-\u003epartial_in_size += d-\u003erdec-\u003emember_position;\n    d-\u003erdec-\u003emember_position = 0;\n    if( Rd_available_bytes( d-\u003erdec ) \u003c Lh_size + 5 \u0026\u0026\n        !d-\u003erdec-\u003eat_stream_end ) return 0;\n    if( Rd_finished( d-\u003erdec ) \u0026\u0026 !d-\u003efirst_header ) return 0;\n    rd = Rd_read_data( d-\u003erdec, d-\u003emember_header, Lh_size );\n    if( rd \u003c Lh_size || Rd_finished( d-\u003erdec ) )\t/* End Of File */\n      {\n      if( rd \u003c= 0 || Lh_verify_prefix( d-\u003emember_header, rd ) )\n        d-\u003elz_errno = LZ_unexpected_eof;\n      else\n        d-\u003elz_errno = LZ_header_error;\n      d-\u003efatal = true;\n      return -1;\n      }\n    if( !Lh_verify_magic( d-\u003emember_header ) )\n      {\n      /* unreading the header prevents sync_to_member from skipping a member\n         if leading garbage is shorter than a full header; \"lgLZIP\\x01\\x0C\" */\n      if( Rd_unread_data( d-\u003erdec, rd ) )\n        {\n        if( d-\u003efirst_header || !Lh_verify_corrupt( d-\u003emember_header ) )\n          d-\u003elz_errno = LZ_header_error;\n        else\n          d-\u003elz_errno = LZ_data_error;\t\t/* corrupt header */\n        }\n      else\n        d-\u003elz_errno = LZ_library_error;\n      d-\u003efatal = true;\n      return -1;\n      }\n    if( !Lh_verify_version( d-\u003emember_header ) ||\n        !isvalid_ds( Lh_get_dictionary_size( d-\u003emember_header ) ) )\n      {\n      /* Skip a possible \"LZIP\" leading garbage; \"LZIPLZIP\\x01\\x0C\".\n         Leave member_pos pointing to the first error. */\n      if( Rd_unread_data( d-\u003erdec, 1 + !Lh_verify_version( d-\u003emember_header ) ) )\n        d-\u003elz_errno = LZ_data_error;\t/* bad version or bad dict size */\n      else\n        d-\u003elz_errno = LZ_library_error;\n      d-\u003efatal = true;\n      return -1;\n      }\n    d-\u003efirst_header = false;\n    if( Rd_available_bytes( d-\u003erdec ) \u003c 5 )\n      {\n      /* set position at EOF */\n      d-\u003erdec-\u003emember_position += Cb_used_bytes( \u0026d-\u003erdec-\u003ecb );\n      Cb_reset( \u0026d-\u003erdec-\u003ecb );\n      d-\u003elz_errno = LZ_unexpected_eof;\n      d-\u003efatal = true;\n      return -1;\n      }\n    d-\u003elz_decoder = (struct LZ_decoder *)malloc( sizeof (struct LZ_decoder) );\n    if( !d-\u003elz_decoder || !LZd_init( d-\u003elz_decoder, d-\u003erdec,\n                             Lh_get_dictionary_size( d-\u003emember_header ) ) )\n      {\t\t\t\t\t/* not enough free memory */\n      if( d-\u003elz_decoder )\n        { LZd_free( d-\u003elz_decoder ); free( d-\u003elz_decoder ); d-\u003elz_decoder = 0; }\n      d-\u003elz_errno = LZ_mem_error;\n      d-\u003efatal = true;\n      return -1;\n      }\n    d-\u003erdec-\u003ereload_pending = true;\n    }\n  result = LZd_decode_member( d-\u003elz_decoder );\n  if( result != 0 )\n    {\n    if( result == 2 )\t\t\t/* set input position at EOF */\n      { d-\u003erdec-\u003emember_position += Cb_used_bytes( \u0026d-\u003erdec-\u003ecb );\n        Cb_reset( \u0026d-\u003erdec-\u003ecb );\n        d-\u003elz_errno = LZ_unexpected_eof; }\n    else if( result == 5 ) d-\u003elz_errno = LZ_library_error;\n    else d-\u003elz_errno = LZ_data_error;\n    d-\u003efatal = true;\n    if( Cb_empty( \u0026d-\u003elz_decoder-\u003ecb ) ) return -1;\n    }\nget_data:\n  return Cb_read_data( \u0026d-\u003elz_decoder-\u003ecb, buffer, size );\n  }","filepath":"lzlib-1.11/lzlib.c","line_number":399,"entry_url":"https://github.com/haskell-hvr/lzlib.git","slot_name":"v0.0.0.0"},"3697520":{"score":0.5607585,"function_name":"ss_compare","code":"static INLINE\nint\nss_compare(const unsigned char *T,\n           const int *p1, const int *p2,\n           int depth) {\n  const unsigned char *U1, *U2, *U1n, *U2n;\n\n  for(U1 = T + depth + *p1,\n      U2 = T + depth + *p2,\n      U1n = T + *(p1 + 1) + 2,\n      U2n = T + *(p2 + 1) + 2;\n      (U1 \u003c U1n) \u0026\u0026 (U2 \u003c U2n) \u0026\u0026 (*U1 == *U2);\n      ++U1, ++U2) {\n  }\n\n  return U1 \u003c U1n ?\n        (U2 \u003c U2n ? *U1 - *U2 : 1) :\n        (U2 \u003c U2n ? -1 : 0);\n}","filepath":"lib/divsufsort.c","line_number":229,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.5.1"},"3733568":{"score":0.64008874,"function_name":"divsufsort","code":"int\ndivsufsort(const unsigned char *T, int *SA, int n, int openMP) {\n  int *bucket_A, *bucket_B;\n  int m;\n  int err = 0;\n\n  /* Check arguments. */\n  if((T == NULL) || (SA == NULL) || (n \u003c 0)) { return -1; }\n  else if(n == 0) { return 0; }\n  else if(n == 1) { SA[0] = 0; return 0; }\n  else if(n == 2) { m = (T[0] \u003c T[1]); SA[m ^ 1] = 0, SA[m] = 1; return 0; }\n\n  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));\n  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));\n\n  /* Suffixsort. */\n  if((bucket_A != NULL) \u0026\u0026 (bucket_B != NULL)) {\n    m = sort_typeBstar(T, SA, bucket_A, bucket_B, n, openMP);\n    construct_SA(T, SA, bucket_A, bucket_B, n, m);\n  } else {\n    err = -2;\n  }\n\n  free(bucket_B);\n  free(bucket_A);\n\n  return err;\n}","filepath":"lib/divsufsort.c","line_number":1846,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.5.1"},"3735680":{"score":0.8308892,"function_name":"ss_mintrosort","code":"static\nvoid\nss_mintrosort(const unsigned char *T, const int *PA,\n              int *first, int *last,\n              int depth) {\n#define STACK_SIZE SS_MISORT_STACKSIZE\n  struct { int *a, *b, c; int d; } stack[STACK_SIZE];\n  const unsigned char *Td;\n  int *a, *b, *c, *d, *e, *f;\n  int s, t;\n  int ssize;\n  int limit;\n  int v, x = 0;\n\n  for(ssize = 0, limit = ss_ilg(last - first);;) {\n\n    if((last - first) \u003c= SS_INSERTIONSORT_THRESHOLD) {\n#if 1 \u003c SS_INSERTIONSORT_THRESHOLD\n      if(1 \u003c (last - first)) { ss_insertionsort(T, PA, first, last, depth); }\n#endif\n      STACK_POP(first, last, depth, limit);\n      continue;\n    }\n\n    Td = T + depth;\n    if(limit-- == 0) { ss_heapsort(Td, PA, first, last - first); }\n    if(limit \u003c 0) {\n      for(a = first + 1, v = Td[PA[*first]]; a \u003c last; ++a) {\n        if((x = Td[PA[*a]]) != v) {\n          if(1 \u003c (a - first)) { break; }\n          v = x;\n          first = a;\n        }\n      }\n      if(Td[PA[*first] - 1] \u003c v) {\n        first = ss_partition(PA, first, a, depth);\n      }\n      if((a - first) \u003c= (last - a)) {\n        if(1 \u003c (a - first)) {\n          STACK_PUSH(a, last, depth, -1);\n          last = a, depth += 1, limit = ss_ilg(a - first);\n        } else {\n          first = a, limit = -1;\n        }\n      } else {\n        if(1 \u003c (last - a)) {\n          STACK_PUSH(first, a, depth + 1, ss_ilg(a - first));\n          first = a, limit = -1;\n        } else {\n          last = a, depth += 1, limit = ss_ilg(a - first);\n        }\n      }\n      continue;\n    }\n\n    /* choose pivot */\n    a = ss_pivot(Td, PA, first, last);\n    v = Td[PA[*a]];\n    SWAP(*first, *a);\n\n    /* partition */\n    for(b = first; (++b \u003c last) \u0026\u0026 ((x = Td[PA[*b]]) == v);) { }\n    if(((a = b) \u003c last) \u0026\u0026 (x \u003c v)) {\n      for(; (++b \u003c last) \u0026\u0026 ((x = Td[PA[*b]]) \u003c= v);) {\n        if(x == v) { SWAP(*b, *a); ++a; }\n      }\n    }\n    for(c = last; (b \u003c --c) \u0026\u0026 ((x = Td[PA[*c]]) == v);) { }\n    if((b \u003c (d = c)) \u0026\u0026 (x \u003e v)) {\n      for(; (b \u003c --c) \u0026\u0026 ((x = Td[PA[*c]]) \u003e= v);) {\n        if(x == v) { SWAP(*c, *d); --d; }\n      }\n    }\n    for(; b \u003c c;) {\n      SWAP(*b, *c);\n      for(; (++b \u003c c) \u0026\u0026 ((x = Td[PA[*b]]) \u003c= v);) {\n        if(x == v) { SWAP(*b, *a); ++a; }\n      }\n      for(; (b \u003c --c) \u0026\u0026 ((x = Td[PA[*c]]) \u003e= v);) {\n        if(x == v) { SWAP(*c, *d); --d; }\n      }\n    }\n\n    if(a \u003c= d) {\n      c = b - 1;\n\n      if((s = a - first) \u003e (t = b - a)) { s = t; }\n      for(e = first, f = b - s; 0 \u003c s; --s, ++e, ++f) { SWAP(*e, *f); }\n      if((s = d - c) \u003e (t = last - d - 1)) { s = t; }\n      for(e = b, f = last - s; 0 \u003c s; --s, ++e, ++f) { SWAP(*e, *f); }\n\n      a = first + (b - a), c = last - (d - c);\n      b = (v \u003c= Td[PA[*a] - 1]) ? a : ss_partition(PA, a, c, depth);\n\n      if((a - first) \u003c= (last - c)) {\n        if((last - c) \u003c= (c - b)) {\n          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));\n          STACK_PUSH(c, last, depth, limit);\n          last = a;\n        } else if((a - first) \u003c= (c - b)) {\n          STACK_PUSH(c, last, depth, limit);\n          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));\n          last = a;\n        } else {\n          STACK_PUSH(c, last, depth, limit);\n          STACK_PUSH(first, a, depth, limit);\n          first = b, last = c, depth += 1, limit = ss_ilg(c - b);\n        }\n      } else {\n        if((a - first) \u003c= (c - b)) {\n          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));\n          STACK_PUSH(first, a, depth, limit);\n          first = c;\n        } else if((last - c) \u003c= (c - b)) {\n          STACK_PUSH(first, a, depth, limit);\n          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));\n          first = c;\n        } else {\n          STACK_PUSH(first, a, depth, limit);\n          STACK_PUSH(c, last, depth, limit);\n          first = b, last = c, depth += 1, limit = ss_ilg(c - b);\n        }\n      }\n    } else {\n      limit += 1;\n      if(Td[PA[*first] - 1] \u003c v) {\n        first = ss_partition(PA, first, last, depth);\n        limit = ss_ilg(last - first);\n      }\n      depth += 1;\n    }\n  }\n#undef STACK_SIZE\n}","filepath":"lib/divsufsort.c","line_number":398,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.5.1"},"3741408":{"score":0.8786847,"function_name":"ss_swapmerge","code":"static\nvoid\nss_swapmerge(const unsigned char *T, const int *PA,\n             int *first, int *middle, int *last,\n             int *buf, int bufsize, int depth) {\n#define STACK_SIZE SS_SMERGE_STACKSIZE\n#define GETIDX(a) ((0 \u003c= (a)) ? (a) : (~(a)))\n#define MERGE_CHECK(a, b, c)\\\n  do {\\\n    if(((c) \u0026 1) ||\\\n       (((c) \u0026 2) \u0026\u0026 (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\\\n      *(a) = ~*(a);\\\n    }\\\n    if(((c) \u0026 4) \u0026\u0026 ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\\\n      *(b) = ~*(b);\\\n    }\\\n  } while(0)\n  struct { int *a, *b, *c; int d; } stack[STACK_SIZE];\n  int *l, *r, *lm, *rm;\n  int m, len, half;\n  int ssize;\n  int check, next;\n\n  for(check = 0, ssize = 0;;) {\n    if((last - middle) \u003c= bufsize) {\n      if((first \u003c middle) \u0026\u0026 (middle \u003c last)) {\n        ss_mergebackward(T, PA, first, middle, last, buf, depth);\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n      continue;\n    }\n\n    if((middle - first) \u003c= bufsize) {\n      if(first \u003c middle) {\n        ss_mergeforward(T, PA, first, middle, last, buf, depth);\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n      continue;\n    }\n\n    for(m = 0, len = MIN(middle - first, last - middle), half = len \u003e\u003e 1;\n        0 \u003c len;\n        len = half, half \u003e\u003e= 1) {\n      if(ss_compare(T, PA + GETIDX(*(middle + m + half)),\n                       PA + GETIDX(*(middle - m - half - 1)), depth) \u003c 0) {\n        m += half + 1;\n        half -= (len \u0026 1) ^ 1;\n      }\n    }\n\n    if(0 \u003c m) {\n      lm = middle - m, rm = middle + m;\n      ss_blockswap(lm, middle, m);\n      l = r = middle, next = 0;\n      if(rm \u003c last) {\n        if(*rm \u003c 0) {\n          *rm = ~*rm;\n          if(first \u003c lm) { for(; *--l \u003c 0;) { } next |= 4; }\n          next |= 1;\n        } else if(first \u003c lm) {\n          for(; *r \u003c 0; ++r) { }\n          next |= 2;\n        }\n      }\n\n      if((l - first) \u003c= (last - r)) {\n        STACK_PUSH(r, rm, last, (next \u0026 3) | (check \u0026 4));\n        middle = lm, last = l, check = (check \u0026 3) | (next \u0026 4);\n      } else {\n        if((next \u0026 2) \u0026\u0026 (r == middle)) { next ^= 6; }\n        STACK_PUSH(first, lm, l, (check \u0026 3) | (next \u0026 4));\n        first = r, middle = rm, check = (next \u0026 3) | (check \u0026 4);\n      }\n    } else {\n      if(ss_compare(T, PA + GETIDX(*(middle - 1)), PA + *middle, depth) == 0) {\n        *middle = ~*middle;\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n    }\n  }\n#undef STACK_SIZE\n}","filepath":"lib/divsufsort.c","line_number":742,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.5.1"},"3745984":{"score":0.7522816,"function_name":"sssort","code":"static\nvoid\nsssort(const unsigned char *T, const int *PA,\n       int *first, int *last,\n       int *buf, int bufsize,\n       int depth, int n, int lastsuffix) {\n  int *a;\n#if SS_BLOCKSIZE != 0\n  int *b, *middle, *curbuf;\n  int j, k, curbufsize, limit;\n#endif\n  int i;\n\n  if(lastsuffix != 0) { ++first; }\n\n#if SS_BLOCKSIZE == 0\n  ss_mintrosort(T, PA, first, last, depth);\n#else\n  if((bufsize \u003c SS_BLOCKSIZE) \u0026\u0026\n      (bufsize \u003c (last - first)) \u0026\u0026\n      (bufsize \u003c (limit = ss_isqrt(last - first)))) {\n    if(SS_BLOCKSIZE \u003c limit) { limit = SS_BLOCKSIZE; }\n    buf = middle = last - limit, bufsize = limit;\n  } else {\n    middle = last, limit = 0;\n  }\n  for(a = first, i = 0; SS_BLOCKSIZE \u003c (middle - a); a += SS_BLOCKSIZE, ++i) {\n#if SS_INSERTIONSORT_THRESHOLD \u003c SS_BLOCKSIZE\n    ss_mintrosort(T, PA, a, a + SS_BLOCKSIZE, depth);\n#elif 1 \u003c SS_BLOCKSIZE\n    ss_insertionsort(T, PA, a, a + SS_BLOCKSIZE, depth);\n#endif\n    curbufsize = last - (a + SS_BLOCKSIZE);\n    curbuf = a + SS_BLOCKSIZE;\n    if(curbufsize \u003c= bufsize) { curbufsize = bufsize, curbuf = buf; }\n    for(b = a, k = SS_BLOCKSIZE, j = i; j \u0026 1; b -= k, k \u003c\u003c= 1, j \u003e\u003e= 1) {\n      ss_swapmerge(T, PA, b - k, b, b + k, curbuf, curbufsize, depth);\n    }\n  }\n#if SS_INSERTIONSORT_THRESHOLD \u003c SS_BLOCKSIZE\n  ss_mintrosort(T, PA, a, middle, depth);\n#elif 1 \u003c SS_BLOCKSIZE\n  ss_insertionsort(T, PA, a, middle, depth);\n#endif\n  for(k = SS_BLOCKSIZE; i != 0; k \u003c\u003c= 1, i \u003e\u003e= 1) {\n    if(i \u0026 1) {\n      ss_swapmerge(T, PA, a - k, a, middle, buf, bufsize, depth);\n      a -= k;\n    }\n  }\n  if(limit != 0) {\n#if SS_INSERTIONSORT_THRESHOLD \u003c SS_BLOCKSIZE\n    ss_mintrosort(T, PA, middle, last, depth);\n#elif 1 \u003c SS_BLOCKSIZE\n    ss_insertionsort(T, PA, middle, last, depth);\n#endif\n    ss_inplacemerge(T, PA, first, middle, last, depth);\n  }\n#endif\n\n  if(lastsuffix != 0) {\n    /* Insert last type B* suffix. */\n    int PAi[2]; PAi[0] = PA[*(first - 1)], PAi[1] = n - 2;\n    for(a = first, i = *(first - 1);\n        (a \u003c last) \u0026\u0026 ((*a \u003c 0) || (0 \u003c ss_compare(T, \u0026(PAi[0]), PA + *a, depth)));\n        ++a) {\n      *(a - 1) = *a;\n    }\n    *(a - 1) = i;\n  }\n}","filepath":"lib/divsufsort.c","line_number":834,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.5.1"},"3748352":{"score":0.8123496,"function_name":"tr_introsort","code":"static\nvoid\ntr_introsort(int *ISA, const int *ISAd,\n             int *SA, int *first, int *last,\n             trbudget_t *budget) {\n#define STACK_SIZE TR_STACKSIZE\n  struct { const int *a; int *b, *c; int d, e; }stack[STACK_SIZE];\n  int *a, *b, *c;\n  int t;\n  int v, x = 0;\n  int incr = ISAd - ISA;\n  int limit, next;\n  int ssize, trlink = -1;\n\n  for(ssize = 0, limit = tr_ilg(last - first);;) {\n\n    if(limit \u003c 0) {\n      if(limit == -1) {\n        /* tandem repeat partition */\n        tr_partition(ISAd - incr, first, first, last, \u0026a, \u0026b, last - SA - 1);\n\n        /* update ranks */\n        if(a \u003c last) {\n          for(c = first, v = a - SA - 1; c \u003c a; ++c) { ISA[*c] = v; }\n        }\n        if(b \u003c last) {\n          for(c = a, v = b - SA - 1; c \u003c b; ++c) { ISA[*c] = v; }\n        }\n\n        /* push */\n        if(1 \u003c (b - a)) {\n          STACK_PUSH5(NULL, a, b, 0, 0);\n          STACK_PUSH5(ISAd - incr, first, last, -2, trlink);\n          trlink = ssize - 2;\n        }\n        if((a - first) \u003c= (last - b)) {\n          if(1 \u003c (a - first)) {\n            STACK_PUSH5(ISAd, b, last, tr_ilg(last - b), trlink);\n            last = a, limit = tr_ilg(a - first);\n          } else if(1 \u003c (last - b)) {\n            first = b, limit = tr_ilg(last - b);\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        } else {\n          if(1 \u003c (last - b)) {\n            STACK_PUSH5(ISAd, first, a, tr_ilg(a - first), trlink);\n            first = b, limit = tr_ilg(last - b);\n          } else if(1 \u003c (a - first)) {\n            last = a, limit = tr_ilg(a - first);\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        }\n      } else if(limit == -2) {\n        /* tandem repeat copy */\n        a = stack[--ssize].b, b = stack[ssize].c;\n        if(stack[ssize].d == 0) {\n          tr_copy(ISA, SA, first, a, b, last, ISAd - ISA);\n        } else {\n          if(0 \u003c= trlink) { stack[trlink].d = -1; }\n          tr_partialcopy(ISA, SA, first, a, b, last, ISAd - ISA);\n        }\n        STACK_POP5(ISAd, first, last, limit, trlink);\n      } else {\n        /* sorted partition */\n        if(0 \u003c= *first) {\n          a = first;\n          do { ISA[*a] = a - SA; } while((++a \u003c last) \u0026\u0026 (0 \u003c= *a));\n          first = a;\n        }\n        if(first \u003c last) {\n          a = first; do { *a = ~*a; } while(*++a \u003c 0);\n          next = (ISA[*a] != ISAd[*a]) ? tr_ilg(a - first + 1) : -1;\n          if(++a \u003c last) { for(b = first, v = a - SA - 1; b \u003c a; ++b) { ISA[*b] = v; } }\n\n          /* push */\n          if(trbudget_check(budget, a - first)) {\n            if((a - first) \u003c= (last - a)) {\n              STACK_PUSH5(ISAd, a, last, -3, trlink);\n              ISAd += incr, last = a, limit = next;\n            } else {\n              if(1 \u003c (last - a)) {\n                STACK_PUSH5(ISAd + incr, first, a, next, trlink);\n                first = a, limit = -3;\n              } else {\n                ISAd += incr, last = a, limit = next;\n              }\n            }\n          } else {\n            if(0 \u003c= trlink) { stack[trlink].d = -1; }\n            if(1 \u003c (last - a)) {\n              first = a, limit = -3;\n            } else {\n              STACK_POP5(ISAd, first, last, limit, trlink);\n            }\n          }\n        } else {\n          STACK_POP5(ISAd, first, last, limit, trlink);\n        }\n      }\n      continue;\n    }\n\n    if((last - first) \u003c= TR_INSERTIONSORT_THRESHOLD) {\n      tr_insertionsort(ISAd, first, last);\n      limit = -3;\n      continue;\n    }\n\n    if(limit-- == 0) {\n      tr_heapsort(ISAd, first, last - first);\n      for(a = last - 1; first \u003c a; a = b) {\n        for(x = ISAd[*a], b = a - 1; (first \u003c= b) \u0026\u0026 (ISAd[*b] == x); --b) { *b = ~*b; }\n      }\n      limit = -3;\n      continue;\n    }\n\n    /* choose pivot */\n    a = tr_pivot(ISAd, first, last);\n    SWAP(*first, *a);\n    v = ISAd[*first];\n\n    /* partition */\n    tr_partition(ISAd, first, first + 1, last, \u0026a, \u0026b, v);\n    if((last - first) != (b - a)) {\n      next = (ISA[*a] != v) ? tr_ilg(b - a) : -1;\n\n      /* update ranks */\n      for(c = first, v = a - SA - 1; c \u003c a; ++c) { ISA[*c] = v; }\n      if(b \u003c last) { for(c = a, v = b - SA - 1; c \u003c b; ++c) { ISA[*c] = v; } }\n\n      /* push */\n      if((1 \u003c (b - a)) \u0026\u0026 (trbudget_check(budget, b - a))) {\n        if((a - first) \u003c= (last - b)) {\n          if((last - b) \u003c= (b - a)) {\n            if(1 \u003c (a - first)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              STACK_PUSH5(ISAd, b, last, limit, trlink);\n              last = a;\n            } else if(1 \u003c (last - b)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              first = b;\n            } else {\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else if((a - first) \u003c= (b - a)) {\n            if(1 \u003c (a - first)) {\n              STACK_PUSH5(ISAd, b, last, limit, trlink);\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              last = a;\n            } else {\n              STACK_PUSH5(ISAd, b, last, limit, trlink);\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else {\n            STACK_PUSH5(ISAd, b, last, limit, trlink);\n            STACK_PUSH5(ISAd, first, a, limit, trlink);\n            ISAd += incr, first = a, last = b, limit = next;\n          }\n        } else {\n          if((a - first) \u003c= (b - a)) {\n            if(1 \u003c (last - b)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              STACK_PUSH5(ISAd, first, a, limit, trlink);\n              first = b;\n            } else if(1 \u003c (a - first)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              last = a;\n            } else {\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else if((last - b) \u003c= (b - a)) {\n            if(1 \u003c (last - b)) {\n              STACK_PUSH5(ISAd, first, a, limit, trlink);\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              first = b;\n            } else {\n              STACK_PUSH5(ISAd, first, a, limit, trlink);\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else {\n            STACK_PUSH5(ISAd, first, a, limit, trlink);\n            STACK_PUSH5(ISAd, b, last, limit, trlink);\n            ISAd += incr, first = a, last = b, limit = next;\n          }\n        }\n      } else {\n        if((1 \u003c (b - a)) \u0026\u0026 (0 \u003c= trlink)) { stack[trlink].d = -1; }\n        if((a - first) \u003c= (last - b)) {\n          if(1 \u003c (a - first)) {\n            STACK_PUSH5(ISAd, b, last, limit, trlink);\n            last = a;\n          } else if(1 \u003c (last - b)) {\n            first = b;\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        } else {\n          if(1 \u003c (last - b)) {\n            STACK_PUSH5(ISAd, first, a, limit, trlink);\n            first = b;\n          } else if(1 \u003c (a - first)) {\n            last = a;\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        }\n      }\n    } else {\n      if(trbudget_check(budget, last - first)) {\n        limit = tr_ilg(last - first), ISAd += incr;\n      } else {\n        if(0 \u003c= trlink) { stack[trlink].d = -1; }\n        STACK_POP5(ISAd, first, last, limit, trlink);\n      }\n    }\n  }\n#undef STACK_SIZE\n}","filepath":"lib/divsufsort.c","line_number":1173,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.5.1"},"3757392":{"score":0.78546774,"function_name":"trsort","code":"static\nvoid\ntrsort(int *ISA, int *SA, int n, int depth) {\n  int *ISAd;\n  int *first, *last;\n  trbudget_t budget;\n  int t, skip, unsorted;\n\n  trbudget_init(\u0026budget, tr_ilg(n) * 2 / 3, n);\n/*  trbudget_init(\u0026budget, tr_ilg(n) * 3 / 4, n); */\n  for(ISAd = ISA + depth; -n \u003c *SA; ISAd += ISAd - ISA) {\n    first = SA;\n    skip = 0;\n    unsorted = 0;\n    do {\n      if((t = *first) \u003c 0) { first -= t; skip += t; }\n      else {\n        if(skip != 0) { *(first + skip) = skip; skip = 0; }\n        last = SA + ISA[t] + 1;\n        if(1 \u003c (last - first)) {\n          budget.count = 0;\n          tr_introsort(ISA, ISAd, SA, first, last, \u0026budget);\n          if(budget.count != 0) { unsorted += budget.count; }\n          else { skip = first - last; }\n        } else if((last - first) == 1) {\n          skip = -1;\n        }\n        first = last;\n      }\n    } while(first \u003c (SA + n));\n    if(skip != 0) { *(first + skip) = skip; }\n    if(unsorted == 0) { break; }\n  }\n}","filepath":"lib/divsufsort.c","line_number":1400,"entry_url":"https://github.com/facebook/zstd.git","slot_name":"v0.5.1"},"4118080":{"score":0.5634807,"function_name":"ss_partition","code":"static INLINE\nsaidx_t *\nss_partition(const saidx_t *PA,\n                    saidx_t *first, saidx_t *last, saidx_t depth) {\n  saidx_t *a, *b;\n  saidx_t t;\n  for(a = first - 1, b = last;;) {\n    for(; (++a \u003c b) \u0026\u0026 ((PA[*a] + depth) \u003e= (PA[*a + 1] + 1));) { *a = ~*a; }\n    for(; (a \u003c --b) \u0026\u0026 ((PA[*b] + depth) \u003c  (PA[*b + 1] + 1));) { }\n    if(b \u003c= a) { break; }\n    t = ~*b;\n    *b = *a;\n    *a = t;\n  }\n  if(first \u003c a) { *first = ~*first; }\n  return a;\n}","filepath":"src/divbwt.c","line_number":426,"entry_url":"https://github.com/kjn/lbzip2.git","slot_name":"v2.2"},"4125952":{"score":0.675104,"function_name":"ss_blockswap","code":"static INLINE\nvoid\nss_blockswap(int *a, int *b, int n) {\n  int t;\n  for(; 0 \u003c n; --n, ++a, ++b) {\n    t = *a, *a = *b, *b = t;\n  }\n}","filepath":"libzpaq.cpp","line_number":5176,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4126032":{"score":0.791336,"function_name":"salsa8","code":"static void salsa8(U32* b) {\n  unsigned x[16]={0};\n  memcpy(x, b, 64);\n  for (int i=0; i\u003c4; ++i) {\n    #define R(a,b) (((a)\u003c\u003c(b))+((a)\u003e\u003e(32-b)))\n    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n    #undef R\n  }\n  for (int i=0; i\u003c16; ++i) b[i]+=x[i];\n}","filepath":"libzpaq.cpp","line_number":601,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4126880":{"score":0.8697652,"function_name":"blockmix","code":"static void blockmix(U32* b, int r) {\n  assert(r\u003c=8);\n  U32 x[16];\n  U32 y[256];\n  memcpy(x, b+32*r-16, 64);\n  for (int i=0; i\u003c2*r; ++i) {\n    for (int j=0; j\u003c16; ++j) x[j]^=b[i*16+j];\n    salsa8(x);\n    memcpy(\u0026y[i*16], x, 64);\n  }\n  for (int i=0; i\u003cr; ++i) memcpy(b+i*16, \u0026y[i*32], 64);\n  for (int i=0; i\u003cr; ++i) memcpy(b+(i+r)*16, \u0026y[i*32+16], 64);\n}","filepath":"libzpaq.cpp","line_number":628,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4127344":{"score":0.67222357,"function_name":"ZPAQL::write","code":"bool ZPAQL::write(Writer* out2, bool pp) {\n  if (header.size()\u003c=6) return false;\n  assert(header[0]+256*header[1]==cend-2+hend-hbegin);\n  assert(cend\u003e=7);\n  assert(hbegin\u003e=cend);\n  assert(hend\u003e=hbegin);\n  assert(out2);\n  if (!pp) {  // if not a postprocessor then write COMP\n    for (int i=0; i\u003ccend; ++i)\n      out2-\u003eput(header[i]);\n  }\n  else {  // write PCOMP size only\n    out2-\u003eput((hend-hbegin)\u0026255);\n    out2-\u003eput((hend-hbegin)\u003e\u003e8);\n  }\n  for (int i=hbegin; i\u003chend; ++i)\n    out2-\u003eput(header[i]);\n  return true;\n}","filepath":"libzpaq.cpp","line_number":866,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4127712":{"score":0.6652087,"function_name":"salsa8","code":"static void salsa8(U32* b) {\n  unsigned x[16]={0};\n  memcpy(x, b, 64);\n  for (int i=0; i\u003c4; ++i) {\n    #define R(a,b) (((a)\u003c\u003c(b))+((a)\u003e\u003e(32-b)))\n    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n    #undef R\n  }\n  for (int i=0; i\u003c16; ++i) b[i]+=x[i];\n}","filepath":"libzpaq.cpp","line_number":601,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4129472":{"score":0.622532,"function_name":"ss_pivot","code":"static INLINE\nint *\nss_pivot(const unsigned char *Td, const int *PA, int *first, int *last) {\n  int *middle;\n  int t;\n\n  t = last - first;\n  middle = first + t / 2;\n\n  if(t \u003c= 512) {\n    if(t \u003c= 32) {\n      return ss_median3(Td, PA, first, middle, last - 1);\n    } else {\n      t \u003e\u003e= 2;\n      return ss_median5(Td, PA, first, first + t, middle, last - 1 - t, last - 1);\n    }\n  }\n  t \u003e\u003e= 3;\n  first  = ss_median3(Td, PA, first, first + t, first + (t \u003c\u003c 1));\n  middle = ss_median3(Td, PA, middle - t, middle, middle + t);\n  last   = ss_median3(Td, PA, last - 1 - (t \u003c\u003c 1), last - 1 - t, last - 1);\n  return ss_median3(Td, PA, first, middle, last);\n}","filepath":"libzpaq.cpp","line_number":4987,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4135168":{"score":0.87405974,"function_name":"ss_swapmerge","code":"static\nvoid\nss_swapmerge(const unsigned char *T, const int *PA,\n             int *first, int *middle, int *last,\n             int *buf, int bufsize, int depth) {\n#define STACK_SIZE SS_SMERGE_STACKSIZE\n#define GETIDX(a) ((0 \u003c= (a)) ? (a) : (~(a)))\n#define MERGE_CHECK(a, b, c)\\\n  do {\\\n    if(((c) \u0026 1) ||\\\n       (((c) \u0026 2) \u0026\u0026 (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\\\n      *(a) = ~*(a);\\\n    }\\\n    if(((c) \u0026 4) \u0026\u0026 ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\\\n      *(b) = ~*(b);\\\n    }\\\n  } while(0)\n  struct { int *a, *b, *c; int d; } stack[STACK_SIZE];\n  int *l, *r, *lm, *rm;\n  int m, len, half;\n  int ssize;\n  int check, next;\n\n  for(check = 0, ssize = 0;;) {\n    if((last - middle) \u003c= bufsize) {\n      if((first \u003c middle) \u0026\u0026 (middle \u003c last)) {\n        ss_mergebackward(T, PA, first, middle, last, buf, depth);\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n      continue;\n    }\n\n    if((middle - first) \u003c= bufsize) {\n      if(first \u003c middle) {\n        ss_mergeforward(T, PA, first, middle, last, buf, depth);\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n      continue;\n    }\n\n    for(m = 0, len = MIN(middle - first, last - middle), half = len \u003e\u003e 1;\n        0 \u003c len;\n        len = half, half \u003e\u003e= 1) {\n      if(ss_compare(T, PA + GETIDX(*(middle + m + half)),\n                       PA + GETIDX(*(middle - m - half - 1)), depth) \u003c 0) {\n        m += half + 1;\n        half -= (len \u0026 1) ^ 1;\n      }\n    }\n\n    if(0 \u003c m) {\n      lm = middle - m, rm = middle + m;\n      ss_blockswap(lm, middle, m);\n      l = r = middle, next = 0;\n      if(rm \u003c last) {\n        if(*rm \u003c 0) {\n          *rm = ~*rm;\n          if(first \u003c lm) { for(; *--l \u003c 0;) { } next |= 4; }\n          next |= 1;\n        } else if(first \u003c lm) {\n          for(; *r \u003c 0; ++r) { }\n          next |= 2;\n        }\n      }\n\n      if((l - first) \u003c= (last - r)) {\n        STACK_PUSH(r, rm, last, (next \u0026 3) | (check \u0026 4));\n        middle = lm, last = l, check = (check \u0026 3) | (next \u0026 4);\n      } else {\n        if((next \u0026 2) \u0026\u0026 (r == middle)) { next ^= 6; }\n        STACK_PUSH(first, lm, l, (check \u0026 3) | (next \u0026 4));\n        first = r, middle = rm, check = (next \u0026 3) | (check \u0026 4);\n      }\n    } else {\n      if(ss_compare(T, PA + GETIDX(*(middle - 1)), PA + *middle, depth) == 0) {\n        *middle = ~*middle;\n      }\n      MERGE_CHECK(first, last, check);\n      STACK_POP(first, middle, last, check);\n    }\n  }\n#undef STACK_SIZE\n}","filepath":"libzpaq.cpp","line_number":5378,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4139504":{"score":0.7949817,"function_name":"tr_introsort","code":"static\nvoid\ntr_introsort(int *ISA, const int *ISAd,\n             int *SA, int *first, int *last,\n             trbudget_t *budget) {\n#define STACK_SIZE TR_STACKSIZE\n  struct { const int *a; int *b, *c; int d, e; }stack[STACK_SIZE];\n  int *a, *b, *c;\n  int t;\n  int v, x = 0;\n  int incr = ISAd - ISA;\n  int limit, next;\n  int ssize, trlink = -1;\n\n  for(ssize = 0, limit = tr_ilg(last - first);;) {\n\n    if(limit \u003c 0) {\n      if(limit == -1) {\n        /* tandem repeat partition */\n        tr_partition(ISAd - incr, first, first, last, \u0026a, \u0026b, last - SA - 1);\n\n        /* update ranks */\n        if(a \u003c last) {\n          for(c = first, v = a - SA - 1; c \u003c a; ++c) { ISA[*c] = v; }\n        }\n        if(b \u003c last) {\n          for(c = a, v = b - SA - 1; c \u003c b; ++c) { ISA[*c] = v; }\n        }\n\n        /* push */\n        if(1 \u003c (b - a)) {\n          STACK_PUSH5(NULL, a, b, 0, 0);\n          STACK_PUSH5(ISAd - incr, first, last, -2, trlink);\n          trlink = ssize - 2;\n        }\n        if((a - first) \u003c= (last - b)) {\n          if(1 \u003c (a - first)) {\n            STACK_PUSH5(ISAd, b, last, tr_ilg(last - b), trlink);\n            last = a, limit = tr_ilg(a - first);\n          } else if(1 \u003c (last - b)) {\n            first = b, limit = tr_ilg(last - b);\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        } else {\n          if(1 \u003c (last - b)) {\n            STACK_PUSH5(ISAd, first, a, tr_ilg(a - first), trlink);\n            first = b, limit = tr_ilg(last - b);\n          } else if(1 \u003c (a - first)) {\n            last = a, limit = tr_ilg(a - first);\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        }\n      } else if(limit == -2) {\n        /* tandem repeat copy */\n        a = stack[--ssize].b, b = stack[ssize].c;\n        if(stack[ssize].d == 0) {\n          tr_copy(ISA, SA, first, a, b, last, ISAd - ISA);\n        } else {\n          if(0 \u003c= trlink) { stack[trlink].d = -1; }\n          tr_partialcopy(ISA, SA, first, a, b, last, ISAd - ISA);\n        }\n        STACK_POP5(ISAd, first, last, limit, trlink);\n      } else {\n        /* sorted partition */\n        if(0 \u003c= *first) {\n          a = first;\n          do { ISA[*a] = a - SA; } while((++a \u003c last) \u0026\u0026 (0 \u003c= *a));\n          first = a;\n        }\n        if(first \u003c last) {\n          a = first; do { *a = ~*a; } while(*++a \u003c 0);\n          next = (ISA[*a] != ISAd[*a]) ? tr_ilg(a - first + 1) : -1;\n          if(++a \u003c last) { for(b = first, v = a - SA - 1; b \u003c a; ++b) { ISA[*b] = v; } }\n\n          /* push */\n          if(trbudget_check(budget, a - first)) {\n            if((a - first) \u003c= (last - a)) {\n              STACK_PUSH5(ISAd, a, last, -3, trlink);\n              ISAd += incr, last = a, limit = next;\n            } else {\n              if(1 \u003c (last - a)) {\n                STACK_PUSH5(ISAd + incr, first, a, next, trlink);\n                first = a, limit = -3;\n              } else {\n                ISAd += incr, last = a, limit = next;\n              }\n            }\n          } else {\n            if(0 \u003c= trlink) { stack[trlink].d = -1; }\n            if(1 \u003c (last - a)) {\n              first = a, limit = -3;\n            } else {\n              STACK_POP5(ISAd, first, last, limit, trlink);\n            }\n          }\n        } else {\n          STACK_POP5(ISAd, first, last, limit, trlink);\n        }\n      }\n      continue;\n    }\n\n    if((last - first) \u003c= TR_INSERTIONSORT_THRESHOLD) {\n      tr_insertionsort(ISAd, first, last);\n      limit = -3;\n      continue;\n    }\n\n    if(limit-- == 0) {\n      tr_heapsort(ISAd, first, last - first);\n      for(a = last - 1; first \u003c a; a = b) {\n        for(x = ISAd[*a], b = a - 1; (first \u003c= b) \u0026\u0026 (ISAd[*b] == x); --b) { *b = ~*b; }\n      }\n      limit = -3;\n      continue;\n    }\n\n    /* choose pivot */\n    a = tr_pivot(ISAd, first, last);\n    SWAP(*first, *a);\n    v = ISAd[*first];\n\n    /* partition */\n    tr_partition(ISAd, first, first + 1, last, \u0026a, \u0026b, v);\n    if((last - first) != (b - a)) {\n      next = (ISA[*a] != v) ? tr_ilg(b - a) : -1;\n\n      /* update ranks */\n      for(c = first, v = a - SA - 1; c \u003c a; ++c) { ISA[*c] = v; }\n      if(b \u003c last) { for(c = a, v = b - SA - 1; c \u003c b; ++c) { ISA[*c] = v; } }\n\n      /* push */\n      if((1 \u003c (b - a)) \u0026\u0026 (trbudget_check(budget, b - a))) {\n        if((a - first) \u003c= (last - b)) {\n          if((last - b) \u003c= (b - a)) {\n            if(1 \u003c (a - first)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              STACK_PUSH5(ISAd, b, last, limit, trlink);\n              last = a;\n            } else if(1 \u003c (last - b)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              first = b;\n            } else {\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else if((a - first) \u003c= (b - a)) {\n            if(1 \u003c (a - first)) {\n              STACK_PUSH5(ISAd, b, last, limit, trlink);\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              last = a;\n            } else {\n              STACK_PUSH5(ISAd, b, last, limit, trlink);\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else {\n            STACK_PUSH5(ISAd, b, last, limit, trlink);\n            STACK_PUSH5(ISAd, first, a, limit, trlink);\n            ISAd += incr, first = a, last = b, limit = next;\n          }\n        } else {\n          if((a - first) \u003c= (b - a)) {\n            if(1 \u003c (last - b)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              STACK_PUSH5(ISAd, first, a, limit, trlink);\n              first = b;\n            } else if(1 \u003c (a - first)) {\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              last = a;\n            } else {\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else if((last - b) \u003c= (b - a)) {\n            if(1 \u003c (last - b)) {\n              STACK_PUSH5(ISAd, first, a, limit, trlink);\n              STACK_PUSH5(ISAd + incr, a, b, next, trlink);\n              first = b;\n            } else {\n              STACK_PUSH5(ISAd, first, a, limit, trlink);\n              ISAd += incr, first = a, last = b, limit = next;\n            }\n          } else {\n            STACK_PUSH5(ISAd, first, a, limit, trlink);\n            STACK_PUSH5(ISAd, b, last, limit, trlink);\n            ISAd += incr, first = a, last = b, limit = next;\n          }\n        }\n      } else {\n        if((1 \u003c (b - a)) \u0026\u0026 (0 \u003c= trlink)) { stack[trlink].d = -1; }\n        if((a - first) \u003c= (last - b)) {\n          if(1 \u003c (a - first)) {\n            STACK_PUSH5(ISAd, b, last, limit, trlink);\n            last = a;\n          } else if(1 \u003c (last - b)) {\n            first = b;\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        } else {\n          if(1 \u003c (last - b)) {\n            STACK_PUSH5(ISAd, first, a, limit, trlink);\n            first = b;\n          } else if(1 \u003c (a - first)) {\n            last = a;\n          } else {\n            STACK_POP5(ISAd, first, last, limit, trlink);\n          }\n        }\n      }\n    } else {\n      if(trbudget_check(budget, last - first)) {\n        limit = tr_ilg(last - first), ISAd += incr;\n      } else {\n        if(0 \u003c= trlink) { stack[trlink].d = -1; }\n        STACK_POP5(ISAd, first, last, limit, trlink);\n      }\n    }\n  }\n#undef STACK_SIZE\n}","filepath":"libzpaq.cpp","line_number":5809,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4153056":{"score":0.83283913,"function_name":"allocx","code":"void allocx(U8* \u0026p, int \u0026n, int newsize) {\n#ifdef NOJIT\n  p=0;\n  n=0;\n#else\n  if (p || n) {\n    if (p)\n#ifdef unix\n      munmap(p, n);\n#else // Windows\n      VirtualFree(p, 0, MEM_RELEASE);\n#endif\n    p=0;\n    n=0;\n  }\n  if (newsize\u003e0) {\n#ifdef unix\n    p=(U8*)mmap(0, newsize, PROT_READ|PROT_WRITE|PROT_EXEC,\n                MAP_PRIVATE|MAP_ANON, -1, 0);\n    if ((void*)p==MAP_FAILED) p=0;\n#else\n    p=(U8*)VirtualAlloc(0, newsize, MEM_RESERVE|MEM_COMMIT,\n                        PAGE_EXECUTE_READWRITE);\n#endif\n    if (p)\n      n=newsize;\n    else {\n      n=0;\n      error(\"allocx failed\");\n    }\n  }\n#endif\n}","filepath":"libzpaq.cpp","line_number":67,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4153216":{"score":0.83238316,"function_name":"SHA1::init","code":"void SHA1::init() {\n  len=0;\n  h[0]=0x67452301;\n  h[1]=0xEFCDAB89;\n  h[2]=0x98BADCFE;\n  h[3]=0x10325476;\n  h[4]=0xC3D2E1F0;\n  memset(w, 0, sizeof(w));\n}","filepath":"libzpaq.cpp","line_number":106,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4153264":{"score":0.8236925,"function_name":"SHA256::process","code":"void SHA256::process() {\n\n  #define ror(a,b) ((a)\u003e\u003e(b)|(a\u003c\u003c(32-(b))))\n\n  #define m(i) \\\n     w[(i)\u002615]+=w[(i-7)\u002615] \\\n       +(ror(w[(i-15)\u002615],7)^ror(w[(i-15)\u002615],18)^(w[(i-15)\u002615]\u003e\u003e3)) \\\n       +(ror(w[(i-2)\u002615],17)^ror(w[(i-2)\u002615],19)^(w[(i-2)\u002615]\u003e\u003e10))\n\n  #define r(a,b,c,d,e,f,g,h,i) { \\\n    unsigned t1=ror(e,14)^e; \\\n    t1=ror(t1,5)^e; \\\n    h+=ror(t1,6)+((e\u0026f)^(~e\u0026g))+k[i]+w[(i)\u002615]; } \\\n    d+=h; \\\n    {unsigned t1=ror(a,9)^a; \\\n    t1=ror(t1,11)^a; \\\n    h+=ror(t1,2)+((a\u0026b)^(c\u0026(a^b))); }\n\n  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);\n\n  #define r8(i) \\\n    r(a,b,c,d,e,f,g,h,i);   \\\n    r(h,a,b,c,d,e,f,g,i+1); \\\n    r(g,h,a,b,c,d,e,f,i+2); \\\n    r(f,g,h,a,b,c,d,e,i+3); \\\n    r(e,f,g,h,a,b,c,d,i+4); \\\n    r(d,e,f,g,h,a,b,c,i+5); \\\n    r(c,d,e,f,g,h,a,b,i+6); \\\n    r(b,c,d,e,f,g,h,a,i+7);\n\n  #define mr8(i) \\\n    mr(a,b,c,d,e,f,g,h,i);   \\\n    mr(h,a,b,c,d,e,f,g,i+1); \\\n    mr(g,h,a,b,c,d,e,f,i+2); \\\n    mr(f,g,h,a,b,c,d,e,i+3); \\\n    mr(e,f,g,h,a,b,c,d,i+4); \\\n    mr(d,e,f,g,h,a,b,c,i+5); \\\n    mr(c,d,e,f,g,h,a,b,i+6); \\\n    mr(b,c,d,e,f,g,h,a,i+7);\n\n  static const unsigned k[64]={\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};\n\n  unsigned a=s[0];\n  unsigned b=s[1];\n  unsigned c=s[2];\n  unsigned d=s[3];\n  unsigned e=s[4];\n  unsigned f=s[5];\n  unsigned g=s[6];\n  unsigned h=s[7];\n\n  r8(0);\n  r8(8);\n  mr8(16);\n  mr8(24);\n  mr8(32);\n  mr8(40);\n  mr8(48);\n  mr8(56);\n\n  s[0]+=a;\n  s[1]+=b;\n  s[2]+=c;\n  s[3]+=d;\n  s[4]+=e;\n  s[5]+=f;\n  s[6]+=g;\n  s[7]+=h;\n\n  #undef mr8\n  #undef r8\n  #undef mr\n  #undef r\n  #undef m\n  #undef ror\n}","filepath":"libzpaq.cpp","line_number":194,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4157664":{"score":0.7379222,"function_name":"SHA1::write","code":"void SHA1::write(const char* buf, int64_t n) {\n  const unsigned char* p=(const unsigned char*) buf;\n  for (; n\u003e0 \u0026\u0026 (U32(len)\u0026511)!=0; --n) put(*p++);\n  for (; n\u003e=64; n-=64) {\n    for (int i=0; i\u003c16; ++i)\n      w[i]=p[0]\u003c\u003c24|p[1]\u003c\u003c16|p[2]\u003c\u003c8|p[3], p+=4;\n    len+=512;\n    process();\n  }\n  for (; n\u003e0; --n) put(*p++);\n}","filepath":"libzpaq.cpp","line_number":147,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4158192":{"score":0.6471893,"function_name":"SHA1::result","code":"const char* SHA1::result() {\n\n  // pad and append length\n  const U64 s=len;\n  put(0x80);\n  while ((len\u0026511)!=448)\n    put(0);\n  put(s\u003e\u003e56);\n  put(s\u003e\u003e48);\n  put(s\u003e\u003e40);\n  put(s\u003e\u003e32);\n  put(s\u003e\u003e24);\n  put(s\u003e\u003e16);\n  put(s\u003e\u003e8);\n  put(s);\n\n  // copy h to hbuf\n  for (int i=0; i\u003c5; ++i) {\n    hbuf[4*i]=h[i]\u003e\u003e24;\n    hbuf[4*i+1]=h[i]\u003e\u003e16;\n    hbuf[4*i+2]=h[i]\u003e\u003e8;\n    hbuf[4*i+3]=h[i];\n  }\n\n  // return hash prior to clearing state\n  init();\n  return hbuf;\n}","filepath":"libzpaq.cpp","line_number":117,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4159184":{"score":0.8441315,"function_name":"SHA256::init","code":"void SHA256::init() {\n  len0=len1=0;\n  s[0]=0x6a09e667;\n  s[1]=0xbb67ae85;\n  s[2]=0x3c6ef372;\n  s[3]=0xa54ff53a;\n  s[4]=0x510e527f;\n  s[5]=0x9b05688c;\n  s[6]=0x1f83d9ab;\n  s[7]=0x5be0cd19;\n  memset(w, 0, sizeof(w));\n}","filepath":"libzpaq.cpp","line_number":181,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4159248":{"score":0.8697283,"function_name":"SHA256::process","code":"void SHA256::process() {\n\n  #define ror(a,b) ((a)\u003e\u003e(b)|(a\u003c\u003c(32-(b))))\n\n  #define m(i) \\\n     w[(i)\u002615]+=w[(i-7)\u002615] \\\n       +(ror(w[(i-15)\u002615],7)^ror(w[(i-15)\u002615],18)^(w[(i-15)\u002615]\u003e\u003e3)) \\\n       +(ror(w[(i-2)\u002615],17)^ror(w[(i-2)\u002615],19)^(w[(i-2)\u002615]\u003e\u003e10))\n\n  #define r(a,b,c,d,e,f,g,h,i) { \\\n    unsigned t1=ror(e,14)^e; \\\n    t1=ror(t1,5)^e; \\\n    h+=ror(t1,6)+((e\u0026f)^(~e\u0026g))+k[i]+w[(i)\u002615]; } \\\n    d+=h; \\\n    {unsigned t1=ror(a,9)^a; \\\n    t1=ror(t1,11)^a; \\\n    h+=ror(t1,2)+((a\u0026b)^(c\u0026(a^b))); }\n\n  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);\n\n  #define r8(i) \\\n    r(a,b,c,d,e,f,g,h,i);   \\\n    r(h,a,b,c,d,e,f,g,i+1); \\\n    r(g,h,a,b,c,d,e,f,i+2); \\\n    r(f,g,h,a,b,c,d,e,i+3); \\\n    r(e,f,g,h,a,b,c,d,i+4); \\\n    r(d,e,f,g,h,a,b,c,i+5); \\\n    r(c,d,e,f,g,h,a,b,i+6); \\\n    r(b,c,d,e,f,g,h,a,i+7);\n\n  #define mr8(i) \\\n    mr(a,b,c,d,e,f,g,h,i);   \\\n    mr(h,a,b,c,d,e,f,g,i+1); \\\n    mr(g,h,a,b,c,d,e,f,i+2); \\\n    mr(f,g,h,a,b,c,d,e,i+3); \\\n    mr(e,f,g,h,a,b,c,d,i+4); \\\n    mr(d,e,f,g,h,a,b,c,i+5); \\\n    mr(c,d,e,f,g,h,a,b,i+6); \\\n    mr(b,c,d,e,f,g,h,a,i+7);\n\n  static const unsigned k[64]={\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};\n\n  unsigned a=s[0];\n  unsigned b=s[1];\n  unsigned c=s[2];\n  unsigned d=s[3];\n  unsigned e=s[4];\n  unsigned f=s[5];\n  unsigned g=s[6];\n  unsigned h=s[7];\n\n  r8(0);\n  r8(8);\n  mr8(16);\n  mr8(24);\n  mr8(32);\n  mr8(40);\n  mr8(48);\n  mr8(56);\n\n  s[0]+=a;\n  s[1]+=b;\n  s[2]+=c;\n  s[3]+=d;\n  s[4]+=e;\n  s[5]+=f;\n  s[6]+=g;\n  s[7]+=h;\n\n  #undef mr8\n  #undef r8\n  #undef mr\n  #undef r\n  #undef m\n  #undef ror\n}","filepath":"libzpaq.cpp","line_number":194,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4169552":{"score":0.7347605,"function_name":"SHA1::result","code":"const char* SHA1::result() {\n\n  // pad and append length\n  const U64 s=len;\n  put(0x80);\n  while ((len\u0026511)!=448)\n    put(0);\n  put(s\u003e\u003e56);\n  put(s\u003e\u003e48);\n  put(s\u003e\u003e40);\n  put(s\u003e\u003e32);\n  put(s\u003e\u003e24);\n  put(s\u003e\u003e16);\n  put(s\u003e\u003e8);\n  put(s);\n\n  // copy h to hbuf\n  for (int i=0; i\u003c5; ++i) {\n    hbuf[4*i]=h[i]\u003e\u003e24;\n    hbuf[4*i+1]=h[i]\u003e\u003e16;\n    hbuf[4*i+2]=h[i]\u003e\u003e8;\n    hbuf[4*i+3]=h[i];\n  }\n\n  // return hash prior to clearing state\n  init();\n  return hbuf;\n}","filepath":"libzpaq.cpp","line_number":117,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4172256":{"score":0.7471557,"function_name":"pbkdf2","code":"static void pbkdf2(const char* pw, int pwLen, const char* salt, int saltLen,\n                   int c, char* buf, int dkLen) {\n  assert(c==1);\n  assert(dkLen%32==0);\n  assert(pwLen\u003c=64);\n\n  libzpaq::SHA256 sha256;\n  char b[32];\n  for (int i=1; i*32\u003c=dkLen; ++i) {\n    for (int j=0; j\u003cpwLen; ++j) sha256.put(pw[j]^0x36);\n    for (int j=pwLen; j\u003c64; ++j) sha256.put(0x36);\n    for (int j=0; j\u003csaltLen; ++j) sha256.put(salt[j]);\n    for (int j=24; j\u003e=0; j-=8) sha256.put(i\u003e\u003ej);\n    memcpy(b, sha256.result(), 32);\n    for (int j=0; j\u003cpwLen; ++j) sha256.put(pw[j]^0x5c);\n    for (int j=pwLen; j\u003c64; ++j) sha256.put(0x5c);\n    for (int j=0; j\u003c32; ++j) sha256.put(b[j]);\n    memcpy(buf+i*32-32, sha256.result(), 32);\n  }\n}","filepath":"libzpaq.cpp","line_number":578,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4173776":{"score":0.78834355,"function_name":"AES_CTR::AES_CTR","code":"AES_CTR::AES_CTR(const char* key, int keylen, const char* iv) {\n  assert(key  != NULL);\n  assert(keylen==16 || keylen==24 || keylen==32);\n\n  // Initialize IV (default 0)\n  iv0=iv1=0;\n  if (iv) {\n    LOAD32H(iv0, iv);\n    LOAD32H(iv1, iv+4);\n  }\n\n  // Initialize encryption tables\n  for (int i=0; i\u003c256; ++i) {\n    unsigned s1=\n    \"\\x63\\x7c\\x77\\x7b\\xf2\\x6b\\x6f\\xc5\\x30\\x01\\x67\\x2b\\xfe\\xd7\\xab\\x76\"\n    \"\\xca\\x82\\xc9\\x7d\\xfa\\x59\\x47\\xf0\\xad\\xd4\\xa2\\xaf\\x9c\\xa4\\x72\\xc0\"\n    \"\\xb7\\xfd\\x93\\x26\\x36\\x3f\\xf7\\xcc\\x34\\xa5\\xe5\\xf1\\x71\\xd8\\x31\\x15\"\n    \"\\x04\\xc7\\x23\\xc3\\x18\\x96\\x05\\x9a\\x07\\x12\\x80\\xe2\\xeb\\x27\\xb2\\x75\"\n    \"\\x09\\x83\\x2c\\x1a\\x1b\\x6e\\x5a\\xa0\\x52\\x3b\\xd6\\xb3\\x29\\xe3\\x2f\\x84\"\n    \"\\x53\\xd1\\x00\\xed\\x20\\xfc\\xb1\\x5b\\x6a\\xcb\\xbe\\x39\\x4a\\x4c\\x58\\xcf\"\n    \"\\xd0\\xef\\xaa\\xfb\\x43\\x4d\\x33\\x85\\x45\\xf9\\x02\\x7f\\x50\\x3c\\x9f\\xa8\"\n    \"\\x51\\xa3\\x40\\x8f\\x92\\x9d\\x38\\xf5\\xbc\\xb6\\xda\\x21\\x10\\xff\\xf3\\xd2\"\n    \"\\xcd\\x0c\\x13\\xec\\x5f\\x97\\x44\\x17\\xc4\\xa7\\x7e\\x3d\\x64\\x5d\\x19\\x73\"\n    \"\\x60\\x81\\x4f\\xdc\\x22\\x2a\\x90\\x88\\x46\\xee\\xb8\\x14\\xde\\x5e\\x0b\\xdb\"\n    \"\\xe0\\x32\\x3a\\x0a\\x49\\x06\\x24\\x5c\\xc2\\xd3\\xac\\x62\\x91\\x95\\xe4\\x79\"\n    \"\\xe7\\xc8\\x37\\x6d\\x8d\\xd5\\x4e\\xa9\\x6c\\x56\\xf4\\xea\\x65\\x7a\\xae\\x08\"\n    \"\\xba\\x78\\x25\\x2e\\x1c\\xa6\\xb4\\xc6\\xe8\\xdd\\x74\\x1f\\x4b\\xbd\\x8b\\x8a\"\n    \"\\x70\\x3e\\xb5\\x66\\x48\\x03\\xf6\\x0e\\x61\\x35\\x57\\xb9\\x86\\xc1\\x1d\\x9e\"\n    \"\\xe1\\xf8\\x98\\x11\\x69\\xd9\\x8e\\x94\\x9b\\x1e\\x87\\xe9\\xce\\x55\\x28\\xdf\"\n    \"\\x8c\\xa1\\x89\\x0d\\xbf\\xe6\\x42\\x68\\x41\\x99\\x2d\\x0f\\xb0\\x54\\xbb\\x16\"\n    [i]\u0026255;\n    unsigned s2=s1\u003c\u003c1;\n    if (s2\u003e=0x100) s2^=0x11b;\n    unsigned s3=s1^s2;\n    Te0[i]=s2\u003c\u003c24|s1\u003c\u003c16|s1\u003c\u003c8|s3;\n    Te1[i]=s3\u003c\u003c24|s2\u003c\u003c16|s1\u003c\u003c8|s1;\n    Te2[i]=s1\u003c\u003c24|s3\u003c\u003c16|s2\u003c\u003c8|s1;\n    Te3[i]=s1\u003c\u003c24|s1\u003c\u003c16|s3\u003c\u003c8|s2;\n    Te4[i]=s1\u003c\u003c24|s1\u003c\u003c16|s1\u003c\u003c8|s1;\n  }\n\n  // setup the forward key\n  Nr = 10 + ((keylen/8)-2)*2;  // 10, 12, or 14 rounds\n  int i = 0;\n  U32* rk = \u0026ek[0];\n  U32 temp;\n  static const U32 rcon[10] = {\n    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,\n    0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,\n    0x1B000000UL, 0x36000000UL};  // round constants\n\n  LOAD32H(rk[0], key   );\n  LOAD32H(rk[1], key +  4);\n  LOAD32H(rk[2], key +  8);\n  LOAD32H(rk[3], key + 12);\n  if (keylen == 16) {\n    for (;;) {\n      temp  = rk[3];\n      rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];\n      rk[5] = rk[1] ^ rk[4];\n      rk[6] = rk[2] ^ rk[5];\n      rk[7] = rk[3] ^ rk[6];\n      if (++i == 10) {\n         break;\n      }\n      rk += 4;\n    }\n  }\n  else if (keylen == 24) {\n    LOAD32H(rk[4], key + 16);\n    LOAD32H(rk[5], key + 20);\n    for (;;) {\n      temp = rk[5];\n      rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];\n      rk[ 7] = rk[ 1] ^ rk[ 6];\n      rk[ 8] = rk[ 2] ^ rk[ 7];\n      rk[ 9] = rk[ 3] ^ rk[ 8];\n      if (++i == 8) {\n        break;\n      }\n      rk[10] = rk[ 4] ^ rk[ 9];\n      rk[11] = rk[ 5] ^ rk[10];\n      rk += 6;\n    }\n  }\n  else if (keylen == 32) {\n    LOAD32H(rk[4], key + 16);\n    LOAD32H(rk[5], key + 20);\n    LOAD32H(rk[6], key + 24);\n    LOAD32H(rk[7], key + 28);\n    for (;;) {\n      temp = rk[7];\n      rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];\n      rk[ 9] = rk[ 1] ^ rk[ 8];\n      rk[10] = rk[ 2] ^ rk[ 9];\n      rk[11] = rk[ 3] ^ rk[10];\n      if (++i == 7) {\n        break;\n      }\n      temp = rk[11];\n      rk[12] = rk[ 4] ^ setup_mix(temp\u003c\u003c24|temp\u003e\u003e8);\n      rk[13] = rk[ 5] ^ rk[12];\n      rk[14] = rk[ 6] ^ rk[13];\n      rk[15] = rk[ 7] ^ rk[14];\n      rk += 8;\n    }\n  }\n}","filepath":"libzpaq.cpp","line_number":347,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4177120":{"score":0.8306214,"function_name":"AES_CTR::encrypt","code":"void AES_CTR::encrypt(U32 s0, U32 s1, U32 s2, U32 s3, unsigned char* ct) {\n  int r = Nr \u003e\u003e 1;\n  U32 *rk = \u0026ek[0];\n  U32 t0=0, t1=0, t2=0, t3=0;\n  s0 ^= rk[0];\n  s1 ^= rk[1];\n  s2 ^= rk[2];\n  s3 ^= rk[3];\n  for (;;) {\n    t0 =\n      Te0[byte(s0, 3)] ^\n      Te1[byte(s1, 2)] ^\n      Te2[byte(s2, 1)] ^\n      Te3[byte(s3, 0)] ^\n      rk[4];\n    t1 =\n      Te0[byte(s1, 3)] ^\n      Te1[byte(s2, 2)] ^\n      Te2[byte(s3, 1)] ^\n      Te3[byte(s0, 0)] ^\n      rk[5];\n    t2 =\n      Te0[byte(s2, 3)] ^\n      Te1[byte(s3, 2)] ^\n      Te2[byte(s0, 1)] ^\n      Te3[byte(s1, 0)] ^\n      rk[6];\n    t3 =\n      Te0[byte(s3, 3)] ^\n      Te1[byte(s0, 2)] ^\n      Te2[byte(s1, 1)] ^\n      Te3[byte(s2, 0)] ^\n      rk[7];\n\n    rk += 8;\n    if (--r == 0) {\n      break;\n    }\n\n    s0 =\n      Te0[byte(t0, 3)] ^\n      Te1[byte(t1, 2)] ^\n      Te2[byte(t2, 1)] ^\n      Te3[byte(t3, 0)] ^\n      rk[0];\n    s1 =\n      Te0[byte(t1, 3)] ^\n      Te1[byte(t2, 2)] ^\n      Te2[byte(t3, 1)] ^\n      Te3[byte(t0, 0)] ^\n      rk[1];\n    s2 =\n      Te0[byte(t2, 3)] ^\n      Te1[byte(t3, 2)] ^\n      Te2[byte(t0, 1)] ^\n      Te3[byte(t1, 0)] ^\n      rk[2];\n    s3 =\n      Te0[byte(t3, 3)] ^\n      Te1[byte(t0, 2)] ^\n      Te2[byte(t1, 1)] ^\n      Te3[byte(t2, 0)] ^\n      rk[3];\n  }\n\n  // apply last round and map cipher state to byte array block:\n  s0 =\n    (Te4_3[byte(t0, 3)]) ^\n    (Te4_2[byte(t1, 2)]) ^\n    (Te4_1[byte(t2, 1)]) ^\n    (Te4_0[byte(t3, 0)]) ^\n    rk[0];\n  STORE32H(s0, ct);\n  s1 =\n    (Te4_3[byte(t1, 3)]) ^\n    (Te4_2[byte(t2, 2)]) ^\n    (Te4_1[byte(t3, 1)]) ^\n    (Te4_0[byte(t0, 0)]) ^\n    rk[1];\n  STORE32H(s1, ct+4);\n  s2 =\n    (Te4_3[byte(t2, 3)]) ^\n    (Te4_2[byte(t3, 2)]) ^\n    (Te4_1[byte(t0, 1)]) ^\n    (Te4_0[byte(t1, 0)]) ^\n    rk[2];\n  STORE32H(s2, ct+8);\n  s3 =\n    (Te4_3[byte(t3, 3)]) ^\n    (Te4_2[byte(t0, 2)]) ^\n    (Te4_1[byte(t1, 1)]) ^\n    (Te4_0[byte(t2, 0)]) ^ \n    rk[3];\n  STORE32H(s3, ct+12);\n}","filepath":"libzpaq.cpp","line_number":457,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4178064":{"score":0.7729583,"function_name":"AES_CTR::encrypt","code":"void AES_CTR::encrypt(char* buf, int n, U64 offset) {\n  for (U64 i=offset/16; i\u003c=(offset+n)/16; ++i) {\n    unsigned char ct[16];\n    encrypt(iv0, iv1, i\u003e\u003e32, i, ct);\n    for (int j=0; j\u003c16; ++j) {\n      const int k=i*16-offset+j;\n      if (k\u003e=0 \u0026\u0026 k\u003cn)\n        buf[k]^=ct[j];\n    }\n  }\n}","filepath":"libzpaq.cpp","line_number":555,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4178640":{"score":0.61633253,"function_name":"scrypt","code":"void scrypt(const char* pw, int pwlen,\n            const char* salt, int saltlen,\n            int n, int r, int p, char* buf, int buflen) {\n  assert(r\u003c=8);\n  assert(n\u003e0 \u0026\u0026 (n\u0026(n-1))==0);  // power of 2?\n  libzpaq::Array\u003cchar\u003e b(p*r*128);\n  pbkdf2(pw, pwlen, salt, saltlen, 1, \u0026b[0], p*r*128);\n  for (int i=0; i\u003cp; ++i) smix(\u0026b[i*r*128], r, n);\n  pbkdf2(pw, pwlen, \u0026b[0], p*r*128, 1, buf, buflen);\n}","filepath":"libzpaq.cpp","line_number":661,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4180336":{"score":0.7881831,"function_name":"random","code":"void random(char* buf, int n) {\n#ifdef unix\n  FILE* in=fopen(\"/dev/urandom\", \"rb\");\n  if (in \u0026\u0026 int(fread(buf, 1, n, in))==n)\n    fclose(in);\n  else {\n    error(\"key generation failed\");\n  }\n#else\n  HCRYPTPROV h;\n  if (CryptAcquireContext(\u0026h, NULL, NULL, PROV_RSA_FULL,\n      CRYPT_VERIFYCONTEXT) \u0026\u0026 CryptGenRandom(h, n, (BYTE*)buf))\n    CryptReleaseContext(h, 0);\n  else {\n    fprintf(stderr, \"CryptGenRandom: error %d\\n\", int(GetLastError()));\n    error(\"key generation failed\");\n  }\n#endif\n  if (n\u003e=1 \u0026\u0026 (buf[0]=='z' || buf[0]=='7'))\n    buf[0]^=0x80;\n}","filepath":"libzpaq.cpp","line_number":685,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4180464":{"score":0.5905425,"function_name":"ZPAQL::clear","code":"void ZPAQL::clear() {\n  cend=hbegin=hend=0;  // COMP and HCOMP locations\n  a=b=c=d=f=pc=0;      // machine state\n  header.resize(0);\n  h.resize(0);\n  m.resize(0);\n  r.resize(0);\n  allocx(rcode, rcode_size, 0);\n}","filepath":"libzpaq.cpp","line_number":932,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4180528":{"score":0.5786799,"function_name":"SHA256::init","code":"void SHA256::init() {\n  len0=len1=0;\n  s[0]=0x6a09e667;\n  s[1]=0xbb67ae85;\n  s[2]=0x3c6ef372;\n  s[3]=0xa54ff53a;\n  s[4]=0x510e527f;\n  s[5]=0x9b05688c;\n  s[6]=0x1f83d9ab;\n  s[7]=0x5be0cd19;\n  memset(w, 0, sizeof(w));\n}","filepath":"libzpaq.cpp","line_number":181,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4180624":{"score":0.77655977,"function_name":"ZPAQL::read","code":"int ZPAQL::read(Reader* in2) {\n\n  // Get header size and allocate\n  int hsize=in2-\u003eget();\n  hsize+=in2-\u003eget()*256;\n  header.resize(hsize+300);\n  cend=hbegin=hend=0;\n  header[cend++]=hsize\u0026255;\n  header[cend++]=hsize\u003e\u003e8;\n  while (cend\u003c7) header[cend++]=in2-\u003eget(); // hh hm ph pm n\n\n  // Read COMP\n  int n=header[cend-1];\n  for (int i=0; i\u003cn; ++i) {\n    int type=in2-\u003eget();  // component type\n    if (type\u003c0 || type\u003e255) error(\"unexpected end of file\");\n    header[cend++]=type;  // component type\n    int size=compsize[type];\n    if (size\u003c1) error(\"Invalid component type\");\n    if (cend+size\u003ehsize) error(\"COMP overflows header\");\n    for (int j=1; j\u003csize; ++j)\n      header[cend++]=in2-\u003eget();\n  }\n  if ((header[cend++]=in2-\u003eget())!=0) error(\"missing COMP END\");\n\n  // Insert a guard gap and read HCOMP\n  hbegin=hend=cend+128;\n  if (hend\u003ehsize+129) error(\"missing HCOMP\");\n  while (hend\u003chsize+129) {\n    assert(hend\u003cheader.isize()-8);\n    int op=in2-\u003eget();\n    if (op==-1) error(\"unexpected end of file\");\n    header[hend++]=op;\n  }\n  if ((header[hend++]=in2-\u003eget())!=0) error(\"missing HCOMP END\");\n  assert(cend\u003e=7 \u0026\u0026 cend\u003cheader.isize());\n  assert(hbegin==cend+128 \u0026\u0026 hbegin\u003cheader.isize());\n  assert(hend\u003ehbegin \u0026\u0026 hend\u003cheader.isize());\n  assert(hsize==header[0]+256*header[1]);\n  assert(hsize==cend-2+hend-hbegin);\n  allocx(rcode, rcode_size, 0);  // clear JIT code\n  return cend+hend-hbegin;\n}","filepath":"libzpaq.cpp","line_number":887,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4181392":{"score":0.6038117,"function_name":"ZPAQL::clear","code":"void ZPAQL::clear() {\n  cend=hbegin=hend=0;  // COMP and HCOMP locations\n  a=b=c=d=f=pc=0;      // machine state\n  header.resize(0);\n  h.resize(0);\n  m.resize(0);\n  r.resize(0);\n  allocx(rcode, rcode_size, 0);\n}","filepath":"libzpaq.cpp","line_number":932,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4181552":{"score":0.6223531,"function_name":"ZPAQL::ZPAQL","code":"ZPAQL::ZPAQL() {\n  output=0;\n  sha1=0;\n  rcode=0;\n  rcode_size=0;\n  clear();\n  outbuf.resize(1\u003c\u003c14);\n  bufptr=0;\n}","filepath":"libzpaq.cpp","line_number":943,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4182096":{"score":0.64724034,"function_name":"ZPAQL::memory","code":"double ZPAQL::memory() {\n  double mem=pow2(header[2]+2)+pow2(header[3])  // hh hm\n            +pow2(header[4]+2)+pow2(header[5])  // ph pm\n            +header.size();\n  int cp=7;  // start of comp list\n  for (int i=0; i\u003cheader[6]; ++i) {  // n\n    assert(cp\u003ccend);\n    double size=pow2(header[cp+1]); // sizebits\n    switch(header[cp]) {\n      case CM: mem+=4*size; break;\n      case ICM: mem+=64*size+1024; break;\n      case MATCH: mem+=4*size+pow2(header[cp+2]); break; // bufbits\n      case MIX2: mem+=2*size; break;\n      case MIX: mem+=4*size*header[cp+3]; break; // m\n      case ISSE: mem+=64*size+2048; break;\n      case SSE: mem+=128*size; break;\n    }\n    cp+=compsize[header[cp]];\n  }\n  return mem;\n}","filepath":"libzpaq.cpp","line_number":986,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4189152":{"score":0.6190103,"function_name":"Predictor::Predictor","code":"Predictor::Predictor(ZPAQL\u0026 zr):\n    c8(1), hmap4(1), z(zr) {\n  assert(sizeof(U8)==1);\n  assert(sizeof(U16)==2);\n  assert(sizeof(U32)==4);\n  assert(sizeof(U64)==8);\n  assert(sizeof(short)==2);\n  assert(sizeof(int)==4);\n  pcode=0;\n  pcode_size=0;\n  initTables=false;\n}","filepath":"libzpaq.cpp","line_number":1705,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4189696":{"score":0.7916597,"function_name":"Predictor::find","code":"size_t Predictor::find(Array\u003cU8\u003e\u0026 ht, int sizebits, U32 cxt) {\n  assert(initTables);\n  assert(ht.size()==size_t(16)\u003c\u003csizebits);\n  int chk=cxt\u003e\u003esizebits\u0026255;\n  size_t h0=(cxt*16)\u0026(ht.size()-16);\n  if (ht[h0]==chk) return h0;\n  size_t h1=h0^16;\n  if (ht[h1]==chk) return h1;\n  size_t h2=h0^32;\n  if (ht[h2]==chk) return h2;\n  if (ht[h0+1]\u003c=ht[h1+1] \u0026\u0026 ht[h0+1]\u003c=ht[h2+1])\n    return memset(\u0026ht[h0], 0, 16), ht[h0]=chk, h0;\n  else if (ht[h1+1]\u003cht[h2+1])\n    return memset(\u0026ht[h1], 0, 16), ht[h1]=chk, h1;\n  else\n    return memset(\u0026ht[h2], 0, 16), ht[h2]=chk, h2;\n}","filepath":"libzpaq.cpp","line_number":2072,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4191184":{"score":0.74477285,"function_name":"Decoder::decode","code":"int Decoder::decode(int p) {\n  assert(pr.isModeled());\n  assert(p\u003e=0 \u0026\u0026 p\u003c65536);\n  assert(high\u003elow \u0026\u0026 low\u003e0);\n  if (curr\u003clow || curr\u003ehigh) error(\"archive corrupted\");\n  assert(curr\u003e=low \u0026\u0026 curr\u003c=high);\n  U32 mid=low+U32(((high-low)*U64(U32(p)))\u003e\u003e16);  // split range\n  assert(high\u003emid \u0026\u0026 mid\u003e=low);\n  int y;\n  if (curr\u003c=mid) y=1, high=mid;  // pick half\n  else y=0, low=mid+1;\n  while ((high^low)\u003c0x1000000) { // shift out identical leading bytes\n    high=high\u003c\u003c8|255;\n    low=low\u003c\u003c8;\n    low+=(low==0);\n    int c=get();\n    if (c\u003c0) error(\"unexpected end of file\");\n    curr=curr\u003c\u003c8|c;\n  }\n  return y;\n}","filepath":"libzpaq.cpp","line_number":2104,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4191584":{"score":0.7058561,"function_name":"Decoder::skip","code":"int Decoder::skip() {\n  int c=-1;\n  if (pr.isModeled()) {\n    while (curr==0)  // at start?\n      curr=get();\n    while (curr \u0026\u0026 (c=get())\u003e=0)  // find 4 zeros\n      curr=curr\u003c\u003c8|c;\n    while ((c=get())==0) ;  // might be more than 4\n    return c;\n  }\n  else {\n    if (curr==0)  // at start?\n      for (int i=0; i\u003c4 \u0026\u0026 (c=get())\u003e=0; ++i) curr=curr\u003c\u003c8|c;\n    while (curr\u003e0) {\n      while (curr\u003e0) {\n        --curr;\n        if (get()\u003c0) return error(\"skipped to EOF\"), -1;\n      }\n      for (int i=0; i\u003c4 \u0026\u0026 (c=get())\u003e=0; ++i) curr=curr\u003c\u003c8|c;\n    }\n    if (c\u003e=0) c=get();\n    return c;\n  }\n}","filepath":"libzpaq.cpp","line_number":2158,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4193968":{"score":0.64881706,"function_name":"Decompresser::findBlock","code":"bool Decompresser::findBlock(double* memptr) {\n  assert(state==BLOCK);\n\n  // Find start of block\n  U32 h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;\n  // Rolling hashes initialized to hash of first 13 bytes\n  int c;\n  while ((c=dec.get())!=-1) {\n    h1=h1*12+c;\n    h2=h2*20+c;\n    h3=h3*28+c;\n    h4=h4*44+c;\n    if (h1==0xB16B88F1 \u0026\u0026 h2==0xFF5376F1 \u0026\u0026 h3==0x72AC5BF1 \u0026\u0026 h4==0x2F909AF1)\n      break;  // hash of 16 byte string\n  }\n  if (c==-1) return false;\n\n  // Read header\n  if ((c=dec.get())!=1 \u0026\u0026 c!=2) error(\"unsupported ZPAQ level\");\n  if (dec.get()!=1) error(\"unsupported ZPAQL type\");\n  z.read(\u0026dec);\n  if (c==1 \u0026\u0026 z.header.isize()\u003e6 \u0026\u0026 z.header[6]==0)\n    error(\"ZPAQ level 1 requires at least 1 component\");\n  if (memptr) *memptr=z.memory();\n  state=FILENAME;\n  decode_state=FIRSTSEG;\n  return true;\n}","filepath":"libzpaq.cpp","line_number":2247,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4196528":{"score":0.7196804,"function_name":"Decompresser::findFilename","code":"bool Decompresser::findFilename(Writer* filename) {\n  assert(state==FILENAME);\n  int c=dec.get();\n  if (c==1) {  // segment found\n    while (true) {\n      c=dec.get();\n      if (c==-1) error(\"unexpected EOF\");\n      if (c==0) {\n        state=COMMENT;\n        return true;\n      }\n      if (filename) filename-\u003eput(c);\n    }\n  }\n  else if (c==255) {  // end of block found\n    state=BLOCK;\n    return false;\n  }\n  else\n    error(\"missing segment or end of block\");\n  return false;\n}","filepath":"libzpaq.cpp","line_number":2278,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4197056":{"score":0.70620215,"function_name":"Decompresser::readComment","code":"void Decompresser::readComment(Writer* comment) {\n  assert(state==COMMENT);\n  state=DATA;\n  while (true) {\n    int c=dec.get();\n    if (c==-1) error(\"unexpected EOF\");\n    if (c==0) break;\n    if (comment) comment-\u003eput(c);\n  }\n  if (dec.get()!=0) error(\"missing reserved byte\");\n}","filepath":"libzpaq.cpp","line_number":2302,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4197520":{"score":0.84941924,"function_name":"Decompresser::readSegmentEnd","code":"void Decompresser::readSegmentEnd(char* sha1string) {\n  assert(state==DATA || state==SEGEND);\n\n  // Skip remaining data if any and get next byte\n  int c=0;\n  if (state==DATA) {\n    c=dec.skip();\n    decode_state=SKIP;\n  }\n  else if (state==SEGEND)\n    c=dec.get();\n  state=FILENAME;\n\n  // Read checksum\n  if (c==254) {\n    if (sha1string) sha1string[0]=0;  // no checksum\n  }\n  else if (c==253) {\n    if (sha1string) sha1string[0]=1;\n    for (int i=1; i\u003c=20; ++i) {\n      c=dec.get();\n      if (sha1string) sha1string[i]=c;\n    }\n  }\n  else\n    error(\"missing end of segment marker\");\n}","filepath":"libzpaq.cpp","line_number":2348,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4198080":{"score":0.69809484,"function_name":"Encoder::encode","code":"void Encoder::encode(int y, int p) {\n  assert(out);\n  assert(p\u003e=0 \u0026\u0026 p\u003c65536);\n  assert(y==0 || y==1);\n  assert(high\u003elow \u0026\u0026 low\u003e0);\n  U32 mid=low+U32(((high-low)*U64(U32(p)))\u003e\u003e16);  // split range\n  assert(high\u003emid \u0026\u0026 mid\u003e=low);\n  if (y) high=mid; else low=mid+1; // pick half\n  while ((high^low)\u003c0x1000000) { // write identical leading bytes\n    out-\u003eput(high\u003e\u003e24);  // same as low\u003e\u003e24\n    high=high\u003c\u003c8|255;\n    low=low\u003c\u003c8;\n    low+=(low==0); // so we don't code 4 0 bytes in a row\n  }\n}","filepath":"libzpaq.cpp","line_number":2402,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4198208":{"score":0.89050007,"function_name":"Compiler::next","code":"void Compiler::next() {\n  assert(in);\n  for (; *in; ++in) {\n    if (*in=='\\n') ++line;\n    if (*in=='(') state+=1+(state\u003c0);\n    else if (state\u003e0 \u0026\u0026 *in==')') --state;\n    else if (state\u003c0 \u0026\u0026 *in\u003c=' ') state=0;\n    else if (state==0 \u0026\u0026 *in\u003e' ') {state=-1; break;}\n  }\n  if (!*in) error(\"unexpected end of config\");\n}","filepath":"libzpaq.cpp","line_number":2494,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4198496":{"score":0.7569852,"function_name":"Compiler::syntaxError","code":"void Compiler::syntaxError(const char* msg, const char* expected) {\n  Array\u003cchar\u003e sbuf(128);  // error message to report\n  char* s=\u0026sbuf[0];\n  strcat(s, \"Config line \");\n  for (int i=strlen(s), r=1000000; r; r/=10)  // append line number\n    if (line/r) s[i++]='0'+line/r%10;\n  strcat(s, \" at \");\n  for (int i=strlen(s); i\u003c40 \u0026\u0026 *in\u003e' '; ++i)  // append token found\n    s[i]=*in++;\n  strcat(s, \": \");\n  strncat(s, msg, 40);  // append message\n  if (expected) {\n    strcat(s, \", expected: \");\n    strncat(s, expected, 20);  // append expected token if any\n  }\n  error(s);\n}","filepath":"libzpaq.cpp","line_number":2518,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4199328":{"score":0.84513384,"function_name":"Compiler::rtoken","code":"int Compiler::rtoken(int low, int high) {\n  next();\n  int r=0;\n  if (in[0]=='$' \u0026\u0026 in[1]\u003e='1' \u0026\u0026 in[1]\u003c='9') {\n    if (in[2]=='+') r=atoi(in+3);\n    if (args) r+=args[in[1]-'1'];\n  }\n  else if (in[0]=='-' || (in[0]\u003e='0' \u0026\u0026 in[0]\u003c='9')) r=atoi(in);\n  else syntaxError(\"expected a number\");\n  if (r\u003clow) syntaxError(\"number too low\");\n  if (r\u003ehigh) syntaxError(\"number too high\");\n  return r;\n}","filepath":"libzpaq.cpp","line_number":2559,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4199568":{"score":0.6903709,"function_name":"Compiler::rtoken","code":"int Compiler::rtoken(const char* list[]) {\n  assert(in);\n  assert(list);\n  next();\n  for (int i=0; list[i]; ++i)\n    if (matchToken(list[i]))\n      return i;\n  syntaxError(\"unexpected\");\n  assert(0);\n  return -1; // not reached\n}","filepath":"libzpaq.cpp","line_number":2538,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4199968":{"score":0.8954672,"function_name":"Compiler::rtoken","code":"int Compiler::rtoken(int low, int high) {\n  next();\n  int r=0;\n  if (in[0]=='$' \u0026\u0026 in[1]\u003e='1' \u0026\u0026 in[1]\u003c='9') {\n    if (in[2]=='+') r=atoi(in+3);\n    if (args) r+=args[in[1]-'1'];\n  }\n  else if (in[0]=='-' || (in[0]\u003e='0' \u0026\u0026 in[0]\u003c='9')) r=atoi(in);\n  else syntaxError(\"expected a number\");\n  if (r\u003clow) syntaxError(\"number too low\");\n  if (r\u003ehigh) syntaxError(\"number too high\");\n  return r;\n}","filepath":"libzpaq.cpp","line_number":2559,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4200224":{"score":0.70101714,"function_name":"Compiler::compile_comp","code":"int Compiler::compile_comp(ZPAQL\u0026 z) {\n  int op=0;\n  const int comp_begin=z.hend;\n  while (true) {\n    op=rtoken(opcodelist);\n    if (op==POST || op==PCOMP || op==END) break;\n    int operand=-1; // 0...255 if 2 bytes\n    int operand2=-1;  // 0...255 if 3 bytes\n    if (op==IF) {\n      op=JF;\n      operand=0; // set later\n      if_stack.push(z.hend+1); // save jump target location\n    }\n    else if (op==IFNOT) {\n      op=JT;\n      operand=0;\n      if_stack.push(z.hend+1); // save jump target location\n    }\n    else if (op==IFL || op==IFNOTL) {  // long if\n      if (op==IFL) z.header[z.hend++]=(JT);\n      if (op==IFNOTL) z.header[z.hend++]=(JF);\n      z.header[z.hend++]=(3);\n      op=LJ;\n      operand=operand2=0;\n      if_stack.push(z.hend+1);\n    }\n    else if (op==ELSE || op==ELSEL) {\n      if (op==ELSE) op=JMP, operand=0;\n      if (op==ELSEL) op=LJ, operand=operand2=0;\n      int a=if_stack.pop();  // conditional jump target location\n      assert(a\u003ecomp_begin \u0026\u0026 a\u003cint(z.hend));\n      if (z.header[a-1]!=LJ) {  // IF, IFNOT\n        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);\n        int j=z.hend-a+1+(op==LJ); // offset at IF\n        assert(j\u003e=0);\n        if (j\u003e127) syntaxError(\"IF too big, try IFL, IFNOTL\");\n        z.header[a]=j;\n      }\n      else {  // IFL, IFNOTL\n        int j=z.hend-comp_begin+2+(op==LJ);\n        assert(j\u003e=0);\n        z.header[a]=j\u0026255;\n        z.header[a+1]=(j\u003e\u003e8)\u0026255;\n      }\n      if_stack.push(z.hend+1);  // save JMP target location\n    }\n    else if (op==ENDIF) {\n      int a=if_stack.pop();  // jump target address\n      assert(a\u003ecomp_begin \u0026\u0026 a\u003cint(z.hend));\n      int j=z.hend-a-1;  // jump offset\n      assert(j\u003e=0);\n      if (z.header[a-1]!=LJ) {\n        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);\n        if (j\u003e127) syntaxError(\"IF too big, try IFL, IFNOTL, ELSEL\\n\");\n        z.header[a]=j;\n      }\n      else {\n        assert(a+1\u003cint(z.hend));\n        j=z.hend-comp_begin;\n        z.header[a]=j\u0026255;\n        z.header[a+1]=(j\u003e\u003e8)\u0026255;\n      }\n    }\n    else if (op==DO) {\n      do_stack.push(z.hend);\n    }\n    else if (op==WHILE || op==UNTIL || op==FOREVER) {\n      int a=do_stack.pop();\n      assert(a\u003e=comp_begin \u0026\u0026 a\u003cint(z.hend));\n      int j=a-z.hend-2;\n      assert(j\u003c=-2);\n      if (j\u003e=-127) {  // backward short jump\n        if (op==WHILE) op=JT;\n        if (op==UNTIL) op=JF;\n        if (op==FOREVER) op=JMP;\n        operand=j\u0026255;\n      }\n      else {  // backward long jump\n        j=a-comp_begin;\n        assert(j\u003e=0 \u0026\u0026 j\u003cint(z.hend)-comp_begin);\n        if (op==WHILE) {\n          z.header[z.hend++]=(JF);\n          z.header[z.hend++]=(3);\n        }\n        if (op==UNTIL) {\n          z.header[z.hend++]=(JT);\n          z.header[z.hend++]=(3);\n        }\n        op=LJ;\n        operand=j\u0026255;\n        operand2=j\u003e\u003e8;\n      }\n    }\n    else if ((op\u00267)==7) { // 2 byte operand, read N\n      if (op==LJ) {\n        operand=rtoken(0, 65535);\n        operand2=operand\u003e\u003e8;\n        operand\u0026=255;\n      }\n      else if (op==JT || op==JF || op==JMP) {\n        operand=rtoken(-128, 127);\n        operand\u0026=255;\n      }\n      else\n        operand=rtoken(0, 255);\n    }\n    if (op\u003e=0 \u0026\u0026 op\u003c=255)\n      z.header[z.hend++]=(op);\n    if (operand\u003e=0)\n      z.header[z.hend++]=(operand);\n    if (operand2\u003e=0)\n      z.header[z.hend++]=(operand2);\n    if (z.hend\u003e=z.header.isize()-130 || z.hend-z.hbegin+z.cend-2\u003e65535)\n      syntaxError(\"program too big\");\n  }\n  z.header[z.hend++]=(0); // END\n  return op;\n}","filepath":"libzpaq.cpp","line_number":2575,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4202032":{"score":0.75642055,"function_name":"Compiler::Compiler","code":"Compiler::Compiler(const char* in_, int* args_, ZPAQL\u0026 hz_, ZPAQL\u0026 pz_,\n                   Writer* out2_): in(in_), args(args_), hz(hz_), pz(pz_),\n                   out2(out2_), if_stack(1000), do_stack(1000) {\n  line=1;\n  state=0;\n  hz.clear();\n  pz.clear();\n  hz.header.resize(68000); \n\n  // Compile the COMP section of header\n  rtoken(\"comp\");\n  hz.header[2]=rtoken(0, 255);  // hh\n  hz.header[3]=rtoken(0, 255);  // hm\n  hz.header[4]=rtoken(0, 255);  // ph\n  hz.header[5]=rtoken(0, 255);  // pm\n  const int n=hz.header[6]=rtoken(0, 255);  // n\n  hz.cend=7;\n  for (int i=0; i\u003cn; ++i) {\n    rtoken(i, i);\n    CompType type=CompType(rtoken(compname));\n    hz.header[hz.cend++]=type;\n    int clen=libzpaq::compsize[type\u0026255];\n    if (clen\u003c1 || clen\u003e10) syntaxError(\"invalid component\");\n    for (int j=1; j\u003cclen; ++j)\n      hz.header[hz.cend++]=rtoken(0, 255);  // component arguments\n  }\n  hz.header[hz.cend++];  // end\n  hz.hbegin=hz.hend=hz.cend+128;\n\n  // Compile HCOMP\n  rtoken(\"hcomp\");\n  int op=compile_comp(hz);\n\n  // Compute header size\n  int hsize=hz.cend-2+hz.hend-hz.hbegin;\n  hz.header[0]=hsize\u0026255;\n  hz.header[1]=hsize\u003e\u003e8;\n\n  // Compile POST 0 END\n  if (op==POST) {\n    rtoken(0, 0);\n    rtoken(\"end\");\n  }\n\n  // Compile PCOMP pcomp_cmd ; program... END\n  else if (op==PCOMP) {\n    pz.header.resize(68000);\n    pz.header[4]=hz.header[4];  // ph\n    pz.header[5]=hz.header[5];  // pm\n    pz.cend=8;\n    pz.hbegin=pz.hend=pz.cend+128;\n\n    // get pcomp_cmd ending with \";\" (case sensitive)\n    next();\n    while (*in \u0026\u0026 *in!=';') {\n      if (out2)\n        out2-\u003eput(*in);\n      ++in;\n    }\n    if (*in) ++in;\n\n    // Compile PCOMP\n    op=compile_comp(pz);\n    int len=pz.cend-2+pz.hend-pz.hbegin;  // insert header size\n    assert(len\u003e=0);\n    pz.header[0]=len\u0026255;\n    pz.header[1]=len\u003e\u003e8;\n    if (op!=END)\n      syntaxError(\"expected END\");\n  }\n  else if (op!=END)\n    syntaxError(\"expected END or POST 0 END or PCOMP cmd ; ... END\");\n}","filepath":"libzpaq.cpp","line_number":2698,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4203632":{"score":0.77385914,"function_name":"Compressor::writeTag","code":"void Compressor::writeTag() {\n  assert(state==INIT);\n  enc.out-\u003eput(0x37);\n  enc.out-\u003eput(0x6b);\n  enc.out-\u003eput(0x53);\n  enc.out-\u003eput(0x74);\n  enc.out-\u003eput(0xa0);\n  enc.out-\u003eput(0x31);\n  enc.out-\u003eput(0x83);\n  enc.out-\u003eput(0xd3);\n  enc.out-\u003eput(0x8c);\n  enc.out-\u003eput(0xb2);\n  enc.out-\u003eput(0x28);\n  enc.out-\u003eput(0xb0);\n  enc.out-\u003eput(0xd3);\n}","filepath":"libzpaq.cpp","line_number":2776,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4203872":{"score":0.6619214,"function_name":"ZPAQL::read","code":"int ZPAQL::read(Reader* in2) {\n\n  // Get header size and allocate\n  int hsize=in2-\u003eget();\n  hsize+=in2-\u003eget()*256;\n  header.resize(hsize+300);\n  cend=hbegin=hend=0;\n  header[cend++]=hsize\u0026255;\n  header[cend++]=hsize\u003e\u003e8;\n  while (cend\u003c7) header[cend++]=in2-\u003eget(); // hh hm ph pm n\n\n  // Read COMP\n  int n=header[cend-1];\n  for (int i=0; i\u003cn; ++i) {\n    int type=in2-\u003eget();  // component type\n    if (type\u003c0 || type\u003e255) error(\"unexpected end of file\");\n    header[cend++]=type;  // component type\n    int size=compsize[type];\n    if (size\u003c1) error(\"Invalid component type\");\n    if (cend+size\u003ehsize) error(\"COMP overflows header\");\n    for (int j=1; j\u003csize; ++j)\n      header[cend++]=in2-\u003eget();\n  }\n  if ((header[cend++]=in2-\u003eget())!=0) error(\"missing COMP END\");\n\n  // Insert a guard gap and read HCOMP\n  hbegin=hend=cend+128;\n  if (hend\u003ehsize+129) error(\"missing HCOMP\");\n  while (hend\u003chsize+129) {\n    assert(hend\u003cheader.isize()-8);\n    int op=in2-\u003eget();\n    if (op==-1) error(\"unexpected end of file\");\n    header[hend++]=op;\n  }\n  if ((header[hend++]=in2-\u003eget())!=0) error(\"missing HCOMP END\");\n  assert(cend\u003e=7 \u0026\u0026 cend\u003cheader.isize());\n  assert(hbegin==cend+128 \u0026\u0026 hbegin\u003cheader.isize());\n  assert(hend\u003ehbegin \u0026\u0026 hend\u003cheader.isize());\n  assert(hsize==header[0]+256*header[1]);\n  assert(hsize==cend-2+hend-hbegin);\n  allocx(rcode, rcode_size, 0);  // clear JIT code\n  return cend+hend-hbegin;\n}","filepath":"libzpaq.cpp","line_number":887,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4204720":{"score":0.812647,"function_name":"Compressor::startBlock","code":"void Compressor::startBlock(int level) {\n\n  // Model 1 - min.cfg\n  static const char models[]={\n  26,0,1,2,0,0,2,3,16,8,19,0,0,96,4,28,\n  59,10,59,112,25,10,59,10,59,112,56,0,\n\n  // Model 2 - mid.cfg\n  69,0,3,3,0,0,8,3,5,8,13,0,8,17,1,8,\n  18,2,8,18,3,8,19,4,4,22,24,7,16,0,7,24,\n  (char)-1,0,17,104,74,4,95,1,59,112,10,25,59,112,10,25,\n  59,112,10,25,59,112,10,25,59,112,10,25,59,10,59,112,\n  25,69,(char)-49,8,112,56,0,\n\n  // Model 3 - max.cfg\n  (char)-60,0,5,9,0,0,22,1,(char)-96,3,5,8,13,1,8,16,\n  2,8,18,3,8,19,4,8,19,5,8,20,6,4,22,24,\n  3,17,8,19,9,3,13,3,13,3,13,3,14,7,16,0,\n  15,24,(char)-1,7,8,0,16,10,(char)-1,6,0,15,16,24,0,9,\n  8,17,32,(char)-1,6,8,17,18,16,(char)-1,9,16,19,32,(char)-1,6,\n  0,19,20,16,0,0,17,104,74,4,95,2,59,112,10,25,\n  59,112,10,25,59,112,10,25,59,112,10,25,59,112,10,25,\n  59,10,59,112,10,25,59,112,10,25,69,(char)-73,32,(char)-17,64,47,\n  14,(char)-25,91,47,10,25,60,26,48,(char)-122,(char)-105,20,112,63,9,70,\n  (char)-33,0,39,3,25,112,26,52,25,25,74,10,4,59,112,25,\n  10,4,59,112,25,10,4,59,112,25,65,(char)-113,(char)-44,72,4,59,\n  112,8,(char)-113,(char)-40,8,68,(char)-81,60,60,25,69,(char)-49,9,112,25,25,\n  25,25,25,112,56,0,\n\n  0,0}; // 0,0 = end of list\n\n  if (level\u003c1) error(\"compression level must be at least 1\");\n  const char* p=models;\n  int i;\n  for (i=1; i\u003clevel \u0026\u0026 toU16(p); ++i)\n    p+=toU16(p)+2;\n  if (toU16(p)\u003c1) error(\"compression level too high\");\n  startBlock(p);\n}","filepath":"libzpaq.cpp","line_number":2793,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4204880":{"score":0.6802385,"function_name":"Compressor::startBlock","code":"void Compressor::startBlock(const char* config, int* args, Writer* pcomp_cmd) {\n  assert(state==INIT);\n  Compiler(config, args, z, pz, pcomp_cmd);\n  pz.sha1=\u0026sha1;\n  assert(z.header.isize()\u003e6);\n  enc.out-\u003eput('z');\n  enc.out-\u003eput('P');\n  enc.out-\u003eput('Q');\n  enc.out-\u003eput(1+(z.header[6]==0));  // level 1 or 2\n  enc.out-\u003eput(1);\n  z.write(enc.out, false);\n  state=BLOCK1;\n}","filepath":"libzpaq.cpp","line_number":2856,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4205120":{"score":0.7927313,"function_name":"Compressor::startSegment","code":"void Compressor::startSegment(const char* filename, const char* comment) {\n  assert(state==BLOCK1 || state==BLOCK2);\n  enc.out-\u003eput(1);\n  while (filename \u0026\u0026 *filename)\n    enc.out-\u003eput(*filename++);\n  enc.out-\u003eput(0);\n  while (comment \u0026\u0026 *comment)\n    enc.out-\u003eput(*comment++);\n  enc.out-\u003eput(0);\n  enc.out-\u003eput(0);\n  if (state==BLOCK1) state=SEG1;\n  if (state==BLOCK2) state=SEG2;\n}","filepath":"libzpaq.cpp","line_number":2871,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4205392":{"score":0.5734514,"function_name":"ZPAQL::assemble","code":"int ZPAQL::assemble() {\n\n  // x86? (not foolproof)\n  const int S=sizeof(char*);      // 4 = x86, 8 = x86-64\n  U32 t=0x12345678;\n  if (*(char*)\u0026t!=0x78 || (S!=4 \u0026\u0026 S!=8))\n    error(\"JIT supported only for x86-32 and x86-64\");\n\n  const U8* hcomp=\u0026header[hbegin];\n  const int hlen=hend-hbegin+2;\n  const int msize=m.size();\n  const int hsize=h.size();\n  static const int regcode[8]={2,6,7,5}; // a,b,c,d.. -\u003e edx,esi,edi,ebp,eax..\n  Array\u003cint\u003e it(hlen);            // hcomp -\u003e rcode locations\n  int done=0;  // number of instructions assembled (0..hlen)\n  int o=5;  // rcode output index, reserve space for jmp\n\n  // Code for the halt instruction (restore registers and return)\n  const int halt=o;\n  if (S==8) {\n    put2l(0x48b9, \u0026a);        // mov rcx, a\n    put2(0x8911);             // mov [rcx], edx\n    put2l(0x48b9, \u0026b);        // mov rcx, b\n    put2(0x8931);             // mov [rcx], esi\n    put2l(0x48b9, \u0026c);        // mov rcx, c\n    put2(0x8939);             // mov [rcx], edi\n    put2l(0x48b9, \u0026d);        // mov rcx, d\n    put2(0x8929);             // mov [rcx], ebp\n    put2l(0x48b9, \u0026f);        // mov rcx, f\n    put2(0x8919);             // mov [rcx], ebx\n    put4(0x4883c408);         // add rsp, 8\n    put2(0x415f);             // pop r15\n    put2(0x415e);             // pop r14\n    put2(0x415d);             // pop r13\n    put2(0x415c);             // pop r12\n  }\n  else {\n    put2a(0x8915, \u0026a);        // mov [a], edx\n    put2a(0x8935, \u0026b);        // mov [b], esi\n    put2a(0x893d, \u0026c);        // mov [c], edi\n    put2a(0x892d, \u0026d);        // mov [d], ebp\n    put2a(0x891d, \u0026f);        // mov [f], ebx\n    put3(0x83c40c);           // add esp, 12\n  }\n  put1(0x5b);                 // pop ebx\n  put1(0x5f);                 // pop edi\n  put1(0x5e);                 // pop esi\n  put1(0x5d);                 // pop ebp\n  put1(0xc3);                 // ret\n\n  // Code for the out instruction.\n  // Store a=edx at outbuf[bufptr++]. If full, call flush1().\n  const int outlabel=o;\n  if (S==8) {\n    put2l(0x48b8, \u0026outbuf[0]);// mov rax, outbuf.p\n    put2l(0x49ba, \u0026bufptr);   // mov r10, \u0026bufptr\n    put3(0x418b0a);           // mov rcx, [r10]\n    put3(0x881408);           // mov [rax+rcx], dl\n    put2(0xffc1);             // inc rcx\n    put3(0x41890a);           // mov [r10], ecx\n    put2a(0x81f9, outbuf.size());  // cmp rcx, outbuf.size()\n    put2(0x7403);             // jz L1\n    put2(0x31c0);             // xor eax, eax\n    put1(0xc3);               // ret\n\n    put1(0x55);               // L1: push rbp ; call flush1(this)\n    put1(0x57);               // push rdi\n    put1(0x56);               // push rsi\n    put1(0x52);               // push rdx\n    put1(0x51);               // push rcx\n    put3(0x4889e5);           // mov rbp, rsp\n    put4(0x4883c570);         // add rbp, 112\n#if defined(unix) \u0026\u0026 !defined(__CYGWIN__)\n    put2l(0x48bf, this);      // mov rdi, this\n#else  // Windows\n    put2l(0x48b9, this);      // mov rcx, this\n#endif\n    put2l(0x49bb, \u0026flush1);   // mov r11, \u0026flush1\n    put3(0x41ffd3);           // call r11\n    put1(0x59);               // pop rcx\n    put1(0x5a);               // pop rdx\n    put1(0x5e);               // pop rsi\n    put1(0x5f);               // pop rdi\n    put1(0x5d);               // pop rbp\n  }\n  else {\n    put1a(0xb8, \u0026outbuf[0]);  // mov eax, outbuf.p\n    put2a(0x8b0d, \u0026bufptr);   // mov ecx, [bufptr]\n    put3(0x881408);           // mov [eax+ecx], dl\n    put2(0xffc1);             // inc ecx\n    put2a(0x890d, \u0026bufptr);   // mov [bufptr], ecx\n    put2a(0x81f9, outbuf.size());  // cmp ecx, outbuf.size()\n    put2(0x7403);             // jz L1\n    put2(0x31c0);             // xor eax, eax\n    put1(0xc3);               // ret\n    put3(0x83ec0c);           // L1: sub esp, 12\n    put4(0x89542404);         // mov [esp+4], edx\n    put3a(0xc70424, this);    // mov [esp], this\n    put1a(0xb8, \u0026flush1);     // mov eax, \u0026flush1\n    put2(0xffd0);             // call eax\n    put4(0x8b542404);         // mov edx, [esp+4]\n    put3(0x83c40c);           // add esp, 12\n  }\n  put1(0xc3);               // ret\n\n  // Set it[i]=1 for each ZPAQL instruction reachable from the previous\n  // instruction + 2 if reachable by a jump (or 3 if both).\n  it[0]=2;\n  assert(hlen\u003e0 \u0026\u0026 hcomp[hlen-1]==0);  // ends with error\n  do {\n    done=0;\n    const int NONE=0x80000000;\n    for (int i=0; i\u003chlen; ++i) {\n      int op=hcomp[i];\n      if (it[i]) {\n        int next1=i+oplen(hcomp+i), next2=NONE; // next and jump targets\n        if (iserr(op)) next1=NONE;  // error\n        if (op==56) next1=NONE, next2=0;  // halt\n        if (op==255) next1=NONE, next2=hcomp[i+1]+256*hcomp[i+2]; // lj\n        if (op==39||op==47||op==63)next2=i+2+(hcomp[i+1]\u003c\u003c24\u003e\u003e24);// jt,jf,jmp\n        if (op==63) next1=NONE;  // jmp\n        if ((next2\u003c0 || next2\u003e=hlen) \u0026\u0026 next2!=NONE) next2=hlen-1; // error\n        if (next1\u003e=0 \u0026\u0026 next1\u003chlen \u0026\u0026 !(it[next1]\u00261)) it[next1]|=1, ++done;\n        if (next2\u003e=0 \u0026\u0026 next2\u003chlen \u0026\u0026 !(it[next2]\u00262)) it[next2]|=2, ++done;\n      }\n    }\n  } while (done\u003e0);\n\n  // Set it[i] bits 2-3 to 4, 8, or 12 if a comparison\n  //  (==, \u003c, \u003e respectively) does not need to save the result in f,\n  // or if a conditional jump (jt, jf) does not need to read f.\n  // This is true if a comparison is followed directly by a jt/jf,\n  // the jt/jf is not a jump target, the byte before is not a jump\n  // target (for a 2 byte comparison), and for the comparison instruction\n  // if both paths after the jt/jf lead to another comparison or error\n  // before another jt/jf. At most hlen steps are traced because after\n  // that it must be an infinite loop.\n  for (int i=0; i\u003chlen; ++i) {\n    const int op1=hcomp[i]; // 216..239 = comparison\n    const int i2=i+1+(op1%8==7);  // address of next instruction\n    const int op2=hcomp[i2];  // 39,47 = jt,jf\n    if (it[i] \u0026\u0026 op1\u003e=216 \u0026\u0026 op1\u003c240 \u0026\u0026 (op2==39 || op2==47)\n        \u0026\u0026 it[i2]==1 \u0026\u0026 (i2==i+1 || it[i+1]==0)) {\n      int code=(op1-208)/8*4; // 4,8,12 is ==,\u003c,\u003e\n      it[i2]+=code;  // OK to test CF, ZF instead of f\n      for (int j=0; j\u003c2 \u0026\u0026 code; ++j) {  // trace each path from i2\n        int k=i2+2; // branch not taken\n        if (j==1) k=i2+2+(hcomp[i2+1]\u003c\u003c24\u003e\u003e24);  // branch taken\n        for (int l=0; l\u003chlen \u0026\u0026 code; ++l) {  // trace at most hlen steps\n          if (k\u003c0 || k\u003e=hlen) break;  // out of bounds, pass\n          const int op=hcomp[k];\n          if (op==39 || op==47) code=0;  // jt,jf, fail\n          else if (op\u003e=216 \u0026\u0026 op\u003c240) break;  // ==,\u003c,\u003e, pass\n          else if (iserr(op)) break;  // error, pass\n          else if (op==255) k=hcomp[k+1]+256*hcomp[k+2]; // lj\n          else if (op==63) k=k+2+(hcomp[k+1]\u003c\u003c24\u003e\u003e24);  // jmp\n          else if (op==56) k=0;  // halt\n          else k=k+1+(op%8==7);  // ordinary instruction\n        }\n      }\n      it[i]+=code;  // if \u003e 0 then OK to not save flags in f (bl)\n    }\n  }\n\n  // Start of run(): Save x86 and load ZPAQL registers\n  const int start=o;\n  assert(start\u003e=16);\n  put1(0x55);          // push ebp/rbp\n  put1(0x56);          // push esi/rsi\n  put1(0x57);          // push edi/rdi\n  put1(0x53);          // push ebx/rbx\n  if (S==8) {\n    put2(0x4154);      // push r12\n    put2(0x4155);      // push r13\n    put2(0x4156);      // push r14\n    put2(0x4157);      // push r15\n    put4(0x4883ec08);  // sub rsp, 8\n    put2l(0x48b8, \u0026a); // mov rax, a\n    put2(0x8b10);      // mov edx, [rax]\n    put2l(0x48b8, \u0026b); // mov rax, b\n    put2(0x8b30);      // mov esi, [rax]\n    put2l(0x48b8, \u0026c); // mov rax, c\n    put2(0x8b38);      // mov edi, [rax]\n    put2l(0x48b8, \u0026d); // mov rax, d\n    put2(0x8b28);      // mov ebp, [rax]\n    put2l(0x48b8, \u0026f); // mov rax, f\n    put2(0x8b18);      // mov ebx, [rax]\n    put2l(0x49bc, \u0026h[0]);   // mov r12, h\n    put2l(0x49bd, \u0026outbuf[0]); // mov r13, outbuf.p\n    put2l(0x49be, \u0026r[0]);   // mov r14, r\n    put2l(0x49bf, \u0026m[0]);   // mov r15, m\n  }\n  else {\n    put3(0x83ec0c);    // sub esp, 12\n    put2a(0x8b15, \u0026a); // mov edx, [a]\n    put2a(0x8b35, \u0026b); // mov esi, [b]\n    put2a(0x8b3d, \u0026c); // mov edi, [c]\n    put2a(0x8b2d, \u0026d); // mov ebp, [d]\n    put2a(0x8b1d, \u0026f); // mov ebx, [f]\n  }\n\n  // Assemble in multiple passes until every byte of hcomp has a translation\n  for (int istart=0; istart\u003chlen; ++istart) {\n    int inc=0;\n    for (int i=istart; i\u003chlen \u0026\u0026 it[i]; i+=inc) {\n      const int code=it[i];\n      inc=oplen(hcomp+i);\n\n      // If already assembled, then assemble a jump to it\n      U32 t;\n      assert(it.isize()\u003ei);\n      assert(i\u003e=0 \u0026\u0026 i\u003chlen);\n      if (code\u003e=16) {\n        if (i\u003eistart) {\n          int a=code-o;\n          if (a\u003e-120 \u0026\u0026 a\u003c120)\n            put2(0xeb00+((a-2)\u0026255)); // jmp short o\n          else\n            put1a(0xe9, a-5);  // jmp near o\n        }\n        break;\n      }\n\n      // Else assemble the instruction at hcomp[i] to rcode[o]\n      else {\n        assert(i\u003e=0 \u0026\u0026 i\u003cit.isize());\n        assert(it[i]\u003e0 \u0026\u0026 it[i]\u003c16);\n        assert(o\u003e=16);\n        it[i]=o;\n        ++done;\n        const int op=hcomp[i];\n        const int arg=hcomp[i+1]+((op==255)?256*hcomp[i+2]:0);\n        const int ddd=op/8%8;\n        const int sss=op%8;\n\n        // error instruction: return 1\n        if (iserr(op)) {\n          put1a(0xb8, 1);         // mov eax, 1\n          put1a(0xe9, halt-o-4);  // jmp near halt\n          continue;\n        }\n\n        // Load source *b, *c, *d, or hash (*b) into eax except:\n        // {a,b,c,d}=*d, a{+,-,*,\u0026,|,^,=,==,\u003e,\u003e}=*d: load address to eax\n        // {a,b,c,d}={*b,*c}: load source into ddd\n        if (op==59 || (op\u003e=64 \u0026\u0026 op\u003c240 \u0026\u0026 op%8\u003e=4 \u0026\u0026 op%8\u003c7)) {\n          put2(0x89c0+8*regcode[sss-3+(op==59)]);  // mov eax, {esi,edi,ebp}\n          const int sz=(sss==6?hsize:msize)-1;\n          if (sz\u003e=128) put1a(0x25, sz);            // and eax, dword msize-1\n          else put3(0x83e000+sz);                  // and eax, byte msize-1\n          const int move=(op\u003e=64 \u0026\u0026 op\u003c112); // = or else ddd is eax\n          if (sss\u003c6) { // ddd={a,b,c,d,*b,*c}\n            if (S==8) put5(0x410fb604+8*move*regcode[ddd],0x07);\n                                                   // movzx ddd, byte [r15+rax]\n            else put3a(0x0fb680+8*move*regcode[ddd], \u0026m[0]);\n                                                   // movzx ddd, byte [m+eax]\n          }\n          else if ((0x06587000\u003e\u003e(op/8))\u00261) {// {*b,*c,*d,a/,a%,a\u0026~,a\u003c\u003c,a\u003e\u003e}=*d\n            if (S==8) put4(0x418b0484);            // mov eax, [r12+rax*4]\n            else put3a(0x8b0485, \u0026h[0]);           // mov eax, [h+eax*4]\n          }\n        }\n\n        // Load destination address *b, *c, *d or hashd (*d) into ecx\n        if ((op\u003e=32 \u0026\u0026 op\u003c56 \u0026\u0026 op%8\u003c5) || (op\u003e=96 \u0026\u0026 op\u003c120) || op==60) {\n          put2(0x89c1+8*regcode[op/8%8-3-(op==60)]);// mov ecx,{esi,edi,ebp}\n          const int sz=(ddd==6||op==60?hsize:msize)-1;\n          if (sz\u003e=128) put2a(0x81e1, sz);   // and ecx, dword sz\n          else put3(0x83e100+sz);           // and ecx, byte sz\n          if (op/8%8==6 || op==60) { // *d\n            if (S==8) put4(0x498d0c8c);     // lea rcx, [r12+rcx*4]\n            else put3a(0x8d0c8d, \u0026h[0]);    // lea ecx, [ecx*4+h]\n          }\n          else { // *b, *c\n            if (S==8) put4(0x498d0c0f);     // lea rcx, [r15+rcx]\n            else put2a(0x8d89, \u0026m[0]);      // lea ecx, [ecx+h]\n          }\n        }\n\n        // Translate by opcode\n        switch((op/8)\u002631) {\n          case 0:  // ddd = a\n          case 1:  // ddd = b\n          case 2:  // ddd = c\n          case 3:  // ddd = d\n            switch(sss) {\n              case 0:  // ddd\u003c\u003ea (swap)\n                put2(0x87d0+regcode[ddd]);   // xchg edx, ddd\n                break;\n              case 1:  // ddd++\n                put3(0x83c000+256*regcode[ddd]+inc); // add ddd, inc\n                break;\n              case 2:  // ddd--\n                put3(0x83e800+256*regcode[ddd]+inc); // sub ddd, inc\n                break;\n              case 3:  // ddd!\n                put2(0xf7d0+regcode[ddd]);   // not ddd\n                break;\n              case 4:  // ddd=0\n                put2(0x31c0+9*regcode[ddd]); // xor ddd,ddd\n                break;\n              case 7:  // ddd=r n\n                if (S==8)\n                  put3a(0x418b86+8*regcode[ddd], arg*4); // mov ddd, [r14+n*4]\n                else\n                  put2a(0x8b05+8*regcode[ddd], (\u0026r[arg]));//mov ddd, [r+n]\n                break;\n            }\n            break;\n          case 4:  // ddd = *b\n          case 5:  // ddd = *c\n            switch(sss) {\n              case 0:  // ddd\u003c\u003ea (swap)\n                put2(0x8611);                // xchg dl, [ecx]\n                break;\n              case 1:  // ddd++\n                put3(0x800100+inc);          // add byte [ecx], inc\n                break;\n              case 2:  // ddd--\n                put3(0x802900+inc);          // sub byte [ecx], inc\n                break;\n              case 3:  // ddd!\n                put2(0xf611);                // not byte [ecx]\n                break;\n              case 4:  // ddd=0\n                put2(0x31c0);                // xor eax, eax\n                put2(0x8801);                // mov [ecx], al\n                break;\n              case 7:  // jt, jf\n              {\n                assert(code\u003e=0 \u0026\u0026 code\u003c16);\n                static const unsigned char jtab[2][4]={{5,4,2,7},{4,5,3,6}};\n                               // jnz,je,jb,ja, jz,jne,jae,jbe\n                if (code\u003c4) put2(0x84db);    // test bl, bl\n                if (arg\u003e=128 \u0026\u0026 arg-257-i\u003e=0 \u0026\u0026 o-it[arg-257-i]\u003c120)\n                  put2(0x7000+256*jtab[op==47][code/4]); // jx short 0\n                else\n                  put2a(0x0f80+jtab[op==47][code/4], 0); // jx near 0\n                break;\n              }\n            }\n            break;\n          case 6:  // ddd = *d\n            switch(sss) {\n              case 0:  // ddd\u003c\u003ea (swap)\n                put2(0x8711);             // xchg edx, [ecx]\n                break;\n              case 1:  // ddd++\n                put3(0x830100+inc);       // add dword [ecx], inc\n                break;\n              case 2:  // ddd--\n                put3(0x832900+inc);       // sub dword [ecx], inc\n                break;\n              case 3:  // ddd!\n                put2(0xf711);             // not dword [ecx]\n                break;\n              case 4:  // ddd=0\n                put2(0x31c0);             // xor eax, eax\n                put2(0x8901);             // mov [ecx], eax\n                break;\n              case 7:  // ddd=r n\n                if (S==8)\n                  put3a(0x418996, arg*4); // mov [r14+n*4], edx\n                else\n                  put2a(0x8915, \u0026r[arg]); // mov [r+n], edx\n                break;\n            }\n            break;\n          case 7:  // special\n            switch(op) {\n              case 56: // halt\n                put2(0x31c0);             // xor eax, eax  ; return 0\n                put1a(0xe9, halt-o-4);    // jmp near halt\n                break;\n              case 57:  // out\n                put1a(0xe8, outlabel-o-4);// call outlabel\n                put3(0x83f800);           // cmp eax, 0  ; returned error code\n                put2(0x7405);             // je L1:\n                put1a(0xe9, halt-o-4);    // jmp near halt ; L1:\n                break;\n              case 59:  // hash: a = (a + *b + 512) * 773\n                put3a(0x8d8410, 512);     // lea edx, [eax+edx+512]\n                put2a(0x69d0, 773);       // imul edx, eax, 773\n                break;\n              case 60:  // hashd: *d = (*d + a + 512) * 773\n                put2(0x8b01);             // mov eax, [ecx]\n                put3a(0x8d8410, 512);     // lea eax, [eax+edx+512]\n                put2a(0x69c0, 773);       // imul eax, eax, 773\n                put2(0x8901);             // mov [ecx], eax\n                break;\n              case 63:  // jmp\n                put1a(0xe9, 0);           // jmp near 0 (fill in target later)\n                break;\n            }\n            break;\n          case 8:   // a=\n          case 9:   // b=\n          case 10:  // c=\n          case 11:  // d=\n            if (sss==7)  // n\n              put1a(0xb8+regcode[ddd], arg);         // mov ddd, n\n            else if (sss==6) { // *d\n              if (S==8)\n                put4(0x418b0484+(regcode[ddd]\u003c\u003c11)); // mov ddd, [r12+rax*4]\n              else\n                put3a(0x8b0485+(regcode[ddd]\u003c\u003c11),\u0026h[0]);// mov ddd, [h+eax*4]\n            }\n            else if (sss\u003c4) // a, b, c, d\n              put2(0x89c0+regcode[ddd]+8*regcode[sss]);// mov ddd,sss\n            break;\n          case 12:  // *b=\n          case 13:  // *c=\n            if (sss==7) put3(0xc60100+arg);          // mov byte [ecx], n\n            else if (sss==0) put2(0x8811);           // mov byte [ecx], dl\n            else {\n              if (sss\u003c4) put2(0x89c0+8*regcode[sss]);// mov eax, sss\n              put2(0x8801);                          // mov byte [ecx], al\n            }\n            break;\n          case 14:  // *d=\n            if (sss\u003c7) put2(0x8901+8*regcode[sss]);  // mov [ecx], sss\n            else put2a(0xc701, arg);                 // mov dword [ecx], n\n            break;\n          case 15: break; // not used\n          case 16:  // a+=\n            if (sss==6) {\n              if (S==8) put4(0x41031484);            // add edx, [r12+rax*4]\n              else put3a(0x031485, \u0026h[0]);           // add edx, [h+eax*4]\n            }\n            else if (sss\u003c7) put2(0x01c2+8*regcode[sss]);// add edx, sss\n            else if (arg\u003e=128) put2a(0x81c2, arg);   // add edx, n\n            else put3(0x83c200+arg);                 // add edx, byte n\n            break;\n          case 17:  // a-=\n            if (sss==6) {\n              if (S==8) put4(0x412b1484);            // sub edx, [r12+rax*4]\n              else put3a(0x2b1485, \u0026h[0]);           // sub edx, [h+eax*4]\n            }\n            else if (sss\u003c7) put2(0x29c2+8*regcode[sss]);// sub edx, sss\n            else if (arg\u003e=128) put2a(0x81ea, arg);   // sub edx, n\n            else put3(0x83ea00+arg);                 // sub edx, byte n\n            break;\n          case 18:  // a*=\n            if (sss==6) {\n              if (S==8) put5(0x410faf14,0x84);       // imul edx, [r12+rax*4]\n              else put4a(0x0faf1485, \u0026h[0]);         // imul edx, [h+eax*4]\n            }\n            else if (sss\u003c7) put3(0x0fafd0+regcode[sss]);// imul edx, sss\n            else if (arg\u003e=128) put2a(0x69d2, arg);   // imul edx, n\n            else put3(0x6bd200+arg);                 // imul edx, byte n\n            break;\n          case 19:  // a/=\n          case 20:  // a%=\n            if (sss\u003c7) put2(0x89c1+8*regcode[sss]);  // mov ecx, sss\n            else put1a(0xb9, arg);                   // mov ecx, n\n            put2(0x85c9);                            // test ecx, ecx\n            put3(0x0f44d1);                          // cmovz edx, ecx\n            put2(0x7408-2*(op/8==20));               // jz (over rest)\n            put2(0x89d0);                            // mov eax, edx\n            put2(0x31d2);                            // xor edx, edx\n            put2(0xf7f1);                            // div ecx\n            if (op/8==19) put2(0x89c2);              // mov edx, eax\n            break;\n          case 21:  // a\u0026=\n            if (sss==6) {\n              if (S==8) put4(0x41231484);            // and edx, [r12+rax*4]\n              else put3a(0x231485, \u0026h[0]);           // and edx, [h+eax*4]\n            }\n            else if (sss\u003c7) put2(0x21c2+8*regcode[sss]);// and edx, sss\n            else if (arg\u003e=128) put2a(0x81e2, arg);   // and edx, n\n            else put3(0x83e200+arg);                 // and edx, byte n\n            break;\n          case 22:  // a\u0026~\n            if (sss==7) {\n              if (arg\u003c128) put3(0x83e200+(~arg\u0026255));// and edx, byte ~n\n              else put2a(0x81e2, ~arg);              // and edx, ~n\n            }\n            else {\n              if (sss\u003c4) put2(0x89c0+8*regcode[sss]);// mov eax, sss\n              put2(0xf7d0);                          // not eax\n              put2(0x21c2);                          // and edx, eax\n            }\n            break;\n          case 23:  // a|=\n            if (sss==6) {\n              if (S==8) put4(0x410b1484);            // or edx, [r12+rax*4]\n              else put3a(0x0b1485, \u0026h[0]);           // or edx, [h+eax*4]\n            }\n            else if (sss\u003c7) put2(0x09c2+8*regcode[sss]);// or edx, sss\n            else if (arg\u003e=128) put2a(0x81ca, arg);   // or edx, n\n            else put3(0x83ca00+arg);                 // or edx, byte n\n            break;\n          case 24:  // a^=\n            if (sss==6) {\n              if (S==8) put4(0x41331484);            // xor edx, [r12+rax*4]\n              else put3a(0x331485, \u0026h[0]);           // xor edx, [h+eax*4]\n            }\n            else if (sss\u003c7) put2(0x31c2+8*regcode[sss]);// xor edx, sss\n            else if (arg\u003e=128) put2a(0x81f2, arg);   // xor edx, byte n\n            else put3(0x83f200+arg);                 // xor edx, n\n            break;\n          case 25:  // a\u003c\u003c=\n          case 26:  // a\u003e\u003e=\n            if (sss==7)  // sss = n\n              put3(0xc1e200+8*256*(op/8==26)+arg);   // shl/shr n\n            else {\n              put2(0x89c1+8*regcode[sss]);           // mov ecx, sss\n              put2(0xd3e2+8*(op/8==26));             // shl/shr edx, cl\n            }\n            break;\n          case 27:  // a==\n          case 28:  // a\u003c\n          case 29:  // a\u003e\n            if (sss==6) {\n              if (S==8) put4(0x413b1484);            // cmp edx, [r12+rax*4]\n              else put3a(0x3b1485, \u0026h[0]);           // cmp edx, [h+eax*4]\n            }\n            else if (sss==7)  // sss = n\n              put2a(0x81fa, arg);                    // cmp edx, dword n\n            else\n              put2(0x39c2+8*regcode[sss]);           // cmp edx, sss\n            if (code\u003c4) {\n              if (op/8==27) put3(0x0f94c3);          // setz bl\n              if (op/8==28) put3(0x0f92c3);          // setc bl\n              if (op/8==29) put3(0x0f97c3);          // seta bl\n            }\n            break;\n          case 30:  // not used\n          case 31:  // 255 = lj\n            if (op==255) put1a(0xe9, 0);             // jmp near\n            break;\n        }\n      }\n    }\n  }\n\n  // Finish first pass\n  const int rsize=o;\n  if (o\u003ercode_size) return rsize;\n\n  // Fill in jump addresses (second pass)\n  for (int i=0; i\u003chlen; ++i) {\n    if (it[i]\u003c16) continue;\n    int op=hcomp[i];\n    if (op==39 || op==47 || op==63 || op==255) {  // jt, jf, jmp, lj\n      int target=hcomp[i+1];\n      if (op==255) target+=hcomp[i+2]*256;  // lj\n      else {\n        if (target\u003e=128) target-=256;\n        target+=i+2;\n      }\n      if (target\u003c0 || target\u003e=hlen) target=hlen-1;  // runtime ZPAQL error\n      o=it[i];\n      assert(o\u003e=16 \u0026\u0026 o\u003crcode_size);\n      if ((op==39 || op==47) \u0026\u0026 rcode[o]==0x84) o+=2;  // jt, jf -\u003e skip test\n      assert(o\u003e=16 \u0026\u0026 o\u003crcode_size);\n      if (rcode[o]==0x0f) ++o;  // first byte of jz near, jnz near\n      assert(o\u003crcode_size);\n      op=rcode[o++];  // x86 opcode\n      target=it[target]-o;\n      if ((op\u003e=0x72 \u0026\u0026 op\u003c0x78) || op==0xeb) {  // jx, jmp short\n        --target;\n        if (target\u003c-128 || target\u003e127)\n          error(\"Cannot code x86 short jump\");\n        assert(o\u003crcode_size);\n        rcode[o]=target\u0026255;\n      }\n      else if ((op\u003e=0x82 \u0026\u0026 op\u003c0x88) || op==0xe9) // jx, jmp near\n      {\n        target-=4;\n        puta(target);\n      }\n      else assert(false);  // not a x86 jump\n    }\n  }\n\n  // Jump to start\n  o=0;\n  put1a(0xe9, start-5);  // jmp near start\n  return rsize;\n}","filepath":"libzpaq.cpp","line_number":3231,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4249280":{"score":0.65197915,"function_name":"Predictor::predict","code":"int Predictor::predict() {\n#ifdef NOJIT\n  return predict0();\n#else\n  if (!pcode) {\n    allocx(pcode, pcode_size, (z.cend*100+4096)\u0026-4096);\n    int n=assemble_p();\n    if (n\u003epcode_size) {\n      allocx(pcode, pcode_size, n);\n      n=assemble_p();\n    }\n    if (!pcode || n\u003c15 || pcode_size\u003c15)\n      error(\"run JIT failed\");\n  }\n  assert(pcode \u0026\u0026 pcode[0]);\n  return ((int(*)(Predictor*))\u0026pcode[10])(this);\n#endif\n}","filepath":"libzpaq.cpp","line_number":4589,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4249744":{"score":0.8516787,"function_name":"ZPAQL::run","code":"void ZPAQL::run(U32 input) {\n#ifdef NOJIT\n  run0(input);\n#else\n  if (!rcode) {\n    allocx(rcode, rcode_size, (hend*10+4096)\u0026-4096);\n    int n=assemble();\n    if (n\u003ercode_size) {\n      allocx(rcode, rcode_size, n);\n      n=assemble();\n    }\n    if (!rcode || n\u003c10 || rcode_size\u003c10)\n      error(\"run JIT failed\");\n  }\n  a=input;\n  const U32 rc=((int(*)())(\u0026rcode[0]))();\n  if (rc==0) return;\n  else if (rc==1) libzpaq::error(\"Bad ZPAQL opcode\");\n  else if (rc==2) libzpaq::error(\"Out of memory\");\n  else if (rc==3) libzpaq::error(\"Write error\");\n  else libzpaq::error(\"ZPAQL execution error\");\n#endif\n}","filepath":"libzpaq.cpp","line_number":4634,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4251744":{"score":0.68100935,"function_name":"Predictor::update","code":"void Predictor::update(int y) {\n#ifdef NOJIT\n  update0(y);\n#else\n  assert(pcode \u0026\u0026 pcode[5]);\n  ((void(*)(Predictor*, int))\u0026pcode[5])(this, y);\n\n  // Save bit y in c8, hmap4 (not implemented in JIT)\n  c8+=c8+y;\n  if (c8\u003e=256) {\n    z.run(c8-256);\n    hmap4=1;\n    c8=1;\n    for (int i=0; i\u003cz.header[6]; ++i) h[i]=z.H(i);\n  }\n  else if (c8\u003e=16 \u0026\u0026 c8\u003c32)\n    hmap4=(hmap4\u00260xf)\u003c\u003c5|y\u003c\u003c4|1;\n  else\n    hmap4=(hmap4\u00260x1f0)|(((hmap4\u00260xf)*2+y)\u00260xf);\n#endif\n}","filepath":"libzpaq.cpp","line_number":4610,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4251968":{"score":0.69255924,"function_name":"Decoder::decompress","code":"int Decoder::decompress() {\n  if (pr.isModeled()) {  // n\u003e0 components?\n    if (curr==0) {  // segment initialization\n      for (int i=0; i\u003c4; ++i)\n        curr=curr\u003c\u003c8|get();\n    }\n    if (decode(0)) {\n      if (curr!=0) error(\"decoding end of stream\");\n      return -1;\n    }\n    else {\n      int c=1;\n      while (c\u003c256) {  // get 8 bits\n        int p=pr.predict()*2+1;\n        c+=c+decode(p);\n        pr.update(c\u00261);\n      }\n      return c-256;\n    }\n  }\n  else {\n    if (curr==0) {\n      for (int i=0; i\u003c4; ++i) curr=curr\u003c\u003c8|get();\n      if (curr==0) return -1;\n    }\n    --curr;\n    return get();\n  }\n}","filepath":"libzpaq.cpp","line_number":2127,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4254096":{"score":0.8068443,"function_name":"Encoder::compress","code":"void Encoder::compress(int c) {\n  assert(out);\n  if (pr.isModeled()) {\n    if (c==-1)\n      encode(1, 0);\n    else {\n      assert(c\u003e=0 \u0026\u0026 c\u003c=255);\n      encode(0, 0);\n      for (int i=7; i\u003e=0; --i) {\n        int p=pr.predict()*2+1;\n        assert(p\u003e0 \u0026\u0026 p\u003c65536);\n        int y=c\u003e\u003ei\u00261;\n        encode(y, p);\n        pr.update(y);\n      }\n    }\n  }\n  else {\n    if (low \u0026\u0026 (c\u003c0 || low==buf.size())) {\n      out-\u003eput((low\u003e\u003e24)\u0026255);\n      out-\u003eput((low\u003e\u003e16)\u0026255);\n      out-\u003eput((low\u003e\u003e8)\u0026255);\n      out-\u003eput(low\u0026255);\n      out-\u003ewrite(\u0026buf[0], low);\n      low=0;\n    }\n    if (c\u003e=0) buf[low++]=c;\n  }\n}","filepath":"libzpaq.cpp","line_number":2419,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4254624":{"score":0.8675255,"function_name":"divsufsort","code":"int\ndivsufsort(const unsigned char *T, int *SA, int n) {\n  int *bucket_A, *bucket_B;\n  int m;\n  int err = 0;\n\n  /* Check arguments. */\n  if((T == NULL) || (SA == NULL) || (n \u003c 0)) { return -1; }\n  else if(n == 0) { return 0; }\n  else if(n == 1) { SA[0] = 0; return 0; }\n  else if(n == 2) { m = (T[0] \u003c T[1]); SA[m ^ 1] = 0, SA[m] = 1; return 0; }\n\n  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));\n  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));\n\n  /* Suffixsort. */\n  if((bucket_A != NULL) \u0026\u0026 (bucket_B != NULL)) {\n    m = sort_typeBstar(T, SA, bucket_A, bucket_B, n);\n    construct_SA(T, SA, bucket_A, bucket_B, n, m);\n  } else {\n    err = -2;\n  }\n\n  free(bucket_B);\n  free(bucket_A);\n\n  return err;\n}","filepath":"libzpaq.cpp","line_number":6370,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4255296":{"score":0.8763849,"function_name":"divbwt","code":"int\ndivbwt(const unsigned char *T, unsigned char *U, int *A, int n) {\n  int *B;\n  int *bucket_A, *bucket_B;\n  int m, pidx, i;\n\n  /* Check arguments. */\n  if((T == NULL) || (U == NULL) || (n \u003c 0)) { return -1; }\n  else if(n \u003c= 1) { if(n == 1) { U[0] = T[0]; } return n; }\n\n  if((B = A) == NULL) { B = (int *)malloc((size_t)(n + 1) * sizeof(int)); }\n  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));\n  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));\n\n  /* Burrows-Wheeler Transform. */\n  if((B != NULL) \u0026\u0026 (bucket_A != NULL) \u0026\u0026 (bucket_B != NULL)) {\n    m = sort_typeBstar(T, B, bucket_A, bucket_B, n);\n    pidx = construct_BWT(T, B, bucket_A, bucket_B, n, m);\n\n    /* Copy to output string. */\n    U[0] = T[n - 1];\n    for(i = 0; i \u003c pidx; ++i) { U[i + 1] = (unsigned char)B[i]; }\n    for(i += 1; i \u003c n; ++i) { U[i] = (unsigned char)B[i]; }\n    pidx += 1;\n  } else {\n    pidx = -2;\n  }\n\n  free(bucket_B);\n  free(bucket_A);\n  if(A == NULL) { free(B); }\n\n  return pidx;\n}","filepath":"libzpaq.cpp","line_number":6399,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4258016":{"score":0.8913131,"function_name":"e8e9","code":"void e8e9(unsigned char* buf, int n) {\n  for (int i=n-5; i\u003e=0; --i) {\n    if (((buf[i]\u0026254)==0xe8) \u0026\u0026 ((buf[i+4]+1)\u0026254)==0) {\n      unsigned a=(buf[i+1]|buf[i+2]\u003c\u003c8|buf[i+3]\u003c\u003c16)+i;\n      buf[i+1]=a;\n      buf[i+2]=a\u003e\u003e8;\n      buf[i+3]=a\u003e\u003e16;\n    }\n  }\n}","filepath":"libzpaq.cpp","line_number":6450,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4258128":{"score":0.77515274,"function_name":"lg","code":"int lg(unsigned x) {\n  unsigned r=0;\n  if (x\u003e=65536) r=16, x\u003e\u003e=16;\n  if (x\u003e=256) r+=8, x\u003e\u003e=8;\n  if (x\u003e=16) r+=4, x\u003e\u003e=4;\n  assert(x\u003e=0 \u0026\u0026 x\u003c16);\n  return\n    \"\\x00\\x01\\x02\\x02\\x03\\x03\\x03\\x03\\x04\\x04\\x04\\x04\\x04\\x04\\x04\\x04\"[x]+r;\n}","filepath":"libzpaq.cpp","line_number":6566,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4258256":{"score":0.7015949,"function_name":"LZBuffer::LZBuffer","code":"LZBuffer::LZBuffer(StringBuffer\u0026 inbuf, int args[], const unsigned* sap):\n    ht((args[1]\u00263)==3 ? (inbuf.size()+1)*!sap      // for BWT suffix array\n        : args[5]-args[0]\u003c21 ? 1u\u003c\u003cargs[5]         // for LZ77 hash table\n        : (inbuf.size()*!sap)+(1u\u003c\u003c17\u003c\u003cargs[0])),  // for LZ77 SA and ISA\n    in(inbuf.data()),\n    checkbits(args[5]-args[0]\u003c21 ? 12-args[0] : 17+args[0]),\n    level(args[1]\u00263),\n    htsize(ht.size()),\n    n(inbuf.size()),\n    i(0),\n    minMatch(args[2]),\n    minMatch2(args[3]),\n    maxMatch(BUFSIZE*3),\n    maxLiteral(BUFSIZE/4),\n    lookahead(args[6]),\n    h1(0), h2(0),\n    bucket((1\u003c\u003cargs[4])-1), \n    shift1(minMatch\u003e0 ? (args[5]-1)/minMatch+1 : 1),\n    shift2(minMatch2\u003e0 ? (args[5]-1)/minMatch2+1 : 0),\n    minMatchBoth(MAX(minMatch, minMatch2+lookahead)+4),\n    rb(args[0]\u003e4 ? args[0]-4 : 0),\n    bits(0), nbits(0), rpos(0), wpos(0),\n    idx(0), sa(0), isa(0) {\n  assert(args[0]\u003e=0);\n  assert(n\u003c=(1u\u003c\u003c20\u003c\u003cargs[0]));\n  assert(args[1]\u003e=1 \u0026\u0026 args[1]\u003c=7 \u0026\u0026 args[1]!=4);\n  assert(level\u003e=1 \u0026\u0026 level\u003c=3);\n  if ((minMatch\u003c4 \u0026\u0026 level==1) || (minMatch\u003c1 \u0026\u0026 level==2))\n    error(\"match length $3 too small\");\n\n  // e8e9 transform\n  if (args[1]\u003e4 \u0026\u0026 !sap) e8e9(inbuf.data(), n);\n\n  // build suffix array if not supplied\n  if (args[5]-args[0]\u003e=21 || level==3) {  // LZ77-SA or BWT\n    if (sap)\n      sa=sap;\n    else {\n      assert(ht.size()\u003e=n);\n      assert(ht.size()\u003e0);\n      sa=\u0026ht[0];\n      if (n\u003e0) divsufsort((const unsigned char*)in, (int*)sa, n);\n    }\n    if (level\u003c3) {\n      assert(ht.size()\u003e=(n*(sap==0))+(1u\u003c\u003c17\u003c\u003cargs[0]));\n      isa=\u0026ht[n*(sap==0)];\n    }\n  }\n}","filepath":"libzpaq.cpp","line_number":6596,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4258992":{"score":0.7470186,"function_name":"LZBuffer::write_literal","code":"void LZBuffer::write_literal(unsigned i, unsigned\u0026 lit) {\n  assert(lit\u003e=0);\n  assert(i\u003e=0 \u0026\u0026 i\u003c=n);\n  assert(i\u003e=lit);\n  if (level==1) {\n    if (lit\u003c1) return;\n    int ll=lg(lit);\n    assert(ll\u003e=1 \u0026\u0026 ll\u003c=24);\n    putb(0, 2);\n    --ll;\n    while (--ll\u003e=0) {\n      putb(1, 1);\n      putb((lit\u003e\u003ell)\u00261, 1);\n    }\n    putb(0, 1);\n    while (lit) putb(in[i-lit--], 8);\n  }\n  else {\n    assert(level==2);\n    while (lit\u003e0) {\n      unsigned lit1=lit;\n      if (lit1\u003e64) lit1=64;\n      put(lit1-1);\n      for (unsigned j=i-lit; j\u003ci-lit+lit1; ++j) put(in[j]);\n      lit-=lit1;\n    }\n  }\n}","filepath":"libzpaq.cpp","line_number":6797,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4259760":{"score":0.7482786,"function_name":"LZBuffer::write_match","code":"void LZBuffer::write_match(unsigned len, unsigned off) {\n\n  // mm,mmm,n,ll,r,q[mmmmm-8] = match n*4+ll, offset ((q-1)\u003c\u003crb)+r+1\n  if (level==1) {\n    assert(len\u003e=minMatch \u0026\u0026 len\u003c=maxMatch);\n    assert(off\u003e0);\n    assert(len\u003e=4);\n    assert(rb\u003e=0 \u0026\u0026 rb\u003c=8);\n    int ll=lg(len)-1;\n    assert(ll\u003e=2);\n    off+=(1\u003c\u003crb)-1;\n    int lo=lg(off)-1-rb;\n    assert(lo\u003e=0 \u0026\u0026 lo\u003c=23);\n    putb((lo+8)\u003e\u003e3, 2);// mm\n    putb(lo\u00267, 3);     // mmm\n    while (--ll\u003e=2) {  // n\n      putb(1, 1);\n      putb((len\u003e\u003ell)\u00261, 1);\n    }\n    putb(0, 1);\n    putb(len\u00263, 2);    // ll\n    putb(off, rb);     // r\n    putb(off\u003e\u003erb, lo); // q\n  }\n\n  // x[2]:len[6] off[x-1] \n  else {\n    assert(level==2);\n    assert(minMatch\u003e=1 \u0026\u0026 minMatch\u003c=64);\n    --off;\n    while (len\u003e0) {  // Split long matches to len1=minMatch..minMatch+63\n      const unsigned len1=len\u003eminMatch*2+63 ? minMatch+63 :\n          len\u003eminMatch+63 ? len-minMatch : len;\n      assert(wpos\u003cBUFSIZE-5);\n      assert(len1\u003e=minMatch \u0026\u0026 len1\u003cminMatch+64);\n      if (off\u003c(1\u003c\u003c16)) {\n        put(64+len1-minMatch);\n        put(off\u003e\u003e8);\n        put(off);\n      }\n      else if (off\u003c(1\u003c\u003c24)) {\n        put(128+len1-minMatch);\n        put(off\u003e\u003e16);\n        put(off\u003e\u003e8);\n        put(off);\n      }\n      else {\n        put(192+len1-minMatch);\n        put(off\u003e\u003e24);\n        put(off\u003e\u003e16);\n        put(off\u003e\u003e8);\n        put(off);\n      }\n      len-=len1;\n    }\n  }\n}","filepath":"libzpaq.cpp","line_number":6827,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4261392":{"score":0.81433594,"function_name":"LZBuffer::fill","code":"void LZBuffer::fill() {\n\n  // BWT\n  if (level==3) {\n    assert(in || n==0);\n    assert(sa);\n    for (; wpos\u003cBUFSIZE \u0026\u0026 i\u003cn+5; ++i) {\n      if (i==0) put(n\u003e0 ? in[n-1] : 255);\n      else if (i\u003en) put(idx\u0026255), idx\u003e\u003e=8;\n      else if (sa[i-1]==0) idx=i, put(255);\n      else put(in[sa[i-1]-1]);\n    }\n    return;\n  }\n\n  // LZ77: scan the input\n  unsigned lit=0;  // number of output literals pending\n  const unsigned mask=(1\u003c\u003ccheckbits)-1;\n  while (i\u003cn \u0026\u0026 wpos*2\u003cBUFSIZE) {\n\n    // Search for longest match, or pick closest in case of tie\n    unsigned blen=minMatch-1;  // best match length\n    unsigned bp=0;  // pointer to best match\n    unsigned blit=0;  // literals before best match\n    int bscore=0;  // best cost\n\n    // Look up contexts in suffix array\n    if (isa) {\n      if (sa[isa[i\u0026mask]]!=i) // rebuild ISA\n        for (unsigned j=0; j\u003cn; ++j)\n          if ((sa[j]\u0026~mask)==(i\u0026~mask))\n            isa[sa[j]\u0026mask]=j;\n      for (unsigned h=0; h\u003c=lookahead; ++h) {\n        unsigned q=isa[(h+i)\u0026mask];  // location of h+i in SA\n        assert(q\u003cn);\n        if (sa[q]!=h+i) continue;\n        for (int j=-1; j\u003c=1; j+=2) {  // search backward and forward\n          for (unsigned k=1; k\u003c=bucket; ++k) {\n            unsigned p;  // match to be tested\n            if (q+j*k\u003cn \u0026\u0026 (p=sa[q+j*k]-h)\u003ci) {\n              assert(p\u003cn);\n              unsigned l, l1;  // length of match, leading literals\n              for (l=h; i+l\u003cn \u0026\u0026 l\u003cmaxMatch \u0026\u0026 in[p+l]==in[i+l]; ++l);\n              for (l1=h; l1\u003e0 \u0026\u0026 in[p+l1-1]==in[i+l1-1]; --l1);\n              int score=int(l-l1)*8-lg(i-p)-4*(lit==0 \u0026\u0026 l1\u003e0)-11;\n              for (unsigned a=0; a\u003ch; ++a) score=score*5/8;\n              if (score\u003ebscore) blen=l, bp=p, blit=l1, bscore=score;\n              if (l\u003cblen || l\u003cminMatch || l\u003e255) break;\n            }\n          }\n        }\n        if (bscore\u003c=0 || blen\u003cminMatch) break;\n      }\n    }\n\n    // Look up contexts in a hash table.\n    // Try the longest context orders first. If a match is found, then\n    // skip the lower order as a speed optimization.\n    else if (level==1 || minMatch\u003c=64) {\n      if (minMatch2\u003e0) {\n        for (unsigned k=0; k\u003c=bucket; ++k) {\n          unsigned p=ht[h2^k];\n          if (p \u0026\u0026 (p\u0026mask)==(in[i+3]\u0026mask)) {\n            p\u003e\u003e=checkbits;\n            if (p\u003ci \u0026\u0026 i+blen\u003c=n \u0026\u0026 in[p+blen-1]==in[i+blen-1]) {\n              unsigned l;  // match length from lookahead\n              for (l=lookahead; i+l\u003cn \u0026\u0026 l\u003cmaxMatch \u0026\u0026 in[p+l]==in[i+l]; ++l);\n              if (l\u003e=minMatch2+lookahead) {\n                int l1;  // length back from lookahead\n                for (l1=lookahead; l1\u003e0 \u0026\u0026 in[p+l1-1]==in[i+l1-1]; --l1);\n                assert(l1\u003e=0 \u0026\u0026 l1\u003c=int(lookahead));\n                int score=int(l-l1)*8-lg(i-p)-8*(lit==0 \u0026\u0026 l1\u003e0)-11;\n                if (score\u003ebscore) blen=l, bp=p, blit=l1, bscore=score;\n              }\n            }\n          }\n          if (blen\u003e=128) break;\n        }\n      }\n\n      // Search the lower order context\n      if (!minMatch2 || blen\u003cminMatch2) {\n        for (unsigned k=0; k\u003c=bucket; ++k) {\n          unsigned p=ht[h1^k];\n          if (p \u0026\u0026 i+3\u003cn \u0026\u0026 (p\u0026mask)==(in[i+3]\u0026mask)) {\n            p\u003e\u003e=checkbits;\n            if (p\u003ci \u0026\u0026 i+blen\u003c=n \u0026\u0026 in[p+blen-1]==in[i+blen-1]) {\n              unsigned l;\n              for (l=0; i+l\u003cn \u0026\u0026 l\u003cmaxMatch \u0026\u0026 in[p+l]==in[i+l]; ++l);\n              int score=l*8-lg(i-p)-2*(lit\u003e0)-11;\n              if (score\u003ebscore) blen=l, bp=p, blit=0, bscore=score;\n            }\n          }\n          if (blen\u003e=128) break;\n        }\n      }\n    }\n\n    // If match is long enough, then output any pending literals first,\n    // and then the match. blen is the length of the match.\n    assert(i\u003e=bp);\n    const unsigned off=i-bp;  // offset\n    if (off\u003e0 \u0026\u0026 bscore\u003e0\n        \u0026\u0026 blen-blit\u003e=minMatch+(level==2)*((off\u003e=(1\u003c\u003c16))+(off\u003e=(1\u003c\u003c24)))) {\n      lit+=blit;\n      write_literal(i+blit, lit);\n      write_match(blen-blit, off);\n    }\n\n    // Otherwise add to literal length\n    else {\n      blen=1;\n      ++lit;\n    }\n\n    // Update index, advance blen bytes\n    if (isa)\n      i+=blen;\n    else {\n      while (blen--) {\n        if (i+minMatchBoth\u003cn) {\n          unsigned ih=((i*1234547)\u003e\u003e19)\u0026bucket;\n          const unsigned p=(i\u003c\u003ccheckbits)|(in[i+3]\u0026mask);\n          assert(ih\u003c=bucket);\n          if (minMatch2) {\n            ht[h2^ih]=p;\n            h2=(((h2*9)\u003c\u003cshift2)\n                +(in[i+minMatch2+lookahead]+1)*23456789u)\u0026(htsize-1);\n          }\n          ht[h1^ih]=p;\n          h1=(((h1*5)\u003c\u003cshift1)+(in[i+minMatch]+1)*123456791u)\u0026(htsize-1);\n        }\n        ++i;\n      }\n    }\n\n    // Write long literals to keep buf from filling up\n    if (lit\u003e=maxLiteral)\n      write_literal(i, lit);\n  }\n\n  // Write pending literals at end of input\n  assert(i\u003c=n);\n  if (i==n) {\n    write_literal(n, lit);\n    flush();\n  }\n}","filepath":"libzpaq.cpp","line_number":6647,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4264272":{"score":0.82913077,"function_name":"LZBuffer::read","code":"int LZBuffer::read(char* p, int n) {\n  if (rpos==wpos) fill();\n  int nr=n;\n  if (nr\u003eint(wpos-rpos)) nr=wpos-rpos;\n  if (nr) memcpy(p, buf+rpos, nr);\n  rpos+=nr;\n  assert(rpos\u003c=wpos);\n  if (rpos==wpos) rpos=wpos=0;\n  return nr;\n}","filepath":"libzpaq.cpp","line_number":6585,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4264400":{"score":0.88046145,"function_name":"ZPAQL::init","code":"void ZPAQL::init(int hbits, int mbits) {\n  assert(header.isize()\u003e0);\n  assert(cend\u003e=7);\n  assert(hbegin\u003e=cend+128);\n  assert(hend\u003e=hbegin);\n  assert(hend\u003cheader.isize()-130);\n  assert(header[0]+256*header[1]==cend-2+hend-hbegin);\n  assert(bufptr==0);\n  assert(outbuf.isize()\u003e0);\n  if (hbits\u003e32) error(\"H too big\");\n  if (mbits\u003e32) error(\"M too big\");\n  h.resize(1, hbits);\n  m.resize(1, mbits);\n  r.resize(256);\n  a=b=c=d=pc=f=0;\n}","filepath":"libzpaq.cpp","line_number":1009,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4264544":{"score":0.622449,"function_name":"ZPAQL::init","code":"void ZPAQL::init(int hbits, int mbits) {\n  assert(header.isize()\u003e0);\n  assert(cend\u003e=7);\n  assert(hbegin\u003e=cend+128);\n  assert(hend\u003e=hbegin);\n  assert(hend\u003cheader.isize()-130);\n  assert(header[0]+256*header[1]==cend-2+hend-hbegin);\n  assert(bufptr==0);\n  assert(outbuf.isize()\u003e0);\n  if (hbits\u003e32) error(\"H too big\");\n  if (mbits\u003e32) error(\"M too big\");\n  h.resize(1, hbits);\n  m.resize(1, mbits);\n  r.resize(256);\n  a=b=c=d=pc=f=0;\n}","filepath":"libzpaq.cpp","line_number":1009,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4264688":{"score":0.6228957,"function_name":"ZPAQL::init","code":"void ZPAQL::init(int hbits, int mbits) {\n  assert(header.isize()\u003e0);\n  assert(cend\u003e=7);\n  assert(hbegin\u003e=cend+128);\n  assert(hend\u003e=hbegin);\n  assert(hend\u003cheader.isize()-130);\n  assert(header[0]+256*header[1]==cend-2+hend-hbegin);\n  assert(bufptr==0);\n  assert(outbuf.isize()\u003e0);\n  if (hbits\u003e32) error(\"H too big\");\n  if (mbits\u003e32) error(\"M too big\");\n  h.resize(1, hbits);\n  m.resize(1, mbits);\n  r.resize(256);\n  a=b=c=d=pc=f=0;\n}","filepath":"libzpaq.cpp","line_number":1009,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4268016":{"score":0.6182682,"function_name":"Compressor::postProcess","code":"void Compressor::postProcess(const char* pcomp, int len) {\n  if (state==SEG2) return;\n  assert(state==SEG1);\n  enc.init();\n  if (!pcomp) {\n    len=pz.hend-pz.hbegin;\n    if (len\u003e0) {\n      assert(pz.header.isize()\u003epz.hend);\n      assert(pz.hbegin\u003e=0);\n      pcomp=(const char*)\u0026pz.header[pz.hbegin];\n    }\n    assert(len\u003e=0);\n  }\n  else if (len==0) {\n    len=toU16(pcomp);\n    pcomp+=2;\n  }\n  if (len\u003e0) {\n    enc.compress(1);\n    enc.compress(len\u0026255);\n    enc.compress((len\u003e\u003e8)\u0026255);\n    for (int i=0; i\u003clen; ++i)\n      enc.compress(pcomp[i]\u0026255);\n    if (verify)\n      pz.initp();\n  }\n  else\n    enc.compress(0);\n  state=SEG2;\n}","filepath":"libzpaq.cpp","line_number":2888,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4268512":{"score":0.7940047,"function_name":"Compressor::compress","code":"bool Compressor::compress(int n) {\n  if (state==SEG1)\n    postProcess();\n  assert(state==SEG2);\n\n  const int BUFSIZE=1\u003c\u003c14;\n  char buf[BUFSIZE];  // input buffer\n  while (n) {\n    int nbuf=BUFSIZE;  // bytes read into buf\n    if (n\u003e=0 \u0026\u0026 n\u003cnbuf) nbuf=n;\n    int nr=in-\u003eread(buf, nbuf);\n    if (nr\u003c0 || nr\u003eBUFSIZE || nr\u003enbuf) error(\"invalid read size\");\n    if (nr\u003c=0) return false;\n    if (n\u003e=0) n-=nr;\n    for (int i=0; i\u003cnr; ++i) {\n      int ch=U8(buf[i]);\n      enc.compress(ch);\n      if (verify) {\n        if (pz.hend) pz.run(ch);\n        else sha1.put(ch);\n      }\n    }\n  }\n  return true;\n}","filepath":"libzpaq.cpp","line_number":2920,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4268928":{"score":0.80378973,"function_name":"Compressor::endSegment","code":"void Compressor::endSegment(const char* sha1string) {\n  if (state==SEG1)\n    postProcess();\n  assert(state==SEG2);\n  enc.compress(-1);\n  if (verify \u0026\u0026 pz.hend) {\n    pz.run(-1);\n    pz.flush();\n  }\n  enc.out-\u003eput(0);\n  enc.out-\u003eput(0);\n  enc.out-\u003eput(0);\n  enc.out-\u003eput(0);\n  if (sha1string) {\n    enc.out-\u003eput(253);\n    for (int i=0; i\u003c20; ++i)\n      enc.out-\u003eput(sha1string[i]);\n  }\n  else\n    enc.out-\u003eput(254);\n  state=BLOCK2;\n}","filepath":"libzpaq.cpp","line_number":2947,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4269264":{"score":0.8153425,"function_name":"Compressor::endSegmentChecksum","code":"char* Compressor::endSegmentChecksum(int64_t* size, bool dosha1) {\n  if (state==SEG1)\n    postProcess();\n  assert(state==SEG2);\n  enc.compress(-1);\n  if (verify \u0026\u0026 pz.hend) {\n    pz.run(-1);\n    pz.flush();\n  }\n  enc.out-\u003eput(0);\n  enc.out-\u003eput(0);\n  enc.out-\u003eput(0);\n  enc.out-\u003eput(0);\n  if (verify) {\n    if (size) *size=sha1.usize();\n    memcpy(sha1result, sha1.result(), 20);\n  }\n  if (verify \u0026\u0026 dosha1) {\n    enc.out-\u003eput(253);\n    for (int i=0; i\u003c20; ++i)\n      enc.out-\u003eput(sha1result[i]);\n  }\n  else\n    enc.out-\u003eput(254);\n  state=BLOCK2;\n  return verify ? sha1result : 0;\n}","filepath":"libzpaq.cpp","line_number":2971,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4269680":{"score":0.80541956,"function_name":"PostProcessor::write","code":"int PostProcessor::write(int c) {\n  assert(c\u003e=-1 \u0026\u0026 c\u003c=255);\n  switch (state) {\n    case 0:  // initial state\n      if (c\u003c0) error(\"Unexpected EOS\");\n      state=c+1;  // 1=PASS, 2=PROG\n      if (state\u003e2) error(\"unknown post processing type\");\n      if (state==1) z.clear();\n      break;\n    case 1:  // PASS\n      z.outc(c);\n      break;\n    case 2: // PROG\n      if (c\u003c0) error(\"Unexpected EOS\");\n      hsize=c;  // low byte of size\n      state=3;\n      break;\n    case 3:  // PROG psize[0]\n      if (c\u003c0) error(\"Unexpected EOS\");\n      hsize+=c*256;  // high byte of psize\n      if (hsize\u003c1) error(\"Empty PCOMP\");\n      z.header.resize(hsize+300);\n      z.cend=8;\n      z.hbegin=z.hend=z.cend+128;\n      z.header[4]=ph;\n      z.header[5]=pm;\n      state=4;\n      break;\n    case 4:  // PROG psize[0..1] pcomp[0...]\n      if (c\u003c0) error(\"Unexpected EOS\");\n      assert(z.hend\u003cz.header.isize());\n      z.header[z.hend++]=c;  // one byte of pcomp\n      if (z.hend-z.hbegin==hsize) {  // last byte of pcomp?\n        hsize=z.cend-2+z.hend-z.hbegin;\n        z.header[0]=hsize\u0026255;  // header size with empty COMP\n        z.header[1]=hsize\u003e\u003e8;\n        z.initp();\n        state=5;\n      }\n      break;\n    case 5:  // PROG ... data\n      z.run(c);\n      if (c\u003c0) z.flush();\n      break;\n  }\n  return state;\n}","filepath":"libzpaq.cpp","line_number":2195,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4270464":{"score":0.84033823,"function_name":"Decompresser::decompress","code":"bool Decompresser::decompress(int n) {\n  assert(state==DATA);\n  if (decode_state==SKIP) error(\"decompression after skipped segment\");\n  assert(decode_state!=SKIP);\n\n  // Initialize models to start decompressing block\n  if (decode_state==FIRSTSEG) {\n    dec.init();\n    assert(z.header.size()\u003e5);\n    pp.init(z.header[4], z.header[5]);\n    decode_state=SEG;\n  }\n\n  // Decompress and load PCOMP into postprocessor\n  while ((pp.getState()\u00263)!=1)\n    pp.write(dec.decompress());\n\n  // Decompress n bytes, or all if n \u003c 0\n  while (n) {\n    int c=dec.decompress();\n    pp.write(c);\n    if (c==-1) {\n      state=SEGEND;\n      return false;\n    }\n    if (n\u003e0) --n;\n  }\n  return true;\n}","filepath":"libzpaq.cpp","line_number":2315,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4282496":{"score":0.7676234,"function_name":"makeConfig","code":"std::string makeConfig(const char* method, int args[]) {\n  assert(method);\n  const char type=method[0];\n  assert(type=='x' || type=='s' || type=='0' || type=='i');\n\n  // Read \"{x|s|i|0}N1,N2...N9\" into args[0..8] ($1..$9)\n  args[0]=0;  // log block size in MiB\n  args[1]=0;  // 0=none, 1=var-LZ77, 2=byte-LZ77, 3=BWT, 4..7 adds E8E9\n  args[2]=0;  // lz77 minimum match length\n  args[3]=0;  // secondary context length\n  args[4]=0;  // log searches\n  args[5]=0;  // lz77 hash table size or SA if args[0]+21\n  args[6]=0;  // secondary context look ahead\n  args[7]=0;  // not used\n  args[8]=0;  // not used\n  if (isdigit(*++method)) args[0]=0;\n  for (int i=0; i\u003c9 \u0026\u0026 (isdigit(*method) || *method==',' || *method=='.');) {\n    if (isdigit(*method))\n      args[i]=args[i]*10+*method-'0';\n    else if (++i\u003c9)\n      args[i]=0;\n    ++method;\n  }\n\n  // \"0...\" = No compression\n  if (type=='0')\n    return \"comp 0 0 0 0 0 hcomp end\\n\";\n\n  // Generate the postprocessor\n  std::string hdr, pcomp;\n  const int level=args[1]\u00263;\n  const bool doe8=args[1]\u003e=4 \u0026\u0026 args[1]\u003c=7;\n\n  // LZ77+Huffman, with or without E8E9\n  if (level==1) {\n    const int rb=args[0]\u003e4 ? args[0]-4 : 0;\n    hdr=\"comp 9 16 0 $1+20 \";\n    pcomp=\n    \"pcomp lazy2 3 ;\\n\"\n    \" (r1 = state\\n\"\n    \"  r2 = len - match or literal length\\n\"\n    \"  r3 = m - number of offset bits expected\\n\"\n    \"  r4 = ptr to buf\\n\"\n    \"  r5 = r - low bits of offset\\n\"\n    \"  c = bits - input buffer\\n\"\n    \"  d = n - number of bits in c)\\n\"\n    \"\\n\"\n    \"  a\u003e 255 if\\n\";\n    if (doe8)\n      pcomp+=\n      \"    b=0 d=r 4 do (for b=0..d-1, d = end of buf)\\n\"\n      \"      a=b a==d ifnot\\n\"\n      \"        a+= 4 a\u003cd if\\n\"\n      \"          a=*b a\u0026= 254 a== 232 if (e8 or e9?)\\n\"\n      \"            c=b b++ b++ b++ b++ a=*b a++ a\u0026= 254 a== 0 if (00 or ff)\\n\"\n      \"              b-- a=*b\\n\"\n      \"              b-- a\u003c\u003c= 8 a+=*b\\n\"\n      \"              b-- a\u003c\u003c= 8 a+=*b\\n\"\n      \"              a-=b a++\\n\"\n      \"              *b=a a\u003e\u003e= 8 b++\\n\"\n      \"              *b=a a\u003e\u003e= 8 b++\\n\"\n      \"              *b=a b++\\n\"\n      \"            endif\\n\"\n      \"            b=c\\n\"\n      \"          endif\\n\"\n      \"        endif\\n\"\n      \"        a=*b out b++\\n\"\n      \"      forever\\n\"\n      \"    endif\\n\"\n      \"\\n\";\n    pcomp+=\n    \"    (reset state)\\n\"\n    \"    a=0 b=0 c=0 d=0 r=a 1 r=a 2 r=a 3 r=a 4\\n\"\n    \"    halt\\n\"\n    \"  endif\\n\"\n    \"\\n\"\n    \"  a\u003c\u003c=d a+=c c=a               (bits+=a\u003c\u003cn)\\n\"\n    \"  a= 8 a+=d d=a                (n+=8)\\n\"\n    \"\\n\"\n    \"  (if state==0 (expect new code))\\n\"\n    \"  a=r 1 a== 0 if (match code mm,mmm)\\n\"\n    \"    a= 1 r=a 2                 (len=1)\\n\"\n    \"    a=c a\u0026= 3 a\u003e 0 if          (if (bits\u00263))\\n\"\n    \"      a-- a\u003c\u003c= 3 r=a 3           (m=((bits\u00263)-1)*8)\\n\"\n    \"      a=c a\u003e\u003e= 2 c=a             (bits\u003e\u003e=2)\\n\"\n    \"      b=r 3 a\u0026= 7 a+=b r=a 3     (m+=bits\u00267)\\n\"\n    \"      a=c a\u003e\u003e= 3 c=a             (bits\u003e\u003e=3)\\n\"\n    \"      a=d a-= 5 d=a              (n-=5)\\n\"\n    \"      a= 1 r=a 1                 (state=1)\\n\"\n    \"    else (literal, discard 00)\\n\"\n    \"      a=c a\u003e\u003e= 2 c=a             (bits\u003e\u003e=2)\\n\"\n    \"      d-- d--                    (n-=2)\\n\"\n    \"      a= 3 r=a 1                 (state=3)\\n\"\n    \"    endif\\n\"\n    \"  endif\\n\"\n    \"\\n\"\n    \"  (while state==1 \u0026\u0026 n\u003e=3 (expect match length n*4+ll -\u003e r2))\\n\"\n    \"  do a=r 1 a== 1 if a=d a\u003e 2 if\\n\"\n    \"    a=c a\u0026= 1 a== 1 if         (if bits\u00261)\\n\"\n    \"      a=c a\u003e\u003e= 1 c=a             (bits\u003e\u003e=1)\\n\"\n    \"      b=r 2 a=c a\u0026= 1 a+=b a+=b r=a 2 (len+=len+(bits\u00261))\\n\"\n    \"      a=c a\u003e\u003e= 1 c=a             (bits\u003e\u003e=1)\\n\"\n    \"      d-- d--                    (n-=2)\\n\"\n    \"    else\\n\"\n    \"      a=c a\u003e\u003e= 1 c=a             (bits\u003e\u003e=1)\\n\"\n    \"      a=r 2 a\u003c\u003c= 2 b=a           (len\u003c\u003c=2)\\n\"\n    \"      a=c a\u0026= 3 a+=b r=a 2       (len+=bits\u00263)\\n\"\n    \"      a=c a\u003e\u003e= 2 c=a             (bits\u003e\u003e=2)\\n\"\n    \"      d-- d-- d--                (n-=3)\\n\";\n    if (rb)\n      pcomp+=\"      a= 5 r=a 1                 (state=5)\\n\";\n    else\n      pcomp+=\"      a= 2 r=a 1                 (state=2)\\n\";\n    pcomp+=\n    \"    endif\\n\"\n    \"  forever endif endif\\n\"\n    \"\\n\";\n    if (rb) pcomp+=  // save r in r5\n      \"  (if state==5 \u0026\u0026 n\u003e=8) (expect low bits of offset to put in r5)\\n\"\n      \"  a=r 1 a== 5 if a=d a\u003e \"+itos(rb-1)+\" if\\n\"\n      \"    a=c a\u0026= \"+itos((1\u003c\u003crb)-1)+\" r=a 5            (save r in r5)\\n\"\n      \"    a=c a\u003e\u003e= \"+itos(rb)+\" c=a\\n\"\n      \"    a=d a-= \"+itos(rb)+ \" d=a\\n\"\n      \"    a= 2 r=a 1                   (go to state 2)\\n\"\n      \"  endif endif\\n\"\n      \"\\n\";\n    pcomp+=\n    \"  (if state==2 \u0026\u0026 n\u003e=m) (expect m offset bits)\\n\"\n    \"  a=r 1 a== 2 if a=r 3 a\u003ed ifnot\\n\"\n    \"    a=c r=a 6 a=d r=a 7          (save c=bits, d=n in r6,r7)\\n\"\n    \"    b=r 3 a= 1 a\u003c\u003c=b d=a         (d=1\u003c\u003cm)\\n\"\n    \"    a-- a\u0026=c a+=d                (d=offset=bits\u0026((1\u003c\u003cm)-1)|(1\u003c\u003cm))\\n\";\n    if (rb)\n      pcomp+=  // insert r into low bits of d\n      \"    a\u003c\u003c= \"+itos(rb)+\" d=r 5 a+=d a-= \"+itos((1\u003c\u003crb)-1)+\"\\n\";\n    pcomp+=\n    \"    d=a b=r 4 a=b a-=d c=a       (c=p=(b=ptr)-offset)\\n\"\n    \"\\n\"\n    \"    (while len-- (copy and output match d bytes from *c to *b))\\n\"\n    \"    d=r 2 do a=d a\u003e 0 if d--\\n\"\n    \"      a=*c *b=a c++ b++          (buf[ptr++]-buf[p++])\\n\";\n    if (!doe8) pcomp+=\" out\\n\";\n    pcomp+=\n    \"    forever endif\\n\"\n    \"    a=b r=a 4\\n\"\n    \"\\n\"\n    \"    a=r 6 b=r 3 a\u003e\u003e=b c=a        (bits\u003e\u003e=m)\\n\"\n    \"    a=r 7 a-=b d=a               (n-=m)\\n\"\n    \"    a=0 r=a 1                    (state=0)\\n\"\n    \"  endif endif\\n\"\n    \"\\n\"\n    \"  (while state==3 \u0026\u0026 n\u003e=2 (expect literal length))\\n\"\n    \"  do a=r 1 a== 3 if a=d a\u003e 1 if\\n\"\n    \"    a=c a\u0026= 1 a== 1 if         (if bits\u00261)\\n\"\n    \"      a=c a\u003e\u003e= 1 c=a              (bits\u003e\u003e=1)\\n\"\n    \"      b=r 2 a\u0026= 1 a+=b a+=b r=a 2 (len+=len+(bits\u00261))\\n\"\n    \"      a=c a\u003e\u003e= 1 c=a              (bits\u003e\u003e=1)\\n\"\n    \"      d-- d--                     (n-=2)\\n\"\n    \"    else\\n\"\n    \"      a=c a\u003e\u003e= 1 c=a              (bits\u003e\u003e=1)\\n\"\n    \"      d--                         (--n)\\n\"\n    \"      a= 4 r=a 1                  (state=4)\\n\"\n    \"    endif\\n\"\n    \"  forever endif endif\\n\"\n    \"\\n\"\n    \"  (if state==4 \u0026\u0026 n\u003e=8 (expect len literals))\\n\"\n    \"  a=r 1 a== 4 if a=d a\u003e 7 if\\n\"\n    \"    b=r 4 a=c *b=a\\n\";\n    if (!doe8) pcomp+=\" out\\n\";\n    pcomp+=\n    \"    b++ a=b r=a 4                 (buf[ptr++]=bits)\\n\"\n    \"    a=c a\u003e\u003e= 8 c=a                (bits\u003e\u003e=8)\\n\"\n    \"    a=d a-= 8 d=a                 (n-=8)\\n\"\n    \"    a=r 2 a-- r=a 2 a== 0 if      (if --len\u003c1)\\n\"\n    \"      a=0 r=a 1                     (state=0)\\n\"\n    \"    endif\\n\"\n    \"  endif endif\\n\"\n    \"  halt\\n\"\n    \"end\\n\";\n  }\n\n  // Byte aligned LZ77, with or without E8E9\n  else if (level==2) {\n    hdr=\"comp 9 16 0 $1+20 \";\n    pcomp=\n    \"pcomp lzpre c ;\\n\"\n    \"  (Decode LZ77: d=state, M=output buffer, b=size)\\n\"\n    \"  a\u003e 255 if (at EOF decode e8e9 and output)\\n\";\n    if (doe8)\n      pcomp+=\n      \"    d=b b=0 do (for b=0..d-1, d = end of buf)\\n\"\n      \"      a=b a==d ifnot\\n\"\n      \"        a+= 4 a\u003cd if\\n\"\n      \"          a=*b a\u0026= 254 a== 232 if (e8 or e9?)\\n\"\n      \"            c=b b++ b++ b++ b++ a=*b a++ a\u0026= 254 a== 0 if (00 or ff)\\n\"\n      \"              b-- a=*b\\n\"\n      \"              b-- a\u003c\u003c= 8 a+=*b\\n\"\n      \"              b-- a\u003c\u003c= 8 a+=*b\\n\"\n      \"              a-=b a++\\n\"\n      \"              *b=a a\u003e\u003e= 8 b++\\n\"\n      \"              *b=a a\u003e\u003e= 8 b++\\n\"\n      \"              *b=a b++\\n\"\n      \"            endif\\n\"\n      \"            b=c\\n\"\n      \"          endif\\n\"\n      \"        endif\\n\"\n      \"        a=*b out b++\\n\"\n      \"      forever\\n\"\n      \"    endif\\n\";\n    pcomp+=\n    \"    b=0 c=0 d=0 a=0 r=a 1 r=a 2 (reset state)\\n\"\n    \"  halt\\n\"\n    \"  endif\\n\"\n    \"\\n\"\n    \"  (in state d==0, expect a new code)\\n\"\n    \"  (put length in r1 and inital part of offset in r2)\\n\"\n    \"  c=a a=d a== 0 if\\n\"\n    \"    a=c a\u003e\u003e= 6 a++ d=a\\n\"\n    \"    a== 1 if (literal?)\\n\"\n    \"      a+=c r=a 1 a=0 r=a 2\\n\"\n    \"    else (3 to 5 byte match)\\n\"\n    \"      d++ a=c a\u0026= 63 a+= $3 r=a 1 a=0 r=a 2\\n\"\n    \"    endif\\n\"\n    \"  else\\n\"\n    \"    a== 1 if (writing literal)\\n\"\n    \"      a=c *b=a b++\\n\";\n    if (!doe8) pcomp+=\" out\\n\";\n    pcomp+=\n    \"      a=r 1 a-- a== 0 if d=0 endif r=a 1 (if (--len==0) state=0)\\n\"\n    \"    else\\n\"\n    \"      a\u003e 2 if (reading offset)\\n\"\n    \"        a=r 2 a\u003c\u003c= 8 a|=c r=a 2 d-- (off=off\u003c\u003c8|c, --state)\\n\"\n    \"      else (state==2, write match)\\n\"\n    \"        a=r 2 a\u003c\u003c= 8 a|=c c=a a=b a-=c a-- c=a (c=i-off-1)\\n\"\n    \"        d=r 1 (d=len)\\n\"\n    \"        do (copy and output d=len bytes)\\n\"\n    \"          a=*c *b=a c++ b++\\n\";\n    if (!doe8) pcomp+=\" out\\n\";\n    pcomp+=\n    \"        d-- a=d a\u003e 0 while\\n\"\n    \"        (d=state=0. off, len don\\'t matter)\\n\"\n    \"      endif\\n\"\n    \"    endif\\n\"\n    \"  endif\\n\"\n    \"  halt\\n\"\n    \"end\\n\";\n  }\n\n  // BWT with or without E8E9\n  else if (level==3) {  // IBWT\n    hdr=\"comp 9 16 $1+20 $1+20 \";  // 2^$1 = block size in MB\n    pcomp=\n    \"pcomp bwtrle c ;\\n\"\n    \"\\n\"\n    \"  (read BWT, index into M, size in b)\\n\"\n    \"  a\u003e 255 ifnot\\n\"\n    \"    *b=a b++\\n\"\n    \"\\n\"\n    \"  (inverse BWT)\\n\"\n    \"  elsel\\n\"\n    \"\\n\"\n    \"    (index in last 4 bytes, put in c and R1)\\n\"\n    \"    b-- a=*b\\n\"\n    \"    b-- a\u003c\u003c= 8 a+=*b\\n\"\n    \"    b-- a\u003c\u003c= 8 a+=*b\\n\"\n    \"    b-- a\u003c\u003c= 8 a+=*b c=a r=a 1\\n\"\n    \"\\n\"\n    \"    (save size in R2)\\n\"\n    \"    a=b r=a 2\\n\"\n    \"\\n\"\n    \"    (count bytes in H[~1..~255, ~0])\\n\"\n    \"    do\\n\"\n    \"      a=b a\u003e 0 if\\n\"\n    \"        b-- a=*b a++ a\u0026= 255 d=a d! *d++\\n\"\n    \"      forever\\n\"\n    \"    endif\\n\"\n    \"\\n\"\n    \"    (cumulative counts: H[~i=0..255] = count of bytes before i)\\n\"\n    \"    d=0 d! *d= 1 a=0\\n\"\n    \"    do\\n\"\n    \"      a+=*d *d=a d--\\n\"\n    \"    d\u003c\u003ea a! a\u003e 255 a! d\u003c\u003ea until\\n\"\n    \"\\n\"\n    \"    (build first part of linked list in H[0..idx-1])\\n\"\n    \"    b=0 do\\n\"\n    \"      a=c a\u003eb if\\n\"\n    \"        d=*b d! *d++ d=*d d-- *d=b\\n\"\n    \"      b++ forever\\n\"\n    \"    endif\\n\"\n    \"\\n\"\n    \"    (rest of list in H[idx+1..n-1])\\n\"\n    \"    b=c b++ c=r 2 do\\n\"\n    \"      a=c a\u003eb if\\n\"\n    \"        d=*b d! *d++ d=*d d-- *d=b\\n\"\n    \"      b++ forever\\n\"\n    \"    endif\\n\"\n    \"\\n\";\n    if (args[0]\u003c=4) {  // faster IBWT list traversal limited to 16 MB blocks\n      pcomp+=\n      \"    (copy M to low 8 bits of H to reduce cache misses in next loop)\\n\"\n      \"    b=0 do\\n\"\n      \"      a=c a\u003eb if\\n\"\n      \"        d=b a=*d a\u003c\u003c= 8 a+=*b *d=a\\n\"\n      \"      b++ forever\\n\"\n      \"    endif\\n\"\n      \"\\n\"\n      \"    (traverse list and output or copy to M)\\n\"\n      \"    d=r 1 b=0 do\\n\"\n      \"      a=d a== 0 ifnot\\n\"\n      \"        a=*d a\u003e\u003e= 8 d=a\\n\";\n      if (doe8) pcomp+=\" *b=*d b++\\n\";\n      else      pcomp+=\" a=*d out\\n\";\n      pcomp+=\n      \"      forever\\n\"\n      \"    endif\\n\"\n      \"\\n\";\n      if (doe8)  // IBWT+E8E9\n        pcomp+=\n        \"    (e8e9 transform to out)\\n\"\n        \"    d=b b=0 do (for b=0..d-1, d = end of buf)\\n\"\n        \"      a=b a==d ifnot\\n\"\n        \"        a+= 4 a\u003cd if\\n\"\n        \"          a=*b a\u0026= 254 a== 232 if\\n\"\n        \"            c=b b++ b++ b++ b++ a=*b a++ a\u0026= 254 a== 0 if\\n\"\n        \"              b-- a=*b\\n\"\n        \"              b-- a\u003c\u003c= 8 a+=*b\\n\"\n        \"              b-- a\u003c\u003c= 8 a+=*b\\n\"\n        \"              a-=b a++\\n\"\n        \"              *b=a a\u003e\u003e= 8 b++\\n\"\n        \"              *b=a a\u003e\u003e= 8 b++\\n\"\n        \"              *b=a b++\\n\"\n        \"            endif\\n\"\n        \"            b=c\\n\"\n        \"          endif\\n\"\n        \"        endif\\n\"\n        \"        a=*b out b++\\n\"\n        \"      forever\\n\"\n        \"    endif\\n\";\n      pcomp+=\n      \"  endif\\n\"\n      \"  halt\\n\"\n      \"end\\n\";\n    }\n    else {  // slower IBWT list traversal for all sized blocks\n      if (doe8) {  // E8E9 after IBWT\n        pcomp+=\n        \"    (R2 = output size without EOS)\\n\"\n        \"    a=r 2 a-- r=a 2\\n\"\n        \"\\n\"\n        \"    (traverse list (d = IBWT pointer) and output inverse e8e9)\\n\"\n        \"    (C = offset = 0..R2-1)\\n\"\n        \"    (R4 = last 4 bytes shifted in from MSB end)\\n\"\n        \"    (R5 = temp pending output byte)\\n\"\n        \"    c=0 d=r 1 do\\n\"\n        \"      a=d a== 0 ifnot\\n\"\n        \"        d=*d\\n\"\n        \"\\n\"\n        \"        (store byte in R4 and shift out to R5)\\n\"\n        \"        b=d a=*b a\u003c\u003c= 24 b=a\\n\"\n        \"        a=r 4 r=a 5 a\u003e\u003e= 8 a|=b r=a 4\\n\"\n        \"\\n\"\n        \"        (if E8|E9 xx xx xx 00|FF in R4:R5 then subtract c from x)\\n\"\n        \"        a=c a\u003e 3 if\\n\"\n        \"          a=r 5 a\u0026= 254 a== 232 if\\n\"\n        \"            a=r 4 a\u003e\u003e= 24 b=a a++ a\u0026= 254 a\u003c 2 if\\n\"\n        \"              a=r 4 a-=c a+= 4 a\u003c\u003c= 8 a\u003e\u003e= 8 \\n\"\n        \"              b\u003c\u003ea a\u003c\u003c= 24 a+=b r=a 4\\n\"\n        \"            endif\\n\"\n        \"          endif\\n\"\n        \"        endif\\n\"\n        \"\\n\"\n        \"        (output buffered byte)\\n\"\n        \"        a=c a\u003e 3 if a=r 5 out endif c++\\n\"\n        \"\\n\"\n        \"      forever\\n\"\n        \"    endif\\n\"\n        \"\\n\"\n        \"    (output up to 4 pending bytes in R4)\\n\"\n        \"    b=r 4\\n\"\n        \"    a=c a\u003e 3 a=b if out endif a\u003e\u003e= 8 b=a\\n\"\n        \"    a=c a\u003e 2 a=b if out endif a\u003e\u003e= 8 b=a\\n\"\n        \"    a=c a\u003e 1 a=b if out endif a\u003e\u003e= 8 b=a\\n\"\n        \"    a=c a\u003e 0 a=b if out endif\\n\"\n        \"\\n\"\n        \"  endif\\n\"\n        \"  halt\\n\"\n        \"end\\n\";\n      }\n      else {\n        pcomp+=\n        \"    (traverse list and output)\\n\"\n        \"    d=r 1 do\\n\"\n        \"      a=d a== 0 ifnot\\n\"\n        \"        d=*d\\n\"\n        \"        b=d a=*b out\\n\"\n        \"      forever\\n\"\n        \"    endif\\n\"\n        \"  endif\\n\"\n        \"  halt\\n\"\n        \"end\\n\";\n      }\n    }\n  }\n\n  // E8E9 or no preprocessing\n  else if (level==0) {\n    hdr=\"comp 9 16 0 0 \";\n    if (doe8) { // E8E9?\n      pcomp=\n      \"pcomp e8e9 d ;\\n\"\n      \"  a\u003e 255 if\\n\"\n      \"    a=c a\u003e 4 if\\n\"\n      \"      c= 4\\n\"\n      \"    else\\n\"\n      \"      a! a+= 5 a\u003c\u003c= 3 d=a a=b a\u003e\u003e=d b=a\\n\"\n      \"    endif\\n\"\n      \"    do a=c a\u003e 0 if\\n\"\n      \"      a=b out a\u003e\u003e= 8 b=a c--\\n\"\n      \"    forever endif\\n\"\n      \"  else\\n\"\n      \"    *b=b a\u003c\u003c= 24 d=a a=b a\u003e\u003e= 8 a+=d b=a c++\\n\"\n      \"    a=c a\u003e 4 if\\n\"\n      \"      a=*b out\\n\"\n      \"      a\u0026= 254 a== 232 if\\n\"\n      \"        a=b a\u003e\u003e= 24 a++ a\u0026= 254 a== 0 if\\n\"\n      \"          a=b a\u003e\u003e= 24 a\u003c\u003c= 24 d=a\\n\"\n      \"          a=b a-=c a+= 5\\n\"\n      \"          a\u003c\u003c= 8 a\u003e\u003e= 8 a|=d b=a\\n\"\n      \"        endif\\n\"\n      \"      endif\\n\"\n      \"    endif\\n\"\n      \"  endif\\n\"\n      \"  halt\\n\"\n      \"end\\n\";\n    }\n    else\n      pcomp=\"end\\n\";\n  }\n  else\n    error(\"Unsupported method\");\n  \n  // Build context model (comp, hcomp) assuming:\n  // H[0..254] = contexts\n  // H[255..511] = location of last byte i-255\n  // M = last 64K bytes, filling backward\n  // C = pointer to most recent byte\n  // R1 = level 2 lz77 1+bytes expected until next code, 0=init\n  // R2 = level 2 lz77 first byte of code\n  int ncomp=0;  // number of components\n  const int membits=args[0]+20;\n  int sb=5;  // bits in last context\n  std::string comp;\n  std::string hcomp=\"hcomp\\n\"\n    \"c-- *c=a a+= 255 d=a *d=c\\n\";\n  if (level==2) {  // put level 2 lz77 parse state in R1, R2\n    hcomp+=\n    \"  (decode lz77 into M. Codes:\\n\"\n    \"  00xxxxxx = literal length xxxxxx+1\\n\"\n    \"  xx......, xx \u003e 0 = match with xx offset bytes to follow)\\n\"\n    \"\\n\"\n    \"  a=r 1 a== 0 if (init)\\n\"\n    \"    a= \"+itos(111+57*doe8)+\" (skip post code)\\n\"\n    \"  else a== 1 if  (new code?)\\n\"\n    \"    a=*c r=a 2  (save code in R2)\\n\"\n    \"    a\u003e 63 if a\u003e\u003e= 6 a++ a++  (match)\\n\"\n    \"    else a++ a++ endif  (literal)\\n\"\n    \"  else (read rest of code)\\n\"\n    \"    a--\\n\"\n    \"  endif endif\\n\"\n    \"  r=a 1  (R1 = 1+expected bytes to next code)\\n\";\n  }\n\n  // Generate the context model\n  while (*method \u0026\u0026 ncomp\u003c254) {\n\n    // parse command C[N1[,N2]...] into v = {C, N1, N2...}\n    std::vector\u003cint\u003e v;\n    v.push_back(*method++);\n    if (isdigit(*method)) {\n      v.push_back(*method++-'0');\n      while (isdigit(*method) || *method==',' || *method=='.') {\n        if (isdigit(*method))\n          v.back()=v.back()*10+*method++-'0';\n        else {\n          v.push_back(0);\n          ++method;\n        }\n      }\n    }\n\n    // c: context model\n    // N1%1000: 0=ICM 1..256=CM limit N1-1\n    // N1/1000: number of times to halve memory\n    // N2: 1..255=offset mod N2. 1000..1255=distance to N2-1000\n    // N3...: 0..255=byte mask + 256=lz77 state. 1000+=run of N3-1000 zeros.\n    if (v[0]=='c') {\n      while (v.size()\u003c3) v.push_back(0);\n      comp+=itos(ncomp)+\" \";\n      sb=11;  // count context bits\n      if (v[2]\u003c256) sb+=lg(v[2]);\n      else sb+=6;\n      for (unsigned i=3; i\u003cv.size(); ++i)\n        if (v[i]\u003c512) sb+=nbits(v[i])*3/4;\n      if (sb\u003emembits) sb=membits;\n      if (v[1]%1000==0) comp+=\"icm \"+itos(sb-6-v[1]/1000)+\"\\n\";\n      else comp+=\"cm \"+itos(sb-2-v[1]/1000)+\" \"+itos(v[1]%1000-1)+\"\\n\";\n\n      // special contexts\n      hcomp+=\"d= \"+itos(ncomp)+\" *d=0\\n\";\n      if (v[2]\u003e1 \u0026\u0026 v[2]\u003c=255) {  // periodic context\n        if (lg(v[2])!=lg(v[2]-1))\n          hcomp+=\"a=c a\u0026= \"+itos(v[2]-1)+\" hashd\\n\";\n        else\n          hcomp+=\"a=c a%= \"+itos(v[2])+\" hashd\\n\";\n      }\n      else if (v[2]\u003e=1000 \u0026\u0026 v[2]\u003c=1255)  // distance context\n        hcomp+=\"a= 255 a+= \"+itos(v[2]-1000)+\n               \" d=a a=*d a-=c a\u003e 255 if a= 255 endif d= \"+\n               itos(ncomp)+\" hashd\\n\";\n\n      // Masked context\n      for (unsigned i=3; i\u003cv.size(); ++i) {\n        if (i==3) hcomp+=\"b=c \";\n        if (v[i]==255)\n          hcomp+=\"a=*b hashd\\n\";  // ordinary byte\n        else if (v[i]\u003e0 \u0026\u0026 v[i]\u003c255)\n          hcomp+=\"a=*b a\u0026= \"+itos(v[i])+\" hashd\\n\";  // masked byte\n        else if (v[i]\u003e=256 \u0026\u0026 v[i]\u003c512) { // lz77 state or masked literal byte\n          hcomp+=\n          \"a=r 1 a\u003e 1 if\\n\"  // expect literal or offset\n          \"  a=r 2 a\u003c 64 if\\n\"  // expect literal\n          \"    a=*b \";\n          if (v[i]\u003c511) hcomp+=\"a\u0026= \"+itos(v[i]-256);\n          hcomp+=\" hashd\\n\"\n          \"  else\\n\"  // expect match offset byte\n          \"    a\u003e\u003e= 6 hashd a=r 1 hashd\\n\"\n          \"  endif\\n\"\n          \"else\\n\"  // expect new code\n          \"  a= 255 hashd a=r 2 hashd\\n\"\n          \"endif\\n\";\n        }\n        else if (v[i]\u003e=1256)  // skip v[i]-1000 bytes\n          hcomp+=\"a= \"+itos(((v[i]-1000)\u003e\u003e8)\u0026255)+\" a\u003c\u003c= 8 a+= \"\n               +itos((v[i]-1000)\u0026255)+\n          \" a+=b b=a\\n\";\n        else if (v[i]\u003e1000)\n          hcomp+=\"a= \"+itos(v[i]-1000)+\" a+=b b=a\\n\";\n        if (v[i]\u003c512 \u0026\u0026 i\u003cv.size()-1)\n          hcomp+=\"b++ \";\n      }\n      ++ncomp;\n    }\n\n    // m,8,24: MIX, size, rate\n    // t,8,24: MIX2, size, rate\n    // s,8,32,255: SSE, size, start, limit\n    if (strchr(\"mts\", v[0]) \u0026\u0026 ncomp\u003eint(v[0]=='t')) {\n      if (v.size()\u003c=1) v.push_back(8);\n      if (v.size()\u003c=2) v.push_back(24+8*(v[0]=='s'));\n      if (v[0]=='s' \u0026\u0026 v.size()\u003c=3) v.push_back(255);\n      comp+=itos(ncomp);\n      sb=5+v[1]*3/4;\n      if (v[0]=='m')\n        comp+=\" mix \"+itos(v[1])+\" 0 \"+itos(ncomp)+\" \"+itos(v[2])+\" 255\\n\";\n      else if (v[0]=='t')\n        comp+=\" mix2 \"+itos(v[1])+\" \"+itos(ncomp-1)+\" \"+itos(ncomp-2)\n            +\" \"+itos(v[2])+\" 255\\n\";\n      else // s\n        comp+=\" sse \"+itos(v[1])+\" \"+itos(ncomp-1)+\" \"+itos(v[2])+\" \"\n            +itos(v[3])+\"\\n\";\n      if (v[1]\u003e8) {\n        hcomp+=\"d= \"+itos(ncomp)+\" *d=0 b=c a=0\\n\";\n        for (; v[1]\u003e=16; v[1]-=8) {\n          hcomp+=\"a\u003c\u003c= 8 a+=*b\";\n          if (v[1]\u003e16) hcomp+=\" b++\";\n          hcomp+=\"\\n\";\n        }\n        if (v[1]\u003e8)\n          hcomp+=\"a\u003c\u003c= 8 a+=*b a\u003e\u003e= \"+itos(16-v[1])+\"\\n\";\n        hcomp+=\"a\u003c\u003c= 8 *d=a\\n\";\n      }\n      ++ncomp;\n    }\n\n    // i: ISSE chain with order increasing by N1,N2...\n    if (v[0]=='i' \u0026\u0026 ncomp\u003e0) {\n      assert(sb\u003e=5);\n      hcomp+=\"d= \"+itos(ncomp-1)+\" b=c a=*d d++\\n\";\n      for (unsigned i=1; i\u003cv.size() \u0026\u0026 ncomp\u003c254; ++i) {\n        for (int j=0; j\u003cv[i]%10; ++j) {\n          hcomp+=\"hash \";\n          if (i\u003cv.size()-1 || j\u003cv[i]%10-1) hcomp+=\"b++ \";\n          sb+=6;\n        }\n        hcomp+=\"*d=a\";\n        if (i\u003cv.size()-1) hcomp+=\" d++\";\n        hcomp+=\"\\n\";\n        if (sb\u003emembits) sb=membits;\n        comp+=itos(ncomp)+\" isse \"+itos(sb-6-v[i]/10)+\" \"+itos(ncomp-1)+\"\\n\";\n        ++ncomp;\n      }\n    }\n\n    // a24,0,0: MATCH. N1=hash multiplier. N2,N3=halve buf, table.\n    if (v[0]=='a') {\n      if (v.size()\u003c=1) v.push_back(24);\n      while (v.size()\u003c4) v.push_back(0);\n      comp+=itos(ncomp)+\" match \"+itos(membits-v[3]-2)+\" \"\n          +itos(membits-v[2])+\"\\n\";\n      hcomp+=\"d= \"+itos(ncomp)+\" a=*d a*= \"+itos(v[1])\n           +\" a+=*c a++ *d=a\\n\";\n      sb=5+(membits-v[2])*3/4;\n      ++ncomp;\n    }\n\n    // w1,65,26,223,20,0: ICM-ISSE chain of length N1 with word contexts,\n    // where a word is a sequence of c such that c\u0026N4 is in N2..N2+N3-1.\n    // Word is hashed by: hash := hash*N5+c+1\n    // Decrease memory by 2^-N6.\n    if (v[0]=='w') {\n      if (v.size()\u003c=1) v.push_back(1);\n      if (v.size()\u003c=2) v.push_back(65);\n      if (v.size()\u003c=3) v.push_back(26);\n      if (v.size()\u003c=4) v.push_back(223);\n      if (v.size()\u003c=5) v.push_back(20);\n      if (v.size()\u003c=6) v.push_back(0);\n      comp+=itos(ncomp)+\" icm \"+itos(membits-6-v[6])+\"\\n\";\n      for (int i=1; i\u003cv[1]; ++i)\n        comp+=itos(ncomp+i)+\" isse \"+itos(membits-6-v[6])+\" \"\n            +itos(ncomp+i-1)+\"\\n\";\n      hcomp+=\"a=*c a\u0026= \"+itos(v[4])+\" a-= \"+itos(v[2])+\" a\u0026= 255 a\u003c \"\n           +itos(v[3])+\" if\\n\";\n      for (int i=0; i\u003cv[1]; ++i) {\n        if (i==0) hcomp+=\"  d= \"+itos(ncomp);\n        else hcomp+=\"  d++\";\n        hcomp+=\" a=*d a*= \"+itos(v[5])+\" a+=*c a++ *d=a\\n\";\n      }\n      hcomp+=\"else\\n\";\n      for (int i=v[1]-1; i\u003e0; --i)\n        hcomp+=\"  d= \"+itos(ncomp+i-1)+\" a=*d d++ *d=a\\n\";\n      hcomp+=\"  d= \"+itos(ncomp)+\" *d=0\\n\"\n           \"endif\\n\";\n      ncomp+=v[1]-1;\n      sb=membits-v[6];\n      ++ncomp;\n    }\n  }\n  return hdr+itos(ncomp)+\"\\n\"+comp+hcomp+\"halt\\n\"+pcomp;\n}","filepath":"libzpaq.cpp","line_number":6887,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4318720":{"score":0.69280547,"function_name":"compressBlock","code":"void compressBlock(StringBuffer* in, Writer* out, const char* method_,\n                   const char* filename, const char* comment, bool dosha1) {\n  assert(in);\n  assert(out);\n  assert(method_);\n  assert(method_[0]);\n  std::string method=method_;\n  const unsigned n=in-\u003esize();  // input size\n  const int arg0=MAX(lg(n+4095)-20, 0);  // block size\n  assert((1u\u003c\u003c(arg0+20))\u003e=n+4096);\n\n  // Get type from method \"LB,R,t\" where L is level 0..5, B is block\n  // size 0..11, R is redundancy 0..255, t = 0..3 = binary, text, exe, both.\n  unsigned type=0;\n  if (isdigit(method[0])) {\n    int commas=0, arg[4]={0};\n    for (int i=1; i\u003cint(method.size()) \u0026\u0026 commas\u003c4; ++i) {\n      if (method[i]==',' || method[i]=='.') ++commas;\n      else if (isdigit(method[i])) arg[commas]=arg[commas]*10+method[i]-'0';\n    }\n    if (commas==0) type=512;\n    else type=arg[1]*4+arg[2];\n  }\n\n  // Get hash of input\n  libzpaq::SHA1 sha1;\n  const char* sha1ptr=0;\n#ifdef DEBUG\n  if (true) {\n#else\n  if (dosha1) {\n#endif\n    sha1.write(in-\u003ec_str(), n);\n    sha1ptr=sha1.result();\n  }\n\n  // Expand default methods\n  if (isdigit(method[0])) {\n    const int level=method[0]-'0';\n    assert(level\u003e=0 \u0026\u0026 level\u003c=9);\n\n    // build models\n    const int doe8=(type\u00262)*2;\n    method=\"x\"+itos(arg0);\n    std::string htsz=\",\"+itos(19+arg0+(arg0\u003c=6));  // lz77 hash table size\n    std::string sasz=\",\"+itos(21+arg0);            // lz77 suffix array size\n\n    // store uncompressed\n    if (level==0)\n      method=\"0\"+itos(arg0)+\",0\";\n\n    // LZ77, no model. Store if hard to compress\n    else if (level==1) {\n      if (type\u003c40) method+=\",0\";\n      else {\n        method+=\",\"+itos(1+doe8)+\",\";\n        if      (type\u003c80)  method+=\"4,0,1,15\";\n        else if (type\u003c128) method+=\"4,0,2,16\";\n        else if (type\u003c256) method+=\"4,0,2\"+htsz;\n        else if (type\u003c960) method+=\"5,0,3\"+htsz;\n        else               method+=\"6,0,3\"+htsz;\n      }\n    }\n\n    // LZ77 with longer search\n    else if (level==2) {\n      if (type\u003c32) method+=\",0\";\n      else {\n        method+=\",\"+itos(1+doe8)+\",\";\n        if (type\u003c64) method+=\"4,0,3\"+htsz;\n        else method+=\"4,0,7\"+sasz+\",1\";\n      }\n    }\n\n    // LZ77 with CM depending on redundancy\n    else if (level==3) {\n      if (type\u003c20)  // store if not compressible\n        method+=\",0\";\n      else if (type\u003c48)  // fast LZ77 if barely compressible\n        method+=\",\"+itos(1+doe8)+\",4,0,3\"+htsz;\n      else if (type\u003e=640 || (type\u00261))  // BWT if text or highly compressible\n        method+=\",\"+itos(3+doe8)+\"ci1\";\n      else  // LZ77 with O0-1 compression of up to 12 literals\n        method+=\",\"+itos(2+doe8)+\",12,0,7\"+sasz+\",1c0,0,511i2\";\n    }\n\n    // LZ77+CM, fast CM, or BWT depending on type\n    else if (level==4) {\n      if (type\u003c12)\n        method+=\",0\";\n      else if (type\u003c24)\n        method+=\",\"+itos(1+doe8)+\",4,0,3\"+htsz;\n      else if (type\u003c48)\n        method+=\",\"+itos(2+doe8)+\",5,0,7\"+sasz+\"1c0,0,511\";\n      else if (type\u003c900) {\n        method+=\",\"+itos(doe8)+\"ci1,1,1,1,2a\";\n        if (type\u00261) method+=\"w\";\n        method+=\"m\";\n      }\n      else\n        method+=\",\"+itos(3+doe8)+\"ci1\";\n    }\n\n    // Slow CM with lots of models\n    else {  // 5..9\n\n      // Model text files\n      method+=\",\"+itos(doe8);\n      if (type\u00261) method+=\"w2c0,1010,255i1\";\n      else method+=\"w1i1\";\n      method+=\"c256ci1,1,1,1,1,1,2a\";\n\n      // Analyze the data\n      const int NR=1\u003c\u003c12;\n      int pt[256]={0};  // position of last occurrence\n      int r[NR]={0};    // count repetition gaps of length r\n      const unsigned char* p=in-\u003edata();\n      if (level\u003e0) {\n        for (unsigned i=0; i\u003cn; ++i) {\n          const int k=i-pt[p[i]];\n          if (k\u003e0 \u0026\u0026 k\u003cNR) ++r[k];\n          pt[p[i]]=i;\n        }\n      }\n\n      // Add periodic models\n      int n1=n-r[1]-r[2]-r[3];\n      for (int i=0; i\u003c2; ++i) {\n        int period=0;\n        double score=0;\n        int t=0;\n        for (int j=5; j\u003cNR \u0026\u0026 t\u003cn1; ++j) {\n          const double s=r[j]/(256.0+n1-t);\n          if (s\u003escore) score=s, period=j;\n          t+=r[j];\n        }\n        if (period\u003e4 \u0026\u0026 score\u003e0.1) {\n          method+=\"c0,0,\"+itos(999+period)+\",255i1\";\n          if (period\u003c=255)\n            method+=\"c0,\"+itos(period)+\"i1\";\n          n1-=r[period];\n          r[period]=0;\n        }\n        else\n          break;\n      }\n      method+=\"c0,2,0,255i1c0,3,0,0,255i1c0,4,0,0,0,255i1mm16ts19t0\";\n    }\n  }\n\n  // Compress\n  std::string config;\n  int args[9]={0};\n  config=makeConfig(method.c_str(), args);\n  assert(n\u003c=(0x100000u\u003c\u003cargs[0])-4096);\n  libzpaq::Compressor co;\n  co.setOutput(out);\n#ifdef DEBUG\n  co.setVerify(true);\n#endif\n  StringBuffer pcomp_cmd;\n  co.writeTag();\n  co.startBlock(config.c_str(), args, \u0026pcomp_cmd);\n  std::string cs=itos(n);\n  if (comment) cs=cs+\" \"+comment;\n  co.startSegment(filename, cs.c_str());\n  if (args[1]\u003e=1 \u0026\u0026 args[1]\u003c=7 \u0026\u0026 args[1]!=4) {  // LZ77 or BWT\n    LZBuffer lz(*in, args);\n    co.setInput(\u0026lz);\n    co.compress();\n  }\n  else {  // compress with e8e9 or no preprocessing\n    if (args[1]\u003e=4 \u0026\u0026 args[1]\u003c=7)\n      e8e9(in-\u003edata(), in-\u003esize());\n    co.setInput(in);\n    co.compress();\n  }\n#ifdef DEBUG  // verify pre-post processing are inverses\n  int64_t outsize;\n  const char* sha1result=co.endSegmentChecksum(\u0026outsize, dosha1);\n  assert(sha1result);\n  assert(sha1ptr);\n  if (memcmp(sha1result, sha1ptr, 20)!=0)\n    error(\"Pre/post-processor test failed\");\n#else\n  co.endSegment(sha1ptr);\n#endif\n  co.endBlock();\n}","filepath":"libzpaq.cpp","line_number":7543,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4330912":{"score":0.7748913,"function_name":"compress","code":"void compress(Reader* in, Writer* out, const char* method,\n              const char* filename, const char* comment, bool dosha1) {\n\n  // Get block size\n  int bs=4;\n  if (method \u0026\u0026 method[0] \u0026\u0026 method[1]\u003e='0' \u0026\u0026 method[1]\u003c='9') {\n    bs=method[1]-'0';\n    if (method[2]\u003e='0' \u0026\u0026 method[2]\u003c='9') bs=bs*10+method[2]-'0';\n    if (bs\u003e11) bs=11;\n  }\n  bs=(0x100000\u003c\u003cbs)-4096;\n\n  // Compress in blocks\n  StringBuffer sb(bs);\n  sb.write(0, bs);\n  int n=0;\n  while (in \u0026\u0026 (n=in-\u003eread((char*)sb.data(), bs))\u003e0) {\n    sb.resize(n);\n    compressBlock(\u0026sb, out, method, filename, comment, dosha1);\n    filename=0;\n    comment=0;\n    sb.resize(0);\n  }\n}","filepath":"libzpaq.cpp","line_number":3008,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4331712":{"score":0.5981351,"function_name":"ZPAQL::execute","code":"int ZPAQL::execute() {\n  switch(header[pc++]) {\n    case 0: err(); break; // ERROR\n    case 1: ++a; break; // A++\n    case 2: --a; break; // A--\n    case 3: a = ~a; break; // A!\n    case 4: a = 0; break; // A=0\n    case 7: a = r[header[pc++]]; break; // A=R N\n    case 8: swap(b); break; // B\u003c\u003eA\n    case 9: ++b; break; // B++\n    case 10: --b; break; // B--\n    case 11: b = ~b; break; // B!\n    case 12: b = 0; break; // B=0\n    case 15: b = r[header[pc++]]; break; // B=R N\n    case 16: swap(c); break; // C\u003c\u003eA\n    case 17: ++c; break; // C++\n    case 18: --c; break; // C--\n    case 19: c = ~c; break; // C!\n    case 20: c = 0; break; // C=0\n    case 23: c = r[header[pc++]]; break; // C=R N\n    case 24: swap(d); break; // D\u003c\u003eA\n    case 25: ++d; break; // D++\n    case 26: --d; break; // D--\n    case 27: d = ~d; break; // D!\n    case 28: d = 0; break; // D=0\n    case 31: d = r[header[pc++]]; break; // D=R N\n    case 32: swap(m(b)); break; // *B\u003c\u003eA\n    case 33: ++m(b); break; // *B++\n    case 34: --m(b); break; // *B--\n    case 35: m(b) = ~m(b); break; // *B!\n    case 36: m(b) = 0; break; // *B=0\n    case 39: if (f) pc+=((header[pc]+128)\u0026255)-127; else ++pc; break; // JT N\n    case 40: swap(m(c)); break; // *C\u003c\u003eA\n    case 41: ++m(c); break; // *C++\n    case 42: --m(c); break; // *C--\n    case 43: m(c) = ~m(c); break; // *C!\n    case 44: m(c) = 0; break; // *C=0\n    case 47: if (!f) pc+=((header[pc]+128)\u0026255)-127; else ++pc; break; // JF N\n    case 48: swap(h(d)); break; // *D\u003c\u003eA\n    case 49: ++h(d); break; // *D++\n    case 50: --h(d); break; // *D--\n    case 51: h(d) = ~h(d); break; // *D!\n    case 52: h(d) = 0; break; // *D=0\n    case 55: r[header[pc++]] = a; break; // R=A N\n    case 56: return 0  ; // HALT\n    case 57: outc(a\u0026255); break; // OUT\n    case 59: a = (a+m(b)+512)*773; break; // HASH\n    case 60: h(d) = (h(d)+a+512)*773; break; // HASHD\n    case 63: pc+=((header[pc]+128)\u0026255)-127; break; // JMP N\n    case 64: break; // A=A\n    case 65: a = b; break; // A=B\n    case 66: a = c; break; // A=C\n    case 67: a = d; break; // A=D\n    case 68: a = m(b); break; // A=*B\n    case 69: a = m(c); break; // A=*C\n    case 70: a = h(d); break; // A=*D\n    case 71: a = header[pc++]; break; // A= N\n    case 72: b = a; break; // B=A\n    case 73: break; // B=B\n    case 74: b = c; break; // B=C\n    case 75: b = d; break; // B=D\n    case 76: b = m(b); break; // B=*B\n    case 77: b = m(c); break; // B=*C\n    case 78: b = h(d); break; // B=*D\n    case 79: b = header[pc++]; break; // B= N\n    case 80: c = a; break; // C=A\n    case 81: c = b; break; // C=B\n    case 82: break; // C=C\n    case 83: c = d; break; // C=D\n    case 84: c = m(b); break; // C=*B\n    case 85: c = m(c); break; // C=*C\n    case 86: c = h(d); break; // C=*D\n    case 87: c = header[pc++]; break; // C= N\n    case 88: d = a; break; // D=A\n    case 89: d = b; break; // D=B\n    case 90: d = c; break; // D=C\n    case 91: break; // D=D\n    case 92: d = m(b); break; // D=*B\n    case 93: d = m(c); break; // D=*C\n    case 94: d = h(d); break; // D=*D\n    case 95: d = header[pc++]; break; // D= N\n    case 96: m(b) = a; break; // *B=A\n    case 97: m(b) = b; break; // *B=B\n    case 98: m(b) = c; break; // *B=C\n    case 99: m(b) = d; break; // *B=D\n    case 100: break; // *B=*B\n    case 101: m(b) = m(c); break; // *B=*C\n    case 102: m(b) = h(d); break; // *B=*D\n    case 103: m(b) = header[pc++]; break; // *B= N\n    case 104: m(c) = a; break; // *C=A\n    case 105: m(c) = b; break; // *C=B\n    case 106: m(c) = c; break; // *C=C\n    case 107: m(c) = d; break; // *C=D\n    case 108: m(c) = m(b); break; // *C=*B\n    case 109: break; // *C=*C\n    case 110: m(c) = h(d); break; // *C=*D\n    case 111: m(c) = header[pc++]; break; // *C= N\n    case 112: h(d) = a; break; // *D=A\n    case 113: h(d) = b; break; // *D=B\n    case 114: h(d) = c; break; // *D=C\n    case 115: h(d) = d; break; // *D=D\n    case 116: h(d) = m(b); break; // *D=*B\n    case 117: h(d) = m(c); break; // *D=*C\n    case 118: break; // *D=*D\n    case 119: h(d) = header[pc++]; break; // *D= N\n    case 128: a += a; break; // A+=A\n    case 129: a += b; break; // A+=B\n    case 130: a += c; break; // A+=C\n    case 131: a += d; break; // A+=D\n    case 132: a += m(b); break; // A+=*B\n    case 133: a += m(c); break; // A+=*C\n    case 134: a += h(d); break; // A+=*D\n    case 135: a += header[pc++]; break; // A+= N\n    case 136: a -= a; break; // A-=A\n    case 137: a -= b; break; // A-=B\n    case 138: a -= c; break; // A-=C\n    case 139: a -= d; break; // A-=D\n    case 140: a -= m(b); break; // A-=*B\n    case 141: a -= m(c); break; // A-=*C\n    case 142: a -= h(d); break; // A-=*D\n    case 143: a -= header[pc++]; break; // A-= N\n    case 144: a *= a; break; // A*=A\n    case 145: a *= b; break; // A*=B\n    case 146: a *= c; break; // A*=C\n    case 147: a *= d; break; // A*=D\n    case 148: a *= m(b); break; // A*=*B\n    case 149: a *= m(c); break; // A*=*C\n    case 150: a *= h(d); break; // A*=*D\n    case 151: a *= header[pc++]; break; // A*= N\n    case 152: div(a); break; // A/=A\n    case 153: div(b); break; // A/=B\n    case 154: div(c); break; // A/=C\n    case 155: div(d); break; // A/=D\n    case 156: div(m(b)); break; // A/=*B\n    case 157: div(m(c)); break; // A/=*C\n    case 158: div(h(d)); break; // A/=*D\n    case 159: div(header[pc++]); break; // A/= N\n    case 160: mod(a); break; // A%=A\n    case 161: mod(b); break; // A%=B\n    case 162: mod(c); break; // A%=C\n    case 163: mod(d); break; // A%=D\n    case 164: mod(m(b)); break; // A%=*B\n    case 165: mod(m(c)); break; // A%=*C\n    case 166: mod(h(d)); break; // A%=*D\n    case 167: mod(header[pc++]); break; // A%= N\n    case 168: a \u0026= a; break; // A\u0026=A\n    case 169: a \u0026= b; break; // A\u0026=B\n    case 170: a \u0026= c; break; // A\u0026=C\n    case 171: a \u0026= d; break; // A\u0026=D\n    case 172: a \u0026= m(b); break; // A\u0026=*B\n    case 173: a \u0026= m(c); break; // A\u0026=*C\n    case 174: a \u0026= h(d); break; // A\u0026=*D\n    case 175: a \u0026= header[pc++]; break; // A\u0026= N\n    case 176: a \u0026= ~ a; break; // A\u0026~A\n    case 177: a \u0026= ~ b; break; // A\u0026~B\n    case 178: a \u0026= ~ c; break; // A\u0026~C\n    case 179: a \u0026= ~ d; break; // A\u0026~D\n    case 180: a \u0026= ~ m(b); break; // A\u0026~*B\n    case 181: a \u0026= ~ m(c); break; // A\u0026~*C\n    case 182: a \u0026= ~ h(d); break; // A\u0026~*D\n    case 183: a \u0026= ~ header[pc++]; break; // A\u0026~ N\n    case 184: a |= a; break; // A|=A\n    case 185: a |= b; break; // A|=B\n    case 186: a |= c; break; // A|=C\n    case 187: a |= d; break; // A|=D\n    case 188: a |= m(b); break; // A|=*B\n    case 189: a |= m(c); break; // A|=*C\n    case 190: a |= h(d); break; // A|=*D\n    case 191: a |= header[pc++]; break; // A|= N\n    case 192: a ^= a; break; // A^=A\n    case 193: a ^= b; break; // A^=B\n    case 194: a ^= c; break; // A^=C\n    case 195: a ^= d; break; // A^=D\n    case 196: a ^= m(b); break; // A^=*B\n    case 197: a ^= m(c); break; // A^=*C\n    case 198: a ^= h(d); break; // A^=*D\n    case 199: a ^= header[pc++]; break; // A^= N\n    case 200: a \u003c\u003c= (a\u002631); break; // A\u003c\u003c=A\n    case 201: a \u003c\u003c= (b\u002631); break; // A\u003c\u003c=B\n    case 202: a \u003c\u003c= (c\u002631); break; // A\u003c\u003c=C\n    case 203: a \u003c\u003c= (d\u002631); break; // A\u003c\u003c=D\n    case 204: a \u003c\u003c= (m(b)\u002631); break; // A\u003c\u003c=*B\n    case 205: a \u003c\u003c= (m(c)\u002631); break; // A\u003c\u003c=*C\n    case 206: a \u003c\u003c= (h(d)\u002631); break; // A\u003c\u003c=*D\n    case 207: a \u003c\u003c= (header[pc++]\u002631); break; // A\u003c\u003c= N\n    case 208: a \u003e\u003e= (a\u002631); break; // A\u003e\u003e=A\n    case 209: a \u003e\u003e= (b\u002631); break; // A\u003e\u003e=B\n    case 210: a \u003e\u003e= (c\u002631); break; // A\u003e\u003e=C\n    case 211: a \u003e\u003e= (d\u002631); break; // A\u003e\u003e=D\n    case 212: a \u003e\u003e= (m(b)\u002631); break; // A\u003e\u003e=*B\n    case 213: a \u003e\u003e= (m(c)\u002631); break; // A\u003e\u003e=*C\n    case 214: a \u003e\u003e= (h(d)\u002631); break; // A\u003e\u003e=*D\n    case 215: a \u003e\u003e= (header[pc++]\u002631); break; // A\u003e\u003e= N\n    case 216: f = 1; break; // A==A\n    case 217: f = (a == b); break; // A==B\n    case 218: f = (a == c); break; // A==C\n    case 219: f = (a == d); break; // A==D\n    case 220: f = (a == U32(m(b))); break; // A==*B\n    case 221: f = (a == U32(m(c))); break; // A==*C\n    case 222: f = (a == h(d)); break; // A==*D\n    case 223: f = (a == U32(header[pc++])); break; // A== N\n    case 224: f = 0; break; // A\u003cA\n    case 225: f = (a \u003c b); break; // A\u003cB\n    case 226: f = (a \u003c c); break; // A\u003cC\n    case 227: f = (a \u003c d); break; // A\u003cD\n    case 228: f = (a \u003c U32(m(b))); break; // A\u003c*B\n    case 229: f = (a \u003c U32(m(c))); break; // A\u003c*C\n    case 230: f = (a \u003c h(d)); break; // A\u003c*D\n    case 231: f = (a \u003c U32(header[pc++])); break; // A\u003c N\n    case 232: f = 0; break; // A\u003eA\n    case 233: f = (a \u003e b); break; // A\u003eB\n    case 234: f = (a \u003e c); break; // A\u003eC\n    case 235: f = (a \u003e d); break; // A\u003eD\n    case 236: f = (a \u003e U32(m(b))); break; // A\u003e*B\n    case 237: f = (a \u003e U32(m(c))); break; // A\u003e*C\n    case 238: f = (a \u003e h(d)); break; // A\u003e*D\n    case 239: f = (a \u003e U32(header[pc++])); break; // A\u003e N\n    case 255: if((pc=hbegin+header[pc]+256*header[pc+1])\u003e=hend)err();break;//LJ\n    default: err();\n  }\n  return 1;\n}","filepath":"libzpaq.cpp","line_number":1041,"entry_url":"https://github.com/zpaq/zpaq.git","slot_name":"7.15"},"4338672":{"score":0.60647535,"function_name":"qlz_decompress","code":"static size_t qlz_decompress(const char *source, void *destination, qlz_state_decompress *state)\n{\n\tsize_t dsiz = qlz_size_decompressed(source);\n\n#if QLZ_STREAMING_BUFFER \u003e 0\n\tif (state-\u003estream_counter + qlz_size_decompressed(source) - 1 \u003e= QLZ_STREAMING_BUFFER) \n#endif\n\t{\n\t\tif((*source \u0026 1) == 1)\n\t\t{\n\t\t\treset_table_decompress(state);\n\t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, (unsigned char *)destination, dsiz, state, (const unsigned char *)destination);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(destination, source + qlz_size_header(source), dsiz);\n\t\t}\n\t\tstate-\u003estream_counter = 0;\n\t\treset_table_decompress(state);\n\t}\n#if QLZ_STREAMING_BUFFER \u003e 0\n\telse\n\t{\n\t\tunsigned char *dst = state-\u003estream_buffer + state-\u003estream_counter;\n\t\tif((*source \u0026 1) == 1)\n\t\t{\n\t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, dst, dsiz, state, (const unsigned char *)state-\u003estream_buffer);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(dst, source + qlz_size_header(source), dsiz);\n\t\t\treset_table_decompress(state);\n\t\t}\n\t\tmemcpy(destination, dst, dsiz);\n\t\tstate-\u003estream_counter += dsiz;\n\t}\n#endif\n\treturn dsiz;\n}","filepath":"quicklz_/src/quicklz.c","line_number":809,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4339216":{"score":0.6693497,"function_name":"qlz_get_setting","code":"static int qlz_get_setting(int setting)\n{\n\tswitch (setting)\n\t{\n\t\tcase 0: return QLZ_COMPRESSION_LEVEL;\n\t\tcase 1: return sizeof(qlz_state_compress);\n\t\tcase 2: return sizeof(qlz_state_decompress);\n\t\tcase 3: return QLZ_STREAMING_BUFFER;\n#ifdef QLZ_MEMORY_SAFE\n\t\tcase 6: return 1;\n#else\n\t\tcase 6: return 0;\n#endif\n\t\tcase 7: return QLZ_VERSION_MAJOR;\n\t\tcase 8: return QLZ_VERSION_MINOR;\n\t\tcase 9: return QLZ_VERSION_REVISION;\n\t}\n\treturn -1;\n}","filepath":"quicklz_/src/quicklz.c","line_number":35,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4339248":{"score":0.71547055,"function_name":"qlz_decompress_core","code":"static size_t qlz_decompress_core(const unsigned char *source, unsigned char *destination, size_t size, qlz_state_decompress *state, const unsigned char *history)\n{\n\tconst unsigned char *src = source + qlz_size_header((const char *)source);\n\tunsigned char *dst = destination;\n\tconst unsigned char *last_destination_byte = destination + size - 1;\n\tui32 cword_val = 1;\n\tconst unsigned char *last_matchstart = last_destination_byte - UNCONDITIONAL_MATCHLEN - UNCOMPRESSED_END;\n\tunsigned char *last_hashed = destination - 1;\n\tconst unsigned char *last_source_byte = source + qlz_size_compressed((const char *)source) - 1;\n\tstatic const ui32 bitlut[16] = {4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};\n\n\t(void) last_source_byte;\n\t(void) last_hashed;\n\t(void) state;\n\t(void) history;\n\n\tfor(;;) \n\t{\n\t\tui32 fetch;\n\n\t\tif (cword_val == 1)\n\t\t{\n#ifdef QLZ_MEMORY_SAFE\n\t\t\tif(src + CWORD_LEN - 1 \u003e last_source_byte)\n\t\t\t\treturn 0;\n#endif\n\t\t\tcword_val = fast_read(src, CWORD_LEN);\n\t\t\tsrc += CWORD_LEN;\n\t\t}\n\n#ifdef QLZ_MEMORY_SAFE\n\t\t\tif(src + 4 - 1 \u003e last_source_byte)\n\t\t\t\treturn 0;\n#endif\n\n\t\tfetch = fast_read(src, 4);\n\n\t\tif ((cword_val \u0026 1) == 1)\n\t\t{\n\t\t\tui32 matchlen;\n\t\t\tconst unsigned char *offset2;\n\n#if QLZ_COMPRESSION_LEVEL == 1\n\t\t\tui32 hash;\n\t\t\tcword_val = cword_val \u003e\u003e 1;\n\t\t\thash = (fetch \u003e\u003e 4) \u0026 0xfff;\n\t\t\toffset2 = (const unsigned char *)(size_t)state-\u003ehash[hash].offset;\n\n\t\t\tif((fetch \u0026 0xf) != 0)\n\t\t\t{\n\t\t\t\tmatchlen = (fetch \u0026 0xf) + 2;\n\t\t\t\tsrc += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchlen = *(src + 2);\n\t\t\t\tsrc += 3;\t\t\t\t\t\t\t\n\t\t\t}\t\n\n#elif QLZ_COMPRESSION_LEVEL == 2\n\t\t\tui32 hash;\n\t\t\tunsigned char c;\n\t\t\tcword_val = cword_val \u003e\u003e 1;\n\t\t\thash = (fetch \u003e\u003e 5) \u0026 0x7ff;\n\t\t\tc = (unsigned char)(fetch \u0026 0x3);\n\t\t\toffset2 = state-\u003ehash[hash].offset[c];\n\n\t\t\tif((fetch \u0026 (28)) != 0)\n\t\t\t{\n\t\t\t\tmatchlen = ((fetch \u003e\u003e 2) \u0026 0x7) + 2;\n\t\t\t\tsrc += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchlen = *(src + 2);\n\t\t\t\tsrc += 3;\t\t\t\t\t\t\t\n\t\t\t}\t\n\n#elif QLZ_COMPRESSION_LEVEL == 3\n\t\t\tui32 offset;\n\t\t\tcword_val = cword_val \u003e\u003e 1;\n\t\t\tif ((fetch \u0026 3) == 0)\n\t\t\t{\n\t\t\t\toffset = (fetch \u0026 0xff) \u003e\u003e 2;\n\t\t\t\tmatchlen = 3;\n\t\t\t\tsrc++;\n\t\t\t}\n\t\t\telse if ((fetch \u0026 2) == 0)\n\t\t\t{\n\t\t\t\toffset = (fetch \u0026 0xffff) \u003e\u003e 2;\n\t\t\t\tmatchlen = 3;\n\t\t\t\tsrc += 2;\n\t\t\t}\n\t\t\telse if ((fetch \u0026 1) == 0)\n\t\t\t{\n\t\t\t\toffset = (fetch \u0026 0xffff) \u003e\u003e 6;\n\t\t\t\tmatchlen = ((fetch \u003e\u003e 2) \u0026 15) + 3;\n\t\t\t\tsrc += 2;\n\t\t\t}\n\t\t\telse if ((fetch \u0026 127) != 3)\n\t\t\t{\n\t\t\t\toffset = (fetch \u003e\u003e 7) \u0026 0x1ffff;\n\t\t\t\tmatchlen = ((fetch \u003e\u003e 2) \u0026 0x1f) + 2;\n\t\t\t\tsrc += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toffset = (fetch \u003e\u003e 15);\n\t\t\t\tmatchlen = ((fetch \u003e\u003e 7) \u0026 255) + 3;\n\t\t\t\tsrc += 4;\n\t\t\t}\n\n\t\t\toffset2 = dst - offset;\n#endif\n\t\n#ifdef QLZ_MEMORY_SAFE\n\t\t\tif(offset2 \u003c history || offset2 \u003e dst - MINOFFSET - 1)\n\t\t\t\treturn 0;\n\n\t\t\tif(matchlen \u003e (ui32)(last_destination_byte - dst - UNCOMPRESSED_END + 1))\n\t\t\t\treturn 0;\n#endif\n\n\t\t\tmemcpy_up(dst, offset2, matchlen);\n\t\t\tdst += matchlen;\n\n#if QLZ_COMPRESSION_LEVEL \u003c= 2\n\t\t\tupdate_hash_upto(state, \u0026last_hashed, dst - matchlen);\n\t\t\tlast_hashed = dst - 1;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (dst \u003c last_matchstart)\n\t\t\t{\n\t\t\t\tunsigned int n = bitlut[cword_val \u0026 0xf];\n#ifdef X86X64\n\t\t\t\t*(ui32 *)dst = *(ui32 *)src;\n#else\n\t\t\t\tmemcpy_up(dst, src, 4);\n#endif\n\t\t\t\tcword_val = cword_val \u003e\u003e n;\n\t\t\t\tdst += n;\n\t\t\t\tsrc += n;\n#if QLZ_COMPRESSION_LEVEL \u003c= 2\n\t\t\t\tupdate_hash_upto(state, \u0026last_hashed, dst - 3);\t\t\n#endif\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\t\t\n\t\t\t\twhile(dst \u003c= last_destination_byte)\n\t\t\t\t{\n\t\t\t\t\tif (cword_val == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsrc += CWORD_LEN;\n\t\t\t\t\t\tcword_val = 1U \u003c\u003c 31;\n\t\t\t\t\t}\n#ifdef QLZ_MEMORY_SAFE\n\t\t\t\t\tif(src \u003e= last_source_byte + 1)\n\t\t\t\t\t\treturn 0;\n#endif\n\t\t\t\t\t*dst = *src;\n\t\t\t\t\tdst++;\n\t\t\t\t\tsrc++;\n\t\t\t\t\tcword_val = cword_val \u003e\u003e 1;\n\t\t\t\t}\n\n#if QLZ_COMPRESSION_LEVEL \u003c= 2\n\t\t\t\tupdate_hash_upto(state, \u0026last_hashed, last_destination_byte - 3); // todo, use constant\n#endif\n\t\t\t\treturn size;\n\t\t\t}\n\n\t\t}\n\t}\n}","filepath":"quicklz_/src/quicklz.c","line_number":552,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4357296":{"score":0.638625,"function_name":"pqdownheap","code":"local void pqdownheap(s, tree, k)\n    deflate_state *s;\n    ct_data *tree;  /* the tree to restore */\n    int k;               /* node to move down */\n{\n    int v = s-\u003eheap[k];\n    int j = k \u003c\u003c 1;  /* left son of k */\n    while (j \u003c= s-\u003eheap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j \u003c s-\u003eheap_len \u0026\u0026\n            smaller(tree, s-\u003eheap[j+1], s-\u003eheap[j], s-\u003edepth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s-\u003eheap[j], s-\u003edepth)) break;\n\n        /* Exchange v with the smallest son */\n        s-\u003eheap[k] = s-\u003eheap[j];  k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j \u003c\u003c= 1;\n    }\n    s-\u003eheap[k] = v;\n}","filepath":"src/third_party/zlib/trees.c","line_number":451,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4360192":{"score":0.750928,"function_name":"init_block","code":"local void init_block(s)\n    deflate_state *s;\n{\n    int n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n \u003c L_CODES;  n++) s-\u003edyn_ltree[n].Freq = 0;\n    for (n = 0; n \u003c D_CODES;  n++) s-\u003edyn_dtree[n].Freq = 0;\n    for (n = 0; n \u003c BL_CODES; n++) s-\u003ebl_tree[n].Freq = 0;\n\n    s-\u003edyn_ltree[END_BLOCK].Freq = 1;\n    s-\u003eopt_len = s-\u003estatic_len = 0L;\n    s-\u003esym_next = s-\u003ematches = 0;\n}","filepath":"src/third_party/zlib/trees.c","line_number":407,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4360352":{"score":0.77616704,"function_name":"pqdownheap","code":"local void pqdownheap(s, tree, k)\n    deflate_state *s;\n    ct_data *tree;  /* the tree to restore */\n    int k;               /* node to move down */\n{\n    int v = s-\u003eheap[k];\n    int j = k \u003c\u003c 1;  /* left son of k */\n    while (j \u003c= s-\u003eheap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j \u003c s-\u003eheap_len \u0026\u0026\n            smaller(tree, s-\u003eheap[j+1], s-\u003eheap[j], s-\u003edepth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s-\u003eheap[j], s-\u003edepth)) break;\n\n        /* Exchange v with the smallest son */\n        s-\u003eheap[k] = s-\u003eheap[j];  k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j \u003c\u003c= 1;\n    }\n    s-\u003eheap[k] = v;\n}","filepath":"src/third_party/zlib/trees.c","line_number":451,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4360592":{"score":0.76840526,"function_name":"gen_bitlen","code":"local void gen_bitlen(s, desc)\n    deflate_state *s;\n    tree_desc *desc;    /* the tree descriptor */\n{\n    ct_data *tree        = desc-\u003edyn_tree;\n    int max_code         = desc-\u003emax_code;\n    const ct_data *stree = desc-\u003estat_desc-\u003estatic_tree;\n    const intf *extra    = desc-\u003estat_desc-\u003eextra_bits;\n    int base             = desc-\u003estat_desc-\u003eextra_base;\n    int max_length       = desc-\u003estat_desc-\u003emax_length;\n    int h;              /* heap index */\n    int n, m;           /* iterate over the tree elements */\n    int bits;           /* bit length */\n    int xbits;          /* extra bits */\n    ush f;              /* frequency */\n    int overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits \u003c= MAX_BITS; bits++) s-\u003ebl_count[bits] = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[s-\u003eheap[s-\u003eheap_max]].Len = 0; /* root of the heap */\n\n    for (h = s-\u003eheap_max+1; h \u003c HEAP_SIZE; h++) {\n        n = s-\u003eheap[h];\n        bits = tree[tree[n].Dad].Len + 1;\n        if (bits \u003e max_length) bits = max_length, overflow++;\n        tree[n].Len = (ush)bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n \u003e max_code) continue; /* not a leaf node */\n\n        s-\u003ebl_count[bits]++;\n        xbits = 0;\n        if (n \u003e= base) xbits = extra[n-base];\n        f = tree[n].Freq;\n        s-\u003eopt_len += (ulg)f * (unsigned)(bits + xbits);\n        if (stree) s-\u003estatic_len += (ulg)f * (unsigned)(stree[n].Len + xbits);\n    }\n    if (overflow == 0) return;\n\n    Tracev((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n        bits = max_length-1;\n        while (s-\u003ebl_count[bits] == 0) bits--;\n        s-\u003ebl_count[bits]--;      /* move one leaf down the tree */\n        s-\u003ebl_count[bits+1] += 2; /* move one overflow item as its brother */\n        s-\u003ebl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n        overflow -= 2;\n    } while (overflow \u003e 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits != 0; bits--) {\n        n = s-\u003ebl_count[bits];\n        while (n != 0) {\n            m = s-\u003eheap[--h];\n            if (m \u003e max_code) continue;\n            if ((unsigned) tree[m].Len != (unsigned) bits) {\n                Tracev((stderr,\"code %d bits %d-\u003e%d\\n\", m, tree[m].Len, bits));\n                s-\u003eopt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;\n                tree[m].Len = (ush)bits;\n            }\n            n--;\n        }\n    }\n}","filepath":"src/third_party/zlib/trees.c","line_number":486,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4362176":{"score":0.75353605,"function_name":"build_tree","code":"local void build_tree(s, desc)\n    deflate_state *s;\n    tree_desc *desc; /* the tree descriptor */\n{\n    ct_data *tree         = desc-\u003edyn_tree;\n    const ct_data *stree  = desc-\u003estat_desc-\u003estatic_tree;\n    int elems             = desc-\u003estat_desc-\u003eelems;\n    int n, m;          /* iterate over heap elements */\n    int max_code = -1; /* largest code with non zero frequency */\n    int node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n    s-\u003eheap_len = 0, s-\u003eheap_max = HEAP_SIZE;\n\n    for (n = 0; n \u003c elems; n++) {\n        if (tree[n].Freq != 0) {\n            s-\u003eheap[++(s-\u003eheap_len)] = max_code = n;\n            s-\u003edepth[n] = 0;\n        } else {\n            tree[n].Len = 0;\n        }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s-\u003eheap_len \u003c 2) {\n        node = s-\u003eheap[++(s-\u003eheap_len)] = (max_code \u003c 2 ? ++max_code : 0);\n        tree[node].Freq = 1;\n        s-\u003edepth[node] = 0;\n        s-\u003eopt_len--; if (stree) s-\u003estatic_len -= stree[node].Len;\n        /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc-\u003emax_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = s-\u003eheap_len/2; n \u003e= 1; n--) pqdownheap(s, tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n        pqremove(s, tree, n);  /* n = node of least frequency */\n        m = s-\u003eheap[SMALLEST]; /* m = node of next least frequency */\n\n        s-\u003eheap[--(s-\u003eheap_max)] = n; /* keep the nodes sorted by frequency */\n        s-\u003eheap[--(s-\u003eheap_max)] = m;\n\n        /* Create a new node father of n and m */\n        tree[node].Freq = tree[n].Freq + tree[m].Freq;\n        s-\u003edepth[node] = (uch)((s-\u003edepth[n] \u003e= s-\u003edepth[m] ?\n                                s-\u003edepth[n] : s-\u003edepth[m]) + 1);\n        tree[n].Dad = tree[m].Dad = (ush)node;\n#ifdef DUMP_BL_TREE\n        if (tree == s-\u003ebl_tree) {\n            fprintf(stderr,\"\\nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);\n        }\n#endif\n        /* and insert the new node in the heap */\n        s-\u003eheap[SMALLEST] = node++;\n        pqdownheap(s, tree, SMALLEST);\n\n    } while (s-\u003eheap_len \u003e= 2);\n\n    s-\u003eheap[--(s-\u003eheap_max)] = s-\u003eheap[SMALLEST];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, (tree_desc *)desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes ((ct_data *)tree, max_code, s-\u003ebl_count);\n}","filepath":"src/third_party/zlib/trees.c","line_number":615,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4363632":{"score":0.796471,"function_name":"scan_tree","code":"local void scan_tree (s, tree, max_code)\n    deflate_state *s;\n    ct_data *tree;   /* the tree to be scanned */\n    int max_code;    /* and its largest code of non zero frequency */\n{\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    if (nextlen == 0) max_count = 138, min_count = 3;\n    tree[max_code+1].Len = (ush)0xffff; /* guard */\n\n    for (n = 0; n \u003c= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n+1].Len;\n        if (++count \u003c max_count \u0026\u0026 curlen == nextlen) {\n            continue;\n        } else if (count \u003c min_count) {\n            s-\u003ebl_tree[curlen].Freq += count;\n        } else if (curlen != 0) {\n            if (curlen != prevlen) s-\u003ebl_tree[curlen].Freq++;\n            s-\u003ebl_tree[REP_3_6].Freq++;\n        } else if (count \u003c= 10) {\n            s-\u003ebl_tree[REPZ_3_10].Freq++;\n        } else {\n            s-\u003ebl_tree[REPZ_11_138].Freq++;\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}","filepath":"src/third_party/zlib/trees.c","line_number":703,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4363920":{"score":0.63951254,"function_name":"send_tree","code":"local void send_tree (s, tree, max_code)\n    deflate_state *s;\n    ct_data *tree; /* the tree to be scanned */\n    int max_code;       /* and its largest code of non zero frequency */\n{\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    /* tree[max_code+1].Len = -1; */  /* guard already set */\n    if (nextlen == 0) max_count = 138, min_count = 3;\n\n    for (n = 0; n \u003c= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n+1].Len;\n        if (++count \u003c max_count \u0026\u0026 curlen == nextlen) {\n            continue;\n        } else if (count \u003c min_count) {\n            do { send_code(s, curlen, s-\u003ebl_tree); } while (--count != 0);\n\n        } else if (curlen != 0) {\n            if (curlen != prevlen) {\n                send_code(s, curlen, s-\u003ebl_tree); count--;\n            }\n            Assert(count \u003e= 3 \u0026\u0026 count \u003c= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s-\u003ebl_tree); send_bits(s, count-3, 2);\n\n        } else if (count \u003c= 10) {\n            send_code(s, REPZ_3_10, s-\u003ebl_tree); send_bits(s, count-3, 3);\n\n        } else {\n            send_code(s, REPZ_11_138, s-\u003ebl_tree); send_bits(s, count-11, 7);\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}","filepath":"src/third_party/zlib/trees.c","line_number":748,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4365328":{"score":0.7246674,"function_name":"build_bl_tree","code":"local int build_bl_tree(s)\n    deflate_state *s;\n{\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, (ct_data *)s-\u003edyn_ltree, s-\u003el_desc.max_code);\n    scan_tree(s, (ct_data *)s-\u003edyn_dtree, s-\u003ed_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, (tree_desc *)(\u0026(s-\u003ebl_desc)));\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES-1; max_blindex \u003e= 3; max_blindex--) {\n        if (s-\u003ebl_tree[bl_order[max_blindex]].Len != 0) break;\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s-\u003eopt_len += 3*((ulg)max_blindex+1) + 5+5+4;\n    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n            s-\u003eopt_len, s-\u003estatic_len));\n\n    return max_blindex;\n}","filepath":"src/third_party/zlib/trees.c","line_number":799,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4365744":{"score":0.6881125,"function_name":"send_all_trees","code":"local void send_all_trees(s, lcodes, dcodes, blcodes)\n    deflate_state *s;\n    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n    int rank;                    /* index in bl_order */\n\n    Assert (lcodes \u003e= 257 \u0026\u0026 dcodes \u003e= 1 \u0026\u0026 blcodes \u003e= 4, \"not enough codes\");\n    Assert (lcodes \u003c= L_CODES \u0026\u0026 dcodes \u003c= D_CODES \u0026\u0026 blcodes \u003c= BL_CODES,\n            \"too many codes\");\n    Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes-1,   5);\n    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank \u003c blcodes; rank++) {\n        Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s-\u003ebl_tree[bl_order[rank]].Len, 3);\n    }\n    Tracev((stderr, \"\\nbl tree: sent %ld\", s-\u003ebits_sent));\n\n    send_tree(s, (ct_data *)s-\u003edyn_ltree, lcodes-1); /* literal tree */\n    Tracev((stderr, \"\\nlit tree: sent %ld\", s-\u003ebits_sent));\n\n    send_tree(s, (ct_data *)s-\u003edyn_dtree, dcodes-1); /* distance tree */\n    Tracev((stderr, \"\\ndist tree: sent %ld\", s-\u003ebits_sent));\n}","filepath":"src/third_party/zlib/trees.c","line_number":834,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4366160":{"score":0.70662045,"function_name":"_tr_tally","code":"int ZLIB_INTERNAL _tr_tally (s, dist, lc)\n    deflate_state *s;\n    unsigned dist;  /* distance of matched string */\n    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n    s-\u003esym_buf[s-\u003esym_next++] = dist;\n    s-\u003esym_buf[s-\u003esym_next++] = dist \u003e\u003e 8;\n    s-\u003esym_buf[s-\u003esym_next++] = lc;\n    if (dist == 0) {\n        /* lc is the unmatched char */\n        s-\u003edyn_ltree[lc].Freq++;\n    } else {\n        s-\u003ematches++;\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;             /* dist = match distance - 1 */\n        Assert((ush)dist \u003c (ush)MAX_DIST(s) \u0026\u0026\n               (ush)lc \u003c= (ush)(MAX_MATCH-MIN_MATCH) \u0026\u0026\n               (ush)d_code(dist) \u003c (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s-\u003edyn_ltree[_length_code[lc]+LITERALS+1].Freq++;\n        s-\u003edyn_dtree[d_code(dist)].Freq++;\n    }\n    return (s-\u003esym_next == s-\u003esym_end);\n}","filepath":"src/third_party/zlib/trees.c","line_number":1014,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4367168":{"score":0.6488644,"function_name":"compress_block","code":"local void compress_block(s, ltree, dtree)\n    deflate_state *s;\n    const ct_data *ltree; /* literal tree */\n    const ct_data *dtree; /* distance tree */\n{\n    unsigned dist;      /* distance of matched string */\n    int lc;             /* match length or unmatched char (if dist == 0) */\n    unsigned sx = 0;    /* running index in sym_buf */\n    unsigned code;      /* the code to send */\n    int extra;          /* number of extra bits to send */\n\n    if (s-\u003esym_next != 0) do {\n        dist = s-\u003esym_buf[sx++] \u0026 0xff;\n        dist += (unsigned)(s-\u003esym_buf[sx++] \u0026 0xff) \u003c\u003c 8;\n        lc = s-\u003esym_buf[sx++];\n        if (dist == 0) {\n            send_code(s, lc, ltree); /* send a literal byte */\n            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc];\n            send_code(s, code+LITERALS+1, ltree); /* send the length code */\n            extra = extra_lbits[code];\n            if (extra != 0) {\n                lc -= base_length[code];\n                send_bits(s, lc, extra);       /* send the extra length bits */\n            }\n            dist--; /* dist is now the match distance - 1 */\n            code = d_code(dist);\n            Assert (code \u003c D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);       /* send the distance code */\n            extra = extra_dbits[code];\n            if (extra != 0) {\n                dist -= (unsigned)base_dist[code];\n                send_bits(s, dist, extra);   /* send the extra distance bits */\n            }\n        } /* literal or match pair ? */\n\n        /* Check that the overlay between pending_buf and sym_buf is ok: */\n        Assert(s-\u003epending \u003c s-\u003elit_bufsize + sx, \"pendingBuf overflow\");\n\n    } while (sx \u003c s-\u003esym_next);\n\n    send_code(s, END_BLOCK, ltree);\n}","filepath":"src/third_party/zlib/trees.c","line_number":1042,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4368736":{"score":0.7713881,"function_name":"bi_reverse","code":"local unsigned bi_reverse(code, len)\n    unsigned code; /* the value to invert */\n    int len;       /* its bit length */\n{\n    register unsigned res = 0;\n    do {\n        res |= code \u0026 1;\n        code \u003e\u003e= 1, res \u003c\u003c= 1;\n    } while (--len \u003e 0);\n    return res \u003e\u003e 1;\n}","filepath":"src/third_party/zlib/trees.c","line_number":1136,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4368768":{"score":0.6237285,"function_name":"bi_windup","code":"local void bi_windup(s)\n    deflate_state *s;\n{\n    if (s-\u003ebi_valid \u003e 8) {\n        put_short(s, s-\u003ebi_buf);\n    } else if (s-\u003ebi_valid \u003e 0) {\n        put_byte(s, (Byte)s-\u003ebi_buf);\n    }\n    s-\u003ebi_buf = 0;\n    s-\u003ebi_valid = 0;\n#ifdef ZLIB_DEBUG\n    s-\u003ebits_sent = (s-\u003ebits_sent+7) \u0026 ~7;\n#endif\n}","filepath":"src/third_party/zlib/trees.c","line_number":1168,"entry_url":"https://github.com/klzgrad/naiveproxy.git","slot_name":"v71.0.3578.98-1"},"4385920":{"score":0.8625561,"function_name":"argtoi","code":"unsigned argtoi(char *s, unsigned def) {\r\n  char *p; \r\n  unsigned n = strtol(s, \u0026p, 10),f = 1;\r\n  switch(*p) {\r\n    case 'B': f = 1; break;\r\n    case 'K': f = KB; break;\r\n    case 'M': f = MB; break;\r\n    case 'G': f = GB; break;\r\n    case 'k': f = Kb; break;\r\n    case 'm': f = Mb; break;\r\n    case 'g': f = Gb; break;\r\n    case 'b': def = 0;\r\n\tdefault: if(!def) return n\u003e=32?0xffffffffu:(1u \u003c\u003c n); f = def; \r\n  }\r\n  return n*f;\r\n}","filepath":"plugins.cc","line_number":1156,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4386256":{"score":0.8487083,"function_name":"codini","code":"int codini(size_t insize, int codec, int lev, char *prm) {\r\n  workmemsize = 0;  \r\n\r\n  switch(codec) {\r\n      #if C_C_BLOSC2\r\n    case P_C_BLOSC2: blosc_init(); blosc_set_nthreads(1);break;\r\n      #endif\r\n      \r\n      #if C_FASTARI\r\n    case P_FASTARI: workmemsize = FA_WORKMEM; break;\r\n      #endif\r\n\r\n      #if C_LZFSE\r\n    case P_LZFSE:\r\n      { size_t lzfse_size = lzfse_encode_scratch_size();\r\n        workmemsize = max(lzfse_size, workmemsize);\r\n        lzfse_size = lzfse_decode_scratch_size();\r\n        workmemsize = max(lzfse_size, workmemsize);\r\n      }\r\n      break;\r\n      #endif\r\n\r\n      #if C_LZFSEA\r\n    case P_LZFSEA:\r\n      { size_t lzfsea_size = compression_encode_scratch_buffer_size(COMPRESSION_LZFSE);\r\n        workmemsize = max(lzfsea_size, workmemsize);\r\n        lzfsea_size = compression_decode_scratch_buffer_size(COMPRESSION_LZFSE);\r\n        workmemsize = max(lzfsea_size, workmemsize);\r\n      }\r\n      break;\r\n      #endif\r\n\r\n      #if C_LZO\r\n    case P_LZO1b: lzo_init(); workmemsize = LZO1B_999_MEM_COMPRESS; break;\r\n    case P_LZO1c: P_LZO1f: P_LZO1x: P_LZO1y: P_LZO1z: P_LZO2a: lzo_init(); workmemsize = LZO1X_MEM_COMPRESS; break;\r\n      #endif\r\n\t\r\n      #if C_CHAMELEON\r\n    case P_CHAMELEON: workmemsize = sizeof(struct Chameleon); break;\r\n\t  #endif\r\n\t\r\n      #if C_QUICKLZ\r\n    case P_QUICKLZ:\r\n      state_size  = max(qlz_get_setting1(1), max(qlz_get_setting2(1), qlz_get_setting3(1))); workmemsize = max(state_size, workmemsize);\r\n      dstate_size = max(qlz_get_setting1(2), max(qlz_get_setting2(2), qlz_get_setting3(2))); workmemsize = max(dstate_size, workmemsize);\r\n      break;\r\n      #endif\r\n \r\n      #if C_BRIEFLZ\r\n    case P_BRIEFLZ: workmemsize = blz_workmem_size_level(insize, lev); break;\r\n      #endif  \r\n\r\n      #if C_SNAPPY_C\r\n    case P_SNAPPY_C: snappy_init_env(\u0026env); break; \r\n      #endif\r\n    \r\n      #if C_WFLZ\t\r\n    case P_WFLZ: workmemsize = wfLZ_GetWorkMemSize(); break;\r\n      #endif\r\n\r\n      #if C_YAPPY\r\n    case P_YAPPY: YappyFillTables(); break;\r\n      #endif\r\n\r\n      #if C_LIBBSC\r\n    case P_LIBBSC: case P_LIBBSCC: bsc_init(LIBBSC_FEATURE_FASTMODE); bsc_st_init(LIBBSC_FEATURE_FASTMODE); break;\r\n      #endif\r\n\r\n      #if C_LIBSLZ\r\n         slz_make_crc_table();\r\n         slz_prepare_dist_table();\r\n      #endif\r\n\r\n\t  #if C_FSE\r\n    case P_FSEH: workmemsize = max(4096*sizeof(unsigned), workmemsize); break;\r\n      #endif\r\n\r\n      #ifdef LZTURBO  \r\n    #include \"../dev/x/beplug0.h\"\r\n      #endif\r\n  }\r\n  if(!workmemsize) return 0;\r\n  if(workmemsize \u003e sizeof(_workmem) \u0026\u0026 !(workmem = (char *)malloc(workmemsize)) ) { \r\n    fprintf(stderr, \"Codini: malloc error. workmemsize=%d\\n\", workmemsize); \r\n    exit(0);\r\n  }\r\n  return 0;\r\n}","filepath":"plugins.cc","line_number":1192,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4386944":{"score":0.7963164,"function_name":"codstart","code":"int codstart(size_t insize, int codec, int lev, char *prm, int mode) { \r\n  switch(codec) {\r\n      #if C_ZSTD\r\n    case P_ZSTD: \r\n      if(strchr(prm, 'D')) {\r\n        if(mode) { if(!ddictPtr) { char *q; ddictPtr = NULL; if(q = strchr(prm,'D')) { q=q+(q[1]=='='?2:1);  if(!(ddictPtr = createDDict_orDie(q     ))) die(\"zstd:createDDict '%s' failed\\n\", q); } } }\r\n        else     { if(!cdictPtr) { char *q; cdictPtr = NULL; if(q = strchr(prm,'D')) { q=q+(q[1]=='='?2:1);  if(!(cdictPtr = createCDict_orDie(q, lev))) die(\"zstd:createCDict '%s' failed\\n\", q); } } }\r\n      }\r\n      break;\r\n      #endif\r\n    default:;\r\n  }\r\n  return 0;\r\n}","filepath":"plugins.cc","line_number":1281,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4387440":{"score":0.7974832,"function_name":"codend","code":"int codend(size_t insize, int codec, int lev, char *prm, int mode) {\r\n  switch(codec) {\r\n      #if C_ZSTD\r\n    case P_ZSTD:\r\n      //if(strchr(prm, 'D')) {\r\n        if(cdictPtr) { ZSTD_freeCDict(cdictPtr); cdictPtr = NULL; }\r\n        if(ddictPtr) { ZSTD_freeDDict(ddictPtr); ddictPtr = NULL; }\r\n      //}\r\n      break;\r\n      #endif\r\n  }\r\n  return 0;\r\n}","filepath":"plugins.cc","line_number":1296,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4387536":{"score":0.72397995,"function_name":"codexit","code":"void codexit(int codec) { \r\n  if(workmem != _workmem) {\r\n      #if C_MARLIN\r\n    if(codec == P_MARLIN) Marlin_free_dictionary((Marlin *)workmem);\r\n    else \r\n      #endif\r\n    free(workmem/*, workmemsize*/); \r\n    workmem = _workmem;\r\n  }\r\n    #if C_SNAPPY_C\r\n  if(codec == P_SNAPPY_C)\r\n    snappy_free_env(\u0026env);\r\n    #endif\r\n}","filepath":"plugins.cc","line_number":1310,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4394192":{"score":0.8050262,"function_name":"coddecomp","code":"int coddecomp(unsigned char *in, int inlen, unsigned char *out, int outlen, int codec, int lev, char *prm) {\r\n  switch(codec) {\r\n      #if C_AOM   \t\r\n    case P_AOM:     aomdec(in, inlen, out, outlen); return outlen;\r\n\t  #endif\r\n\r\n  \t  #if C_BALZ\r\n\tcase P_BALZ: return balzdecompress(in, inlen, out, outlen);\r\n      #endif\r\n\r\n\t  #if C_BCM\r\n    case P_BCM: return bcmdecompress(in, inlen, out, outlen);\r\n      #endif \r\n\r\n      #if C_C_BLOSC2\r\n    case P_C_BLOSC2: return blosc_decompress(in, out, outlen);\r\n      #endif\r\n\r\n      #if C_C_BLOSC2LZ\r\n    case P_C_BLOSC2LZ: return blosclz_decompress(in, inlen, out, outlen);\r\n      #endif\r\n\t  \r\n\t  #if C_BRIEFLZ\r\n\tcase P_BRIEFLZ:     return blz_depack(in, out, outlen);\r\n\t  #endif\r\n\t  \r\n      #if C_BROTLI\r\n    case P_BROTLI: { BrotliDecoderState* s = BrotliDecoderCreateInstance(NULL, NULL, NULL); if(!s) return -1;\r\n\tBrotliDecoderSetParameter(s, BROTLI_DECODER_PARAM_LARGE_WINDOW, 1u); \r\n\tsize_t total_out, available_in=inlen, available_out=outlen; uint8_t *next_in=in, *next_out=out;\r\n\tBrotliDecoderResult rc = BrotliDecoderDecompressStream(s, \u0026available_in, (const uint8_t **)\u0026next_in, \u0026available_out, (uint8_t **)\u0026next_out, \u0026total_out); \r\n        BrotliDecoderDestroyInstance(s);\r\n        return rc?total_out:0; \r\n      }\r\n\t  #endif\r\n\r\n      #if C_LIBBSC\r\n\tcase P_LIBBSC:\t   return bsc_decompress(in, inlen, out, outlen, BSC_MODE);\r\n\tcase P_LIBBSCC:\t   return bsc_coder_decompress(in, out, lev, BSC_MODE);\r\n\t  #endif\r\n\t\r\n\t  #if C_LIBDEFLATE\r\n\tcase P_LIBDEFLATE:  { size_t rc; struct libdeflate_decompressor *dd = libdeflate_alloc_decompressor(); \r\n            if(prm \u0026\u0026 *prm=='d') outlen = libdeflate_deflate_decompress(dd, in, inlen,out, outlen, \u0026rc);\r\n       else if(prm \u0026\u0026 *prm=='g') outlen = libdeflate_gzip_decompress(   dd, in, inlen,out, outlen, \u0026rc);\r\n       else                      outlen = libdeflate_zlib_decompress(   dd, in, inlen,out, outlen, \u0026rc);\r\n\t   libdeflate_free_decompressor(dd); \r\n       return outlen;\r\n\t  }\r\n\t  #endif\r\n\r\n      #if C_BZIP2 \t  \r\n \tcase P_BZIP2: { unsigned outsize = outlen; return BZ2_bzBuffToBuffDecompress((char *)out, \u0026outsize, (char *)in, inlen, 0, 0)==BZ_OK?outlen:-1; }\r\n      #endif\r\n\t  \r\n\t  #if C_CHAMELEON\r\n    case P_CHAMELEON:  { Chameleon_Reset((Chameleon *)workmem); lev\u003c2?Chameleon_Decode((Chameleon *)workmem, out, outlen, in):Chameleon2_Decode((Chameleon *)workmem, out, outlen, in); return inlen; }\r\n\t  #endif\r\n\r\n      #if C_CSC\r\n    case P_CSC: { \r\n        CSCProps prop; CSCDec_ReadProperties(\u0026prop, (uint8_t*)in);\r\n        MemISeqInStream  si; si.s.Read  = (int(*)(const ISeqInStream *, void *, size_t *))cscread;  si.in  = in + CSC_PROP_SIZE; si.inlen  = inlen - CSC_PROP_SIZE;\r\n\t    MemISeqOutStream so; so.s.Write = (size_t(*)(const ISeqOutStream *, const void *, size_t  ))cscwrite; so.out = out;                so.outlen = 0;\r\n\t    CSCDecHandle dh = CSCDec_Create(\u0026prop, (ISeqInStream*)\u0026si, NULL); CSCDec_Decode(dh, (ISeqOutStream*)\u0026so, NULL); CSCDec_Destroy(dh);\r\n        return si.inlen;\r\n      }\r\n      #endif\r\n\r\n     #if C_CRUSH\r\n    case P_CRUSH: crush_decompress(in, out, outlen); break;\r\n\t  #endif\r\n\t  \r\n      #if C_DAALA\r\n    case P_DAALA:   daaladec(in, inlen, out, outlen); return outlen;\r\n\t  #endif\r\n\r\n      #if C_DENSITY\r\n    case P_DENSITY: { density_processing_result rs = density_decompress((uint8_t *)in, inlen, (uint8_t*)out, outlen/*+DENSITY_MINIMUM_OUTPUT_BUFFER_SIZE*/);  return rs.state?0:rs.bytesWritten; }\r\n      #endif\r\n\r\n      #if C_FASTARI\r\n    case P_FASTARI:  { size_t outsize = outlen; return fa_decompress((const unsigned char *)in, out, inlen, \u0026outsize, workmem)?0:inlen; }\r\n      #endif\r\n\r\n      #if C_DOBOZ\r\n\tcase P_DOBOZ:   { doboz::Decompressor d; return d.decompress(in, inlen, out, outlen) == doboz::RESULT_OK ? outlen : -1; }\r\n      #endif\r\n\r\n\t  #if C_FASTLZ\r\n    case P_FASTLZ: fastlz_decompress(in, inlen, out, outlen); break;\r\n\t  #endif\r\n\t   \r\n \t  #if C_GIPFELI\r\n    case P_GIPFELI: { \r\n\t    util::compression::Compressor *c = util::compression::NewGipfeliCompressor();\r\n        util::compression::UncheckedByteArraySink sink((char*) out);\r\n        util::compression::ByteArraySource         src((const char*)in, inlen);\r\n        outlen = c-\u003eUncompressStream(\u0026src, \u0026sink); delete c; return outlen;\r\n\t  }  \r\n      break;\r\n\t  #endif\r\n\r\n\t  #if C_GLZA\r\n    case P_GLZA: { size_t outsize; GLZAdecode(inlen, (uint8_t *)in, \u0026outsize, (uint8_t *)out, (FILE *)0); break; }\r\n\t  #endif\r\n\r\n      #if C_HEATSHRINK\r\n    case P_HEATSHRINK: return hsdecompress(in, inlen, out, outlen); \r\n      #endif\r\n\r\n      #if C_IGZIP\r\n    case P_IGZIP: { struct inflate_state s; int rc; isal_inflate_init(\u0026s);\r\n         /*    if(prm \u0026\u0026 *prm == 'd') { s.crc_flag = ISAL_DEFLATE; }\r\n        else if(prm \u0026\u0026 *prm == 'g') { s.crc_flag = ISAL_GZIP; }\r\n        else s.crc_flag = ISAL_ZLIB;*/\r\n\t    s.next_in  = in;  s.avail_in  = inlen;\r\n\t    s.next_out = out; s.avail_out = outlen;\r\n\t    if((rc = isal_inflate_stateless(\u0026s)) != ISAL_DECOMP_OK) die(\"igzip error. rc=%d\\n\", rc);\r\n      } break;\r\n      #endif\r\n\r\n\t  #if C_LIBLZF \r\n    case P_LIBLZF: lzf_decompress(in, inlen, out, outlen); break;\r\n\t  #endif\r\n\r\n      #if C_SMALLZ4\r\n    case P_SMALLZ4: \r\n      if(!strchr(prm,'z')) { gip = in; giend = in+inlen; gop = out; unlz4(getbyte,sendbytes,NULL); break; }         \r\n      #endif \r\n\t  \r\n\t  #if C_LZ4ULTRA\r\n    case P_LZ4ULTRA: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if(strchr(prm,'z')) LZ4_decompress_safe((const char *)in, (char *)out, inlen, outlen);\r\n      if(!strchr(prm,'z')) {\r\n        unsigned nFlags = 0; \r\n        if(strchr(prm,'c')) nFlags |= LZ4ULTRA_FLAG_FAVOR_RATIO;\r\n        if(strchr(prm,'r')) nFlags |= LZ4ULTRA_FLAG_RAW_BLOCK;\r\n        if(strchr(prm,'i')) nFlags |= LZ4ULTRA_FLAG_INDEP_BLOCKS;\r\n        if(strchr(prm,'l')) nFlags |= LZ4ULTRA_FLAG_LEGACY_FRAMES;        \r\n        lz4ultra_decompress_inmem(in, out, inlen, outlen, nFlags);//lz4ultra_expand_block(in, inlen, out, 0, outlen); \r\n        break;\r\n      } // else fall throught to decompression with lz4\r\n \t  #endif\r\n\r\n\t  #if C_LZ4\r\n    case P_LZ4: \r\n      if(strchr(prm,'M')) { LZ4_decompress_safe((const char *)in, (char *)out, inlen, outlen); break; }\r\n      else {\r\n        lz4: LZ4F_dctx *ctx; LZ4F_createDecompressionContext(\u0026ctx, LZ4F_VERSION);\r\n        size_t ilen = inlen, olen = outlen, rc = LZ4F_decompress(ctx, out, \u0026olen, in, \u0026ilen, NULL);\r\n        LZ4F_freeDecompressionContext(ctx);\r\n        return rc;\r\n      } \r\n      #endif\r\n\r\n\t  #if C_LIZARD\r\n    case P_LIZARD: return Lizard_decompress_safe((const char *)in, (char *)out, inlen, outlen); \r\n      #endif\r\n\t  \r\n      #if C_LZFSE\r\n    case P_LZFSE : return lzfse_decode_buffer(out, outlen, in, inlen, workmem); \r\n      #endif\r\n\r\n      #if C_LZFSEA\r\n    case P_LZFSEA : return compression_decode_buffer(out, outlen, in, inlen, workmem, COMPRESSION_LZFSE);\r\n      #endif\r\n\r\n\t  #if C_LIBLZG\r\n\tcase P_LIBLZG: LZG_Decode(in, inlen, out, outlen); break;\r\n\t  #endif\r\n\t  \r\n      #if C_LIBZPAQ\r\n    case P_LIBZPAQ: { zin = in; zin_ = in+inlen; zout = out; libzpaq::decompress(\u0026zmemin, \u0026zmemout); return zin - in; }\r\n      #endif\r\n\r\n      #if C_LZHAM\r\n    case P_LZHAM: { lzham_decompress_params p; memset(\u0026p, 0, sizeof(p)); p.m_struct_size = sizeof(p);\r\n      p.m_dict_size_log2    = in[0];\r\n      size_t outl           = outlen;\r\n\t  lzham_uint32 adler32  = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n      return lzham_decompress_memory(\u0026p, (lzham_uint8*)out, \u0026outl, in+1, inlen, \u0026adler32) == LZHAM_COMP_STATUS_SUCCESS?outlen:-1;\t\r\n\t}\r\n      #endif\r\n\t  \r\n      #if C_LZLIB\r\n\tcase P_LZLIB: { long out_len = outlen; bbdecompress( in, outlen, out, \u0026out_len ); } break;\r\n      #endif \r\n\t  \r\n      #if C_FLZMA2\r\n    case P_FLZMA2: { return FL2_decompress(out, outlen,  in, inlen); }\r\n      #endif\r\n\r\n\t  #if C_LZMA\r\n\tcase P_LZMA: {  \r\n\t    SizeT ol = outlen, il = inlen - LZMA_PROPS_SIZE; ELzmaStatus sts;\r\n\t    return LzmaDecode(out, \u0026ol, in+LZMA_PROPS_SIZE, \u0026il, in, LZMA_PROPS_SIZE, LZMA_FINISH_END, \u0026sts, \u0026g_Alloc)?0:inlen;\r\n      }\r\n      #endif\r\n\r\n\t  #if C_LZMAT\r\n\tcase P_LZMAT:  { MP_U32 rc = outlen; lzmat_decode(out, \u0026rc, in, inlen); return rc; }  \r\n\t  #endif\r\n\t    \r\n\t  #if C_LZO\r\n    case P_LZO1x: { lzo_uint out_len;   lzo1x_decompress(in, inlen, out, \u0026out_len, NULL); break; }\r\n    case P_LZO1b: { lzo_uint out_len;   lzo1b_decompress(in, inlen, out, \u0026out_len, NULL); break; }\r\n    case P_LZO1c: { lzo_uint out_len;   lzo1c_decompress(in, inlen, out, \u0026out_len, NULL); break; }\r\n    case P_LZO1f: { lzo_uint out_len;   lzo1f_decompress(in, inlen, out, \u0026out_len, NULL); break; }\r\n    case P_LZO1y: { lzo_uint out_len;   lzo1y_decompress(in, inlen, out, \u0026out_len, NULL); break; }\r\n    case P_LZO1z: { lzo_uint out_len;   lzo1z_decompress(in, inlen, out, \u0026out_len, NULL); break; }    \r\n    case P_LZO2a: { lzo_uint out_len;   lzo2a_decompress(in, inlen, out, \u0026out_len, NULL); break; }\r\n      #endif \r\n\r\n\t  #if C_LZOMA\r\n\tcase P_LZOMA:   lzomaunpack(in, inlen, out, outlen);break;\r\n      #endif\r\n\r\n      #if _MINIZ\r\n    case P_MINIZ: { uLongf outsize = outlen; int rc = mz_uncompress(out, \u0026outsize, in, inlen); } break;\r\n      #endif\r\n\r\n      #if C_NAKA\r\n    case P_NAKA:    return NakaDecompress((char *)out, (char *)in, inlen); \r\n      #endif\r\n\t  #if C_PITHY\r\n    case P_PITHY: return pithy_Decompress((const char *)in, inlen, (char *)out, outlen);\r\n      #endif  \t\r\n\r\n      #if C_QUICKLZ\r\n    case P_QUICKLZ: { lev= (in[0]\u003e\u003e2)\u00263; outlen = lev\u003c=1?qlz_decompress1((char*)in, out, workmem):(lev\u003c=2?qlz_decompress2((char*)in, out, workmem):qlz_decompress3((char*)in, out, workmem)); } break;\r\n      #endif\r\n\t  \r\n\t  #if C_SAP\r\n    case P_SAP: { CsObjectInt d; SAP_INT bytes_read, bytes_written; \r\n\t    d.CsInitDecompr((SAP_BYTE *)in); in += CS_HEAD_SIZE; d.CsDecompr( (SAP_BYTE *)in, inlen-CS_HEAD_SIZE, (SAP_BYTE *)out, outlen, lev, \u0026bytes_read, \u0026bytes_written );\t\t\t \r\n\t    return inlen-CS_HEAD_SIZE; \r\n\t  }\r\n      #endif  \t\r\n\r\n      #if C_ZLING\r\n    case P_ZLING: zling_decompress(in, inlen, out, outlen); break;\r\n      #endif\r\n\r\n\t  #if C_LZSA\r\n\tcase P_LZSA:  { \r\n      unsigned nFlags = 0; int nFormatVersion=1; \r\n      if(strchr(prm,'c')) nFlags |= LZSA_FLAG_FAVOR_RATIO;\r\n      if(strchr(prm,'r')) nFlags |= LZSA_FLAG_RAW_BLOCK;\r\n      if(strchr(prm,'f')) nFormatVersion = 2;\r\n      lzsa_decompress_inmem(in, out, inlen, outlen, nFlags, \u0026nFormatVersion);\r\n      break;\r\n    }\r\n      #endif\r\n\r\n\t  #if C_LZSS\r\n    case P_LZSS: lzss_decode(in, out, outlen); break;\r\n\t  #endif\r\n\r\n\t  #if C_LZSSE\r\n        #ifdef __x86_64__\r\n\tcase P_LZSSE2: return LZSSE2_Decompress(in,inlen,out,outlen);\r\n\tcase P_LZSSE4: return LZSSE4_Decompress(in,inlen,out,outlen);\r\n\tcase P_LZSSE8: return LZSSE8_Decompress(in,inlen,out,outlen);\r\n\t    #endif\r\n\t  #endif\r\n\r\n      #if C_MSCOMPRESS\r\n     case P_MSCOMPRESS: { size_t _outlen=outlen; return ms_decompress((MSCompFormat)lev, in, inlen, out, \u0026_outlen)==MSCOMP_OK?inlen:0; }\r\n      #endif\t \r\n\r\n\t  #if C_SHOCO\r\n    case P_SHOCO:     shoco_decompress((const char *)in, inlen, (char *)out, outlen); return inlen;\r\n      #endif  \t\r\n\r\n\t  #if C_SHRINKER\r\n    case P_SHRINKER:    shrinker_decompress(in, out, outlen); break;\r\n\t  #endif\r\n\t   \r\n\t  #if C_SNAPPY\r\n        #if __cplusplus\r\n    case P_SNAPPY: snappy::RawUncompress((char*)in, inlen, (char*)out);  break;\r\n        #else \r\n    case P_SNAPPY: snappy_uncompress(in, inlen, out, \u0026outlen);\t\r\n        #endif\r\n\t  #endif\t\r\n\t  \r\n\t  #if C_SNAPPY_C \r\n\tcase P_SNAPPY_C: return snappy_uncompress((const char *)in, inlen, (char *)out);\r\n\t  #endif  \r\n\t  \r\n      #if C_TORNADO\r\n    case P_TORNADO:     return tordecompress(in, out, inlen, outlen);\r\n      #endif\r\n\t  \r\n      #if C_ULZ\r\n    case P_ULZ: { ULZ ulz; return ulz.Decompress(in, inlen, out, outlen); }\r\n      #endif\r\n\r\n      #if C_WFLZ\r\n    case P_WFLZ:    wfLZ_Decompress( in, out); return inlen;\r\n\t  #endif\r\n\r\n      #if C_WIMLIB\r\n    case P_WIMLIB: { struct wimlib_decompressor *decompressor; if(wimlib_create_decompressor(lev, 32*1024/*inlen*/, \u0026decompressor)) return 0;\r\n        outlen = wimlib_decompress(in, inlen, out, outlen, decompressor);  wimlib_free_decompressor(decompressor); return inlen;\r\n      }\r\n\t  #endif\r\n \r\n      #if C_WKDM\r\n    case P_WKDM:    WKdm_decompress ((WK_word*)in, (WK_word*)out, outlen);\r\n\t  #endif \r\n\r\n\t  #if C_XPACK\r\n\tcase P_XPACK:  { size_t rc; struct xpack_decompressor *dd = xpack_alloc_decompressor(); \r\n\t    outlen = xpack_decompress(dd, in, inlen,out, outlen, \u0026rc); \r\n\t    xpack_free_decompressor(dd); return outlen;\r\n\t  } \r\n\t  #endif\r\n\r\n      #if C_YALZ77\r\n    case P_YALZ77: { lz77::decompress_t d; std::string extra; if(!d.feed(in,in+inlen,extra) || extra.size() \u003e 0) return 0;\r\n        const std::string\u0026 os = d.result(); memcpy(out, os.c_str(), os.size()); return os.size(); \r\n\t  }\r\n\t  #endif\r\n\r\n\t  #if C_YAPPY\r\n\tcase P_YAPPY:    return YappyUnCompress(in, in+inlen, out)-out; \r\n      #endif\r\n\t  \r\n\t  #if C_LIBSLZ\r\n\tcase P_LIBSLZ: {       \r\n      struct slz_stream strm;\r\n      int fmt=15; \r\n            if(prm \u0026\u0026 *prm == 'd') fmt=-15;\r\n       else if(prm \u0026\u0026 *prm == 'g') fmt=15|32;\r\n       z_stream z; \r\n       memset(\u0026z, 0, sizeof(z));\r\n       z.next_in   = in; \r\n       z.avail_in  = inlen; \r\n       z.next_out  = out; \r\n       z.avail_out = outlen;\r\n       if(inflateInit2(\u0026z, fmt) == Z_OK) { \r\n         if(inflate(\u0026z, Z_SYNC_FLUSH) == Z_STREAM_END)\r\n           inflateEnd(\u0026z);\r\n       } \r\n    } break;\r\n      #endif  \t \r\n\r\n      #if C_ZLIB  \r\n    //case P_IGZIP: case P_LIBDEFLATE:\r\n      #if C_ZLIBNG == 0\r\n    case P_ZOPFLI:\r\n      #endif\r\n    case P_ZLIB: { uLongf outsize = outlen; int rc = uncompress(out, \u0026outsize, in, inlen); } break;\r\n      #endif\r\n\r\n      #if C_ZLIBNG\r\n    case P_ZOPFLI:\r\n    case P_ZLIBNG: { uLongf outsize = outlen; int rc = zng_uncompress(out, \u0026outsize, in, inlen); } break;\r\n      #endif\r\n\r\n      #if C_ZSTD\r\n    case P_ZSTD: if(strchr(prm,'D')) {\r\n                   unsigned const expectedDictID = ZSTD_getDictID_fromDDict(ddictPtr);\r\n                   unsigned const actualDictID   = ZSTD_getDictID_fromFrame(in, inlen);\r\n                   if(actualDictID != expectedDictID) { printf(\"ZSTD: DictID mismatch: expected %u got %u\", expectedDictID, actualDictID); return 0; }\r\n                   ZSTD_DCtx *ctx = ZSTD_createDCtx();\r\n                   inlen = ZSTD_decompress_usingDDict(ctx, out, outlen, in, inlen, ddictPtr);\r\n                   ZSTD_freeDCtx(ctx);   \r\n                } else ZSTD_decompress( out, outlen, in, inlen);\r\n      break;\r\n      #endif\r\n      //------------ Encoding -----------------------------------------------------------------------\r\n      #if C_RLE\r\n    case P_RLES:\r\n      switch(lev) {\r\n        case  0: return  srled( in, inlen, out, outlen); \r\n        case  8: return  srled8( in, inlen, out, outlen, _ESC8); \r\n        case 16: return  srled16(in, inlen, out, outlen, _ESC16); \r\n        case 32: return  srled32(in, inlen, out, outlen, _ESC32);\r\n        case 64: return  srled64(in, inlen, out, outlen, _ESC64);\r\n      } break;\r\n    case P_RLET: return trled(in, inlen, out, outlen); \r\n    case P_RLEM: return mrled(in, out, outlen); \r\n      #endif \r\n\r\n      #if C_RLE8\r\n    case P_RLE8: \r\n      switch(lev) {\r\n        case  1 : { int subSections = 0; char *q; if(q=strchr(prm,'S')) subSections = atoi(q+(q[1]=='='?2:1)); return subSections?rle8m_decompress(in, inlen, out, outlen):rle8_decompress(in, inlen, out, outlen); }\r\n        case  2 : return    rle8_ultra_decompress(in, inlen, out, outlen);\r\n        case  8 : return  rle8_extreme_decompress(in, inlen, out, outlen);\r\n        case 16 : return rle16_extreme_decompress(in, inlen, out, outlen);\r\n        case 24 : return rle24_extreme_decompress(in, inlen, out, outlen);\r\n        case 32 : return rle32_extreme_decompress(in, inlen, out, outlen);\r\n        case 48 : return rle48_extreme_decompress(in, inlen, out, outlen);\r\n        case 64 : return rle64_extreme_decompress(in, inlen, out, outlen);\r\n     }\r\n      #endif\r\n\r\n\t  #if C_B64\r\n    case P_B64_PLAIN:  { size_t outlen; base64_decode(in, inlen, out, \u0026outlen, BASE64_FORCE_PLAIN);  return inlen; }\r\n    case P_B64_SSSE3:  { size_t outlen; base64_decode(in, inlen, out, \u0026outlen, BASE64_FORCE_SSSE3);  return inlen; } \r\n    case P_B64_SSE41:  { size_t outlen; base64_decode(in, inlen, out, \u0026outlen, BASE64_FORCE_SSE41);  return inlen; }\r\n    case P_B64_AVX:    { size_t outlen; base64_decode(in, inlen, out, \u0026outlen, BASE64_FORCE_AVX);    return inlen; }\r\n    case P_B64_AVX2:   { size_t outlen; base64_decode(in, inlen, out, \u0026outlen, BASE64_FORCE_AVX2);   return inlen; }\r\n    case P_B64_NEON64: { size_t outlen; base64_decode(in, inlen, out, \u0026outlen, BASE64_FORCE_NEON64); return inlen; }\r\n\t  #endif\r\n\r\n      //------------ Transform -----------------------------------------------------------------------\r\n\t  #if C_TB64 \r\n\tcase P_TB64:    return tb64dec(     in, inlen, out);\r\n\tcase P_TB64S:   return tb64sdec(    in, inlen, out); \r\n\tcase P_TB64X:   return tb64xdec(    in, inlen, out); \r\n        #ifdef __ARM_NEON\r\n    case P_TB64NEON:  \r\n        #else\r\n    case P_TB64AVX: return tb64avxdec(  in, inlen, out);\r\n\t      #ifdef AVX2_ON\r\n    case P_TB64AVX2: return tb64avx2dec(in, inlen, out);\r\n\t      #endif\r\n        #endif\r\n    case P_TB64SSE: return tb64ssedec(  in, inlen, out);\r\n      #endif\r\n\r\n      #if C_DIVBWT\r\n    case P_DIVBWT: memcpy(out, in+4, outlen); bsc_bwt_decode(out, outlen, *(unsigned *)in, 0, NULL, 0); return inlen;\r\n    case P_ST: {   memcpy(out, in+4, inlen-4); bsc_st_decode(out, inlen-4, lev, *(unsigned *)(in), 0); break; }\r\n      #endif\r\n\r\n      #if C_BRC\r\n    case P_BRC: if(lev) { struct brc_cxt_s brc_cxt; size_t o; brc_init_cxt(\u0026brc_cxt, outlen); brc_cxt.size = inlen; memcpy(brc_cxt.block, in, inlen); brc_decode(\u0026brc_cxt, out, \u0026o); brc_free_cxt(\u0026brc_cxt); return inlen; }\r\n                else return vsrc_reverse(in, out, inlen);\r\n      #endif\r\n\t  #if C_FB64\r\n        #ifdef AVX2_ON\r\n\tcase P_FB64AVX2:      fast_avx2_base64_decode(out, in,inlen);return inlen;\r\n\tcase P_FB64KLOMP:    { size_t _outlen = outlen; klomp_avx2_base64_decode( (const char *)in, inlen, (char *)out, \u0026_outlen); return inlen; }\r\n\t    #endif\r\n\r\n\tcase P_FB64CHROMIUM:  chromium_base64_decode( (char*)out,(const char*)in,inlen); return inlen;\r\n\tcase P_FB64LINUX:     linux_base64_decode(    (char*)out,(const char*)in,(const char*)in+inlen); return inlen;\r\n\tcase P_FB64PLAIN:   { size_t _outlen = outlen; scalar_base64_decode(\t (const char*)in,inlen,(char*)out,\u0026_outlen);return inlen; }\r\n        #ifdef __ARM_NEON \r\n\tcase P_FB64NEON:      neon_base64_decode(out, in,inlen);return inlen;\r\n        #endif\r\n\t  #endif\r\n\r\n\t  #if C_SB64\r\n\tcase P_SB64SSE:  base64::sse::decode(base64::sse::lookup_base, in, inlen, out); return inlen;\r\n\t  #endif\r\n  \r\n      //------------ Entropy Coders ------------------------------------------------------------------\r\n      #if C_MEMCPY \r\n    case P_MCPY:     memcpy(out, in, inlen);  break;\r\n    case P_LMCPY: libmemcpy(out, in, outlen); break;\r\n      #endif\r\n\r\n      #if C_BCMEC\r\n\tcase P_BCMEC:   return bcmdec(in, inlen, out, outlen);\r\n\t  #endif\r\n\r\n\t  #if C_FASTAC\r\n    case P_FASTAC: {\r\n\t    Adaptive_Data_Model adaptive_model(SYMNUM); \r\n        adaptive_model.set_alphabet(SYMNUM); \r\n        adaptive_model.reset(); \r\n        Arithmetic_Codec decoder(outlen, in); \r\n        decoder.start_decoder();   \r\n        for(int i = 0; i \u003c outlen; i++) \r\n\t\t  out[i] = (unsigned char)(decoder.decode(adaptive_model));\r\n        decoder.stop_decoder();\r\n        return outlen;\r\n      }\r\n      #endif\r\n\r\n\t  #if C_FASTHF\r\n    case P_FASTHF: { \r\n\t    Adaptive_Huffman_Code adaptive_model(SYMNUM); \r\n        adaptive_model.set_alphabet(SYMNUM); adaptive_model.reset(); \r\n        Binary_Codec decoder(outlen, in);\r\n        decoder.start_decoder();\r\n        for(int i = 0; i \u003c outlen; i++) \r\n          out[i] = (unsigned char)(decoder.decode(adaptive_model));\r\n        decoder.stop_decoder();\r\n      } break;\r\n      #endif\r\n\t  \r\n      #if C_FPC\r\n    case P_FPC:  return FPC_decompress(out,outlen,in,inlen); \r\n      #endif\r\n\r\n\t  #if C_FSC\r\n    case P_FSC:     { size_t outsize = 0; uint8_t *op = NULL; int ok = FSCDecode(in, inlen, \u0026op, \u0026outsize); if(ok) { memcpy(out,op,outlen); free(op); } } break;\r\n\t  #endif\r\n \r\n\t  #if C_FSE\r\n    case P_FSE:  if(inlen == outlen) memcpy(out, in, outlen); else if(inlen == 1) memset(out,in[0],outlen); else FSE_decompress(out, outlen, in, inlen); break;\r\n    case P_FSEH: if(inlen == outlen) memcpy(out, in, outlen); else if(inlen == 1) memset(out,in[0],outlen); else HUF_decompress(out, outlen, in, inlen); break;\r\n\t  #endif\r\n\t\t\r\n      #if C_FQZ\r\n\tcase P_FQZ0: uncompress_block(in, out, outlen); break;\r\n\t  #endif\r\n\r\n      #if C_JAC\r\n    case P_JAC:  { unsigned outlen; arith_uncompress_O0(in, inlen, \u0026outlen, out); } break;\r\n      #endif\r\n\r\n\t  #if C_RANS_S\r\n    case P_RANS_S8   : rans_uncompress_to(    8,in, inlen, out, (unsigned *)\u0026outlen, lev); break;\r\n    case P_RANS_S16  : rans_uncompress_to(   16,in, inlen, out, (unsigned *)\u0026outlen, lev); break;\r\n\t    #ifdef AVX2_ON\t \r\n    case P_RANS_S32  : rans_uncompress_to_32x16(in, inlen, out, (unsigned *)\u0026outlen, lev); break;\r\n\t    #endif\r\n\t  #endif\r\n\r\n      #if C_FPAQC\r\n    case P_FPAQC:   absd(in, outlen, out); break;\r\n      #endif\r\n\r\n      #if C_MMRC     \r\n    case P_O0ZP:    rczmmd(in, outlen, out); break;\r\n    case P_FPAQ0F2: rcmm2d(in, outlen, out); break;\r\n    case P_MMRC:    rcmmd( in, outlen, out); break;\r\n      #endif\r\n\r\n\t  #if C_MARLIN\r\n    case P_MARLIN:  Marlin_decompress((Marlin *)workmem, (uint8_t*)out, outlen, in, inlen); /*Marlin_free_dictionary((Marlin *)workmem);*/ break;\r\n\t  #endif\r\n\r\n      #if C_NANS\r\n    case P_NANS:    nansdec(in, inlen, out, outlen); break;\r\n\t  #endif\r\n\r\n       #if C_NIBRANS\r\n    case P_NIBRANS: { struct nibrans nbra; nibransInit(\u0026nbra); return nibransDecode(\u0026nbra, out, outlen, in, inlen); }\r\n      #endif\r\n\r\n     #if C_PPMDEC\r\n\tcase P_PPMDEC:  return ppmddec(in, inlen, out, outlen);\r\n\t  #endif\r\n\r\n      #if C_POLHF\r\n    case P_POLHF:   polardec(in, out, outlen); break;\r\n      #endif\r\n\r\n      #if C_SHRC\r\n    case P_SHRCV:   vecrcdec(in, outlen, out); break;\r\n    case P_SHRC:    rcshd(in, out, outlen); break;\r\n      #endif\r\n\r\n      #if C_SUBOTIN\r\n    case P_SUB:     subdec(in, outlen, out, outlen, SYMNUM); break;\r\n      #endif\r\n\r\n      #if C_TORNADOHF\r\n    case P_TORNADOHF:    torhdec(in, inlen, out, outlen); break;\r\n      #endif \r\n\r\n      #if C_TURBORC\r\n    case P_TURBORC: {\r\n      switch(lev) {\r\n        case 11 : return rcsdec(   in, outlen, out);\r\n        case 12 : return rcsxdec(  in, outlen, out);\r\n        case 13 : return rcssdec(  in, outlen, out);\r\n        case 14 : return rcssxdec( in, outlen, out);\r\n\r\n        case 21 : return rcrlesdec(   in, outlen, out);\r\n        case 22 : return rcrlesxdec(  in, outlen, out);\r\n        case 23 : return rcrlessdec(  in, outlen, out);\r\n        case 24 : return rcrlessxdec( in, outlen, out);\r\n\r\n        case 30 : return rcgsdec8(    in, outlen, out);\r\n        case 31 : return rcgsdec16(   in, outlen, out);\r\n        case 32 : return rcgsdec32(   in, outlen, out);\r\n        case 33 : return rcgssdec8(   in, outlen, out);\r\n        case 34 : return rcgssdec16(  in, outlen, out);\r\n        case 35 : return rcgssdec32(  in, outlen, out);\r\n//        case 2 : return trcndec( in, outlen, out);\r\n      }\r\n\t}\r\n      #endif \r\n\t  \r\n\t  #if C_ZLIB\t\r\n    case P_ZLIBH: { unsigned char *out_=out+outlen,*ip=in,*op; unsigned oplen;//return ZLIBH_decompress((char* )out, (const char*)in);\r\n      for(op = out; op != out+outlen; op+=oplen) { oplen = min(out_-op,lev*1024);\r\n        z_stream z; memset(\u0026z, 0, sizeof(z));\r\n        if(inflateInit2(\u0026z, -15) == Z_OK) {\r\n          z.avail_in  = ctou16(ip);   ip+=2;\r\n          z.next_in   = ip;           ip+=z.avail_in;\r\n          z.next_out  = op; \r\n          z.avail_out = outlen;\r\n          if(inflate(\u0026z, Z_SYNC_FLUSH) != Z_STREAM_END) break; //op += outlen - z.avail_out;\r\n          inflateEnd(\u0026z);\r\n        } \r\n      }\r\n    } break;\r\n\t  #endif\t\r\n\r\n\t  #if C_ZLIB\t\t\r\n    case P_ZRLE: { z_stream z; memset(\u0026z, 0, sizeof(z));\r\n      if(inflateInit2(\u0026z, -15) == Z_OK) {\r\n        z.next_in   = in;\r\n        z.avail_in  = inlen;\r\n        z.next_out  = out; \r\n        z.avail_out = outlen;\r\n        if(inflate(\u0026z, Z_SYNC_FLUSH) != Z_STREAM_END) break; \r\n        inflateEnd(\u0026z);\r\n      }\r\n    } break;\r\n\t  #endif\t\r\n\r\n      #ifdef LZTURBO  \r\n    #include \"../dev/x/beplugd.c\"\r\n      #endif\r\n\r\n      #if C_MYCODEC \r\n//   case P_MYCODEC:   return mydecomp(in, inlen, out, outlen);\r\n\t  #endif\t\r\n  }\r\n  return NULL;\r\n}","filepath":"plugins.cc","line_number":2052,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4397360":{"score":0.82620406,"function_name":"codver","code":"char *codver(int codec, char *v, char *s) {\r\n  switch(codec) {  \r\n      #if C_C_BLOSC2\r\n    return BLOSC_VERSION_STRING;\r\n      #endif \r\n\t  #if C_BRIEFLZ\r\n    case P_BRIEFLZ: sprintf(s,\"%d.%d.%d\", BLZ_VER_MAJOR, BLZ_VER_MINOR, BLZ_VER_PATCH); break;\r\n\t  #endif\r\n\r\n\t  #if C_LZ4\r\n    case P_LZ4:     sprintf(s,\"%d.%d.%d\", LZ4_VERSION_MAJOR, LZ4_VERSION_MINOR, LZ4_VERSION_RELEASE); break;\r\n\t  #endif\r\n\r\n\t  #if C_LIZARD\r\n    case P_LIZARD:     sprintf(s,\"%d.%d.%d\", LIZARD_VERSION_MAJOR, LIZARD_VERSION_MINOR, LIZARD_VERSION_RELEASE); break;\r\n\t  #endif\r\n\r\n\t  #if C_ZSTD\r\n    case P_ZSTD:    sprintf(s,\"%d.%d.%d\", ZSTD_VERSION_MAJOR, ZSTD_VERSION_MINOR, ZSTD_VERSION_RELEASE); break;\r\n      #endif\r\n\r\n\t  #if C_DENSITY\r\n    case P_DENSITY: sprintf(s,\"%d.%d.%d\", density_version_major(), density_version_minor(), density_version_revision()); break;\r\n\t  #endif\r\n\r\n      #if C_HEATSHRINK\r\n    case P_HEATSHRINK: sprintf(s,\"%d.%d.%d\", HEATSHRINK_VERSION_MAJOR, HEATSHRINK_VERSION_MINOR, HEATSHRINK_VERSION_PATCH); break;\r\n      #endif\r\n\r\n\t  #if C_SNAPPY\r\n    case P_SNAPPY:  sprintf(s,\"%d.%d.%d\", SNAPPY_MAJOR, SNAPPY_MINOR, SNAPPY_PATCHLEVEL); break;\r\n\t  #endif\r\n      #if C_ZLIB\r\n    case P_ZLIB:\r\n      sprintf(s,zlib_version); break;\r\n      #endif\r\n      #if C_ZLIBNG\r\n    case P_ZLIBNG:\r\n      sprintf(s,zlibng_version()); break;\r\n      #endif\r\n\tdefault:        strcpy(s,v);\r\n  }\r\n  return s;\r\n}","filepath":"plugins.cc","line_number":2676,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2019-12"},"4397872":{"score":0.7501438,"function_name":"libcmpn","code":"int libcmpn(const struct plug *e1, const struct plug *e2) {\n  int c = strcmp(e1-\u003es, e2-\u003es);\n  if(c \u003c 0)\n    return -1;\n  else if(c \u003e 0)\n    return 1;\n  else if(e1-\u003elev \u003c e2-\u003elev)\n    return -1;\n  else if(e1-\u003elev \u003e e2-\u003elev)\n    return 1;\n  return 0;\n}","filepath":"turbobench.c","line_number":831,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4397952":{"score":0.64069307,"function_name":"libcmp","code":"int libcmp(const struct plug *e1, const struct plug *e2) {\n  if(e1-\u003elen \u003c e2-\u003elen)\n    return -1;\n  else if(e1-\u003elen \u003e e2-\u003elen)\n    return 1;\n  else if(e1-\u003etd \u003c e2-\u003etd)\n    return -1;\n  else if(e1-\u003etd \u003e e2-\u003etd)\n    return 1;\n  return 0;\n}","filepath":"turbobench.c","line_number":819,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398016":{"score":0.88038963,"function_name":"strpref","code":"int strpref(const char *const *str, int n, char sep1, char sep2) {\n  int i, j=0;\n  for(;;j++)\n    for(i = 0; i \u003c n; i++)\n \t  if(!str[i][j] || str[i][j] != str[0][j]) {\n\t    while (j \u003e 0 \u0026\u0026 str[0][j-1] != sep1 \u0026\u0026 str[0][j-1] != sep2) j--;\n\t    return j;\n\t  }\n  return 0;\n}","filepath":"turbobench.c","line_number":66,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398144":{"score":0.8687248,"function_name":"memcheck","code":"int memcheck(unsigned char *in, unsigned n, unsigned char *cpy, int cmp, char *finame) { \n  int i;\n  if(cmp \u003c= 1) \n    return 0;\n  for(i = 0; i \u003c n; i++)\n    if(in[i] != cpy[i]) {\n      if(cmp \u003e 3) abort(); // crash (AFL) fuzzing\n      printf(\"ERROR at %d:%x, %x file=%s\\n\", i, in[i], cpy[i], finame);\n      if(cmp \u003e 2) exit(EXIT_FAILURE);      \n\t  return i+1; \n\t}\n  return 0;\n}","filepath":"turbobench.c","line_number":77,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398288":{"score":0.8546506,"function_name":"_valloc","code":"void *_valloc(size_t size, unsigned a) {\n  if(!size) return NULL;\n    #if defined(_WIN32)\n  return VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n    #elif defined(USE_MMAP)\n  void *ptr = mmap(NULL/*0(size_t)a\u003c\u003cMAP_BITS*/, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n  if(ptr == MAP_FAILED) return NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  return ptr;\n    #else\n  return malloc(size); \n    #endif\n}","filepath":"turbobench.c","line_number":98,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398368":{"score":0.9492595,"function_name":"_vfree","code":"void _vfree(void *p, size_t size) {\n  if(!p) return;\n    #if defined(_WIN32)\n  VirtualFree(p, 0, MEM_RELEASE);\n    #elif defined(USE_MMAP)\n  munmap(p, size);\n    #else\n  free(p);\n    #endif\n}","filepath":"turbobench.c","line_number":111,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398528":{"score":0.89341396,"function_name":"malloc","code":"void *malloc(size_t size) {\n  if(!mem_malloc) {\n    void *p = mem_heapp;\n    if((mem_heapp += size) \u003e= mem_heap+sizeof(mem_heap)) \n      die(\"malloc:initial memory overflow\\n\");\n    return p;       \n  }\n  void *p = (*mem_malloc)(size);\n  if(p) \n    mem_add(malloc_usable_size(p)); \n  return p;\n}","filepath":"turbobench.c","line_number":163,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398688":{"score":0.8921039,"function_name":"calloc","code":"void *calloc(size_t nmemb, size_t size) { \n  size_t _size = nmemb*size;\n  if(!mem_calloc) {\n    void *p = mem_heapp;\n    if((mem_heapp += _size) \u003e= mem_heap+sizeof(mem_heap)) \n      die(\"calloc:initial memory overflow\\n\");\n    memset(p,0,_size);\n    return p;       \n  }\n  void *p = (*mem_calloc)(nmemb, size);\n  if(p) \n    mem_add(malloc_usable_size(p)); \n  return p;\n}","filepath":"turbobench.c","line_number":176,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398864":{"score":0.7983159,"function_name":"memalign","code":"void *memalign(size_t nmemb, size_t size) { \n  size_t _size = nmemb*size;\n\n  mem_add(_size);\n  void *p = (*mem_memalign)(nmemb, size);      \n  if(p) \n    mem_add(malloc_usable_size(p)); \n  return p;\n}","filepath":"turbobench.c","line_number":191,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4398976":{"score":0.581377,"function_name":"memalign","code":"void *memalign(size_t nmemb, size_t size) { \n  size_t _size = nmemb*size;\n\n  mem_add(_size);\n  void *p = (*mem_memalign)(nmemb, size);      \n  if(p) \n    mem_add(malloc_usable_size(p)); \n  return p;\n}","filepath":"turbobench.c","line_number":191,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4399104":{"score":0.6617546,"function_name":"malloc","code":"void *malloc(size_t size) {\n  if(!mem_malloc) {\n    void *p = mem_heapp;\n    if((mem_heapp += size) \u003e= mem_heap+sizeof(mem_heap)) \n      die(\"malloc:initial memory overflow\\n\");\n    return p;       \n  }\n  void *p = (*mem_malloc)(size);\n  if(p) \n    mem_add(malloc_usable_size(p)); \n  return p;\n}","filepath":"turbobench.c","line_number":163,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4399392":{"score":0.7021668,"function_name":"plugsprt","code":"void plugsprt(void) {\n  struct plugs *gs;\n\n    #if defined(_COMPRESS1) || defined(_COMPRESS2)\n  struct plugg *pg; \n  printf(\"Codec group:\\n\");\n  for(pg = plugg; pg \u003c plugg+PLUGGSIZE; pg++) \n    printf(\"%-16s %s %s\\n\", pg-\u003eid, pg-\u003edesc);\n    #endif\n\n    #if defined(_ECODEC)\n  printf(\"\\nEntropy Coder group: 'ECODER' entropy coders\\n\");\n    #endif\n\n  printf(\"\\nPlugins:\\n\");\n  for(gs = plugs; gs-\u003eid \u003e= 0; gs++) \n    if(gs-\u003ecodec)\n      { printf(\"%s %s\\n\", gs-\u003es, gs-\u003elev?gs-\u003elev:\"\"); fflush(stdout);}\n}","filepath":"turbobench.c","line_number":264,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4399504":{"score":0.91086197,"function_name":"plugsprtv","code":"void plugsprtv(FILE *f, int fmt) {\n  struct plugs *gs;\n  char         *pv = \"\";\n\n  switch(fmt) {\n    case FMT_HTMLT: \n    case FMT_HTML: \n      printf(\"%s\\n\", \"\u003chtml\u003e\u003chead\u003e\u003cmeta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\"\u003e\u003ctitle\u003eTurboBench\u003c/title\u003e\u003c/head\u003e\u003cbody\u003e\u003cpre\u003e\u003cul\u003e\"); \n      break;\n    case FMT_VBULLETIN:\n    case FMT_VBULLETIN2:\n      fprintf(f,\"[list]\\n\"); \n      break;\n  }\n\n  for(gs = plugs; gs-\u003eid \u003e= 0; gs++)\n    if(gs-\u003ecodec \u0026\u0026 strcmp(gs-\u003ename,pv)) {\n      pv = gs-\u003ename;\n\t  char name[65]; //,ver[33]; ver[0] = 0; codver(gs-\u003eid, gs-\u003ever, ver);  \n      sprintf(name, \"%s\", gs-\u003ename);\n      switch(fmt) {  \n         case FMT_VBULLETIN: \n         case FMT_VBULLETIN2: \n          fprintf(f, \"[*]%s\\n\", name ); \n          break;\n        case FMT_HTML     : \n          fprintf(f, \"\u003cli\u003e%s\\n\", name ); \n          break;\n        case FMT_MARKDOWN :\n          fprintf(f, \" - %s\\n\", name ); \n          break;\n        default:\n          fprintf(f, \"%-24s\\n\", name);\n      }\n    }\n\n  switch(fmt) {\n    case FMT_VBULLETIN:\n    case FMT_VBULLETIN2:\n      fprintf(f,\"[/list]\\n\"); \n      break;\n    case FMT_HTML:\n      fprintf(f,\"\u003c/ul\u003e\u003c/pre\u003e\u003c/body\u003e\u003c/html\u003e\"); \n      break;\n  }\n}","filepath":"turbobench.c","line_number":284,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4400048":{"score":0.907403,"function_name":"plugins","code":"int plugins(struct plug *plug, struct plugs *gs, int *pk, unsigned bsize, int bsizex, int lev, char *prm) { \n  int i,k = *pk;\n  for(i = 0; i \u003c k; i++) \n    if(plug[i].id == gs-\u003eid \u0026\u0026 plug[i].lev == lev \u0026\u0026 !strcmp(plug[i].prm,prm))\n      return -1;\n  if(k \u003e= PLUGN) \n    die(\"Too many codecs specified\\n\");\n  memset(\u0026plug[k], 0, sizeof(struct plug)); \n  plug[k].id  = gs-\u003eid; \n  plug[k].err = 0; \n  plug[k].s   = gs-\u003es; \n  plug[k].lev = lev; \n  strncpy(plug[k].prm, prm?prm:(char *)\"\", PRM_SIZE); plug[k].prm[PRM_SIZE] = 0;\n  plug[k].tms[0]  = 0;\n  if(gs-\u003eflag \u0026 E_ANS)  \n    plug[k].blksize = seg_ans;\n  else if(gs-\u003eflag \u0026 E_HUF) \n    plug[k].blksize = seg_huf;\n  else plug[k].blksize = gs-\u003eblksize \u0026\u0026 !bsizex?gs-\u003eblksize:bsize;\n  *pk = ++k;\n  return 0;\n}","filepath":"turbobench.c","line_number":348,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4400464":{"score":0.8457843,"function_name":"plugreg","code":"int plugreg(struct plug *plug, char *cmd, int k, int bsize, int bsizex) {\n  static char *cempty=\"\"; \n  int ignore = 0;\n\n  while(*cmd) { \n    while(isspace(*cmd)) \n      cmd++; \n    char *name = cmd; \n    while(isalnum(*cmd) || *cmd == '_' || *cmd == '-') \n      cmd++; \n    if(*cmd) *cmd++ = 0;\n\n    if(!strcmp(name, \"ON\" )) { \n      ignore = 1; \n      continue; \n    }\n    else if(!strcmp(name, \"OFF\")) { \n      ignore = 0; \n      continue; \n    }\n\n    for(;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n      while(isspace(*cmd) || *cmd == ',') \n        cmd++;\n\n      char *prm = cmd; \t\t\t\t\t\t\t\t\t\n      int lev = strtol(cmd, \u0026cmd, 10); \n      if(prm == cmd) { \n        lev = INVLEV; \n        prm = cempty; \n      }\n      else if(isalnum(*cmd) || *cmd == ':') {\n        prm = cmd;\n        while(isalnum(*cmd) || *cmd == '_' || *cmd == '-'  || *cmd == ':' || *cmd == '=') \n          cmd++; \n        if(*cmd) \n          *cmd++ = 0; \n      } else \n        prm = cempty;\n\n      int found = 0;\n      struct plugs *gs,*gfs=NULL;  \n      if(!*name) \n        break;                              \n      for(gs = plugs; gs-\u003eid \u003e= 0; gs++)\n        if(gs-\u003ecodec \u0026\u0026 !strcasecmp(gs-\u003es, name) ) { \n          char s[33],*q; \n          sprintf(s,\"%d\", lev); \n          found++; \n          if(lev==INVLEV \u0026\u0026 gs-\u003elev \u0026\u0026 !gs-\u003elev[0] || gs-\u003elev \u0026\u0026 (q=strstr(gs-\u003elev, s)) \u0026\u0026 (q==gs-\u003elev || *(q-1) == ',')) {\t\t\t\t\n            found++; \n            plugins(plug, gs, \u0026k, bsize, bsizex, lev, prm); \n          }\n          break; \n        }\n      if(found\u003c2 \u0026\u0026 !ignore) {\n        if(!found) \n          fprintf(stderr, \"codec '%s' not found\\n\", name);\n        else if(lev == INVLEV) \n          fprintf(stderr, \"level [%s] not specified for codec '%s'\\n\", gs-\u003elev, name );\n        else if(gs-\u003elev \u0026\u0026 gs-\u003elev[0]) \n          fprintf(stderr, \"level '%d' for codec '%s' not in range [%s]\\n\", lev, name, gs-\u003elev);\n        else \n          fprintf(stderr, \"codec '%s' has no levels\\n\", name);\n        exit(0); \n      }\n      while(isspace(*cmd)) \n        cmd++;\t\t\t\t\t\t\n      if(*cmd != ',' \u0026\u0026 (*cmd \u003c '0' || *cmd \u003e '9')) \n        break;\n    }\n  } \n  a:plug[k].id = -1;  \n  return k;\n}","filepath":"turbobench.c","line_number":371,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4401744":{"score":0.8815145,"function_name":"plugprth","code":"void plugprth(FILE *f, int fmt, char *t) {\n  char *plot  = \"\u003cscript src=https://cdn.plot.ly/plotly-latest.min.js\u003e\u003c/script\u003e\";\n  char *jquery = \"\u003cscript src=\\\"http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js\\\"\u003e\u003c/script\u003e\";\n  char *tstyle = \"\u003clink rel=\\\"stylesheet\\\" href=\\\"http://tablesorter.com/themes/blue/style.css\\\" type=\\\"text/css\\\" media=\\\"print, projection, screen\\\" /\u003e\";\n  char *table  = \"\u003cscript type=\\\"text/javascript\\\" src=\\\"http://tablesorter.com/__jquery.tablesorter.min.js\\\"\u003e\u003c/script\u003e\";\n  char *code   = \"\u003cscript type=\\\"text/javascript\\\"\u003e$(function() {\t\t$(\\\"#myTable\\\").tablesorter({sortList:[[0,0],[2,1]], widgets: ['zebra']});\t\t$(\\\"#options\\\").tablesorter({sortList: [[0,0]], headers: { 3:{sorter: false}, 4:{sorter: false}}});\t});\t\u003c/script\u003e\u003cscript type=\\\"text/javascript\\\" src=\\\"http://tablesorter.com/__jquery.tablesorter.min.js\\\"\u003e\u003c/script\u003e\u003cscript type=\\\"text/javascript\\\"\u003e$(function() {\t\t$(\\\"#myTable2\\\").tablesorter({sortList:[[0,0],[2,1]], widgets: ['zebra']});\t\t$(\\\"#options\\\").tablesorter({sortList: [[0,0]], headers: { 3:{sorter: false}, 4:{sorter: false}}});\t});\t\u003c/script\u003e\";\n  char s[128];\n  time_t tm; \n  time(\u0026tm);\n  sprintf(s, \"TurboBench: %s - %s\", t, asctime(localtime(\u0026tm)));\n\n  switch(fmt) {\n    case FMT_TEXT:     \n      fprintf(f,\"%s\\n\", s ); \n      break;\n    case FMT_VBULLETIN:\n    case FMT_VBULLETIN2:\n      fprintf(f,\"%s\\n\", s); \n      break;\n    case FMT_HTMLT:  \n      fprintf(f,\"\u003chtml\u003e\u003chead\u003e\u003cmeta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\"\u003e\u003ctitle\u003eTurboBench: %s - \u003c/title\u003e\u003c/head\u003e\u003cbody\u003e\\n\", s); \n      break;\n    case FMT_HTML:     \n      fprintf(f,\"\u003chtml\u003e\u003chead\u003e\u003cmeta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\"\u003e\u003ctitle\u003eTurboBench: %s - \u003c/title\u003e%s%s%s%s%s\u003c/head\u003e\u003cbody\u003e\\n\", s, plot, jquery, tstyle, table, code); \n       break;\n    case FMT_MARKDOWN: \n      fprintf(f,\"#### %s (bold = pareto)  MB=1.000.000\\n\", s); \n      break;\n  }\n}","filepath":"turbobench.c","line_number":486,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4402112":{"score":0.92842853,"function_name":"plugprtth","code":"void plugprtth(FILE *f, int fmt) {\n  char *head =  \"     C Size  ratio%     C MB/s     D MB/s   Name            File              (bold = pareto)\"; \n\n  switch(fmt) {\n    case FMT_TEXT:     \n      fprintf(f,\"      C Size  ratio%%     C MB/s     D MB/s   Name            File\\n\"); \n      break;\n    case FMT_VBULLETIN:\n      fprintf(f,\"[table]C Size|ratio%|C MB/s|D MB/s|Name|File (MB=1.000.0000)\\n\"); \n      break;\n    case FMT_VBULLETIN2:\n      fprintf(f,\"[CODE][B]%s[/B] MB=1.000.0000\\n\", head); \n      break;\n    case FMT_HTMLT:    \n      fprintf(f,\"\u003cpre\u003e\u003cb\u003e%s\u003c/b\u003e MB=1.000.0000\\n\", head); \n      break;\n    case FMT_HTML:     \n      fprintf(f,\"\u003ch3\u003eTurboBench: Compressor Benchmark\u003c/h3\u003e\u003ctable id='myTable' class='tablesorter' style=\\\"width:35%%\\\"\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eC Size\u003c/th\u003e\u003cth\u003eratio%%\u003c/th\u003e\u003cth\u003eC MB/s\u003c/th\u003e\u003cth\u003eD MB/s\u003c/th\u003e\u003cth\u003eName\u003c/th\u003e\u003cth\u003eC Mem\u003c/th\u003e\u003cth\u003eD Mem\u003c/th\u003e\u003cth\u003eFile\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\\n\"); \n      break;\n    case FMT_MARKDOWN: \n      fprintf(f,\"|C Size|ratio%|C MB/s|D MB/s|Name|File|\\n|--------:|-----:|--------:|--------:|----------------|----------------|\\n\"); \n      break;\n    case FMT_CSV:      \n      fprintf(f,\"size,csize,ratio,ctime,dtime,name,file\\n\"); \n      break;\n    case FMT_TSV:      \n      fprintf(f,\"size\\tcsize\\tratio\\tctime\\tdtime\\tname\\tfile\\n\"); \n      break;\n    case FMT_SQUASH:   \n      fprintf(f,\"dataset,plugin,codec,level,compressed_size,compress_cpu,compress_wall,decompress_cpu,decompress_wall\\n\"); \n      break;\n  }\n}","filepath":"turbobench.c","line_number":525,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4402368":{"score":0.9314983,"function_name":"plugprttf","code":"void plugprttf(FILE *f, int fmt) {\n  switch(fmt) {\n    case FMT_VBULLETIN:\n      fprintf(f,\"[/table]\\n\");\n      break;\n    case FMT_VBULLETIN2:\n      fprintf(f,\"[/CODE]\\n\"); \n      break;\n    case FMT_HTMLT:    \n      fprintf(f,\"\u003c/pre\u003e\\n\"); \n      break;\n    case FMT_HTML:\n      fprintf(f,\"\u003c/tbody\u003e\u003c/table\u003e\\n\"); \n      break;\n    case FMT_MARKDOWN: \n      fprintf(f,\"\\n\\n\"); \n      break;\n  }\n}","filepath":"turbobench.c","line_number":559,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4402560":{"score":0.77426356,"function_name":"plugprt","code":"void plugprt(struct plug *plug, long long totinlen, char *finame, int fmt, double *ptc, double *ptd, FILE *f) {\n  double ratio  = RATIO(plug-\u003elen,totinlen),    \n         //ratio  = FACTOR(plug-\u003elen,totinlen),\n         tc     = TMBS(totinlen,plug-\u003etc), td = TMBS(totinlen,plug-\u003etd);\n  char   name[256]; \n  if(plug-\u003elev != INVLEV) \n    sprintf(name, \"%s%s %d%s\", plug-\u003eerr?\"?\":\"\", plug-\u003es, plug-\u003elev, plug-\u003eprm);\n  else\n    sprintf(name, \"%s%s%s\",    plug-\u003eerr?\"?\":\"\", plug-\u003es,            plug-\u003eprm);\n  \n  int c = 0, d = 0, n = 0;\n  if(!plug-\u003eerr \u0026\u0026 tc \u003e *ptc) { c++; n++; *ptc = tc; } \n  if(!plug-\u003eerr \u0026\u0026 td \u003e *ptd) { d++; n++; *ptd = td; } \n  switch(fmt) {\n    case FMT_TEXT:     \n      if(f == stdout) {\n          #ifdef _WIN32\n        HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n        fprintf(f, \"%12\"PRId64\"   %5.1f   \", plug-\u003elen, ratio); \n        #define BBOLD 15\n        if(c) SetConsoleTextAttribute(h, BBOLD);\n        fprintf(f, \"%8.2f   \", tc); \n        if(c) SetConsoleTextAttribute(h, 7);\n        if(d) SetConsoleTextAttribute(h, BBOLD);\n        fprintf(f, \"%8.2f   \", td); \n        if(d) SetConsoleTextAttribute(h, 7);\n        if(n) SetConsoleTextAttribute(h, BBOLD);\n        fprintf(f, \"%-16s\", name); \n        if(n) SetConsoleTextAttribute(h, 7);\n        fprintf(f, \"%s\\n\", finame); \n\t\t#undef BBOLD\n          #else\n        fprintf(f, \"%12\"PRId64\"   %5.1f   %s%8.2f%s   %s%8.2f%s   %s%-16s%s%s\\n\", \n          plug-\u003elen, ratio, c?BOLDB:\"\", tc, c?BOLDE:\"\",  d?BOLDB:\"\", td, d?BOLDE:\"\", n?BOLDB:\"\", name, n?BOLDE:\"\", finame); \n          #endif\n      } \n      else\n        fprintf(f,\"%12\"PRId64\"   %5.1f   %8.2f   %8.2f   %-32s %s\\n\", plug-\u003elen, ratio, tc, td, name, finame); \n      break;\n    case FMT_VBULLETIN:\n      fprintf(f, \"%12\"PRId64\"|%5.1f|%s%8.2f%s|%s%8.2f%s|%s%-16s%s|%s\\n\", \n        plug-\u003elen, ratio, c?\"[B]\":\"\", tc, c?\"[/B]\":\"\",  d?\"[B]\":\"\", td, d?\"[/B]\":\"\", n?\"[B]\":\"\", name, n?\"[/B]\":\"\", finame); \n      break;\n    case FMT_VBULLETIN2:\n      fprintf(f, \"%12\"PRId64\"   %5.1f   %s%8.2f%s   %s%8.2f%s   %s%-16s%s%s\\n\", \n        plug-\u003elen, ratio, c?\"[B]\":\"\", tc, c?\"[/B]\":\"\",  d?\"[B]\":\"\", td, d?\"[/B]\":\"\", n?\"[B]\":\"\", name, n?\"[/B]\":\"\", finame); \n      break;\n    case FMT_HTMLT:    \n      fprintf(f, \"%12\"PRId64\"   %5.1f   %s%8.2f%s   %s%8.2f%s   %s%-16s%s%s\\n\", \n        plug-\u003elen, ratio, c?\"\u003cb\u003e\":\"\", tc, c?\"\u003c/b\u003e\":\"\",  d?\"\u003cb\u003e\":\"\", td, d?\"\u003c/b\u003e\":\"\", n?\"\u003cb\u003e\":\"\", name, n?\"\u003c/b\u003e\":\"\", finame); \n      break;\n    case FMT_HTML:     \n      fprintf(f, \"\u003ctr\u003e\u003ctd align=\\\"right\\\"\u003e%11\"PRId64\"\u003c/td\u003e\u003ctd align=\\\"right\\\"\u003e%5.1f\u003c/td\u003e\u003ctd align=\\\"right\\\"\u003e%s%8.2f%s\u003c/td\u003e\u003ctd align=\\\"right\\\"\u003e%s%8.2f%s\u003c/td\u003e\u003ctd\u003e%s%-16s%s\u003c/td\u003e\u003ctd align=\\\"right\\\"\u003e%\"PRId64\"\u003c/td\u003e\u003ctd align=\\\"right\\\"\u003e%\"PRId64\"\u003c/td\u003e\u003ctd\u003e%s\u003c/td\u003e\u003c/tr\u003e\\n\",\n        plug-\u003elen, ratio, c?\"\u003cb\u003e\":\"\", tc, c?\"\u003c/b\u003e\":\"\",  d?\"\u003cb\u003e\":\"\", td, d?\"\u003c/b\u003e\":\"\", n?\"\u003cb\u003e\":\"\", name, n?\"\u003c/b\u003e\":\"\", \n//        SIZE_ROUNDUP(plug-\u003ememc, Kb)/Kb, SIZE_ROUNDUP(plug-\u003ememd,Kb)/Kb, \n        plug-\u003ememc, plug-\u003ememd, \n        finame); \n      break;\n    case FMT_MARKDOWN: \n      fprintf(f, \"|%\"PRId64\"|%5.1f|%s%.2f%s|%s%.2f%s|%s%s%s|%s|\\n\", \n        plug-\u003elen, ratio, c?\"**\":\"\",  tc, c?\"**\":\"\",    d?\"**\":\"\",  td, d?\"**\":\"\",   n?\"**\":\"\",  name, n?\"**\":\"\",   finame); \n      break;\n    case FMT_CSV:\n      fprintf(f, \"%12\"PRId64\",%11\"PRId64\",%5.1f,%8.2f,%8.2f,%-16s,%s\\n\",\n        totinlen, plug-\u003elen, ratio, tc, td, name, finame); \n      break;\n    case FMT_TSV:    \n      fprintf(f,\"%12\"PRId64\"\\t%11\"PRId64\"\\t%5.1f\\t%8.2f\\t%8.2f\\t%-16s\\t%s\\n\",\n        totinlen, plug-\u003elen, ratio, tc, td, name, finame); \n      break;\n    case FMT_SQUASH:\n      fprintf(f,\"%12\"PRId64\",%11\"PRId64\",%5.1f,%8.2f,%8.2f,%-16s,%s\\n\",\n        finame, name, name, plug-\u003elen,        tc, tc, td, td); \n      break;\n  }\n}","filepath":"turbobench.c","line_number":582,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4404432":{"score":0.8649899,"function_name":"plugprtph","code":"void plugprtph(FILE *f, int fmt) {\n  int i; char *s = plugspeedup(speedup,0);\n\n  switch(fmt) {\n    case FMT_HTML: \n      fprintf(f,\"\u003cp\u003e\u003ch3\u003eTurboBench: Speedup %s sheet\u003c/h3\u003e\u003ctable id='myTable2' class='tablesorter' style=\\\"width:80%%\\\"\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eName\u003c/th\u003e\", s);\n      for(i = 0; i \u003c BWSIZE; i++) \n        fprintf(f, \"\u003cth\u003e%s\u003c/th\u003e\", bw[i].s);\n      fprintf(f, \"\u003ctd\u003eFile\"); \n      if(blknum) \n        fprintf(f, \" blknum=%d \", blknum);\n      fprintf(f, \"\u003c/td\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\\n\"); \n      break;\n    case FMT_MARKDOWN: \n      fprintf(f,\"#### TurboBench: Speedup %s sheet\\n\\n\", s);\n      fprintf(f, \"|Name\"); \n      for(i = 0; i \u003c BWSIZE; i++) \n        fprintf(f, \"|%s\", bw[i].s);\n      fprintf(f, \"|File\"); \n      if(blknum) \n        fprintf(f, \" blknum=%d \", blknum);\n      fprintf(f, \"|\\n\"); \n      fprintf(f, \"|-------------\");\n      for(i = 0; i \u003c BWSIZE; i++) \n        fprintf(f, \"|---------:\");\n      fprintf(f, \"|-------------|\\n\"); \n      break;\n    case FMT_VBULLETIN:\n      fprintf(f,\"TurboBench: Speedup %s sheet\\n\\n\", s);\n      fprintf(f,\"[table][B]\\n\"); \n      break;\n    case FMT_VBULLETIN2:\n      fprintf(f,\"TurboBench: Speedup %s sheet\\n\\n\", s);\n      fprintf(f,\"[CODE][B]\\n\"); \n    default: \n      fprintf(f,\"Name           \");\n      for(i = 0; i \u003c BWSIZE; i++) \n        fprintf(f, \"%10s\", bw[i].s);\n      if(blknum) \n        fprintf(f, \" blknum=%d \", blknum);\n      fprintf(f, \"\\n\"); \n    if(fmt == FMT_VBULLETIN || fmt == FMT_VBULLETIN2) \n      fprintf(f,\"[/B]\\n\"); \n  }\n}","filepath":"turbobench.c","line_number":666,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4405280":{"score":0.91584355,"function_name":"plugprtp","code":"void plugprtp(struct plug *plug, long long totinlen, char *finame, int fmt, int speedup, FILE *f) {\n  int  i;\n  char name[255]; \n  if(plug-\u003elev != INVLEV) \n    sprintf(name, \"%s%s%s%d%s\", plug-\u003eerr?\"?\":\"\", plug-\u003es, fmt==FMT_MARKDOWN?\"_\":\" \", plug-\u003elev, plug-\u003eprm);\n  else\n    sprintf(name, \"%s%s%s\",    plug-\u003eerr?\"?\":\"\", plug-\u003es,            plug-\u003eprm);\n  if(fmt == FMT_HTML) \n    fprintf(f, \"\u003ctr\u003e\u003ctd\u003e%s\u003c/td\u003e\", name);\n  else \n    fprintf(f, \"%-32s\", name);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\n  for(i = 0; i \u003c BWSIZE; i++) {\n    switch(fmt) {\n      case FMT_HTMLT: \n      case FMT_HTML: \n        fprintf(f, \"\u003ctd align=\\\"right\\\"\u003e\"); \n        break;\n      case FMT_MARKDOWN: \n        fprintf(f, \"|\"); \n        break;\n    }\n    switch(speedup) {\n      case SP_TRANSFERD:  fprintf(f,\"%9.3f \",     spmbs(plug-\u003etd,          plug-\u003elen, i, totinlen));       break;\n      case SP_SPEEDUPD:   fprintf(f,\"%9d \", (int)(spdup(plug-\u003etd,          plug-\u003elen, i, totinlen)+0.5));  break;\n      case SP_TRANSFERC:  fprintf(f,\"%9.3f \",     spmbs(plug-\u003etc,          plug-\u003elen, i, totinlen));       break;\n      case SP_SPEEDUPC:   fprintf(f,\"%9d \", (int)(spdup(plug-\u003etc,          plug-\u003elen, i, totinlen)+0.5));  break;\n      case SP_SPEEDUP:    fprintf(f,\"%9d \", (int)(spdup(plug-\u003etc+plug-\u003etd, plug-\u003elen, i, totinlen)+0.5));  break;\n      case SP_TRANSFER:   fprintf(f,\"%9.3f \",     spmbs(plug-\u003etc+plug-\u003etd, plug-\u003elen, i, totinlen));       break;\n    }\n    switch(fmt) {\n      case FMT_HTMLT: \n      case FMT_HTML: \n        fprintf(f, \"\u003c/td\u003e\");\n        break;\n      case FMT_MARKDOWN: \n        break;\n    }\n  }\n  switch(fmt) {\n    case FMT_HTMLT: \n    case FMT_HTML: \n      fprintf(f, \"\u003ctd\u003e%s\u003c/td\u003e\u003c/tr\u003e\\n\", finame);\n      break;\n    case FMT_MARKDOWN: \n      fprintf(f, \"|%s|\\n\", finame); \n      break;\n    default: \n      fprintf(f, \"%s\\n\", finame); \n      break;\n  }\n}","filepath":"turbobench.c","line_number":722,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4406800":{"score":0.8080847,"function_name":"plugplot","code":"void plugplot(struct plug *plug, long long totinlen, int fmt, int speedup, char *s, FILE *f) {\n  int  i;\n  char name[65];\n  if(plug-\u003elev != INVLEV)\n    sprintf(name, \"%s%s_%d%s\", plug-\u003eerr?\"?\":\"\", plug-\u003es, plug-\u003elev, plug-\u003eprm);\n  else\n    sprintf(name, \"%s%s%s\",    plug-\u003eerr?\"?\":\"\", plug-\u003es,            plug-\u003eprm);\n  strcat(s,name); strcat(s,\",\");\n\n  fprintf(f, \"var %s = { x: [\", name);\t\t\t\t\t\t\t\n  for(i = 0; i \u003c BWSIZE; i++) \n    fprintf(f,\"%llu%s\", bw[i].bw, i+1 \u003c BWSIZE?\",\":\"\"); \t\t\t\n  fprintf(f, \"],\\ny: [\");\t\t\t\t\t\t\t\n\n  for(i = 0; i \u003c BWSIZE; i++)  \t\t\t\t\n    switch(speedup) {\n      case SP_TRANSFERD: fprintf(f,\"%9.3f%s\",     spmbs(plug-\u003etd,          plug-\u003elen, i, totinlen),      i+1 \u003c BWSIZE?\",\":\"\"); break;\n      case SP_SPEEDUPD:  fprintf(f,\"%9d%s\", (int)(spdup(plug-\u003etd,          plug-\u003elen, i, totinlen)+0.5), i+1 \u003c BWSIZE?\",\":\"\"); break;\n      case SP_TRANSFERC: fprintf(f,\"%9.3f%s\",     spmbs(plug-\u003etc,          plug-\u003elen, i, totinlen),      i+1 \u003c BWSIZE?\",\":\"\"); break;\n      case SP_SPEEDUPC:  fprintf(f,\"%9d%s\", (int)(spdup(plug-\u003etc,          plug-\u003elen, i, totinlen)+0.5), i+1 \u003c BWSIZE?\",\":\"\"); break;\n      case SP_SPEEDUP:   fprintf(f,\"%9d%s\", (int)(spdup(plug-\u003etc+plug-\u003etd, plug-\u003elen, i, totinlen)+0.5), i+1 \u003c BWSIZE?\",\":\"\"); break;\n      case SP_TRANSFER:  fprintf(f,\"%9.3f%s\",     spmbs(plug-\u003etc+plug-\u003etd, plug-\u003elen, i, totinlen),      i+1 \u003c BWSIZE?\",\":\"\"); break;\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \n  fprintf(f, \"],\\ntype: 'scatter',\\nmode: 'lines+markers',\\nline: {shape: 'spline'},\\nname: '%s'\\n};\\n\", name);\t\t\t\t\t\t\t \n}","filepath":"turbobench.c","line_number":788,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4408384":{"score":0.828547,"function_name":"plugplotc","code":"void plugplotc(struct plug *plug, int k, long long totinlen, int fmt, int speedup, char *s, FILE *f) {\n  int  i, n = 0;\n  char name[65],txt[256];  \n  qsort(plug, k, sizeof(struct plug), (int(*)(const void*,const void*))libcmpn);\n  \n  struct plug *g,*gs=plug,*p;\n  for(txt[0] = name[0] = 0, g = plug; g \u003c plug+k; g++) \n  if(g-\u003eid \u003c= P_MCPY \u0026\u0026 !plotmcpy) \n    continue;\n  else { \t\t\t\t\t\n    if(strcmp(g-\u003es, name)) {\n      if(name[0]) { \t\t\t\t\t\t\t\t\t\t\t\t\t\t\n        fprintf(f, \"],\\ny: [\");\n        for(p = gs; p \u003c g; p++) \n          fprintf(f, \"%.2f%s\", SP_ISFACTOR(speedup)?FACTOR(p-\u003elen,totinlen):RATIO(p-\u003elen,totinlen), p+1\u003cg?\",\":\"\");        \n        fprintf(f, \"],\\nmode: 'markers+text',\\ntype: 'scatter',\\nname: '%s',\\ntextposition: 'top center', textfont: { family:  'Raleway, sans-serif' }, marker: { size: 12 }\\n\", name, txt);\t\n        if(txt[0]) \n          fprintf(f, \"\\n,text: [%s]\\n\", txt);\n        fprintf(f, \"};\\n\");\n        strcat(s,\",\");\n        txt[0] = 0;\n      }\n      gs = g;\n      strcpy(name, g-\u003es);\t\t\t\t\t\t\t\t\t\t\t\t\t\n      fprintf(f, \"var %s = {\\n x: [\", g-\u003es);\n      strcat(s, g-\u003es); \n    } else { \n      fprintf(f, \",\");\n      strcat(txt, \",\"); \n    }\n    if(g-\u003elev != INVLEV) { \n      char ts[33]; \n      sprintf(ts, \"'%s%s%d%s'\", divxy\u003e=2?\"\":g-\u003es, divxy\u003e=2?\"\":\",\", g-\u003elev, g-\u003eprm); \n      strcat(txt, ts); \n    }\n    unsigned sptype = SP_TYPE(speedup);\n    double t = sptype==1?g-\u003etc:(sptype?g-\u003etc+g-\u003etd:g-\u003etd);  //0:Decomp 1:Comp 2:Comp+Decomp\n    fprintf(f, \"%.2f\", TMBS(totinlen,t));\n  }\n  fprintf(f, \"],\\ny: [\");\n  for(p = gs; p \u003c g; p++) \n    fprintf(f, \"%.2f%s\", SP_ISFACTOR(speedup)?FACTOR(p-\u003elen,totinlen):RATIO(p-\u003elen,totinlen), p+1\u003cg?\",\":\"\");        \n  fprintf(f, \"],\\nmode: 'markers+text',\\ntype: 'scatter',\\nname: '%s',\\ntextposition: 'top center', textfont: { family:  'Raleway, sans-serif' }, marker: { size: 12 }\\n\", name, txt);\t\n  if(txt[0]) \n    fprintf(f, \"\\n,text:[%s]\\n\", txt);\n  fprintf(f, \"};\\n\");\n}","filepath":"turbobench.c","line_number":845,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4410240":{"score":0.83781075,"function_name":"plugprts","code":"int plugprts(struct plug *plug, int k, char *finame, int xstdout, unsigned long long totlen, int fmt, char *t) { \n  double ptc = 0.0, ptd = 0.0;\n  struct plug *g; \n  if(!totlen) return 0; \t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t\t\t\tif(verbose\u003e1) printf(\"'%s'\\n\", finame); \n\n  qsort(plugt, k, sizeof(struct plug), (int(*)(const void*,const void*))libcmp);\n  char s[257];\n  sprintf(s, \"%s.%s\", finame, fmtext[fmt]);\n  FILE *fo = xstdout\u003e=0?stdout:fopen(s, \"w\");\n  if(!fo) \n    die(\"file create error for '%s'\\n\", finame); \n  plugprth( fo, fmt, t);\n  plugprtth(fo, fmt);\n  for(g = plugt; g \u003c plugt+k; g++) \n    plugprt(g, totlen, finame, fmt, \u0026ptc, \u0026ptd, fo);\n  plugprttf(fo, fmt);\n\n  if(speedup) { \n    switch(fmt) {\n      case FMT_TEXT : \n        fprintf(fo, \"\\n\"); \n        break;\n      case FMT_HTML : \n        break;\n      case FMT_HTMLT: \n        fprintf(fo, \"\u003cpre\u003e\\n\");\n        break;\n      case FMT_MARKDOWN :\n        fprintf(fo, \"\\n\"); \n        break;\n    }\n    plugprtph(fo, fmt); \n    for(g = plugt; g \u003c plugt+k; g++) \n      plugprtp(g, totlen, finame, fmt, speedup, fo);  \n    fprintf(fo, \"\\n\"); \n    switch(fmt) {\n      case FMT_TEXT : \n        fprintf(fo, \"\\n\"); break;\n      case FMT_HTML : \n        fprintf(fo, \"\u003c/tbody\u003e\u003c/table\u003e\\n\"); break;\n      case FMT_HTMLT: \n        fprintf(fo, \"\u003c/pre\u003e\\n\"); \n        break;\n      case FMT_VBULLETIN:\n        fprintf(fo,\"[/table]\\n\"); \n        break;\n      case FMT_VBULLETIN2:\n        fprintf(fo,\"[/CODE]\\n\"); \n        break;\n      case FMT_MARKDOWN :\n        fprintf(fo, \"\\n\"); \n        break;\n    }\n    if(fmt == FMT_HTML) {\n      char s[1025];  \n      s[0] = 0; \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(verbose\u003e1) printf(\"generate speedup plot\\n\");\n      plugplotb(fo, fmt, 1); \n      for(g = plugt; g \u003c plugt+k; g++) \n        if(g-\u003eid \u003e P_MCPY || plotmcpy)\n          plugplot(g, totlen, fmt, speedup, s, fo);  \n      plugplote(fo, fmt, s);\n\n      s[0] = 0; \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(verbose\u003e1) printf(\"generate speed/ratio plot\\n\");\n      plugplotb(fo, fmt, 2); \n      plugplotc(plug, k, totlen, fmt, speedup, s, fo);\n      plugplotce(fo, fmt, s);\n\n    }\n  }\n  plugprtf(fo, fmt);\n  fclose(fo);\n}","filepath":"turbobench.c","line_number":898,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4411744":{"score":0.90353036,"function_name":"plugread","code":"int plugread(struct plug *plug, char *finame, long long *totinlen) {\n  char s[LSIZE+1],name[33];\n  struct plug *p=plug;\n  FILE *fi = fopen(finame, \"r\"); \n  if(!fi) return -1;\n\n  fgets(s, LSIZE, fi);\n  for(p = plug;;) {\n    p-\u003etms[0] = name[0] = 0;\n\tchar ss[LSIZE+1],*t = ss,*q;\n\tif(!fgets(ss, LSIZE, fi)) break; ss[strlen(ss)-1]=0; if(!strlen(ss)) break; \n\n\tfor(q = t;  *q \u0026\u0026 *q != '\\t'; q++);  *q++ = 0; strncpy(s, t, LSIZE); s[LSIZE]=0; t = q;\n\t*totinlen = strtoull(t, \u0026t, 10);   \n\tp-\u003elen    = strtoull(++t, \u0026t, 10);\n\tp-\u003etd     = strtod(  ++t, \u0026t);\n\tp-\u003etc     = strtod(  ++t, \u0026t);\n\tfor(q = ++t; *q \u0026\u0026 *q != '\\t'; q++); *q++ = 0; strncpy(name,t,32); name[32]=0; t=q;\n\tp-\u003elev    = strtol(t, \u0026t, 10); \n\twhile(*t \u0026\u0026 isspace(*t)) t++;\n\tfor(q = t; *q \u0026\u0026 *q != '\\t'; q++);   *q++ = 0; strncpy(p-\u003eprm, t, PRM_SIZE); p-\u003eprm[PRM_SIZE]=0; t = q;\n\tp-\u003ememc   = strtoull(t, \u0026t, 10);\n    p-\u003ememd   = strtoull(++t, \u0026t, 10);\n    p-\u003estkc   = strtoull(++t, \u0026t, 10);\n    p-\u003estkd   = strtoull(++t, \u0026t, 10);\n\n    for(q = ++t; *q \u0026\u0026 *q != '\\t'; q++); *q++ = 0; strncpy(p-\u003etms, t, TMS_SIZE); p-\u003etms[TMS_SIZE]=0; t = q;\n    if(p-\u003eprm[0]=='?') \n      p-\u003eprm[0]=0;\n    int i;  \t\t\t\t\t\t\t\n    for(i = 0; plugs[i].id \u003e=0; i++) {  \n      if(!strcmp(name, plugs[i].s)) { \n        p-\u003es  = plugs[i].s; \n        p-\u003eid = plugs[i].id; \t\t\t\t\t\t\t\t\t\t\tif(verbose\u003e1) { fprintf(stdout, \"$%s\\t%\"PRId64\"\\t%\"PRId64\"\\t%.6f\\t%.6f\\t%s\\t%d%s\\t%s\\t%\"PRId64\"\\t%\"PRId64\"\\t%\"PRId64\"\\t%\"PRId64\"\\n\",\n                                                                                         s, *totinlen, p-\u003elen, p-\u003etd, p-\u003etc, p-\u003es, p-\u003elev, p-\u003eprm, p-\u003etms, p-\u003ememc, p-\u003ememd, p-\u003estkc, p-\u003estkd); fflush(stdout); }\n        p++;\n        break; \n      } \n    }\t  \n  }\n  fclose(fi);\n  return p - plug;\n}","filepath":"turbobench.c","line_number":971,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4412912":{"score":0.62733245,"function_name":"becomp","code":"int becomp(unsigned char *_in, unsigned _inlen, unsigned char *_out, size_t outsize, unsigned bsize, int id, int lev, char *prm) { \n  unsigned char *op,*oe = _out + outsize;\n  codstart(_inlen, id, lev, prm, 0);\n  TMBEG(tm_Rep);     \n    mempeakinit();                                           \n    unsigned char *in,*ip;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    for(op = _out, in = _in; in \u003c _in+_inlen; ) {\n      unsigned inlen,bs; \n      if(mode) { \t\t\t\t\t\t\t\t\t\t\t\t\t\tblknum++;\n        inlen = ctou32(in); in += 4; \n        ctou32(op) = inlen; op += 4; //vbput32(op, inlen); \n        if(in+inlen\u003e_in+_inlen) inlen = (_in+_inlen)-in;\n      } else inlen = _inlen;\n\n      for(ip = in, in += inlen; ip \u003c in; ) { \n        size_t iplen = in - ip; iplen = min(iplen, bsize);       \n        bs = mode?((min(bsize, iplen) \u003c (1\u003c\u003c16))?2:4):0;\n        int oplen = codcomp(ip, iplen, op+bs, oe-(op+bs), id, lev,prm);\n        if(oplen \u003c= 0 || oplen \u003e= iplen \u0026\u0026 mcpy) {\n\t      if(mcpy) { memcpy(op+bs, ip, iplen); oplen = iplen; }\n\t      else if(oplen \u003c= 0) { op=_out; goto end; }\n\t    }\n        if(bs == 2 \u0026\u0026 oplen \u003e= (1\u003c\u003c16)) { printf(\"Output larger than input! Use option '-P'\\n\"); exit(-1); }\n        if(mode) { bs==2?(ctou16(op) = oplen):(ctou32(op) = oplen); } op += oplen+bs; ip += iplen; \n        if(op \u003e _out+outsize) \n\t      die(\"Overflow error %llu, %u in lib=%d\\n\", outsize, (int)(op - _out), id);                                                      \n      }\n    }\n  TMEND(_inlen);\t\n  end: codend(_inlen, id, lev, prm, 0);\t\n  return op - _out;;\n}","filepath":"turbobench.c","line_number":1023,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4414720":{"score":0.59559834,"function_name":"bedecomp","code":"int bedecomp(unsigned char *_in, int _inlen, unsigned char *_out, unsigned _outlen, unsigned bsize, int id, int lev, char *prm) { \n  unsigned char *ip;\n  codstart(_inlen, id, lev, prm, 1);\n  TMBEG(tm_Rep2);     mempeakinit();\n  unsigned char *out,*op;\n  for(ip = _in, out = _out; out \u003c _out+_outlen;) {\n    unsigned outlen,bs; \n    if(mode) { outlen = ctou32(ip); ip += 4; \n      ctou32(out) = outlen; out += 4;\n      if(out+outlen\u003e_out+_outlen) \n        outlen = (_out+_outlen)-out; \n    } else outlen = _outlen;\n    for(op = out, out += outlen; op \u003c out; ) { \n      unsigned oplen = out - op; \n      oplen = min(oplen, bsize); \n      bs = mode?((min(bsize,oplen)\u003c(1\u003c\u003c16))?2:4):0;\n      int l, iplen = mode?(bs==2?ctou16(ip):ctou32(ip)):_inlen; ip += bs;\n      if(mcpy \u0026\u0026 iplen==oplen) \n        memcpy(op, ip, oplen); \n\t  else l = coddecomp(ip, iplen, op, oplen, id, lev,prm);\n      ip += iplen; op += oplen;\n    }\n  }\n  TMEND(_outlen);\n  codend(_inlen, id, lev, prm, 1);\t\n  return ip - _in;\n}","filepath":"turbobench.c","line_number":1056,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4417200":{"score":0.8353991,"function_name":"plugfile","code":"unsigned long long plugfile(struct plug *plug, char *finame, unsigned long long filenmax, size_t bsize, struct plug *plugr, int tid, int krep) { \n  size_t outsize;   \n  FILE *fi = strcmp(finame,\"stdin\")?fopen(finame, \"rb\"):stdin; if(!fi) { perror(finame); return 0; /*die(\"open error '%s'\\n\", finame);*/ }\n  char *p; \n  if((p = strrchr(finame, '\\\\')) || (p = strrchr(finame, '/'))) finame = p+1; \tif(verbose\u003e1) printf(\"'%s'\\n\", finame);\n  p = finame; \n\n  char name[65]; \n  if(plug-\u003elev != INVLEV) \n    sprintf(name, \"%s %d%s\", plug-\u003es, plug-\u003elev, plug-\u003eprm);\n  else\n    sprintf(name, \"%s%s\",    plug-\u003es,            plug-\u003eprm);\n \n  size_t filen;\n  if(finame) {\n    fseeko(fi, 0, SEEK_END); filen = ftello(fi); fseeko(fi , 0 , SEEK_SET); if(filen \u003e filenmax) filen = filenmax;\n  } else \n    filen = filenmax;\n  \n  size_t insize   = filen; \t\t\t         \t\t\t\t\t\t\t\tif(filen \u003c mininlen) insize = mininlen;\n  size_t pagesize = getpagesize();\n  size_t insizem  = (fuzz\u00263)?SIZE_ROUNDUP(insize, pagesize):(insize+INOVD);\n\n  outsize = insize*fac + 10*Mb; \n  unsigned char *_in = NULL;\n  if(insizem \u0026\u0026 !(_in = _valloc(insizem,1)))\n    die(\"malloc error in size=%u\\n\", insizem);\n  \n  unsigned char *_cpy = _in, *out = (unsigned char*)_valloc(outsize,2);  \t\tif(!out) die(\"malloc error out size=%u\\n\", outsize);\n\n  if((cmp || tid) \u0026\u0026 insizem \u0026\u0026 !(_cpy = _valloc(insizem,3)))\n    die(\"malloc error cpy size=%u\\n\", insizem);\n \n  codini(insize, plug-\u003eid, plug-\u003elev, plug-\u003eprm);\t\n  size_t    inlen;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  long long totinlen = 0;\n  double    ptc = DBL_MAX, ptd = DBL_MAX;\n  bsize     = plug-\u003eblksize;\n  plug-\u003elen = plug-\u003etc = plug-\u003etd = 0; \t\t\t\t\t\t\t\t\t\t\tblknum = 0;\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  while((inlen = fread(_in, 1, insize, fi)) \u003e 0) {\n    unsigned char *in = _in; \n    if(fuzz \u0026 1) { in = (_in+insizem)-inlen; memmove(in, _in, inlen); \t\t\t/*printf(\"SEGFAULT Check\");fflush(stdout); in[inlen-1] = in[inlen]; printf(\"SEGFAULT TEST FAILED\"); fflush(stdout);*/  }\n    double   tc = 0.0, td = 0.0;         \n    size_t   l = inlen,outlen;\n\ttotinlen += inlen;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    BEPRE;\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmemrcpy(out, in, inlen);\n    unsigned nb = 1;\n    if(l \u003c mininlen) {\n      bsize = l;\n      unsigned char *p;\n      for(p = in+l; ; p+=l) {\n        if(p+l \u003e in+insize) break;\n        nb++;\n        memcpy(p, in, l);\n      }\n    }\n    size_t peak = mempeakinit();\n    unsigned *_stack = stackini();   \n\n\toutlen = becomp(in, l*nb, out, outsize, bsize, plug-\u003eid, plug-\u003elev, plug-\u003eprm)/nb;\n\tplug-\u003elen += outlen; \n    plug-\u003etc  += (tc += (double)tm_tm/((double)tm_rm*nb)); \n\tplug-\u003ememc = mempeak() - peak;\n    plug-\u003estkc = stackpeak(_stack);\n    if(tm_Rep \u003e 1) \n      TMSLEEP;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(verbose \u0026\u0026 inlen == filen) { double ratio = (double)outlen*100.0/inlen; printf(\"%12u   %5.1f   %8.2f   \", outlen, ratio, TMBS(inlen,tc)); fflush(stdout); }\n    if(cmp) {\n      unsigned char *cpz = _cpy; \n      if(fuzz \u0026 2) { cpz = (_cpy+insizem) - l; \t\t\t\t\t\t\t\t\t\t\t/*printf(\"SEGFAULT Check\");fflush(stdout); cpz[l-1] = cpz[l]; printf(\"SEGFAULT TEST FAILED\"); fflush(stdout);*/  }\n\t  if(_cpy != _in) memrcpy(cpz, in, l);\n      peak = mempeakinit();\n      unsigned *_stack = stackini();   \n\t  unsigned cpylen = bedecomp(out, outlen, cpz, l*nb, bsize, plug-\u003eid,plug-\u003elev, plug-\u003eprm)/nb; \n\t  td = (double)tm_tm/((double)tm_rm*nb);\t\t\n      plug-\u003ememd = mempeak() - peak;              \t\t\t\t\t\tif(verbose \u0026\u0026 inlen == filen) { printf(\"%8.2f   %-16s %s\\n\", TMBS(inlen,td), name, finame); }\n      plug-\u003estkd = stackpeak(_stack);\n      int e = memcheck(in, l, cpz, fuzz?3:cmp, finame);  \n      plug-\u003eerr = plug-\u003eerr?plug-\u003eerr:e;\n      BEPOST;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n \t  plug-\u003etd += td; \n\t} else \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(verbose \u0026\u0026 inlen == filen) { printf(\"%8.2f   %-16s %s\\n\", 0.0, name, finame); }\n\tif(totinlen \u003e= filen) \n      break;\n  }\t  \n  _vfree(out, outsize); \n  _vfree(_in, insizem);\n  if(_cpy \u0026\u0026 _cpy != _in) \n    _vfree(_cpy, insizem); \n  codexit(plug-\u003eid);\n  fclose(fi); \n  if(verbose \u0026\u0026 filen \u003e insize) \n    plugprt(plug, totinlen, finame, FMT_TEXT, \u0026ptc, \u0026ptd,stdout);\n  return totinlen;\n}","filepath":"turbobench.c","line_number":1155,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4421312":{"score":0.9653742,"function_name":"usage","code":"void usage(char *pgm) {\n  fprintf(stderr, \"\\nTurboBench Copyright (c) 2013-2017 Powturbo %s\\n\", __DATE__);\n  fprintf(stderr, \"Usage: %s [options] [file]\\n\", pgm);\n  fprintf(stderr, \" -eS      S = compressors/groups separated by '/' Parameter can be specified after ','\\n\");\n  fprintf(stderr, \" -b#s     # = blocksize (default filesize). max=1GB\\n\");\n  fprintf(stderr, \" -d#      # = log2 dictionary size: 15-30 (default blocksize).Only brotli,lzham,lzlib,lzma,zstd\\n\");\n  fprintf(stderr, \" -B#s     # = max. benchmark filesize (default 1GB) ex. -B4G\\n\");\n  fprintf(stderr, \" -s#s     # = min. buffer size to duplicate \u0026 test small files (ex. -s50)\\n\");\n  fprintf(stderr, \"          s = modifier s:K,M,G=(1000, 1.000.000, 1.000.000.000) s:k,m,h=(1024,1Mb,1Gb). (default m) ex. 64k or 64K\\n\");\n  fprintf(stderr, \"Benchmark:\\n\");\n  fprintf(stderr, \" -i#/-j#  # = Minimum  de/compression iterations per run (default=auto)\\n\");\n  fprintf(stderr, \" -I#/-J#  # = Number of de/compression runs (default=3)\\n\");\n  fprintf(stderr, \" -t#      # = min. time in seconds per run.(default=2sec)\\n\");\n  fprintf(stderr, \" -S#      Sleep # min. after 2 min. processing mimizing CPU trottling\\n\");\n  fprintf(stderr, \" -k#      Repeat all benchmarks # times (default=3). -k0 = test mode\\n\");\n  fprintf(stderr, \" -K#t     Max. time limit for all benchmarks (default 24h)\\n\");\n  fprintf(stderr, \"          t = M:millisecond s:second m:minute h:hour. ex. 3h\\n\");\n  fprintf(stderr, \" -D       No process real-time priority setting\\n\");\n  fprintf(stderr, \"Check:\\n\");\n  fprintf(stderr, \" -C#      #=0 compress only, #1=No check #=2 ignore errors, #=3 exit on error, #=4 crash on error\\n\");\n  fprintf(stderr, \" -f#      check reading/writing outside bounds: #=1 compress, #=2 decompress, #3:both\\n\");\n  fprintf(stderr, \"Output:\\n\");\n  fprintf(stderr, \" -v#      # = verbosity 0..3 (default 1)\\n\");\n  fprintf(stderr, \" -rstr    str = Remark/Comment string\\n\");\n  fprintf(stderr, \" -l#      # = 1 : print all groups/plugins, # = 2 : print all codecs\\n\");\n  fprintf(stderr, \" -S#      Plot transfer speed: #=1 Comp        speedup #=2 Decomp speedup #=3 Comp        'MB/s' #=4 Decomp 'MB/s'\\n\");\n  fprintf(stderr, \"                               #=4 Comp+Decomp speedup                    #=5 Comp+Decomp 'MB/s'\\n\");\n  fprintf(stderr, \" -p#      #='print format' 1=text 2=html 3=htm 4=markdown 5/6:vBulletin 7:csv(comma) 8=tsv(tab)\\n\");\n  fprintf(stderr, \" -Q#      # Plot window 0:1920x1080, 1:1600x900, 2:1280x720, 3:800x600 (default=1)\\n\");\n  fprintf(stderr, \" -g       -g:no merge w/ old result 'file.tbb', -gg:process w/o output (use for fuzzing)\\n\");\n  fprintf(stderr, \" -o       print on standard output\\n\");\n  fprintf(stderr, \" -G       plot memcpy\\n\");\n  fprintf(stderr, \" -w       Plot Speedup linear x-axis (default log)\\n\");\n  fprintf(stderr, \" -z       Plot Ratio/Speed logarithmic x-axis (default linear)\\n\");\n  fprintf(stderr, \"Multiblock:\\n\");\n  fprintf(stderr, \" -Moutput concatenate all input files to multiple blocks file output\\n\");\\\n  fprintf(stderr, \" -m       process multiple blocks per file.\\n\");\n  fprintf(stderr, \" -N       block character delimiter (ex. -N9 for newline, 1 block/line)\\n\");\n  BEUSAGE;\n  fprintf(stderr, \"ex. ./turbobench enwik9 -eFAST/bzip2/lzma,5,9\\n\");\n  fprintf(stderr, \"ex. ./turbobench enwik9 -eFAST/OPTIMAL/bsc,0:e2 -i0\\n\");\n  fprintf(stderr, \"ex. ./turbobench eECODER -R\\\"entropy coder test\\\"\\n\");\n  fprintf(stderr, \"ex. ./turbobench enwik9 -elzma,9:fb273:lc2:lp2\\n\");\n  exit(0);\n}","filepath":"turbobench.c","line_number":1253,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"},"4422512":{"score":0.852265,"function_name":"printfile","code":"void printfile(char *finame, int xstdout, int fmt, char *rem) {\n  long long totinlen;\n  int       k = plugread(plugt, finame, \u0026totinlen); \n  char      *p, s[256];\n  if(k \u003c 0)\n    die(stderr, \"file open error for '%s'\\n\", finame);\n\n  if(!k) return;\n  strncpy(s, finame, 255); \n  s[255]=0;\n  if((p = strrchr(s,'.')) \u0026\u0026 !strcmp(p, \".tbb\"))\n    *p=0;\n  plugprts(plugt, k, s, xstdout, totinlen, fmt, rem);\t\n}","filepath":"turbobench.c","line_number":1299,"entry_url":"https://github.com/powturbo/TurboBench.git","slot_name":"2020-02"}}}