{"file_sha256":"33ead107e7a01e9eb3432baebe14172ae6fe94ce62f41afad9f884e7c9b5dfe7","base_addr":4194304,"functions":{"4616240":{"score":0.8061745,"function_name":"uv__threadpool_cleanup","code":"__attribute__((destructor))\n#endif\nvoid uv__threadpool_cleanup(void) {\n  unsigned int i;\n\n  if (nthreads == 0)\n    return;\n\n#ifndef __MVS__\n  /* TODO(gabylb) - zos: revisit when Woz compiler is available. */\n  post(\u0026exit_message, UV__WORK_CPU);\n#endif\n\n  for (i = 0; i \u003c nthreads; i++)\n    if (uv_thread_join(threads + i))\n      abort();\n\n  if (threads != default_threads)\n    uv__free(threads);\n\n  uv_mutex_destroy(\u0026mutex);\n  uv_cond_destroy(\u0026cond);\n\n  threads = NULL;\n  nthreads = 0;\n}","filepath":"ext/deps/libcat/deps/libuv/src/threadpool.c","line_number":165,"entry_url":"https://github.com/swow/swow.git","slot_name":"v0.1.0-nightly20220722"},"4618368":{"score":0.5603019,"function_name":"xmrig::NetworkState::onActive","code":"void xmrig::NetworkState::onActive(IStrategy *strategy, IClient *client)\n{\n    snprintf(m_pool, sizeof(m_pool) - 1, \"%s:%d\", client-\u003epool().host().data(), client-\u003epool().port());\n\n    m_ip             = client-\u003eip();\n    m_tls            = client-\u003etlsVersion();\n    m_fingerprint    = client-\u003etlsFingerprint();\n    m_active         = true;\n    m_connectionTime = Chrono::steadyMSecs();\n\n    StrategyProxy::onActive(strategy, client);\n}","filepath":"src/base/net/stratum/NetworkState.cpp","line_number":265,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.10.0"},"4618448":{"score":0.73280984,"function_name":"xmrig::NetworkState::stop","code":"void xmrig::NetworkState::stop()\n{\n    m_active      = false;\n    m_diff        = 0;\n    m_ip          = nullptr;\n    m_tls         = nullptr;\n    m_fingerprint = nullptr;\n\n    m_failures++;\n    m_latency.clear();\n}","filepath":"src/base/net/stratum/NetworkState.cpp","line_number":356,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.10.0"},"4618496":{"score":0.6691935,"function_name":"xmrig::NetworkState::latency","code":"uint32_t xmrig::NetworkState::latency() const\n{\n    const size_t calls = m_latency.size();\n    if (calls == 0) {\n        return 0;\n    }\n\n    auto v = m_latency;\n    std::nth_element(v.begin(), v.begin() + calls / 2, v.end());\n\n    return v[calls / 2];\n}","filepath":"src/base/net/stratum/NetworkState.cpp","line_number":306,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.10.0"},"4618704":{"score":0.6757037,"function_name":"__inplace_stable_sort","code":"void\n    __inplace_stable_sort(_RandomAccessIterator __first,\n\t\t\t  _RandomAccessIterator __last, _Compare __comp)\n    {\n      if (__last - __first \u003c 15)\n\t{\n\t  std::__insertion_sort(__first, __last, __comp);\n\t  return;\n\t}\n      _RandomAccessIterator __middle = __first + (__last - __first) / 2;\n      std::__inplace_stable_sort(__first, __middle, __comp);\n      std::__inplace_stable_sort(__middle, __last, __comp);\n      std::__merge_without_buffer(__first, __middle, __last,\n\t\t\t\t  __middle - __first,\n\t\t\t\t  __last - __middle,\n\t\t\t\t  __comp);\n    }","filepath":"libstdc++-v3/include/bits/stl_algo.h","line_number":2770,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-5"},"4619264":{"score":0.83441955,"function_name":"xmrig::NetworkState::add","code":"void xmrig::NetworkState::add(const SubmitResult \u0026result, const char *error)\n{\n    if (error) {\n        m_rejected++;\n        return;\n    }\n\n    m_accepted++;\n    m_hashes += result.diff;\n\n    const size_t ln = m_topDiff.size() - 1;\n    if (result.actualDiff \u003e m_topDiff[ln]) {\n        m_topDiff[ln] = result.actualDiff;\n        std::sort(m_topDiff.rbegin(), m_topDiff.rend());\n    }\n\n    m_latency.push_back(result.elapsed \u003e 0xFFFF ? 0xFFFF : static_cast\u003cuint16_t\u003e(result.elapsed));\n}","filepath":"src/base/net/stratum/NetworkState.cpp","line_number":336,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.10.0"},"4621504":{"score":0.6872311,"function_name":"App::~App","code":"App::~App()\n{\n    Mem::release();\n\n    uv_tty_reset_mode();\n\n    delete m_console;\n    delete m_controller;\n\n#   ifndef XMRIG_NO_HTTPD\n    delete m_httpd;\n#   endif\n}","filepath":"src/App.cpp","line_number":77,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"4621680":{"score":0.616515,"function_name":"App::onSignal","code":"void App::onSignal(uv_signal_t *handle, int signum)\n{\n    switch (signum)\n    {\n    case SIGHUP:\n        LOG_WARN(\"SIGHUP received, exiting\");\n        break;\n\n    case SIGTERM:\n        LOG_WARN(\"SIGTERM received, exiting\");\n        break;\n\n    case SIGINT:\n        LOG_WARN(\"SIGINT received, exiting\");\n        break;\n\n    default:\n        break;\n    }\n\n    uv_signal_stop(handle);\n    m_self-\u003eclose();\n}","filepath":"src/App.cpp","line_number":195,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"4621920":{"score":0.7446915,"function_name":"App::onConsoleCommand","code":"void App::onConsoleCommand(char command)\n{\n    switch (command) {\n    case 'h':\n    case 'H':\n        Workers::printHashrate(true);\n        break;\n\n    case 'p':\n    case 'P':\n        if (Workers::isEnabled()) {\n            LOG_INFO(m_controller-\u003econfig()-\u003eisColors() ? \"\\x1B[01;33mpaused\\x1B[0m, press \\x1B[01;35mr\\x1B[0m to resume\" : \"paused, press 'r' to resume\");\n            Workers::setEnabled(false);\n        }\n        break;\n\n    case 'r':\n    case 'R':\n        if (!Workers::isEnabled()) {\n            LOG_INFO(m_controller-\u003econfig()-\u003eisColors() ? \"\\x1B[01;32mresumed\" : \"resumed\");\n            Workers::setEnabled(true);\n        }\n        break;\n\n    case 3:\n        LOG_WARN(\"Ctrl+C received, exiting\");\n        close();\n        break;\n\n    default:\n        break;\n    }\n}","filepath":"src/App.cpp","line_number":146,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"4622336":{"score":0.6785661,"function_name":"App::App","code":"App::App(int argc, char **argv) :\n    m_console(nullptr),\n    m_httpd(nullptr)\n{\n    m_self = this;\n\n    m_controller = new xmrig::Controller();\n    if (m_controller-\u003einit(argc, argv) != 0) {\n        return;\n    }\n\n    if (!m_controller-\u003econfig()-\u003eisBackground()) {\n        m_console = new Console(this);\n    }\n\n    uv_signal_init(uv_default_loop(), \u0026m_sigHUP);\n    uv_signal_init(uv_default_loop(), \u0026m_sigINT);\n    uv_signal_init(uv_default_loop(), \u0026m_sigTERM);\n}","filepath":"src/App.cpp","line_number":56,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"4622576":{"score":0.6793222,"function_name":"App::exec","code":"int App::exec()\n{\n    if (!m_controller-\u003eisReady()) {\n        return 2;\n    }\n\n    uv_signal_start(\u0026m_sigHUP,  App::onSignal, SIGHUP);\n    uv_signal_start(\u0026m_sigINT,  App::onSignal, SIGINT);\n    uv_signal_start(\u0026m_sigTERM, App::onSignal, SIGTERM);\n\n    background();\n\n    Mem::allocate(m_controller-\u003econfig()-\u003ealgorithm(),\n                  m_controller-\u003econfig()-\u003ethreadsCount(),\n                  m_controller-\u003econfig()-\u003eisDoubleHash(),\n                  m_controller-\u003econfig()-\u003eisHugePages()\n                  );\n\n    Summary::print(m_controller);\n\n    if (m_controller-\u003econfig()-\u003eisDryRun()) {\n        LOG_NOTICE(\"OK\");\n        release();\n\n        return 0;\n    }\n\n#   ifndef XMRIG_NO_API\n    Api::start(m_controller);\n#   endif\n\n#   ifndef XMRIG_NO_HTTPD\n    m_httpd = new Httpd(\n                m_controller-\u003econfig()-\u003eapiPort(),\n                m_controller-\u003econfig()-\u003eapiToken(),\n                m_controller-\u003econfig()-\u003eisApiIPv6(),\n                m_controller-\u003econfig()-\u003eisApiRestricted()\n                );\n\n    m_httpd-\u003estart();\n#   endif\n\n    Workers::start(m_controller);\n\n    m_controller-\u003enetwork()-\u003econnect();\n\n    const int r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n    uv_loop_close(uv_default_loop());\n\n    release();\n    return r;\n}","filepath":"src/App.cpp","line_number":92,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"4623104":{"score":0.8322233,"function_name":"xmrig::CommonConfig::parseBoolean","code":"bool xmrig::CommonConfig::parseBoolean(int key, bool enable)\n{\n    switch (key) {\n    case BackgroundKey: /* --background */\n        m_background = enable;\n        break;\n\n    case SyslogKey: /* --syslog */\n        m_syslog = enable;\n        break;\n\n    case KeepAliveKey: /* --keepalive */\n        m_pools.back()-\u003esetKeepAlive(enable ? Url::kKeepAliveTimeout : 0);\n        break;\n\n#   ifndef XMRIG_PROXY_PROJECT\n    case NicehashKey: /* --nicehash */\n        m_pools.back()-\u003esetNicehash(enable);\n        break;\n#   endif\n\n    case ColorKey: /* --no-color */\n        m_colors = enable;\n        break;\n\n    case WatchKey: /* watch */\n        m_watch = enable;\n        break;\n\n    case ApiIPv6Key: /* ipv6 */\n        m_apiIPv6 = enable;\n\n    case ApiRestrictedKey: /* restricted */\n        m_apiRestricted = enable;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/CommonConfig.cpp","line_number":140,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta2"},"4623424":{"score":0.8724359,"function_name":"xmrig::CommonConfig::parseInt","code":"bool xmrig::CommonConfig::parseInt(int key, int arg)\n{\n    switch (key) {\n    case RetriesKey: /* --retries */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 1000) {\n            m_retries = arg;\n        }\n        break;\n\n    case RetryPauseKey: /* --retry-pause */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 3600) {\n            m_retryPause = arg;\n        }\n        break;\n\n    case KeepAliveKey: /* --keepalive */\n        m_pools.back()-\u003esetKeepAlive(arg);\n        break;\n\n    case VariantKey: /* --variant */\n        m_pools.back()-\u003esetVariant(arg);\n        break;\n\n    case DonateLevelKey: /* --donate-level */\n        if (arg \u003e= kMinDonateLevel \u0026\u0026 arg \u003c= 99) {\n            m_donateLevel = arg;\n        }\n        break;\n\n    case ApiPort: /* --api-port */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 65536) {\n            m_apiPort = arg;\n        }\n        break;\n\n    case PrintTimeKey: /* --print-time */\n        if (arg \u003e= 0 \u0026\u0026 arg \u003c= 3600) {\n            m_printTime = arg;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/CommonConfig.cpp","line_number":316,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"4623648":{"score":0.5486593,"function_name":"print_api","code":"static void print_api(xmrig::Config *config)\n{\n    const int port = config-\u003eapiPort();\n    if (port == 0) {\n        return;\n    }\n\n    Log::i()-\u003etext(config-\u003eisColors() ? GREEN_BOLD(\" * \") WHITE_BOLD(\"%-13s\") CYAN(\"%s:\") CYAN_BOLD(\"%d\")\n                                      : \" * %-13s%s:%d\",\n                   \"API BIND\", config-\u003eisApiIPv6() ? \"[::]\" : \"0.0.0.0\", port);\n}","filepath":"src/Summary.cpp","line_number":125,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.7.0-beta"},"4624144":{"score":0.66282725,"function_name":"xmrig::CommonConfig::printVersions","code":"void xmrig::CommonConfig::printVersions()\n{\n    char buf[256] = { 0 };\n\n#   if defined(__clang__)\n    snprintf(buf, sizeof buf, \"clang/%d.%d.%d\", __clang_major__, __clang_minor__, __clang_patchlevel__);\n#   elif defined(__GNUC__)\n    snprintf(buf, sizeof buf, \"gcc/%d.%d.%d\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#   elif defined(_MSC_VER)\n    snprintf(buf, sizeof buf, \"MSVC/%d\", MSVC_VERSION);\n#   endif\n\n    Log::i()-\u003etext(isColors() ? GREEN_BOLD(\" * \") WHITE_BOLD(\"%-13s\") CYAN_BOLD(\"%s/%s\") WHITE_BOLD(\" %s\")\n                              : \" * %-13s%s/%s %s\",\n                   \"ABOUT\", APP_NAME, APP_VERSION, buf);\n\n#   if defined(XMRIG_AMD_PROJECT)\n#   if CL_VERSION_2_0\n    const char *ocl = \"2.0\";\n#   elif CL_VERSION_1_2\n    const char *ocl = \"1.2\";\n#   elif CL_VERSION_1_1\n    const char *ocl = \"1.1\";\n#   elif CL_VERSION_1_0\n    const char *ocl = \"1.0\";\n#   else\n    const char *ocl = \"0.0\";\n#   endif\n    int length = snprintf(buf, sizeof buf, \"OpenCL/%s \", ocl);\n#   elif defined(XMRIG_NVIDIA_PROJECT)\n    const int cudaVersion = cuda_get_runtime_version();\n    int length = snprintf(buf, sizeof buf, \"CUDA/%d.%d \", cudaVersion / 1000, cudaVersion % 100);\n#   else\n    memset(buf, 0, 16);\n\n#   if !defined(XMRIG_NO_HTTPD) || !defined(XMRIG_NO_TLS)\n    int length = 0;\n#   endif\n#   endif\n\n#   if !defined(XMRIG_NO_TLS) \u0026\u0026 defined(OPENSSL_VERSION_TEXT)\n    {\n        constexpr const char *v = OPENSSL_VERSION_TEXT + 8;\n        length += snprintf(buf + length, (sizeof buf) - length, \"OpenSSL/%.*s \", static_cast\u003cint\u003e(strchr(v, ' ') - v), v);\n    }\n#   endif\n\n#   ifndef XMRIG_NO_HTTPD\n    length += snprintf(buf + length, (sizeof buf) - length, \"microhttpd/%s \", MHD_get_version());\n#   endif\n\n    Log::i()-\u003etext(isColors() ? GREEN_BOLD(\" * \") WHITE_BOLD(\"%-13slibuv/%s %s\")\n                              : \" * %-13slibuv/%s %s\",\n                   \"LIBS\", uv_version_string(), buf);\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":109,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4624576":{"score":0.88923526,"function_name":"xmrig::CommonConfig::parseInt","code":"bool xmrig::CommonConfig::parseInt(int key, int arg)\n{\n    switch (key) {\n    case RetriesKey: /* --retries */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 1000) {\n            m_retries = arg;\n        }\n        break;\n\n    case RetryPauseKey: /* --retry-pause */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 3600) {\n            m_retryPause = arg;\n        }\n        break;\n\n    case KeepAliveKey: /* --keepalive */\n        m_pools.back()-\u003esetKeepAlive(arg);\n        break;\n\n    case VariantKey: /* --variant */\n        m_pools.back()-\u003esetVariant(arg);\n        break;\n\n    case DonateLevelKey: /* --donate-level */\n        if (arg \u003e= kMinimumDonateLevel \u0026\u0026 arg \u003c= 99) {\n            m_donateLevel = arg;\n        }\n        break;\n\n    case ApiPort: /* --api-port */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 65536) {\n            m_apiPort = arg;\n        }\n        break;\n\n    case PrintTimeKey: /* --print-time */\n        if (arg \u003e= 0 \u0026\u0026 arg \u003c= 3600) {\n            m_printTime = arg;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/CommonConfig.cpp","line_number":328,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta2"},"4624800":{"score":0.6731077,"function_name":"Options::parseArg","code":"bool Options::parseArg(int key, char *arg)\n{\n    char *p;\n    int v;\n    uint64_t ul;\n    Url *url;\n\n    switch (key) {\n    case 'a': /* --algo */\n        if (!setAlgo(arg)) {\n            return false;\n        }\n        break;\n\n    case 'O': /* --userpass */\n        if (!setUserpass(arg)) {\n            return false;\n        }\n        break;\n\n    case 'o': /* --url */\n        url = parseUrl(arg);\n        if (url) {\n            free(m_url);\n            m_url = url;\n        }\n        break;\n\n    case 'b': /* --backup-url */\n        url = parseUrl(arg);\n        if (url) {\n            free(m_backupUrl);\n            m_backupUrl = url;\n        }\n        break;\n\n    case 'u': /* --user */\n        free(m_user);\n        m_user = strdup(arg);\n        break;\n\n    case 'p': /* --pass */\n        free(m_pass);\n        m_pass = strdup(arg);\n        break;\n\n    case 'r': /* --retries */\n        v = strtol(arg, nullptr, 10);\n        if (v \u003c 1 || v \u003e 1000) {\n            showUsage(1);\n            return false;\n        }\n\n        m_retries = v;\n        break;\n\n    case 'R': /* --retry-pause */\n        v = strtol(arg, nullptr, 10);\n        if (v \u003c 1 || v \u003e 3600) {\n            showUsage(1);\n            return false;\n        }\n\n        m_retryPause = v;\n        break;\n\n    case 't': /* --threads */\n        v = strtol(arg, nullptr, 10);\n        if (v \u003c 1 || v \u003e 1024) {\n            showUsage(1);\n            return false;\n        }\n\n        m_threads = v;\n        break;\n\n    case 1004: /* --max-cpu-usage */\n        v = strtol(arg, nullptr, 10);\n        if (v \u003c 1 || v \u003e 100) {\n            showUsage(1);\n            return false;\n        }\n\n        m_maxCpuUsage = v;\n        break;\n\n    case 1005: /* --safe */\n        m_safe = true;\n        break;\n\n    case 'k': /* --keepalive */\n        m_keepAlive = true;\n        break;\n\n    case 'V': /* --version */\n        showVersion();\n        return false;\n\n    case 'h': /* --help */\n        showUsage(0);\n        return false;\n\n    case 'B': /* --background */\n        m_background = true;\n        m_colors = false;\n        break;\n\n    case 'v': /* --av */\n        v = strtol(arg, nullptr, 10);\n        if (v \u003c 0 || v \u003e 1000) {\n            showUsage(1);\n            return false;\n        }\n\n        m_algoVariant = v;\n        break;\n\n    case 1020: /* --cpu-affinity */\n        p  = strstr(arg, \"0x\");\n        ul = p ? strtoul(p, NULL, 16) : atol(arg);\n        if (ul \u003e (1UL \u003c\u003c Cpu::threads()) -1) {\n            ul = -1;\n        }\n\n        m_affinity = ul;\n        break;\n\n    case 1002: /* --no-color */\n        m_colors = false;\n        break;\n\n    case 1003: /* --donate-level */\n        v = strtol(arg, nullptr, 10);\n        if (v \u003c 1 || v \u003e 99) {\n            showUsage(1);\n            return false;\n        }\n\n        m_donateLevel = v;\n        break;\n\n    case 1006: /* --nicehash */\n        m_nicehash = true;\n        break;\n\n    case 1007: /* --print-time */\n        v = strtol(arg, nullptr, 10);\n        if (v \u003c 0 || v \u003e 1000) {\n            showUsage(1);\n            return false;\n        }\n\n        m_printTime = v;\n        break;\n\n    default:\n        showUsage(1);\n        return false;\n    }\n\n    return true;\n}","filepath":"src/Options.cpp","line_number":221,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.0"},"4627232":{"score":0.9004869,"function_name":"xmrig::CommonConfig::finalize","code":"bool xmrig::CommonConfig::finalize()\n{\n    if (m_state == ReadyState) {\n        return true;\n    }\n\n    if (m_state == ErrorState) {\n        return false;\n    }\n\n    if (!m_algorithm.isValid()) {\n        return false;\n    }\n\n    for (Pool \u0026pool : m_pools) {\n        pool.adjust(m_algorithm);\n\n        if (pool.isValid() \u0026\u0026 pool.algorithm().isValid()) {\n            m_activePools.push_back(std::move(pool));\n        }\n    }\n\n    m_pools.clear();\n\n    if (m_activePools.empty()) {\n        m_state = ErrorState;\n        return false;\n    }\n\n    m_state = ReadyState;\n    return true;\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":111,"entry_url":"https://github.com/xmrig/xmrig-proxy.git","slot_name":"v2.6.5"},"4627808":{"score":0.5558803,"function_name":"xmrig::CommonConfig::CommonConfig","code":"xmrig::CommonConfig::CommonConfig() :\n    m_algorithm(CRYPTONIGHT),\n    m_adjusted(false),\n    m_apiIPv6(false),\n    m_apiRestricted(true),\n    m_background(false),\n    m_colors(true),\n    m_syslog(false),\n\n#   ifdef XMRIG_PROXY_PROJECT\n    m_watch(true),\n#   else\n    m_watch(false), // TODO: enable config file watch by default when this feature propertly handled and tested.\n#   endif\n\n    m_apiToken(nullptr),\n    m_apiWorkerId(nullptr),\n    m_fileName(nullptr),\n    m_logFile(nullptr),\n    m_userAgent(nullptr),\n    m_apiPort(0),\n    m_donateLevel(kDefaultDonateLevel),\n    m_printTime(60),\n    m_retries(5),\n    m_retryPause(5)\n{\n    m_pools.push_back(new Url());\n\n#   ifdef XMRIG_PROXY_PROJECT\n    m_retries    = 2;\n    m_retryPause = 1;\n#   endif\n}","filepath":"src/core/CommonConfig.cpp","line_number":61,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta2"},"4628432":{"score":0.71193683,"function_name":"xmrig::CommonConfig::save","code":"bool xmrig::CommonConfig::save()\n{\n    if (!m_fileName) {\n        return false;\n    }\n\n    uv_fs_t req;\n    const int fd = uv_fs_open(uv_default_loop(), \u0026req, m_fileName, O_WRONLY | O_CREAT | O_TRUNC, 0644, nullptr);\n    if (fd \u003c 0) {\n        return false;\n    }\n\n    uv_fs_req_cleanup(\u0026req);\n\n    rapidjson::Document doc;\n    getJSON(doc);\n\n    FILE *fp = fdopen(fd, \"w\");\n\n    char buf[4096];\n    rapidjson::FileWriteStream os(fp, buf, sizeof(buf));\n    rapidjson::PrettyWriter\u003crapidjson::FileWriteStream\u003e writer(os);\n    doc.Accept(writer);\n\n    fclose(fp);\n\n    uv_fs_close(uv_default_loop(), \u0026req, fd, nullptr);\n    uv_fs_req_cleanup(\u0026req);\n\n    LOG_NOTICE(\"configuration saved to: \\\"%s\\\"\", m_fileName);\n    return true;\n}","filepath":"src/core/CommonConfig.cpp","line_number":287,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta2"},"4633152":{"score":0.68426514,"function_name":"Accept","code":"bool Accept(Handler\u0026 handler) const {\n        switch(GetType()) {\n        case kNullType:     return handler.Null();\n        case kFalseType:    return handler.Bool(false);\n        case kTrueType:     return handler.Bool(true);\n\n        case kObjectType:\n            if (RAPIDJSON_UNLIKELY(!handler.StartObject()))\n                return false;\n            for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {\n                RAPIDJSON_ASSERT(m-\u003ename.IsString()); // User may change the type of name by MemberIterator.\n                if (RAPIDJSON_UNLIKELY(!handler.Key(m-\u003ename.GetString(), m-\u003ename.GetStringLength(), (m-\u003ename.data_.f.flags \u0026 kCopyFlag) != 0)))\n                    return false;\n                if (RAPIDJSON_UNLIKELY(!m-\u003evalue.Accept(handler)))\n                    return false;\n            }\n            return handler.EndObject(data_.o.size);\n\n        case kArrayType:\n            if (RAPIDJSON_UNLIKELY(!handler.StartArray()))\n                return false;\n            for (ConstValueIterator v = Begin(); v != End(); ++v)\n                if (RAPIDJSON_UNLIKELY(!v-\u003eAccept(handler)))\n                    return false;\n            return handler.EndArray(data_.a.size);\n    \n        case kStringType:\n            return handler.String(GetString(), GetStringLength(), (data_.f.flags \u0026 kCopyFlag) != 0);\n    \n        default:\n            RAPIDJSON_ASSERT(GetType() == kNumberType);\n            if (IsDouble())         return handler.Double(data_.n.d);\n            else if (IsInt())       return handler.Int(data_.n.i.i);\n            else if (IsUint())      return handler.Uint(data_.n.u.u);\n            else if (IsInt64())     return handler.Int64(data_.n.i64);\n            else                    return handler.Uint64(data_.n.u64);\n        }\n    }","filepath":"dep/rapidjson/rapidjson/document.h","line_number":1948,"entry_url":"https://github.com/TrinityCore/TrinityCore.git","slot_name":"TDB927.22081"},"4643872":{"score":0.532709,"function_name":"xmrig::ConfigLoader::parseJSON","code":"void xmrig::ConfigLoader::parseJSON(xmrig::IConfig *config, const struct option *option, const rapidjson::Value \u0026object)\n{\n    if (!option-\u003ename || !object.HasMember(option-\u003ename)) {\n        return;\n    }\n\n    const rapidjson::Value \u0026value = object[option-\u003ename];\n\n    if (option-\u003ehas_arg) {\n        if (value.IsString()) {\n            config-\u003eparseString(option-\u003eval, value.GetString());\n        }\n        else if (value.IsInt64()) {\n            config-\u003eparseUint64(option-\u003eval, value.GetUint64());\n        }\n        else if (value.IsBool()) {\n            config-\u003eparseBoolean(option-\u003eval, value.IsTrue());\n        }\n    }\n    else if (value.IsBool()) {\n        config-\u003eparseBoolean(option-\u003eval, value.IsTrue());\n    }\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":259,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4644912":{"score":0.5703439,"function_name":"xmrig::ConfigLoader::loadFromJSON","code":"bool xmrig::ConfigLoader::loadFromJSON(xmrig::IConfig *config, const rapidjson::Document \u0026doc)\n{\n    for (size_t i = 0; i \u003c ARRAY_SIZE(config_options); i++) {\n        parseJSON(config, \u0026config_options[i], doc);\n    }\n\n    const rapidjson::Value \u0026pools = doc[\"pools\"];\n    if (pools.IsArray()) {\n        for (const rapidjson::Value \u0026value : pools.GetArray()) {\n            if (!value.IsObject()) {\n                continue;\n            }\n\n            for (size_t i = 0; i \u003c ARRAY_SIZE(pool_options); i++) {\n                parseJSON(config, \u0026pool_options[i], value);\n            }\n        }\n    }\n\n    const rapidjson::Value \u0026api = doc[\"api\"];\n    if (api.IsObject()) {\n        for (size_t i = 0; i \u003c ARRAY_SIZE(api_options); i++) {\n            parseJSON(config, \u0026api_options[i], api);\n        }\n    }\n\n    config-\u003eparseJSON(doc);\n\n    return config-\u003efinalize();\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":89,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4646000":{"score":0.49827194,"function_name":"xmrig::ConfigLoader::showVersion","code":"void xmrig::ConfigLoader::showVersion()\n{\n    printf(APP_NAME \" \" APP_VERSION \"\\n built on \" __DATE__\n\n#   if defined(__clang__)\n    \" with clang \" __clang_version__);\n#   elif defined(__GNUC__)\n    \" with GCC\");\n    printf(\" %d.%d.%d\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#   elif defined(_MSC_VER)\n    \" with MSVC\");\n    printf(\" %d\", MSVC_VERSION);\n#   else\n    );\n#   endif\n\n    printf(\"\\n features:\"\n#   if defined(__i386__) || defined(_M_IX86)\n    \" 32-bit\"\n#   elif defined(__x86_64__) || defined(_M_AMD64)\n    \" 64-bit\"\n#   endif\n\n#   if defined(__AES__) || defined(_MSC_VER)\n    \" AES\"\n#   endif\n    \"\\n\");\n\n    printf(\"\\nlibuv/%s\\n\", uv_version_string());\n\n#   ifndef XMRIG_NO_HTTPD\n    printf(\"microhttpd/%s\\n\", MHD_get_version());\n#   endif\n\n#   if !defined(XMRIG_NO_TLS) \u0026\u0026 defined(OPENSSL_VERSION_TEXT)\n    {\n        constexpr const char *v = OPENSSL_VERSION_TEXT + 8;\n        printf(\"OpenSSL/%.*s\\n\", static_cast\u003cint\u003e(strchr(v, ' ') - v), v);\n    }\n#   endif\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":290,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4648448":{"score":0.647668,"function_name":"xmrig::ConfigLoader::reload","code":"bool xmrig::ConfigLoader::reload(xmrig::IConfig *oldConfig, const char *json)\n{\n    xmrig::IConfig *config = m_creator-\u003ecreate();\n    if (!loadFromJSON(config, json)) {\n        delete config;\n\n        return false;\n    }\n\n    config-\u003esetFileName(oldConfig-\u003efileName());\n    const bool saved = config-\u003esave();\n\n    if (config-\u003eisWatch() \u0026\u0026 m_watcher \u0026\u0026 saved) {\n        delete config;\n\n        return true;\n    }\n\n    m_listener-\u003eonNewConfig(config);\n    return true;\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":121,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4648784":{"score":0.62455404,"function_name":"xmrig::ConfigLoader::getJSON","code":"bool xmrig::ConfigLoader::getJSON(const char *fileName, rapidjson::Document \u0026doc)\n{\n    uv_fs_t req;\n    const int fd = uv_fs_open(uv_default_loop(), \u0026req, fileName, O_RDONLY, 0644, nullptr);\n    if (fd \u003c 0) {\n        fprintf(stderr, \"unable to open %s: %s\\n\", fileName, uv_strerror(fd));\n        return false;\n    }\n\n    uv_fs_req_cleanup(\u0026req);\n\n    FILE *fp = fdopen(fd, \"rb\");\n    char buf[8192];\n    rapidjson::FileReadStream is(fp, buf, sizeof(buf));\n\n    doc.ParseStream(is);\n\n    uv_fs_close(uv_default_loop(), \u0026req, fd, nullptr);\n    uv_fs_req_cleanup(\u0026req);\n\n    if (doc.HasParseError()) {\n        printf(\"%s\u003c%d\u003e: %s\\n\", fileName, (int) doc.GetErrorOffset(), rapidjson::GetParseError_En(doc.GetParseError()));\n        return false;\n    }\n\n    return doc.IsObject();\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":207,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4649632":{"score":0.55841964,"function_name":"xmrig::ConfigLoader::loadFromFile","code":"bool xmrig::ConfigLoader::loadFromFile(xmrig::IConfig *config, const char *fileName)\n{\n    rapidjson::Document doc;\n    if (!getJSON(fileName, doc)) {\n        return false;\n    }\n\n    config-\u003esetFileName(fileName);\n\n    return loadFromJSON(config, doc);\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":63,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4650032":{"score":0.51325846,"function_name":"xmrig::ConfigLoader::parseArg","code":"bool xmrig::ConfigLoader::parseArg(xmrig::IConfig *config, int key, const char *arg)\n{\n    switch (key) {\n    case xmrig::IConfig::VersionKey: /* --version */\n        showVersion();\n        return false;\n\n    case xmrig::IConfig::HelpKey: /* --help */\n        showUsage();\n        return false;\n\n    case xmrig::IConfig::ConfigKey: /* --config */\n        loadFromFile(config, arg);\n        break;\n\n    default:\n        return config-\u003eparseString(key, arg);;\n    }\n\n    return true;\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":236,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4650288":{"score":0.5727171,"function_name":"xmrig::ConfigLoader::load","code":"xmrig::IConfig *xmrig::ConfigLoader::load(int argc, char **argv, IConfigCreator *creator, IWatcherListener *listener)\n{\n    m_creator  = creator;\n    m_listener = listener;\n\n    xmrig::IConfig *config = m_creator-\u003ecreate();\n    int key;\n\n    while (1) {\n        key = getopt_long(argc, argv, short_options, options, NULL);\n        if (key \u003c 0) {\n            break;\n        }\n\n        if (!parseArg(config, key, optarg)) {\n            delete config;\n            return nullptr;\n        }\n    }\n\n    if (optind \u003c argc) {\n        fprintf(stderr, \"%s: unsupported non-option argument '%s'\\n\", argv[0], argv[optind]);\n        delete config;\n        return nullptr;\n    }\n\n    if (!config-\u003efinalize()) {\n        delete config;\n\n        config = m_creator-\u003ecreate();\n        loadFromFile(config, Platform::defaultConfigName());\n    }\n\n    if (!config-\u003efinalize()) {\n        if (!config-\u003ealgorithm().isValid()) {\n            fprintf(stderr, \"No valid algorithm specified. Exiting.\\n\");\n        }\n        else {\n            fprintf(stderr, \"No valid configuration found. Exiting.\\n\");\n        }\n\n        delete config;\n        return nullptr;\n    }\n\n    if (config-\u003eisWatch()) {\n        m_watcher = new xmrig::ConfigWatcher(config-\u003efileName(), creator, listener);\n    }\n\n    return config;\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":144,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4655936":{"score":0.78890026,"function_name":"Encode","code":"RAPIDJSON_NAMESPACE_BEGIN\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Encoding\r\n\r\n/*! \\class rapidjson::Encoding\r\n    \\brief Concept for encoding of Unicode characters.\r\n\r\n\\code\r\nconcept Encoding {\r\n    typename Ch;    //! Type of character. A \"character\" is actually a code unit in unicode's definition.\r\n\r\n    enum { supportUnicode = 1 }; // or 0 if not supporting unicode\r\n\r\n    //! \\brief Encode a Unicode codepoint to an output stream.\r\n    //! \\param os Output stream.\r\n    //! \\param codepoint An unicode codepoint, ranging from 0x0 to 0x10FFFF inclusively.\r\n    template\u003ctypename OutputStream\u003e\r\n    static void Encode(OutputStream\u0026 os, unsigned codepoint);\r\n\r\n    //! \\brief Decode a Unicode codepoint from an input stream.\r\n    //! \\param is Input stream.\r\n    //! \\param codepoint Output of the unicode codepoint.\r\n    //! \\return true if a valid codepoint can be decoded from the stream.\r\n    template \u003ctypename InputStream\u003e\r\n    static bool Decode(InputStream\u0026 is, unsigned* codepoint);\r\n\r\n    //! \\brief Validate one Unicode codepoint from an encoded stream.\r\n    //! \\param is Input stream to obtain codepoint.\r\n    //! \\param os Output for copying one codepoint.\r\n    //! \\return true if it is valid.\r\n    //! \\note This function just validating and copying the codepoint without actually decode it.\r\n    template \u003ctypename InputStream, typename OutputStream\u003e\r\n    static bool Validate(InputStream\u0026 is, OutputStream\u0026 os);\r\n\r\n    // The following functions are deal with byte streams.\r\n\r\n    //! Take a character from input byte stream, skip BOM if exist.\r\n    template \u003ctypename InputByteStream\u003e\r\n    static CharType TakeBOM(InputByteStream\u0026 is);\r\n\r\n    //! Take a character from input byte stream.\r\n    template \u003ctypename InputByteStream\u003e\r\n    static Ch Take(InputByteStream\u0026 is);\r\n\r\n    //! Put BOM to output byte stream.\r\n    template \u003ctypename OutputByteStream\u003e\r\n    static void PutBOM(OutputByteStream\u0026 os);\r\n\r\n    //! Put a character to output byte stream.\r\n    template \u003ctypename OutputByteStream\u003e\r\n    static void Put(OutputByteStream\u0026 os, Ch c);\r\n};\r\n\\endcode\r\n*/\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// UTF8\r\n\r\n//! UTF-8 encoding.\r\n/*! http://en.wikipedia.org/wiki/UTF-8\r\n    http://tools.ietf.org/html/rfc3629\r\n    \\tparam CharType Code unit for storing 8-bit UTF-8 data. Default is char.\r\n    \\note implements Encoding concept\r\n*/\r\ntemplate\u003ctypename CharType = char\u003e\r\nstruct UTF8 {\r\n    typedef CharType Ch;\r\n\r\n    enum { supportUnicode = 1 };\r\n\r\n    template\u003ctypename OutputStream\u003e\r\n    static void Encode(OutputStream\u0026 os, unsigned codepoint) {\r\n        if (codepoint \u003c= 0x7F) \r\n            os.Put(static_cast\u003cCh\u003e(codepoint \u0026 0xFF));\r\n        else if (codepoint \u003c= 0x7FF) {\r\n            os.Put(static_cast\u003cCh\u003e(0xC0 | ((codepoint \u003e\u003e 6) \u0026 0xFF)));\r\n            os.Put(static_cast\u003cCh\u003e(0x80 | ((codepoint \u0026 0x3F))));\r\n        }\r\n        else if (codepoint \u003c= 0xFFFF) {\r\n            os.Put(static_cast\u003cCh\u003e(0xE0 | ((codepoint \u003e\u003e 12) \u0026 0xFF)));\r\n            os.Put(static_cast\u003cCh\u003e(0x80 | ((codepoint \u003e\u003e 6) \u0026 0x3F)));\r\n            os.Put(static_cast\u003cCh\u003e(0x80 | (codepoint \u0026 0x3F)));\r\n        }\r\n        else {\r\n            RAPIDJSON_ASSERT(codepoint \u003c= 0x10FFFF);\r\n            os.Put(static_cast\u003cCh\u003e(0xF0 | ((codepoint \u003e\u003e 18) \u0026 0xFF)));\r\n            os.Put(static_cast\u003cCh\u003e(0x80 | ((codepoint \u003e\u003e 12) \u0026 0x3F)));\r\n            os.Put(static_cast\u003cCh\u003e(0x80 | ((codepoint \u003e\u003e 6) \u0026 0x3F)));\r\n            os.Put(static_cast\u003cCh\u003e(0x80 | (codepoint \u0026 0x3F)));\r\n        }\r\n    }","filepath":"src/thirdparty/rapidjson/encodings.h","line_number":30,"entry_url":"https://github.com/tunabrain/tungsten.git","slot_name":"v0.1.0"},"4657424":{"score":0.66023034,"function_name":"ParseStringToStream","code":"RAPIDJSON_FORCEINLINE void ParseStringToStream(InputStream\u0026 is, OutputStream\u0026 os) {\r\n//!@cond RAPIDJSON_HIDDEN_FROM_DOXYGEN\r\n#define Z16 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\r\n        static const char escape[256] = {\r\n            Z16, Z16, 0, 0,'\\\"', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'/', \r\n            Z16, Z16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\\\', 0, 0, 0, \r\n            0, 0,'\\b', 0, 0, 0,'\\f', 0, 0, 0, 0, 0, 0, 0,'\\n', 0, \r\n            0, 0,'\\r', 0,'\\t', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \r\n            Z16, Z16, Z16, Z16, Z16, Z16, Z16, Z16\r\n        };\r\n#undef Z16\r\n//!@endcond\r\n\r\n        RAPIDJSON_ASSERT(is.Peek() == '\\\"');\r\n        is.Take();  // Skip '\\\"'\r\n\r\n        for (;;) {\r\n            Ch c = is.Peek();\r\n            if (c == '\\\\') {    // Escape\r\n                is.Take();\r\n                Ch e = is.Take();\r\n                if ((sizeof(Ch) == 1 || unsigned(e) \u003c 256) \u0026\u0026 escape[(unsigned char)e]) {\r\n                    os.Put(escape[(unsigned char)e]);\r\n                }\r\n                else if (e == 'u') {    // Unicode\r\n                    unsigned codepoint = ParseHex4(is);\r\n                    if (codepoint \u003e= 0xD800 \u0026\u0026 codepoint \u003c= 0xDBFF) {\r\n                        // Handle UTF-16 surrogate pair\r\n                        if (is.Take() != '\\\\' || is.Take() != 'u')\r\n                            RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, is.Tell() - 2);\r\n                        unsigned codepoint2 = ParseHex4(is);\r\n                        if (codepoint2 \u003c 0xDC00 || codepoint2 \u003e 0xDFFF)\r\n                            RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, is.Tell() - 2);\r\n                        codepoint = (((codepoint - 0xD800) \u003c\u003c 10) | (codepoint2 - 0xDC00)) + 0x10000;\r\n                    }\r\n                    TEncoding::Encode(os, codepoint);\r\n                }\r\n                else\r\n                    RAPIDJSON_PARSE_ERROR(kParseErrorStringEscapeInvalid, is.Tell() - 1);\r\n            }\r\n            else if (c == '\"') {    // Closing double quote\r\n                is.Take();\r\n                os.Put('\\0');   // null-terminate the string\r\n                return;\r\n            }\r\n            else if (c == '\\0')\r\n                RAPIDJSON_PARSE_ERROR(kParseErrorStringMissQuotationMark, is.Tell() - 1);\r\n            else if ((unsigned)c \u003c 0x20) // RFC 4627: unescaped = %x20-21 / %x23-5B / %x5D-10FFFF\r\n                RAPIDJSON_PARSE_ERROR(kParseErrorStringEscapeInvalid, is.Tell() - 1);\r\n            else {\r\n                if (parseFlags \u0026 kParseValidateEncodingFlag ? \r\n                    !Transcoder\u003cSEncoding, TEncoding\u003e::Validate(is, os) : \r\n                    !Transcoder\u003cSEncoding, TEncoding\u003e::Transcode(is, os))\r\n                    RAPIDJSON_PARSE_ERROR(kParseErrorStringInvalidEncoding, is.Tell());\r\n            }\r\n        }\r\n    }","filepath":"src/third_party/rapidjson/rapidjson/reader.h","line_number":648,"entry_url":"https://github.com/datastax/cpp-driver.git","slot_name":"2.7.1"},"4665280":{"score":0.61142623,"function_name":"ffecom_tree_canonize_ptr_","code":"static void\nffecom_tree_canonize_ptr_ (tree *decl, tree *offset,\n\t\t\t   tree t)\n{\n  switch (TREE_CODE (t))\n    {\n    case NOP_EXPR:\n    case CONVERT_EXPR:\n    case NON_LVALUE_EXPR:\n      ffecom_tree_canonize_ptr_ (decl, offset, TREE_OPERAND (t, 0));\n      break;\n\n    case PLUS_EXPR:\n      ffecom_tree_canonize_ptr_ (decl, offset, TREE_OPERAND (t, 0));\n      if ((*decl == NULL_TREE)\n\t  || (*decl == error_mark_node))\n\tbreak;\n\n      if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)\n\t{\n\t  /* An offset into COMMON.  */\n\t  *offset = size_binop (PLUS_EXPR,\n\t\t\t\t*offset,\n\t\t\t\tTREE_OPERAND (t, 1));\n\t  /* Convert offset (presumably in bytes) into canonical units\n\t     (presumably bits).  */\n\t  *offset = size_binop (MULT_EXPR,\n\t\t\t\t*offset,\n\t\t\t\tTYPE_SIZE (TREE_TYPE (TREE_TYPE (t))));\n\t  break;\n\t}\n      /* Not a COMMON reference, so an unrecognized pattern.  */\n      *decl = error_mark_node;\n      break;\n\n    case PARM_DECL:\n      *decl = t;\n      *offset = size_zero_node;\n      break;\n\n    case ADDR_EXPR:\n      if (TREE_CODE (TREE_OPERAND (t, 0)) == VAR_DECL)\n\t{\n\t  /* A reference to COMMON.  */\n\t  *decl = TREE_OPERAND (t, 0);\n\t  *offset = size_zero_node;\n\t  break;\n\t}\n      /* Fall through.  */\n    default:\n      /* Not a COMMON reference, so an unrecognized pattern.  */\n      *decl = error_mark_node;\n      break;\n    }\n}","filepath":"gcc/f/com.c","line_number":9430,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/egcs-1.0.1-prerelease"},"4683216":{"score":0.71572113,"function_name":"xmrig::ConfigWatcher::reload","code":"void xmrig::ConfigWatcher::reload()\n{\n    LOG_WARN(\"\\\"%s\\\" was changed, reloading configuration\", m_path.data());\n\n    IConfig *config = m_creator-\u003ecreate();\n    ConfigLoader::loadFromFile(config, m_path.data());\n\n    if (!config-\u003efinalize()) {\n        LOG_ERR(\"reloading failed\");\n\n        delete config;\n        return;\n    }\n\n    m_listener-\u003eonNewConfig(config);\n\n#   ifndef _WIN32\n    uv_fs_event_stop(\u0026m_fsEvent);\n    start();\n#   endif\n}","filepath":"src/common/config/ConfigWatcher.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4683520":{"score":0.5641482,"function_name":"xmrig::ConfigWatcher::ConfigWatcher","code":"xmrig::ConfigWatcher::ConfigWatcher(const char *path, IConfigCreator *creator, IWatcherListener *listener) :\n    m_creator(creator),\n    m_listener(listener),\n    m_path(path)\n{\n    uv_fs_event_init(uv_default_loop(), \u0026m_fsEvent);\n    uv_timer_init(uv_default_loop(), \u0026m_timer);\n\n    m_fsEvent.data = m_timer.data = this;\n\n    start();\n}","filepath":"src/common/config/ConfigWatcher.cpp","line_number":35,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4683744":{"score":0.7873393,"function_name":"xmrig::ConfigWatcher::reload","code":"void xmrig::ConfigWatcher::reload()\n{\n    LOG_WARN(\"\\\"%s\\\" was changed, reloading configuration\", m_path.data());\n\n    IConfig *config = m_creator-\u003ecreate();\n    ConfigLoader::loadFromFile(config, m_path.data());\n\n    if (!config-\u003efinalize()) {\n        LOG_ERR(\"reloading failed\");\n\n        delete config;\n        return;\n    }\n\n    m_listener-\u003eonNewConfig(config);\n\n#   ifndef _WIN32\n    uv_fs_event_stop(\u0026m_fsEvent);\n    start();\n#   endif\n}","filepath":"src/common/config/ConfigWatcher.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4684096":{"score":0.68914306,"function_name":"Console::onRead","code":"void Console::onRead(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf)\n{\n    if (nread \u003c 0) {\n        return uv_close(reinterpret_cast\u003cuv_handle_t*\u003e(stream), nullptr);\n    }\n\n    if (nread == 1) {\n        static_cast\u003cConsole*\u003e(stream-\u003edata)-\u003em_listener-\u003eonConsoleCommand(buf-\u003ebase[0]);\n    }\n}","filepath":"src/Console.cpp","line_number":52,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"4684144":{"score":0.7423738,"function_name":"Console::Console","code":"Console::Console(IConsoleListener *listener)\n    : m_listener(listener)\n{\n    m_tty.data = this;\n    uv_tty_init(uv_default_loop(), \u0026m_tty, 0, 1);\n\n    if (!uv_is_readable(reinterpret_cast\u003cuv_stream_t*\u003e(\u0026m_tty))) {\n        return;\n    }\n\n    uv_tty_set_mode(\u0026m_tty, UV_TTY_MODE_RAW);\n    uv_read_start(reinterpret_cast\u003cuv_stream_t*\u003e(\u0026m_tty), Console::onAllocBuffer, Console::onRead);\n}","filepath":"src/Console.cpp","line_number":29,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"4684240":{"score":0.64600945,"function_name":"xmrig::Algorithm::isValid","code":"bool xmrig::Algorithm::isValid() const\n{\n    if (m_algo == INVALID_ALGO) {\n        return false;\n    }\n\n    for (size_t i = 0; i \u003c ARRAY_SIZE(algorithms); i++) {\n        if (algorithms[i].algo == m_algo \u0026\u0026 algorithms[i].variant == m_variant) {\n            return true;\n        }\n    }\n\n    return false;\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":139,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4684432":{"score":0.73478097,"function_name":"xmrig::Algorithm::parseXmrStakAlgorithm","code":"void xmrig::Algorithm::parseXmrStakAlgorithm(const char *algo)\n{\n    m_algo    = INVALID_ALGO;\n    m_variant = VARIANT_AUTO;\n\n    assert(algo != nullptr);\n    if (algo == nullptr) {\n        return;\n    }\n\n    for (size_t i = 0; i \u003c ARRAY_SIZE(xmrStakAlgorithms); i++) {\n        if (strcasecmp(algo, xmrStakAlgorithms[i].name) == 0) {\n            m_algo    = xmrStakAlgorithms[i].algo;\n            m_variant = xmrStakAlgorithms[i].variant;\n            break;\n        }\n    }\n\n    if (m_algo == INVALID_ALGO) {\n        assert(false);\n    }\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":206,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4684592":{"score":0.59087026,"function_name":"xmrig::Algorithm::parseVariant","code":"void xmrig::Algorithm::parseVariant(const char *variant)\n{\n    m_variant = VARIANT_AUTO;\n\n    for (size_t i = 0; i \u003c ARRAY_SIZE(variants); i++) {\n        if (strcasecmp(variant, variants[i]) == 0) {\n            m_variant = static_cast\u003cVariant\u003e(i);\n            break;\n        }\n    }\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":165,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4684960":{"score":0.75247383,"function_name":"xmrig::Algorithm::parseVariant","code":"void xmrig::Algorithm::parseVariant(int variant)\n{\n    assert(variant \u003e= -1 \u0026\u0026 variant \u003c= 2);\n\n    switch (variant) {\n    case -1:\n    case 0:\n    case 1:\n        m_variant = static_cast\u003cVariant\u003e(variant);\n        break;\n\n    case 2:\n        m_variant = VARIANT_2;\n        break;\n\n    default:\n        break;\n    }\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":178,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4685024":{"score":0.6552712,"function_name":"xmrig::Algorithm::name","code":"const char *xmrig::Algorithm::name(bool shortName) const\n{\n    for (size_t i = 0; i \u003c ARRAY_SIZE(algorithms); i++) {\n        if (algorithms[i].algo == m_algo \u0026\u0026 algorithms[i].variant == m_variant) {\n            return shortName ? algorithms[i].shortName : algorithms[i].name;\n        }\n    }\n\n    return \"invalid\";\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":231,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4685472":{"score":0.8873997,"function_name":"keccakf","code":"void keccakf(uint64_t st[25], int rounds)\n{\n    int i, j, round;\n    uint64_t t, bc[5];\n\n    for (round = 0; round \u003c rounds; ++round) {\n\n        // Theta\n        bc[0] = st[0] ^ st[5] ^ st[10] ^ st[15] ^ st[20];\n        bc[1] = st[1] ^ st[6] ^ st[11] ^ st[16] ^ st[21];\n        bc[2] = st[2] ^ st[7] ^ st[12] ^ st[17] ^ st[22];\n        bc[3] = st[3] ^ st[8] ^ st[13] ^ st[18] ^ st[23];\n        bc[4] = st[4] ^ st[9] ^ st[14] ^ st[19] ^ st[24];\n\n        for (i = 0; i \u003c 5; ++i) {\n            t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);\n            st[i     ] ^= t;\n            st[i +  5] ^= t;\n            st[i + 10] ^= t;\n            st[i + 15] ^= t;\n            st[i + 20] ^= t;\n        }\n\n        // Rho Pi\n        t = st[1];\n        st[ 1] = ROTL64(st[ 6], 44);\n        st[ 6] = ROTL64(st[ 9], 20);\n        st[ 9] = ROTL64(st[22], 61);\n        st[22] = ROTL64(st[14], 39);\n        st[14] = ROTL64(st[20], 18);\n        st[20] = ROTL64(st[ 2], 62);\n        st[ 2] = ROTL64(st[12], 43);\n        st[12] = ROTL64(st[13], 25);\n        st[13] = ROTL64(st[19],  8);\n        st[19] = ROTL64(st[23], 56);\n        st[23] = ROTL64(st[15], 41);\n        st[15] = ROTL64(st[ 4], 27);\n        st[ 4] = ROTL64(st[24], 14);\n        st[24] = ROTL64(st[21],  2);\n        st[21] = ROTL64(st[ 8], 55);\n        st[ 8] = ROTL64(st[16], 45);\n        st[16] = ROTL64(st[ 5], 36);\n        st[ 5] = ROTL64(st[ 3], 28);\n        st[ 3] = ROTL64(st[18], 21);\n        st[18] = ROTL64(st[17], 15);\n        st[17] = ROTL64(st[11], 10);\n        st[11] = ROTL64(st[ 7],  6);\n        st[ 7] = ROTL64(st[10],  3);\n        st[10] = ROTL64(t, 1);\n\n        //  Chi\n        // unrolled loop, where only last iteration is different\n        j = 0;\n        bc[0] = st[j    ];\n        bc[1] = st[j + 1];\n\n        st[j    ] ^= (~st[j + 1]) \u0026 st[j + 2];\n        st[j + 1] ^= (~st[j + 2]) \u0026 st[j + 3];\n        st[j + 2] ^= (~st[j + 3]) \u0026 st[j + 4];\n        st[j + 3] ^= (~st[j + 4]) \u0026 bc[0];\n        st[j + 4] ^= (~bc[0]) \u0026 bc[1];\n\n        j = 5;\n        bc[0] = st[j    ];\n        bc[1] = st[j + 1];\n\n        st[j    ] ^= (~st[j + 1]) \u0026 st[j + 2];\n        st[j + 1] ^= (~st[j + 2]) \u0026 st[j + 3];\n        st[j + 2] ^= (~st[j + 3]) \u0026 st[j + 4];\n        st[j + 3] ^= (~st[j + 4]) \u0026 bc[0];\n        st[j + 4] ^= (~bc[0]) \u0026 bc[1];\n\n        j = 10;\n        bc[0] = st[j    ];\n        bc[1] = st[j + 1];\n\n        st[j    ] ^= (~st[j + 1]) \u0026 st[j + 2];\n        st[j + 1] ^= (~st[j + 2]) \u0026 st[j + 3];\n        st[j + 2] ^= (~st[j + 3]) \u0026 st[j + 4];\n        st[j + 3] ^= (~st[j + 4]) \u0026 bc[0];\n        st[j + 4] ^= (~bc[0]) \u0026 bc[1];\n\n        j = 15;\n        bc[0] = st[j    ];\n        bc[1] = st[j + 1];\n\n        st[j    ] ^= (~st[j + 1]) \u0026 st[j + 2];\n        st[j + 1] ^= (~st[j + 2]) \u0026 st[j + 3];\n        st[j + 2] ^= (~st[j + 3]) \u0026 st[j + 4];\n        st[j + 3] ^= (~st[j + 4]) \u0026 bc[0];\n        st[j + 4] ^= (~bc[0]) \u0026 bc[1];\n\n        j = 20;\n        bc[0] = st[j    ];\n        bc[1] = st[j + 1];\n        bc[2] = st[j + 2];\n        bc[3] = st[j + 3];\n        bc[4] = st[j + 4];\n\n        st[j    ] ^= (~bc[1]) \u0026 bc[2];\n        st[j + 1] ^= (~bc[2]) \u0026 bc[3];\n        st[j + 2] ^= (~bc[3]) \u0026 bc[4];\n        st[j + 3] ^= (~bc[4]) \u0026 bc[0];\n        st[j + 4] ^= (~bc[0]) \u0026 bc[1];\n        \n        //  Iota\n        st[0] ^= keccakf_rndc[round];\n    }\n}","filepath":"src/crypto/c_keccak.c","line_number":29,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"4687072":{"score":0.7134999,"function_name":"keccak","code":"void keccak(const uint8_t *in, int inlen, uint8_t *md, int mdlen)\n{\n    state_t st;\n    uint8_t temp[144];\n    int i, rsiz, rsizw;\n\n    rsiz = sizeof(state_t) == mdlen ? HASH_DATA_AREA : 200 - 2 * mdlen;\n    rsizw = rsiz / 8;\n    \n    memset(st, 0, sizeof(st));\n\n    for ( ; inlen \u003e= rsiz; inlen -= rsiz, in += rsiz) {\n        for (i = 0; i \u003c rsizw; i++)\n            st[i] ^= ((uint64_t *) in)[i];\n        keccakf(st, KECCAK_ROUNDS);\n    }\n    \n    // last block and padding\n    memcpy(temp, in, inlen);\n    temp[inlen++] = 1;\n    memset(temp + inlen, 0, rsiz - inlen);\n    temp[rsiz - 1] |= 0x80;\n\n    for (i = 0; i \u003c rsizw; i++)\n        st[i] ^= ((uint64_t *) temp)[i];\n\n    keccakf(st, KECCAK_ROUNDS);\n\n    memcpy(md, st, mdlen);\n}","filepath":"src/crypto/c_keccak.c","line_number":142,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"4692864":{"score":0.6538968,"function_name":"xmrig::ConsoleLog::message","code":"void xmrig::ConsoleLog::message(Level level, const char* fmt, va_list args)\n{\n    time_t now = time(nullptr);\n    tm stime;\n\n#   ifdef _WIN32\n    localtime_s(\u0026stime, \u0026now);\n#   else\n    localtime_r(\u0026now, \u0026stime);\n#   endif\n\n    snprintf(m_fmt, sizeof(m_fmt) - 1, \"[%d-%02d-%02d %02d:%02d:%02d]%s %s%s\",\n             stime.tm_year + 1900,\n             stime.tm_mon + 1,\n             stime.tm_mday,\n             stime.tm_hour,\n             stime.tm_min,\n             stime.tm_sec,\n             Log::colorByLevel(level, Log::colors),\n             fmt,\n             Log::endl(Log::colors)\n        );\n\n    print(args);\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":76,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4693152":{"score":0.495322,"function_name":"ConsoleLog::print","code":"void ConsoleLog::print(va_list args)\n{\n    m_uvBuf.len = vsnprintf(m_buf, sizeof(m_buf) - 1, m_fmt, args);\n    if (m_uvBuf.len \u003c= 0) {\n        return;\n    }\n\n    if (!isWritable()) {\n        fputs(m_buf, stdout);\n        fflush(stdout);\n    }\n    else {\n        uv_try_write(m_stream, \u0026m_uvBuf, 1);\n    }\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":117,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4693552":{"score":0.60515475,"function_name":"ConsoleLog::message","code":"void ConsoleLog::message(Level level, const char* fmt, va_list args)\n{\n    time_t now = time(nullptr);\n    tm stime;\n\n#   ifdef _WIN32\n    localtime_s(\u0026stime, \u0026now);\n#   else\n    localtime_r(\u0026now, \u0026stime);\n#   endif\n\n    const bool isColors = m_controller-\u003econfig()-\u003eisColors();\n\n    snprintf(m_fmt, sizeof(m_fmt) - 1, \"[%d-%02d-%02d %02d:%02d:%02d]%s %s%s\",\n             stime.tm_year + 1900,\n             stime.tm_mon + 1,\n             stime.tm_mday,\n             stime.tm_hour,\n             stime.tm_min,\n             stime.tm_sec,\n             Log::colorByLevel(level, isColors),\n             fmt,\n             Log::endl(isColors)\n        );\n\n    print(args);\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":69,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4693936":{"score":0.7753296,"function_name":"ConsoleLog::ConsoleLog","code":"ConsoleLog::ConsoleLog(xmrig::Controller *controller) :\n    m_stream(nullptr),\n    m_controller(controller)\n{\n    if (uv_tty_init(uv_default_loop(), \u0026m_tty, 1, 0) \u003c 0) {\n        Log::colors = false;\n        return;\n    }\n\n    uv_tty_set_mode(\u0026m_tty, UV_TTY_MODE_NORMAL);\n    m_uvBuf.base = m_buf;\n    m_stream     = reinterpret_cast\u003cuv_stream_t*\u003e(\u0026m_tty);\n\n#   ifdef WIN32\n    HANDLE handle = GetStdHandle(STD_INPUT_HANDLE);\n    if (handle != INVALID_HANDLE_VALUE) {\n        DWORD mode = 0;\n        if (GetConsoleMode(handle, \u0026mode)) {\n           mode \u0026= ~ENABLE_QUICK_EDIT_MODE;\n           SetConsoleMode(handle, mode | ENABLE_EXTENDED_FLAGS);\n        }\n    }\n#   endif\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":43,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4694080":{"score":0.7192856,"function_name":"ConsoleLog::isWritable","code":"bool ConsoleLog::isWritable() const\n{\n    if (!m_stream || uv_is_writable(m_stream) != 1) {\n        return false;\n    }\n\n    const uv_handle_type type = uv_guess_handle(1);\n    return type == UV_TTY || type == UV_NAMED_PIPE;\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":106,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4694432":{"score":0.6357721,"function_name":"ConsoleLog::message","code":"void ConsoleLog::message(Level level, const char* fmt, va_list args)\n{\n    time_t now = time(nullptr);\n    tm stime;\n\n#   ifdef _WIN32\n    localtime_s(\u0026stime, \u0026now);\n#   else\n    localtime_r(\u0026now, \u0026stime);\n#   endif\n\n    const bool isColors = m_controller-\u003econfig()-\u003eisColors();\n\n    snprintf(m_fmt, sizeof(m_fmt) - 1, \"[%d-%02d-%02d %02d:%02d:%02d]%s %s%s\",\n             stime.tm_year + 1900,\n             stime.tm_mon + 1,\n             stime.tm_mday,\n             stime.tm_hour,\n             stime.tm_min,\n             stime.tm_sec,\n             Log::colorByLevel(level, isColors),\n             fmt,\n             Log::endl(isColors)\n        );\n\n    print(args);\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":69,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4695232":{"score":0.79102445,"function_name":"xmrig::Log::message","code":"void xmrig::Log::message(ILogBackend::Level level, const char* fmt, ...)\n{\n    uv_mutex_lock(\u0026m_mutex);\n\n    va_list args;\n    va_list copy;\n    va_start(args, fmt);\n\n    for (ILogBackend *backend : m_backends) {\n        va_copy(copy, args);\n        backend-\u003emessage(level, fmt, copy);\n        va_end(copy);\n    }\n\n    va_end(args);\n\n    uv_mutex_unlock(\u0026m_mutex);\n}","filepath":"src/common/log/Log.cpp","line_number":59,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4695536":{"score":0.7654631,"function_name":"xmrig::Log::text","code":"void xmrig::Log::text(const char* fmt, ...)\n{\n    uv_mutex_lock(\u0026m_mutex);\n\n    va_list args;\n    va_list copy;\n    va_start(args, fmt);\n\n    for (ILogBackend *backend : m_backends) {\n        va_copy(copy, args);\n        backend-\u003etext(fmt, copy);\n        va_end(copy);\n    }\n\n    va_end(args);\n\n    uv_mutex_unlock(\u0026m_mutex);\n}","filepath":"src/common/log/Log.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4695840":{"score":0.6702105,"function_name":"xmrig::Log::endl","code":"const char *xmrig::Log::endl(bool isColors)\n{\n#   ifdef _WIN32\n    return isColors ? \"\\x1B[0m\\r\\n\" : \"\\r\\n\";\n#   else\n    return isColors ? \"\\x1B[0m\\n\" : \"\\n\";\n#   endif\n}","filepath":"src/common/log/Log.cpp","line_number":109,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4695872":{"score":0.867532,"function_name":"Log::endl","code":"const char *Log::endl(bool isColors)\n{\n#   ifdef _WIN32\n    return isColors ? \"\\x1B[0m\\r\\n\" : \"\\r\\n\";\n#   else\n    return isColors ? \"\\x1B[0m\\n\" : \"\\n\";\n#   endif\n}","filepath":"src/common/log/Log.cpp","line_number":103,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4696432":{"score":0.51152277,"function_name":"xmrig::Client::onAllocBuffer","code":"void xmrig::Client::onAllocBuffer(uv_handle_t *handle, size_t, uv_buf_t *buf)\n{\n    auto client = getClient(handle-\u003edata);\n    if (!client) {\n        return;\n    }\n\n    buf-\u003ebase = client-\u003em_recvBuf.current();\n\n#   ifdef _WIN32\n    buf-\u003elen = static_cast\u003cULONG\u003e(client-\u003em_recvBuf.available());\n#   else\n    buf-\u003elen = client-\u003em_recvBuf.available();\n#   endif\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":901,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4696640":{"score":0.5504792,"function_name":"xmrig::Client::resolve","code":"int xmrig::Client::resolve(const char *host)\n{\n    setState(HostLookupState);\n\n    m_expire     = 0;\n    m_recvBufPos = 0;\n\n    if (m_failures == -1) {\n        m_failures = 0;\n    }\n\n    const int r = uv_getaddrinfo(uv_default_loop(), \u0026m_resolver, Client::onResolved, host, nullptr, \u0026m_hints);\n    if (r) {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s:%u] getaddrinfo error: \\\"%s\\\"\", host, m_pool.port(), uv_strerror(r));\n        }\n        return 1;\n    }\n\n    return 0;\n}","filepath":"src/common/net/Client.cpp","line_number":478,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4697200":{"score":0.7294961,"function_name":"xmrig::Client::close","code":"bool xmrig::Client::close()\n{\n    if (m_state == ClosingState) {\n        return m_socket != nullptr;\n    }\n\n    if (m_state == UnconnectedState || m_socket == nullptr) {\n        return false;\n    }\n\n    setState(ClosingState);\n\n    if (uv_is_closing(reinterpret_cast\u003cuv_handle_t*\u003e(m_socket)) == 0) {\n        uv_close(reinterpret_cast\u003cuv_handle_t*\u003e(m_socket), Client::onClose);\n    }\n\n    return true;\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":303,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4697344":{"score":0.92269063,"function_name":"xmrig::Client::isCriticalError","code":"bool xmrig::Client::isCriticalError(const char *message)\n{\n    if (!message) {\n        return false;\n    }\n\n    if (strncasecmp(message, \"Unauthenticated\", 15) == 0) {\n        return true;\n    }\n\n    if (strncasecmp(message, \"your IP is banned\", 17) == 0) {\n        return true;\n    }\n\n    if (strncasecmp(message, \"IP Address currently banned\", 27) == 0) {\n        return true;\n    }\n\n    return false;\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":323,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4697488":{"score":0.61921227,"function_name":"xmrig::Client::send","code":"bool xmrig::Client::send(BIO *bio)\n{\n#   ifdef XMRIG_FEATURE_TLS\n    uv_buf_t buf;\n    buf.len = BIO_get_mem_data(bio, \u0026buf.base);\n\n    if (buf.len == 0) {\n        return true;\n    }\n\n    LOG_DEBUG(\"[%s] TLS send     (%d bytes)\", url(), static_cast\u003cint\u003e(buf.len));\n\n    bool result = false;\n    if (state() == ConnectedState \u0026\u0026 uv_is_writable(m_stream)) {\n        result = uv_try_write(m_stream, \u0026buf, 1) \u003e 0;\n\n        if (!result) {\n            close();\n        }\n    }\n    else {\n        LOG_DEBUG_ERR(\"[%s] send failed, invalid state: %d\", url(), m_state);\n    }\n\n    (void) BIO_reset(bio);\n\n    return result;\n#   else\n    return false;\n#   endif\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":445,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4697680":{"score":0.79602706,"function_name":"Client::verifyAlgorithm","code":"bool Client::verifyAlgorithm(const xmrig::Algorithm \u0026algorithm) const\n{\n    if (m_pool.isCompatible(algorithm)) {\n        return true;\n    }\n\n    if (isQuiet()) {\n        return false;\n    }\n\n    if (algorithm.isValid()) {\n        LOG_ERR(\"Incompatible algorithm \\\"%s\\\" detected, reconnect\", algorithm.name());\n    }\n    else {\n        LOG_ERR(\"Unknown/unsupported algorithm detected, reconnect\");\n    }\n\n    return false;\n}","filepath":"src/common/net/Client.cpp","line_number":333,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4698160":{"score":0.48768848,"function_name":"Client::send","code":"int64_t Client::send(size_t size)\n{\n    LOG_DEBUG(\"[%s:%u] send (%d bytes): \\\"%s\\\"\", m_url.host(), m_url.port(), size, m_sendBuf);\n    if (state() != ConnectedState || !uv_is_writable(m_stream)) {\n        LOG_DEBUG_ERR(\"[%s:%u] send failed, invalid state: %d\", m_url.host(), m_url.port(), m_state);\n        return -1;\n    }\n\n    uv_buf_t buf = uv_buf_init(m_sendBuf, (unsigned int) size);\n\n    if (uv_try_write(m_stream, \u0026buf, 1) \u003c 0) {\n        close();\n        return -1;\n    }\n\n    m_expire = uv_now(uv_default_loop()) + kResponseTimeout;\n    return m_sequence++;\n}","filepath":"src/net/Client.cpp","line_number":274,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.4.4"},"4698416":{"score":0.5937781,"function_name":"xmrig::Client::tick","code":"void xmrig::Client::tick(uint64_t now)\n{\n    if (m_state == ConnectedState) {\n        if (m_expire \u0026\u0026 now \u003e m_expire) {\n            LOG_DEBUG_ERR(\"[%s] timeout\", url());\n            close();\n        }\n        else if (m_keepAlive \u0026\u0026 now \u003e m_keepAlive) {\n            ping();\n        }\n\n        return;\n    }\n\n    if (m_state == ReconnectingState \u0026\u0026 m_expire \u0026\u0026 now \u003e m_expire) {\n        return connect();\n    }\n\n    if (m_state == ConnectingState \u0026\u0026 m_expire \u0026\u0026 now \u003e m_expire) {\n        return reconnect();\n    }\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":257,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4699264":{"score":0.8488009,"function_name":"xmrig::Client::parseExtensions","code":"void xmrig::Client::parseExtensions(const rapidjson::Value \u0026value)\n{\n    m_extensions = 0;\n\n    if (!value.IsArray()) {\n        return;\n    }\n\n    for (const rapidjson::Value \u0026ext : value.GetArray()) {\n        if (!ext.IsString()) {\n            continue;\n        }\n\n        if (strcmp(ext.GetString(), \"algo\") == 0) {\n            m_extensions |= AlgoExt;\n            continue;\n        }\n\n        if (strcmp(ext.GetString(), \"nicehash\") == 0) {\n            m_extensions |= NicehashExt;\n            m_nicehash = true;\n            continue;\n        }\n    }\n}","filepath":"src/common/net/Client.cpp","line_number":710,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4699760":{"score":0.6947181,"function_name":"xmrig::Client::startTimeout","code":"void xmrig::Client::startTimeout()\n{\n    m_expire = 0;\n\n    if (has\u003cEXT_KEEPALIVE\u003e()) {\n        const uint64_t ms = static_cast\u003cuint64_t\u003e(m_pool.keepAlive() \u003e 0 ? m_pool.keepAlive() : Pool::kKeepAliveTimeout) * 1000;\n\n        m_keepAlive = Chrono::steadyMSecs() + ms;\n    }\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":889,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4700432":{"score":0.50417876,"function_name":"xmrig::BaseClient::setPool","code":"void xmrig::BaseClient::setPool(const Pool \u0026pool)\n{\n    if (!pool.isValid()) {\n        return;\n    }\n\n    m_pool      = pool;\n    m_user      = Env::expand(pool.user());\n    m_password  = Env::expand(pool.password());\n    m_rigId     = Env::expand(pool.rigId());\n}","filepath":"src/base/net/stratum/BaseClient.cpp","line_number":49,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v5.5.0"},"4700768":{"score":0.729374,"function_name":"Client::parseJob","code":"bool Client::parseJob(const json_t *params, int *code)\n{\n    if (!json_is_object(params)) {\n        *code = 2;\n        return false;\n    }\n\n    Job job(m_id, m_url.isNicehash());\n    if (!job.setId(json_string_value(json_object_get(params, \"job_id\")))) {\n        *code = 3;\n        return false;\n    }\n\n    if (!job.setBlob(json_string_value(json_object_get(params, \"blob\")))) {\n        *code = 4;\n        return false;\n    }\n\n    if (!job.setTarget(json_string_value(json_object_get(params, \"target\")))) {\n        *code = 5;\n        return false;\n    }\n\n    m_job = std::move(job);\n\n    LOG_DEBUG(\"[%s:%u] job: \\\"%s\\\", diff: %lld\", m_url.host(), m_url.port(), job.id(), job.diff());\n    return true;\n}","filepath":"src/net/Client.cpp","line_number":165,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.0.1"},"4703504":{"score":0.67673635,"function_name":"Client::parseLogin","code":"bool Client::parseLogin(const rapidjson::Value \u0026result, int *code)\n{\n    if (!m_rpcId.setId(result[\"id\"].GetString())) {\n        *code = 1;\n        return false;\n    }\n\n#   ifndef XMRIG_PROXY_PROJECT\n    m_nicehash = m_pool.isNicehash();\n#   endif\n\n    if (result.HasMember(\"extensions\")) {\n        parseExtensions(result[\"extensions\"]);\n    }\n\n    const bool rc = parseJob(result[\"job\"], code);\n    m_jobs = 0;\n\n    return rc;\n}","filepath":"src/net/Client.cpp","line_number":290,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"4705392":{"score":0.79040504,"function_name":"xmrig::Client::parseNotification","code":"void xmrig::Client::parseNotification(const char *method, const rapidjson::Value \u0026params, const rapidjson::Value \u0026error)\n{\n    if (error.IsObject()) {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s] error: \\\"%s\\\", code: %d\", url(), error[\"message\"].GetString(), error[\"code\"].GetInt());\n        }\n        return;\n    }\n\n    if (!method) {\n        return;\n    }\n\n    if (strcmp(method, \"job\") == 0) {\n        int code = -1;\n        if (parseJob(params, \u0026code)) {\n            m_listener-\u003eonJobReceived(this, m_job, params);\n        }\n        else {\n            close();\n        }\n\n        return;\n    }\n\n    LOG_WARN(\"[%s] unsupported method: \\\"%s\\\"\", url(), method);\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":718,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4705808":{"score":0.74801195,"function_name":"Client::parseResponse","code":"void Client::parseResponse(int64_t id, const json_t *result, const json_t *error)\n{\n    if (json_is_object(error)) {\n        const char *message = json_string_value(json_object_get(error, \"message\"));\n\n        auto it = m_results.find(id);\n        if (it != m_results.end()) {\n            m_listener-\u003eonResultAccepted(this, it-\u003esecond.diff, it-\u003esecond.elapsed(), message);\n            m_results.erase(it);\n        }\n        else if (!m_quiet) {\n            LOG_ERR(\"[%s:%u] error: \\\"%s\\\", code: %lld\", m_url.host(), m_url.port(), message, json_integer_value(json_object_get(error, \"code\")));\n        }\n\n        if (id == 1 || (message \u0026\u0026 strncasecmp(message, \"Unauthenticated\", 15) == 0)) {\n            close();\n        }\n\n        return;\n    }\n\n    if (!json_is_object(result)) {\n        return;\n    }\n\n    if (id == 1) {\n        int code = -1;\n        if (!parseLogin(result, \u0026code)) {\n            if (!m_quiet) {\n                LOG_ERR(\"[%s:%u] login error code: %d\", m_url.host(), m_url.port(), code);\n            }\n\n            return close();\n        }\n\n        m_failures = 0;\n        m_listener-\u003eonLoginSuccess(this);\n        m_listener-\u003eonJobReceived(this, m_job);\n        return;\n    }\n\n    auto it = m_results.find(id);\n    if (it != m_results.end()) {\n        m_listener-\u003eonResultAccepted(this, it-\u003esecond.diff, it-\u003esecond.elapsed(), nullptr);\n        m_results.erase(it);\n    }\n}","filepath":"src/net/Client.cpp","line_number":335,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.0.0"},"4706864":{"score":0.55127585,"function_name":"xmrig::Client::deleteLater","code":"void xmrig::Client::deleteLater()\n{\n    if (!m_listener) {\n        return;\n    }\n\n    m_listener = nullptr;\n\n    if (!disconnect()) {\n        m_storage.remove(m_key);\n    }\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":243,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4707504":{"score":0.73371756,"function_name":"xmrig::Client::reconnect","code":"void xmrig::Client::reconnect()\n{\n    if (!m_listener) {\n        m_storage.remove(m_key);\n\n        return;\n    }\n\n    m_keepAlive = 0;\n\n    if (m_failures == -1) {\n        return m_listener-\u003eonClose(this, -1);\n    }\n\n    setState(ReconnectingState);\n\n    m_failures++;\n    m_listener-\u003eonClose(this, static_cast\u003cint\u003e(m_failures));\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":839,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4708112":{"score":0.55547523,"function_name":"xmrig::Client::onClose","code":"void xmrig::Client::onClose()\n{\n    delete m_socket;\n\n    m_stream = nullptr;\n    m_socket = nullptr;\n    setState(UnconnectedState);\n\n#   ifdef XMRIG_FEATURE_TLS\n    if (m_tls) {\n        delete m_tls;\n        m_tls = nullptr;\n    }\n#   endif\n\n    reconnect();\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":621,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4708560":{"score":0.5347742,"function_name":"Client::onResolved","code":"void Client::onResolved(uv_getaddrinfo_t *req, int status, struct addrinfo *res)\n{\n    auto client = getClient(req-\u003edata);\n    if (status \u003c 0) {\n        LOG_ERR(\"[%s:%u] DNS error: \\\"%s\\\"\", client-\u003em_url.host(), client-\u003em_url.port(), uv_strerror(status));\n        return client-\u003ereconnect();\n    }\n\n    addrinfo *ptr = res;\n    std::vector\u003caddrinfo*\u003e ipv4;\n    std::vector\u003caddrinfo*\u003e ipv6;\n\n    while (ptr != nullptr) {\n        if (ptr-\u003eai_family == AF_INET) {\n            ipv4.push_back(ptr);\n        }\n\n        if (ptr-\u003eai_family == AF_INET6) {\n            ipv6.push_back(ptr);\n        }\n\n        ptr = ptr-\u003eai_next;\n    }\n\n    if (ipv4.empty() \u0026\u0026 ipv6.empty()) {\n        LOG_ERR(\"[%s:%u] DNS error: \\\"No IPv4 (A) or IPv6 (AAAA) records found\\\"\", client-\u003em_url.host(), client-\u003em_url.port());\n\n        uv_freeaddrinfo(res);\n        return client-\u003ereconnect();\n    }\n\n    client-\u003econnect(ipv4, ipv6);\n    uv_freeaddrinfo(res);\n}","filepath":"src/net/Client.cpp","line_number":679,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.0"},"4709424":{"score":0.75917536,"function_name":"xmrig::Client::Client","code":"xmrig::Client::Client(int id, const char *agent, IClientListener *listener) :\n    m_ipv6(false),\n    m_nicehash(false),\n    m_quiet(false),\n    m_agent(agent),\n    m_listener(listener),\n    m_extensions(0),\n    m_id(id),\n    m_retries(5),\n    m_retryPause(5000),\n    m_failures(0),\n    m_recvBufPos(0),\n    m_state(UnconnectedState),\n    m_tls(nullptr),\n    m_expire(0),\n    m_jobs(0),\n    m_keepAlive(0),\n    m_key(0),\n    m_stream(nullptr),\n    m_socket(nullptr)\n{\n    m_key = m_storage.add(this);\n\n    memset(m_ip, 0, sizeof(m_ip));\n    memset(\u0026m_hints, 0, sizeof(m_hints));\n\n    m_resolver.data = m_storage.ptr(m_key);\n\n    m_hints.ai_family   = AF_UNSPEC;\n    m_hints.ai_socktype = SOCK_STREAM;\n    m_hints.ai_protocol = IPPROTO_TCP;\n\n    m_recvBuf.base = m_buf;\n    m_recvBuf.len  = sizeof(m_buf);\n}","filepath":"src/common/net/Client.cpp","line_number":74,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4710160":{"score":0.72627074,"function_name":"xmrig::Client::send","code":"int64_t xmrig::Client::send(const rapidjson::Value \u0026obj)\n{\n    using namespace rapidjson;\n\n    Value value;\n\n    StringBuffer buffer(nullptr, 512);\n    Writer\u003cStringBuffer\u003e writer(buffer);\n    obj.Accept(writer);\n\n    const size_t size = buffer.GetSize();\n    if (size \u003e (sizeof(m_sendBuf) - 2)) {\n        LOG_ERR(\"[%s] send failed: \\\"send buffer overflow: %zu \u003e %zu\\\"\", url(), size, (sizeof(m_sendBuf) - 2));\n        close();\n        return -1;\n    }\n\n    memcpy(m_sendBuf, buffer.GetString(), size);\n    m_sendBuf[size]     = '\\n';\n    m_sendBuf[size + 1] = '\\0';\n\n    return send(size + 1);\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":150,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4716464":{"score":0.5053842,"function_name":"xmrig::Client::handshake","code":"void xmrig::Client::handshake()\n{\n#   ifdef XMRIG_FEATURE_TLS\n    if (isTLS()) {\n        m_expire = Chrono::steadyMSecs() + kResponseTimeout;\n\n        m_tls-\u003ehandshake();\n    }\n    else\n#   endif\n    {\n        login();\n    }\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":580,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4716544":{"score":0.49946976,"function_name":"xmrig::Client::onConnect","code":"void xmrig::Client::onConnect(uv_connect_t *req, int status)\n{\n    auto client = getClient(req-\u003edata);\n    if (!client) {\n        delete req;\n        return;\n    }\n\n    if (status \u003c 0) {\n        if (!client-\u003eisQuiet()) {\n            LOG_ERR(\"[%s] connect error: \\\"%s\\\"\", client-\u003eurl(), uv_strerror(status));\n        }\n\n        if (client-\u003estate() == ReconnectingState) {\n            return;\n        }\n\n        if (client-\u003estate() != ConnectingState) {\n            if (!client-\u003eisQuiet()) {\n                LOG_ERR(\"[%s] connect error: \\\"invalid state: %d\\\"\", client-\u003eurl(), client-\u003estate());\n            }\n\n            return;\n        }\n\n        delete req;\n        client-\u003eclose();\n        return;\n    }\n\n    client-\u003em_stream = static_cast\u003cuv_stream_t*\u003e(req-\u003ehandle);\n    client-\u003em_stream-\u003edata = req-\u003edata;\n    client-\u003esetState(ConnectedState);\n\n    uv_read_start(client-\u003em_stream, onAllocBuffer, onRead);\n    delete req;\n\n    client-\u003ehandshake();\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":929,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.4.0-beta"},"4722480":{"score":0.8174057,"function_name":"Client::parse","code":"void Client::parse(char *line, size_t len)\n{\n    startTimeout();\n\n    line[len - 1] = '\\0';\n\n    LOG_DEBUG(\"[%s:%u] received (%d bytes): \\\"%s\\\"\", m_url.host(), m_url.port(), len, line);\n\n    if (len \u003c 32 || line[0] != '{') {\n        if (!m_quiet) {\n            LOG_ERR(\"[%s:%u] JSON decode failed\", m_url.host(), m_url.port());\n        }\n\n        return;\n    }\n\n    rapidjson::Document doc;\n    if (doc.ParseInsitu(line).HasParseError()) {\n        if (!m_quiet) {\n            LOG_ERR(\"[%s:%u] JSON decode failed: \\\"%s\\\"\", m_url.host(), m_url.port(), rapidjson::GetParseError_En(doc.GetParseError()));\n        }\n\n        return;\n    }\n\n    if (!doc.IsObject()) {\n        return;\n    }\n\n    const rapidjson::Value \u0026id = doc[\"id\"];\n    if (id.IsInt64()) {\n        parseResponse(id.GetInt64(), doc[\"result\"], doc[\"error\"]);\n    }\n    else {\n        parseNotification(doc[\"method\"].GetString(), doc[\"params\"], doc[\"error\"]);\n    }\n}","filepath":"src/net/Client.cpp","line_number":472,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.2"},"4727312":{"score":0.45287013,"function_name":"xmrig::Client::parse","code":"void xmrig::Client::parse(char *line, size_t len)\n{\n    startTimeout();\n\n    LOG_DEBUG(\"[%s] received (%d bytes): \\\"%.*s\\\"\", url(), len, static_cast\u003cint\u003e(len), line);\n\n    if (len \u003c 32 || line[0] != '{') {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s] JSON decode failed\", url());\n        }\n\n        return;\n    }\n\n    rapidjson::Document doc;\n    if (doc.ParseInsitu(line).HasParseError()) {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s] JSON decode failed: \\\"%s\\\"\", url(), rapidjson::GetParseError_En(doc.GetParseError()));\n        }\n\n        return;\n    }\n\n    if (!doc.IsObject()) {\n        return;\n    }\n\n    const rapidjson::Value \u0026id = doc[\"id\"];\n    if (id.IsInt64()) {\n        parseResponse(id.GetInt64(), doc[\"result\"], doc[\"error\"]);\n    }\n    else {\n        parseNotification(doc[\"method\"].GetString(), doc[\"params\"], doc[\"error\"]);\n    }\n}","filepath":"src/base/net/stratum/Client.cpp","line_number":679,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v5.11.2"},"4730768":{"score":0.7222087,"function_name":"PB_DS_CLASS_C_DEC::\nclear_imp","code":"PB_DS_CLASS_T_DEC\nvoid\nPB_DS_CLASS_C_DEC::\nclear_imp(node_pointer p_nd)\n{\n  while (p_nd != 0)\n    {\n      clear_imp(p_nd-\u003em_p_l_child);\n      node_pointer p_next = p_nd-\u003em_p_next_sibling;\n      actual_erase_node(p_nd);\n      p_nd = p_next;\n    }\n}","filepath":"libstdc++-v3/include/ext/pb_ds/detail/left_child_next_sibling_heap_/erase_fn_imps.hpp","line_number":62,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"4736848":{"score":0.6085173,"function_name":"remove_useless_stmts_1","code":"static void\nremove_useless_stmts_1 (tree *tp, struct rus_data *data)\n{\n  tree t = *tp, op;\n\n  switch (TREE_CODE (t))\n    {\n    case COND_EXPR:\n      remove_useless_stmts_cond (tp, data);\n      break;\n\n    case TRY_FINALLY_EXPR:\n      remove_useless_stmts_tf (tp, data);\n      break;\n\n    case TRY_CATCH_EXPR:\n      remove_useless_stmts_tc (tp, data);\n      break;\n\n    case BIND_EXPR:\n      remove_useless_stmts_bind (tp, data);\n      break;\n\n    case GOTO_EXPR:\n      remove_useless_stmts_goto (tp, data);\n      break;\n\n    case LABEL_EXPR:\n      remove_useless_stmts_label (tp, data);\n      break;\n\n    case RETURN_EXPR:\n      fold_stmt (tp);\n      data-\u003elast_goto = NULL;\n      data-\u003emay_branch = true;\n      break;\n\n    case CALL_EXPR:\n      fold_stmt (tp);\n      data-\u003elast_goto = NULL;\n      notice_special_calls (t);\n      update_call_expr_flags (t);\n      if (tree_could_throw_p (t))\n\tdata-\u003emay_throw = true;\n      break;\n\n    case MODIFY_EXPR:\n      data-\u003elast_goto = NULL;\n      fold_stmt (tp);\n      op = get_call_expr_in (t);\n      if (op)\n\t{\n\t  update_call_expr_flags (op);\n\t  notice_special_calls (op);\n\t}\n      if (tree_could_throw_p (t))\n\tdata-\u003emay_throw = true;\n      break;\n\n    case STATEMENT_LIST:\n      {\n\ttree_stmt_iterator i = tsi_start (t);\n\twhile (!tsi_end_p (i))\n\t  {\n\t    t = tsi_stmt (i);\n\t    if (IS_EMPTY_STMT (t))\n\t      {\n\t\ttsi_delink (\u0026i);\n\t\tcontinue;\n\t      }\n\t    \n\t    remove_useless_stmts_1 (tsi_stmt_ptr (i), data);\n\n\t    t = tsi_stmt (i);\n\t    if (TREE_CODE (t) == STATEMENT_LIST)\n\t      {\n\t\ttsi_link_before (\u0026i, t, TSI_SAME_STMT);\n\t\ttsi_delink (\u0026i);\n\t      }\n\t    else\n\t      tsi_next (\u0026i);\n\t  }\n      }\n      break;\n    case ASM_EXPR:\n      fold_stmt (tp);\n      data-\u003elast_goto = NULL;\n      break;\n\n    default:\n      data-\u003elast_goto = NULL;\n      break;\n    }\n}","filepath":"gcc/tree-cfg.c","line_number":1806,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"4749392":{"score":0.73376477,"function_name":"Job::setBlob","code":"bool Job::setBlob(const char *blob)\n{\n    if (!blob) {\n        return false;\n    }\n\n    m_size = strlen(blob);\n    if (m_size % 2 != 0) {\n        return false;\n    }\n\n    m_size /= 2;\n    if (m_size \u003c 76 || m_size \u003e= sizeof(m_blob)) {\n        return false;\n    }\n\n    if (!fromHex(blob, (int) m_size * 2, m_blob)) {\n        return false;\n    }\n\n    if (*nonce() != 0 \u0026\u0026 !m_nicehash) {\n        m_nicehash = true;\n    }\n\n    return true;\n}","filepath":"src/net/Job.cpp","line_number":94,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.0"},"4749776":{"score":0.7258434,"function_name":"Job::setTarget","code":"bool Job::setTarget(const char *target)\n{\n    if (!target) {\n        return false;\n    }\n\n    const size_t len = strlen(target);\n\n    if (len \u003c= 8) {\n        uint32_t tmp = 0;\n        char str[8];\n        memcpy(str, target, len);\n\n        if (!fromHex(str, 8, reinterpret_cast\u003cunsigned char*\u003e(\u0026tmp)) || tmp == 0) {\n            return false;\n        }\n\n        m_target = 0xFFFFFFFFFFFFFFFFULL / (0xFFFFFFFFULL / static_cast\u003cuint64_t\u003e(tmp));\n    }\n    else if (len \u003c= 16) {\n        m_target = 0;\n        char str[16];\n        memcpy(str, target, len);\n\n        if (!fromHex(str, 16, reinterpret_cast\u003cunsigned char*\u003e(\u0026m_target)) || m_target == 0) {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n\n    m_diff = toDiff(m_target);\n    return true;\n}","filepath":"src/net/Job.cpp","line_number":122,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.0"},"4752320":{"score":0.6948582,"function_name":"Job::fromHex","code":"bool Job::fromHex(const char* in, unsigned int len, unsigned char* out)\n{\n    bool error = false;\n    for (unsigned int i = 0; i \u003c len; i += 2) {\n        out[i / 2] = (hf_hex2bin(in[i], error) \u003c\u003c 4) | hf_hex2bin(in[i + 1], error);\n\n        if (error) {\n            return false;\n        }\n    }\n    return true;\n}","filepath":"src/net/Job.cpp","line_number":186,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.0"},"4752864":{"score":0.7298509,"function_name":"Job::Job","code":"Job::Job() :\n    m_nicehash(false),\n    m_coin(),\n    m_algo(xmrig::ALGO_CRYPTONIGHT),\n    m_poolId(-2),\n    m_threadId(-1),\n    m_variant(xmrig::VARIANT_AUTO),\n    m_size(0),\n    m_diff(0),\n    m_target(0),\n    m_blob()\n{\n}","filepath":"src/net/Job.cpp","line_number":59,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.0"},"4752976":{"score":0.74820805,"function_name":"Url::Url","code":"Url::Url(const char *url) :\n    m_host(nullptr),\n    m_port(3333)\n{\n    const char *p = strstr(url, \"://\");\n    const char *base = url;\n\n    if (p) {\n        if (strncasecmp(url, \"stratum+tcp://\", 14)) {\n            return;\n        }\n\n        base = url + 14;\n    }\n\n    if (!strlen(base) || *base == '/') {\n        return;\n    }\n\n    const char *port = strchr(base, ':');\n    if (!port) {\n        m_host = strdup(base);\n        return;\n    }\n\n    const size_t size = port++ - base + 1;\n    m_host = static_cast\u003cchar*\u003e(malloc(size));\n    memcpy(m_host, base, size - 1);\n    m_host[size - 1] = '\\0';\n\n    m_port = strtol(port, nullptr, 10);\n}","filepath":"src/net/Url.cpp","line_number":55,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.0"},"4753552":{"score":0.6385503,"function_name":"Pool::Pool","code":"Pool::Pool(const char *host, uint16_t port, const char *user, const char *password, int keepAlive, bool nicehash, bool tls) :\n    m_nicehash(nicehash),\n    m_tls(tls),\n    m_keepAlive(keepAlive),\n    m_port(port),\n    m_host(host),\n    m_password(password),\n    m_user(user)\n{\n    const size_t size = m_host.size() + 8;\n    assert(size \u003e 8);\n\n    char *url = new char[size]();\n    snprintf(url, size - 1, \"%s:%d\", m_host.data(), m_port);\n\n    m_url = url;\n}","filepath":"src/common/net/Pool.cpp","line_number":77,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4753888":{"score":0.7182458,"function_name":"Pool::isCompatible","code":"bool Pool::isCompatible(const xmrig::Algorithm \u0026algorithm) const\n{\n    for (const auto \u0026a : m_algorithms) {\n        if (algorithm == a) {\n            return true;\n        }\n    }\n\n    return false;\n}","filepath":"src/common/net/Pool.cpp","line_number":92,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4754256":{"score":0.78196704,"function_name":"Pool::parse","code":"bool Pool::parse(const char *url)\n{\n    assert(url != nullptr);\n\n    const char *p = strstr(url, \"://\");\n    const char *base = url;\n\n    if (p) {\n        if (strncasecmp(url, \"stratum+tcp://\", 14) == 0) {\n            m_tls = false;\n        }\n        else if (strncasecmp(url, \"stratum+ssl://\", 14) == 0) {\n            m_tls = true;\n        }\n        else {\n            return false;\n        }\n\n        base = url + 14;\n    }\n\n    if (!strlen(base) || *base == '/') {\n        return false;\n    }\n\n    m_url = url;\n    if (base[0] == '[') {\n        return parseIPv6(base);\n    }\n\n    const char *port = strchr(base, ':');\n    if (!port) {\n        m_host = base;\n        return true;\n    }\n\n    const size_t size = port++ - base + 1;\n    char *host        = new char[size]();\n    memcpy(host, base, size - 1);\n\n    m_host = host;\n    m_port = static_cast\u003cuint16_t\u003e(strtol(port, nullptr, 10));\n\n    return true;\n}","filepath":"src/common/net/Pool.cpp","line_number":134,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4754768":{"score":0.6694643,"function_name":"Pool::setUserpass","code":"bool Pool::setUserpass(const char *userpass)\n{\n    const char *p = strchr(userpass, ':');\n    if (!p) {\n        return false;\n    }\n\n    char *user = new char[p - userpass + 1]();\n    strncpy(user, userpass, p - userpass);\n\n    m_user     = user;\n    m_password = p + 1;\n\n    return true;\n}","filepath":"src/common/net/Pool.cpp","line_number":181,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4765888":{"score":0.7193597,"function_name":"Pool::parseIPv6","code":"bool Pool::parseIPv6(const char *addr)\n{\n    const char *end = strchr(addr, ']');\n    if (!end) {\n        return false;\n    }\n\n    const char *port = strchr(end, ':');\n    if (!port) {\n        return false;\n    }\n\n    const size_t size = end - addr;\n    char *host        = new char[size]();\n    memcpy(host, addr + 1, size - 1);\n\n    m_host = host;\n    m_port = static_cast\u003cuint16_t\u003e(strtol(port + 1, nullptr, 10));\n\n    return true;\n}","filepath":"src/common/net/Pool.cpp","line_number":284,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4766096":{"score":0.7857163,"function_name":"Pool::adjustVariant","code":"void Pool::adjustVariant(const xmrig::Variant variantHint)\n{\n#   ifndef XMRIG_PROXY_PROJECT\n    using namespace xmrig;\n\n    if (m_host.contains(\".nicehash.com\")) {\n        m_keepAlive = false;\n        m_nicehash  = true;\n        bool valid  = true;\n\n        switch (m_port) {\n        case 3355:\n        case 33355:\n            valid = m_algorithm.algo() == CRYPTONIGHT \u0026\u0026 m_host.contains(\"cryptonight.\");\n            m_algorithm.setVariant(VARIANT_0);\n            break;\n\n        case 3363:\n        case 33363:\n            valid = m_algorithm.algo() == CRYPTONIGHT \u0026\u0026 m_host.contains(\"cryptonightv7.\");\n            m_algorithm.setVariant(VARIANT_1);\n            break;\n\n        case 3364:\n            valid = m_algorithm.algo() == CRYPTONIGHT_HEAVY \u0026\u0026 m_host.contains(\"cryptonightheavy.\");\n            m_algorithm.setVariant(VARIANT_0);\n            break;\n\n        case 3367:\n        case 33367:\n            valid = m_algorithm.algo() == CRYPTONIGHT \u0026\u0026 m_host.contains(\"cryptonightv8.\");\n            m_algorithm.setVariant(VARIANT_2);\n            break;\n\n        default:\n            break;\n        }\n\n        if (!valid) {\n            m_algorithm.setAlgo(INVALID_ALGO);\n        }\n\n        m_tls = m_port \u003e 33000;\n        return;\n    }\n\n    if (m_host.contains(\".minergate.com\")) {\n        m_keepAlive = false;\n        bool valid  = true;\n        m_algorithm.setVariant(VARIANT_1);\n\n        if (m_host.contains(\"xmr.pool.\")) {\n            valid = m_algorithm.algo() == CRYPTONIGHT;\n            m_algorithm.setVariant(m_port == 45700 ? VARIANT_AUTO : VARIANT_0);\n        }\n        else if (m_host.contains(\"aeon.pool.\") \u0026\u0026 m_port == 45690) {\n            valid = m_algorithm.algo() == CRYPTONIGHT_LITE;\n            m_algorithm.setVariant(VARIANT_1);\n        }\n\n        if (!valid) {\n            m_algorithm.setAlgo(INVALID_ALGO);\n        }\n\n        return;\n    }\n\n    if (variantHint != VARIANT_AUTO) {\n        m_algorithm.setVariant(variantHint);\n        return;\n    }\n\n    if (m_algorithm.variant() != VARIANT_AUTO) {\n        return;\n    }\n\n    if (m_algorithm.algo() == CRYPTONIGHT_HEAVY)  {\n        m_algorithm.setVariant(VARIANT_0);\n    }\n    else if (m_algorithm.algo() == CRYPTONIGHT_LITE) {\n        m_algorithm.setVariant(VARIANT_1);\n    }\n#   endif\n}","filepath":"src/common/net/Pool.cpp","line_number":318,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4766512":{"score":0.7492832,"function_name":"Pool::addVariant","code":"void Pool::addVariant(xmrig::Variant variant)\n{\n    const xmrig::Algorithm algorithm(m_algorithm.algo(), variant);\n    if (!algorithm.isValid() || m_algorithm == algorithm) {\n        return;\n    }\n\n    m_algorithms.push_back(algorithm);\n}","filepath":"src/common/net/Pool.cpp","line_number":307,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4768096":{"score":0.62458014,"function_name":"Pool::rebuild","code":"void Pool::rebuild()\n{\n    m_algorithms.clear();\n\n    if (!m_algorithm.isValid()) {\n        return;\n    }\n\n    m_algorithms.push_back(m_algorithm);\n\n#   ifndef XMRIG_PROXY_PROJECT\n    addVariant(xmrig::VARIANT_WOW);\n    addVariant(xmrig::VARIANT_2);\n    addVariant(xmrig::VARIANT_1);\n    addVariant(xmrig::VARIANT_0);\n    addVariant(xmrig::VARIANT_HALF);\n    addVariant(xmrig::VARIANT_XTL);\n    addVariant(xmrig::VARIANT_TUBE);\n    addVariant(xmrig::VARIANT_MSR);\n    addVariant(xmrig::VARIANT_XHV);\n    addVariant(xmrig::VARIANT_XAO);\n    addVariant(xmrig::VARIANT_RTO);\n    addVariant(xmrig::VARIANT_GPU);\n    addVariant(xmrig::VARIANT_AUTO);\n#   endif\n}","filepath":"src/common/net/Pool.cpp","line_number":404,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4771424":{"score":0.8815276,"function_name":"FailoverStrategy::onClose","code":"void FailoverStrategy::onClose(Client *client, int failures)\n{\n    if (failures == -1) {\n        return;\n    }\n\n    if (m_active == client-\u003eid()) {\n        m_active = -1;\n        m_listener-\u003eonPause(this);\n    }\n\n    if (m_index == 0 \u0026\u0026 failures \u003c m_retries) {\n        return;\n    }\n\n    if (m_index == client-\u003eid() \u0026\u0026 (m_pools.size() - m_index) \u003e 1) {\n        m_pools[++m_index]-\u003econnect();\n    }\n}","filepath":"src/net/strategies/FailoverStrategy.cpp","line_number":100,"entry_url":"https://github.com/xmrig/xmrig-proxy.git","slot_name":"v2.5.3"},"4771584":{"score":0.8218533,"function_name":"FailoverStrategy::stop","code":"void FailoverStrategy::stop()\n{\n    for (size_t i = 0; i \u003c m_pools.size(); ++i) {\n        m_pools[i]-\u003edisconnect();\n    }\n\n    m_index  = 0;\n    m_active = -1;\n\n    m_listener-\u003eonPause(this);\n}","filepath":"src/net/strategies/FailoverStrategy.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig-proxy.git","slot_name":"v2.5.3"},"4771824":{"score":0.70984614,"function_name":"FailoverStrategy::onLoginSuccess","code":"void FailoverStrategy::onLoginSuccess(Client *client)\n{\n    int active = m_active;\n\n    if (client-\u003eid() == 0 || !isActive()) {\n        active = client-\u003eid();\n    }\n\n    for (size_t i = 1; i \u003c m_pools.size(); ++i) {\n        if (active != static_cast\u003cint\u003e(i)) {\n            m_pools[i]-\u003edisconnect();\n        }\n    }\n\n    if (active \u003e= 0 \u0026\u0026 active != m_active) {\n        m_index = m_active = active;\n        m_listener-\u003eonActive(this, client);\n    }\n}","filepath":"src/net/strategies/FailoverStrategy.cpp","line_number":129,"entry_url":"https://github.com/xmrig/xmrig-proxy.git","slot_name":"v2.5.3"},"4772288":{"score":0.74901533,"function_name":"FailoverStrategy::add","code":"void FailoverStrategy::add(const Pool \u0026pool)\n{\n    Client *client = new Client((int) m_pools.size(), Platform::userAgent(), this);\n    client-\u003esetPool(pool);\n    client-\u003esetRetryPause(m_retryPause * 1000);\n    client-\u003esetQuiet(m_quiet);\n\n    m_pools.push_back(client);\n}","filepath":"src/net/strategies/FailoverStrategy.cpp","line_number":156,"entry_url":"https://github.com/xmrig/xmrig-proxy.git","slot_name":"v2.5.3"},"4772512":{"score":0.68663454,"function_name":"FailoverStrategy::FailoverStrategy","code":"FailoverStrategy::FailoverStrategy(const std::vector\u003cPool\u003e \u0026urls, int retryPause, int retries, IStrategyListener *listener, bool quiet) :\n    m_quiet(quiet),\n    m_retries(retries),\n    m_retryPause(retryPause),\n    m_active(-1),\n    m_index(0),\n    m_listener(listener)\n{\n    for (const Pool \u0026url : urls) {\n        add(url);\n    }\n}","filepath":"src/net/strategies/FailoverStrategy.cpp","line_number":31,"entry_url":"https://github.com/xmrig/xmrig-proxy.git","slot_name":"v2.5.3"},"4773456":{"score":0.77276003,"function_name":"xmrig::SinglePoolStrategy::onClose","code":"void xmrig::SinglePoolStrategy::onClose(Client *, int)\n{\n    if (!isActive()) {\n        return;\n    }\n\n    m_active = false;\n    m_listener-\u003eonPause(this);\n}","filepath":"src/common/net/strategies/SinglePoolStrategy.cpp","line_number":90,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4773616":{"score":0.6402658,"function_name":"xmrig::SinglePoolStrategy::SinglePoolStrategy","code":"xmrig::SinglePoolStrategy::SinglePoolStrategy(const Pool \u0026pool, int retryPause, int retries, IStrategyListener *listener, bool quiet) :\n    m_active(false),\n    m_listener(listener)\n{\n    m_client = new Client(0, Platform::userAgent(), this);\n    m_client-\u003esetPool(pool);\n    m_client-\u003esetRetries(retries);\n    m_client-\u003esetRetryPause(retryPause * 1000);\n    m_client-\u003esetQuiet(quiet);\n}","filepath":"src/common/net/strategies/SinglePoolStrategy.cpp","line_number":32,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4773888":{"score":0.6628169,"function_name":"Platform::defaultConfigName","code":"const char *Platform::defaultConfigName()\n{\n    size_t size = 520;\n\n    if (*m_defaultConfigName) {\n        return m_defaultConfigName;\n    }\n\n    if (uv_exepath(m_defaultConfigName, \u0026size) \u003c 0) {\n        return nullptr;\n    }\n\n    if (size \u003c 500) {\n#       ifdef WIN32\n        char *p = strrchr(m_defaultConfigName, '\\\\');\n#       else\n        char *p = strrchr(m_defaultConfigName, '/');\n#       endif\n\n        if (p) {\n            strcpy(p + 1, \"config.json\");\n            return m_defaultConfigName;\n        }\n    }\n\n    *m_defaultConfigName = '\\0';\n    return nullptr;\n}","filepath":"src/common/Platform.cpp","line_number":43,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"4774064":{"score":0.65618,"function_name":"Platform::init","code":"void Platform::init(const char *userAgent)\n{\n#   ifndef XMRIG_NO_TLS\n    SSL_library_init();\n    SSL_load_error_strings();\n    ERR_load_BIO_strings();\n    ERR_load_crypto_strings();\n    SSL_load_error_strings();\n    OpenSSL_add_all_digests();\n#   endif\n\n    if (userAgent) {\n        m_userAgent = userAgent;\n    }\n    else {\n        m_userAgent = createUserAgent();\n    }\n}","filepath":"src/common/Platform.cpp","line_number":73,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"4774192":{"score":0.7278097,"function_name":"xmrig::Config::parseBoolean","code":"bool xmrig::Config::parseBoolean(int key, bool enable)\n{\n    if (!CommonConfig::parseBoolean(key, enable)) {\n        return false;\n    }\n\n    switch (key) {\n    case IConfig::SafeKey: /* --safe */\n        m_safe = enable;\n        break;\n\n    case IConfig::HugePagesKey: /* --no-huge-pages */\n        m_hugePages = enable;\n        break;\n\n    case IConfig::DryRunKey: /* --dry-run */\n        m_dryRun = enable;\n        break;\n\n    case IConfig::HardwareAESKey: /* hw-aes config only */\n        m_aesMode = enable ? AES_HW : AES_SOFT;\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":188,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4774368":{"score":0.7050618,"function_name":"xmrig::Config::parseBoolean","code":"bool xmrig::Config::parseBoolean(int key, bool enable)\n{\n    if (!CommonConfig::parseBoolean(key, enable)) {\n        return false;\n    }\n\n    switch (key) {\n    case SafeKey: /* --safe */\n        m_safe = enable;\n        break;\n\n    case HugePagesKey: /* --no-huge-pages */\n        m_hugePages = enable;\n        break;\n\n    case HardwareAESKey: /* hw-aes config only */\n        m_aesMode = enable ? AES_HW : AES_SOFT;\n        break;\n\n#   ifndef XMRIG_NO_ASM\n    case AssemblyKey:\n        m_assembly = Asm::parse(enable);\n        break;\n#   endif\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":192,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4774560":{"score":0.7685784,"function_name":"xmrig::Config::parseString","code":"bool xmrig::Config::parseString(int key, const char *arg)\n{\n    if (!CommonConfig::parseString(key, arg)) {\n        return false;\n    }\n\n    switch (key) {\n    case AVKey:          /* --av */\n    case MaxCPUUsageKey: /* --max-cpu-usage */\n    case CPUPriorityKey: /* --cpu-priority */\n        return parseUint64(key, strtol(arg, nullptr, 10));\n\n    case SafeKey: /* --safe */\n        return parseBoolean(key, true);\n\n    case HugePagesKey: /* --no-huge-pages */\n        return parseBoolean(key, false);\n\n    case ThreadsKey:  /* --threads */\n        if (strncmp(arg, \"all\", 3) == 0) {\n            m_threads.count = Cpu::info()-\u003ethreads();\n            return true;\n        }\n\n        return parseUint64(key, strtol(arg, nullptr, 10));\n\n    case CPUAffinityKey: /* --cpu-affinity */\n        {\n            const char *p  = strstr(arg, \"0x\");\n            return parseUint64(key, p ? strtoull(p, nullptr, 16) : strtoull(arg, nullptr, 10));\n        }\n\n#   ifndef XMRIG_NO_ASM\n    case AssemblyKey: /* --asm */\n        m_assembly = Asm::parse(arg);\n        break;\n#   endif\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":225,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4775408":{"score":0.6779176,"function_name":"xmrig::Config::Config","code":"xmrig::Config::Config() : xmrig::CommonConfig(),\n    m_aesMode(AES_AUTO),\n    m_algoVariant(AV_AUTO),\n    m_assembly(ASM_AUTO),\n    m_hugePages(true),\n    m_safe(false),\n    m_shouldSave(false),\n    m_maxCpuUsage(75),\n    m_priority(-1)\n{\n}","filepath":"src/core/Config.cpp","line_number":44,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4775680":{"score":0.92027223,"function_name":"xmrig::Config::parseInt","code":"bool xmrig::Config::parseInt(int key, int arg)\n{\n    switch (key) {\n    case ThreadsKey: /* --threads */\n        if (arg \u003e= 0 \u0026\u0026 arg \u003c 1024) {\n            m_threads.count = arg;\n        }\n        break;\n\n    case AVKey: /* --av */\n        if (arg \u003e= AV_AUTO \u0026\u0026 arg \u003c AV_MAX) {\n            m_algoVariant = static_cast\u003cAlgoVariant\u003e(arg);\n        }\n        break;\n\n    case MaxCPUUsageKey: /* --max-cpu-usage */\n        if (m_maxCpuUsage \u003e 0 \u0026\u0026 arg \u003c= 100) {\n            m_maxCpuUsage = arg;\n        }\n        break;\n\n    case CPUPriorityKey: /* --cpu-priority */\n        if (arg \u003e= 0 \u0026\u0026 arg \u003c= 5) {\n            m_priority = arg;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":314,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4775824":{"score":0.728826,"function_name":"Options::getAlgoVariant","code":"int Options::getAlgoVariant() const\n{\n#   ifndef XMRIG_NO_AEON\n    if (m_algo == xmrig::ALGO_CRYPTONIGHT_LITE) {\n        return getAlgoVariantLite();\n    }\n#   endif\n\n    if (m_algoVariant \u003c= AV0_AUTO || m_algoVariant \u003e= AV_MAX) {\n        return Cpu::hasAES() ? AV1_AESNI : AV3_SOFT_AES;\n    }\n\n    if (m_safe \u0026\u0026 !Cpu::hasAES() \u0026\u0026 m_algoVariant \u003c= AV2_AESNI_DOUBLE) {\n        return m_algoVariant + 2;\n    }\n\n    return m_algoVariant;\n}","filepath":"src/Options.cpp","line_number":728,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.0"},"4775968":{"score":0.6779553,"function_name":"xmrig::Config::getAlgoVariant","code":"xmrig::AlgoVariant xmrig::Config::getAlgoVariant() const\n{\n#   ifndef XMRIG_NO_AEON\n    if (m_algorithm.algo() == xmrig::CRYPTONIGHT_LITE) {\n        return getAlgoVariantLite();\n    }\n#   endif\n\n    if (m_algoVariant \u003c= AV_AUTO || m_algoVariant \u003e= AV_MAX) {\n        return Cpu::info()-\u003ehasAES() ? AV_SINGLE : AV_SINGLE_SOFT;\n    }\n\n    if (m_safe \u0026\u0026 !Cpu::info()-\u003ehasAES() \u0026\u0026 m_algoVariant \u003c= AV_DOUBLE) {\n        return static_cast\u003cAlgoVariant\u003e(m_algoVariant + 2);\n    }\n\n    return m_algoVariant;\n}","filepath":"src/core/Config.cpp","line_number":349,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4785792":{"score":0.7810877,"function_name":"xmrig::Config::finalize","code":"bool xmrig::Config::finalize()\n{\n    if (m_state != NoneState) {\n        return CommonConfig::finalize();\n    }\n\n    if (!CommonConfig::finalize()) {\n        return false;\n    }\n\n    if (!m_threads.cpu.empty()) {\n        m_threads.mode     = Advanced;\n        const bool softAES = (m_aesMode == AES_AUTO ? (Cpu::info()-\u003ehasAES() ? AES_HW : AES_SOFT) : m_aesMode) == AES_SOFT;\n\n        for (size_t i = 0; i \u003c m_threads.cpu.size(); ++i) {\n            m_threads.list.push_back(CpuThread::createFromData(i, m_algorithm.algo(), m_threads.cpu[i], m_priority, softAES));\n        }\n\n        return true;\n    }\n\n    const AlgoVariant av = getAlgoVariant();   \n    m_threads.mode = m_threads.count ? Simple : Automatic;\n\n    const size_t size = CpuThread::multiway(av) * cn_select_memory(m_algorithm.algo()) / 1024;\n\n    if (!m_threads.count) {\n        m_threads.count = Cpu::info()-\u003eoptimalThreadsCount(size, m_maxCpuUsage);\n    }\n    else if (m_safe) {\n        const size_t count = Cpu::info()-\u003eoptimalThreadsCount(size, m_maxCpuUsage);\n        if (m_threads.count \u003e count) {\n            m_threads.count = count;\n        }\n    }\n\n    for (size_t i = 0; i \u003c m_threads.count; ++i) {\n        m_threads.list.push_back(CpuThread::createFromAV(i, m_algorithm.algo(), av, m_threads.mask, m_priority, m_assembly));\n    }\n\n    m_shouldSave = m_threads.mode == Automatic;\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":147,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4786512":{"score":0.6471437,"function_name":"xmrig::Config::parseJSON","code":"void xmrig::Config::parseJSON(const rapidjson::Document \u0026doc)\n{\n    const rapidjson::Value \u0026threads = doc[\"threads\"];\n\n    if (threads.IsArray()) {\n        for (const rapidjson::Value \u0026value : threads.GetArray()) {\n            if (!value.IsObject()) {\n                continue;\n            }\n\n            if (value.HasMember(\"low_power_mode\")) {\n                auto data = CpuThread::parse(value);\n\n                if (data.valid) {\n                    m_threads.cpu.push_back(std::move(data));\n                }\n            }\n        }\n    }\n}","filepath":"src/core/Config.cpp","line_number":292,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4788176":{"score":0.72854376,"function_name":"AddMember","code":"GenericValue\u0026 AddMember(GenericValue\u0026 name, GenericValue\u0026 value, Allocator\u0026 allocator) {\n        RAPIDJSON_ASSERT(IsObject());\n        RAPIDJSON_ASSERT(name.IsString());\n\n        ObjectData\u0026 o = data_.o;\n        if (o.size \u003e= o.capacity) {\n            if (o.capacity == 0) {\n                o.capacity = kDefaultObjectCapacity;\n                SetMembersPointer(reinterpret_cast\u003cMember*\u003e(allocator.Malloc(o.capacity * sizeof(Member))));\n            }\n            else {\n                SizeType oldCapacity = o.capacity;\n                o.capacity += (oldCapacity + 1) / 2; // grow by factor 1.5\n                SetMembersPointer(reinterpret_cast\u003cMember*\u003e(allocator.Realloc(GetMembersPointer(), oldCapacity * sizeof(Member), o.capacity * sizeof(Member))));\n            }\n        }\n        Member* members = GetMembersPointer();\n        members[o.size].name.RawAssign(name);\n        members[o.size].value.RawAssign(value);\n        o.size++;\n        return *this;\n    }","filepath":"bazaar/plugin/assimp/contrib/rapidjson/include/rapidjson/document.h","line_number":1241,"entry_url":"https://github.com/ultimatepp/ultimatepp.git","slot_name":"2021.1"},"4789696":{"score":0.7823783,"function_name":"xmrig::Controller::onNewConfig","code":"void xmrig::Controller::onNewConfig(IConfig *config)\n{\n    Config *previousConfig = d_ptr-\u003econfig;\n    d_ptr-\u003econfig = static_cast\u003cConfig*\u003e(config);\n\n    for (xmrig::IControllerListener *listener : d_ptr-\u003elisteners) {\n        listener-\u003eonConfigChanged(d_ptr-\u003econfig, previousConfig);\n    }\n\n    delete previousConfig;\n}","filepath":"src/core/Controller.cpp","line_number":141,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4790160":{"score":0.7259749,"function_name":"xmrig::Controller::init","code":"int xmrig::Controller::init(int argc, char **argv)\n{\n    Cpu::init();\n\n    d_ptr-\u003econfig = xmrig::Config::load(argc, argv, this);\n    if (!d_ptr-\u003econfig) {\n        return 1;\n    }\n\n    Log::init();\n    Platform::init(config()-\u003euserAgent());\n    Platform::setProcessPriority(d_ptr-\u003econfig-\u003epriority());\n\n    if (!config()-\u003eisBackground()) {\n        Log::add(new ConsoleLog(this));\n    }\n\n    if (config()-\u003elogFile()) {\n        Log::add(new FileLog(this, config()-\u003elogFile()));\n    }\n\n#   ifdef HAVE_SYSLOG_H\n    if (config()-\u003eisSyslog()) {\n        Log::add(new SysLog());\n    }\n#   endif\n\n    d_ptr-\u003enetwork = new Network(this);\n    return 0;\n}","filepath":"src/core/Controller.cpp","line_number":95,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4791232":{"score":0.53174734,"function_name":"Mem::create","code":"MemInfo Mem::create(cryptonight_ctx **ctx, xmrig::Algo algorithm, size_t count)\n{\n    using namespace xmrig;\n\n    MemInfo info;\n    info.size = cn_select_memory(algorithm) * count;\n\n    constexpr const size_t align_size = 2 * 1024 * 1024;\n    info.size  = ((info.size + align_size - 1) / align_size) * align_size;\n    info.pages = info.size / align_size;\n\n    allocate(info, m_enabled);\n\n    for (size_t i = 0; i \u003c count; ++i) {\n        cryptonight_ctx *c = static_cast\u003ccryptonight_ctx *\u003e(_mm_malloc(sizeof(cryptonight_ctx), 4096));\n        c-\u003ememory          = info.memory + (i * cn_select_memory(algorithm));\n\n        c-\u003egenerated_code              = reinterpret_cast\u003ccn_mainloop_fun_ms_abi\u003e(xmrig::VirtualMemory::allocateExecutableMemory(0x4000));\n        c-\u003egenerated_code_data.variant = xmrig::VARIANT_MAX;\n        c-\u003egenerated_code_data.height  = std::numeric_limits\u003cuint64_t\u003e::max();\n\n        ctx[i] = c;\n    }\n\n    return info;\n}","filepath":"src/Mem.cpp","line_number":41,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"4791552":{"score":0.58565587,"function_name":"Mem::release","code":"void Mem::release(cryptonight_ctx **ctx, size_t count, MemInfo \u0026info)\n{\n    if (info.memory == nullptr) {\n        return;\n    }\n\n    release(info);\n\n    for (size_t i = 0; i \u003c count; ++i) {\n        _mm_free(ctx[i]);\n    }\n}","filepath":"src/Mem.cpp","line_number":69,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"4791616":{"score":0.70105827,"function_name":"xmrig::Network::onJobResult","code":"void xmrig::Network::onJobResult(const JobResult \u0026result)\n{\n    if (result.poolId == -1 \u0026\u0026 m_donate) {\n        m_donate-\u003esubmit(result);\n        return;\n    }\n\n    m_strategy-\u003esubmit(result);\n}","filepath":"src/net/Network.cpp","line_number":134,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4791792":{"score":0.7736565,"function_name":"xmrig::Network::onActive","code":"void xmrig::Network::onActive(IStrategy *strategy, Client *client)\n{\n    if (m_donate \u0026\u0026 m_donate == strategy) {\n        LOG_NOTICE(\"dev donate started\");\n        return;\n    }\n\n    m_state.setPool(client-\u003ehost(), client-\u003eport(), client-\u003eip());\n\n    const char *tlsVersion = client-\u003etlsVersion();\n    LOG_INFO(isColors() ? WHITE_BOLD(\"use pool \") CYAN_BOLD(\"%s:%d \") GREEN_BOLD(\"%s\") \" \\x1B[1;30m%s \"\n                        : \"use pool %s:%d %s %s\",\n             client-\u003ehost(), client-\u003eport(), tlsVersion ? tlsVersion : \"\", client-\u003eip());\n\n    const char *fingerprint = client-\u003etlsFingerprint();\n    if (fingerprint != nullptr) {\n        LOG_INFO(\"%sfingerprint (SHA-256): \\\"%s\\\"\", isColors() ? \"\\x1B[1;30m\" : \"\", fingerprint);\n    }\n}","filepath":"src/net/Network.cpp","line_number":87,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4792256":{"score":0.8221698,"function_name":"xmrig::Network::onPause","code":"void xmrig::Network::onPause(IStrategy *strategy)\n{\n    if (m_donate \u0026\u0026 m_donate == strategy) {\n        LOG_NOTICE(\"dev donate finished\");\n        m_strategy-\u003eresume();\n    }\n\n    if (!m_strategy-\u003eisActive()) {\n        LOG_ERR(\"no active pools, stop mining\");\n        m_state.stop();\n        return Workers::pause();\n    }\n}","filepath":"src/net/Network.cpp","line_number":145,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4792464":{"score":0.7437577,"function_name":"xmrig::Network::onResultAccepted","code":"void xmrig::Network::onResultAccepted(IStrategy *, Client *, const SubmitResult \u0026result, const char *error)\n{\n    m_state.add(result, error);\n\n    if (error) {\n        LOG_INFO(isColors() ? \"\\x1B[1;31mrejected\\x1B[0m (%\" PRId64 \"/%\" PRId64 \") diff \\x1B[1;37m%u\\x1B[0m \\x1B[31m\\\"%s\\\"\\x1B[0m \\x1B[1;30m(%\" PRIu64 \" ms)\"\n                            : \"rejected (%\" PRId64 \"/%\" PRId64 \") diff %u \\\"%s\\\" (%\" PRIu64 \" ms)\",\n                 m_state.accepted, m_state.rejected, result.diff, error, result.elapsed);\n    }\n    else {\n        LOG_INFO(isColors() ? \"\\x1B[1;32maccepted\\x1B[0m (%\" PRId64 \"/%\" PRId64 \") diff \\x1B[1;37m%u\\x1B[0m \\x1B[1;30m(%\" PRIu64 \" ms)\"\n                            : \"accepted (%\" PRId64 \"/%\" PRId64 \") diff %u (%\" PRIu64 \" ms)\",\n                 m_state.accepted, m_state.rejected, result.diff, result.elapsed);\n    }\n}","filepath":"src/net/Network.cpp","line_number":160,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4793152":{"score":0.73108083,"function_name":"xmrig::Network::Network","code":"xmrig::Network::Network(Controller *controller) :\n    m_donate(nullptr)\n{\n    Workers::setListener(this);\n    controller-\u003eaddListener(this);\n\n    const Pools \u0026pools = controller-\u003econfig()-\u003epools();\n    m_strategy = pools.createStrategy(this);\n\n    if (controller-\u003econfig()-\u003edonateLevel() \u003e 0) {\n        m_donate = new DonateStrategy(controller-\u003econfig()-\u003edonateLevel(), pools.data().front().user(), controller-\u003econfig()-\u003ealgorithm().algo(), this);\n    }\n\n    m_timer.data = this;\n    uv_timer_init(uv_default_loop(), \u0026m_timer);\n\n    uv_timer_start(\u0026m_timer, Network::onTick, kTickInterval, kTickInterval);\n}","filepath":"src/net/Network.cpp","line_number":45,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4793760":{"score":0.5960319,"function_name":"xmrig::Network::setJob","code":"void xmrig::Network::setJob(Client *client, const Job \u0026job, bool donate)\n{\n    if (job.height()) {\n        LOG_INFO(isColors() ? MAGENTA_BOLD(\"new job\") \" from \" WHITE_BOLD(\"%s:%d\") \" diff \" WHITE_BOLD(\"%d\") \" algo \" WHITE_BOLD(\"%s\") \" height \" WHITE_BOLD(\"%\" PRIu64)\n                            : \"new job from %s:%d diff %d algo %s height %\" PRIu64,\n                 client-\u003ehost(), client-\u003eport(), job.diff(), job.algorithm().shortName(), job.height());\n    }\n    else {\n        LOG_INFO(isColors() ? MAGENTA_BOLD(\"new job\") \" from \" WHITE_BOLD(\"%s:%d\") \" diff \" WHITE_BOLD(\"%d\") \" algo \" WHITE_BOLD(\"%s\")\n                            : \"new job from %s:%d diff %d algo %s\",\n                 client-\u003ehost(), client-\u003eport(), job.diff(), job.algorithm().shortName());\n    }\n\n    if (!donate \u0026\u0026 m_donate) {\n        m_donate-\u003esetAlgo(job.algorithm());\n    }\n\n    m_state.diff = job.diff();\n    Workers::setJob(job, donate);\n}","filepath":"src/net/Network.cpp","line_number":183,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4793984":{"score":0.5865431,"function_name":"xmrig::Network::tick","code":"void xmrig::Network::tick()\n{\n    const uint64_t now = uv_now(uv_default_loop());\n\n    m_strategy-\u003etick(now);\n\n    if (m_donate) {\n        m_donate-\u003etick(now);\n    }\n\n#   ifndef XMRIG_NO_API\n    Api::tick(m_state);\n#   endif\n}","filepath":"src/net/Network.cpp","line_number":205,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4794240":{"score":0.7751456,"function_name":"DonateStrategy::onActive","code":"void DonateStrategy::onActive(IStrategy *strategy, Client *client)\n{\n    if (!isActive()) {\n        uv_timer_start(\u0026m_timer, DonateStrategy::onTimer, m_donateTime, 0);\n    }\n\n    m_active = true;\n    m_listener-\u003eonActive(this, client);\n}","filepath":"src/net/strategies/DonateStrategy.cpp","line_number":125,"entry_url":"https://github.com/xmrig/xmrig-nvidia.git","slot_name":"v2.11.0"},"4794992":{"score":0.83312964,"function_name":"DonateStrategy::DonateStrategy","code":"DonateStrategy::DonateStrategy(int level, const char *user, xmrig::Algo algo, IStrategyListener *listener) :\n    m_active(false),\n    m_donateTime(level * 60 * 1000),\n    m_idleTime((100 - level) * 60 * 1000),\n    m_strategy(nullptr),\n    m_listener(listener),\n    m_now(0),\n    m_stop(0)\n{\n    uint8_t hash[200];\n    char userId[65] = { 0 };\n\n    xmrig::keccak(reinterpret_cast\u003cconst uint8_t *\u003e(user), strlen(user), hash);\n    Job::toHex(hash, 32, userId);\n\n#   ifndef XMRIG_NO_TLS\n    m_pools.push_back(Pool(\"donate.ssl.xmrig.com\", 443, userId, nullptr, false, true, true));\n#   endif\n\n    m_pools.push_back(Pool(\"donate.v2.xmrig.com\", 3333, userId, nullptr, false, true));\n\n    for (Pool \u0026pool : m_pools) {\n        pool.adjust(xmrig::Algorithm(algo, xmrig::VARIANT_AUTO));\n    }\n\n    if (m_pools.size() \u003e 1) {\n        m_strategy = new FailoverStrategy(m_pools, 1, 2, this, true);\n    }\n    else {\n        m_strategy = new SinglePoolStrategy(m_pools.front(), 1, 2, this, true);\n    }\n\n    m_timer.data = this;\n    uv_timer_init(uv_default_loop(), \u0026m_timer);\n\n    idle(m_idleTime * randomf(0.5, 1.5));\n}","filepath":"src/net/strategies/DonateStrategy.cpp","line_number":42,"entry_url":"https://github.com/xmrig/xmrig-nvidia.git","slot_name":"v2.11.0"},"4798400":{"score":0.8555752,"function_name":"aes_round","code":"inline void aes_round(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7)\n{\n    *x0 = soft_aesenc(*x0, key);\n    *x1 = soft_aesenc(*x1, key);\n    *x2 = soft_aesenc(*x2, key);\n    *x3 = soft_aesenc(*x3, key);\n    *x4 = soft_aesenc(*x4, key);\n    *x5 = soft_aesenc(*x5, key);\n    *x6 = soft_aesenc(*x6, key);\n    *x7 = soft_aesenc(*x7, key);\n}","filepath":"algo/cryptonight/cryptonight_softaes.h","line_number":62,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.8.2"},"4798672":{"score":0.7525543,"function_name":"aes_genkey","code":"inline void aes_genkey(const __m128i* memory, __m128i* k0, __m128i* k1, __m128i* k2, __m128i* k3, __m128i* k4, __m128i* k5, __m128i* k6, __m128i* k7, __m128i* k8, __m128i* k9)\n{\n    __m128i xout0 = _mm_load_si128(memory);\n    __m128i xout2 = _mm_load_si128(memory + 1);\n    *k0 = xout0;\n    *k1 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x1);\n    *k2 = xout0;\n    *k3 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x2);\n    *k4 = xout0;\n    *k5 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x4);\n    *k6 = xout0;\n    *k7 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x8);\n    *k8 = xout0;\n    *k9 = xout2;\n}","filepath":"algo/cryptonight/cryptonight_softaes.h","line_number":75,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.8.2"},"4799200":{"score":0.78237456,"function_name":"cn_explode_scratchpad","code":"static inline void cn_explode_scratchpad(const __m128i* input, __m128i* output)\n{\n    // This is more than we have registers, compiler will assign 2 keys on the stack\n    __m128i xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7;\n    __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;\n\n    aes_genkey(input, \u0026k0, \u0026k1, \u0026k2, \u0026k3, \u0026k4, \u0026k5, \u0026k6, \u0026k7, \u0026k8, \u0026k9);\n\n    xin0 = _mm_load_si128(input + 4);\n    xin1 = _mm_load_si128(input + 5);\n    xin2 = _mm_load_si128(input + 6);\n    xin3 = _mm_load_si128(input + 7);\n    xin4 = _mm_load_si128(input + 8);\n    xin5 = _mm_load_si128(input + 9);\n    xin6 = _mm_load_si128(input + 10);\n    xin7 = _mm_load_si128(input + 11);\n\n    for (size_t i = 0; i \u003c MEMORY / sizeof(__m128i); i += 8) {\n        aes_round(k0, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k1, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k2, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k3, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k4, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k5, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k6, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k7, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k8, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k9, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n\n        _mm_store_si128(output + i + 0, xin0);\n        _mm_store_si128(output + i + 1, xin1);\n        _mm_store_si128(output + i + 2, xin2);\n        _mm_store_si128(output + i + 3, xin3);\n        _mm_store_si128(output + i + 4, xin4);\n        _mm_store_si128(output + i + 5, xin5);\n        _mm_store_si128(output + i + 6, xin6);\n        _mm_store_si128(output + i + 7, xin7);\n    }\n}","filepath":"algo/cryptonight/cryptonight_softaes.h","line_number":100,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.8.2"},"4800048":{"score":0.7622594,"function_name":"cn_implode_scratchpad","code":"static inline void cn_implode_scratchpad(const __m128i* input, __m128i* output)\n{\n    // This is more than we have registers, compiler will assign 2 keys on the stack\n    __m128i xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7;\n    __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;\n\n    aes_genkey(output + 2, \u0026k0, \u0026k1, \u0026k2, \u0026k3, \u0026k4, \u0026k5, \u0026k6, \u0026k7, \u0026k8, \u0026k9);\n\n    xout0 = _mm_load_si128(output + 4);\n    xout1 = _mm_load_si128(output + 5);\n    xout2 = _mm_load_si128(output + 6);\n    xout3 = _mm_load_si128(output + 7);\n    xout4 = _mm_load_si128(output + 8);\n    xout5 = _mm_load_si128(output + 9);\n    xout6 = _mm_load_si128(output + 10);\n    xout7 = _mm_load_si128(output + 11);\n\n    for (size_t i = 0; __builtin_expect(i \u003c MEMORY / sizeof(__m128i), 1); i += 8)\n    {\n        xout0 = _mm_xor_si128(_mm_load_si128(input + i + 0), xout0);\n        xout1 = _mm_xor_si128(_mm_load_si128(input + i + 1), xout1);\n        xout2 = _mm_xor_si128(_mm_load_si128(input + i + 2), xout2);\n        xout3 = _mm_xor_si128(_mm_load_si128(input + i + 3), xout3);\n        xout4 = _mm_xor_si128(_mm_load_si128(input + i + 4), xout4);\n        xout5 = _mm_xor_si128(_mm_load_si128(input + i + 5), xout5);\n        xout6 = _mm_xor_si128(_mm_load_si128(input + i + 6), xout6);\n        xout7 = _mm_xor_si128(_mm_load_si128(input + i + 7), xout7);\n\n        aes_round(k0, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k1, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k2, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k3, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k4, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k5, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k6, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k7, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k8, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k9, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n    }\n\n    _mm_store_si128(output + 4, xout0);\n    _mm_store_si128(output + 5, xout1);\n    _mm_store_si128(output + 6, xout2);\n    _mm_store_si128(output + 7, xout3);\n    _mm_store_si128(output + 8, xout4);\n    _mm_store_si128(output + 9, xout5);\n    _mm_store_si128(output + 10, xout6);\n    _mm_store_si128(output + 11, xout7);\n}","filepath":"algo/cryptonight/cryptonight_softaes.h","line_number":141,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.8.2"},"4801824":{"score":0.79462403,"function_name":"cn_implode_scratchpad","code":"static inline void cn_implode_scratchpad(const __m128i* input, __m128i* output)\n{\n    // This is more than we have registers, compiler will assign 2 keys on the stack\n    __m128i xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7;\n    __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;\n\n    aes_genkey(output + 2, \u0026k0, \u0026k1, \u0026k2, \u0026k3, \u0026k4, \u0026k5, \u0026k6, \u0026k7, \u0026k8, \u0026k9);\n\n    xout0 = _mm_load_si128(output + 4);\n    xout1 = _mm_load_si128(output + 5);\n    xout2 = _mm_load_si128(output + 6);\n    xout3 = _mm_load_si128(output + 7);\n    xout4 = _mm_load_si128(output + 8);\n    xout5 = _mm_load_si128(output + 9);\n    xout6 = _mm_load_si128(output + 10);\n    xout7 = _mm_load_si128(output + 11);\n\n    for (size_t i = 0; i \u003c MEMORY / sizeof(__m128i); i += 8)\n    {\n        _mm_prefetch((const char*)input + i + 0, _MM_HINT_NTA);\n        xout0 = _mm_xor_si128(_mm_load_si128(input + i + 0), xout0);\n        xout1 = _mm_xor_si128(_mm_load_si128(input + i + 1), xout1);\n        xout2 = _mm_xor_si128(_mm_load_si128(input + i + 2), xout2);\n        xout3 = _mm_xor_si128(_mm_load_si128(input + i + 3), xout3);\n        _mm_prefetch((const char*)input + i + 4, _MM_HINT_NTA);\n        xout4 = _mm_xor_si128(_mm_load_si128(input + i + 4), xout4);\n        xout5 = _mm_xor_si128(_mm_load_si128(input + i + 5), xout5);\n        xout6 = _mm_xor_si128(_mm_load_si128(input + i + 6), xout6);\n        xout7 = _mm_xor_si128(_mm_load_si128(input + i + 7), xout7);\n\n        aes_round(k0, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k1, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k2, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k3, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k4, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k5, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k6, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k7, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k8, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k9, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n    }\n\n    _mm_store_si128(output + 4, xout0);\n    _mm_store_si128(output + 5, xout1);\n    _mm_store_si128(output + 6, xout2);\n    _mm_store_si128(output + 7, xout3);\n    _mm_store_si128(output + 8, xout4);\n    _mm_store_si128(output + 9, xout5);\n    _mm_store_si128(output + 10, xout6);\n    _mm_store_si128(output + 11, xout7);\n}","filepath":"algo/cryptonight/i686/cryptonight_av1_aesni.c","line_number":200,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.6.0"},"4806864":{"score":0.77427256,"function_name":"aes_genkey","code":"static inline void aes_genkey(const __m128i* memory, __m128i* k0, __m128i* k1, __m128i* k2, __m128i* k3, __m128i* k4, __m128i* k5, __m128i* k6, __m128i* k7, __m128i* k8, __m128i* k9)\n{\n    __m128i xout0 = _mm_load_si128(memory);\n    __m128i xout2 = _mm_load_si128(memory + 1);\n    *k0 = xout0;\n    *k1 = xout2;\n\n    soft_aes_genkey_sub\u003c0x01\u003e(\u0026xout0, \u0026xout2);\n    *k2 = xout0;\n    *k3 = xout2;\n\n    soft_aes_genkey_sub\u003c0x02\u003e(\u0026xout0, \u0026xout2);\n    *k4 = xout0;\n    *k5 = xout2;\n\n    soft_aes_genkey_sub\u003c0x04\u003e(\u0026xout0, \u0026xout2);\n    *k6 = xout0;\n    *k7 = xout2;\n\n    soft_aes_genkey_sub\u003c0x08\u003e(\u0026xout0, \u0026xout2);\n    *k8 = xout0;\n    *k9 = xout2;\n}","filepath":"src/crypto/CryptoNight_arm.h","line_number":164,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4813808":{"score":0.80681056,"function_name":"cn_explode_scratchpad","code":"static inline void cn_explode_scratchpad(const __m128i* input, __m128i* output)\n{\n    // This is more than we have registers, compiler will assign 2 keys on the stack\n    __m128i xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7;\n    __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;\n\n    aes_genkey(input, \u0026k0, \u0026k1, \u0026k2, \u0026k3, \u0026k4, \u0026k5, \u0026k6, \u0026k7, \u0026k8, \u0026k9);\n\n    xin0 = _mm_load_si128(input + 4);\n    xin1 = _mm_load_si128(input + 5);\n    xin2 = _mm_load_si128(input + 6);\n    xin3 = _mm_load_si128(input + 7);\n    xin4 = _mm_load_si128(input + 8);\n    xin5 = _mm_load_si128(input + 9);\n    xin6 = _mm_load_si128(input + 10);\n    xin7 = _mm_load_si128(input + 11);\n\n    for (size_t i = 0; i \u003c MEMORY / sizeof(__m128i); i += 8) {\n        aes_round(k0, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k1, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k2, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k3, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k4, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k5, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k6, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k7, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k8, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k9, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n\n        _mm_store_si128(output + i + 0, xin0);\n        _mm_store_si128(output + i + 1, xin1);\n        _mm_store_si128(output + i + 2, xin2);\n        _mm_store_si128(output + i + 3, xin3);\n        _mm_prefetch((const char*)output + i + 0, _MM_HINT_T2);\n        _mm_store_si128(output + i + 4, xin4);\n        _mm_store_si128(output + i + 5, xin5);\n        _mm_store_si128(output + i + 6, xin6);\n        _mm_store_si128(output + i + 7, xin7);\n        _mm_prefetch((const char*)output + i + 4, _MM_HINT_T2);\n    }\n}","filepath":"algo/cryptonight/i686/cryptonight_av1_aesni.c","line_number":157,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.6.0"},"4846480":{"score":0.8525059,"function_name":"xmrig::CpuThread::CpuThread","code":"xmrig::CpuThread::CpuThread(size_t index, Algo algorithm, AlgoVariant av, Multiway multiway, int64_t affinity, int priority, bool softAES, bool prefetch) :\n    m_algorithm(algorithm),\n    m_av(av),\n    m_prefetch(prefetch),\n    m_softAES(softAES),\n    m_priority(priority),\n    m_affinity(affinity),\n    m_multiway(multiway),\n    m_index(index)\n{\n}","filepath":"src/workers/CpuThread.cpp","line_number":39,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4846720":{"score":0.67636913,"function_name":"xmrig::CpuThread::createFromAV","code":"xmrig::CpuThread *xmrig::CpuThread::createFromAV(size_t index, Algo algorithm, AlgoVariant av, int64_t affinity, int priority)\n{\n    assert(av \u003e AV_AUTO \u0026\u0026 av \u003c AV_MAX);\n\n    int64_t cpuId = -1L;\n\n    if (affinity != -1L) {\n        size_t idx = 0;\n\n        for (size_t i = 0; i \u003c 64; i++) {\n            if (!(affinity \u0026 (1ULL \u003c\u003c i))) {\n                continue;\n            }\n\n            if (idx == index) {\n                cpuId = i;\n                break;\n            }\n\n            idx++;\n        }\n    }\n\n    return new CpuThread(index, algorithm, av, multiway(av), cpuId, priority, isSoftAES(av), false);\n}","filepath":"src/workers/CpuThread.cpp","line_number":220,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4846960":{"score":0.6321728,"function_name":"xmrig::CpuThread::createFromData","code":"xmrig::CpuThread *xmrig::CpuThread::createFromData(size_t index, Algo algorithm, const CpuThread::Data \u0026data, int priority, bool softAES)\n{\n    int av                  = AV_AUTO;\n    const Multiway multiway = data.multiway;\n\n    if (multiway \u003c= DoubleWay) {\n        av = softAES ? (multiway + 2) : multiway;\n    }\n    else {\n        av = softAES ? (multiway + 5) : (multiway + 2);\n    }\n\n    assert(av \u003e AV_AUTO \u0026\u0026 av \u003c AV_MAX);\n\n    return new CpuThread(index, algorithm, static_cast\u003cAlgoVariant\u003e(av), multiway, data.affinity, priority, softAES, false);\n}","filepath":"src/workers/CpuThread.cpp","line_number":247,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4847280":{"score":0.6724589,"function_name":"xmrig::CpuThread::parse","code":"xmrig::CpuThread::Data xmrig::CpuThread::parse(const rapidjson::Value \u0026object)\n{\n    Data data;\n\n    const auto \u0026multiway = object[\"low_power_mode\"];\n    if (multiway.IsBool()) {\n        data.multiway = multiway.IsTrue() ? DoubleWay : SingleWay;\n        data.valid    = true;\n    }\n    else if (multiway.IsUint()) {\n        data.setMultiway(multiway.GetInt());\n    }\n\n    if (!data.valid) {\n        return data;\n    }\n\n    const auto \u0026affinity = object[\"affine_to_cpu\"];\n\n    if (affinity.IsUint64()) {\n        data.affinity = affinity.GetInt64();\n    }\n\n    return data;\n}","filepath":"src/workers/CpuThread.cpp","line_number":265,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4847856":{"score":0.6283101,"function_name":"xmrig::DnsConfig::toJSON","code":"rapidjson::Value xmrig::DnsConfig::toJSON(rapidjson::Document \u0026doc) const\n{\n    using namespace rapidjson;\n\n    auto \u0026allocator = doc.GetAllocator();\n    Value obj(kObjectType);\n\n    obj.AddMember(StringRef(kIPv6), m_ipv6, allocator);\n    obj.AddMember(StringRef(kTTL),  m_ttl, allocator);\n\n    return obj;\n}","filepath":"src/base/net/dns/DnsConfig.cpp","line_number":46,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.11.0"},"4848544":{"score":0.58126146,"function_name":"xmrig::CpuConfig::toJSON","code":"rapidjson::Value xmrig::CpuConfig::toJSON(rapidjson::Document \u0026doc) const\n{\n    using namespace rapidjson;\n    auto \u0026allocator = doc.GetAllocator();\n\n    Value obj(kObjectType);\n\n    obj.AddMember(StringRef(kEnabled),      m_enabled, allocator);\n    obj.AddMember(StringRef(kHugePages),    m_hugePages, allocator);\n    obj.AddMember(StringRef(kHwAes),        m_aes == AES_AUTO ? Value(kNullType) : Value(m_aes == AES_HW), allocator);\n    obj.AddMember(StringRef(kPriority),     priority() != -1 ? Value(priority()) : Value(kNullType), allocator);\n\n#   ifdef XMRIG_FEATURE_ASM\n    obj.AddMember(StringRef(kAsm), m_assembly.toJSON(), allocator);\n#   endif\n\n#   ifdef XMRIG_ALGO_ARGON2\n    obj.AddMember(StringRef(kArgon2Impl), m_argon2Impl.toJSON(), allocator);\n#   endif\n\n    m_threads.toJSON(obj, doc);\n\n    return obj;\n}","filepath":"src/backend/cpu/CpuConfig.cpp","line_number":86,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v3.1.0"},"4849680":{"score":0.73397577,"function_name":"cryptonight_double_hash_asm","code":"inline void cryptonight_double_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MEM = xmrig::cn_select_memory\u003cALGO\u003e();\n\n    xmrig::keccak(input,        size, ctx[0]-\u003estate);\n    xmrig::keccak(input + size, size, ctx[1]-\u003estate);\n\n    cn_explode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003ememory));\n    cn_explode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[1]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[1]-\u003ememory));\n\n    cnv2_double_mainloop_sandybridge_asm(ctx[0], ctx[1]);\n\n    cn_implode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003estate));\n    cn_implode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[1]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[1]-\u003estate));\n\n    xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate), 24);\n    xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate), 24);\n\n    extra_hashes[ctx[0]-\u003estate[0] \u0026 3](ctx[0]-\u003estate, 200, output);\n    extra_hashes[ctx[1]-\u003estate[0] \u0026 3](ctx[1]-\u003estate, 200, output + 32);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":592,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4853072":{"score":0.8065664,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const void *__restrict__ input, size_t size, void *__restrict__ output, struct cryptonight_ctx *__restrict__ ctx)\n{\n    keccak((const uint8_t *) input,        size, ctx-\u003estate0, 200);\n    keccak((const uint8_t *) input + size, size, ctx-\u003estate1, 200);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    const uint8_t* l1 = ctx-\u003ememory + MEM;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate1);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n    uint64_t idx1 = h1[0] ^ h1[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n        __m128i cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n\n        if (SOFT_AES) {\n            cx0 = soft_aesenc(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = soft_aesenc(cx1, _mm_set_epi64x(ah1, al1));\n        }\n        else {\n            cx0 = _mm_aesenc_si128(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = _mm_aesenc_si128(cx1, _mm_set_epi64x(ah1, al1));\n        }\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx0));\n        _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx1, cx1));\n\n        idx0 = EXTRACT64(cx0);\n        idx1 = EXTRACT64(cx1);\n\n        bx0 = cx0;\n        bx1 = cx1;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        lo = __umul128(idx1, cl, \u0026hi);\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0] = al1;\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1] = ah1;\n\n        ah1 ^= ch;\n        al1 ^= cl;\n        idx1 = al1;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    keccakf(h0, 24);\n    keccakf(h1, 24);\n\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, static_cast\u003cchar*\u003e(output));\n    extra_hashes[ctx-\u003estate1[0] \u0026 3](ctx-\u003estate1, 200, static_cast\u003cchar*\u003e(output) + 32);\n}","filepath":"src/crypto/CryptoNight_p.h","line_number":366,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"4853680":{"score":0.6947474,"function_name":"cryptonight_hash","code":"inline void cryptonight_hash(const void *__restrict__ input, size_t size, void *__restrict__ output, cryptonight_ctx *__restrict__ ctx)\n{\n    keccak(static_cast\u003cconst uint8_t*\u003e(input), size, ctx-\u003estate0, 200);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) ctx-\u003estate0, (__m128i*) ctx-\u003ememory);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx;\n        cx = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n\n        if (SOFT_AES) {\n            cx = soft_aesenc(cx, _mm_set_epi64x(ah0, al0));\n        }\n        else {\n            cx = _mm_aesenc_si128(cx, _mm_set_epi64x(ah0, al0));\n        }\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx));\n        idx0 = EXTRACT64(cx);\n        bx0 = cx;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[1] = ah0;\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) ctx-\u003ememory, (__m128i*) ctx-\u003estate0);\n\n    keccakf(h0, 24);\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, static_cast\u003cchar*\u003e(output));\n}","filepath":"src/crypto/CryptoNight_p.h","line_number":312,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"4857152":{"score":0.81530106,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const void *__restrict__ input, size_t size, void *__restrict__ output, struct cryptonight_ctx *__restrict__ ctx)\n{\n    keccak((const uint8_t *) input,        size, ctx-\u003estate0, 200);\n    keccak((const uint8_t *) input + size, size, ctx-\u003estate1, 200);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    const uint8_t* l1 = ctx-\u003ememory + MEM;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate1);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n    uint64_t idx1 = h1[0] ^ h1[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n        __m128i cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n\n        cx0 = _mm_aesenc_si128(cx0, _mm_set_epi64x(ah0, al0));\n        cx1 = _mm_aesenc_si128(cx1, _mm_set_epi64x(ah1, al1));\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx0));\n        _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx1, cx1));\n\n        idx0 = EXTRACT64(cx0);\n        idx1 = EXTRACT64(cx1);\n\n        bx0 = cx0;\n        bx1 = cx1;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        lo = __umul128(idx1, cl, \u0026hi);\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0] = al1;\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1] = ah1;\n\n        ah1 ^= ch;\n        al1 ^= cl;\n        idx1 = al1;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    keccakf(h0, 24);\n    keccakf(h1, 24);\n\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, static_cast\u003cchar*\u003e(output));\n    extra_hashes[ctx-\u003estate1[0] \u0026 3](ctx-\u003estate1, 200, static_cast\u003cchar*\u003e(output) + 32);\n}","filepath":"src/crypto/CryptoNight_p.h","line_number":360,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.0"},"4864976":{"score":0.7509855,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, struct cryptonight_ctx *__restrict__ ctx)\n{\n    keccak(input,        (int) size, ctx-\u003estate0, 200);\n    keccak(input + size, (int) size, ctx-\u003estate1, 200);\n\n    VARIANT1_INIT(0);\n    VARIANT1_INIT(1);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    const uint8_t* l1 = ctx-\u003ememory + MEM;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate1);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n    uint64_t idx1 = h1[0] ^ h1[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0, cx1;\n\n        if (SOFT_AES) {\n            cx0 = soft_aesenc((uint32_t*)\u0026l0[idx0 \u0026 MASK], _mm_set_epi64x(ah0, al0));\n            cx1 = soft_aesenc((uint32_t*)\u0026l1[idx1 \u0026 MASK], _mm_set_epi64x(ah1, al1));\n        }\n        else {\n            cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n            cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n            cx0 = _mm_aesenc_si128(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = _mm_aesenc_si128(cx1, _mm_set_epi64x(ah1, al1));\n        }\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx0));\n        _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx1, cx1));\n        VARIANT1_1(\u0026l0[idx0 \u0026 MASK]);\n        VARIANT1_1(\u0026l1[idx1 \u0026 MASK]);\n\n        idx0 = EXTRACT64(cx0);\n        idx1 = EXTRACT64(cx1);\n\n        bx0 = cx0;\n        bx1 = cx1;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        VARIANT1_2(ah0, 0);\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n        VARIANT1_2(ah0, 0);\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        lo = __umul128(idx1, cl, \u0026hi);\n\n        al1 += hi;\n        ah1 += lo;\n\n        VARIANT1_2(ah1, 1);\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0] = al1;\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1] = ah1;\n        VARIANT1_2(ah1, 1);\n\n        ah1 ^= ch;\n        al1 ^= cl;\n        idx1 = al1;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    keccakf(h0, 24);\n    keccakf(h1, 24);\n\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, output);\n    extra_hashes[ctx-\u003estate1[0] \u0026 3](ctx-\u003estate1, 200, output + 32);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":371,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.5.1"},"4865920":{"score":0.83184355,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const void *__restrict__ input, size_t size, void *__restrict__ output, struct cryptonight_ctx *__restrict__ ctx)\n{\n    keccak((const uint8_t *) input,        (int) size, ctx-\u003estate0, 200);\n    keccak((const uint8_t *) input + size, (int) size, ctx-\u003estate1, 200);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    const uint8_t* l1 = ctx-\u003ememory + MEM;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate1);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n    uint64_t idx1 = h1[0] ^ h1[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0, cx1;\n\n        if (SOFT_AES) {\n            cx0 = soft_aesenc((uint32_t*)\u0026l0[idx0 \u0026 MASK], _mm_set_epi64x(ah0, al0));\n            cx1 = soft_aesenc((uint32_t*)\u0026l1[idx1 \u0026 MASK], _mm_set_epi64x(ah1, al1));\n        }\n        else {\n            cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n            cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n#           ifndef XMRIG_ARMv7\n            cx0 = vreinterpretq_m128i_u8(vaesmcq_u8(vaeseq_u8(cx0, vdupq_n_u8(0)))) ^ _mm_set_epi64x(ah0, al0);\n            cx1 = vreinterpretq_m128i_u8(vaesmcq_u8(vaeseq_u8(cx1, vdupq_n_u8(0)))) ^ _mm_set_epi64x(ah1, al1);\n#           endif\n        }\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx0));\n        _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx1, cx1));\n\n        idx0 = EXTRACT64(cx0);\n        idx1 = EXTRACT64(cx1);\n\n        bx0 = cx0;\n        bx1 = cx1;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        lo = __umul128(idx1, cl, \u0026hi);\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0] = al1;\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1] = ah1;\n\n        ah1 ^= ch;\n        al1 ^= cl;\n        idx1 = al1;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    keccakf(h0, 24);\n    keccakf(h1, 24);\n\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, static_cast\u003cchar*\u003e(output));\n    extra_hashes[ctx-\u003estate1[0] \u0026 3](ctx-\u003estate1, 200, static_cast\u003cchar*\u003e(output) + 32);\n}","filepath":"src/crypto/CryptoNight_arm.h","line_number":404,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.4.5"},"4871408":{"score":0.7423317,"function_name":"cryptonight_single_hash_asm","code":"inline void cryptonight_single_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MEM = xmrig::cn_select_memory\u003cALGO\u003e();\n\n    xmrig::keccak(input, size, ctx[0]-\u003estate);\n    cn_explode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003ememory));\n\n    if (ASM == xmrig::ASM_INTEL) {\n        cnv2_mainloop_ivybridge_asm(ctx[0]);\n    }\n    else {\n        cnv2_mainloop_ryzen_asm(ctx[0]);\n    }\n\n    cn_implode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003estate));\n    xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate), 24);\n    extra_hashes[ctx[0]-\u003estate[0] \u0026 3](ctx[0]-\u003estate, 200, output);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":571,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4882640":{"score":0.80396605,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_V1        = xmrig::cn_base_variant\u003cVARIANT\u003e() == xmrig::VARIANT_1;\n\n    if (IS_V1 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 64);\n        return;\n    }\n\n    xmrig::keccak(input,        size, ctx[0]-\u003estate);\n    xmrig::keccak(input + size, size, ctx[1]-\u003estate);\n\n    const uint8_t* l0 = ctx[0]-\u003ememory;\n    const uint8_t* l1 = ctx[1]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n\n    VARIANT1_INIT(0);\n    VARIANT1_INIT(1);\n    VARIANT2_INIT(0);\n    VARIANT2_INIT(1);\n    VARIANT2_SET_ROUNDING_MODE();\n\n    cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx00 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx01 = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);\n    __m128i bx10 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i bx11 = _mm_set_epi64x(h1[9] ^ h1[11], h1[8] ^ h1[10]);\n\n    uint64_t idx0 = al0;\n    uint64_t idx1 = al1;\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0, cx1;\n        if (VARIANT == xmrig::VARIANT_TUBE || !SOFT_AES) {\n            cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n            cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n        }\n\n        const __m128i ax0 = _mm_set_epi64x(ah0, al0);\n        const __m128i ax1 = _mm_set_epi64x(ah1, al1);\n        if (VARIANT == xmrig::VARIANT_TUBE) {\n            cx0 = aes_round_tweak_div(cx0, ax0);\n            cx1 = aes_round_tweak_div(cx1, ax1);\n        }\n        else if (SOFT_AES) {\n            cx0 = soft_aesenc((uint32_t*)\u0026l0[idx0 \u0026 MASK], ax0);\n            cx1 = soft_aesenc((uint32_t*)\u0026l1[idx1 \u0026 MASK], ax1);\n        }\n        else {\n            cx0 = _mm_aesenc_si128(cx0, ax0);\n            cx1 = _mm_aesenc_si128(cx1, ax1);\n        }\n\n        if (IS_V1 || (VARIANT == xmrig::VARIANT_2)) {\n            cryptonight_monero_tweak\u003cVARIANT\u003e((uint64_t*)\u0026l0[idx0 \u0026 MASK], l0, idx0 \u0026 MASK, ax0, bx00, bx01, cx0);\n            cryptonight_monero_tweak\u003cVARIANT\u003e((uint64_t*)\u0026l1[idx1 \u0026 MASK], l1, idx1 \u0026 MASK, ax1, bx10, bx11, cx1);\n        } else {\n            _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx00, cx0));\n            _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx10, cx1));\n        }\n\n        idx0 = _mm_cvtsi128_si64(cx0);\n        idx1 = _mm_cvtsi128_si64(cx1);\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        if (VARIANT == xmrig::VARIANT_2) {\n            VARIANT2_INTEGER_MATH(0, cl, cx0);\n            lo = __umul128(idx0, cl, \u0026hi);\n            VARIANT2_SHUFFLE2(l0, idx0 \u0026 MASK, ax0, bx00, bx01, hi, lo);\n        } else {\n            lo = __umul128(idx0, cl, \u0026hi);\n        }\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[0] = al0;\n\n        if (IS_V1 \u0026\u0026 (VARIANT == xmrig::VARIANT_TUBE || VARIANT == xmrig::VARIANT_RTO)) {\n            ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;\n        } else if (IS_V1) {\n            ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0;\n        } else {\n            ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n        }\n\n        al0 ^= cl;\n        ah0 ^= ch;\n        idx0 = al0;\n\n        if (ALGO == xmrig::CRYPTONIGHT_HEAVY) {\n            int64_t n = ((int64_t*)\u0026l0[idx0 \u0026 MASK])[0];\n            int32_t d = ((int32_t*)\u0026l0[idx0 \u0026 MASK])[2];\n            int64_t q = n / (d | 0x5);\n\n            ((int64_t*)\u0026l0[idx0 \u0026 MASK])[0] = n ^ q;\n\n            if (VARIANT == xmrig::VARIANT_XHV) {\n                d = ~d;\n            }\n\n            idx0 = d ^ q;\n        }\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        if (VARIANT == xmrig::VARIANT_2) {\n            VARIANT2_INTEGER_MATH(1, cl, cx1);\n            lo = __umul128(idx1, cl, \u0026hi);\n            VARIANT2_SHUFFLE2(l1, idx1 \u0026 MASK, ax1, bx10, bx11, hi, lo);\n        } else {\n            lo = __umul128(idx1, cl, \u0026hi);\n        }\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[0] = al1;\n\n        if (IS_V1 \u0026\u0026 (VARIANT == xmrig::VARIANT_TUBE || VARIANT == xmrig::VARIANT_RTO)) {\n            ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[1] = ah1 ^ tweak1_2_1 ^ al1;\n        } else if (IS_V1) {\n            ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[1] = ah1 ^ tweak1_2_1;\n        } else {\n            ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[1] = ah1;\n        }\n\n        al1 ^= cl;\n        ah1 ^= ch;\n        idx1 = al1;\n\n        if (ALGO == xmrig::CRYPTONIGHT_HEAVY) {\n            int64_t n = ((int64_t*)\u0026l1[idx1 \u0026 MASK])[0];\n            int32_t d = ((int32_t*)\u0026l1[idx1 \u0026 MASK])[2];\n            int64_t q = n / (d | 0x5);\n\n            ((int64_t*)\u0026l1[idx1 \u0026 MASK])[0] = n ^ q;\n\n            if (VARIANT == xmrig::VARIANT_XHV) {\n                d = ~d;\n            }\n\n            idx1 = d ^ q;\n        }\n\n        if (VARIANT == xmrig::VARIANT_2) {\n            bx01 = bx00;\n            bx11 = bx10;\n        }\n        bx00 = cx0;\n        bx10 = cx1;\n    }\n\n    cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    xmrig::keccakf(h0, 24);\n    xmrig::keccakf(h1, 24);\n\n    extra_hashes[ctx[0]-\u003estate[0] \u0026 3](ctx[0]-\u003estate, 200, output);\n    extra_hashes[ctx[1]-\u003estate[0] \u0026 3](ctx[1]-\u003estate, 200, output + 32);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":617,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4901600":{"score":0.7256707,"function_name":"cryptonight_penta_hash","code":"inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n\n    if (VARIANT \u003e 0 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 5);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n    CONST_INIT(ctx[4], 4);\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint8_t* l4  = ctx[4]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n    uint64_t* h4 = reinterpret_cast\u003cuint64_t*\u003e(ctx[4]-\u003estate);\n\n    __m128i ax0 = _mm_set_epi64x(h0[1] ^ h0[5], h0[0] ^ h0[4]);\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i ax1 = _mm_set_epi64x(h1[1] ^ h1[5], h1[0] ^ h1[4]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i ax2 = _mm_set_epi64x(h2[1] ^ h2[5], h2[0] ^ h2[4]);\n    __m128i bx2 = _mm_set_epi64x(h2[3] ^ h2[7], h2[2] ^ h2[6]);\n    __m128i ax3 = _mm_set_epi64x(h3[1] ^ h3[5], h3[0] ^ h3[4]);\n    __m128i bx3 = _mm_set_epi64x(h3[3] ^ h3[7], h3[2] ^ h3[6]);\n    __m128i ax4 = _mm_set_epi64x(h4[1] ^ h4[5], h4[0] ^ h4[4]);\n    __m128i bx4 = _mm_set_epi64x(h4[3] ^ h4[7], h4[2] ^ h4[6]);\n    __m128i cx0 = _mm_set_epi64x(0, 0);\n    __m128i cx1 = _mm_set_epi64x(0, 0);\n    __m128i cx2 = _mm_set_epi64x(0, 0);\n    __m128i cx3 = _mm_set_epi64x(0, 0);\n    __m128i cx4 = _mm_set_epi64x(0, 0);\n\n    uint64_t idx0, idx1, idx2, idx3, idx4;\n    idx0 = EXTRACT64(ax0);\n    idx1 = EXTRACT64(ax1);\n    idx2 = EXTRACT64(ax2);\n    idx3 = EXTRACT64(ax3);\n    idx4 = EXTRACT64(ax4);\n\n    for (size_t i = 0; i \u003c ITERATIONS / 2; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3, *ptr4;\n\n        // EVEN ROUND\n        CN_STEP1(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP1(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP2(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP2(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP3(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP3(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP4(ax0, bx0, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, bx1, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, bx2, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, bx3, cx3, l3, mc3, ptr3, idx3);\n        CN_STEP4(ax4, bx4, cx4, l4, mc4, ptr4, idx4);\n\n        // ODD ROUND\n        CN_STEP1(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP1(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP2(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP2(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP3(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP3(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP4(ax0, cx0, bx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, cx1, bx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, cx2, bx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, cx3, bx3, l3, mc3, ptr3, idx3);\n        CN_STEP4(ax4, cx4, bx4, l4, mc4, ptr4, idx4);\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":900,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4911968":{"score":0.761078,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const void *__restrict__ input, size_t size, void *__restrict__ output, struct cryptonight_ctx *__restrict__ ctx)\n{\n    keccak((const uint8_t *) input,        size, ctx-\u003estate0, 200);\n    keccak((const uint8_t *) input + size, size, ctx-\u003estate1, 200);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    const uint8_t* l1 = ctx-\u003ememory + MEM;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate1);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n    uint64_t idx1 = h1[0] ^ h1[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n        __m128i cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n\n        if (SOFT_AES) {\n            cx0 = soft_aesenc(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = soft_aesenc(cx1, _mm_set_epi64x(ah1, al1));\n        }\n        else {\n            cx0 = _mm_aesenc_si128(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = _mm_aesenc_si128(cx1, _mm_set_epi64x(ah1, al1));\n        }\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx0));\n        _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx1, cx1));\n\n        idx0 = EXTRACT64(cx0);\n        idx1 = EXTRACT64(cx1);\n\n        bx0 = cx0;\n        bx1 = cx1;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        lo = __umul128(idx1, cl, \u0026hi);\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0] = al1;\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1] = ah1;\n\n        ah1 ^= ch;\n        al1 ^= cl;\n        idx1 = al1;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    keccakf(h0, 24);\n    keccakf(h1, 24);\n\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, static_cast\u003cchar*\u003e(output));\n    extra_hashes[ctx-\u003estate1[0] \u0026 3](ctx-\u003estate1, 200, static_cast\u003cchar*\u003e(output) + 32);\n}","filepath":"src/crypto/CryptoNight_p.h","line_number":366,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.1"},"4919168":{"score":0.7894449,"function_name":"cryptonight_penta_hash","code":"inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_MONERO    = xmrig::cn_is_monero\u003cVARIANT\u003e();\n\n    if (IS_MONERO \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 5);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n    CONST_INIT(ctx[4], 4);\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint8_t* l4  = ctx[4]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n    uint64_t* h4 = reinterpret_cast\u003cuint64_t*\u003e(ctx[4]-\u003estate);\n\n    __m128i ax0 = _mm_set_epi64x(h0[1] ^ h0[5], h0[0] ^ h0[4]);\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i ax1 = _mm_set_epi64x(h1[1] ^ h1[5], h1[0] ^ h1[4]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i ax2 = _mm_set_epi64x(h2[1] ^ h2[5], h2[0] ^ h2[4]);\n    __m128i bx2 = _mm_set_epi64x(h2[3] ^ h2[7], h2[2] ^ h2[6]);\n    __m128i ax3 = _mm_set_epi64x(h3[1] ^ h3[5], h3[0] ^ h3[4]);\n    __m128i bx3 = _mm_set_epi64x(h3[3] ^ h3[7], h3[2] ^ h3[6]);\n    __m128i ax4 = _mm_set_epi64x(h4[1] ^ h4[5], h4[0] ^ h4[4]);\n    __m128i bx4 = _mm_set_epi64x(h4[3] ^ h4[7], h4[2] ^ h4[6]);\n    __m128i cx0 = _mm_set_epi64x(0, 0);\n    __m128i cx1 = _mm_set_epi64x(0, 0);\n    __m128i cx2 = _mm_set_epi64x(0, 0);\n    __m128i cx3 = _mm_set_epi64x(0, 0);\n    __m128i cx4 = _mm_set_epi64x(0, 0);\n\n    uint64_t idx0, idx1, idx2, idx3, idx4;\n    idx0 = EXTRACT64(ax0);\n    idx1 = EXTRACT64(ax1);\n    idx2 = EXTRACT64(ax2);\n    idx3 = EXTRACT64(ax3);\n    idx4 = EXTRACT64(ax4);\n\n    for (size_t i = 0; i \u003c ITERATIONS / 2; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3, *ptr4;\n\n        // EVEN ROUND\n        CN_STEP1(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP1(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP2(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP2(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP3(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP3(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP4(ax0, bx0, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, bx1, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, bx2, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, bx3, cx3, l3, mc3, ptr3, idx3);\n        CN_STEP4(ax4, bx4, cx4, l4, mc4, ptr4, idx4);\n\n        // ODD ROUND\n        CN_STEP1(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP1(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP2(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP2(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP3(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP3(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP4(ax0, cx0, bx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, cx1, bx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, cx2, bx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, cx3, bx3, l3, mc3, ptr3, idx3);\n        CN_STEP4(ax4, cx4, bx4, l4, mc4, ptr4, idx4);\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":927,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4920768":{"score":0.78348225,"function_name":"cryptonight_quad_hash","code":"inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_MONERO    = xmrig::cn_is_monero\u003cVARIANT\u003e();\n\n    if (IS_MONERO \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 4);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n\n    __m128i ax0 = _mm_set_epi64x(h0[1] ^ h0[5], h0[0] ^ h0[4]);\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i ax1 = _mm_set_epi64x(h1[1] ^ h1[5], h1[0] ^ h1[4]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i ax2 = _mm_set_epi64x(h2[1] ^ h2[5], h2[0] ^ h2[4]);\n    __m128i bx2 = _mm_set_epi64x(h2[3] ^ h2[7], h2[2] ^ h2[6]);\n    __m128i ax3 = _mm_set_epi64x(h3[1] ^ h3[5], h3[0] ^ h3[4]);\n    __m128i bx3 = _mm_set_epi64x(h3[3] ^ h3[7], h3[2] ^ h3[6]);\n    __m128i cx0 = _mm_set_epi64x(0, 0);\n    __m128i cx1 = _mm_set_epi64x(0, 0);\n    __m128i cx2 = _mm_set_epi64x(0, 0);\n    __m128i cx3 = _mm_set_epi64x(0, 0);\n\n    uint64_t idx0, idx1, idx2, idx3;\n    idx0 = EXTRACT64(ax0);\n    idx1 = EXTRACT64(ax1);\n    idx2 = EXTRACT64(ax2);\n    idx3 = EXTRACT64(ax3);\n\n    for (size_t i = 0; i \u003c ITERATIONS / 2; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3;\n\n        // EVEN ROUND\n        CN_STEP1(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP2(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP3(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP4(ax0, bx0, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, bx1, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, bx2, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, bx3, cx3, l3, mc3, ptr3, idx3);\n\n        // ODD ROUND\n        CN_STEP1(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP2(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP3(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP4(ax0, cx0, bx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, cx1, bx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, cx2, bx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, cx3, bx3, l3, mc3, ptr3, idx3);\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":820,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4946368":{"score":0.7449182,"function_name":"cryptonight_quad_hash","code":"inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_MONERO    = xmrig::cn_is_monero\u003cVARIANT\u003e();\n\n    if (IS_MONERO \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 4);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n\n    __m128i ax0 = _mm_set_epi64x(h0[1] ^ h0[5], h0[0] ^ h0[4]);\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i ax1 = _mm_set_epi64x(h1[1] ^ h1[5], h1[0] ^ h1[4]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i ax2 = _mm_set_epi64x(h2[1] ^ h2[5], h2[0] ^ h2[4]);\n    __m128i bx2 = _mm_set_epi64x(h2[3] ^ h2[7], h2[2] ^ h2[6]);\n    __m128i ax3 = _mm_set_epi64x(h3[1] ^ h3[5], h3[0] ^ h3[4]);\n    __m128i bx3 = _mm_set_epi64x(h3[3] ^ h3[7], h3[2] ^ h3[6]);\n    __m128i cx0 = _mm_set_epi64x(0, 0);\n    __m128i cx1 = _mm_set_epi64x(0, 0);\n    __m128i cx2 = _mm_set_epi64x(0, 0);\n    __m128i cx3 = _mm_set_epi64x(0, 0);\n\n    uint64_t idx0, idx1, idx2, idx3;\n    idx0 = EXTRACT64(ax0);\n    idx1 = EXTRACT64(ax1);\n    idx2 = EXTRACT64(ax2);\n    idx3 = EXTRACT64(ax3);\n\n    for (size_t i = 0; i \u003c ITERATIONS / 2; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3;\n\n        // EVEN ROUND\n        CN_STEP1(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP2(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP3(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP4(ax0, bx0, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, bx1, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, bx2, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, bx3, cx3, l3, mc3, ptr3, idx3);\n\n        // ODD ROUND\n        CN_STEP1(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP2(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP3(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP4(ax0, cx0, bx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, cx1, bx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, cx2, bx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, cx3, bx3, l3, mc3, ptr3, idx3);\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":820,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4956400":{"score":0.7738291,"function_name":"cryptonight_triple_hash","code":"inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_MONERO    = xmrig::cn_is_monero\u003cVARIANT\u003e();\n\n    if (IS_MONERO \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 3);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 3; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n\n    __m128i ax0 = _mm_set_epi64x(h0[1] ^ h0[5], h0[0] ^ h0[4]);\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i ax1 = _mm_set_epi64x(h1[1] ^ h1[5], h1[0] ^ h1[4]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i ax2 = _mm_set_epi64x(h2[1] ^ h2[5], h2[0] ^ h2[4]);\n    __m128i bx2 = _mm_set_epi64x(h2[3] ^ h2[7], h2[2] ^ h2[6]);\n    __m128i cx0 = _mm_set_epi64x(0, 0);\n    __m128i cx1 = _mm_set_epi64x(0, 0);\n    __m128i cx2 = _mm_set_epi64x(0, 0);\n\n    uint64_t idx0, idx1, idx2;\n    idx0 = EXTRACT64(ax0);\n    idx1 = EXTRACT64(ax1);\n    idx2 = EXTRACT64(ax2);\n\n    for (size_t i = 0; i \u003c ITERATIONS / 2; i++) {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2;\n\n        // EVEN ROUND\n        CN_STEP1(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx2, cx2, l2, ptr2, idx2);\n\n        CN_STEP2(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx2, cx2, l2, ptr2, idx2);\n\n        CN_STEP3(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, bx2, cx2, l2, ptr2, idx2);\n\n        CN_STEP4(ax0, bx0, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, bx1, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, bx2, cx2, l2, mc2, ptr2, idx2);\n\n        // ODD ROUND\n        CN_STEP1(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, cx2, bx2, l2, ptr2, idx2);\n\n        CN_STEP2(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, cx2, bx2, l2, ptr2, idx2);\n\n        CN_STEP3(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, cx2, bx2, l2, ptr2, idx2);\n\n        CN_STEP4(ax0, cx0, bx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, cx1, bx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, cx2, bx2, l2, mc2, ptr2, idx2);\n    }\n\n    for (size_t i = 0; i \u003c 3; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":729,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4962640":{"score":0.7642103,"function_name":"cryptonight_penta_hash","code":"inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK         = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS   = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM          = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr xmrig::Variant BASE = xmrig::cn_base_variant\u003cVARIANT\u003e();\n\n    if (BASE == xmrig::VARIANT_1 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 5);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint8_t* l4  = ctx[4]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n    uint64_t* h4 = reinterpret_cast\u003cuint64_t*\u003e(ctx[4]-\u003estate);\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n    CONST_INIT(ctx[4], 4);\n    VARIANT2_SET_ROUNDING_MODE();\n\n    uint64_t idx0, idx1, idx2, idx3, idx4;\n    idx0 = _mm_cvtsi128_si64(ax0);\n    idx1 = _mm_cvtsi128_si64(ax1);\n    idx2 = _mm_cvtsi128_si64(ax2);\n    idx3 = _mm_cvtsi128_si64(ax3);\n    idx4 = _mm_cvtsi128_si64(ax4);\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3, *ptr4;\n\n        CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx30, bx31, cx3, l3, ptr3, idx3);\n        CN_STEP1(ax4, bx40, bx41, cx4, l4, ptr4, idx4);\n\n        CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx30, bx31, cx3, l3, ptr3, idx3);\n        CN_STEP2(ax4, bx40, bx41, cx4, l4, ptr4, idx4);\n\n        CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);\n        CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);\n        CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);\n        CN_STEP3(3, ax3, bx30, bx31, cx3, l3, ptr3, idx3);\n        CN_STEP3(4, ax4, bx40, bx41, cx4, l4, ptr4, idx4);\n\n        CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(3, ax3, bx30, bx31, cx3, l3, mc3, ptr3, idx3);\n        CN_STEP4(4, ax4, bx40, bx41, cx4, l4, mc4, ptr4, idx4);\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":1053,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"4974688":{"score":0.7861324,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK         = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS   = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM          = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr xmrig::Variant BASE = xmrig::cn_base_variant\u003cVARIANT\u003e();\n\n    if (BASE == xmrig::VARIANT_1 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 64);\n        return;\n    }\n\n    xmrig::keccak(input,        size, ctx[0]-\u003estate);\n    xmrig::keccak(input + size, size, ctx[1]-\u003estate);\n\n    const uint8_t* l0 = ctx[0]-\u003ememory;\n    const uint8_t* l1 = ctx[1]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n\n    VARIANT1_INIT(0);\n    VARIANT1_INIT(1);\n    VARIANT2_INIT(0);\n    VARIANT2_INIT(1);\n    VARIANT2_SET_ROUNDING_MODE();\n\n    cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx00 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx01 = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);\n    __m128i bx10 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i bx11 = _mm_set_epi64x(h1[9] ^ h1[11], h1[8] ^ h1[10]);\n\n    uint64_t idx0 = al0;\n    uint64_t idx1 = al1;\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0, cx1;\n        if (VARIANT == xmrig::VARIANT_TUBE || !SOFT_AES) {\n            cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n            cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n        }\n\n        const __m128i ax0 = _mm_set_epi64x(ah0, al0);\n        const __m128i ax1 = _mm_set_epi64x(ah1, al1);\n        if (VARIANT == xmrig::VARIANT_TUBE) {\n            cx0 = aes_round_tweak_div(cx0, ax0);\n            cx1 = aes_round_tweak_div(cx1, ax1);\n        }\n        else if (SOFT_AES) {\n            cx0 = soft_aesenc((uint32_t*)\u0026l0[idx0 \u0026 MASK], ax0);\n            cx1 = soft_aesenc((uint32_t*)\u0026l1[idx1 \u0026 MASK], ax1);\n        }\n        else {\n            cx0 = _mm_aesenc_si128(cx0, ax0);\n            cx1 = _mm_aesenc_si128(cx1, ax1);\n        }\n\n        if (BASE == xmrig::VARIANT_1 || (BASE == xmrig::VARIANT_2)) {\n            cryptonight_monero_tweak\u003cVARIANT, BASE\u003e((uint64_t*)\u0026l0[idx0 \u0026 MASK], l0, idx0 \u0026 MASK, ax0, bx00, bx01, cx0);\n            cryptonight_monero_tweak\u003cVARIANT, BASE\u003e((uint64_t*)\u0026l1[idx1 \u0026 MASK], l1, idx1 \u0026 MASK, ax1, bx10, bx11, cx1);\n        } else {\n            _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx00, cx0));\n            _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx10, cx1));\n        }\n\n        idx0 = _mm_cvtsi128_si64(cx0);\n        idx1 = _mm_cvtsi128_si64(cx1);\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n\n        if (BASE == xmrig::VARIANT_2) {\n            VARIANT2_INTEGER_MATH(0, cl, cx0);\n            lo = __umul128(idx0, cl, \u0026hi);\n            VARIANT2_SHUFFLE2(l0, idx0 \u0026 MASK, ax0, bx00, bx01, hi, lo);\n        } else {\n            lo = __umul128(idx0, cl, \u0026hi);\n        }\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[0] = al0;\n\n        if (BASE == xmrig::VARIANT_1 \u0026\u0026 (VARIANT == xmrig::VARIANT_TUBE || VARIANT == xmrig::VARIANT_RTO)) {\n            ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;\n        } else if (BASE == xmrig::VARIANT_1) {\n            ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0;\n        } else {\n            ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n        }\n\n        al0 ^= cl;\n        ah0 ^= ch;\n        idx0 = al0;\n\n        if (ALGO == xmrig::CRYPTONIGHT_HEAVY) {\n            int64_t n = ((int64_t*)\u0026l0[idx0 \u0026 MASK])[0];\n            int32_t d = ((int32_t*)\u0026l0[idx0 \u0026 MASK])[2];\n            int64_t q = n / (d | 0x5);\n\n            ((int64_t*)\u0026l0[idx0 \u0026 MASK])[0] = n ^ q;\n\n            if (VARIANT == xmrig::VARIANT_XHV) {\n                d = ~d;\n            }\n\n            idx0 = d ^ q;\n        }\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n\n        if (BASE == xmrig::VARIANT_2) {\n            VARIANT2_INTEGER_MATH(1, cl, cx1);\n            lo = __umul128(idx1, cl, \u0026hi);\n            VARIANT2_SHUFFLE2(l1, idx1 \u0026 MASK, ax1, bx10, bx11, hi, lo);\n        } else {\n            lo = __umul128(idx1, cl, \u0026hi);\n        }\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[0] = al1;\n\n        if (BASE == xmrig::VARIANT_1 \u0026\u0026 (VARIANT == xmrig::VARIANT_TUBE || VARIANT == xmrig::VARIANT_RTO)) {\n            ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[1] = ah1 ^ tweak1_2_1 ^ al1;\n        } else if (BASE == xmrig::VARIANT_1) {\n            ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[1] = ah1 ^ tweak1_2_1;\n        } else {\n            ((uint64_t*)\u0026l1[idx1 \u0026 MASK])[1] = ah1;\n        }\n\n        al1 ^= cl;\n        ah1 ^= ch;\n        idx1 = al1;\n\n        if (ALGO == xmrig::CRYPTONIGHT_HEAVY) {\n            int64_t n = ((int64_t*)\u0026l1[idx1 \u0026 MASK])[0];\n            int32_t d = ((int32_t*)\u0026l1[idx1 \u0026 MASK])[2];\n            int64_t q = n / (d | 0x5);\n\n            ((int64_t*)\u0026l1[idx1 \u0026 MASK])[0] = n ^ q;\n\n            if (VARIANT == xmrig::VARIANT_XHV) {\n                d = ~d;\n            }\n\n            idx1 = d ^ q;\n        }\n\n        if (BASE == xmrig::VARIANT_2) {\n            bx01 = bx00;\n            bx11 = bx10;\n        }\n\n        bx00 = cx0;\n        bx10 = cx1;\n    }\n\n    cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    xmrig::keccakf(h0, 24);\n    xmrig::keccakf(h1, 24);\n\n    extra_hashes[ctx[0]-\u003estate[0] \u0026 3](ctx[0]-\u003estate, 200, output);\n    extra_hashes[ctx[1]-\u003estate[0] \u0026 3](ctx[1]-\u003estate, 200, output + 32);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":647,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"4975520":{"score":0.76767296,"function_name":"cryptonight_single_hash","code":"inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_V1        = xmrig::cn_base_variant\u003cVARIANT\u003e() == xmrig::VARIANT_1;\n\n    if (IS_V1 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32);\n        return;\n    }\n\n    xmrig::keccak(input, size, ctx[0]-\u003estate);\n\n    cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) ctx[0]-\u003estate, (__m128i*) ctx[0]-\u003ememory);\n\n    const uint8_t* l0 = ctx[0]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n\n    VARIANT1_INIT(0);\n    VARIANT2_INIT(0);\n    VARIANT2_SET_ROUNDING_MODE();\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);\n\n    uint64_t idx0 = al0;\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx;\n        if (VARIANT == xmrig::VARIANT_TUBE || !SOFT_AES) {\n            cx = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n        }\n\n        const __m128i ax0 = _mm_set_epi64x(ah0, al0);\n        if (VARIANT == xmrig::VARIANT_TUBE) {\n            cx = aes_round_tweak_div(cx, ax0);\n        }\n        else if (SOFT_AES) {\n            cx = soft_aesenc((uint32_t*)\u0026l0[idx0 \u0026 MASK], ax0);\n        }\n        else {  \n            cx = _mm_aesenc_si128(cx, ax0);\n        }\n\n        if (IS_V1 || VARIANT == xmrig::VARIANT_2) {\n            cryptonight_monero_tweak\u003cVARIANT\u003e((uint64_t*)\u0026l0[idx0 \u0026 MASK], l0, idx0 \u0026 MASK, ax0, bx0, bx1, cx);\n        } else {\n            _mm_store_si128((__m128i *)\u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx));\n        }\n\n        idx0 = _mm_cvtsi128_si64(cx);\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        if (VARIANT == xmrig::VARIANT_2) {\n            VARIANT2_INTEGER_MATH(0, cl, cx);\n            lo = __umul128(idx0, cl, \u0026hi);\n            VARIANT2_SHUFFLE2(l0, idx0 \u0026 MASK, ax0, bx0, bx1, hi, lo);\n        }\n        else {\n            lo = __umul128(idx0, cl, \u0026hi);\n        }\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[0] = al0;\n\n        if (IS_V1 \u0026\u0026 (VARIANT == xmrig::VARIANT_TUBE || VARIANT == xmrig::VARIANT_RTO)) {\n            ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;\n        } else if (IS_V1) {\n            ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0;\n        } else {\n            ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[1] = ah0;\n        }\n\n        al0 ^= cl;\n        ah0 ^= ch;\n        idx0 = al0;\n\n        if (ALGO == xmrig::CRYPTONIGHT_HEAVY) {\n            int64_t n = ((int64_t*)\u0026l0[idx0 \u0026 MASK])[0];\n            int32_t d = ((int32_t*)\u0026l0[idx0 \u0026 MASK])[2];\n            int64_t q = n / (d | 0x5);\n\n            ((int64_t*)\u0026l0[idx0 \u0026 MASK])[0] = n ^ q;\n\n            if (VARIANT == xmrig::VARIANT_XHV) {\n                d = ~d;\n            }\n\n            idx0 = d ^ q;\n        }\n        if (VARIANT == xmrig::VARIANT_2) {\n            bx1 = bx0;\n        }\n        bx0 = cx;\n    }\n\n    cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) ctx[0]-\u003ememory, (__m128i*) ctx[0]-\u003estate);\n\n    xmrig::keccakf(h0, 24);\n    extra_hashes[ctx[0]-\u003estate[0] \u0026 3](ctx[0]-\u003estate, 200, output);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":454,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4975952":{"score":0.7420336,"function_name":"cryptonight_quad_hash","code":"inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n\n    if (VARIANT \u003e 0 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 4);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n\n    __m128i ax0 = _mm_set_epi64x(h0[1] ^ h0[5], h0[0] ^ h0[4]);\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i ax1 = _mm_set_epi64x(h1[1] ^ h1[5], h1[0] ^ h1[4]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i ax2 = _mm_set_epi64x(h2[1] ^ h2[5], h2[0] ^ h2[4]);\n    __m128i bx2 = _mm_set_epi64x(h2[3] ^ h2[7], h2[2] ^ h2[6]);\n    __m128i ax3 = _mm_set_epi64x(h3[1] ^ h3[5], h3[0] ^ h3[4]);\n    __m128i bx3 = _mm_set_epi64x(h3[3] ^ h3[7], h3[2] ^ h3[6]);\n    __m128i cx0 = _mm_set_epi64x(0, 0);\n    __m128i cx1 = _mm_set_epi64x(0, 0);\n    __m128i cx2 = _mm_set_epi64x(0, 0);\n    __m128i cx3 = _mm_set_epi64x(0, 0);\n\n    uint64_t idx0, idx1, idx2, idx3;\n    idx0 = EXTRACT64(ax0);\n    idx1 = EXTRACT64(ax1);\n    idx2 = EXTRACT64(ax2);\n    idx3 = EXTRACT64(ax3);\n\n    for (size_t i = 0; i \u003c ITERATIONS / 2; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3;\n\n        // EVEN ROUND\n        CN_STEP1(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP2(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP3(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, bx3, cx3, l3, ptr3, idx3);\n\n        CN_STEP4(ax0, bx0, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, bx1, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, bx2, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, bx3, cx3, l3, mc3, ptr3, idx3);\n\n        // ODD ROUND\n        CN_STEP1(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP2(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP3(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, cx3, bx3, l3, ptr3, idx3);\n\n        CN_STEP4(ax0, cx0, bx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, cx1, bx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, cx2, bx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, cx3, bx3, l3, mc3, ptr3, idx3);\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":794,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4977392":{"score":0.6830349,"function_name":"cryptonight_quad_hash","code":"inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_V1        = xmrig::cn_base_variant\u003cVARIANT\u003e() == xmrig::VARIANT_1;;\n\n    if (IS_V1 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 4);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n    VARIANT2_SET_ROUNDING_MODE();\n\n    uint64_t idx0, idx1, idx2, idx3;\n    idx0 = _mm_cvtsi128_si64(ax0);\n    idx1 = _mm_cvtsi128_si64(ax1);\n    idx2 = _mm_cvtsi128_si64(ax2);\n    idx3 = _mm_cvtsi128_si64(ax3);\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3;\n\n        CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx30, bx31, cx3, l3, ptr3, idx3);\n\n        CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx30, bx31, cx3, l3, ptr3, idx3);\n\n        CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);\n        CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);\n        CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);\n        CN_STEP3(3, ax3, bx30, bx31, cx3, l3, ptr3, idx3);\n\n        CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(3, ax3, bx30, bx31, cx3, l3, mc3, ptr3, idx3);\n    }\n\n    for (size_t i = 0; i \u003c 4; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":947,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4983568":{"score":0.72093666,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const void *__restrict__ input, size_t size, void *__restrict__ output, struct cryptonight_ctx *__restrict__ ctx)\n{\n    keccak((const uint8_t *) input,        (int) size, ctx-\u003estate0, 200);\n    keccak((const uint8_t *) input + size, (int) size, ctx-\u003estate1, 200);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    const uint8_t* l1 = ctx-\u003ememory + MEM;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate1);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n    uint64_t idx1 = h1[0] ^ h1[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n        __m128i cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n\n        if (SOFT_AES) {\n            cx0 = soft_aesenc(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = soft_aesenc(cx1, _mm_set_epi64x(ah1, al1));\n        }\n        else {\n            cx0 = _mm_aesenc_si128(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = _mm_aesenc_si128(cx1, _mm_set_epi64x(ah1, al1));\n        }\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx0));\n        _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx1, cx1));\n\n        idx0 = EXTRACT64(cx0);\n        idx1 = EXTRACT64(cx1);\n\n        bx0 = cx0;\n        bx1 = cx1;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        lo = __umul128(idx1, cl, \u0026hi);\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0] = al1;\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1] = ah1;\n\n        ah1 ^= ch;\n        al1 ^= cl;\n        idx1 = al1;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    keccakf(h0, 24);\n    keccakf(h1, 24);\n\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, static_cast\u003cchar*\u003e(output));\n    extra_hashes[ctx-\u003estate1[0] \u0026 3](ctx-\u003estate1, 200, static_cast\u003cchar*\u003e(output) + 32);\n}","filepath":"src/crypto/CryptoNight_p.h","line_number":366,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"4985280":{"score":0.7680253,"function_name":"cryptonight_single_hash_asm","code":"inline void cryptonight_single_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MEM = xmrig::cn_select_memory\u003cALGO\u003e();\n\n    xmrig::keccak(input, size, ctx[0]-\u003estate);\n    cn_explode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003ememory));\n\n    if (VARIANT == xmrig::VARIANT_2) {\n        if (ASM == xmrig::ASM_INTEL) {\n            cnv2_mainloop_ivybridge_asm(ctx[0]);\n        }\n        else if (ASM == xmrig::ASM_RYZEN) {\n            cnv2_mainloop_ryzen_asm(ctx[0]);\n        }\n        else {\n            cnv2_mainloop_bulldozer_asm(ctx[0]);\n        }\n    }\n    else if (VARIANT == xmrig::VARIANT_HALF) {\n        if (ASM == xmrig::ASM_INTEL) {\n            cn_half_mainloop_ivybridge_asm(ctx[0]);\n        }\n        else if (ASM == xmrig::ASM_RYZEN) {\n            cn_half_mainloop_ryzen_asm(ctx[0]);\n        }\n        else {\n            cn_half_mainloop_bulldozer_asm(ctx[0]);\n        }\n    }\n\n    cn_implode_scratchpad\u003cALGO, MEM, false\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[0]-\u003estate));\n    xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate), 24);\n    extra_hashes[ctx[0]-\u003estate[0] \u0026 3](ctx[0]-\u003estate, 200, output);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":580,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"4990768":{"score":0.7901918,"function_name":"cryptonight_penta_hash","code":"inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK       = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM        = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr bool IS_MONERO    = xmrig::cn_is_monero\u003cVARIANT\u003e();\n\n    if (IS_MONERO \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32 * 5);\n        return;\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        xmrig::keccak(input + size * i, size, ctx[i]-\u003estate);\n        cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory));\n    }\n\n    CONST_INIT(ctx[0], 0);\n    CONST_INIT(ctx[1], 1);\n    CONST_INIT(ctx[2], 2);\n    CONST_INIT(ctx[3], 3);\n    CONST_INIT(ctx[4], 4);\n\n    uint8_t* l0  = ctx[0]-\u003ememory;\n    uint8_t* l1  = ctx[1]-\u003ememory;\n    uint8_t* l2  = ctx[2]-\u003ememory;\n    uint8_t* l3  = ctx[3]-\u003ememory;\n    uint8_t* l4  = ctx[4]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx[1]-\u003estate);\n    uint64_t* h2 = reinterpret_cast\u003cuint64_t*\u003e(ctx[2]-\u003estate);\n    uint64_t* h3 = reinterpret_cast\u003cuint64_t*\u003e(ctx[3]-\u003estate);\n    uint64_t* h4 = reinterpret_cast\u003cuint64_t*\u003e(ctx[4]-\u003estate);\n\n    __m128i ax0 = _mm_set_epi64x(h0[1] ^ h0[5], h0[0] ^ h0[4]);\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i ax1 = _mm_set_epi64x(h1[1] ^ h1[5], h1[0] ^ h1[4]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n    __m128i ax2 = _mm_set_epi64x(h2[1] ^ h2[5], h2[0] ^ h2[4]);\n    __m128i bx2 = _mm_set_epi64x(h2[3] ^ h2[7], h2[2] ^ h2[6]);\n    __m128i ax3 = _mm_set_epi64x(h3[1] ^ h3[5], h3[0] ^ h3[4]);\n    __m128i bx3 = _mm_set_epi64x(h3[3] ^ h3[7], h3[2] ^ h3[6]);\n    __m128i ax4 = _mm_set_epi64x(h4[1] ^ h4[5], h4[0] ^ h4[4]);\n    __m128i bx4 = _mm_set_epi64x(h4[3] ^ h4[7], h4[2] ^ h4[6]);\n    __m128i cx0 = _mm_set_epi64x(0, 0);\n    __m128i cx1 = _mm_set_epi64x(0, 0);\n    __m128i cx2 = _mm_set_epi64x(0, 0);\n    __m128i cx3 = _mm_set_epi64x(0, 0);\n    __m128i cx4 = _mm_set_epi64x(0, 0);\n\n    uint64_t idx0, idx1, idx2, idx3, idx4;\n    idx0 = EXTRACT64(ax0);\n    idx1 = EXTRACT64(ax1);\n    idx2 = EXTRACT64(ax2);\n    idx3 = EXTRACT64(ax3);\n    idx4 = EXTRACT64(ax4);\n\n    for (size_t i = 0; i \u003c ITERATIONS / 2; i++)\n    {\n        uint64_t hi, lo;\n        __m128i *ptr0, *ptr1, *ptr2, *ptr3, *ptr4;\n\n        // EVEN ROUND\n        CN_STEP1(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP1(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP2(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP2(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP3(ax0, bx0, cx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, bx1, cx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, bx2, cx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, bx3, cx3, l3, ptr3, idx3);\n        CN_STEP3(ax4, bx4, cx4, l4, ptr4, idx4);\n\n        CN_STEP4(ax0, bx0, cx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, bx1, cx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, bx2, cx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, bx3, cx3, l3, mc3, ptr3, idx3);\n        CN_STEP4(ax4, bx4, cx4, l4, mc4, ptr4, idx4);\n\n        // ODD ROUND\n        CN_STEP1(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP1(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP1(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP1(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP1(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP2(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP2(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP2(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP2(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP2(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP3(ax0, cx0, bx0, l0, ptr0, idx0);\n        CN_STEP3(ax1, cx1, bx1, l1, ptr1, idx1);\n        CN_STEP3(ax2, cx2, bx2, l2, ptr2, idx2);\n        CN_STEP3(ax3, cx3, bx3, l3, ptr3, idx3);\n        CN_STEP3(ax4, cx4, bx4, l4, ptr4, idx4);\n\n        CN_STEP4(ax0, cx0, bx0, l0, mc0, ptr0, idx0);\n        CN_STEP4(ax1, cx1, bx1, l1, mc1, ptr1, idx1);\n        CN_STEP4(ax2, cx2, bx2, l2, mc2, ptr2, idx2);\n        CN_STEP4(ax3, cx3, bx3, l3, mc3, ptr3, idx3);\n        CN_STEP4(ax4, cx4, bx4, l4, mc4, ptr4, idx4);\n    }\n\n    for (size_t i = 0; i \u003c 5; i++) {\n        cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e(reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003ememory), reinterpret_cast\u003c__m128i*\u003e(ctx[i]-\u003estate));\n        xmrig::keccakf(reinterpret_cast\u003cuint64_t*\u003e(ctx[i]-\u003estate), 24);\n        extra_hashes[ctx[i]-\u003estate[0] \u0026 3](ctx[i]-\u003estate, 200, output + 32 * i);\n    }\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":927,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4993440":{"score":0.7872489,"function_name":"cryptonight_single_hash","code":"inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx)\n{\n    constexpr size_t MASK         = xmrig::cn_select_mask\u003cALGO\u003e();\n    constexpr size_t ITERATIONS   = xmrig::cn_select_iter\u003cALGO, VARIANT\u003e();\n    constexpr size_t MEM          = xmrig::cn_select_memory\u003cALGO\u003e();\n    constexpr xmrig::Variant BASE = xmrig::cn_base_variant\u003cVARIANT\u003e();\n\n    if (BASE == xmrig::VARIANT_1 \u0026\u0026 size \u003c 43) {\n        memset(output, 0, 32);\n        return;\n    }\n\n    xmrig::keccak(input, size, ctx[0]-\u003estate);\n\n    cn_explode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) ctx[0]-\u003estate, (__m128i*) ctx[0]-\u003ememory);\n\n    const uint8_t* l0 = ctx[0]-\u003ememory;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx[0]-\u003estate);\n\n    VARIANT1_INIT(0);\n    VARIANT2_INIT(0);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);\n\n    uint64_t idx0 = al0;\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx;\n        if (VARIANT == xmrig::VARIANT_TUBE || !SOFT_AES) {\n            cx = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n        }\n\n        const __m128i ax0 = _mm_set_epi64x(ah0, al0);\n        if (VARIANT == xmrig::VARIANT_TUBE) {\n            cx = aes_round_tweak_div(cx, ax0);\n        }\n        else if (SOFT_AES) {\n            cx = soft_aesenc((uint32_t*)\u0026l0[idx0 \u0026 MASK], ax0);\n        }\n        else {\n            cx = _mm_aesenc_si128(cx, ax0);\n        }\n\n        if (BASE == xmrig::VARIANT_1 || BASE == xmrig::VARIANT_2) {\n            cryptonight_monero_tweak\u003cVARIANT, BASE\u003e(l0, idx0 \u0026 MASK, ax0, bx0, bx1, cx);\n        } else {\n            _mm_store_si128((__m128i *)\u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx));\n        }\n\n        idx0 = _mm_cvtsi128_si64(cx);\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n\n        if (BASE == xmrig::VARIANT_2) {\n            VARIANT2_INTEGER_MATH(0, cl, cx);\n            lo = __umul128(idx0, cl, \u0026hi);\n            VARIANT2_SHUFFLE2(l0, idx0 \u0026 MASK, ax0, bx0, bx1, hi, lo);\n        }\n        else {\n            lo = __umul128(idx0, cl, \u0026hi);\n        }\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[0] = al0;\n\n        if (BASE == xmrig::VARIANT_1 \u0026\u0026 (VARIANT == xmrig::VARIANT_TUBE || VARIANT == xmrig::VARIANT_RTO)) {\n            ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;\n        } else if (BASE == xmrig::VARIANT_1) {\n            ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[1] = ah0 ^ tweak1_2_0;\n        } else {\n            ((uint64_t*)\u0026l0[idx0 \u0026 MASK])[1] = ah0;\n        }\n\n        al0 ^= cl;\n        ah0 ^= ch;\n        idx0 = al0;\n\n        if (ALGO == xmrig::CRYPTONIGHT_HEAVY) {\n            const int64x2_t x = vld1q_s64(reinterpret_cast\u003cconst int64_t *\u003e(\u0026l0[idx0 \u0026 MASK]));\n            const int64_t n   = vgetq_lane_s64(x, 0);\n            const int32_t d   = vgetq_lane_s32(x, 2);\n            const int64_t q   = n / (d | 0x5);\n\n            ((int64_t*)\u0026l0[idx0 \u0026 MASK])[0] = n ^ q;\n\n            if (VARIANT == xmrig::VARIANT_XHV) {\n                idx0 = (~d) ^ q;\n            }\n            else {\n                idx0 = d ^ q;\n            }\n        }\n\n        if (BASE == xmrig::VARIANT_2) {\n            bx1 = bx0;\n        }\n\n        bx0 = cx;\n    }\n\n    cn_implode_scratchpad\u003cALGO, MEM, SOFT_AES\u003e((__m128i*) ctx[0]-\u003ememory, (__m128i*) ctx[0]-\u003estate);\n\n    xmrig::keccakf(h0, 24);\n    extra_hashes[ctx[0]-\u003estate[0] \u0026 3](ctx[0]-\u003estate, 200, output);\n}","filepath":"src/crypto/CryptoNight_arm.h","line_number":430,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"4997888":{"score":0.8043388,"function_name":"cryptonight_double_hash","code":"inline void cryptonight_double_hash(const void *__restrict__ input, size_t size, void *__restrict__ output, struct cryptonight_ctx *__restrict__ ctx)\n{\n    keccak((const uint8_t *) input,        (int) size, ctx-\u003estate0, 200);\n    keccak((const uint8_t *) input + size, (int) size, ctx-\u003estate1, 200);\n\n    const uint8_t* l0 = ctx-\u003ememory;\n    const uint8_t* l1 = ctx-\u003ememory + MEM;\n    uint64_t* h0 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate0);\n    uint64_t* h1 = reinterpret_cast\u003cuint64_t*\u003e(ctx-\u003estate1);\n\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h0, (__m128i*) l0);\n    cn_explode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) h1, (__m128i*) l1);\n\n    uint64_t al0 = h0[0] ^ h0[4];\n    uint64_t al1 = h1[0] ^ h1[4];\n    uint64_t ah0 = h0[1] ^ h0[5];\n    uint64_t ah1 = h1[1] ^ h1[5];\n\n    __m128i bx0 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);\n    __m128i bx1 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);\n\n    uint64_t idx0 = h0[0] ^ h0[4];\n    uint64_t idx1 = h1[0] ^ h1[4];\n\n    for (size_t i = 0; i \u003c ITERATIONS; i++) {\n        __m128i cx0, cx1;\n\n        if (SOFT_AES) {\n            cx0 = soft_aesenc((uint32_t*)\u0026l0[idx0 \u0026 MASK], _mm_set_epi64x(ah0, al0));\n            cx1 = soft_aesenc((uint32_t*)\u0026l1[idx1 \u0026 MASK], _mm_set_epi64x(ah1, al1));\n        }\n        else {\n            cx0 = _mm_load_si128((__m128i *) \u0026l0[idx0 \u0026 MASK]);\n            cx1 = _mm_load_si128((__m128i *) \u0026l1[idx1 \u0026 MASK]);\n            cx0 = _mm_aesenc_si128(cx0, _mm_set_epi64x(ah0, al0));\n            cx1 = _mm_aesenc_si128(cx1, _mm_set_epi64x(ah1, al1));\n        }\n\n        _mm_store_si128((__m128i *) \u0026l0[idx0 \u0026 MASK], _mm_xor_si128(bx0, cx0));\n        _mm_store_si128((__m128i *) \u0026l1[idx1 \u0026 MASK], _mm_xor_si128(bx1, cx1));\n\n        idx0 = EXTRACT64(cx0);\n        idx1 = EXTRACT64(cx1);\n\n        bx0 = cx0;\n        bx1 = cx1;\n\n        uint64_t hi, lo, cl, ch;\n        cl = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1];\n        lo = __umul128(idx0, cl, \u0026hi);\n\n        al0 += hi;\n        ah0 += lo;\n\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[0] = al0;\n        ((uint64_t*) \u0026l0[idx0 \u0026 MASK])[1] = ah0;\n\n        ah0 ^= ch;\n        al0 ^= cl;\n        idx0 = al0;\n\n        cl = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0];\n        ch = ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1];\n        lo = __umul128(idx1, cl, \u0026hi);\n\n        al1 += hi;\n        ah1 += lo;\n\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[0] = al1;\n        ((uint64_t*) \u0026l1[idx1 \u0026 MASK])[1] = ah1;\n\n        ah1 ^= ch;\n        al1 ^= cl;\n        idx1 = al1;\n    }\n\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l0, (__m128i*) h0);\n    cn_implode_scratchpad\u003cMEM, SOFT_AES\u003e((__m128i*) l1, (__m128i*) h1);\n\n    keccakf(h0, 24);\n    keccakf(h1, 24);\n\n    extra_hashes[ctx-\u003estate0[0] \u0026 3](ctx-\u003estate0, 200, static_cast\u003cchar*\u003e(output));\n    extra_hashes[ctx-\u003estate1[0] \u0026 3](ctx-\u003estate1, 200, static_cast\u003cchar*\u003e(output) + 32);\n}","filepath":"src/crypto/CryptoNight_x86.h","line_number":364,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.4.5"},"4999296":{"score":0.6041907,"function_name":"xmrig::Hashrate::calc","code":"double xmrig::Hashrate::calc(size_t threadId, size_t ms) const\n{\n    assert(threadId \u003c m_threads);\n    if (threadId \u003e= m_threads) {\n        return nan(\"\");\n    }\n\n    uint64_t earliestHashCount = 0;\n    uint64_t earliestStamp     = 0;\n    uint64_t lastestStamp      = 0;\n    uint64_t lastestHashCnt    = 0;\n    bool haveFullSet           = false;\n\n    for (size_t i = 1; i \u003c kBucketSize; i++) {\n        const size_t idx = (m_top[threadId] - i) \u0026 kBucketMask;\n\n        if (m_timestamps[threadId][idx] == 0) {\n            break;\n        }\n\n        if (lastestStamp == 0) {\n            lastestStamp = m_timestamps[threadId][idx];\n            lastestHashCnt = m_counts[threadId][idx];\n        }\n\n        if (xmrig::Chrono::highResolutionMSecs() - m_timestamps[threadId][idx] \u003e ms) {\n            haveFullSet = true;\n            break;\n        }\n\n        earliestStamp = m_timestamps[threadId][idx];\n        earliestHashCount = m_counts[threadId][idx];\n    }\n\n    if (!haveFullSet || earliestStamp == 0 || lastestStamp == 0) {\n        return nan(\"\");\n    }\n\n    if (lastestStamp - earliestStamp == 0) {\n        return nan(\"\");\n    }\n\n    const auto hashes = static_cast\u003cdouble\u003e(lastestHashCnt - earliestHashCount);\n    const auto time   = static_cast\u003cdouble\u003e(lastestStamp - earliestStamp) / 1000.0;\n\n    return hashes / time;\n}","filepath":"src/backend/common/Hashrate.cpp","line_number":94,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.0.1-beta"},"5000096":{"score":0.75090885,"function_name":"xmrig::Hashrate::calc","code":"double xmrig::Hashrate::calc(size_t ms) const\n{\n    double result = 0.0;\n    double data;\n\n    for (size_t i = 0; i \u003c m_threads; ++i) {\n        data = calc(i, ms);\n        if (std::isnormal(data)) {\n            result += data;\n        }\n    }\n\n    return result;\n}","filepath":"src/backend/common/Hashrate.cpp","line_number":78,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.0.1-beta"},"5000352":{"score":0.6122649,"function_name":"Hashrate::print","code":"void Hashrate::print()\n{\n    char num1[8] = { 0 };\n    char num2[8] = { 0 };\n    char num3[8] = { 0 };\n    char num4[8] = { 0 };\n\n    LOG_INFO(m_controller-\u003econfig()-\u003eisColors() ? \"\\x1B[01;37mspeed\\x1B[0m 2.5s/60s/15m \\x1B[01;36m%s \\x1B[22;36m%s %s \\x1B[01;36mH/s\\x1B[0m max: \\x1B[01;36m%s H/s\" : \"speed 2.5s/60s/15m %s %s %s H/s max: %s H/s\",\n             format(calc(ShortInterval),  num1, sizeof(num1)),\n             format(calc(MediumInterval), num2, sizeof(num2)),\n             format(calc(LargeInterval),  num3, sizeof(num3)),\n             format(m_highest,            num4, sizeof(num4))\n             );\n}","filepath":"src/workers/Hashrate.cpp","line_number":152,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"5001472":{"score":0.80655074,"function_name":"format","code":"inline static const char *format(double h, char *buf, size_t size)\n{\n    if (std::isnormal(h)) {\n        snprintf(buf, size, \"%03.1f\", h);\n        return buf;\n    }\n\n    return \"n/a\";\n}","filepath":"src/backend/common/Hashrate.cpp","line_number":38,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v4.0.1-beta"},"5003968":{"score":0.7219639,"function_name":"MultiWorker\u003cN\u003e::verify","code":"bool MultiWorker\u003cN\u003e::verify(xmrig::Variant variant, const uint8_t *referenceValue)\n{\n\n    xmrig::CpuThread::cn_hash_fun func = m_thread-\u003efn(variant);\n    if (!func) {\n        return false;\n    }\n\n    func(test_input, 76, m_hash, m_ctx, 0);\n    return memcmp(m_hash, referenceValue, sizeof m_hash) == 0;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":207,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"5004064":{"score":0.7270111,"function_name":"MultiWorker\u003cN\u003e::selfTest","code":"bool MultiWorker\u003cN\u003e::selfTest()\n{\n    using namespace xmrig;\n\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT) {\n        const bool rc = verify(VARIANT_0,      test_output_v0)   \u0026\u0026\n                        verify(VARIANT_1,      test_output_v1)   \u0026\u0026\n                        verify(VARIANT_2,      test_output_v2)   \u0026\u0026\n                        verify(VARIANT_XTL,    test_output_xtl)  \u0026\u0026\n                        verify(VARIANT_MSR,    test_output_msr)  \u0026\u0026\n                        verify(VARIANT_XAO,    test_output_xao)  \u0026\u0026\n                        verify(VARIANT_RTO,    test_output_rto)  \u0026\u0026\n                        verify(VARIANT_HALF,   test_output_half) \u0026\u0026\n                        verify2(VARIANT_WOW,   test_output_wow)  \u0026\u0026\n                        verify2(VARIANT_4,     test_output_r)    \u0026\u0026\n                        verify(VARIANT_RWZ,    test_output_rwz)  \u0026\u0026\n                        verify(VARIANT_ZLS,    test_output_zls)  \u0026\u0026\n                        verify(VARIANT_DOUBLE, test_output_double);\n\n#       ifdef XMRIG_ALGO_CN_GPU\n        if (!rc || N \u003e 1) {\n            return rc;\n        }\n\n        return verify(VARIANT_GPU, test_output_gpu);\n#       else\n        return rc;\n#       endif\n    }\n\n#   ifdef XMRIG_ALGO_CN_LITE\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_LITE) {\n        return verify(VARIANT_0,    test_output_v0_lite) \u0026\u0026\n               verify(VARIANT_1,    test_output_v1_lite);\n    }\n#   endif\n\n#   ifdef XMRIG_ALGO_CN_HEAVY\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_HEAVY) {\n        return verify(VARIANT_0,    test_output_v0_heavy)  \u0026\u0026\n               verify(VARIANT_XHV,  test_output_xhv_heavy) \u0026\u0026\n               verify(VARIANT_TUBE, test_output_tube_heavy);\n    }\n#   endif\n\n#   ifdef XMRIG_ALGO_CN_PICO\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_PICO) {\n        return verify(VARIANT_TRTL, test_output_pico_trtl);\n    }\n#   endif\n\n#   ifdef XMRIG_ALGO_RANDOMX\n    if (m_thread-\u003ealgorithm() == RANDOM_X) {\n        return true;\n    }\n#   endif\n\n    return false;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"5006176":{"score":0.758613,"function_name":"MultiWorker\u003cN\u003e::consumeJob","code":"void MultiWorker\u003cN\u003e::consumeJob()\n{\n    xmrig::Job job = Workers::job();\n    m_sequence = Workers::sequence();\n    if (m_state.job == job) {\n        return;\n    }\n\n    save(job);\n\n    if (resume(job)) {\n        return;\n    }\n\n    m_state.job = job;\n\n    const size_t size = m_state.job.size();\n    memcpy(m_state.blob, m_state.job.blob(), m_state.job.size());\n\n    if (N \u003e 1) {\n        for (size_t i = 1; i \u003c N; ++i) {\n            memcpy(m_state.blob + (i * size), m_state.blob, size);\n        }\n    }\n\n    for (size_t i = 0; i \u003c N; ++i) {\n        if (m_state.job.isNicehash()) {\n            *nonce(i) = (*nonce(i) \u0026 0xff000000U) + (0xffffffU / m_totalWays * (m_offset + i));\n        }\n        else {\n           *nonce(i) = 0xffffffffU / m_totalWays * (m_offset + i);\n        }\n    }\n}","filepath":"src/workers/MultiWorker.cpp","line_number":268,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"5006880":{"score":0.69570583,"function_name":"MultiWorker\u003cN\u003e::start","code":"void MultiWorker\u003cN\u003e::start()\n{\n    while (Workers::sequence() \u003e 0) {\n        if (Workers::isPaused()) {\n            do {\n                std::this_thread::sleep_for(std::chrono::milliseconds(200));\n            }\n            while (Workers::isPaused());\n\n            if (Workers::sequence() == 0) {\n                break;\n            }\n\n            consumeJob();\n        }\n\n        while (!Workers::isOutdated(m_sequence)) {\n            if ((m_count \u0026 0x7) == 0) {\n                storeStats();\n            }\n\n            const xmrig::Variant v = m_state.job.algorithm().variant();\n\n#           ifdef XMRIG_ALGO_RANDOMX\n            if (v == xmrig::VARIANT_RX_WOW) {\n                allocateRandomX_VM();\n                Workers::updateDataset(m_state.job.seedHash(), m_totalWays);\n                randomx_calculate_hash(m_rx_vm, m_state.blob, m_state.job.size(), m_hash);\n            }\n            else\n#           endif\n            {\n                m_thread-\u003efn(v)(m_state.blob, m_state.job.size(), m_hash, m_ctx, m_state.job.height());\n            }\n\n            for (size_t i = 0; i \u003c N; ++i) {\n                if (*reinterpret_cast\u003cuint64_t*\u003e(m_hash + (i * 32) + 24) \u003c m_state.job.target()) {\n                    Workers::submit(xmrig::JobResult(m_state.job.poolId(), m_state.job.id(), m_state.job.clientId(), *nonce(i), m_hash + (i * 32), m_state.job.diff(), m_state.job.algorithm()));\n                }\n\n                *nonce(i) += 1;\n            }\n\n            m_count += N;\n\n            std::this_thread::yield();\n        }\n\n        consumeJob();\n    }\n}","filepath":"src/workers/MultiWorker.cpp","line_number":141,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"5009440":{"score":0.7321896,"function_name":"MultiWorker\u003cN\u003e::verify","code":"bool MultiWorker\u003cN\u003e::verify(xmrig::Variant variant, const uint8_t *referenceValue)\n{\n\n    xmrig::CpuThread::cn_hash_fun func = m_thread-\u003efn(variant);\n    if (!func) {\n        return false;\n    }\n\n    func(test_input, 76, m_hash, m_ctx);\n    return memcmp(m_hash, referenceValue, sizeof m_hash) == 0;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":157,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.11.0"},"5009536":{"score":0.77324116,"function_name":"MultiWorker\u003cN\u003e::selfTest","code":"bool MultiWorker\u003cN\u003e::selfTest()\n{\n    using namespace xmrig;\n\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT) {\n        const bool rc = verify(VARIANT_0,    test_output_v0)  \u0026\u0026\n                        verify(VARIANT_1,    test_output_v1)  \u0026\u0026\n                        verify(VARIANT_2,    test_output_v2)  \u0026\u0026\n                        verify(VARIANT_XTL,  test_output_xtl) \u0026\u0026\n                        verify(VARIANT_MSR,  test_output_msr) \u0026\u0026\n                        verify(VARIANT_XAO,  test_output_xao) \u0026\u0026\n                        verify(VARIANT_RTO,  test_output_rto) \u0026\u0026\n                        verify(VARIANT_HALF, test_output_half);\n\n#       ifndef XMRIG_NO_CN_GPU\n        if (!rc || N \u003e 1) {\n            return rc;\n        }\n\n        return verify(VARIANT_GPU, test_output_gpu);\n#       else\n        return rc;\n#       endif\n    }\n\n#   ifndef XMRIG_NO_AEON\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_LITE) {\n        return verify(VARIANT_0,    test_output_v0_lite) \u0026\u0026\n               verify(VARIANT_1,    test_output_v1_lite);\n    }\n#   endif\n\n#   ifndef XMRIG_NO_SUMO\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_HEAVY) {\n        return verify(VARIANT_0,    test_output_v0_heavy)  \u0026\u0026\n               verify(VARIANT_XHV,  test_output_xhv_heavy) \u0026\u0026\n               verify(VARIANT_TUBE, test_output_tube_heavy);\n    }\n#   endif\n\n#   ifndef XMRIG_NO_CN_PICO\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_PICO) {\n        return verify(VARIANT_TRTL, test_output_pico_trtl);\n    }\n#   endif\n\n    return false;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":52,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.11.0"},"5011744":{"score":0.72011644,"function_name":"MultiWorker\u003cN\u003e::consumeJob","code":"void MultiWorker\u003cN\u003e::consumeJob()\n{\n    Job job = Workers::job();\n    m_sequence = Workers::sequence();\n    if (m_state.job == job) {\n        return;\n    }\n\n    save(job);\n\n    if (resume(job)) {\n        return;\n    }\n\n    m_state.job = job;\n\n    const size_t size = m_state.job.size();\n    memcpy(m_state.blob, m_state.job.blob(), m_state.job.size());\n\n    if (N \u003e 1) {\n        for (size_t i = 1; i \u003c N; ++i) {\n            memcpy(m_state.blob + (i * size), m_state.blob, size);\n        }\n    }\n\n    for (size_t i = 0; i \u003c N; ++i) {\n        if (m_state.job.isNicehash()) {\n            *nonce(i) = (*nonce(i) \u0026 0xff000000U) + (0xffffffU / m_totalWays * (m_offset + i));\n        }\n        else {\n           *nonce(i) = 0xffffffffU / m_totalWays * (m_offset + i);\n        }\n    }\n}","filepath":"src/workers/MultiWorker.cpp","line_number":171,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.11.0"},"5023280":{"score":0.7061567,"function_name":"MultiWorker\u003cN\u003e::consumeJob","code":"void MultiWorker\u003cN\u003e::consumeJob()\n{\n    Job job = Workers::job();\n    m_sequence = Workers::sequence();\n    if (m_state.job == job) {\n        return;\n    }\n\n    save(job);\n\n    if (resume(job)) {\n        return;\n    }\n\n    m_state.job = job;\n\n    const size_t size = m_state.job.size();\n    memcpy(m_state.blob, m_state.job.blob(), m_state.job.size());\n\n    if (N \u003e 1) {\n        for (size_t i = 1; i \u003c N; ++i) {\n            memcpy(m_state.blob + (i * size), m_state.blob, size);\n        }\n    }\n\n    for (size_t i = 0; i \u003c N; ++i) {\n        if (m_state.job.isNicehash()) {\n            *nonce(i) = (*nonce(i) \u0026 0xff000000U) + (0xffffffU / m_totalWays * (m_offset + i));\n        }\n        else {\n           *nonce(i) = 0xffffffffU / m_totalWays * (m_offset + i);\n        }\n    }\n}","filepath":"src/workers/MultiWorker.cpp","line_number":148,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"5027360":{"score":0.7276285,"function_name":"MultiWorker\u003cN\u003e::verify","code":"bool MultiWorker\u003cN\u003e::verify(xmrig::Variant variant, const uint8_t *referenceValue)\n{\n\n    xmrig::CpuThread::cn_hash_fun func = m_thread-\u003efn(variant);\n    if (!func) {\n        return false;\n    }\n\n    func(test_input, 76, m_hash, m_ctx);\n    return memcmp(m_hash, referenceValue, sizeof m_hash) == 0;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":134,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"5027456":{"score":0.7089714,"function_name":"MultiWorker\u003cN\u003e::selfTest","code":"bool MultiWorker\u003cN\u003e::selfTest()\n{\n    if (m_thread-\u003ealgorithm() == xmrig::CRYPTONIGHT) {\n        return verify(xmrig::VARIANT_0,   test_output_v0) \u0026\u0026\n               verify(xmrig::VARIANT_1,   test_output_v1) \u0026\u0026\n               verify(xmrig::VARIANT_XTL, test_output_xtl) \u0026\u0026\n               verify(xmrig::VARIANT_MSR, test_output_msr);\n    }\n\n#   ifndef XMRIG_NO_AEON\n    if (m_thread-\u003ealgorithm() == xmrig::CRYPTONIGHT_LITE) {\n        return verify(xmrig::VARIANT_0,    test_output_v0_lite) \u0026\u0026\n               verify(xmrig::VARIANT_1,    test_output_v1_lite) \u0026\u0026\n               verify(xmrig::VARIANT_IPBC, test_output_ipbc_lite);\n    }\n#   endif\n\n#   ifndef XMRIG_NO_SUMO\n    if (m_thread-\u003ealgorithm() == xmrig::CRYPTONIGHT_HEAVY) {\n        return verify(xmrig::VARIANT_0,   test_output_v0_heavy) \u0026\u0026\n               verify(xmrig::VARIANT_XHV, test_output_xhv_heavy);\n    }\n#   endif\n\n    return false;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":51,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"5032064":{"score":0.67401576,"function_name":"Worker::Worker","code":"Worker::Worker(Handle *handle) :\n    m_id(handle-\u003ethreadId()),\n    m_totalWays(handle-\u003etotalWays()),\n    m_offset(handle-\u003eoffset()),\n    m_hashCount(0),\n    m_timestamp(0),\n    m_count(0),\n    m_sequence(0),\n    m_thread(static_cast\u003cxmrig::CpuThread *\u003e(handle-\u003econfig()))\n{\n    if (xmrig::Cpu::info()-\u003ethreads() \u003e 1 \u0026\u0026 m_thread-\u003eaffinity() != -1L) {\n        Platform::setThreadAffinity(m_thread-\u003eaffinity());\n    }\n\n    Platform::setThreadPriority(m_thread-\u003epriority());\n}","filepath":"src/workers/Worker.cpp","line_number":34,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"5032336":{"score":0.5673963,"function_name":"internal_gettimeofday","code":"static inline void\ninternal_gettimeofday (struct timeval *result)\n{\n#if defined (HAVE_GETTIMEOFDAY)\n  gettimeofday (result, NULL);\n#else\n  jlong val = _Jv_platform_gettimeofday ();\n  result-\u003etv_sec = val / 1000;\n  result-\u003etv_usec = (val % 1000) * 1000;\n#endif /* HAVE_GETTIMEOFDAY */\n}","filepath":"libjava/posix.cc","line_number":144,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5033392":{"score":0.6738611,"function_name":"Workers::printHashrate","code":"void Workers::printHashrate(bool detail)\n{\n    assert(m_controller != nullptr);\n    if (!m_controller) {\n        return;\n    }\n\n    if (detail) {\n        const bool isColors = m_controller-\u003econfig()-\u003eisColors();\n        char num1[8] = { 0 };\n        char num2[8] = { 0 };\n        char num3[8] = { 0 };\n\n        Log::i()-\u003etext(\"%s| THREAD | AFFINITY | 10s H/s | 60s H/s | 15m H/s |\", isColors ? \"\\x1B[1;37m\" : \"\");\n\n        size_t i = 0;\n        for (const xmrig::IThread *thread : m_controller-\u003econfig()-\u003ethreads()) {\n             Log::i()-\u003etext(\"| %6zu | %8\" PRId64 \" | %7s | %7s | %7s |\",\n                            thread-\u003eindex(),\n                            thread-\u003eaffinity(),\n                            Hashrate::format(m_hashrate-\u003ecalc(thread-\u003eindex(), Hashrate::ShortInterval),  num1, sizeof num1),\n                            Hashrate::format(m_hashrate-\u003ecalc(thread-\u003eindex(), Hashrate::MediumInterval), num2, sizeof num2),\n                            Hashrate::format(m_hashrate-\u003ecalc(thread-\u003eindex(), Hashrate::LargeInterval),  num3, sizeof num3)\n                            );\n\n             i++;\n        }\n    }\n\n    m_hashrate-\u003eprint();\n}","filepath":"src/workers/Workers.cpp","line_number":92,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"5034096":{"score":0.6257801,"function_name":"Workers::setEnabled","code":"void Workers::setEnabled(bool enabled)\n{\n    if (m_enabled == enabled) {\n        return;\n    }\n\n    m_enabled = enabled;\n    if (!m_active) {\n        return;\n    }\n\n    m_paused = enabled ? 0 : 1;\n    m_sequence++;\n}","filepath":"src/workers/Workers.cpp","line_number":125,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"5038368":{"score":0.6068724,"function_name":"Workers::start","code":"void Workers::start(IWorker *worker)\n{\n    const Worker *w = static_cast\u003cconst Worker *\u003e(worker);\n\n    uv_mutex_lock(\u0026m_mutex);\n    m_status.started++;\n    m_status.pages     += w-\u003ememory().pages;\n    m_status.hugePages += w-\u003ememory().hugePages;\n\n    if (m_status.started == m_status.threads) {\n        const double percent = (double) m_status.hugePages / m_status.pages * 100.0;\n        const size_t memory  = m_status.ways * xmrig::cn_select_memory(m_status.algo) / 1048576;\n\n        if (m_status.colors) {\n            LOG_INFO(GREEN_BOLD(\"READY (CPU)\") \" threads \" CYAN_BOLD(\"%zu(%zu)\") \" huge pages %s%zu/%zu %1.0f%%\\x1B[0m memory \" CYAN_BOLD(\"%zu.0 MB\") \"\",\n                     m_status.threads, m_status.ways,\n                     (m_status.hugePages == m_status.pages ? \"\\x1B[1;32m\" : (m_status.hugePages == 0 ? \"\\x1B[1;31m\" : \"\\x1B[1;33m\")),\n                     m_status.hugePages, m_status.pages, percent, memory);\n        }\n        else {\n            LOG_INFO(\"READY (CPU) threads %zu(%zu) huge pages %zu/%zu %1.0f%% memory %zu.0 MB\",\n                     m_status.threads, m_status.ways, m_status.hugePages, m_status.pages, percent, memory);\n        }\n    }\n\n    uv_mutex_unlock(\u0026m_mutex);\n\n    worker-\u003estart();\n}","filepath":"src/workers/Workers.cpp","line_number":321,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"5038944":{"score":0.7383711,"function_name":"Workers::onReady","code":"void Workers::onReady(void *arg)\n{\n    auto handle = static_cast\u003cHandle*\u003e(arg);\n\n    IWorker *worker = nullptr;\n\n    switch (handle-\u003econfig()-\u003emultiway()) {\n    case 1:\n        worker = new MultiWorker\u003c1\u003e(handle);\n        break;\n\n    case 2:\n        worker = new MultiWorker\u003c2\u003e(handle);\n        break;\n\n    case 3:\n        worker = new MultiWorker\u003c3\u003e(handle);\n        break;\n\n    case 4:\n        worker = new MultiWorker\u003c4\u003e(handle);\n        break;\n\n    case 5:\n        worker = new MultiWorker\u003c5\u003e(handle);\n        break;\n\n    default:\n        break;\n    }\n\n    handle-\u003esetWorker(worker);\n\n    if (!worker-\u003eselfTest()) {\n        LOG_ERR(\"thread %zu error: \\\"hash self-test failed\\\".\", handle-\u003eworker()-\u003eid());\n\n        return;\n    }\n\n    start(worker);\n}","filepath":"src/workers/Workers.cpp","line_number":243,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"5040352":{"score":0.5393605,"function_name":"xmrig::Platform::createUserAgent","code":"char *xmrig::Platform::createUserAgent()\n{\n    constexpr const size_t max = 256;\n\n    char *buf = new char[max]();\n    int length = snprintf(buf, max, \"%s/%s (Linux \", APP_NAME, APP_VERSION);\n\n#   if defined(__x86_64__)\n    length += snprintf(buf + length, max - length, \"x86_64) libuv/%s\", uv_version_string());\n#   elif defined(__aarch64__)\n    length += snprintf(buf + length, max - length, \"aarch64) libuv/%s\", uv_version_string());\n#   elif defined(__arm__)\n    length += snprintf(buf + length, max - length, \"arm) libuv/%s\", uv_version_string());\n#   else\n    length += snprintf(buf + length, max - length, \"i686) libuv/%s\", uv_version_string());\n#   endif\n\n#   ifdef __clang__\n    length += snprintf(buf + length, max - length, \" clang/%d.%d.%d\", __clang_major__, __clang_minor__, __clang_patchlevel__);\n#   elif defined(__GNUC__)\n    length += snprintf(buf + length, max - length, \" gcc/%d.%d.%d\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#   endif\n\n    return buf;\n}","filepath":"src/base/kernel/Platform_unix.cpp","line_number":49,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.9.0"},"5040576":{"score":0.7848565,"function_name":"createUserAgent","code":"static inline char *createUserAgent()\n{\n    const size_t max = 160;\n\n    char *buf = new char[max];\n    int length = snprintf(buf, max, \"%s/%s (Linux \", APP_NAME, APP_VERSION);\n\n#   if defined(__x86_64__)\n    length += snprintf(buf + length, max - length, \"x86_64) libuv/%s\", uv_version_string());\n#   else\n    length += snprintf(buf + length, max - length, \"i686) libuv/%s\", uv_version_string());\n#   endif\n\n#   ifdef XMRIG_NVIDIA_PROJECT\n    const int cudaVersion = cuda_get_runtime_version();\n    length += snprintf(buf + length, max - length, \" CUDA/%d.%d\", cudaVersion / 1000, cudaVersion % 100);\n#   endif\n\n#   ifdef __GNUC__\n    length += snprintf(buf + length, max - length, \" gcc/%d.%d.%d\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#   endif\n\n    return buf;\n}","filepath":"src/common/Platform_unix.cpp","line_number":55,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.2"},"5040768":{"score":0.65006363,"function_name":"Platform::setThreadAffinity","code":"bool Platform::setThreadAffinity(uint64_t cpu_id)\n{\n    cpu_set_t mn;\n    CPU_ZERO(\u0026mn);\n    CPU_SET(cpu_id, \u0026mn);\n\n#   ifndef __ANDROID__\n    return pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), \u0026mn) == 0;\n#   else\n    return sched_setaffinity(gettid(), sizeof(cpu_set_t), \u0026mn) == 0;\n#   endif\n}","filepath":"src/common/Platform_unix.cpp","line_number":81,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.2"},"5040928":{"score":0.6555581,"function_name":"Platform::setThreadPriority","code":"void Platform::setThreadPriority(int priority)\n{\n    if (priority == -1) {\n        return;\n    }\n\n    int prio = 19;\n    switch (priority)\n    {\n    case 1:\n        prio = 5;\n        break;\n\n    case 2:\n        prio = 0;\n        break;\n\n    case 3:\n        prio = -5;\n        break;\n\n    case 4:\n        prio = -10;\n        break;\n\n    case 5:\n        prio = -15;\n        break;\n\n    default:\n        break;\n    }\n\n    setpriority(PRIO_PROCESS, 0, prio);\n\n#   ifdef SCHED_IDLE\n    if (priority == 0) {\n        sched_param param;\n        param.sched_priority = 0;\n\n        if (sched_setscheduler(0, SCHED_IDLE, \u0026param) != 0) {\n            sched_setscheduler(0, SCHED_BATCH, \u0026param);\n        }\n    }\n#   endif\n}","filepath":"src/common/Platform_unix.cpp","line_number":112,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.2"},"5041104":{"score":0.7363888,"function_name":"Mem::allocate","code":"void Mem::allocate(MemInfo \u0026info, bool enabled)\n{\n    info.hugePages = 0;\n\n    if (!enabled) {\n        info.memory = static_cast\u003cuint8_t*\u003e(_mm_malloc(info.size, 4096));\n\n        return;\n    }\n\n    info.memory = static_cast\u003cuint8_t*\u003e(xmrig::VirtualMemory::allocateLargePagesMemory(info.size));\n    if (!info.memory) {\n        return allocate(info, false);;\n    }\n\n    info.hugePages = info.pages;\n\n    if (madvise(info.memory, info.size, MADV_RANDOM | MADV_WILLNEED) != 0) {\n        LOG_ERR(\"madvise failed\");\n    }\n\n    if (mlock(info.memory, info.size) == 0) {\n        m_flags |= Lock;\n    }\n}","filepath":"src/Mem_unix.cpp","line_number":50,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"5041376":{"score":0.6473553,"function_name":"Mem::release","code":"void Mem::release(MemInfo \u0026info)\n{\n    if (info.hugePages) {\n        if (m_flags \u0026 Lock) {\n            munlock(info.memory, info.size);\n        }\n\n        xmrig::VirtualMemory::freeLargePagesMemory(info.memory, info.size);\n    }\n    else {\n        _mm_free(info.memory);\n    }\n}","filepath":"src/Mem_unix.cpp","line_number":77,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.16.0-beta"},"5041456":{"score":0.8177297,"function_name":"xmrig::AdvancedCpuInfo::optimalThreadsCount","code":"size_t xmrig::AdvancedCpuInfo::optimalThreadsCount(size_t memSize, int maxCpuUsage) const\n{\n    if (threads() == 1) {\n        return 1;\n    }\n\n    size_t cache = 0;\n    if (m_L3) {\n        cache = m_L2_exclusive ? (m_L2 + m_L3) : m_L3;\n    }\n    else {\n        cache = m_L2;\n    }\n\n    size_t count = 0;\n\n    if (cache) {\n        count = cache / memSize;\n\n        if (cache % memSize \u003e= memSize / 2) {\n            count++;\n        }\n    }\n    else {\n        count = threads() / 2;\n    }\n\n    if (count \u003e (size_t) threads()) {\n        count = threads();\n    }\n\n    if (((float) count / threads() * 100) \u003e maxCpuUsage) {\n        count = (int) ceil((float) threads() * (maxCpuUsage / 100.0));\n    }\n\n    return count \u003c 1 ? 1 : count;\n}","filepath":"src/core/cpu/AdvancedCpuInfo.cpp","line_number":89,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"5042048":{"score":0.812562,"function_name":"xmrig::AdvancedCpuInfo::AdvancedCpuInfo","code":"xmrig::AdvancedCpuInfo::AdvancedCpuInfo() :\n    m_assembly(ASM_NONE),\n    m_aes(false),\n    m_L2_exclusive(false),\n    m_brand(),\n    m_cores(0),\n    m_L2(0),\n    m_L3(0),\n    m_sockets(1),\n    m_threads(0)\n{\n    struct cpu_raw_data_t raw = { 0 };\n    struct cpu_id_t data = { 0 };\n\n    cpuid_get_raw_data(\u0026raw);\n    cpu_identify(\u0026raw, \u0026data);\n\n    strncpy(m_brand, data.brand_str, sizeof(m_brand));\n\n    m_threads = data.total_logical_cpus;\n    m_sockets = threads() / data.num_logical_cpus;\n    if (m_sockets == 0) {\n        m_sockets = 1;\n    }\n\n    m_cores = data.num_cores * m_sockets;\n    m_L3 = data.l3_cache \u003e 0 ? data.l3_cache * m_sockets : 0;\n\n    // Workaround for AMD CPUs https://github.com/anrieff/libcpuid/issues/97\n    if (data.vendor == VENDOR_AMD \u0026\u0026 data.ext_family \u003e= 0x15 \u0026\u0026 data.ext_family \u003c 0x17) {\n        m_L2 = data.l2_cache * (cores() / 2) * m_sockets;\n        m_L2_exclusive = true;\n    }\n    // Workaround for Intel Pentium Dual-Core, Core Duo, Core 2 Duo, Core 2 Quad and their Xeon homologue\n    // These processors have L2 cache shared by 2 cores.\n    else if (data.vendor == VENDOR_INTEL \u0026\u0026 data.ext_family == 0x06 \u0026\u0026 (data.ext_model == 0x0E || data.ext_model == 0x0F || data.ext_model == 0x17)) {\n        int l2_count_per_socket = cores() \u003e 1 ? cores() / 2 : 1;\n        m_L2 = data.l2_cache \u003e 0 ? data.l2_cache * l2_count_per_socket * m_sockets : 0;\n    }\n    else{\n        m_L2 = data.l2_cache \u003e 0 ? data.l2_cache * cores() * m_sockets : 0;\n    }\n\n    if (data.flags[CPU_FEATURE_AES]) {\n        m_aes = true;\n\n        if (data.vendor == VENDOR_AMD) {\n            m_assembly = (data.ext_family \u003e= 23) ? ASM_RYZEN : ASM_BULLDOZER;\n        }\n        else if (data.vendor == VENDOR_INTEL) {\n            m_assembly = ASM_INTEL;\n        }\n    }\n}","filepath":"src/core/cpu/AdvancedCpuInfo.cpp","line_number":33,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.0"},"5042960":{"score":0.57988846,"function_name":"scrypt_core","code":"static inline void scrypt_core(uint32_t *X, uint32_t *V, int N)\n{\n\tuint32_t i, j, k;\n\t\n\tfor (i = 0; i \u003c N; i++) {\n\t\tmemcpy(\u0026V[i * 32], X, 128);\n\t\txor_salsa8(\u0026X[0], \u0026X[16]);\n\t\txor_salsa8(\u0026X[16], \u0026X[0]);\n\t}\n\tfor (i = 0; i \u003c N; i++) {\n\t\tj = 32 * (X[16] \u0026 (N - 1));\n\t\tfor (k = 0; k \u003c 32; k++)\n\t\t\tX[k] ^= V[j + k];\n\t\txor_salsa8(\u0026X[0], \u0026X[16]);\n\t\txor_salsa8(\u0026X[16], \u0026X[0]);\n\t}\n}","filepath":"scrypt.c","line_number":488,"entry_url":"https://github.com/pooler/cpuminer.git","slot_name":"v2.4.1"},"5050384":{"score":0.67442405,"function_name":"SHA256_Transform","code":"static void SHA256_Transform(uint32_t *state, const uint32_t *block, int swap)\n{\n\tuint32_t W[64];\n\tuint32_t S[8];\n\tuint32_t t0, t1;\n\tint i;\n\n\t/* 1. Prepare message schedule W. */\n\tif (swap)\n\t\tbyteswap_vec(W, block, 16);\n\telse\n\t\tmemcpy(W, block, 64);\n\tfor (i = 16; i \u003c 64; i += 2) {\n\t\tW[i]   = s1(W[i - 2]) + W[i - 7] + s0(W[i - 15]) + W[i - 16];\n\t\tW[i+1] = s1(W[i - 1]) + W[i - 6] + s0(W[i - 14]) + W[i - 15];\n\t}\n\n\t/* 2. Initialize working variables. */\n\tmemcpy(S, state, 32);\n\n\t/* 3. Mix. */\n\tRNDr(S, W, 0, 0x428a2f98);\n\tRNDr(S, W, 1, 0x71374491);\n\tRNDr(S, W, 2, 0xb5c0fbcf);\n\tRNDr(S, W, 3, 0xe9b5dba5);\n\tRNDr(S, W, 4, 0x3956c25b);\n\tRNDr(S, W, 5, 0x59f111f1);\n\tRNDr(S, W, 6, 0x923f82a4);\n\tRNDr(S, W, 7, 0xab1c5ed5);\n\tRNDr(S, W, 8, 0xd807aa98);\n\tRNDr(S, W, 9, 0x12835b01);\n\tRNDr(S, W, 10, 0x243185be);\n\tRNDr(S, W, 11, 0x550c7dc3);\n\tRNDr(S, W, 12, 0x72be5d74);\n\tRNDr(S, W, 13, 0x80deb1fe);\n\tRNDr(S, W, 14, 0x9bdc06a7);\n\tRNDr(S, W, 15, 0xc19bf174);\n\tRNDr(S, W, 16, 0xe49b69c1);\n\tRNDr(S, W, 17, 0xefbe4786);\n\tRNDr(S, W, 18, 0x0fc19dc6);\n\tRNDr(S, W, 19, 0x240ca1cc);\n\tRNDr(S, W, 20, 0x2de92c6f);\n\tRNDr(S, W, 21, 0x4a7484aa);\n\tRNDr(S, W, 22, 0x5cb0a9dc);\n\tRNDr(S, W, 23, 0x76f988da);\n\tRNDr(S, W, 24, 0x983e5152);\n\tRNDr(S, W, 25, 0xa831c66d);\n\tRNDr(S, W, 26, 0xb00327c8);\n\tRNDr(S, W, 27, 0xbf597fc7);\n\tRNDr(S, W, 28, 0xc6e00bf3);\n\tRNDr(S, W, 29, 0xd5a79147);\n\tRNDr(S, W, 30, 0x06ca6351);\n\tRNDr(S, W, 31, 0x14292967);\n\tRNDr(S, W, 32, 0x27b70a85);\n\tRNDr(S, W, 33, 0x2e1b2138);\n\tRNDr(S, W, 34, 0x4d2c6dfc);\n\tRNDr(S, W, 35, 0x53380d13);\n\tRNDr(S, W, 36, 0x650a7354);\n\tRNDr(S, W, 37, 0x766a0abb);\n\tRNDr(S, W, 38, 0x81c2c92e);\n\tRNDr(S, W, 39, 0x92722c85);\n\tRNDr(S, W, 40, 0xa2bfe8a1);\n\tRNDr(S, W, 41, 0xa81a664b);\n\tRNDr(S, W, 42, 0xc24b8b70);\n\tRNDr(S, W, 43, 0xc76c51a3);\n\tRNDr(S, W, 44, 0xd192e819);\n\tRNDr(S, W, 45, 0xd6990624);\n\tRNDr(S, W, 46, 0xf40e3585);\n\tRNDr(S, W, 47, 0x106aa070);\n\tRNDr(S, W, 48, 0x19a4c116);\n\tRNDr(S, W, 49, 0x1e376c08);\n\tRNDr(S, W, 50, 0x2748774c);\n\tRNDr(S, W, 51, 0x34b0bcb5);\n\tRNDr(S, W, 52, 0x391c0cb3);\n\tRNDr(S, W, 53, 0x4ed8aa4a);\n\tRNDr(S, W, 54, 0x5b9cca4f);\n\tRNDr(S, W, 55, 0x682e6ff3);\n\tRNDr(S, W, 56, 0x748f82ee);\n\tRNDr(S, W, 57, 0x78a5636f);\n\tRNDr(S, W, 58, 0x84c87814);\n\tRNDr(S, W, 59, 0x8cc70208);\n\tRNDr(S, W, 60, 0x90befffa);\n\tRNDr(S, W, 61, 0xa4506ceb);\n\tRNDr(S, W, 62, 0xbef9a3f7);\n\tRNDr(S, W, 63, 0xc67178f2);\n\n\t/* 4. Mix local working variables into global state */\n\tfor (i = 0; i \u003c 8; i++)\n\t\tstate[i] += S[i];\n}","filepath":"scrypt.c","line_number":90,"entry_url":"https://github.com/pooler/cpuminer.git","slot_name":"v2.1.4"},"5051696":{"score":0.61080134,"function_name":"scrypt_1024_1_1_256_sp","code":"static void scrypt_1024_1_1_256_sp(const uint32_t *input, uint32_t *output,\n\tunsigned char *scratchpad)\n{\n\tuint32_t tstate[8], ostate[8];\n\tuint32_t *V;\n\tuint32_t X[32];\n\tV = (uint32_t *)(((uintptr_t)(scratchpad) + 63) \u0026 ~ (uintptr_t)(63));\n\n\tHMAC_SHA256_80_init(input, tstate, ostate);\n\tPBKDF2_SHA256_80_128(tstate, ostate, input, X);\n\n\tscrypt_core(X, V);\n\n\treturn PBKDF2_SHA256_128_32(tstate, ostate, X, output);\n}","filepath":"scrypt.c","line_number":520,"entry_url":"https://github.com/pooler/cpuminer.git","slot_name":"v2.1.4"},"5052816":{"score":0.58745366,"function_name":"blake256_compress","code":"void blake256_compress(state *S, const uint8_t *block) {\n    uint32_t v[16], m[16], i;\n\n#define ROT(x,n) (((x)\u003c\u003c(32-n))|((x)\u003e\u003e(n)))\n#define G(a,b,c,d,e)                                      \\\n    v[a] += (m[sigma[i][e]] ^ cst[sigma[i][e+1]]) + v[b]; \\\n    v[d] = ROT(v[d] ^ v[a],16);                           \\\n    v[c] += v[d];                                         \\\n    v[b] = ROT(v[b] ^ v[c],12);                           \\\n    v[a] += (m[sigma[i][e+1]] ^ cst[sigma[i][e]])+v[b];   \\\n    v[d] = ROT(v[d] ^ v[a], 8);                           \\\n    v[c] += v[d];                                         \\\n    v[b] = ROT(v[b] ^ v[c], 7);\n\n    for (i = 0; i \u003c 16; ++i) m[i] = U8TO32(block + i * 4);\n    for (i = 0; i \u003c 8;  ++i) v[i] = S-\u003eh[i];\n    v[ 8] = S-\u003es[0] ^ 0x243F6A88;\n    v[ 9] = S-\u003es[1] ^ 0x85A308D3;\n    v[10] = S-\u003es[2] ^ 0x13198A2E;\n    v[11] = S-\u003es[3] ^ 0x03707344;\n    v[12] = 0xA4093822;\n    v[13] = 0x299F31D0;\n    v[14] = 0x082EFA98;\n    v[15] = 0xEC4E6C89;\n\n    if (S-\u003enullt == 0) {\n        v[12] ^= S-\u003et[0];\n        v[13] ^= S-\u003et[0];\n        v[14] ^= S-\u003et[1];\n        v[15] ^= S-\u003et[1];\n    }\n\n    for (i = 0; i \u003c 14; ++i) {\n        G(0, 4,  8, 12,  0);\n        G(1, 5,  9, 13,  2);\n        G(2, 6, 10, 14,  4);\n        G(3, 7, 11, 15,  6);\n        G(3, 4,  9, 14, 14);\n        G(2, 7,  8, 13, 12);\n        G(0, 5, 10, 15,  8);\n        G(1, 6, 11, 12, 10);\n    }\n\n    for (i = 0; i \u003c 16; ++i) S-\u003eh[i % 8] ^= v[i];\n    for (i = 0; i \u003c 8;  ++i) S-\u003eh[i] ^= S-\u003es[i % 4];\n}","filepath":"src/crypto/c_blake256.c","line_number":53,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"5055328":{"score":0.77770066,"function_name":"SHA256_InitState","code":"static inline void SHA256_InitState(uint32_t *state)\n{\n\t/* Magic initialization constants */\n\tstate[0] = 0x6A09E667;\n\tstate[1] = 0xBB67AE85;\n\tstate[2] = 0x3C6EF372;\n\tstate[3] = 0xA54FF53A;\n\tstate[4] = 0x510E527F;\n\tstate[5] = 0x9B05688C;\n\tstate[6] = 0x1F83D9AB;\n\tstate[7] = 0x5BE0CD19;\n}","filepath":"scrypt.c","line_number":48,"entry_url":"https://github.com/pooler/cpuminer.git","slot_name":"v2.1.4"},"5055440":{"score":0.8336779,"function_name":"blake224_init","code":"void blake224_init(state *S) {\n    S-\u003eh[0] = 0xC1059ED8;\n    S-\u003eh[1] = 0x367CD507;\n    S-\u003eh[2] = 0x3070DD17;\n    S-\u003eh[3] = 0xF70E5939;\n    S-\u003eh[4] = 0xFFC00B31;\n    S-\u003eh[5] = 0x68581511;\n    S-\u003eh[6] = 0x64F98FA7;\n    S-\u003eh[7] = 0xBEFA4FA4;\n    S-\u003et[0] = S-\u003et[1] = S-\u003ebuflen = S-\u003enullt = 0;\n    S-\u003es[0] = S-\u003es[1] = S-\u003es[2] = S-\u003es[3] = 0;\n}","filepath":"src/crypto/c_blake256.c","line_number":113,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"5055552":{"score":0.6922755,"function_name":"blake2b_update","code":"void blake2b_update(blake2b_state *S, const void *in, size_t inlen)\n{\n    const uint8_t *pin = (const uint8_t *)in;\n\n    if (S-\u003ebuflen + inlen \u003e BLAKE2B_BLOCKBYTES) {\n        size_t left = S-\u003ebuflen;\n        size_t fill = BLAKE2B_BLOCKBYTES - left;\n        memcpy(\u0026S-\u003ebuf[left], pin, fill);\n        blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n        blake2b_compress(S, S-\u003ebuf, 0);\n        S-\u003ebuflen = 0;\n        inlen -= fill;\n        pin += fill;\n        /* Avoid buffer copies when possible */\n        while (inlen \u003e BLAKE2B_BLOCKBYTES) {\n            blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n            blake2b_compress(S, pin, 0);\n            inlen -= BLAKE2B_BLOCKBYTES;\n            pin += BLAKE2B_BLOCKBYTES;\n        }\n    }\n    memcpy(\u0026S-\u003ebuf[S-\u003ebuflen], pin, inlen);\n    S-\u003ebuflen += inlen;\n}","filepath":"src/3rdparty/argon2/lib/blake2/blake2.c","line_number":138,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v3.1.0"},"5056016":{"score":0.854736,"function_name":"blake256_update","code":"void blake256_update(state *S, const uint8_t *data, uint64_t datalen) {\n    int left = S-\u003ebuflen \u003e\u003e 3;\n    int fill = 64 - left;\n\n    if (left \u0026\u0026 (((datalen \u003e\u003e 3) \u0026 0x3F) \u003e= (unsigned) fill)) {\n        memcpy((void *) (S-\u003ebuf + left), (void *) data, fill);\n        S-\u003et[0] += 512;\n        if (S-\u003et[0] == 0) S-\u003et[1]++;\n        blake256_compress(S, S-\u003ebuf);\n        data += fill;\n        datalen -= (fill \u003c\u003c 3);\n        left = 0;\n    }\n\n    while (datalen \u003e= 512) {\n        S-\u003et[0] += 512;\n        if (S-\u003et[0] == 0) S-\u003et[1]++;\n        blake256_compress(S, data);\n        data += 64;\n        datalen -= 512;\n    }\n\n    if (datalen \u003e 0) {\n        memcpy((void *) (S-\u003ebuf + left), (void *) data, datalen \u003e\u003e 3);\n        S-\u003ebuflen = (left \u003c\u003c 3) + (int) datalen;\n    } else {\n        S-\u003ebuflen = 0;\n    }\n}","filepath":"src/crypto/c_blake256.c","line_number":127,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"5056480":{"score":0.87108386,"function_name":"blake256_final_h","code":"void blake256_final_h(state *S, uint8_t *digest, uint8_t pa, uint8_t pb) {\n    uint8_t msglen[8];\n    uint32_t lo = S-\u003et[0] + S-\u003ebuflen, hi = S-\u003et[1];\n    if (lo \u003c (unsigned) S-\u003ebuflen) hi++;\n    U32TO8(msglen + 0, hi);\n    U32TO8(msglen + 4, lo);\n\n    if (S-\u003ebuflen == 440) { /* one padding byte */\n        S-\u003et[0] -= 8;\n        blake256_update(S, \u0026pa, 8);\n    } else {\n        if (S-\u003ebuflen \u003c 440) { /* enough space to fill the block  */\n            if (S-\u003ebuflen == 0) S-\u003enullt = 1;\n            S-\u003et[0] -= 440 - S-\u003ebuflen;\n            blake256_update(S, padding, 440 - S-\u003ebuflen);\n        } else { /* need 2 compressions */\n            S-\u003et[0] -= 512 - S-\u003ebuflen;\n            blake256_update(S, padding, 512 - S-\u003ebuflen);\n            S-\u003et[0] -= 440;\n            blake256_update(S, padding + 1, 440);\n            S-\u003enullt = 1;\n        }\n        blake256_update(S, \u0026pb, 8);\n        S-\u003et[0] -= 8;\n    }\n    S-\u003et[0] -= 64;\n    blake256_update(S, msglen, 64);\n\n    U32TO8(digest +  0, S-\u003eh[0]);\n    U32TO8(digest +  4, S-\u003eh[1]);\n    U32TO8(digest +  8, S-\u003eh[2]);\n    U32TO8(digest + 12, S-\u003eh[3]);\n    U32TO8(digest + 16, S-\u003eh[4]);\n    U32TO8(digest + 20, S-\u003eh[5]);\n    U32TO8(digest + 24, S-\u003eh[6]);\n    U32TO8(digest + 28, S-\u003eh[7]);\n}","filepath":"src/crypto/c_blake256.c","line_number":162,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"5058352":{"score":0.65394604,"function_name":"hmac_blake256_init","code":"void hmac_blake256_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {\n    const uint8_t *key = _key;\n    uint8_t keyhash[32];\n    uint8_t pad[64];\n    uint64_t i;\n\n    if (keylen \u003e 64) {\n        blake256_hash(keyhash, key, keylen);\n        key = keyhash;\n        keylen = 32;\n    }\n\n    blake256_init(\u0026S-\u003einner);\n    memset(pad, 0x36, 64);\n    for (i = 0; i \u003c keylen; ++i) {\n        pad[i] ^= key[i];\n    }\n    blake256_update(\u0026S-\u003einner, pad, 512);\n\n    blake256_init(\u0026S-\u003eouter);\n    memset(pad, 0x5c, 64);\n    for (i = 0; i \u003c keylen; ++i) {\n        pad[i] ^= key[i];\n    }\n    blake256_update(\u0026S-\u003eouter, pad, 512);\n\n    memset(keyhash, 0, 32);\n}","filepath":"src/crypto/c_blake256.c","line_number":225,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.3.0"},"5059440":{"score":0.70086414,"function_name":"sha256d","code":"void sha256d(unsigned char *hash, const unsigned char *data, int len)\n{\n\tuint32_t S[16], T[16];\n\tint i, r;\n\n\tsha256_init(S);\n\tfor (r = len; r \u003e -9; r -= 64) {\n\t\tif (r \u003c 64)\n\t\t\tmemset(T, 0, 64);\n\t\tmemcpy(T, data + len - r, r \u003e 64 ? 64 : (r \u003c 0 ? 0 : r));\n\t\tif (r \u003c 64)\n\t\t\t((unsigned char *)T)[r] = 0x80;\n\t\tfor (i = 0; i \u003c 16; i++)\n\t\t\tT[i] = be32dec(T + i);\n\t\tif (r \u003c 56)\n\t\t\tT[15] = 8 * len;\n\t\tsha256_transform(S, T, 0);\n\t}\n\tmemcpy(S + 8, sha256d_hash1 + 8, 32);\n\tsha256_init(T);\n\tsha256_transform(T, S, 0);\n\tfor (i = 0; i \u003c 8; i++)\n\t\tbe32enc((uint32_t *)hash + i, T[i]);\n}","filepath":"sha2.c","line_number":199,"entry_url":"https://github.com/pooler/cpuminer.git","slot_name":"v2.3.1"},"5060528":{"score":0.6381684,"function_name":"blake2b_long","code":"void blake2b_long(void *out, size_t outlen, const void *in, size_t inlen)\n{\n    uint8_t *pout = (uint8_t *)out;\n    blake2b_state blake_state;\n    uint8_t outlen_bytes[sizeof(uint32_t)] = {0};\n\n    store32(outlen_bytes, (uint32_t)outlen);\n    if (outlen \u003c= BLAKE2B_OUTBYTES) {\n        blake2b_init(\u0026blake_state, outlen);\n        blake2b_update(\u0026blake_state, outlen_bytes, sizeof(outlen_bytes));\n        blake2b_update(\u0026blake_state, in, inlen);\n        blake2b_final(\u0026blake_state, pout, outlen);\n    } else {\n        uint32_t toproduce;\n        uint8_t out_buffer[BLAKE2B_OUTBYTES];\n\n        blake2b_init(\u0026blake_state, BLAKE2B_OUTBYTES);\n        blake2b_update(\u0026blake_state, outlen_bytes, sizeof(outlen_bytes));\n        blake2b_update(\u0026blake_state, in, inlen);\n        blake2b_final(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n\n        memcpy(pout, out_buffer, BLAKE2B_OUTBYTES / 2);\n        pout += BLAKE2B_OUTBYTES / 2;\n        toproduce = (uint32_t)outlen - BLAKE2B_OUTBYTES / 2;\n\n        while (toproduce \u003e BLAKE2B_OUTBYTES) {\n            blake2b_init(\u0026blake_state, BLAKE2B_OUTBYTES);\n            blake2b_update(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n            blake2b_final(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n\n            memcpy(pout, out_buffer, BLAKE2B_OUTBYTES / 2);\n            pout += BLAKE2B_OUTBYTES / 2;\n            toproduce -= BLAKE2B_OUTBYTES / 2;\n        }\n\n        blake2b_init(\u0026blake_state, toproduce);\n        blake2b_update(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n        blake2b_final(\u0026blake_state, out_buffer, toproduce);\n\n        memcpy(pout, out_buffer, toproduce);\n\n        clear_internal_memory(out_buffer, sizeof(out_buffer));\n    }\n}","filepath":"src/3rdparty/argon2/lib/blake2/blake2.c","line_number":182,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v3.1.0"},"5065072":{"score":0.5687607,"function_name":"Skein_512_Final","code":"static int Skein_512_Final(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)\n    {\n    size_t i,n,byteCnt;\n    u64b_t X[SKEIN_512_STATE_WORDS];\n    Skein_Assert(ctx-\u003eh.bCnt \u003c= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\n\n    ctx-\u003eh.T[1] |= SKEIN_T1_FLAG_FINAL;                 /* tag as the final block */\n    if (ctx-\u003eh.bCnt \u003c SKEIN_512_BLOCK_BYTES)            /* zero pad b[] if necessary */\n        memset(\u0026ctx-\u003eb[ctx-\u003eh.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx-\u003eh.bCnt);\n\n    Skein_512_Process_Block(ctx,ctx-\u003eb,1,ctx-\u003eh.bCnt);  /* process the final block */\n    \n    /* now output the result */\n    byteCnt = (ctx-\u003eh.hashBitLen + 7) \u003e\u003e 3;             /* total number of output bytes */\n\n    /* run Threefish in \"counter mode\" to generate output */\n    memset(ctx-\u003eb,0,sizeof(ctx-\u003eb));  /* zero out b[], so it can hold the counter */\n    memcpy(X,ctx-\u003eX,sizeof(X));       /* keep a local copy of counter mode \"key\" */\n    for (i=0;i*SKEIN_512_BLOCK_BYTES \u003c byteCnt;i++)\n        {\n        ((u64b_t *)ctx-\u003eb)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\n        Skein_Start_New_Type(ctx,OUT_FINAL);\n        Skein_512_Process_Block(ctx,ctx-\u003eb,1,sizeof(u64b_t)); /* run \"counter mode\" */\n        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;   /* number of output bytes left to go */\n        if (n \u003e= SKEIN_512_BLOCK_BYTES)\n            n  = SKEIN_512_BLOCK_BYTES;\n        Skein_Put64_LSB_First(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx-\u003eX,n);   /* \"output\" the ctr mode bytes */\n        Skein_Show_Final(512,\u0026ctx-\u003eh,n,hashVal+i*SKEIN_512_BLOCK_BYTES);\n        memcpy(ctx-\u003eX,X,sizeof(X));   /* restore the counter mode key for next time */\n        }\n    return SKEIN_SUCCESS;\n    }","filepath":"src/crypto/c_skein.c","line_number":554,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5068944":{"score":0.54325753,"function_name":"blake2b_long","code":"void blake2b_long(void *out, size_t outlen, const void *in, size_t inlen)\n{\n    uint8_t *pout = (uint8_t *)out;\n    blake2b_state blake_state;\n    uint8_t outlen_bytes[sizeof(uint32_t)] = {0};\n\n    store32(outlen_bytes, (uint32_t)outlen);\n    if (outlen \u003c= BLAKE2B_OUTBYTES) {\n        blake2b_init(\u0026blake_state, outlen);\n        blake2b_update(\u0026blake_state, outlen_bytes, sizeof(outlen_bytes));\n        blake2b_update(\u0026blake_state, in, inlen);\n        blake2b_final(\u0026blake_state, pout, outlen);\n    } else {\n        uint32_t toproduce;\n        uint8_t out_buffer[BLAKE2B_OUTBYTES];\n\n        blake2b_init(\u0026blake_state, BLAKE2B_OUTBYTES);\n        blake2b_update(\u0026blake_state, outlen_bytes, sizeof(outlen_bytes));\n        blake2b_update(\u0026blake_state, in, inlen);\n        blake2b_final(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n\n        memcpy(pout, out_buffer, BLAKE2B_OUTBYTES / 2);\n        pout += BLAKE2B_OUTBYTES / 2;\n        toproduce = (uint32_t)outlen - BLAKE2B_OUTBYTES / 2;\n\n        while (toproduce \u003e BLAKE2B_OUTBYTES) {\n            blake2b_init(\u0026blake_state, BLAKE2B_OUTBYTES);\n            blake2b_update(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n            blake2b_final(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n\n            memcpy(pout, out_buffer, BLAKE2B_OUTBYTES / 2);\n            pout += BLAKE2B_OUTBYTES / 2;\n            toproduce -= BLAKE2B_OUTBYTES / 2;\n        }\n\n        blake2b_init(\u0026blake_state, toproduce);\n        blake2b_update(\u0026blake_state, out_buffer, BLAKE2B_OUTBYTES);\n        blake2b_final(\u0026blake_state, out_buffer, toproduce);\n\n        memcpy(pout, out_buffer, toproduce);\n\n        clear_internal_memory(out_buffer, sizeof(out_buffer));\n    }\n}","filepath":"src/3rdparty/argon2/lib/blake2/blake2.c","line_number":182,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v3.1.0"},"5077344":{"score":0.58235574,"function_name":"skein_hash","code":"SkeinHashReturn skein_hash(int hashbitlen, const SkeinBitSequence *data, /* all-in-one call */\n                SkeinDataLength databitlen,SkeinBitSequence *hashval)\n{\n  hashState  state;\n  SkeinHashReturn r = Init(\u0026state,hashbitlen);\n  if (r == SKEIN_SUCCESS)\n  { /* these calls do not fail when called properly */\n    r = Update(\u0026state,data,databitlen);\n    Final(\u0026state,hashval);\n  }\n  return r;\n}","filepath":"src/crypto/c_skein.c","line_number":657,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5080048":{"score":0.7998848,"function_name":"Skein_512_Process_Block","code":"static void Skein_512_Process_Block(Skein_512_Ctxt_t *ctx,const u08b_t *blkPtr,size_t blkCnt,size_t byteCntAdd)\n    { /* do it in C */\n    enum\n        {\n        WCNT = SKEIN_512_STATE_WORDS\n        };\n#undef  RCNT\n#define RCNT  (SKEIN_512_ROUNDS_TOTAL/8)\n\n#ifdef  SKEIN_LOOP                              /* configure how much to unroll the loop */\n#define SKEIN_UNROLL_512 (((SKEIN_LOOP)/10)%10)\n#else\n#define SKEIN_UNROLL_512 (0)\n#endif\n\n#if SKEIN_UNROLL_512\n#if (RCNT % SKEIN_UNROLL_512)\n#error \"Invalid SKEIN_UNROLL_512\"               /* sanity check on unroll count */\n#endif\n    size_t  r;\n    u64b_t  kw[WCNT+4+RCNT*2];                  /* key schedule words : chaining vars + tweak + \"rotation\"*/\n#else\n    u64b_t  kw[WCNT+4];                         /* key schedule words : chaining vars + tweak */\n#endif\n    u64b_t  X0,X1,X2,X3,X4,X5,X6,X7;            /* local copy of vars, for speed */\n    u64b_t  w [WCNT];                           /* local copy of input block */\n#ifdef SKEIN_DEBUG\n    const u64b_t *Xptr[8];                      /* use for debugging (help compiler put Xn in registers) */\n    Xptr[0] = \u0026X0;  Xptr[1] = \u0026X1;  Xptr[2] = \u0026X2;  Xptr[3] = \u0026X3;\n    Xptr[4] = \u0026X4;  Xptr[5] = \u0026X5;  Xptr[6] = \u0026X6;  Xptr[7] = \u0026X7;\n#endif\n\n    Skein_assert(blkCnt != 0);                  /* never call with blkCnt == 0! */\n    ts[0] = ctx-\u003eh.T[0];\n    ts[1] = ctx-\u003eh.T[1];\n    do  {\n        /* this implementation only supports 2**64 input bytes (no carry out here) */\n        ts[0] += byteCntAdd;                    /* update processed length */\n\n        /* precompute the key schedule for this block */\n        ks[0] = ctx-\u003eX[0];\n        ks[1] = ctx-\u003eX[1];\n        ks[2] = ctx-\u003eX[2];\n        ks[3] = ctx-\u003eX[3];\n        ks[4] = ctx-\u003eX[4];\n        ks[5] = ctx-\u003eX[5];\n        ks[6] = ctx-\u003eX[6];\n        ks[7] = ctx-\u003eX[7];\n        ks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ \n                ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;\n\n        ts[2] = ts[0] ^ ts[1];\n\n        Skein_Get64_LSB_First(w,blkPtr,WCNT); /* get input block in little-endian format */\n        DebugSaveTweak(ctx);\n        Skein_Show_Block(BLK_BITS,\u0026ctx-\u003eh,ctx-\u003eX,blkPtr,w,ks,ts);\n\n        X0   = w[0] + ks[0];                    /* do the first full key injection */\n        X1   = w[1] + ks[1];\n        X2   = w[2] + ks[2];\n        X3   = w[3] + ks[3];\n        X4   = w[4] + ks[4];\n        X5   = w[5] + ks[5] + ts[0];\n        X6   = w[6] + ks[6] + ts[1];\n        X7   = w[7] + ks[7];\n\n        blkPtr += SKEIN_512_BLOCK_BYTES;\n\n        Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_KEY_INITIAL,Xptr);\n        /* run the rounds */\n#define Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                  \\\n    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \\\n    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \\\n    X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; \\\n    X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6; \\\n\n#if SKEIN_UNROLL_512 == 0                       \n#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)      /* unrolled */  \\\n    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,rNum,Xptr);\n\n#define I512(R)                                                     \\\n    X0   += ks[((R)+1) % 9];   /* inject the key schedule value */  \\\n    X1   += ks[((R)+2) % 9];                                        \\\n    X2   += ks[((R)+3) % 9];                                        \\\n    X3   += ks[((R)+4) % 9];                                        \\\n    X4   += ks[((R)+5) % 9];                                        \\\n    X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3];                      \\\n    X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3];                      \\\n    X7   += ks[((R)+8) % 9] +     (R)+1;                            \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_KEY_INJECT,Xptr);\n#else                                       /* looping version */\n#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,4*(r-1)+rNum,Xptr);\n\n#define I512(R)                                                     \\\n    X0   += ks[r+(R)+0];        /* inject the key schedule value */ \\\n    X1   += ks[r+(R)+1];                                            \\\n    X2   += ks[r+(R)+2];                                            \\\n    X3   += ks[r+(R)+3];                                            \\\n    X4   += ks[r+(R)+4];                                            \\\n    X5   += ks[r+(R)+5] + ts[r+(R)+0];                              \\\n    X6   += ks[r+(R)+6] + ts[r+(R)+1];                              \\\n    X7   += ks[r+(R)+7] +    r+(R)   ;                              \\\n    ks[r +       (R)+8] = ks[r+(R)-1];  /* rotate key schedule */   \\\n    ts[r +       (R)+2] = ts[r+(R)-1];                              \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_KEY_INJECT,Xptr);\n\n    for (r=1;r \u003c 2*RCNT;r+=2*SKEIN_UNROLL_512)   /* loop thru it */\n#endif                         /* end of looped code definitions */\n        {\n#define R512_8_rounds(R)  /* do 8 full rounds */  \\\n        R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1);   \\\n        R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2);   \\\n        R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3);   \\\n        R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4);   \\\n        I512(2*(R));                              \\\n        R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5);   \\\n        R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6);   \\\n        R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7);   \\\n        R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8);   \\\n        I512(2*(R)+1);        /* and key injection */\n\n        R512_8_rounds( 0);\n\n#define R512_Unroll_R(NN) ((SKEIN_UNROLL_512 == 0 \u0026\u0026 SKEIN_512_ROUNDS_TOTAL/8 \u003e (NN)) || (SKEIN_UNROLL_512 \u003e (NN)))\n\n  #if   R512_Unroll_R( 1)\n        R512_8_rounds( 1);\n  #endif\n  #if   R512_Unroll_R( 2)\n        R512_8_rounds( 2);\n  #endif\n  #if   R512_Unroll_R( 3)\n        R512_8_rounds( 3);\n  #endif\n  #if   R512_Unroll_R( 4)\n        R512_8_rounds( 4);\n  #endif\n  #if   R512_Unroll_R( 5)\n        R512_8_rounds( 5);\n  #endif\n  #if   R512_Unroll_R( 6)\n        R512_8_rounds( 6);\n  #endif\n  #if   R512_Unroll_R( 7)\n        R512_8_rounds( 7);\n  #endif\n  #if   R512_Unroll_R( 8)\n        R512_8_rounds( 8);\n  #endif\n  #if   R512_Unroll_R( 9)\n        R512_8_rounds( 9);\n  #endif\n  #if   R512_Unroll_R(10)\n        R512_8_rounds(10);\n  #endif\n  #if   R512_Unroll_R(11)\n        R512_8_rounds(11);\n  #endif\n  #if   R512_Unroll_R(12)\n        R512_8_rounds(12);\n  #endif\n  #if   R512_Unroll_R(13)\n        R512_8_rounds(13);\n  #endif\n  #if   R512_Unroll_R(14)\n        R512_8_rounds(14);\n  #endif\n  #if  (SKEIN_UNROLL_512 \u003e 14)\n#error  \"need more unrolling in Skein_512_Process_Block\"\n  #endif\n        }\n\n        /* do the final \"feedforward\" xor, update context chaining vars */\n        ctx-\u003eX[0] = X0 ^ w[0];\n        ctx-\u003eX[1] = X1 ^ w[1];\n        ctx-\u003eX[2] = X2 ^ w[2];\n        ctx-\u003eX[3] = X3 ^ w[3];\n        ctx-\u003eX[4] = X4 ^ w[4];\n        ctx-\u003eX[5] = X5 ^ w[5];\n        ctx-\u003eX[6] = X6 ^ w[6];\n        ctx-\u003eX[7] = X7 ^ w[7];\n        Skein_Show_Round(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_FEED_FWD,ctx-\u003eX);\n\n        ts[1] \u0026= ~SKEIN_T1_FLAG_FIRST;\n        }\n    while (--blkCnt);\n    ctx-\u003eh.T[0] = ts[0];\n    ctx-\u003eh.T[1] = ts[1];\n    }","filepath":"src/crypto/c_skein.c","line_number":265,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5084352":{"score":0.60830486,"function_name":"sha1_process_block","code":"void\nsha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)\n{\n  const sha1_uint32 *words = (const sha1_uint32*) buffer;\n  size_t nwords = len / sizeof (sha1_uint32);\n  const sha1_uint32 *endp = words + nwords;\n  sha1_uint32 x[16];\n  sha1_uint32 a = ctx-\u003eA;\n  sha1_uint32 b = ctx-\u003eB;\n  sha1_uint32 c = ctx-\u003eC;\n  sha1_uint32 d = ctx-\u003eD;\n  sha1_uint32 e = ctx-\u003eE;\n\n  /* First increment the byte count.  RFC 1321 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx-\u003etotal[0] += len;\n  if (ctx-\u003etotal[0] \u003c len)\n    ++ctx-\u003etotal[1];\n\n#define rol(x, n) (((x) \u003c\u003c (n)) | ((sha1_uint32) (x) \u003e\u003e (32 - (n))))\n\n#define M(I) ( tm =   x[I\u00260x0f] ^ x[(I-14)\u00260x0f] \\\n\t\t    ^ x[(I-8)\u00260x0f] ^ x[(I-3)\u00260x0f] \\\n\t       , (x[I\u00260x0f] = rol(tm, 1)) )\n\n#define R(A,B,C,D,E,F,K,M)  do { E += rol( A, 5 )     \\\n\t\t\t\t      + F( B, C, D )  \\\n\t\t\t\t      + K\t      \\\n\t\t\t\t      + M;\t      \\\n\t\t\t\t B = rol( B, 30 );    \\\n\t\t\t       } while(0)\n\n  while (words \u003c endp)\n    {\n      sha1_uint32 tm;\n      int t;\n      for (t = 0; t \u003c 16; t++)\n\t{\n\t  x[t] = SWAP (*words);\n\t  words++;\n\t}\n\n      R( a, b, c, d, e, F1, K1, x[ 0] );\n      R( e, a, b, c, d, F1, K1, x[ 1] );\n      R( d, e, a, b, c, F1, K1, x[ 2] );\n      R( c, d, e, a, b, F1, K1, x[ 3] );\n      R( b, c, d, e, a, F1, K1, x[ 4] );\n      R( a, b, c, d, e, F1, K1, x[ 5] );\n      R( e, a, b, c, d, F1, K1, x[ 6] );\n      R( d, e, a, b, c, F1, K1, x[ 7] );\n      R( c, d, e, a, b, F1, K1, x[ 8] );\n      R( b, c, d, e, a, F1, K1, x[ 9] );\n      R( a, b, c, d, e, F1, K1, x[10] );\n      R( e, a, b, c, d, F1, K1, x[11] );\n      R( d, e, a, b, c, F1, K1, x[12] );\n      R( c, d, e, a, b, F1, K1, x[13] );\n      R( b, c, d, e, a, F1, K1, x[14] );\n      R( a, b, c, d, e, F1, K1, x[15] );\n      R( e, a, b, c, d, F1, K1, M(16) );\n      R( d, e, a, b, c, F1, K1, M(17) );\n      R( c, d, e, a, b, F1, K1, M(18) );\n      R( b, c, d, e, a, F1, K1, M(19) );\n      R( a, b, c, d, e, F2, K2, M(20) );\n      R( e, a, b, c, d, F2, K2, M(21) );\n      R( d, e, a, b, c, F2, K2, M(22) );\n      R( c, d, e, a, b, F2, K2, M(23) );\n      R( b, c, d, e, a, F2, K2, M(24) );\n      R( a, b, c, d, e, F2, K2, M(25) );\n      R( e, a, b, c, d, F2, K2, M(26) );\n      R( d, e, a, b, c, F2, K2, M(27) );\n      R( c, d, e, a, b, F2, K2, M(28) );\n      R( b, c, d, e, a, F2, K2, M(29) );\n      R( a, b, c, d, e, F2, K2, M(30) );\n      R( e, a, b, c, d, F2, K2, M(31) );\n      R( d, e, a, b, c, F2, K2, M(32) );\n      R( c, d, e, a, b, F2, K2, M(33) );\n      R( b, c, d, e, a, F2, K2, M(34) );\n      R( a, b, c, d, e, F2, K2, M(35) );\n      R( e, a, b, c, d, F2, K2, M(36) );\n      R( d, e, a, b, c, F2, K2, M(37) );\n      R( c, d, e, a, b, F2, K2, M(38) );\n      R( b, c, d, e, a, F2, K2, M(39) );\n      R( a, b, c, d, e, F3, K3, M(40) );\n      R( e, a, b, c, d, F3, K3, M(41) );\n      R( d, e, a, b, c, F3, K3, M(42) );\n      R( c, d, e, a, b, F3, K3, M(43) );\n      R( b, c, d, e, a, F3, K3, M(44) );\n      R( a, b, c, d, e, F3, K3, M(45) );\n      R( e, a, b, c, d, F3, K3, M(46) );\n      R( d, e, a, b, c, F3, K3, M(47) );\n      R( c, d, e, a, b, F3, K3, M(48) );\n      R( b, c, d, e, a, F3, K3, M(49) );\n      R( a, b, c, d, e, F3, K3, M(50) );\n      R( e, a, b, c, d, F3, K3, M(51) );\n      R( d, e, a, b, c, F3, K3, M(52) );\n      R( c, d, e, a, b, F3, K3, M(53) );\n      R( b, c, d, e, a, F3, K3, M(54) );\n      R( a, b, c, d, e, F3, K3, M(55) );\n      R( e, a, b, c, d, F3, K3, M(56) );\n      R( d, e, a, b, c, F3, K3, M(57) );\n      R( c, d, e, a, b, F3, K3, M(58) );\n      R( b, c, d, e, a, F3, K3, M(59) );\n      R( a, b, c, d, e, F4, K4, M(60) );\n      R( e, a, b, c, d, F4, K4, M(61) );\n      R( d, e, a, b, c, F4, K4, M(62) );\n      R( c, d, e, a, b, F4, K4, M(63) );\n      R( b, c, d, e, a, F4, K4, M(64) );\n      R( a, b, c, d, e, F4, K4, M(65) );\n      R( e, a, b, c, d, F4, K4, M(66) );\n      R( d, e, a, b, c, F4, K4, M(67) );\n      R( c, d, e, a, b, F4, K4, M(68) );\n      R( b, c, d, e, a, F4, K4, M(69) );\n      R( a, b, c, d, e, F4, K4, M(70) );\n      R( e, a, b, c, d, F4, K4, M(71) );\n      R( d, e, a, b, c, F4, K4, M(72) );\n      R( c, d, e, a, b, F4, K4, M(73) );\n      R( b, c, d, e, a, F4, K4, M(74) );\n      R( a, b, c, d, e, F4, K4, M(75) );\n      R( e, a, b, c, d, F4, K4, M(76) );\n      R( d, e, a, b, c, F4, K4, M(77) );\n      R( c, d, e, a, b, F4, K4, M(78) );\n      R( b, c, d, e, a, F4, K4, M(79) );\n\n      a = ctx-\u003eA += a;\n      b = ctx-\u003eB += b;\n      c = ctx-\u003eC += c;\n      d = ctx-\u003eD += d;\n      e = ctx-\u003eE += e;\n    }\n}","filepath":"sha1.c","line_number":285,"entry_url":"https://salsa.debian.org/lechner/mdadm.git","slot_name":"mdadm-4.2-rc3"},"5088384":{"score":0.83932996,"function_name":"Skein_512_Update","code":"static int Skein_512_Update(Skein_512_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt)\n    {\n    size_t n;\n\n    Skein_Assert(ctx-\u003eh.bCnt \u003c= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\n\n    /* process full blocks, if any */\n    if (msgByteCnt + ctx-\u003eh.bCnt \u003e SKEIN_512_BLOCK_BYTES)\n        {\n        if (ctx-\u003eh.bCnt)                              /* finish up any buffered message data */\n            {\n            n = SKEIN_512_BLOCK_BYTES - ctx-\u003eh.bCnt;  /* # bytes free in buffer b[] */\n            if (n)\n                {\n                Skein_assert(n \u003c msgByteCnt);         /* check on our logic here */\n                memcpy(\u0026ctx-\u003eb[ctx-\u003eh.bCnt],msg,n);\n                msgByteCnt  -= n;\n                msg         += n;\n                ctx-\u003eh.bCnt += n;\n                }\n            Skein_assert(ctx-\u003eh.bCnt == SKEIN_512_BLOCK_BYTES);\n            Skein_512_Process_Block(ctx,ctx-\u003eb,1,SKEIN_512_BLOCK_BYTES);\n            ctx-\u003eh.bCnt = 0;\n            }\n        /* now process any remaining full blocks, directly from input message data */\n        if (msgByteCnt \u003e SKEIN_512_BLOCK_BYTES)\n            {\n            n = (msgByteCnt-1) / SKEIN_512_BLOCK_BYTES;   /* number of full blocks to process */\n            Skein_512_Process_Block(ctx,msg,n,SKEIN_512_BLOCK_BYTES);\n            msgByteCnt -= n * SKEIN_512_BLOCK_BYTES;\n            msg        += n * SKEIN_512_BLOCK_BYTES;\n            }\n        Skein_assert(ctx-\u003eh.bCnt == 0);\n        }\n\n    /* copy any remaining source message data bytes into b[] */\n    if (msgByteCnt)\n        {\n        Skein_assert(msgByteCnt + ctx-\u003eh.bCnt \u003c= SKEIN_512_BLOCK_BYTES);\n        memcpy(\u0026ctx-\u003eb[ctx-\u003eh.bCnt],msg,msgByteCnt);\n        ctx-\u003eh.bCnt += msgByteCnt;\n        }\n\n    return SKEIN_SUCCESS;\n    }","filepath":"src/crypto/c_skein.c","line_number":506,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5088592":{"score":0.7185524,"function_name":"Skein_512_Final","code":"static int Skein_512_Final(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)\n    {\n    size_t i,n,byteCnt;\n    u64b_t X[SKEIN_512_STATE_WORDS];\n    Skein_Assert(ctx-\u003eh.bCnt \u003c= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\n\n    ctx-\u003eh.T[1] |= SKEIN_T1_FLAG_FINAL;                 /* tag as the final block */\n    if (ctx-\u003eh.bCnt \u003c SKEIN_512_BLOCK_BYTES)            /* zero pad b[] if necessary */\n        memset(\u0026ctx-\u003eb[ctx-\u003eh.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx-\u003eh.bCnt);\n\n    Skein_512_Process_Block(ctx,ctx-\u003eb,1,ctx-\u003eh.bCnt);  /* process the final block */\n    \n    /* now output the result */\n    byteCnt = (ctx-\u003eh.hashBitLen + 7) \u003e\u003e 3;             /* total number of output bytes */\n\n    /* run Threefish in \"counter mode\" to generate output */\n    memset(ctx-\u003eb,0,sizeof(ctx-\u003eb));  /* zero out b[], so it can hold the counter */\n    memcpy(X,ctx-\u003eX,sizeof(X));       /* keep a local copy of counter mode \"key\" */\n    for (i=0;i*SKEIN_512_BLOCK_BYTES \u003c byteCnt;i++)\n        {\n        ((u64b_t *)ctx-\u003eb)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\n        Skein_Start_New_Type(ctx,OUT_FINAL);\n        Skein_512_Process_Block(ctx,ctx-\u003eb,1,sizeof(u64b_t)); /* run \"counter mode\" */\n        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;   /* number of output bytes left to go */\n        if (n \u003e= SKEIN_512_BLOCK_BYTES)\n            n  = SKEIN_512_BLOCK_BYTES;\n        Skein_Put64_LSB_First(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx-\u003eX,n);   /* \"output\" the ctr mode bytes */\n        Skein_Show_Final(512,\u0026ctx-\u003eh,n,hashVal+i*SKEIN_512_BLOCK_BYTES);\n        memcpy(ctx-\u003eX,X,sizeof(X));   /* restore the counter mode key for next time */\n        }\n    return SKEIN_SUCCESS;\n    }","filepath":"src/Native/libcryptonote/crypto/skein.c","line_number":1540,"entry_url":"https://github.com/coinfoundry/miningcore.git","slot_name":"0.10"},"5089920":{"score":0.6450302,"function_name":"xmr_skein","code":"void xmr_skein(const SkeinBitSequence *data, SkeinBitSequence *hashval){\n  #define XMR_HASHBITLEN 256\n  #define XMR_DATABITLEN 1600\n\n  // Init\n  hashState  state;\n  state.statebits = 64*SKEIN_512_STATE_WORDS;\n\n  // Skein_512_Init(\u0026state.u.ctx_512, (size_t)XMR_HASHBITLEN);\n  state.u.ctx_512.h.hashBitLen = XMR_HASHBITLEN;\n  memcpy(state.u.ctx_512.X,SKEIN_512_IV_256,sizeof(state.u.ctx_512.X));\n  Skein_512_Ctxt_t* ctx = \u0026(state.u.ctx_512);\n  Skein_Start_New_Type(ctx,MSG);\n\n  // Update\n  if ((XMR_DATABITLEN \u0026 7) == 0){  /* partial bytes? */\n    Skein_512_Update(\u0026state.u.ctx_512,data,XMR_DATABITLEN \u003e\u003e 3);\n  }else{   /* handle partial final byte */\n    size_t bCnt = (XMR_DATABITLEN \u003e\u003e 3) + 1;                  /* number of bytes to handle (nonzero here!) */\n    u08b_t b,mask;\n\n    mask = (u08b_t) (1u \u003c\u003c (7 - (XMR_DATABITLEN \u0026 7)));       /* partial byte bit mask */\n    b    = (u08b_t) ((data[bCnt-1] \u0026 (0-mask)) | mask);   /* apply bit padding on final byte */\n\n    Skein_512_Update(\u0026state.u.ctx_512,data,bCnt-1); /* process all but the final byte    */\n    Skein_512_Update(\u0026state.u.ctx_512,\u0026b  ,  1   ); /* process the (masked) partial byte */\n    Skein_Set_Bit_Pad_Flag(state.u.h);                    /* set tweak flag for the final call */\n  }\n\n  // Finalize\n  Skein_512_Final(\u0026state.u.ctx_512, hashval);\n}","filepath":"src/Native/libcryptonight/crypto/c_skein.c","line_number":670,"entry_url":"https://github.com/coinfoundry/miningcore.git","slot_name":"v29"},"5090400":{"score":0.59370136,"function_name":"Api::exec","code":"void Api::exec(const xmrig::HttpRequest \u0026req, xmrig::HttpReply \u0026reply)\n{\n    if (!m_router) {\n        reply.status = 500;\n        return;\n    }\n\n    if (req.method() == xmrig::HttpRequest::Get) {\n        return m_router-\u003eget(req, reply);\n    }\n\n    m_router-\u003eexec(req, reply);\n}","filepath":"src/api/Api.cpp","line_number":50,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5090832":{"score":0.83692366,"function_name":"ApiRouter::exec","code":"void ApiRouter::exec(const xmrig::HttpRequest \u0026req, xmrig::HttpReply \u0026reply)\n{\n    if (req.method() == xmrig::HttpRequest::Put \u0026\u0026 req.match(\"/1/config\")) {\n        m_controller-\u003econfig()-\u003ereload(req.body());\n        return;\n    }\n\n    reply.status = 404;\n}","filepath":"src/api/ApiRouter.cpp","line_number":112,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5090944":{"score":0.629001,"function_name":"ApiRouter::genId","code":"void ApiRouter::genId(const char *id)\n{\n    memset(m_id, 0, sizeof(m_id));\n\n    if (id \u0026\u0026 strlen(id) \u003e 0) {\n        strncpy(m_id, id, sizeof(m_id) - 1);\n        return;\n    }\n\n    uv_interface_address_t *interfaces;\n    int count = 0;\n\n    if (uv_interface_addresses(\u0026interfaces, \u0026count) \u003c 0) {\n        return;\n    }\n\n    for (int i = 0; i \u003c count; i++) {\n        if (!interfaces[i].is_internal \u0026\u0026 interfaces[i].address.address4.sin_family == AF_INET) {\n            uint8_t hash[200];\n            const size_t addrSize = sizeof(interfaces[i].phys_addr);\n            const size_t inSize   = strlen(APP_KIND) + addrSize + sizeof(uint16_t);\n            const uint16_t port   = static_cast\u003cuint16_t\u003e(m_controller-\u003econfig()-\u003eapiPort());\n\n            uint8_t *input = new uint8_t[inSize]();\n            memcpy(input, \u0026port, sizeof(uint16_t));\n            memcpy(input + sizeof(uint16_t), interfaces[i].phys_addr, addrSize);\n            memcpy(input + sizeof(uint16_t) + addrSize, APP_KIND, strlen(APP_KIND));\n\n            xmrig::keccak(input, inSize, hash);\n            xmrig::Buffer::toHex(hash, 8, m_id);\n\n            delete [] input;\n            break;\n        }\n    }\n\n    uv_free_interface_addresses(interfaces, count);\n}","filepath":"src/api/ApiRouter.cpp","line_number":148,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5091440":{"score":0.6294912,"function_name":"xmrig::Api::Api","code":"xmrig::Api::Api(Base *base) :\n    m_base(base),\n    m_id(),\n    m_workerId(),\n    m_timestamp(Chrono::currentMSecsSinceEpoch()),\n    m_httpd(nullptr)\n{\n    base-\u003eaddListener(this);\n\n    genId(base-\u003econfig()-\u003eapiId());\n}","filepath":"src/api/Api.cpp","line_number":52,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.99.3-beta"},"5093696":{"score":0.53882205,"function_name":"ApiRouter::getHashrate","code":"void ApiRouter::getHashrate(rapidjson::Document \u0026doc) const\n{\n    auto \u0026allocator = doc.GetAllocator();\n\n    rapidjson::Value hashrate(rapidjson::kObjectType);\n    rapidjson::Value total(rapidjson::kArrayType);\n    rapidjson::Value threads(rapidjson::kArrayType);\n\n    const Hashrate *hr = Workers::hashrate();\n\n    total.PushBack(normalize(hr-\u003ecalc(Hashrate::ShortInterval)),  allocator);\n    total.PushBack(normalize(hr-\u003ecalc(Hashrate::MediumInterval)), allocator);\n    total.PushBack(normalize(hr-\u003ecalc(Hashrate::LargeInterval)),  allocator);\n\n    for (size_t i = 0; i \u003c Workers::threads(); i++) {\n        rapidjson::Value thread(rapidjson::kArrayType);\n        thread.PushBack(normalize(hr-\u003ecalc(i, Hashrate::ShortInterval)),  allocator);\n        thread.PushBack(normalize(hr-\u003ecalc(i, Hashrate::MediumInterval)), allocator);\n        thread.PushBack(normalize(hr-\u003ecalc(i, Hashrate::LargeInterval)),  allocator);\n\n        threads.PushBack(thread, allocator);\n    }\n\n    hashrate.AddMember(\"total\",   total, allocator);\n    hashrate.AddMember(\"highest\", normalize(hr-\u003ehighest()), allocator);\n    hashrate.AddMember(\"threads\", threads, allocator);\n    doc.AddMember(\"hashrate\", hashrate, allocator);\n}","filepath":"src/api/ApiRouter.cpp","line_number":203,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5112128":{"score":0.49158716,"function_name":"ApiRouter::getThreads","code":"void ApiRouter::getThreads(rapidjson::Document \u0026doc) const\n{\n    doc.SetObject();\n    auto \u0026allocator = doc.GetAllocator();\n    const Hashrate *hr = Workers::hashrate();\n\n    Workers::threadsSummary(doc);\n\n    const std::vector\u003cxmrig::IThread *\u003e \u0026threads = m_controller-\u003econfig()-\u003ethreads();\n    rapidjson::Value list(rapidjson::kArrayType);\n\n    size_t i = 0;\n    for (const xmrig::IThread *thread : threads) {\n        rapidjson::Value value = thread-\u003etoAPI(doc);\n\n        rapidjson::Value hashrate(rapidjson::kArrayType);\n        hashrate.PushBack(normalize(hr-\u003ecalc(i, Hashrate::ShortInterval)),  allocator);\n        hashrate.PushBack(normalize(hr-\u003ecalc(i, Hashrate::MediumInterval)), allocator);\n        hashrate.PushBack(normalize(hr-\u003ecalc(i, Hashrate::LargeInterval)),  allocator);\n\n        i++;\n\n        value.AddMember(\"hashrate\", hashrate, allocator);\n        list.PushBack(value, allocator);\n    }\n\n    doc.AddMember(\"threads\", list, allocator);\n}","filepath":"src/api/ApiRouter.cpp","line_number":285,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5116368":{"score":0.6406405,"function_name":"ApiRouter::setWorkerId","code":"void ApiRouter::setWorkerId(const char *id)\n{\n    memset(m_workerId, 0, sizeof(m_workerId));\n\n    if (id \u0026\u0026 strlen(id) \u003e 0) {\n        strncpy(m_workerId, id, sizeof(m_workerId) - 1);\n    }\n    else {\n        gethostname(m_workerId, sizeof(m_workerId) - 1);\n    }\n}","filepath":"src/api/ApiRouter.cpp","line_number":315,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5116464":{"score":0.7433478,"function_name":"ApiRouter::updateWorkerId","code":"void ApiRouter::updateWorkerId(const char *id, const char *previousId)\n{\n    if (id == previousId) {\n        return;\n    }\n\n    if (id != nullptr \u0026\u0026 previousId != nullptr \u0026\u0026 strcmp(id, previousId) == 0) {\n        return;\n    }\n\n    setWorkerId(id);\n}","filepath":"src/api/ApiRouter.cpp","line_number":328,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5118160":{"score":0.7086898,"function_name":"ApiRouter::finalize","code":"void ApiRouter::finalize(xmrig::HttpReply \u0026reply, rapidjson::Document \u0026doc) const\n{\n    rapidjson::StringBuffer buffer(nullptr, 4096);\n    rapidjson::PrettyWriter\u003crapidjson::StringBuffer\u003e writer(buffer);\n    writer.SetMaxDecimalPlaces(10);\n    doc.Accept(writer);\n\n    reply.status = 200;\n    reply.buf    = strdup(buffer.GetString());\n    reply.size   = buffer.GetSize();\n}","filepath":"src/api/ApiRouter.cpp","line_number":135,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5118656":{"score":0.7914269,"function_name":"ApiRouter::ApiRouter::get","code":"void ApiRouter::ApiRouter::get(const xmrig::HttpRequest \u0026req, xmrig::HttpReply \u0026reply) const\n{\n    rapidjson::Document doc;\n\n    if (req.match(\"/1/config\")) {\n        if (req.isRestricted()) {\n            reply.status = 403;\n            return;\n        }\n\n        m_controller-\u003econfig()-\u003egetJSON(doc);\n\n        return finalize(reply, doc);\n    }\n\n    if (req.match(\"/1/threads\")) {\n        getThreads(doc);\n\n        return finalize(reply, doc);\n    }\n\n    doc.SetObject();\n\n    getIdentify(doc);\n    getMiner(doc);\n    getHashrate(doc);\n    getResults(doc);\n    getConnection(doc);\n\n    return finalize(reply, doc);\n}","filepath":"src/api/ApiRouter.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5130688":{"score":0.57630944,"function_name":"xmrig::Httpd::process","code":"int xmrig::Httpd::process(HttpRequest \u0026req)\n{\n    xmrig::HttpReply reply;\n    if (!req.process(m_accessToken, m_restricted, reply)) {\n        return req.end(reply);\n    }\n\n    if (!req.isFulfilled()) {\n        return MHD_YES;\n    }\n\n    Api::exec(req, reply);\n\n    return req.end(reply);\n}","filepath":"src/common/api/Httpd.cpp","line_number":103,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5130960":{"score":0.76832664,"function_name":"Httpd::Httpd","code":"Httpd::Httpd(int port, const char *accessToken, bool IPv6, bool restricted) :\n    m_idle(true),\n    m_IPv6(IPv6),\n    m_restricted(restricted),\n    m_accessToken(accessToken ? strdup(accessToken) : nullptr),\n    m_port(port),\n    m_daemon(nullptr)\n{\n    uv_timer_init(uv_default_loop(), \u0026m_timer);\n    m_timer.data = this;\n}","filepath":"src/api/Httpd.cpp","line_number":67,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131040":{"score":0.60524726,"function_name":"Httpd::~Httpd","code":"Httpd::~Httpd()\n{\n    uv_timer_stop(\u0026m_timer);\n\n    if (m_daemon) {\n        MHD_stop_daemon(m_daemon);\n    }\n\n    delete m_accessToken;\n}","filepath":"src/api/Httpd.cpp","line_number":80,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131088":{"score":0.73783284,"function_name":"Httpd::start","code":"bool Httpd::start()\n{\n    if (!m_port) {\n        return false;\n    }\n\n    unsigned int flags = 0;\n#   if MHD_VERSION \u003e= 0x00093500\n    if (m_IPv6 \u0026\u0026 MHD_is_feature_supported(MHD_FEATURE_IPv6)) {\n        flags |= MHD_USE_DUAL_STACK;\n    }\n\n    if (MHD_is_feature_supported(MHD_FEATURE_EPOLL)) {\n        flags |= MHD_USE_EPOLL_LINUX_ONLY;\n    }\n#   endif\n\n    m_daemon = MHD_start_daemon(flags, m_port, nullptr, nullptr, \u0026Httpd::handler, this, MHD_OPTION_END);\n    if (!m_daemon) {\n        LOG_ERR(\"HTTP Daemon failed to start.\");\n        return false;\n    }\n\n    uv_timer_start(\u0026m_timer, Httpd::onTimer, kIdleInterval, kIdleInterval);\n    return true;\n}","filepath":"src/api/Httpd.cpp","line_number":92,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131312":{"score":0.6710481,"function_name":"Httpd::process","code":"int Httpd::process(xmrig::HttpRequest \u0026req)\n{\n    xmrig::HttpReply reply;\n    if (!req.process(m_accessToken, m_restricted, reply)) {\n        return req.end(reply);\n    }\n\n    if (!req.isFulfilled()) {\n        return MHD_YES;\n    }\n\n    Api::exec(req, reply);\n\n    return req.end(reply);\n}","filepath":"src/api/Httpd.cpp","line_number":120,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131456":{"score":0.46468878,"function_name":"Httpd::run","code":"void Httpd::run()\n{\n    MHD_run(m_daemon);\n\n    const MHD_DaemonInfo *info = MHD_get_daemon_info(m_daemon, MHD_DAEMON_INFO_CURRENT_CONNECTIONS);\n    if (m_idle \u0026\u0026 info-\u003enum_connections) {\n        uv_timer_set_repeat(\u0026m_timer, kActiveInterval);\n        m_idle = false;\n    }\n    else if (!m_idle \u0026\u0026 !info-\u003enum_connections) {\n        uv_timer_set_repeat(\u0026m_timer, kIdleInterval);\n        m_idle = true;\n    }\n}","filepath":"src/api/Httpd.cpp","line_number":137,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131568":{"score":0.7482935,"function_name":"xmrig::HttpRequest::HttpRequest","code":"xmrig::HttpRequest::HttpRequest(MHD_Connection *connection, const char *url, const char *method, const char *uploadData, size_t *uploadSize, void **cls) :\n    m_fulfilled(true),\n    m_restricted(true),\n    m_uploadData(uploadData),\n    m_url(url),\n    m_body(static_cast\u003cHttpBody*\u003e(*cls)),\n    m_method(Unsupported),\n    m_connection(connection),\n    m_uploadSize(uploadSize),\n    m_cls(cls)\n{\n    if (strcmp(method, MHD_HTTP_METHOD_OPTIONS) == 0) {\n        m_method = Options;\n    }\n    else if (strcmp(method, MHD_HTTP_METHOD_GET) == 0) {\n        m_method = Get;\n    }\n    else if (strcmp(method, MHD_HTTP_METHOD_PUT) == 0) {\n        m_method = Put;\n    }\n}","filepath":"src/api/HttpRequest.cpp","line_number":38,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131776":{"score":0.80149806,"function_name":"xmrig::HttpRequest::process","code":"bool xmrig::HttpRequest::process(const char *accessToken, bool restricted, xmrig::HttpReply \u0026reply)\n{\n    m_restricted = restricted || !accessToken;\n\n    if (m_body) {\n        if (*m_uploadSize != 0) {\n            if (!m_body-\u003ewrite(m_uploadData, *m_uploadSize)) {\n                *m_cls       = nullptr;\n                m_fulfilled  = true;\n                reply.status = MHD_HTTP_PAYLOAD_TOO_LARGE;\n                return false;\n            }\n\n            *m_uploadSize = 0;\n            m_fulfilled   = false;\n            return true;\n        }\n\n        m_fulfilled = true;\n        return true;\n    }\n\n    reply.status = auth(accessToken);\n    if (reply.status != MHD_HTTP_OK) {\n        return false;\n    }\n\n    if (m_restricted \u0026\u0026 m_method != Get) {\n        reply.status = MHD_HTTP_FORBIDDEN;\n        return false;\n    }\n\n    if (m_method == Get) {\n        return true;\n    }\n\n    const char *contentType = MHD_lookup_connection_value(m_connection, MHD_HEADER_KIND, \"Content-Type\");\n    if (!contentType || strcmp(contentType, \"application/json\") != 0) {\n        reply.status = MHD_HTTP_UNSUPPORTED_MEDIA_TYPE;\n        return false;\n    }\n\n    m_body      = new xmrig::HttpBody();\n    m_fulfilled = false;\n    *m_cls      = m_body;\n\n    return true;\n}","filepath":"src/api/HttpRequest.cpp","line_number":75,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5132336":{"score":0.4260537,"function_name":"xmrig::HttpApiResponse::end","code":"void xmrig::HttpApiResponse::end()\n{\n    using namespace rapidjson;\n\n    setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    setHeader(\"Access-Control-Allow-Methods\", \"GET, PUT, POST, DELETE\");\n    setHeader(\"Access-Control-Allow-Headers\", \"Authorization, Content-Type\");\n\n    if (statusCode() \u003e= 400) {\n        if (!m_doc.HasMember(kStatus)) {\n            m_doc.AddMember(StringRef(kStatus), statusCode(), m_doc.GetAllocator());\n        }\n\n        if (!m_doc.HasMember(kError)) {\n            m_doc.AddMember(StringRef(kError), StringRef(http_status_str(static_cast\u003chttp_status\u003e(statusCode()))), m_doc.GetAllocator());\n        }\n    }\n\n    if (!m_doc.MemberCount()) {\n        return HttpResponse::end();\n    }\n\n    setHeader(\"Content-Type\", \"application/json\");\n\n    StringBuffer buffer(nullptr, 4096);\n    PrettyWriter\u003cStringBuffer\u003e writer(buffer);\n    writer.SetMaxDecimalPlaces(10);\n    m_doc.Accept(writer);\n\n    HttpResponse::end(buffer.GetString(), buffer.GetSize());\n}","filepath":"src/base/net/http/HttpApiResponse.cpp","line_number":56,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5132656":{"score":0.86629164,"function_name":"xmrig::HttpRequest::end","code":"int xmrig::HttpRequest::end(int status, MHD_Response *rsp)\n{\n    if (!rsp) {\n        rsp = MHD_create_response_from_buffer(0, nullptr, MHD_RESPMEM_PERSISTENT);\n    }\n\n    MHD_add_response_header(rsp, \"Content-Type\", \"application/json\");\n    MHD_add_response_header(rsp, \"Access-Control-Allow-Origin\", \"*\");\n    MHD_add_response_header(rsp, \"Access-Control-Allow-Methods\", \"GET, PUT\");\n    MHD_add_response_header(rsp, \"Access-Control-Allow-Headers\", \"Authorization\");\n\n    const int ret = MHD_queue_response(m_connection, status, rsp);\n    MHD_destroy_response(rsp);\n    return ret;\n}","filepath":"src/api/HttpRequest.cpp","line_number":141,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5132800":{"score":0.813655,"function_name":"xmrig::HttpRequest::auth","code":"int xmrig::HttpRequest::auth(const char *accessToken)\n{\n    if (!accessToken) {\n        return MHD_HTTP_OK;\n    }\n\n    const char *header = MHD_lookup_connection_value(m_connection, MHD_HEADER_KIND, \"Authorization\");\n    if (accessToken \u0026\u0026 !header) {\n        return MHD_HTTP_UNAUTHORIZED;\n    }\n\n    const size_t size = strlen(header);\n    if (size \u003c 8 || strlen(accessToken) != size - 7 || memcmp(\"Bearer \", header, 7) != 0) {\n        return MHD_HTTP_FORBIDDEN;\n    }\n\n    return strncmp(accessToken, header + 7, strlen(accessToken)) == 0 ? MHD_HTTP_OK : MHD_HTTP_FORBIDDEN;\n}","filepath":"src/api/HttpRequest.cpp","line_number":158,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5132976":{"score":0.7737045,"function_name":"xmrig::Client::Tls::Tls","code":"xmrig::Client::Tls::Tls(Client *client) :\n    m_ready(false),\n    m_buf(),\n    m_fingerprint(),\n    m_client(client),\n    m_ssl(nullptr)\n{\n    m_ctx = SSL_CTX_new(SSLv23_method());\n    assert(m_ctx != nullptr);\n\n    if (!m_ctx) {\n        return;\n    }\n\n    m_writeBio = BIO_new(BIO_s_mem());\n    m_readBio  = BIO_new(BIO_s_mem());\n    SSL_CTX_set_options(m_ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);\n}","filepath":"src/common/net/Tls.cpp","line_number":40,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"5133264":{"score":0.68898106,"function_name":"xmrig::Client::Tls::handshake","code":"bool xmrig::Client::Tls::handshake()\n{\n    m_ssl = SSL_new(m_ctx);\n    assert(m_ssl != nullptr);\n\n    if (!m_ssl) {\n        return false;\n    }\n\n    SSL_set_connect_state(m_ssl);\n    SSL_set_bio(m_ssl, m_readBio, m_writeBio);\n    SSL_do_handshake(m_ssl);\n\n    return send();\n}","filepath":"src/common/net/Tls.cpp","line_number":72,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"5133488":{"score":0.81345,"function_name":"xmrig::Client::Tls::verify","code":"bool xmrig::Client::Tls::verify(X509 *cert)\n{\n    if (cert == nullptr) {\n        LOG_ERR(\"[%s] Failed to get server certificate\", m_client-\u003em_pool.url());\n\n        return false;\n    }\n\n    if (!verifyFingerprint(cert)) {\n        LOG_ERR(\"[%s] Failed to verify server certificate fingerprint\", m_client-\u003em_pool.url());\n\n        const char *fingerprint = m_client-\u003em_pool.fingerprint();\n        if (strlen(m_fingerprint) == 64 \u0026\u0026 fingerprint != nullptr) {\n            LOG_ERR(\"\\\"%s\\\" was given\", m_fingerprint);\n            LOG_ERR(\"\\\"%s\\\" was configured\", fingerprint);\n        }\n\n        return false;\n    }\n\n    return true;\n}","filepath":"src/common/net/Tls.cpp","line_number":148,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"5134000":{"score":0.69572455,"function_name":"xmrig::Client::Tls::read","code":"void xmrig::Client::Tls::read(const char *data, size_t size)\n{\n    BIO_write(m_readBio, data, size);\n\n    if (!SSL_is_init_finished(m_ssl)) {\n        const int rc = SSL_connect(m_ssl);\n\n        if (rc \u003c 0 \u0026\u0026 SSL_get_error(m_ssl, rc) == SSL_ERROR_WANT_READ) {\n            send();\n        } else if (rc == 1) {\n            X509 *cert = SSL_get_peer_certificate(m_ssl);\n            if (!verify(cert)) {\n                X509_free(cert);\n                m_client-\u003eclose();\n\n                return;\n            }\n\n            X509_free(cert);\n            m_ready = true;\n            m_client-\u003elogin();\n      }\n\n      return;\n    }\n\n    int bytes_read = 0;\n    while ((bytes_read = SSL_read(m_ssl, m_buf, sizeof(m_buf))) \u003e 0) {\n        m_client-\u003eparse(m_buf, bytes_read);\n    }\n}","filepath":"src/common/net/Tls.cpp","line_number":109,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"5134272":{"score":0.8709916,"function_name":"xmrig::Client::Tls::verifyFingerprint","code":"bool xmrig::Client::Tls::verifyFingerprint(X509 *cert)\n{\n    const EVP_MD *digest = EVP_get_digestbyname(\"sha256\");\n    if (digest == nullptr) {\n        return false;\n    }\n\n    unsigned char md[EVP_MAX_MD_SIZE];\n    unsigned int dlen;\n\n    if (X509_digest(cert, digest, md, \u0026dlen) != 1) {\n        return false;\n    }\n\n    Job::toHex(md, 32, m_fingerprint);\n    const char *fingerprint = m_client-\u003em_pool.fingerprint();\n\n    return fingerprint == nullptr || strncasecmp(m_fingerprint, fingerprint, 64) == 0;\n}","filepath":"src/common/net/Tls.cpp","line_number":172,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"5134832":{"score":0.56992626,"function_name":"http_parser_init","code":"void\nhttp_parser_init (http_parser *parser, enum http_parser_type t)\n{\n  void *data = parser-\u003edata; /* preserve application data */\n  memset(parser, 0, sizeof(*parser));\n  parser-\u003edata = data;\n  parser-\u003etype = t;\n  parser-\u003estate = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));\n  parser-\u003ehttp_errno = HPE_OK;\n}","filepath":"ext/http/parser/http_parser.c","line_number":2148,"entry_url":"https://github.com/dreamsxin/cphalcon7.git","slot_name":"Dao7-1.3.3-Stable-1"},"5138112":{"score":0.7470383,"function_name":"uv__print_handles","code":"static void uv__print_handles(uv_loop_t* loop, int only_active, FILE* stream) {\n  const char* type;\n  QUEUE* q;\n  uv_handle_t* h;\n\n  if (loop == NULL)\n    loop = uv_default_loop();\n\n  QUEUE_FOREACH(q, \u0026loop-\u003ehandle_queue) {\n    h = QUEUE_DATA(q, uv_handle_t, handle_queue);\n\n    if (only_active \u0026\u0026 !uv__is_active(h))\n      continue;\n\n    switch (h-\u003etype) {\n#define X(uc, lc) case UV_##uc: type = #lc; break;\n      UV_HANDLE_TYPE_MAP(X)\n#undef X\n      default: type = \"\u003cunknown\u003e\";\n    }\n\n    fprintf(stream,\n            \"[%c%c%c] %-8s %p\\n\",\n            \"R-\"[!(h-\u003eflags \u0026 UV__HANDLE_REF)],\n            \"A-\"[!(h-\u003eflags \u0026 UV__HANDLE_ACTIVE)],\n            \"I-\"[!(h-\u003eflags \u0026 UV__HANDLE_INTERNAL)],\n            type,\n            (void*)h);\n  }\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":368,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5138496":{"score":0.8380017,"function_name":"uv__unknown_err_code","code":"static const char* uv__unknown_err_code(int err) {\n  char buf[32];\n  char* copy;\n\n#ifndef _WIN32\n  snprintf(buf, sizeof(buf), \"Unknown system error %d\", err);\n#else\n  _snprintf(buf, sizeof(buf), \"Unknown system error %d\", err);\n#endif\n  copy = uv__strdup(buf);\n\n  return copy != NULL ? copy : \"Unknown system error\";\n}","filepath":"src/uv-common.c","line_number":140,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5138608":{"score":0.81676716,"function_name":"uv__strndup","code":"char* uv__strndup(const char* s, size_t n) {\n  char* m;\n  size_t len = strlen(s);\n  if (n \u003c len)\n    len = n;\n  m = uv__malloc(len + 1);\n  if (m == NULL)\n    return NULL;\n  m[len] = '\\0';\n  return memcpy(m, s, len);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":62,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5138752":{"score":0.9110324,"function_name":"uv_replace_allocator","code":"int uv_replace_allocator(uv_malloc_func malloc_func,\n                         uv_realloc_func realloc_func,\n                         uv_calloc_func calloc_func,\n                         uv_free_func free_func) {\n  if (malloc_func == NULL || realloc_func == NULL ||\n      calloc_func == NULL || free_func == NULL) {\n    return UV_EINVAL;\n  }\n\n  uv__allocator.local_malloc = malloc_func;\n  uv__allocator.local_realloc = realloc_func;\n  uv__allocator.local_calloc = calloc_func;\n  uv__allocator.local_free = free_func;\n\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":97,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5138912":{"score":0.6736739,"function_name":"uv_err_name","code":"const char* uv_err_name(uv_err_t err) {\n  switch (err.code) {\n    case UV_UNKNOWN: return \"UNKNOWN\";\n    case UV_OK: return \"OK\";\n    case UV_EOF: return \"EOF\";\n    case UV_EADDRINFO: return \"EADDRINFO\";\n    case UV_EACCES: return \"EACCES\";\n    case UV_EAGAIN: return \"EAGAIN\";\n    case UV_EADDRINUSE: return \"EADDRINUSE\";\n    case UV_EADDRNOTAVAIL: return \"EADDRNOTAVAIL\";\n    case UV_EAFNOSUPPORT: return \"EAFNOSUPPORT\";\n    case UV_EALREADY: return \"EALREADY\";\n    case UV_EBADF: return \"EBADF\";\n    case UV_EBUSY: return \"EBUSY\";\n    case UV_ECONNABORTED: return \"ECONNABORTED\";\n    case UV_ECONNREFUSED: return \"ECONNREFUSED\";\n    case UV_ECONNRESET: return \"ECONNRESET\";\n    case UV_EDESTADDRREQ: return \"EDESTADDRREQ\";\n    case UV_EFAULT: return \"EFAULT\";\n    case UV_EHOSTUNREACH: return \"EHOSTUNREACH\";\n    case UV_EINTR: return \"EINTR\";\n    case UV_EINVAL: return \"EINVAL\";\n    case UV_EISCONN: return \"EISCONN\";\n    case UV_EMFILE: return \"EMFILE\";\n    case UV_EMSGSIZE: return \"EMSGSIZE\";\n    case UV_ENETDOWN: return \"ENETDOWN\";\n    case UV_ENETUNREACH: return \"ENETUNREACH\";\n    case UV_ENFILE: return \"ENFILE\";\n    case UV_ENOBUFS: return \"ENOBUFS\";\n    case UV_ENOMEM: return \"ENOMEM\";\n    case UV_ENOTDIR: return \"ENOTDIR\";\n    case UV_ENONET: return \"ENONET\";\n    case UV_ENOPROTOOPT: return \"ENOPROTOOPT\";\n    case UV_ENOTCONN: return \"ENOTCONN\";\n    case UV_ENOTSOCK: return \"ENOTSOCK\";\n    case UV_ENOTSUP: return \"ENOTSUP\";\n    case UV_ENOENT: return \"ENOENT\";\n    case UV_ENOSYS: return \"ENOSYS\";\n    case UV_EPIPE: return \"EPIPE\";\n    case UV_EPROTO: return \"EPROTO\";\n    case UV_EPROTONOSUPPORT: return \"EPROTONOSUPPORT\";\n    case UV_EPROTOTYPE: return \"EPROTOTYPE\";\n    case UV_ETIMEDOUT: return \"ETIMEDOUT\";\n    case UV_ECHARSET: return \"ECHARSET\";\n    case UV_EAIFAMNOSUPPORT: return \"EAIFAMNOSUPPORT\";\n    case UV_EAINONAME: return \"EAINONAME\";\n    case UV_EAISERVICE: return \"EAISERVICE\";\n    case UV_EAISOCKTYPE: return \"EAISOCKTYPE\";\n    case UV_ESHUTDOWN: return \"ESHUTDOWN\";\n    case UV_EEXIST: return \"EEXIST\";\n    default:\n      assert(0);\n      return NULL;\n  }\n}","filepath":"src/uv-common.c","line_number":54,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"node-v0.6.0"},"5142720":{"score":0.76938546,"function_name":"uv_ip4_addr","code":"int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr) {\n  memset(addr, 0, sizeof(*addr));\n  addr-\u003esin_family = AF_INET;\n  addr-\u003esin_port = htons(port);\n#ifdef SIN6_LEN\n  addr-\u003esin_len = sizeof(*addr);\n#endif\n  return uv_inet_pton(AF_INET, ip, \u0026(addr-\u003esin_addr.s_addr));\n}","filepath":"wpinet/src/main/native/thirdparty/libuv/src/uv-common.cpp","line_number":221,"entry_url":"https://github.com/wpilibsuite/allwpilib.git","slot_name":"v2023.0.0-alpha-1"},"5142768":{"score":0.742177,"function_name":"uv_ip6_addr","code":"int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr) {\n  char address_part[40];\n  size_t address_part_size;\n  const char* zone_index;\n\n  memset(addr, 0, sizeof(*addr));\n  addr-\u003esin6_family = AF_INET6;\n  addr-\u003esin6_port = htons(port);\n\n  zone_index = strchr(ip, '%');\n  if (zone_index != NULL) {\n    address_part_size = zone_index - ip;\n    if (address_part_size \u003e= sizeof(address_part))\n      address_part_size = sizeof(address_part) - 1;\n\n    memcpy(address_part, ip, address_part_size);\n    address_part[address_part_size] = '\\0';\n    ip = address_part;\n\n    zone_index++; /* skip '%' */\n    /* NOTE: unknown interface (id=0) is silently ignored */\n#ifdef _WIN32\n    addr-\u003esin6_scope_id = atoi(zone_index);\n#else\n    addr-\u003esin6_scope_id = if_nametoindex(zone_index);\n#endif\n  }\n\n  return uv_inet_pton(AF_INET6, ip, \u0026addr-\u003esin6_addr);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":188,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143040":{"score":0.8358867,"function_name":"uv_udp_bind","code":"int uv_udp_bind(uv_udp_t* handle,\n                const struct sockaddr* addr,\n                unsigned int flags) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_UDP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__udp_bind(handle, addr, addrlen, flags);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":249,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143168":{"score":0.75960433,"function_name":"uv_tcp_connect","code":"int uv_tcp_connect(uv_connect_t* req,\n                   uv_tcp_t* handle,\n                   const struct sockaddr* addr,\n                   uv_connect_cb cb) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_TCP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__tcp_connect(req, handle, addr, addrlen, cb);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":268,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143232":{"score":0.7701514,"function_name":"uv_udp_send","code":"int uv_udp_send(uv_udp_send_t* req,\n                uv_udp_t* handle,\n                const uv_buf_t bufs[],\n                unsigned int nbufs,\n                const struct sockaddr* addr,\n                uv_udp_send_cb send_cb) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_UDP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__udp_send(req, handle, bufs, nbufs, addr, addrlen, send_cb);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":288,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143312":{"score":0.7961098,"function_name":"uv_udp_try_send","code":"int uv_udp_try_send(uv_udp_t* handle,\n                    const uv_buf_t bufs[],\n                    unsigned int nbufs,\n                    const struct sockaddr* addr) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_UDP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__udp_try_send(handle, bufs, nbufs, addr, addrlen);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":310,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143376":{"score":0.8180127,"function_name":"uv_udp_recv_start","code":"int uv_udp_recv_start(uv_udp_t* handle,\n                      uv_alloc_cb alloc_cb,\n                      uv_udp_recv_cb recv_cb) {\n  if (handle-\u003etype != UV_UDP || alloc_cb == NULL || recv_cb == NULL)\n    return UV_EINVAL;\n  else\n    return uv__udp_recv_start(handle, alloc_cb, recv_cb);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":330,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143440":{"score":0.8067045,"function_name":"uv_walk","code":"void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg) {\n  QUEUE queue;\n  QUEUE* q;\n  uv_handle_t* h;\n\n  QUEUE_MOVE(\u0026loop-\u003ehandle_queue, \u0026queue);\n  while (!QUEUE_EMPTY(\u0026queue)) {\n    q = QUEUE_HEAD(\u0026queue);\n    h = QUEUE_DATA(q, uv_handle_t, handle_queue);\n\n    QUEUE_REMOVE(q);\n    QUEUE_INSERT_TAIL(\u0026loop-\u003ehandle_queue, q);\n\n    if (h-\u003eflags \u0026 UV__HANDLE_INTERNAL) continue;\n    walk_cb(h, arg);\n  }\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":349,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143792":{"score":0.82208586,"function_name":"uv__count_bufs","code":"size_t uv__count_bufs(const uv_buf_t bufs[], unsigned int nbufs) {\n  unsigned int i;\n  size_t bytes;\n\n  bytes = 0;\n  for (i = 0; i \u003c nbufs; i++)\n    bytes += (size_t) bufs[i].len;\n\n  return bytes;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":436,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5143888":{"score":0.7652104,"function_name":"uv_fs_event_getpath","code":"int uv_fs_event_getpath(uv_fs_event_t* handle, char* buffer, size_t* size) {\n  size_t required_len;\n\n  if (!uv__is_active(handle)) {\n    *size = 0;\n    return UV_EINVAL;\n  }\n\n  required_len = strlen(handle-\u003epath);\n  if (required_len \u003e= *size) {\n    *size = required_len + 1;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, handle-\u003epath, required_len);\n  *size = required_len;\n  buffer[required_len] = '\\0';\n\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":455,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5144000":{"score":0.58960396,"function_name":"uv__fs_scandir_cleanup","code":"void uv__fs_scandir_cleanup(uv_fs_t* req) {\n  uv__dirent_t** dents;\n\n  unsigned int* nbufs = uv__get_nbufs(req);\n\n  dents = req-\u003eptr;\n  if (*nbufs \u003e 0 \u0026\u0026 *nbufs != (unsigned int) req-\u003eresult)\n    (*nbufs)--;\n  for (; *nbufs \u003c (unsigned int) req-\u003eresult; (*nbufs)++)\n    uv__fs_scandir_free(dents[*nbufs]);\n\n  uv__fs_scandir_free(req-\u003eptr);\n  req-\u003eptr = NULL;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":498,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5144112":{"score":0.47388023,"function_name":"uv_fs_scandir_next","code":"int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {\n  uv__dirent_t** dents;\n  uv__dirent_t* dent;\n  unsigned int* nbufs;\n\n  /* Check to see if req passed */\n  if (req-\u003eresult \u003c 0)\n    return req-\u003eresult;\n\n  /* Ptr will be null if req was canceled or no files found */\n  if (!req-\u003eptr)\n    return UV_EOF;\n\n  nbufs = uv__get_nbufs(req);\n  assert(nbufs);\n\n  dents = req-\u003eptr;\n\n  /* Free previous entity */\n  if (*nbufs \u003e 0)\n    uv__fs_scandir_free(dents[*nbufs - 1]);\n\n  /* End was already reached */\n  if (*nbufs == (unsigned int) req-\u003eresult) {\n    uv__fs_scandir_free(dents);\n    req-\u003eptr = NULL;\n    return UV_EOF;\n  }\n\n  dent = dents[(*nbufs)++];\n\n  ent-\u003ename = dent-\u003ed_name;\n#ifdef HAVE_DIRENT_TYPES\n  switch (dent-\u003ed_type) {\n    case UV__DT_DIR:\n      ent-\u003etype = UV_DIRENT_DIR;\n      break;\n    case UV__DT_FILE:\n      ent-\u003etype = UV_DIRENT_FILE;\n      break;\n    case UV__DT_LINK:\n      ent-\u003etype = UV_DIRENT_LINK;\n      break;\n    case UV__DT_FIFO:\n      ent-\u003etype = UV_DIRENT_FIFO;\n      break;\n    case UV__DT_SOCKET:\n      ent-\u003etype = UV_DIRENT_SOCKET;\n      break;\n    case UV__DT_CHAR:\n      ent-\u003etype = UV_DIRENT_CHAR;\n      break;\n    case UV__DT_BLOCK:\n      ent-\u003etype = UV_DIRENT_BLOCK;\n      break;\n    default:\n      ent-\u003etype = UV_DIRENT_UNKNOWN;\n  }\n#else\n  ent-\u003etype = UV_DIRENT_UNKNOWN;\n#endif\n\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":514,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5144384":{"score":0.6835327,"function_name":"uv_loop_configure","code":"int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...) {\n  va_list ap;\n  int err;\n\n  va_start(ap, option);\n  /* Any platform-agnostic options should be handled here. */\n  err = uv__loop_configure(loop, option, ap);\n  va_end(ap);\n\n  return err;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":580,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5144576":{"score":0.84117174,"function_name":"uv_default_loop","code":"uv_loop_t* uv_default_loop(void) {\n  if (default_loop_ptr != NULL)\n    return default_loop_ptr;\n\n  if (uv_loop_init(\u0026default_loop_struct))\n    return NULL;\n\n  default_loop_ptr = \u0026default_loop_struct;\n  return default_loop_ptr;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":597,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5144640":{"score":0.78572357,"function_name":"uv_loop_new","code":"uv_loop_t* uv_loop_new(void) {\n  uv_loop_t* loop;\n\n  loop = uv__malloc(sizeof(*loop));\n  if (loop == NULL)\n    return NULL;\n\n  if (uv_loop_init(loop)) {\n    uv__free(loop);\n    return NULL;\n  }\n\n  return loop;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":609,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5144720":{"score":0.75546044,"function_name":"uv_loop_close","code":"int uv_loop_close(uv_loop_t* loop) {\n  QUEUE* q;\n  uv_handle_t* h;\n#ifndef NDEBUG\n  void* saved_data;\n#endif\n\n  if (uv__has_active_reqs(loop))\n    return UV_EBUSY;\n\n  QUEUE_FOREACH(q, \u0026loop-\u003ehandle_queue) {\n    h = QUEUE_DATA(q, uv_handle_t, handle_queue);\n    if (!(h-\u003eflags \u0026 UV__HANDLE_INTERNAL))\n      return UV_EBUSY;\n  }\n\n  uv__loop_close(loop);\n\n#ifndef NDEBUG\n  saved_data = loop-\u003edata;\n  memset(loop, -1, sizeof(*loop));\n  loop-\u003edata = saved_data;\n#endif\n  if (loop == default_loop_ptr)\n    default_loop_ptr = NULL;\n\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":625,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5144880":{"score":0.9063461,"function_name":"uv_loop_delete","code":"void uv_loop_delete(uv_loop_t* loop) {\n  uv_loop_t* default_loop;\n  int err;\n\n  default_loop = default_loop_ptr;\n\n  err = uv_loop_close(loop);\n  (void) err;    /* Squelch compiler warnings. */\n  assert(err == 0);\n  if (loop != default_loop)\n    uv__free(loop);\n}","filepath":"Utilities/cmlibuv/src/uv-common.c","line_number":655,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.12.0-rc1"},"5145424":{"score":0.7277612,"function_name":"uv__async_start","code":"int uv__async_start(uv_loop_t* loop, struct uv__async* wa, uv__async_cb cb) {\n  int pipefd[2];\n  int err;\n\n  if (wa-\u003eio_watcher.fd != -1)\n    return 0;\n\n  err = uv__async_eventfd();\n  if (err \u003e= 0) {\n    pipefd[0] = err;\n    pipefd[1] = -1;\n  }\n  else if (err == -ENOSYS) {\n    err = uv__make_pipe(pipefd, UV__F_NONBLOCK);\n#if defined(__linux__)\n    /* Save a file descriptor by opening one of the pipe descriptors as\n     * read/write through the procfs.  That file descriptor can then\n     * function as both ends of the pipe.\n     */\n    if (err == 0) {\n      char buf[32];\n      int fd;\n\n      snprintf(buf, sizeof(buf), \"/proc/self/fd/%d\", pipefd[0]);\n      fd = uv__open_cloexec(buf, O_RDWR);\n      if (fd != -1) {\n        uv__close(pipefd[0]);\n        uv__close(pipefd[1]);\n        pipefd[0] = fd;\n        pipefd[1] = fd;\n      }\n    }\n#endif\n  }\n\n  if (err \u003c 0)\n    return err;\n\n  uv__io_init(\u0026wa-\u003eio_watcher, uv__async_io, pipefd[0]);\n  uv__io_start(loop, \u0026wa-\u003eio_watcher, UV__POLLIN);\n  wa-\u003ewfd = pipefd[1];\n  wa-\u003ecb = cb;\n\n  return 0;\n}","filepath":"src/unix/async.c","line_number":209,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.24"},"5145872":{"score":0.731029,"function_name":"uv_async_init","code":"int uv_async_init(uv_loop_t* loop, uv_async_t* handle, uv_async_cb async_cb) {\n  int err;\n\n  err = uv__async_start(loop, \u0026loop-\u003easync_watcher, uv__async_event);\n  if (err)\n    return err;\n\n  uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);\n  handle-\u003easync_cb = async_cb;\n  handle-\u003epending = 0;\n\n  QUEUE_INSERT_TAIL(\u0026loop-\u003easync_handles, \u0026handle-\u003equeue);\n  uv__handle_start(handle);\n\n  return 0;\n}","filepath":"src/unix/async.c","line_number":41,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.14"},"5146368":{"score":0.86919624,"function_name":"uv__async_stop","code":"void uv__async_stop(uv_loop_t* loop, struct uv__async* wa) {\n  if (wa-\u003eio_watcher.fd == -1)\n    return;\n\n  if (wa-\u003ewfd != -1) {\n    if (wa-\u003ewfd != wa-\u003eio_watcher.fd)\n      uv__close(wa-\u003ewfd);\n    wa-\u003ewfd = -1;\n  }\n\n  uv__io_stop(loop, \u0026wa-\u003eio_watcher, POLLIN);\n  uv__close(wa-\u003eio_watcher.fd);\n  wa-\u003eio_watcher.fd = -1;\n}","filepath":"external/iotjs/deps/libtuv/src/unix/async.c","line_number":258,"entry_url":"https://github.com/Samsung/TizenRT.git","slot_name":"1.1_Public_Release"},"5146480":{"score":0.80339366,"function_name":"uv__socket_sockopt","code":"int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {\n  int r;\n  int fd;\n  socklen_t len;\n\n  if (handle == NULL || value == NULL)\n    return -EINVAL;\n\n  if (handle-\u003etype == UV_TCP || handle-\u003etype == UV_NAMED_PIPE)\n    fd = uv__stream_fd((uv_stream_t*) handle);\n  else if (handle-\u003etype == UV_UDP)\n    fd = ((uv_udp_t *) handle)-\u003eio_watcher.fd;\n  else\n    return -ENOTSUP;\n\n  len = sizeof(*value);\n\n  if (*value == 0)\n    r = getsockopt(fd, SOL_SOCKET, optname, value, \u0026len);\n  else\n    r = setsockopt(fd, SOL_SOCKET, optname, (const void*) value, len);\n\n  if (r \u003c 0)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":167,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5146688":{"score":0.60876137,"function_name":"uv__finish_close","code":"static void uv__finish_close(uv_handle_t* handle) {\n  /* Note: while the handle is in the UV_CLOSING state now, it's still possible\n   * for it to be active in the sense that uv__is_active() returns true.\n   * A good example is when the user calls uv_shutdown(), immediately followed\n   * by uv_close(). The handle is considered active at this point because the\n   * completion of the shutdown req is still pending.\n   */\n  assert(handle-\u003eflags \u0026 UV_CLOSING);\n  assert(!(handle-\u003eflags \u0026 UV_CLOSED));\n  handle-\u003eflags |= UV_CLOSED;\n\n  switch (handle-\u003etype) {\n    case UV_PREPARE:\n    case UV_CHECK:\n    case UV_IDLE:\n    case UV_ASYNC:\n    case UV_TIMER:\n    case UV_PROCESS:\n    case UV_FS_EVENT:\n    case UV_FS_POLL:\n    case UV_POLL:\n    case UV_SIGNAL:\n      break;\n\n    case UV_NAMED_PIPE:\n    case UV_TCP:\n    case UV_TTY:\n      uv__stream_destroy((uv_stream_t*)handle);\n      break;\n\n    case UV_UDP:\n      uv__udp_finish_close((uv_udp_t*)handle);\n      break;\n\n    default:\n      assert(0);\n      break;\n  }\n\n  uv__handle_unref(handle);\n  QUEUE_REMOVE(\u0026handle-\u003ehandle_queue);\n\n  if (handle-\u003eclose_cb) {\n    handle-\u003eclose_cb(handle);\n  }\n}","filepath":"src/unix/core.c","line_number":216,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5146784":{"score":0.88421667,"function_name":"uv_close","code":"void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!(handle-\u003eflags \u0026 (UV_CLOSING | UV_CLOSED)));\n\n  handle-\u003eflags |= UV_CLOSING;\n  handle-\u003eclose_cb = close_cb;\n\n  switch (handle-\u003etype) {\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n\n  case UV_UDP:\n    uv__udp_close((uv_udp_t*)handle);\n    break;\n\n  case UV_PREPARE:\n    uv__prepare_close((uv_prepare_t*)handle);\n    break;\n\n  case UV_CHECK:\n    uv__check_close((uv_check_t*)handle);\n    break;\n\n  case UV_IDLE:\n    uv__idle_close((uv_idle_t*)handle);\n    break;\n\n  case UV_ASYNC:\n    uv__async_close((uv_async_t*)handle);\n    break;\n\n  case UV_TIMER:\n    uv__timer_close((uv_timer_t*)handle);\n    break;\n\n  case UV_PROCESS:\n    uv__process_close((uv_process_t*)handle);\n    break;\n\n  case UV_FS_EVENT:\n    uv__fs_event_close((uv_fs_event_t*)handle);\n    break;\n\n  case UV_POLL:\n    uv__poll_close((uv_poll_t*)handle);\n    break;\n\n  case UV_FS_POLL:\n    uv__fs_poll_close((uv_fs_poll_t*)handle);\n    break;\n\n  case UV_SIGNAL:\n    uv__signal_close((uv_signal_t*) handle);\n    /* Signal handles may not be closed immediately. The signal code will */\n    /* itself close uv__make_close_pending whenever appropriate. */\n    return;\n\n  default:\n    assert(0);\n  }\n\n  uv__make_close_pending(handle);\n}","filepath":"src/unix/core.c","line_number":95,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5147168":{"score":0.690789,"function_name":"uv_backend_timeout","code":"int uv_backend_timeout(const uv_loop_t* loop) {\n  if (loop-\u003estop_flag != 0)\n    return 0;\n\n  if (!uv__has_active_handles(loop) \u0026\u0026 !uv__has_active_reqs(loop))\n    return 0;\n\n  if (!QUEUE_EMPTY(\u0026loop-\u003eidle_handles))\n    return 0;\n\n  if (!QUEUE_EMPTY(\u0026loop-\u003epending_queue))\n    return 0;\n\n  if (loop-\u003eclosing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}","filepath":"src/unix/core.c","line_number":289,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5147296":{"score":0.65864,"function_name":"uv_run","code":"int uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r)\n    uv__update_time(loop);\n\n  while (r != 0 \u0026\u0026 loop-\u003estop_flag == 0) {\n    uv__update_time(loop);\n    uv__run_timers(loop);\n    ran_pending = uv__run_pending(loop);\n    uv__run_idle(loop);\n    uv__run_prepare(loop);\n\n    timeout = 0;\n    if ((mode == UV_RUN_ONCE \u0026\u0026 !ran_pending) || mode == UV_RUN_DEFAULT)\n      timeout = uv_backend_timeout(loop);\n\n    uv__io_poll(loop, timeout);\n    uv__run_check(loop);\n    uv__run_closing_handles(loop);\n\n    if (mode == UV_RUN_ONCE) {\n      /* UV_RUN_ONCE implies forward progress: at least one callback must have\n       * been invoked when it returns. uv__io_poll() can return without doing\n       * I/O (meaning: no callbacks) when its timeout expires - which means we\n       * have pending timers that satisfy the forward progress constraint.\n       *\n       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from\n       * the check.\n       */\n      uv__update_time(loop);\n      uv__run_timers(loop);\n    }\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)\n      break;\n  }\n\n  /* The if statement lets gcc compile it to a conditional store. Avoids\n   * dirtying a cache line.\n   */\n  if (loop-\u003estop_flag != 0)\n    loop-\u003estop_flag = 0;\n\n  return r;\n}","filepath":"src/unix/core.c","line_number":321,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5148368":{"score":0.9075765,"function_name":"uv__close","code":"int uv__close(int fd) {\n  int saved_errno;\n  int rc;\n\n  assert(fd \u003e -1);  /* Catch uninitialized io_watcher.fd bugs. */\n  assert(fd \u003e STDERR_FILENO);  /* Catch stdio close bugs. */\n\n  saved_errno = errno;\n  rc = close(fd);\n  if (rc == -1) {\n    rc = -errno;\n    if (rc == -EINTR)\n      rc = -EINPROGRESS;  /* For platform/libc consistency. */\n    errno = saved_errno;\n  }\n\n  return rc;\n}","filepath":"src/unix/core.c","line_number":472,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5148496":{"score":0.80225533,"function_name":"uv__nonblock","code":"int uv__nonblock(int fd, int set) {\n  int r;\n\n  do\n    r = ioctl(fd, FIONBIO, \u0026set);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":495,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5148592":{"score":0.66314256,"function_name":"uv__cloexec","code":"int uv__cloexec(int fd, int set) {\n  int flags;\n  int r;\n\n  do\n    r = fcntl(fd, F_GETFD);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r == -1)\n    return -errno;\n\n  /* Bail out now if already set/clear. */\n  if (!!(r \u0026 FD_CLOEXEC) == !!set)\n    return 0;\n\n  if (set)\n    flags = r | FD_CLOEXEC;\n  else\n    flags = r \u0026 ~FD_CLOEXEC;\n\n  do\n    r = fcntl(fd, F_SETFD, flags);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":556,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5148704":{"score":0.80075824,"function_name":"uv__socket","code":"int uv__socket(int domain, int type, int protocol) {\n  int sockfd;\n  int err;\n\n#if defined(SOCK_NONBLOCK) \u0026\u0026 defined(SOCK_CLOEXEC)\n  sockfd = socket(domain, type | SOCK_NONBLOCK | SOCK_CLOEXEC, protocol);\n  if (sockfd != -1)\n    return sockfd;\n\n  if (errno != EINVAL)\n    return -errno;\n#endif\n\n  sockfd = socket(domain, type, protocol);\n  if (sockfd == -1)\n    return -errno;\n\n  err = uv__nonblock(sockfd, 1);\n  if (err == 0)\n    err = uv__cloexec(sockfd, 1);\n\n  if (err) {\n    uv__close(sockfd);\n    return err;\n  }\n\n#if defined(SO_NOSIGPIPE)\n  {\n    int on = 1;\n    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, \u0026on, sizeof(on));\n  }\n#endif\n\n  return sockfd;\n}","filepath":"src/unix/core.c","line_number":384,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5148880":{"score":0.9158814,"function_name":"uv__accept","code":"int uv__accept(int sockfd) {\n  int peerfd;\n  int err;\n\n  assert(sockfd \u003e= 0);\n\n  while (1) {\n#if defined(__linux__)                          || \\\n    (defined(__FreeBSD__) \u0026\u0026 __FreeBSD__ \u003e= 10) || \\\n    defined(__NetBSD__)\n    static int no_accept4;\n\n    if (no_accept4)\n      goto skip;\n\n    peerfd = uv__accept4(sockfd,\n                         NULL,\n                         NULL,\n                         UV__SOCK_NONBLOCK|UV__SOCK_CLOEXEC);\n    if (peerfd != -1)\n      return peerfd;\n\n    if (errno == EINTR)\n      continue;\n\n    if (errno != ENOSYS)\n      return -errno;\n\n    no_accept4 = 1;\nskip:\n#endif\n\n    peerfd = accept(sockfd, NULL, NULL);\n    if (peerfd == -1) {\n      if (errno == EINTR)\n        continue;\n      return -errno;\n    }\n\n    err = uv__cloexec(peerfd, 1);\n    if (err == 0)\n      err = uv__nonblock(peerfd, 1);\n\n    if (err) {\n      uv__close(peerfd);\n      return err;\n    }\n\n    return peerfd;\n  }\n}","filepath":"src/unix/core.c","line_number":464,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.16.0"},"5149088":{"score":0.76210856,"function_name":"uv__dup","code":"int uv__dup(int fd) {\n  int err;\n\n  fd = dup(fd);\n\n  if (fd == -1)\n    return -errno;\n\n  err = uv__cloexec(fd, 1);\n  if (err) {\n    uv__close(fd);\n    return err;\n  }\n\n  return fd;\n}","filepath":"src/unix/core.c","line_number":593,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5149168":{"score":0.7959493,"function_name":"uv__recvmsg","code":"ssize_t uv__recvmsg(int fd, struct msghdr* msg, int flags) {\n  struct cmsghdr* cmsg;\n  ssize_t rc;\n  int* pfd;\n  int* end;\n#if defined(__linux__)\n  static int no_msg_cmsg_cloexec;\n  if (no_msg_cmsg_cloexec == 0) {\n    rc = recvmsg(fd, msg, flags | 0x40000000);  /* MSG_CMSG_CLOEXEC */\n    if (rc != -1)\n      return rc;\n    if (errno != EINVAL)\n      return -errno;\n    rc = recvmsg(fd, msg, flags);\n    if (rc == -1)\n      return -errno;\n    no_msg_cmsg_cloexec = 1;\n  } else {\n    rc = recvmsg(fd, msg, flags);\n  }\n#else\n  rc = recvmsg(fd, msg, flags);\n#endif\n  if (rc == -1)\n    return -errno;\n  if (msg-\u003emsg_controllen == 0)\n    return rc;\n  for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg))\n    if (cmsg-\u003ecmsg_type == SCM_RIGHTS)\n      for (pfd = (int*) CMSG_DATA(cmsg),\n           end = (int*) ((char*) cmsg + cmsg-\u003ecmsg_len);\n           pfd \u003c end;\n           pfd += 1)\n        uv__cloexec(*pfd, 1);\n  return rc;\n}","filepath":"src/unix/core.c","line_number":611,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5149504":{"score":0.82737815,"function_name":"uv_cwd","code":"int uv_cwd(char* buffer, size_t* size) {\n  if (buffer == NULL || size == NULL)\n    return -EINVAL;\n\n  if (getcwd(buffer, *size) == NULL)\n    return -errno;\n\n  *size = strlen(buffer);\n  if (*size \u003e 1 \u0026\u0026 buffer[*size - 1] == '/') {\n    buffer[*size-1] = '\\0';\n    (*size)--;\n  }\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":649,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5149728":{"score":0.84084487,"function_name":"uv_fileno","code":"int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {\n  int fd_out;\n\n  switch (handle-\u003etype) {\n  case UV_TCP:\n  case UV_NAMED_PIPE:\n  case UV_TTY:\n    fd_out = uv__stream_fd((uv_stream_t*) handle);\n    break;\n\n  case UV_UDP:\n    fd_out = ((uv_udp_t *) handle)-\u003eio_watcher.fd;\n    break;\n\n  case UV_POLL:\n    fd_out = ((uv_poll_t *) handle)-\u003eio_watcher.fd;\n    break;\n\n  default:\n    return -EINVAL;\n  }\n\n  if (uv__is_closing(handle) || fd_out == -1)\n    return -EBADF;\n\n  *fd = fd_out;\n  return 0;\n}","filepath":"src/unix/core.c","line_number":686,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5149840":{"score":0.92669904,"function_name":"uv__io_init","code":"void uv__io_init(uv__io_t* w, uv__io_cb cb, int fd) {\n  assert(cb != NULL);\n  assert(fd \u003e= -1);\n  QUEUE_INIT(\u0026w-\u003epending_queue);\n  QUEUE_INIT(\u0026w-\u003ewatcher_queue);\n  w-\u003ecb = cb;\n  w-\u003efd = fd;\n  w-\u003eevents = 0;\n  w-\u003epevents = 0;\n\n#if defined(UV_HAVE_KQUEUE)\n  w-\u003ercount = 0;\n  w-\u003ewcount = 0;\n#endif /* defined(UV_HAVE_KQUEUE) */\n}","filepath":"src/unix/core.c","line_number":786,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5149968":{"score":0.8832166,"function_name":"uv__io_start","code":"void uv__io_start(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events \u0026 ~(UV__POLLIN | UV__POLLOUT)));\n  assert(0 != events);\n  assert(w-\u003efd \u003e= 0);\n  assert(w-\u003efd \u003c INT_MAX);\n\n  w-\u003epevents |= events;\n  maybe_resize(loop, w-\u003efd + 1);\n\n#if !defined(__sun)\n  /* The event ports backend needs to rearm all file descriptors on each and\n   * every tick of the event loop but the other backends allow us to\n   * short-circuit here if the event mask is unchanged.\n   */\n  if (w-\u003eevents == w-\u003epevents) {\n    if (w-\u003eevents == 0 \u0026\u0026 !QUEUE_EMPTY(\u0026w-\u003ewatcher_queue)) {\n      QUEUE_REMOVE(\u0026w-\u003ewatcher_queue);\n      QUEUE_INIT(\u0026w-\u003ewatcher_queue);\n    }\n    return;\n  }\n#endif\n\n  if (QUEUE_EMPTY(\u0026w-\u003ewatcher_queue))\n    QUEUE_INSERT_TAIL(\u0026loop-\u003ewatcher_queue, \u0026w-\u003ewatcher_queue);\n\n  if (loop-\u003ewatchers[w-\u003efd] == NULL) {\n    loop-\u003ewatchers[w-\u003efd] = w;\n    loop-\u003enfds++;\n  }\n}","filepath":"src/unix/core.c","line_number":803,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5150512":{"score":0.8844054,"function_name":"uv__io_stop","code":"void uv__io_stop(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events \u0026 ~(UV__POLLIN | UV__POLLOUT)));\n  assert(0 != events);\n\n  if (w-\u003efd == -1)\n    return;\n\n  assert(w-\u003efd \u003e= 0);\n\n  /* Happens when uv__io_stop() is called on a handle that was never started. */\n  if ((unsigned) w-\u003efd \u003e= loop-\u003enwatchers)\n    return;\n\n  w-\u003epevents \u0026= ~events;\n\n  if (w-\u003epevents == 0) {\n    QUEUE_REMOVE(\u0026w-\u003ewatcher_queue);\n    QUEUE_INIT(\u0026w-\u003ewatcher_queue);\n\n    if (loop-\u003ewatchers[w-\u003efd] != NULL) {\n      assert(loop-\u003ewatchers[w-\u003efd] == w);\n      assert(loop-\u003enfds \u003e 0);\n      loop-\u003ewatchers[w-\u003efd] = NULL;\n      loop-\u003enfds--;\n      w-\u003eevents = 0;\n    }\n  }\n  else if (QUEUE_EMPTY(\u0026w-\u003ewatcher_queue))\n    QUEUE_INSERT_TAIL(\u0026loop-\u003ewatcher_queue, \u0026w-\u003ewatcher_queue);\n}","filepath":"src/unix/core.c","line_number":836,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5151024":{"score":0.62654835,"function_name":"uv_getrusage","code":"int uv_getrusage(uv_rusage_t* rusage) {\n  struct rusage usage;\n\n  if (getrusage(RUSAGE_SELF, \u0026usage))\n    return -errno;\n\n  rusage-\u003eru_utime.tv_sec = usage.ru_utime.tv_sec;\n  rusage-\u003eru_utime.tv_usec = usage.ru_utime.tv_usec;\n\n  rusage-\u003eru_stime.tv_sec = usage.ru_stime.tv_sec;\n  rusage-\u003eru_stime.tv_usec = usage.ru_stime.tv_usec;\n\n  rusage-\u003eru_maxrss = usage.ru_maxrss;\n  rusage-\u003eru_ixrss = usage.ru_ixrss;\n  rusage-\u003eru_idrss = usage.ru_idrss;\n  rusage-\u003eru_isrss = usage.ru_isrss;\n  rusage-\u003eru_minflt = usage.ru_minflt;\n  rusage-\u003eru_majflt = usage.ru_majflt;\n  rusage-\u003eru_nswap = usage.ru_nswap;\n  rusage-\u003eru_inblock = usage.ru_inblock;\n  rusage-\u003eru_oublock = usage.ru_oublock;\n  rusage-\u003eru_msgsnd = usage.ru_msgsnd;\n  rusage-\u003eru_msgrcv = usage.ru_msgrcv;\n  rusage-\u003eru_nsignals = usage.ru_nsignals;\n  rusage-\u003eru_nvcsw = usage.ru_nvcsw;\n  rusage-\u003eru_nivcsw = usage.ru_nivcsw;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":890,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5151296":{"score":0.8283495,"function_name":"uv__open_cloexec","code":"int uv__open_cloexec(const char* path, int flags) {\n  int err;\n  int fd;\n\n#if defined(__linux__) || (defined(__FreeBSD__) \u0026\u0026 __FreeBSD__ \u003e= 9) || \\\n    defined(__DragonFly__)\n  static int no_cloexec;\n\n  if (!no_cloexec) {\n    fd = open(path, flags | UV__O_CLOEXEC);\n    if (fd != -1)\n      return fd;\n\n    if (errno != EINVAL)\n      return -errno;\n\n    /* O_CLOEXEC not supported. */\n    no_cloexec = 1;\n  }\n#endif\n\n  fd = open(path, flags);\n  if (fd == -1)\n    return -errno;\n\n  err = uv__cloexec(fd, 1);\n  if (err) {\n    uv__close(fd);\n    return err;\n  }\n\n  return fd;\n}","filepath":"src/unix/core.c","line_number":921,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5151456":{"score":0.83015394,"function_name":"uv__dup2_cloexec","code":"int uv__dup2_cloexec(int oldfd, int newfd) {\n  int r;\n#if defined(__FreeBSD__) \u0026\u0026 __FreeBSD__ \u003e= 10\n  do\n    r = dup3(oldfd, newfd, O_CLOEXEC);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n  if (r == -1)\n    return -errno;\n  return r;\n#elif defined(__FreeBSD__) \u0026\u0026 defined(F_DUP2FD_CLOEXEC)\n  do\n    r = fcntl(oldfd, F_DUP2FD_CLOEXEC, newfd);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n  if (r != -1)\n    return r;\n  if (errno != EINVAL)\n    return -errno;\n  /* Fall through. */\n#elif defined(__linux__)\n  static int no_dup3;\n  if (!no_dup3) {\n    do\n      r = uv__dup3(oldfd, newfd, UV__O_CLOEXEC);\n    while (r == -1 \u0026\u0026 (errno == EINTR || errno == EBUSY));\n    if (r != -1)\n      return r;\n    if (errno != ENOSYS)\n      return -errno;\n    /* Fall through. */\n    no_dup3 = 1;\n  }\n#endif\n  {\n    int err;\n    do\n      r = dup2(oldfd, newfd);\n#if defined(__linux__)\n    while (r == -1 \u0026\u0026 (errno == EINTR || errno == EBUSY));\n#else\n    while (r == -1 \u0026\u0026 errno == EINTR);\n#endif\n\n    if (r == -1)\n      return -errno;\n\n    err = uv__cloexec(newfd, 1);\n    if (err) {\n      uv__close(newfd);\n      return err;\n    }\n\n    return r;\n  }\n}","filepath":"src/unix/core.c","line_number":956,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5151648":{"score":0.73847866,"function_name":"uv_os_homedir","code":"int uv_os_homedir(char* buffer, size_t* size) {\n  struct passwd pw;\n  struct passwd* result;\n  char* buf;\n  uid_t uid;\n  size_t bufsize;\n  size_t len;\n  long initsize;\n  int r;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return -EINVAL;\n\n  /* Check if the HOME environment variable is set first */\n  buf = getenv(\"HOME\");\n\n  if (buf != NULL) {\n    len = strlen(buf);\n\n    if (len \u003e= *size) {\n      *size = len;\n      return -ENOBUFS;\n    }\n\n    memcpy(buffer, buf, len + 1);\n    *size = len;\n\n    return 0;\n  }\n\n  /* HOME is not set, so call getpwuid() */\n  initsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n\n  if (initsize \u003c= 0)\n    bufsize = 4096;\n  else\n    bufsize = (size_t) initsize;\n\n  uid = getuid();\n  buf = NULL;\n\n  for (;;) {\n    uv__free(buf);\n    buf = uv__malloc(bufsize);\n\n    if (buf == NULL)\n      return -ENOMEM;\n\n    r = getpwuid_r(uid, \u0026pw, buf, bufsize, \u0026result);\n\n    if (r != ERANGE)\n      break;\n\n    bufsize *= 2;\n  }\n\n  if (r != 0) {\n    uv__free(buf);\n    return -r;\n  }\n\n  if (result == NULL) {\n    uv__free(buf);\n    return -ENOENT;\n  }\n\n  len = strlen(pw.pw_dir);\n\n  if (len \u003e= *size) {\n    *size = len;\n    uv__free(buf);\n    return -ENOBUFS;\n  }\n\n  memcpy(buffer, pw.pw_dir, len + 1);\n  *size = len;\n  uv__free(buf);\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":1012,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5152112":{"score":0.84360695,"function_name":"uv__to_stat","code":"static void uv__to_stat(struct stat* src, uv_stat_t* dst) {\n  dst-\u003est_dev = src-\u003est_dev;\n  dst-\u003est_mode = src-\u003est_mode;\n  dst-\u003est_nlink = src-\u003est_nlink;\n  dst-\u003est_uid = src-\u003est_uid;\n  dst-\u003est_gid = src-\u003est_gid;\n  dst-\u003est_rdev = src-\u003est_rdev;\n  dst-\u003est_ino = src-\u003est_ino;\n  dst-\u003est_size = src-\u003est_size;\n  dst-\u003est_blksize = src-\u003est_blksize;\n  dst-\u003est_blocks = src-\u003est_blocks;\n\n#if defined(__APPLE__)\n  dst-\u003est_atim.tv_sec = src-\u003est_atimespec.tv_sec;\n  dst-\u003est_atim.tv_nsec = src-\u003est_atimespec.tv_nsec;\n  dst-\u003est_mtim.tv_sec = src-\u003est_mtimespec.tv_sec;\n  dst-\u003est_mtim.tv_nsec = src-\u003est_mtimespec.tv_nsec;\n  dst-\u003est_ctim.tv_sec = src-\u003est_ctimespec.tv_sec;\n  dst-\u003est_ctim.tv_nsec = src-\u003est_ctimespec.tv_nsec;\n  dst-\u003est_birthtim.tv_sec = src-\u003est_birthtimespec.tv_sec;\n  dst-\u003est_birthtim.tv_nsec = src-\u003est_birthtimespec.tv_nsec;\n  dst-\u003est_flags = src-\u003est_flags;\n  dst-\u003est_gen = src-\u003est_gen;\n#elif defined(__ANDROID__)\n  dst-\u003est_atim.tv_sec = src-\u003est_atime;\n  dst-\u003est_atim.tv_nsec = src-\u003est_atimensec;\n  dst-\u003est_mtim.tv_sec = src-\u003est_mtime;\n  dst-\u003est_mtim.tv_nsec = src-\u003est_mtimensec;\n  dst-\u003est_ctim.tv_sec = src-\u003est_ctime;\n  dst-\u003est_ctim.tv_nsec = src-\u003est_ctimensec;\n  dst-\u003est_birthtim.tv_sec = src-\u003est_ctime;\n  dst-\u003est_birthtim.tv_nsec = src-\u003est_ctimensec;\n  dst-\u003est_flags = 0;\n  dst-\u003est_gen = 0;\n#elif !defined(_AIX) \u0026\u0026 (       \\\n    defined(__DragonFly__)   || \\\n    defined(__FreeBSD__)     || \\\n    defined(__OpenBSD__)     || \\\n    defined(__NetBSD__)      || \\\n    defined(_GNU_SOURCE)     || \\\n    defined(_BSD_SOURCE)     || \\\n    defined(_SVID_SOURCE)    || \\\n    defined(_XOPEN_SOURCE)   || \\\n    defined(_DEFAULT_SOURCE))\n  dst-\u003est_atim.tv_sec = src-\u003est_atim.tv_sec;\n  dst-\u003est_atim.tv_nsec = src-\u003est_atim.tv_nsec;\n  dst-\u003est_mtim.tv_sec = src-\u003est_mtim.tv_sec;\n  dst-\u003est_mtim.tv_nsec = src-\u003est_mtim.tv_nsec;\n  dst-\u003est_ctim.tv_sec = src-\u003est_ctim.tv_sec;\n  dst-\u003est_ctim.tv_nsec = src-\u003est_ctim.tv_nsec;\n# if defined(__FreeBSD__)    || \\\n     defined(__NetBSD__)\n  dst-\u003est_birthtim.tv_sec = src-\u003est_birthtim.tv_sec;\n  dst-\u003est_birthtim.tv_nsec = src-\u003est_birthtim.tv_nsec;\n  dst-\u003est_flags = src-\u003est_flags;\n  dst-\u003est_gen = src-\u003est_gen;\n# else\n  dst-\u003est_birthtim.tv_sec = src-\u003est_ctim.tv_sec;\n  dst-\u003est_birthtim.tv_nsec = src-\u003est_ctim.tv_nsec;\n  dst-\u003est_flags = 0;\n  dst-\u003est_gen = 0;\n# endif\n#else\n  dst-\u003est_atim.tv_sec = src-\u003est_atime;\n  dst-\u003est_atim.tv_nsec = 0;\n  dst-\u003est_mtim.tv_sec = src-\u003est_mtime;\n  dst-\u003est_mtim.tv_nsec = 0;\n  dst-\u003est_ctim.tv_sec = src-\u003est_ctime;\n  dst-\u003est_ctim.tv_nsec = 0;\n  dst-\u003est_birthtim.tv_sec = src-\u003est_ctime;\n  dst-\u003est_birthtim.tv_nsec = 0;\n  dst-\u003est_flags = 0;\n  dst-\u003est_gen = 0;\n#endif\n}","filepath":"src/unix/fs.c","line_number":869,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5152272":{"score":0.7530459,"function_name":"uv__fs_read","code":"static ssize_t uv__fs_read(uv_fs_t* req) {\n#if defined(__linux__)\n  static int no_preadv;\n#endif\n  ssize_t result;\n\n#if defined(_AIX)\n  struct stat buf;\n  if(fstat(req-\u003efile, \u0026buf))\n    return -1;\n  if(S_ISDIR(buf.st_mode)) {\n    errno = EISDIR;\n    return -1;\n  }\n#endif /* defined(_AIX) */\n  if (req-\u003eoff \u003c 0) {\n    if (req-\u003enbufs == 1)\n      result = read(req-\u003efile, req-\u003ebufs[0].base, req-\u003ebufs[0].len);\n    else\n      result = readv(req-\u003efile, (struct iovec*) req-\u003ebufs, req-\u003enbufs);\n  } else {\n    if (req-\u003enbufs == 1) {\n      result = pread(req-\u003efile, req-\u003ebufs[0].base, req-\u003ebufs[0].len, req-\u003eoff);\n      goto done;\n    }\n\n#if HAVE_PREADV\n    result = preadv(req-\u003efile, (struct iovec*) req-\u003ebufs, req-\u003enbufs, req-\u003eoff);\n#else\n# if defined(__linux__)\n    if (no_preadv) retry:\n# endif\n    {\n      off_t nread;\n      size_t index;\n\n      nread = 0;\n      index = 0;\n      result = 1;\n      do {\n        if (req-\u003ebufs[index].len \u003e 0) {\n          result = pread(req-\u003efile,\n                         req-\u003ebufs[index].base,\n                         req-\u003ebufs[index].len,\n                         req-\u003eoff + nread);\n          if (result \u003e 0)\n            nread += result;\n        }\n        index++;\n      } while (index \u003c req-\u003enbufs \u0026\u0026 result \u003e 0);\n      if (nread \u003e 0)\n        result = nread;\n    }\n# if defined(__linux__)\n    else {\n      result = uv__preadv(req-\u003efile,\n                          (struct iovec*)req-\u003ebufs,\n                          req-\u003enbufs,\n                          req-\u003eoff);\n      if (result == -1 \u0026\u0026 errno == ENOSYS) {\n        no_preadv = 1;\n        goto retry;\n      }\n    }\n# endif\n#endif\n  }\n\ndone:\n  return result;\n}","filepath":"src/unix/fs.c","line_number":295,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5152944":{"score":0.7682062,"function_name":"uv__fs_sendfile_emul","code":"static ssize_t uv__fs_sendfile_emul(uv_fs_t* req) {\n  struct pollfd pfd;\n  int use_pread;\n  off_t offset;\n  ssize_t nsent;\n  ssize_t nread;\n  ssize_t nwritten;\n  size_t buflen;\n  size_t len;\n  ssize_t n;\n  int in_fd;\n  int out_fd;\n  char buf[8192];\n\n  len = req-\u003ebufsml[0].len;\n  in_fd = req-\u003eflags;\n  out_fd = req-\u003efile;\n  offset = req-\u003eoff;\n  use_pread = 1;\n\n  /* Here are the rules regarding errors:\n   *\n   * 1. Read errors are reported only if nsent==0, otherwise we return nsent.\n   *    The user needs to know that some data has already been sent, to stop\n   *    them from sending it twice.\n   *\n   * 2. Write errors are always reported. Write errors are bad because they\n   *    mean data loss: we've read data but now we can't write it out.\n   *\n   * We try to use pread() and fall back to regular read() if the source fd\n   * doesn't support positional reads, for example when it's a pipe fd.\n   *\n   * If we get EAGAIN when writing to the target fd, we poll() on it until\n   * it becomes writable again.\n   *\n   * FIXME: If we get a write error when use_pread==1, it should be safe to\n   *        return the number of sent bytes instead of an error because pread()\n   *        is, in theory, idempotent. However, special files in /dev or /proc\n   *        may support pread() but not necessarily return the same data on\n   *        successive reads.\n   *\n   * FIXME: There is no way now to signal that we managed to send *some* data\n   *        before a write error.\n   */\n  for (nsent = 0; (size_t) nsent \u003c len; ) {\n    buflen = len - nsent;\n\n    if (buflen \u003e sizeof(buf))\n      buflen = sizeof(buf);\n\n    do\n      if (use_pread)\n        nread = pread(in_fd, buf, buflen, offset);\n      else\n        nread = read(in_fd, buf, buflen);\n    while (nread == -1 \u0026\u0026 errno == EINTR);\n\n    if (nread == 0)\n      goto out;\n\n    if (nread == -1) {\n      if (use_pread \u0026\u0026 nsent == 0 \u0026\u0026 (errno == EIO || errno == ESPIPE)) {\n        use_pread = 0;\n        continue;\n      }\n\n      if (nsent == 0)\n        nsent = -1;\n\n      goto out;\n    }\n\n    for (nwritten = 0; nwritten \u003c nread; ) {\n      do\n        n = write(out_fd, buf + nwritten, nread - nwritten);\n      while (n == -1 \u0026\u0026 errno == EINTR);\n\n      if (n != -1) {\n        nwritten += n;\n        continue;\n      }\n\n      if (errno != EAGAIN \u0026\u0026 errno != EWOULDBLOCK) {\n        nsent = -1;\n        goto out;\n      }\n\n      pfd.fd = out_fd;\n      pfd.events = POLLOUT;\n      pfd.revents = 0;\n\n      do\n        n = poll(\u0026pfd, 1, -1);\n      while (n == -1 \u0026\u0026 errno == EINTR);\n\n      if (n == -1 || (pfd.revents \u0026 ~POLLOUT) != 0) {\n        errno = EIO;\n        nsent = -1;\n        goto out;\n      }\n    }\n\n    offset += nread;\n    nsent += nread;\n  }\n\nout:\n  if (nsent != -1)\n    req-\u003eoff = offset;\n\n  return nsent;\n}","filepath":"src/unix/fs.c","line_number":474,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5153520":{"score":0.6899178,"function_name":"uv__fs_buf_iter","code":"static ssize_t uv__fs_buf_iter(uv_fs_t* req, uv__fs_buf_iter_processor process) {\n  unsigned int iovmax;\n  unsigned int nbufs;\n  uv_buf_t* bufs;\n  ssize_t total;\n  ssize_t result;\n\n  iovmax = uv__getiovmax();\n  nbufs = req-\u003enbufs;\n  bufs = req-\u003ebufs;\n  total = 0;\n\n  while (nbufs \u003e 0) {\n    req-\u003enbufs = nbufs;\n    if (req-\u003enbufs \u003e iovmax)\n      req-\u003enbufs = iovmax;\n\n    result = process(req);\n    if (result \u003c= 0) {\n      if (total == 0)\n        total = result;\n      break;\n    }\n\n    if (req-\u003eoff \u003e= 0)\n      req-\u003eoff += result;\n\n    req-\u003ebufs += req-\u003enbufs;\n    nbufs -= req-\u003enbufs;\n    total += result;\n  }\n\n  if (errno == EINTR \u0026\u0026 total == -1)\n    return total;\n\n  if (bufs != req-\u003ebufsml)\n    uv__free(bufs);\n\n  req-\u003ebufs = NULL;\n  req-\u003enbufs = 0;\n\n  return total;\n}","filepath":"src/unix/fs.c","line_number":983,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5153728":{"score":0.7850213,"function_name":"uv__fs_done","code":"static void uv__fs_done(struct uv__work* w, int status) {\n  uv_fs_t* req;\n\n  req = container_of(w, uv_fs_t, work_req);\n  uv__req_unregister(req-\u003eloop, req);\n\n  if (status == -ECANCELED) {\n    assert(req-\u003eresult == 0);\n    req-\u003eresult = -ECANCELED;\n  }\n\n  req-\u003ecb(req);\n}","filepath":"src/unix/fs.c","line_number":1092,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5153888":{"score":0.52374876,"function_name":"uv__fs_work","code":"static void uv__fs_work(struct uv__work* w) {\n  int retry_on_eintr;\n  uv_fs_t* req;\n  ssize_t r;\n\n  req = container_of(w, uv_fs_t, work_req);\n  retry_on_eintr = !(req-\u003efs_type == UV_FS_CLOSE);\n\n  do {\n    errno = 0;\n\n#define X(type, action)                                                       \\\n  case UV_FS_ ## type:                                                        \\\n    r = action;                                                               \\\n    break;\n\n    switch (req-\u003efs_type) {\n    X(ACCESS, access(req-\u003epath, req-\u003eflags));\n    X(CHMOD, chmod(req-\u003epath, req-\u003emode));\n    X(CHOWN, chown(req-\u003epath, req-\u003euid, req-\u003egid));\n    X(CLOSE, close(req-\u003efile));\n    X(COPYFILE, uv__fs_copyfile(req));\n    X(FCHMOD, fchmod(req-\u003efile, req-\u003emode));\n    X(FCHOWN, fchown(req-\u003efile, req-\u003euid, req-\u003egid));\n    X(FDATASYNC, uv__fs_fdatasync(req));\n    X(FSTAT, uv__fs_fstat(req-\u003efile, \u0026req-\u003estatbuf));\n    X(FSYNC, uv__fs_fsync(req));\n    X(FTRUNCATE, ftruncate(req-\u003efile, req-\u003eoff));\n    X(FUTIME, uv__fs_futime(req));\n    X(LSTAT, uv__fs_lstat(req-\u003epath, \u0026req-\u003estatbuf));\n    X(LINK, link(req-\u003epath, req-\u003enew_path));\n    X(MKDIR, mkdir(req-\u003epath, req-\u003emode));\n    X(MKDTEMP, uv__fs_mkdtemp(req));\n    X(OPEN, uv__fs_open(req));\n    X(READ, uv__fs_buf_iter(req, uv__fs_read));\n    X(SCANDIR, uv__fs_scandir(req));\n    X(READLINK, uv__fs_readlink(req));\n    X(REALPATH, uv__fs_realpath(req));\n    X(RENAME, rename(req-\u003epath, req-\u003enew_path));\n    X(RMDIR, rmdir(req-\u003epath));\n    X(SENDFILE, uv__fs_sendfile(req));\n    X(STAT, uv__fs_stat(req-\u003epath, \u0026req-\u003estatbuf));\n    X(SYMLINK, symlink(req-\u003epath, req-\u003enew_path));\n    X(UNLINK, unlink(req-\u003epath));\n    X(UTIME, uv__fs_utime(req));\n    X(WRITE, uv__fs_buf_iter(req, uv__fs_write));\n    default: abort();\n    }\n#undef X\n  } while (r == -1 \u0026\u0026 errno == EINTR \u0026\u0026 retry_on_eintr);\n\n  if (r == -1)\n    req-\u003eresult = -errno;\n  else\n    req-\u003eresult = r;\n\n  if (r == 0 \u0026\u0026 (req-\u003efs_type == UV_FS_STAT ||\n                 req-\u003efs_type == UV_FS_FSTAT ||\n                 req-\u003efs_type == UV_FS_LSTAT)) {\n    req-\u003eptr = \u0026req-\u003estatbuf;\n  }\n}","filepath":"src/unix/fs.c","line_number":1028,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5156224":{"score":0.78422433,"function_name":"uv_fs_access","code":"int uv_fs_access(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 int flags,\n                 uv_fs_cb cb) {\n  INIT(ACCESS);\n  PATH;\n  req-\u003eflags = flags;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1107,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5156624":{"score":0.7942395,"function_name":"uv_fs_chmod","code":"int uv_fs_chmod(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                int mode,\n                uv_fs_cb cb) {\n  INIT(CHMOD);\n  PATH;\n  req-\u003emode = mode;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1119,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5157024":{"score":0.7744498,"function_name":"uv_fs_chown","code":"int uv_fs_chown(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                uv_uid_t uid,\n                uv_gid_t gid,\n                uv_fs_cb cb) {\n  INIT(CHOWN);\n  PATH;\n  req-\u003euid = uid;\n  req-\u003egid = gid;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1131,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5157424":{"score":0.6230125,"function_name":"uv_fs_close","code":"int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {\n  uv_fs_req_init(loop, req, UV_FS_CLOSE, cb);\n  req-\u003efd = fd;\n\n  if (cb) {\n    QUEUE_FS_TP_JOB(loop, req);\n    return 0;\n  } else {\n    fs__close(req);\n    return req-\u003eresult;\n  }\n}","filepath":"src/win/fs.c","line_number":1558,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.18"},"5159872":{"score":0.67577654,"function_name":"uv_fs_link","code":"int uv_fs_link(uv_loop_t* loop,\n               uv_fs_t* req,\n               const char* path,\n               const char* new_path,\n               uv_fs_cb cb) {\n  INIT(LINK);\n  PATH2;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1232,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5160304":{"score":0.82307225,"function_name":"uv_fs_mkdir","code":"int uv_fs_mkdir(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                int mode,\n                uv_fs_cb cb) {\n  INIT(MKDIR);\n  PATH;\n  req-\u003emode = mode;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1243,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5160704":{"score":0.72336936,"function_name":"uv_fs_mkdtemp","code":"int uv_fs_mkdtemp(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* tpl,\n                  uv_fs_cb cb) {\n  INIT(MKDTEMP);\n  req-\u003epath = uv__strdup(tpl);\n  if (req-\u003epath == NULL) {\n    if (cb != NULL)\n      uv__req_unregister(loop, req);\n    return -ENOMEM;\n  }\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1255,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5161040":{"score":0.77745235,"function_name":"uv_fs_open","code":"int uv_fs_open(uv_loop_t* loop,\n               uv_fs_t* req,\n               const char* path,\n               int flags,\n               int mode,\n               uv_fs_cb cb) {\n  INIT(OPEN);\n  PATH;\n  req-\u003eflags = flags;\n  req-\u003emode = mode;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1270,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5161440":{"score":0.8548846,"function_name":"uv_fs_read","code":"int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,\n               uv_file file,\n               const uv_buf_t bufs[],\n               unsigned int nbufs,\n               int64_t off,\n               uv_fs_cb cb) {\n  if (bufs == NULL || nbufs == 0)\n    return -EINVAL;\n\n  INIT(READ);\n  req-\u003efile = file;\n\n  req-\u003enbufs = nbufs;\n  req-\u003ebufs = req-\u003ebufsml;\n  if (nbufs \u003e ARRAY_SIZE(req-\u003ebufsml))\n    req-\u003ebufs = uv__malloc(nbufs * sizeof(*bufs));\n\n  if (req-\u003ebufs == NULL) {\n    if (cb != NULL)\n      uv__req_unregister(loop, req);\n    return -ENOMEM;\n  }\n\n  memcpy(req-\u003ebufs, bufs, nbufs * sizeof(*bufs));\n\n  req-\u003eoff = off;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1284,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5161888":{"score":0.71418536,"function_name":"uv_fs_ftruncate","code":"int uv_fs_ftruncate(uv_loop_t* loop,\n                    uv_fs_t* req,\n                    uv_file file,\n                    int64_t off,\n                    uv_fs_cb cb) {\n  INIT(FTRUNCATE);\n  req-\u003efile = file;\n  req-\u003eoff = off;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1199,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5162288":{"score":0.7927332,"function_name":"uv_fs_readlink","code":"int uv_fs_readlink(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   const char* path,\n                   uv_fs_cb cb) {\n  INIT(READLINK);\n  PATH;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1326,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5162640":{"score":0.79986113,"function_name":"uv_fs_realpath","code":"int uv_fs_realpath(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char * path,\n                  uv_fs_cb cb) {\n  INIT(REALPATH);\n  PATH;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1336,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5162992":{"score":0.70223194,"function_name":"uv_fs_rename","code":"int uv_fs_rename(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 const char* new_path,\n                 uv_fs_cb cb) {\n  INIT(RENAME);\n  PATH2;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1346,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5164416":{"score":0.7203783,"function_name":"uv_fs_copyfile","code":"int uv_fs_copyfile(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   const char* path,\n                   const char* new_path,\n                   int flags,\n                   uv_fs_cb cb) {\n  INIT(COPYFILE);\n  PATH2;\n  req-\u003eflags = flags;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1473,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5165216":{"score":0.7722834,"function_name":"uv_fs_utime","code":"int uv_fs_utime(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                double atime,\n                double mtime,\n                uv_fs_cb cb) {\n  INIT(UTIME);\n  PATH;\n  req-\u003eatime = atime;\n  req-\u003emtime = mtime;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1407,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5165648":{"score":0.84499884,"function_name":"uv_fs_write","code":"int uv_fs_write(uv_loop_t* loop,\n                uv_fs_t* req,\n                uv_file file,\n                const uv_buf_t bufs[],\n                unsigned int nbufs,\n                int64_t off,\n                uv_fs_cb cb) {\n  if (bufs == NULL || nbufs == 0)\n    return -EINVAL;\n\n  INIT(WRITE);\n  req-\u003efile = file;\n\n  req-\u003enbufs = nbufs;\n  req-\u003ebufs = req-\u003ebufsml;\n  if (nbufs \u003e ARRAY_SIZE(req-\u003ebufsml))\n    req-\u003ebufs = uv__malloc(nbufs * sizeof(*bufs));\n\n  if (req-\u003ebufs == NULL) {\n    if (cb != NULL)\n      uv__req_unregister(loop, req);\n    return -ENOMEM;\n  }\n\n  memcpy(req-\u003ebufs, bufs, nbufs * sizeof(*bufs));\n\n  req-\u003eoff = off;\n  POST;\n}","filepath":"src/unix/fs.c","line_number":1421,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5166096":{"score":0.7537322,"function_name":"uv_fs_req_cleanup","code":"void uv_fs_req_cleanup(uv_fs_t* req) {\n  /* Only necessary for asychronous requests, i.e., requests with a callback.\n   * Synchronous ones don't copy their arguments and have req-\u003epath and\n   * req-\u003enew_path pointing to user-owned memory.  UV_FS_MKDTEMP is the\n   * exception to the rule, it always allocates memory.\n   */\n  if (req-\u003epath != NULL \u0026\u0026 (req-\u003ecb != NULL || req-\u003efs_type == UV_FS_MKDTEMP))\n    uv__free((void*) req-\u003epath);  /* Memory is shared with req-\u003enew_path. */\n\n  req-\u003epath = NULL;\n  req-\u003enew_path = NULL;\n\n  if (req-\u003efs_type == UV_FS_SCANDIR \u0026\u0026 req-\u003eptr != NULL)\n    uv__fs_scandir_cleanup(req);\n\n  if (req-\u003eptr != \u0026req-\u003estatbuf)\n    uv__free(req-\u003eptr);\n  req-\u003eptr = NULL;\n}","filepath":"src/unix/fs.c","line_number":1452,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.14.0"},"5166224":{"score":0.8090868,"function_name":"uv__getaddrinfo_done","code":"static void uv__getaddrinfo_done(struct uv__work* w, int status) {\n  uv_getaddrinfo_t* req;\n  struct addrinfo *res;\n\n  req = container_of(w, uv_getaddrinfo_t, work_req);\n  uv__req_unregister(req-\u003eloop, req);\n\n  res = req-\u003eres;\n  req-\u003eres = NULL;\n\n  /* See initialization in uv_getaddrinfo(). */\n  if (req-\u003ehints)\n    free(req-\u003ehints);\n  else if (req-\u003eservice)\n    free(req-\u003eservice);\n  else if (req-\u003ehostname)\n    free(req-\u003ehostname);\n  else\n    assert(0);\n\n  req-\u003ehints = NULL;\n  req-\u003eservice = NULL;\n  req-\u003ehostname = NULL;\n\n  if (status == -ECANCELED) {\n    assert(req-\u003eretcode == 0);\n    req-\u003eretcode = UV_EAI_CANCELED;\n  }\n\n  req-\u003ecb(req, req-\u003eretcode, res);\n}","filepath":"src/unix/getaddrinfo.c","line_number":107,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5166480":{"score":0.8280407,"function_name":"uv__getaddrinfo_translate_error","code":"int uv__getaddrinfo_translate_error(int sys_err) {\n  switch (sys_err) {\n  case 0: return 0;\n#if defined(EAI_ADDRFAMILY)\n  case EAI_ADDRFAMILY: return UV_EAI_ADDRFAMILY;\n#endif\n#if defined(EAI_AGAIN)\n  case EAI_AGAIN: return UV_EAI_AGAIN;\n#endif\n#if defined(EAI_BADFLAGS)\n  case EAI_BADFLAGS: return UV_EAI_BADFLAGS;\n#endif\n#if defined(EAI_BADHINTS)\n  case EAI_BADHINTS: return UV_EAI_BADHINTS;\n#endif\n#if defined(EAI_CANCELED)\n  case EAI_CANCELED: return UV_EAI_CANCELED;\n#endif\n#if defined(EAI_FAIL)\n  case EAI_FAIL: return UV_EAI_FAIL;\n#endif\n#if defined(EAI_FAMILY)\n  case EAI_FAMILY: return UV_EAI_FAMILY;\n#endif\n#if defined(EAI_MEMORY)\n  case EAI_MEMORY: return UV_EAI_MEMORY;\n#endif\n#if defined(EAI_NODATA)\n  case EAI_NODATA: return UV_EAI_NODATA;\n#endif\n#if defined(EAI_NONAME)\n# if !defined(EAI_NODATA) || EAI_NODATA != EAI_NONAME\n  case EAI_NONAME: return UV_EAI_NONAME;\n# endif\n#endif\n#if defined(EAI_OVERFLOW)\n  case EAI_OVERFLOW: return UV_EAI_OVERFLOW;\n#endif\n#if defined(EAI_PROTOCOL)\n  case EAI_PROTOCOL: return UV_EAI_PROTOCOL;\n#endif\n#if defined(EAI_SERVICE)\n  case EAI_SERVICE: return UV_EAI_SERVICE;\n#endif\n#if defined(EAI_SOCKTYPE)\n  case EAI_SOCKTYPE: return UV_EAI_SOCKTYPE;\n#endif\n#if defined(EAI_SYSTEM)\n  case EAI_SYSTEM: return -errno;\n#endif\n  }\n  assert(!\"unknown EAI_* error code\");\n  abort();\n  return 0;  /* Pacify compiler. */\n}","filepath":"src/unix/getaddrinfo.c","line_number":40,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5166800":{"score":0.84401095,"function_name":"uv_getaddrinfo","code":"int uv_getaddrinfo(uv_loop_t* loop,\n                   uv_getaddrinfo_t* req,\n                   uv_getaddrinfo_cb getaddrinfo_cb,\n                   const char* node,\n                   const char* service,\n                   const struct addrinfo* hints) {\n  int nodesize = 0;\n  int servicesize = 0;\n  int hintssize = 0;\n  char* alloc_ptr = NULL;\n  int err;\n\n  if (req == NULL || (node == NULL \u0026\u0026 service == NULL)) {\n    err = WSAEINVAL;\n    goto error;\n  }\n\n  uv_req_init(loop, (uv_req_t*)req);\n\n  req-\u003egetaddrinfo_cb = getaddrinfo_cb;\n  req-\u003eaddrinfo = NULL;\n  req-\u003etype = UV_GETADDRINFO;\n  req-\u003eloop = loop;\n  req-\u003eretcode = 0;\n\n  /* calculate required memory size for all input values */\n  if (node != NULL) {\n    nodesize = ALIGNED_SIZE(uv_utf8_to_utf16(node, NULL, 0) * sizeof(WCHAR));\n    if (nodesize == 0) {\n      err = GetLastError();\n      goto error;\n    }\n  }\n\n  if (service != NULL) {\n    servicesize = ALIGNED_SIZE(uv_utf8_to_utf16(service, NULL, 0) *\n                               sizeof(WCHAR));\n    if (servicesize == 0) {\n      err = GetLastError();\n      goto error;\n    }\n  }\n  if (hints != NULL) {\n    hintssize = ALIGNED_SIZE(sizeof(struct addrinfoW));\n  }\n\n  /* allocate memory for inputs, and partition it as needed */\n  alloc_ptr = (char*)uv__malloc(nodesize + servicesize + hintssize);\n  if (!alloc_ptr) {\n    err = WSAENOBUFS;\n    goto error;\n  }\n\n  /* save alloc_ptr now so we can free if error */\n  req-\u003ealloc = (void*)alloc_ptr;\n\n  /* convert node string to UTF16 into allocated memory and save pointer in */\n  /* the request. */\n  if (node != NULL) {\n    req-\u003enode = (WCHAR*)alloc_ptr;\n    if (uv_utf8_to_utf16(node,\n                         (WCHAR*) alloc_ptr,\n                         nodesize / sizeof(WCHAR)) == 0) {\n      err = GetLastError();\n      goto error;\n    }\n    alloc_ptr += nodesize;\n  } else {\n    req-\u003enode = NULL;\n  }\n\n  /* convert service string to UTF16 into allocated memory and save pointer */\n  /* in the req. */\n  if (service != NULL) {\n    req-\u003eservice = (WCHAR*)alloc_ptr;\n    if (uv_utf8_to_utf16(service,\n                         (WCHAR*) alloc_ptr,\n                         servicesize / sizeof(WCHAR)) == 0) {\n      err = GetLastError();\n      goto error;\n    }\n    alloc_ptr += servicesize;\n  } else {\n    req-\u003eservice = NULL;\n  }\n\n  /* copy hints to allocated memory and save pointer in req */\n  if (hints != NULL) {\n    req-\u003eaddrinfow = (struct addrinfoW*)alloc_ptr;\n    req-\u003eaddrinfow-\u003eai_family = hints-\u003eai_family;\n    req-\u003eaddrinfow-\u003eai_socktype = hints-\u003eai_socktype;\n    req-\u003eaddrinfow-\u003eai_protocol = hints-\u003eai_protocol;\n    req-\u003eaddrinfow-\u003eai_flags = hints-\u003eai_flags;\n    req-\u003eaddrinfow-\u003eai_addrlen = 0;\n    req-\u003eaddrinfow-\u003eai_canonname = NULL;\n    req-\u003eaddrinfow-\u003eai_addr = NULL;\n    req-\u003eaddrinfow-\u003eai_next = NULL;\n  } else {\n    req-\u003eaddrinfow = NULL;\n  }\n\n  uv__req_register(loop, req);\n\n  if (getaddrinfo_cb) {\n    uv__work_submit(loop,\n                    \u0026req-\u003ework_req,\n                    uv__getaddrinfo_work,\n                    uv__getaddrinfo_done);\n    return 0;\n  } else {\n    uv__getaddrinfo_work(\u0026req-\u003ework_req);\n    uv__getaddrinfo_done(\u0026req-\u003ework_req, 0);\n    return req-\u003eretcode;\n  }\n\nerror:\n  if (req != NULL) {\n    uv__free(req-\u003ealloc);\n    req-\u003ealloc = NULL;\n  }\n  return uv_translate_sys_error(err);\n}","filepath":"src/win/getaddrinfo.c","line_number":237,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5167376":{"score":0.65698385,"function_name":"uv_udp_init","code":"int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {\n  uv__handle_init(loop, (uv_handle_t*) handle, UV_UDP);\n\n  handle-\u003esocket = INVALID_SOCKET;\n  handle-\u003ereqs_pending = 0;\n  handle-\u003eactivecnt = 0;\n  handle-\u003efunc_wsarecv = WSARecv;\n  handle-\u003efunc_wsarecvfrom = WSARecvFrom;\n\n  uv_req_init(loop, (uv_req_t*) \u0026(handle-\u003erecv_req));\n  handle-\u003erecv_req.type = UV_UDP_RECV;\n  handle-\u003erecv_req.data = handle;\n\n  return 0;\n}","filepath":"src/win/udp.c","line_number":133,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.6"},"5167440":{"score":0.59726095,"function_name":"uv__udp_recv_start","code":"int uv__udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n    uv_udp_recv_cb recv_cb) {\n  uv_loop_t* loop = handle-\u003eloop;\n  int err;\n\n  if (handle-\u003eflags \u0026 UV_HANDLE_READING) {\n    return WSAEALREADY;\n  }\n\n  if (!(handle-\u003eflags \u0026 UV_HANDLE_BOUND)) {\n    err = uv_udp_bind(handle, uv_addr_ip4_any_, 0);\n    if (err)\n      return err;\n  }\n\n  handle-\u003eflags |= UV_HANDLE_READING;\n  INCREASE_ACTIVE_COUNT(loop, handle);\n  loop-\u003eactive_udp_streams++;\n\n  handle-\u003erecv_cb = recv_cb;\n  handle-\u003ealloc_cb = alloc_cb;\n\n  /* If reading was stopped and then started again, there could still be a */\n  /* recv request pending. */\n  if (!(handle-\u003eflags \u0026 UV_HANDLE_READ_PENDING))\n    uv_udp_queue_recv(loop, handle);\n\n  return 0;\n}","filepath":"src/win/udp.c","line_number":345,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.6"},"5167536":{"score":0.79732776,"function_name":"uv__udp_recv_stop","code":"int uv__udp_recv_stop(uv_udp_t* handle) {\n  if (handle-\u003eflags \u0026 UV_HANDLE_READING) {\n    handle-\u003eflags \u0026= ~UV_HANDLE_READING;\n    handle-\u003eloop-\u003eactive_udp_streams--;\n    DECREASE_ACTIVE_COUNT(loop, handle);\n  }\n\n  return 0;\n}","filepath":"src/win/udp.c","line_number":376,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.6"},"5167600":{"score":0.6219936,"function_name":"uv__run_pending","code":"static void uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  QUEUE_MOVE(\u0026loop-\u003epending_queue, \u0026pq);\n\n  while (!QUEUE_EMPTY(\u0026pq)) {\n    q = QUEUE_HEAD(\u0026pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w-\u003ecb(loop, w, POLLOUT);\n  }\n}","filepath":"src/unix/core.c","line_number":798,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.44.2"},"5168672":{"score":0.70591897,"function_name":"uv_loop_init","code":"int uv_loop_init(uv_loop_t* loop) {\n  int err;\n\n  uv__signal_global_once_init();\n\n  memset(loop, 0, sizeof(*loop));\n  heap_init((struct heap*) \u0026loop-\u003etimer_heap);\n  QUEUE_INIT(\u0026loop-\u003ewq);\n  QUEUE_INIT(\u0026loop-\u003eactive_reqs);\n  QUEUE_INIT(\u0026loop-\u003eidle_handles);\n  QUEUE_INIT(\u0026loop-\u003easync_handles);\n  QUEUE_INIT(\u0026loop-\u003echeck_handles);\n  QUEUE_INIT(\u0026loop-\u003eprepare_handles);\n  QUEUE_INIT(\u0026loop-\u003ehandle_queue);\n\n  loop-\u003enfds = 0;\n  loop-\u003ewatchers = NULL;\n  loop-\u003enwatchers = 0;\n  QUEUE_INIT(\u0026loop-\u003epending_queue);\n  QUEUE_INIT(\u0026loop-\u003ewatcher_queue);\n\n  loop-\u003eclosing_handles = NULL;\n  uv__update_time(loop);\n  uv__async_init(\u0026loop-\u003easync_watcher);\n  loop-\u003esignal_pipefd[0] = -1;\n  loop-\u003esignal_pipefd[1] = -1;\n  loop-\u003ebackend_fd = -1;\n  loop-\u003eemfile_fd = -1;\n\n  loop-\u003etimer_counter = 0;\n  loop-\u003estop_flag = 0;\n\n  err = uv__platform_loop_init(loop);\n  if (err)\n    return err;\n\n  err = uv_signal_init(loop, \u0026loop-\u003echild_watcher);\n  if (err)\n    goto fail_signal_init;\n\n  uv__handle_unref(\u0026loop-\u003echild_watcher);\n  loop-\u003echild_watcher.flags |= UV__HANDLE_INTERNAL;\n  QUEUE_INIT(\u0026loop-\u003eprocess_handles);\n\n  err = uv_rwlock_init(\u0026loop-\u003ecloexec_lock);\n  if (err)\n    goto fail_rwlock_init;\n\n  err = uv_mutex_init(\u0026loop-\u003ewq_mutex);\n  if (err)\n    goto fail_mutex_init;\n\n  err = uv_async_init(loop, \u0026loop-\u003ewq_async, uv__work_done);\n  if (err)\n    goto fail_async_init;\n\n  uv__handle_unref(\u0026loop-\u003ewq_async);\n  loop-\u003ewq_async.flags |= UV__HANDLE_INTERNAL;\n\n  return 0;\n\nfail_async_init:\n  uv_mutex_destroy(\u0026loop-\u003ewq_mutex);\n\nfail_mutex_init:\n  uv_rwlock_destroy(\u0026loop-\u003ecloexec_lock);\n\nfail_rwlock_init:\n  uv__signal_loop_cleanup(loop);\n\nfail_signal_init:\n  uv__platform_loop_delete(loop);\n\n  return err;\n}","filepath":"src/unix/loop.c","line_number":30,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.2"},"5169344":{"score":0.87241626,"function_name":"uv__loop_close","code":"void uv__loop_close(uv_loop_t* loop) {\n  uv__signal_loop_cleanup(loop);\n  uv__platform_loop_delete(loop);\n  uv__async_stop(loop, \u0026loop-\u003easync_watcher);\n\n  if (loop-\u003eemfile_fd != -1) {\n    uv__close(loop-\u003eemfile_fd);\n    loop-\u003eemfile_fd = -1;\n  }\n\n  if (loop-\u003ebackend_fd != -1) {\n    uv__close(loop-\u003ebackend_fd);\n    loop-\u003ebackend_fd = -1;\n  }\n\n  uv_mutex_lock(\u0026loop-\u003ewq_mutex);\n  assert(QUEUE_EMPTY(\u0026loop-\u003ewq) \u0026\u0026 \"thread pool work queue not empty!\");\n  assert(!uv__has_active_reqs(loop));\n  uv_mutex_unlock(\u0026loop-\u003ewq_mutex);\n  uv_mutex_destroy(\u0026loop-\u003ewq_mutex);\n\n  /*\n   * Note that all thread pool stuff is finished at this point and\n   * it is safe to just destroy rw lock\n   */\n  uv_rwlock_destroy(\u0026loop-\u003ecloexec_lock);\n\n#if 0\n  assert(QUEUE_EMPTY(\u0026loop-\u003epending_queue));\n  assert(QUEUE_EMPTY(\u0026loop-\u003ewatcher_queue));\n  assert(loop-\u003enfds == 0);\n#endif\n\n  uv__free(loop-\u003ewatchers);\n  loop-\u003ewatchers = NULL;\n  loop-\u003enwatchers = 0;\n}","filepath":"src/unix/loop.c","line_number":107,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.2"},"5169584":{"score":0.8070287,"function_name":"uv__loop_configure","code":"int uv__loop_configure(uv_loop_t* loop, uv_loop_option option, va_list ap) {\n  if (option != UV_LOOP_BLOCK_SIGNAL)\n    return UV_ENOSYS;\n\n  if (va_arg(ap, int) != SIGPROF)\n    return UV_EINVAL;\n\n  loop-\u003eflags |= UV_LOOP_BLOCK_SIGPROF;\n  return 0;\n}","filepath":"src/unix/loop.c","line_number":146,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.2"},"5169664":{"score":0.7678725,"function_name":"uv__pipe_getsockpeername","code":"static int uv__pipe_getsockpeername(const uv_pipe_t* handle,\n                                    uv__peersockfunc func,\n                                    char* buffer,\n                                    size_t* size) {\n  struct sockaddr_un sa;\n  socklen_t addrlen;\n  int err;\n\n  addrlen = sizeof(sa);\n  memset(\u0026sa, 0, addrlen);\n  err = func(uv__stream_fd(handle), (struct sockaddr*) \u0026sa, \u0026addrlen);\n  if (err \u003c 0) {\n    *size = 0;\n    return UV__ERR(errno);\n  }\n\n#if defined(__linux__)\n  if (sa.sun_path[0] == 0)\n    /* Linux abstract namespace */\n    addrlen -= offsetof(struct sockaddr_un, sun_path);\n  else\n#endif\n    addrlen = strlen(sa.sun_path);\n\n\n  if (addrlen \u003e= *size) {\n    *size = addrlen + 1;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, sa.sun_path, addrlen);\n  *size = addrlen;\n\n  /* only null-terminate if it's not an abstract socket */\n  if (buffer[0] != '\\0')\n    buffer[addrlen] = '\\0';\n\n  return 0;\n}","filepath":"src/unix/pipe.c","line_number":239,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5169904":{"score":0.8283911,"function_name":"uv_pipe_init","code":"int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {\n  uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);\n  handle-\u003eshutdown_req = NULL;\n  handle-\u003econnect_req = NULL;\n  handle-\u003epipe_fname = NULL;\n  handle-\u003eipc = ipc;\n  return 0;\n}","filepath":"src/unix/pipe.c","line_number":33,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5169984":{"score":0.7012274,"function_name":"uv_pipe_bind","code":"int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n  struct sockaddr_un saddr;\n  const char* pipe_fname;\n  int sockfd;\n  int err;\n\n  pipe_fname = NULL;\n\n  /* Already bound? */\n  if (uv__stream_fd(handle) \u003e= 0)\n    return UV_EINVAL;\n\n  /* Make a copy of the file name, it outlives this function's scope. */\n  pipe_fname = uv__strdup(name);\n  if (pipe_fname == NULL)\n    return UV_ENOMEM;\n\n  /* We've got a copy, don't touch the original any more. */\n  name = NULL;\n\n  err = uv__socket(AF_UNIX, SOCK_STREAM, 0);\n  if (err \u003c 0)\n    goto err_socket;\n  sockfd = err;\n\n  memset(\u0026saddr, 0, sizeof saddr);\n  uv__strscpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path));\n  saddr.sun_family = AF_UNIX;\n\n  if (bind(sockfd, (struct sockaddr*)\u0026saddr, sizeof saddr)) {\n    err = UV__ERR(errno);\n    /* Convert ENOENT to EACCES for compatibility with Windows. */\n    if (err == UV_ENOENT)\n      err = UV_EACCES;\n\n    uv__close(sockfd);\n    goto err_socket;\n  }\n\n  /* Success. */\n  handle-\u003eflags |= UV_HANDLE_BOUND;\n  handle-\u003epipe_fname = pipe_fname; /* Is a strdup'ed copy. */\n  handle-\u003eio_watcher.fd = sockfd;\n  return 0;\n\nerr_socket:\n  uv__free((void*)pipe_fname);\n  return err;\n}","filepath":"src/unix/pipe.c","line_number":43,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5170256":{"score":0.7152575,"function_name":"uv_pipe_listen","code":"int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n  if (uv__stream_fd(handle) == -1)\n    return UV_EINVAL;\n\n#if defined(__MVS__)\n  /* On zOS, backlog=0 has undefined behaviour */\n  if (backlog == 0)\n    backlog = 1;\n  else if (backlog \u003c 0)\n    backlog = SOMAXCONN;\n#endif\n\n  if (listen(uv__stream_fd(handle), backlog))\n    return UV__ERR(errno);\n\n  handle-\u003econnection_cb = cb;\n  handle-\u003eio_watcher.cb = uv__server_io;\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLIN);\n  return 0;\n}","filepath":"src/unix/pipe.c","line_number":94,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5170384":{"score":0.7349081,"function_name":"uv__pipe_close","code":"void uv__pipe_close(uv_pipe_t* handle) {\n  if (handle-\u003epipe_fname) {\n    /*\n     * Unlink the file system entity before closing the file descriptor.\n     * Doing it the other way around introduces a race where our process\n     * unlinks a socket with the same name that's just been created by\n     * another thread or process.\n     */\n    unlink(handle-\u003epipe_fname);\n    uv__free((void*)handle-\u003epipe_fname);\n    handle-\u003epipe_fname = NULL;\n  }\n\n  uv__stream_close((uv_stream_t*)handle);\n}","filepath":"src/unix/pipe.c","line_number":116,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5170512":{"score":0.7644345,"function_name":"uv_pipe_connect","code":"void uv_pipe_connect(uv_connect_t* req,\n                    uv_pipe_t* handle,\n                    const char* name,\n                    uv_connect_cb cb) {\n  struct sockaddr_un saddr;\n  int new_sock;\n  int err;\n  int r;\n\n  new_sock = (uv__stream_fd(handle) == -1);\n\n  if (new_sock) {\n    err = uv__socket(AF_UNIX, SOCK_STREAM, 0);\n    if (err \u003c 0)\n      goto out;\n    handle-\u003eio_watcher.fd = err;\n  }\n\n  memset(\u0026saddr, 0, sizeof saddr);\n  uv__strscpy(saddr.sun_path, name, sizeof(saddr.sun_path));\n  saddr.sun_family = AF_UNIX;\n\n  do {\n    r = connect(uv__stream_fd(handle),\n                (struct sockaddr*)\u0026saddr, sizeof saddr);\n  }\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r == -1 \u0026\u0026 errno != EINPROGRESS) {\n    err = UV__ERR(errno);\n#if defined(__CYGWIN__) || defined(__MSYS__)\n    /* EBADF is supposed to mean that the socket fd is bad, but\n       Cygwin reports EBADF instead of ENOTSOCK when the file is\n       not a socket.  We do not expect to see a bad fd here\n       (e.g. due to new_sock), so translate the error.  */\n    if (err == UV_EBADF)\n      err = UV_ENOTSOCK;\n#endif\n    goto out;\n  }\n\n  err = 0;\n  if (new_sock) {\n    err = uv__stream_open((uv_stream_t*)handle,\n                          uv__stream_fd(handle),\n                          UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);\n  }\n\n  if (err == 0)\n    uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLOUT);\n\nout:\n  handle-\u003edelayed_error = err;\n  handle-\u003econnect_req = req;\n\n  uv__req_init(handle-\u003eloop, req, UV_CONNECT);\n  req-\u003ehandle = (uv_stream_t*)handle;\n  req-\u003ecb = cb;\n  QUEUE_INIT(\u0026req-\u003equeue);\n\n  /* Force callback to run on next tick in case of error. */\n  if (err)\n    uv__io_feed(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n\n}","filepath":"src/unix/pipe.c","line_number":169,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5171072":{"score":0.83003896,"function_name":"uv_pipe_pending_count","code":"int uv_pipe_pending_count(uv_pipe_t* handle) {\n  uv__stream_queued_fds_t* queued_fds;\n\n  if (!handle-\u003eipc)\n    return 0;\n\n  if (handle-\u003eaccepted_fd == -1)\n    return 0;\n\n  if (handle-\u003equeued_fds == NULL)\n    return 1;\n\n  queued_fds = handle-\u003equeued_fds;\n  return queued_fds-\u003eoffset + 1;\n}","filepath":"src/unix/pipe.c","line_number":294,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5171152":{"score":0.71043843,"function_name":"uv_pipe_pending_type","code":"uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {\n  if (!handle-\u003eipc)\n    return UV_UNKNOWN_HANDLE;\n\n  if (handle-\u003eaccepted_fd == -1)\n    return UV_UNKNOWN_HANDLE;\n  else\n    return uv__handle_type(handle-\u003eaccepted_fd);\n}","filepath":"src/unix/pipe.c","line_number":311,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.26.0"},"5171200":{"score":0.7864007,"function_name":"uv__poll_io","code":"static void uv__poll_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  uv_poll_t* handle;\n  int pevents;\n\n  handle = container_of(w, uv_poll_t, io_watcher);\n\n  if (events \u0026 UV__POLLERR) {\n    uv__io_stop(loop, w, UV__POLLIN | UV__POLLOUT);\n    uv__handle_stop(handle);\n    handle-\u003epoll_cb(handle, -EBADF, 0);\n    return;\n  }\n\n  pevents = 0;\n  if (events \u0026 UV__POLLIN)\n    pevents |= UV_READABLE;\n  if (events \u0026 UV__POLLOUT)\n    pevents |= UV_WRITABLE;\n\n  handle-\u003epoll_cb(handle, 0, pevents);\n}","filepath":"src/unix/poll.c","line_number":30,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.3.0"},"5171392":{"score":0.85711247,"function_name":"uv_poll_init","code":"int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {\n  int err;\n\n  err = uv__nonblock(fd, 1);\n  if (err)\n    return err;\n\n  uv__handle_init(loop, (uv_handle_t*) handle, UV_POLL);\n  uv__io_init(\u0026handle-\u003eio_watcher, uv__poll_io, fd);\n  handle-\u003epoll_cb = NULL;\n  return 0;\n}","filepath":"src/unix/poll.c","line_number":53,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.3.0"},"5171584":{"score":0.88254553,"function_name":"uv_poll_start","code":"int uv_poll_start(uv_poll_t* handle, int pevents, uv_poll_cb poll_cb) {\n  int events;\n\n  assert((pevents \u0026 ~(UV_READABLE | UV_WRITABLE)) == 0);\n  assert(!(handle-\u003eflags \u0026 (UV_CLOSING | UV_CLOSED)));\n\n  uv__poll_stop(handle);\n\n  if (pevents == 0)\n    return 0;\n\n  events = 0;\n  if (pevents \u0026 UV_READABLE)\n    events |= UV__POLLIN;\n  if (pevents \u0026 UV_WRITABLE)\n    events |= UV__POLLOUT;\n\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, events);\n  uv__handle_start(handle);\n  handle-\u003epoll_cb = poll_cb;\n\n  return 0;\n}","filepath":"src/unix/poll.c","line_number":86,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.3.0"},"5171776":{"score":0.67503,"function_name":"uv__chld","code":"static void uv__chld(uv_signal_t* handle, int signum) {\n  uv_process_t* process;\n  int exit_status;\n  int term_signal;\n  int status;\n  pid_t pid;\n\n  assert(signum == SIGCHLD);\n\n  for (;;) {\n    do\n      pid = waitpid(-1, \u0026status, WNOHANG);\n    while (pid == -1 \u0026\u0026 errno == EINTR);\n\n    if (pid == 0)\n      return;\n\n    if (pid == -1) {\n      if (errno == ECHILD)\n        return; /* XXX stop signal watcher? */\n      else\n        abort();\n    }\n\n    process = uv__process_find(handle-\u003eloop, pid);\n    if (process == NULL)\n      continue; /* XXX bug? abort? */\n\n    uv__handle_stop(process);\n\n    if (process-\u003eexit_cb == NULL)\n      continue;\n\n    exit_status = 0;\n    term_signal = 0;\n\n    if (WIFEXITED(status))\n      exit_status = WEXITSTATUS(status);\n\n    if (WIFSIGNALED(status))\n      term_signal = WTERMSIG(status);\n\n    if (process-\u003eerrorno) {\n      uv__set_sys_error(process-\u003eloop, process-\u003eerrorno);\n      exit_status = -1; /* execve() failed */\n    }\n\n    process-\u003eexit_cb(process, exit_status, term_signal);\n  }\n}","filepath":"src/unix/process.c","line_number":70,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.10.34"},"5172208":{"score":0.651541,"function_name":"uv__make_socketpair","code":"int uv__make_socketpair(int fds[2], int flags) {\n#ifdef SOCK_NONBLOCK\n  int fl;\n\n  fl = SOCK_CLOEXEC;\n\n  if (flags \u0026 UV__F_NONBLOCK)\n    fl |= SOCK_NONBLOCK;\n\n  if (socketpair(AF_UNIX, SOCK_STREAM|fl, 0, fds) == 0)\n    return 0;\n\n  if (errno != EINVAL)\n    return -1;\n\n  /* errno == EINVAL so maybe the kernel headers lied about\n   * the availability of SOCK_NONBLOCK. This can happen if people\n   * build libuv against newer kernel headers than the kernel\n   * they actually run the software on.\n   */\n#endif\n\n  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))\n    return -1;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags \u0026 UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}","filepath":"src/unix/process.c","line_number":70,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"node-v0.7.10"},"5172288":{"score":0.6420984,"function_name":"uv__make_socketpair","code":"int uv__make_socketpair(int fds[2], int flags) {\n#if defined(__linux__)\n  static int no_cloexec;\n\n  if (no_cloexec)\n    goto skip;\n\n  if (socketpair(AF_UNIX, SOCK_STREAM | UV__SOCK_CLOEXEC | flags, 0, fds) == 0)\n    return 0;\n\n  /* Retry on EINVAL, it means SOCK_CLOEXEC is not supported.\n   * Anything else is a genuine error.\n   */\n  if (errno != EINVAL)\n    return -1;\n\n  no_cloexec = 1;\n\nskip:\n#endif\n\n  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))\n    return -1;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags \u0026 UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}","filepath":"src/unix/process.c","line_number":122,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.10.34"},"5172432":{"score":0.63449407,"function_name":"uv__make_pipe","code":"int uv__make_pipe(int fds[2], int flags) {\n#if defined(__linux__)\n  static int no_pipe2;\n\n  if (no_pipe2)\n    goto skip;\n\n  if (uv__pipe2(fds, flags | UV__O_CLOEXEC) == 0)\n    return 0;\n\n  if (errno != ENOSYS)\n    return -1;\n\n  no_pipe2 = 1;\n\nskip:\n#endif\n\n  if (pipe(fds))\n    return -1;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags \u0026 UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}","filepath":"src/unix/process.c","line_number":158,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.10.34"},"5172560":{"score":0.77193016,"function_name":"uv_spawn","code":"int uv_spawn(uv_loop_t* loop,\n             uv_process_t* process,\n             const uv_process_options_t* options) {\n  int signal_pipe[2] = { -1, -1 };\n  int (*pipes)[2];\n  int stdio_count;\n  ssize_t r;\n  pid_t pid;\n  int err;\n  int exec_errorno;\n  int i;\n  int status;\n\n  assert(options-\u003efile != NULL);\n  assert(!(options-\u003eflags \u0026 ~(UV_PROCESS_DETACHED |\n                              UV_PROCESS_SETGID |\n                              UV_PROCESS_SETUID |\n                              UV_PROCESS_WINDOWS_HIDE |\n                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));\n\n  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);\n  QUEUE_INIT(\u0026process-\u003equeue);\n\n  stdio_count = options-\u003estdio_count;\n  if (stdio_count \u003c 3)\n    stdio_count = 3;\n\n  err = -ENOMEM;\n  pipes = uv__malloc(stdio_count * sizeof(*pipes));\n  if (pipes == NULL)\n    goto error;\n\n  for (i = 0; i \u003c stdio_count; i++) {\n    pipes[i][0] = -1;\n    pipes[i][1] = -1;\n  }\n\n  for (i = 0; i \u003c options-\u003estdio_count; i++) {\n    err = uv__process_init_stdio(options-\u003estdio + i, pipes[i]);\n    if (err)\n      goto error;\n  }\n\n  /* This pipe is used by the parent to wait until\n   * the child has called `execve()`. We need this\n   * to avoid the following race condition:\n   *\n   *    if ((pid = fork()) \u003e 0) {\n   *      kill(pid, SIGTERM);\n   *    }\n   *    else if (pid == 0) {\n   *      execve(\"/bin/cat\", argp, envp);\n   *    }\n   *\n   * The parent sends a signal immediately after forking.\n   * Since the child may not have called `execve()` yet,\n   * there is no telling what process receives the signal,\n   * our fork or /bin/cat.\n   *\n   * To avoid ambiguity, we create a pipe with both ends\n   * marked close-on-exec. Then, after the call to `fork()`,\n   * the parent polls the read end until it EOFs or errors with EPIPE.\n   */\n  err = uv__make_pipe(signal_pipe, 0);\n  if (err)\n    goto error;\n\n  uv_signal_start(\u0026loop-\u003echild_watcher, uv__chld, SIGCHLD);\n\n  /* Acquire write lock to prevent opening new fds in worker threads */\n  uv_rwlock_wrlock(\u0026loop-\u003ecloexec_lock);\n  pid = fork();\n\n  if (pid == -1) {\n    err = -errno;\n    uv_rwlock_wrunlock(\u0026loop-\u003ecloexec_lock);\n    uv__close(signal_pipe[0]);\n    uv__close(signal_pipe[1]);\n    goto error;\n  }\n\n  if (pid == 0) {\n    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);\n    abort();\n  }\n\n  /* Release lock in parent process */\n  uv_rwlock_wrunlock(\u0026loop-\u003ecloexec_lock);\n  uv__close(signal_pipe[1]);\n\n  process-\u003estatus = 0;\n  exec_errorno = 0;\n  do\n    r = read(signal_pipe[0], \u0026exec_errorno, sizeof(exec_errorno));\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r == 0)\n    ; /* okay, EOF */\n  else if (r == sizeof(exec_errorno)) {\n    do\n      err = waitpid(pid, \u0026status, 0); /* okay, read errorno */\n    while (err == -1 \u0026\u0026 errno == EINTR);\n    assert(err == pid);\n  } else if (r == -1 \u0026\u0026 errno == EPIPE) {\n    do\n      err = waitpid(pid, \u0026status, 0); /* okay, got EPIPE */\n    while (err == -1 \u0026\u0026 errno == EINTR);\n    assert(err == pid);\n  } else\n    abort();\n\n  uv__close(signal_pipe[0]);\n\n  for (i = 0; i \u003c options-\u003estdio_count; i++) {\n    err = uv__process_open_stream(options-\u003estdio + i, pipes[i], i == 0);\n    if (err == 0)\n      continue;\n\n    while (i--)\n      uv__process_close_stream(options-\u003estdio + i);\n\n    goto error;\n  }\n\n  /* Only activate this handle if exec() happened successfully */\n  if (exec_errorno == 0) {\n    QUEUE_INSERT_TAIL(\u0026loop-\u003eprocess_handles, \u0026process-\u003equeue);\n    uv__handle_start(process);\n  }\n\n  process-\u003epid = pid;\n  process-\u003eexit_cb = options-\u003eexit_cb;\n\n  uv__free(pipes);\n  return exec_errorno;\n\nerror:\n  if (pipes != NULL) {\n    for (i = 0; i \u003c stdio_count; i++) {\n      if (i \u003c options-\u003estdio_count)\n        if (options-\u003estdio[i].flags \u0026 (UV_INHERIT_FD | UV_INHERIT_STREAM))\n          continue;\n      if (pipes[i][0] != -1)\n        close(pipes[i][0]);\n      if (pipes[i][1] != -1)\n        close(pipes[i][1]);\n    }\n    uv__free(pipes);\n  }\n\n  return err;\n}","filepath":"src/unix/process.c","line_number":379,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5174784":{"score":0.78520113,"function_name":"uv__signal_unlock","code":"static int uv__signal_unlock(void) {\n  int r;\n  char data = 42;\n\n  do {\n    r = write(uv__signal_lock_pipefd[1], \u0026data, sizeof data);\n  } while (r \u003c 0 \u0026\u0026 errno == EINTR);\n\n  return (r \u003c 0) ? -1 : 0;\n}","filepath":"src/unix/signal.c","line_number":119,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5174896":{"score":0.5996179,"function_name":"uv__signal_global_init","code":"static void uv__signal_global_init(void) {\n  if (!uv__signal_lock_pipefd[0])\n    /* pthread_atfork can register before and after handlers, one\n     * for each child. This only registers one for the child. That\n     * state is both persistent and cumulative, so if we keep doing\n     * it the handler functions will be called multiple times. Thus\n     * we only want to do it once.\n     */\n    if (pthread_atfork(NULL, NULL, \u0026uv__signal_global_reinit))\n      abort();\n\n  if (uv__make_pipe(uv__signal_lock_pipefd, 0))\n    abort();\n\n  if (uv__signal_unlock())\n    abort();\n}","filepath":"src/unix/signal.c","line_number":66,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5174992":{"score":0.8085147,"function_name":"uv__signal_lock","code":"static int uv__signal_lock(void) {\n  int r;\n  char data;\n\n  do {\n    r = read(uv__signal_lock_pipefd[0], \u0026data, sizeof data);\n  } while (r \u003c 0 \u0026\u0026 errno == EINTR);\n\n  return (r \u003c 0) ? -1 : 0;\n}","filepath":"src/unix/signal.c","line_number":107,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5175104":{"score":0.6230487,"function_name":"uv__signal_block_and_lock","code":"static void uv__signal_block_and_lock(sigset_t* saved_sigmask) {\n  sigset_t new_mask;\n\n  if (sigfillset(\u0026new_mask))\n    abort();\n\n  if (pthread_sigmask(SIG_SETMASK, \u0026new_mask, saved_sigmask))\n    abort();\n\n  if (uv__signal_lock())\n    abort();\n}","filepath":"src/unix/signal.c","line_number":131,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5175216":{"score":0.8060934,"function_name":"uv__signal_event","code":"static void uv__signal_event(uv_loop_t* loop,\n                             uv__io_t* w,\n                             unsigned int events) {\n  uv__signal_msg_t* msg;\n  uv_signal_t* handle;\n  char buf[sizeof(uv__signal_msg_t) * 32];\n  size_t bytes, end, i;\n  int r;\n\n  bytes = 0;\n  end = 0;\n\n  do {\n    r = read(loop-\u003esignal_pipefd[0], buf + bytes, sizeof(buf) - bytes);\n\n    if (r == -1 \u0026\u0026 errno == EINTR)\n      continue;\n\n    if (r == -1 \u0026\u0026 (errno == EAGAIN || errno == EWOULDBLOCK)) {\n      /* If there are bytes in the buffer already (which really is extremely\n       * unlikely if possible at all) we can't exit the function here. We'll\n       * spin until more bytes are read instead.\n       */\n      if (bytes \u003e 0)\n        continue;\n\n      /* Otherwise, there was nothing there. */\n      return;\n    }\n\n    /* Other errors really should never happen. */\n    if (r == -1)\n      abort();\n\n    bytes += r;\n\n    /* `end` is rounded down to a multiple of sizeof(uv__signal_msg_t). */\n    end = (bytes / sizeof(uv__signal_msg_t)) * sizeof(uv__signal_msg_t);\n\n    for (i = 0; i \u003c end; i += sizeof(uv__signal_msg_t)) {\n      msg = (uv__signal_msg_t*) (buf + i);\n      handle = msg-\u003ehandle;\n\n      if (msg-\u003esignum == handle-\u003esignum) {\n        assert(!(handle-\u003eflags \u0026 UV_CLOSING));\n        handle-\u003esignal_cb(handle, handle-\u003esignum);\n      }\n\n      handle-\u003edispatched_signals++;\n\n      if (handle-\u003eflags \u0026 UV__SIGNAL_ONE_SHOT)\n        uv__signal_stop(handle);\n\n      /* If uv_close was called while there were caught signals that were not\n       * yet dispatched, the uv__finish_close was deferred. Make close pending\n       * now if this has happened.\n       */\n      if ((handle-\u003eflags \u0026 UV_CLOSING) \u0026\u0026\n          (handle-\u003ecaught_signals == handle-\u003edispatched_signals)) {\n        uv__make_close_pending((uv_handle_t*) handle);\n      }\n    }\n\n    bytes -= end;\n\n    /* If there are any \"partial\" messages left, move them to the start of the\n     * the buffer, and spin. This should not happen.\n     */\n    if (bytes) {\n      memmove(buf, buf + end, bytes);\n      continue;\n    }\n  } while (end == sizeof buf);\n}","filepath":"src/unix/signal.c","line_number":414,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5175584":{"score":0.68742806,"function_name":"uv__signal_first_handle","code":"static uv_signal_t* uv__signal_first_handle(int signum) {\n  /* This function must be called with the signal lock held. */\n  uv_signal_t lookup;\n  uv_signal_t* handle;\n\n  lookup.signum = signum;\n  lookup.flags = 0;\n  lookup.loop = NULL;\n\n  handle = RB_NFIND(uv__signal_tree_s, \u0026uv__signal_tree, \u0026lookup);\n\n  if (handle != NULL \u0026\u0026 handle-\u003esignum == signum)\n    return handle;\n\n  return NULL;\n}","filepath":"src/unix/signal.c","line_number":154,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5175744":{"score":0.84287095,"function_name":"uv__signal_handler","code":"static void uv__signal_handler(int signum) {\n  uv__signal_msg_t msg;\n  uv_signal_t* handle;\n  int saved_errno;\n\n  saved_errno = errno;\n  memset(\u0026msg, 0, sizeof msg);\n\n  if (uv__signal_lock()) {\n    errno = saved_errno;\n    return;\n  }\n\n  for (handle = uv__signal_first_handle(signum);\n       handle != NULL \u0026\u0026 handle-\u003esignum == signum;\n       handle = RB_NEXT(uv__signal_tree_s, \u0026uv__signal_tree, handle)) {\n    int r;\n\n    msg.signum = signum;\n    msg.handle = handle;\n\n    /* write() should be atomic for small data chunks, so the entire message\n     * should be written at once. In theory the pipe could become full, in\n     * which case the user is out of luck.\n     */\n    do {\n      r = write(handle-\u003eloop-\u003esignal_pipefd[1], \u0026msg, sizeof msg);\n    } while (r == -1 \u0026\u0026 errno == EINTR);\n\n    assert(r == sizeof msg ||\n           (r == -1 \u0026\u0026 (errno == EAGAIN || errno == EWOULDBLOCK)));\n\n    if (r != -1)\n      handle-\u003ecaught_signals++;\n  }\n\n  uv__signal_unlock();\n  errno = saved_errno;\n}","filepath":"src/unix/signal.c","line_number":172,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5178064":{"score":0.82719684,"function_name":"uv__signal_loop_cleanup","code":"void uv__signal_loop_cleanup(uv_loop_t* loop) {\n  QUEUE* q;\n\n  /* Stop all the signal watchers that are still attached to this loop. This\n   * ensures that the (shared) signal tree doesn't contain any invalid entries\n   * entries, and that signal handlers are removed when appropriate.\n   * It's safe to use QUEUE_FOREACH here because the handles and the handle\n   * queue are not modified by uv__signal_stop().\n   */\n  QUEUE_FOREACH(q, \u0026loop-\u003ehandle_queue) {\n    uv_handle_t* handle = QUEUE_DATA(q, uv_handle_t, handle_queue);\n\n    if (handle-\u003etype == UV_SIGNAL)\n      uv__signal_stop((uv_signal_t*) handle);\n  }\n\n  if (loop-\u003esignal_pipefd[0] != -1) {\n    uv__close(loop-\u003esignal_pipefd[0]);\n    loop-\u003esignal_pipefd[0] = -1;\n  }\n\n  if (loop-\u003esignal_pipefd[1] != -1) {\n    uv__close(loop-\u003esignal_pipefd[1]);\n    loop-\u003esignal_pipefd[1] = -1;\n  }\n}","filepath":"src/unix/signal.c","line_number":280,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5178208":{"score":0.6383471,"function_name":"uv_signal_init","code":"int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {\n  int err;\n\n  err = uv__signal_loop_once_init(loop);\n  if (err)\n    return err;\n\n  uv__handle_init(loop, (uv_handle_t*) handle, UV_SIGNAL);\n  handle-\u003esignum = 0;\n  handle-\u003ecaught_signals = 0;\n  handle-\u003edispatched_signals = 0;\n\n  return 0;\n}","filepath":"src/unix/signal.c","line_number":308,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5178448":{"score":0.7051607,"function_name":"uv__signal_start","code":"static int uv__signal_start(uv_signal_t* handle,\n                            uv_signal_cb signal_cb,\n                            int signum,\n                            int oneshot) {\n  sigset_t saved_sigmask;\n  int err;\n  uv_signal_t* first_handle;\n\n  assert(!uv__is_closing(handle));\n\n  /* If the user supplies signum == 0, then return an error already. If the\n   * signum is otherwise invalid then uv__signal_register will find out\n   * eventually.\n   */\n  if (signum == 0)\n    return -EINVAL;\n\n  /* Short circuit: if the signal watcher is already watching {signum} don't\n   * go through the process of deregistering and registering the handler.\n   * Additionally, this avoids pending signals getting lost in the small time\n   * time frame that handle-\u003esignum == 0.\n   */\n  if (signum == handle-\u003esignum) {\n    handle-\u003esignal_cb = signal_cb;\n    return 0;\n  }\n\n  /* If the signal handler was already active, stop it first. */\n  if (handle-\u003esignum != 0) {\n    uv__signal_stop(handle);\n  }\n\n  uv__signal_block_and_lock(\u0026saved_sigmask);\n\n  /* If at this point there are no active signal watchers for this signum (in\n   * any of the loops), it's time to try and register a handler for it here.\n   * Also in case there's only one-shot handlers and a regular handler comes in.\n   */\n  first_handle = uv__signal_first_handle(signum);\n  if (first_handle == NULL ||\n      (!oneshot \u0026\u0026 (first_handle-\u003eflags \u0026 UV__SIGNAL_ONE_SHOT))) {\n    err = uv__signal_register_handler(signum, oneshot);\n    if (err) {\n      /* Registering the signal handler failed. Must be an invalid signal. */\n      uv__signal_unlock_and_unblock(\u0026saved_sigmask);\n      return err;\n    }\n  }\n\n  handle-\u003esignum = signum;\n  if (oneshot)\n    handle-\u003eflags |= UV__SIGNAL_ONE_SHOT;\n\n  RB_INSERT(uv__signal_tree_s, \u0026uv__signal_tree, handle);\n\n  uv__signal_unlock_and_unblock(\u0026saved_sigmask);\n\n  handle-\u003esignal_cb = signal_cb;\n  uv__handle_start(handle);\n\n  return 0;\n}","filepath":"src/unix/signal.c","line_number":350,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.19.0"},"5179840":{"score":0.5711656,"function_name":"uv_read_stop","code":"int uv_read_stop(uv_stream_t* stream) {\n  /* Sanity check. We're going to stop the handle unless it's primed for\n   * writing but that means there should be some kind of write action in\n   * progress.\n   */\n  assert(!uv__io_active(\u0026stream-\u003eio_watcher, UV__POLLOUT) ||\n         !QUEUE_EMPTY(\u0026stream-\u003ewrite_completed_queue) ||\n         !QUEUE_EMPTY(\u0026stream-\u003ewrite_queue) ||\n         stream-\u003eshutdown_req != NULL ||\n         stream-\u003econnect_req != NULL);\n\n  stream-\u003eflags \u0026= ~UV_STREAM_READING;\n  uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, UV__POLLIN);\n  if (!uv__io_active(\u0026stream-\u003eio_watcher, UV__POLLOUT))\n    uv__handle_stop(stream);\n\n#if defined(__APPLE__)\n  /* Notify select() thread about state change */\n  if (stream-\u003eselect != NULL)\n    uv__stream_osx_interrupt_select(stream);\n#endif /* defined(__APPLE__) */\n\n  stream-\u003eread_cb = NULL;\n  stream-\u003eread2_cb = NULL;\n  stream-\u003ealloc_cb = NULL;\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1357,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.12"},"5179888":{"score":0.8535342,"function_name":"uv__stream_eof","code":"static void uv__stream_eof(uv_stream_t* stream, const uv_buf_t* buf) {\n  stream-\u003eflags |= UV_STREAM_READ_EOF;\n  uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n  if (!uv__io_active(\u0026stream-\u003eio_watcher, POLLOUT))\n    uv__handle_stop(stream);\n  uv__stream_osx_interrupt_select(stream);\n  stream-\u003eread_cb(stream, UV_EOF, buf);\n  stream-\u003eflags \u0026= ~UV_STREAM_READING;\n}","filepath":"src/unix/stream.c","line_number":1017,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5180000":{"score":0.697526,"function_name":"uv__write_req_finish","code":"static void uv__write_req_finish(uv_write_t* req) {\n  uv_stream_t* stream = req-\u003ehandle;\n\n  /* Pop the req off tcp-\u003ewrite_queue. */\n  QUEUE_REMOVE(\u0026req-\u003equeue);\n\n  /* Only free when there was no error. On error, we touch up write_queue_size\n   * right before making the callback. The reason we don't do that right away\n   * is that a write_queue_size \u003e 0 is our only way to signal to the user that\n   * they should stop writing - which they should if we got an error. Something\n   * to revisit in future revisions of the libuv API.\n   */\n  if (req-\u003eerror == 0) {\n    if (req-\u003ebufs != req-\u003ebufsml)\n      uv__free(req-\u003ebufs);\n    req-\u003ebufs = NULL;\n  }\n\n  /* Add it to the write_completed_queue where it will have its\n   * callback called in the near future.\n   */\n  QUEUE_INSERT_TAIL(\u0026stream-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n  uv__io_feed(stream-\u003eloop, \u0026stream-\u003eio_watcher);\n}","filepath":"src/unix/stream.c","line_number":712,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5180144":{"score":0.89361346,"function_name":"uv__write","code":"static void uv__write(uv_stream_t* stream) {\n  struct iovec* iov;\n  QUEUE* q;\n  uv_write_t* req;\n  int iovmax;\n  int iovcnt;\n  ssize_t n;\n\nstart:\n\n  assert(uv__stream_fd(stream) \u003e= 0);\n\n  if (QUEUE_EMPTY(\u0026stream-\u003ewrite_queue))\n    return;\n\n  q = QUEUE_HEAD(\u0026stream-\u003ewrite_queue);\n  req = QUEUE_DATA(q, uv_write_t, queue);\n  assert(req-\u003ehandle == stream);\n\n  /*\n   * Cast to iovec. We had to have our own uv_buf_t instead of iovec\n   * because Windows's WSABUF is not an iovec.\n   */\n  assert(sizeof(uv_buf_t) == sizeof(struct iovec));\n  iov = (struct iovec*) \u0026(req-\u003ebufs[req-\u003ewrite_index]);\n  iovcnt = req-\u003enbufs - req-\u003ewrite_index;\n\n  iovmax = uv__getiovmax();\n\n  /* Limit iov count to avoid EINVALs from writev() */\n  if (iovcnt \u003e iovmax)\n    iovcnt = iovmax;\n\n  /*\n   * Now do the actual writev. Note that we've been updating the pointers\n   * inside the iov each time we write. So there is no need to offset it.\n   */\n\n  if (req-\u003esend_handle) {\n    struct msghdr msg;\n    char scratch[64];\n    struct cmsghdr *cmsg;\n    int fd_to_send = uv__handle_fd((uv_handle_t*) req-\u003esend_handle);\n\n    assert(fd_to_send \u003e= 0);\n\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n    msg.msg_iov = iov;\n    msg.msg_iovlen = iovcnt;\n    msg.msg_flags = 0;\n\n    msg.msg_control = (void*) scratch;\n    msg.msg_controllen = CMSG_LEN(sizeof(fd_to_send));\n\n    cmsg = CMSG_FIRSTHDR(\u0026msg);\n    cmsg-\u003ecmsg_level = SOL_SOCKET;\n    cmsg-\u003ecmsg_type = SCM_RIGHTS;\n    cmsg-\u003ecmsg_len = msg.msg_controllen;\n\n    /* silence aliasing warning */\n    {\n      void* pv = CMSG_DATA(cmsg);\n      int* pi = pv;\n      *pi = fd_to_send;\n    }\n\n    do {\n      n = sendmsg(uv__stream_fd(stream), \u0026msg, 0);\n    }\n    while (n == -1 \u0026\u0026 errno == EINTR);\n  } else {\n    do {\n      if (iovcnt == 1) {\n        n = write(uv__stream_fd(stream), iov[0].iov_base, iov[0].iov_len);\n      } else {\n        n = writev(uv__stream_fd(stream), iov, iovcnt);\n      }\n    }\n    while (n == -1 \u0026\u0026 errno == EINTR);\n  }\n\n  if (n \u003c 0) {\n    if (errno != EAGAIN \u0026\u0026 errno != EWOULDBLOCK) {\n      /* Error */\n      req-\u003eerror = -errno;\n      uv__write_req_finish(req);\n      uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, UV__POLLOUT);\n      if (!uv__io_active(\u0026stream-\u003eio_watcher, UV__POLLIN))\n        uv__handle_stop(stream);\n      return;\n    } else if (stream-\u003eflags \u0026 UV_STREAM_BLOCKING) {\n      /* If this is a blocking stream, try again. */\n      goto start;\n    }\n  } else {\n    /* Successful write */\n\n    while (n \u003e= 0) {\n      uv_buf_t* buf = \u0026(req-\u003ebufs[req-\u003ewrite_index]);\n      size_t len = buf-\u003elen;\n\n      assert(req-\u003ewrite_index \u003c req-\u003enbufs);\n\n      if ((size_t)n \u003c len) {\n        buf-\u003ebase += n;\n        buf-\u003elen -= n;\n        stream-\u003ewrite_queue_size -= n;\n        n = 0;\n\n        /* There is more to write. */\n        if (stream-\u003eflags \u0026 UV_STREAM_BLOCKING) {\n          /*\n           * If we're blocking then we should not be enabling the write\n           * watcher - instead we need to try again.\n           */\n          goto start;\n        } else {\n          /* Break loop and ensure the watcher is pending. */\n          break;\n        }\n\n      } else {\n        /* Finished writing the buf at index req-\u003ewrite_index. */\n        req-\u003ewrite_index++;\n\n        assert((size_t)n \u003e= len);\n        n -= len;\n\n        assert(stream-\u003ewrite_queue_size \u003e= len);\n        stream-\u003ewrite_queue_size -= len;\n\n        if (req-\u003ewrite_index == req-\u003enbufs) {\n          /* Then we're done! */\n          assert(n == 0);\n          uv__write_req_finish(req);\n          /* TODO: start trying to write the next request. */\n          return;\n        }\n      }\n    }\n  }\n\n  /* Either we've counted n down to zero or we've got EAGAIN. */\n  assert(n == 0 || n == -1);\n\n  /* Only non-blocking streams should use the write_watcher. */\n  assert(!(stream-\u003eflags \u0026 UV_STREAM_BLOCKING));\n\n  /* We're not done. */\n  uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, UV__POLLOUT);\n}","filepath":"src/unix/stream.c","line_number":720,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.12"},"5181216":{"score":0.80783796,"function_name":"uv__read","code":"static void uv__read(uv_stream_t* stream) {\n  uv_buf_t buf;\n  ssize_t nread;\n  struct msghdr msg;\n  struct cmsghdr* cmsg;\n  char cmsg_space[64];\n  int count;\n\n  stream-\u003eflags \u0026= ~UV_STREAM_READ_PARTIAL;\n\n  /* Prevent loop starvation when the data comes in as fast as (or faster than)\n   * we can read it. XXX Need to rearm fd if we switch to edge-triggered I/O.\n   */\n  count = 32;\n\n  /* XXX: Maybe instead of having UV_STREAM_READING we just test if\n   * tcp-\u003eread_cb is NULL or not?\n   */\n  while ((stream-\u003eread_cb || stream-\u003eread2_cb)\n      \u0026\u0026 (stream-\u003eflags \u0026 UV_STREAM_READING)\n      \u0026\u0026 (count-- \u003e 0)) {\n    assert(stream-\u003ealloc_cb != NULL);\n\n    stream-\u003ealloc_cb((uv_handle_t*)stream, 64 * 1024, \u0026buf);\n    if (buf.len == 0) {\n      /* User indicates it can't or won't handle the read. */\n      uv__stream_read_cb(stream, UV_ENOBUFS, \u0026buf, UV_UNKNOWN_HANDLE);\n      return;\n    }\n\n    assert(buf.base != NULL);\n    assert(uv__stream_fd(stream) \u003e= 0);\n\n    if (stream-\u003eread_cb) {\n      do {\n        nread = read(uv__stream_fd(stream), buf.base, buf.len);\n      }\n      while (nread \u003c 0 \u0026\u0026 errno == EINTR);\n    } else {\n      assert(stream-\u003eread2_cb);\n      /* read2_cb uses recvmsg */\n      msg.msg_flags = 0;\n      msg.msg_iov = (struct iovec*) \u0026buf;\n      msg.msg_iovlen = 1;\n      msg.msg_name = NULL;\n      msg.msg_namelen = 0;\n      /* Set up to receive a descriptor even if one isn't in the message */\n      msg.msg_controllen = 64;\n      msg.msg_control = (void*)  cmsg_space;\n\n      do {\n        nread = recvmsg(uv__stream_fd(stream), \u0026msg, 0);\n      }\n      while (nread \u003c 0 \u0026\u0026 errno == EINTR);\n    }\n\n    if (nread \u003c 0) {\n      /* Error */\n      if (errno == EAGAIN || errno == EWOULDBLOCK) {\n        /* Wait for the next one. */\n        if (stream-\u003eflags \u0026 UV_STREAM_READING) {\n          uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, UV__POLLIN);\n        }\n        uv__stream_read_cb(stream, 0, \u0026buf, UV_UNKNOWN_HANDLE);\n      } else {\n        /* Error. User should call uv_close(). */\n        uv__stream_read_cb(stream, -errno, \u0026buf, UV_UNKNOWN_HANDLE);\n        assert(!uv__io_active(\u0026stream-\u003eio_watcher, UV__POLLIN) \u0026\u0026\n               \"stream-\u003eread_cb(status=-1) did not call uv_close()\");\n      }\n      return;\n    } else if (nread == 0) {\n      uv__stream_eof(stream, \u0026buf);\n      return;\n    } else {\n      /* Successful read */\n      ssize_t buflen = buf.len;\n\n      if (stream-\u003eread_cb) {\n        stream-\u003eread_cb(stream, nread, \u0026buf);\n      } else {\n        assert(stream-\u003eread2_cb);\n\n        /*\n         * XXX: Some implementations can send multiple file descriptors in a\n         * single message. We should be using CMSG_NXTHDR() to walk the\n         * chain to get at them all. This would require changing the API to\n         * hand these back up the caller, is a pain.\n         */\n\n        for (cmsg = CMSG_FIRSTHDR(\u0026msg);\n             msg.msg_controllen \u003e 0 \u0026\u0026 cmsg != NULL;\n             cmsg = CMSG_NXTHDR(\u0026msg, cmsg)) {\n\n          if (cmsg-\u003ecmsg_type == SCM_RIGHTS) {\n            if (stream-\u003eaccepted_fd != -1) {\n              fprintf(stderr, \"(libuv) ignoring extra FD received\\n\");\n            }\n\n            /* silence aliasing warning */\n            {\n              void* pv = CMSG_DATA(cmsg);\n              int* pi = pv;\n              stream-\u003eaccepted_fd = *pi;\n            }\n\n          } else {\n            fprintf(stderr, \"ignoring non-SCM_RIGHTS ancillary data: %d\\n\",\n                cmsg-\u003ecmsg_type);\n          }\n        }\n\n\n        if (stream-\u003eaccepted_fd \u003e= 0) {\n          stream-\u003eread2_cb((uv_pipe_t*) stream,\n                           nread,\n                           \u0026buf,\n                           uv__handle_type(stream-\u003eaccepted_fd));\n        } else {\n          stream-\u003eread2_cb((uv_pipe_t*) stream, nread, \u0026buf, UV_UNKNOWN_HANDLE);\n        }\n      }\n\n      /* Return if we didn't fill the buffer, there is no more data to read. */\n      if (nread \u003c buflen) {\n        stream-\u003eflags |= UV_STREAM_READ_PARTIAL;\n        return;\n      }\n    }\n  }\n}","filepath":"src/unix/stream.c","line_number":959,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.12"},"5182624":{"score":0.889595,"function_name":"uv__write_req_size","code":"static size_t uv__write_req_size(uv_write_t* req) {\n  size_t size;\n\n  assert(req-\u003ebufs != NULL);\n  size = uv_count_bufs(req-\u003ebufs + req-\u003ewrite_index,\n                       req-\u003enbufs - req-\u003ewrite_index);\n  assert(req-\u003ehandle-\u003ewrite_queue_size \u003e= size);\n\n  return size;\n}","filepath":"src/unix/stream.c","line_number":655,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.12"},"5182736":{"score":0.8414904,"function_name":"uv__write_callbacks","code":"static void uv__write_callbacks(uv_stream_t* stream) {\n  uv_write_t* req;\n  QUEUE* q;\n\n  while (!QUEUE_EMPTY(\u0026stream-\u003ewrite_completed_queue)) {\n    /* Pop a req off write_completed_queue. */\n    q = QUEUE_HEAD(\u0026stream-\u003ewrite_completed_queue);\n    req = QUEUE_DATA(q, uv_write_t, queue);\n    QUEUE_REMOVE(q);\n    uv__req_unregister(stream-\u003eloop, req);\n\n    if (req-\u003ebufs != NULL) {\n      stream-\u003ewrite_queue_size -= uv__write_req_size(req);\n      if (req-\u003ebufs != req-\u003ebufsml)\n        uv__free(req-\u003ebufs);\n      req-\u003ebufs = NULL;\n    }\n\n    /* NOTE: call callback AFTER freeing the request data. */\n    if (req-\u003ecb)\n      req-\u003ecb(req, req-\u003eerror);\n  }\n\n  assert(QUEUE_EMPTY(\u0026stream-\u003ewrite_completed_queue));\n}","filepath":"src/unix/stream.c","line_number":947,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5182960":{"score":0.79120195,"function_name":"uv__stream_io","code":"static void uv__stream_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  uv_stream_t* stream;\n\n  stream = container_of(w, uv_stream_t, io_watcher);\n\n  assert(stream-\u003etype == UV_TCP ||\n         stream-\u003etype == UV_NAMED_PIPE ||\n         stream-\u003etype == UV_TTY);\n  assert(!(stream-\u003eflags \u0026 UV_CLOSING));\n\n  if (stream-\u003econnect_req) {\n    uv__stream_connect(stream);\n    return;\n  }\n\n  assert(uv__stream_fd(stream) \u003e= 0);\n\n  /* Ignore POLLHUP here. Even if it's set, there may still be data to read. */\n  if (events \u0026 (POLLIN | POLLERR | POLLHUP))\n    uv__read(stream);\n\n  if (uv__stream_fd(stream) == -1)\n    return;  /* read_cb closed stream. */\n\n  /* Short-circuit iff POLLHUP is set, the user is still interested in read\n   * events and uv__read() reported a partial read but not EOF. If the EOF\n   * flag is set, uv__read() called read_cb with err=UV_EOF and we don't\n   * have to do anything. If the partial read flag is not set, we can't\n   * report the EOF yet because there is still data to read.\n   */\n  if ((events \u0026 POLLHUP) \u0026\u0026\n      (stream-\u003eflags \u0026 UV_STREAM_READING) \u0026\u0026\n      (stream-\u003eflags \u0026 UV_STREAM_READ_PARTIAL) \u0026\u0026\n      !(stream-\u003eflags \u0026 UV_STREAM_READ_EOF)) {\n    uv_buf_t buf = { NULL, 0 };\n    uv__stream_eof(stream, \u0026buf);\n  }\n\n  if (uv__stream_fd(stream) == -1)\n    return;  /* read_cb closed stream. */\n\n  if (events \u0026 (POLLOUT | POLLERR | POLLHUP)) {\n    uv__write(stream);\n    uv__write_callbacks(stream);\n\n    /* Write queue drained. */\n    if (QUEUE_EMPTY(\u0026stream-\u003ewrite_queue))\n      uv__drain(stream);\n  }\n}","filepath":"src/unix/stream.c","line_number":1298,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5183968":{"score":0.77940416,"function_name":"uv__stream_init","code":"void uv__stream_init(uv_loop_t* loop,\n                     uv_stream_t* stream,\n                     uv_handle_type type) {\n  int err;\n\n  uv__handle_init(loop, (uv_handle_t*)stream, type);\n  stream-\u003eread_cb = NULL;\n  stream-\u003ealloc_cb = NULL;\n  stream-\u003eclose_cb = NULL;\n  stream-\u003econnection_cb = NULL;\n  stream-\u003econnect_req = NULL;\n  stream-\u003eshutdown_req = NULL;\n  stream-\u003eaccepted_fd = -1;\n  stream-\u003equeued_fds = NULL;\n  stream-\u003edelayed_error = 0;\n  QUEUE_INIT(\u0026stream-\u003ewrite_queue);\n  QUEUE_INIT(\u0026stream-\u003ewrite_completed_queue);\n  stream-\u003ewrite_queue_size = 0;\n\n  if (loop-\u003eemfile_fd == -1) {\n    err = uv__open_cloexec(\"/dev/null\", O_RDONLY);\n    if (err \u003c 0)\n        /* In the rare case that \"/dev/null\" isn't mounted open \"/\"\n         * instead.\n         */\n        err = uv__open_cloexec(\"/\", O_RDONLY);\n    if (err \u003e= 0)\n      loop-\u003eemfile_fd = err;\n  }\n\n#if defined(__APPLE__)\n  stream-\u003eselect = NULL;\n#endif /* defined(__APPLE_) */\n\n  uv__io_init(\u0026stream-\u003eio_watcher, uv__stream_io, -1);\n}","filepath":"src/unix/stream.c","line_number":77,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5184272":{"score":0.92063564,"function_name":"uv__stream_open","code":"int uv__stream_open(uv_stream_t* stream, int fd, int flags) {\n#if defined(__APPLE__)\n  int enable;\n#endif\n\n  if (!(stream-\u003eio_watcher.fd == -1 || stream-\u003eio_watcher.fd == fd))\n    return UV_EBUSY;\n\n  assert(fd \u003e= 0);\n  stream-\u003eflags |= flags;\n\n  if (stream-\u003etype == UV_TCP) {\n    if ((stream-\u003eflags \u0026 UV_TCP_NODELAY) \u0026\u0026 uv__tcp_nodelay(fd, 1))\n      return UV__ERR(errno);\n\n    /* TODO Use delay the user passed in. */\n    if ((stream-\u003eflags \u0026 UV_TCP_KEEPALIVE) \u0026\u0026 uv__tcp_keepalive(fd, 1, 60))\n      return UV__ERR(errno);\n  }\n\n#if defined(__APPLE__)\n  enable = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_OOBINLINE, \u0026enable, sizeof(enable)) \u0026\u0026\n      errno != ENOTSOCK \u0026\u0026\n      errno != EINVAL) {\n    return UV__ERR(errno);\n  }\n#endif\n\n  stream-\u003eio_watcher.fd = fd;\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":398,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5184448":{"score":0.75840104,"function_name":"uv__stream_flush_write_queue","code":"void uv__stream_flush_write_queue(uv_stream_t* stream, int error) {\n  uv_write_t* req;\n  QUEUE* q;\n  while (!QUEUE_EMPTY(\u0026stream-\u003ewrite_queue)) {\n    q = QUEUE_HEAD(\u0026stream-\u003ewrite_queue);\n    QUEUE_REMOVE(q);\n\n    req = QUEUE_DATA(q, uv_write_t, queue);\n    req-\u003eerror = error;\n\n    QUEUE_INSERT_TAIL(\u0026stream-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n  }\n}","filepath":"src/unix/stream.c","line_number":433,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5184544":{"score":0.82495576,"function_name":"uv__stream_destroy","code":"void uv__stream_destroy(uv_stream_t* stream) {\n  assert(!uv__io_active(\u0026stream-\u003eio_watcher, POLLIN | POLLOUT));\n  assert(stream-\u003eflags \u0026 UV_CLOSED);\n\n  if (stream-\u003econnect_req) {\n    uv__req_unregister(stream-\u003eloop, stream-\u003econnect_req);\n    stream-\u003econnect_req-\u003ecb(stream-\u003econnect_req, UV_ECANCELED);\n    stream-\u003econnect_req = NULL;\n  }\n\n  uv__stream_flush_write_queue(stream, UV_ECANCELED);\n  uv__write_callbacks(stream);\n\n  if (stream-\u003eshutdown_req) {\n    /* The ECANCELED error code is a lie, the shutdown(2) syscall is a\n     * fait accompli at this point. Maybe we should revisit this in v0.11.\n     * A possible reason for leaving it unchanged is that it informs the\n     * callee that the handle has been destroyed.\n     */\n    uv__req_unregister(stream-\u003eloop, stream-\u003eshutdown_req);\n    stream-\u003eshutdown_req-\u003ecb(stream-\u003eshutdown_req, UV_ECANCELED);\n    stream-\u003eshutdown_req = NULL;\n  }\n\n  assert(stream-\u003ewrite_queue_size == 0);\n}","filepath":"src/unix/stream.c","line_number":448,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5184992":{"score":0.8377018,"function_name":"uv__server_io","code":"void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  uv_stream_t* stream;\n  int err;\n\n  stream = container_of(w, uv_stream_t, io_watcher);\n  assert(events == UV__POLLIN);\n  assert(stream-\u003eaccepted_fd == -1);\n  assert(!(stream-\u003eflags \u0026 UV_CLOSING));\n\n  uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, UV__POLLIN);\n\n  /* connection_cb can close the server socket while we're\n   * in the loop so check it on each iteration.\n   */\n  while (uv__stream_fd(stream) != -1) {\n    assert(stream-\u003eaccepted_fd == -1);\n\n#if defined(UV_HAVE_KQUEUE)\n    if (w-\u003ercount \u003c= 0)\n      return;\n#endif /* defined(UV_HAVE_KQUEUE) */\n\n    err = uv__accept(uv__stream_fd(stream));\n    if (err \u003c 0) {\n      if (err == -EAGAIN || err == -EWOULDBLOCK)\n        return;  /* Not an error. */\n\n      if (err == -ECONNABORTED)\n        continue;  /* Ignore. Nothing we can do about that. */\n\n      if (err == -EMFILE || err == -ENFILE) {\n        err = uv__emfile_trick(loop, uv__stream_fd(stream));\n        if (err == -EAGAIN || err == -EWOULDBLOCK)\n          break;\n      }\n\n      stream-\u003econnection_cb(stream, err);\n      continue;\n    }\n\n    UV_DEC_BACKLOG(w)\n    stream-\u003eaccepted_fd = err;\n    stream-\u003econnection_cb(stream, 0);\n\n    if (stream-\u003eaccepted_fd != -1) {\n      /* The user hasn't yet accepted called uv_accept() */\n      uv__io_stop(loop, \u0026stream-\u003eio_watcher, UV__POLLIN);\n      return;\n    }\n\n    if (stream-\u003etype == UV_TCP \u0026\u0026 (stream-\u003eflags \u0026 UV_TCP_SINGLE_ACCEPT)) {\n      /* Give other processes a chance to accept connections. */\n      struct timespec timeout = { 0, 1 };\n      nanosleep(\u0026timeout, NULL);\n    }\n  }\n}","filepath":"src/unix/stream.c","line_number":496,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.12"},"5185520":{"score":0.7847535,"function_name":"uv_accept","code":"int uv_accept(uv_stream_t* server, uv_stream_t* client) {\n  int err;\n\n  assert(server-\u003eloop == client-\u003eloop);\n\n  if (server-\u003eaccepted_fd == -1)\n    return UV_EAGAIN;\n\n  switch (client-\u003etype) {\n    case UV_NAMED_PIPE:\n    case UV_TCP:\n      err = uv__stream_open(client,\n                            server-\u003eaccepted_fd,\n                            UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n      if (err) {\n        /* TODO handle error */\n        uv__close(server-\u003eaccepted_fd);\n        goto done;\n      }\n      break;\n\n    case UV_UDP:\n      err = uv_udp_open((uv_udp_t*) client, server-\u003eaccepted_fd);\n      if (err) {\n        uv__close(server-\u003eaccepted_fd);\n        goto done;\n      }\n      break;\n\n    default:\n      return UV_EINVAL;\n  }\n\n  client-\u003eflags |= UV_HANDLE_BOUND;\n\ndone:\n  /* Process queued fds */\n  if (server-\u003equeued_fds != NULL) {\n    uv__stream_queued_fds_t* queued_fds;\n\n    queued_fds = server-\u003equeued_fds;\n\n    /* Read first */\n    server-\u003eaccepted_fd = queued_fds-\u003efds[0];\n\n    /* All read, free */\n    assert(queued_fds-\u003eoffset \u003e 0);\n    if (--queued_fds-\u003eoffset == 0) {\n      uv__free(queued_fds);\n      server-\u003equeued_fds = NULL;\n    } else {\n      /* Shift rest */\n      memmove(queued_fds-\u003efds,\n              queued_fds-\u003efds + 1,\n              queued_fds-\u003eoffset * sizeof(*queued_fds-\u003efds));\n    }\n  } else {\n    server-\u003eaccepted_fd = -1;\n    if (err == 0)\n      uv__io_start(server-\u003eloop, \u0026server-\u003eio_watcher, POLLIN);\n  }\n  return err;\n}","filepath":"src/unix/stream.c","line_number":580,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5185888":{"score":0.66703033,"function_name":"uv_listen","code":"int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {\n  int err;\n\n  switch (stream-\u003etype) {\n  case UV_TCP:\n    err = uv_tcp_listen((uv_tcp_t*)stream, backlog, cb);\n    break;\n\n  case UV_NAMED_PIPE:\n    err = uv_pipe_listen((uv_pipe_t*)stream, backlog, cb);\n    break;\n\n  default:\n    err = UV_EINVAL;\n  }\n\n  if (err == 0)\n    uv__handle_start(stream);\n\n  return err;\n}","filepath":"src/unix/stream.c","line_number":645,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5185984":{"score":0.8297536,"function_name":"uv__handle_type","code":"uv_handle_type uv__handle_type(int fd) {\n  struct sockaddr_storage ss;\n  socklen_t sslen;\n  socklen_t len;\n  int type;\n\n  memset(\u0026ss, 0, sizeof(ss));\n  sslen = sizeof(ss);\n\n  if (getsockname(fd, (struct sockaddr*)\u0026ss, \u0026sslen))\n    return UV_UNKNOWN_HANDLE;\n\n  len = sizeof type;\n\n  if (getsockopt(fd, SOL_SOCKET, SO_TYPE, \u0026type, \u0026len))\n    return UV_UNKNOWN_HANDLE;\n\n  if (type == SOCK_STREAM) {\n#if defined(_AIX) || defined(__DragonFly__)\n    /* on AIX/DragonFly the getsockname call returns an empty sa structure\n     * for sockets of type AF_UNIX.  For all other types it will\n     * return a properly filled in structure.\n     */\n    if (sslen == 0)\n      return UV_NAMED_PIPE;\n#endif\n    switch (ss.ss_family) {\n      case AF_UNIX:\n        return UV_NAMED_PIPE;\n      case AF_INET:\n      case AF_INET6:\n        return UV_TCP;\n      }\n  }\n\n  if (type == SOCK_DGRAM \u0026\u0026\n      (ss.ss_family == AF_INET || ss.ss_family == AF_INET6))\n    return UV_UDP;\n\n  return UV_UNKNOWN_HANDLE;\n}","filepath":"src/unix/stream.c","line_number":974,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5186240":{"score":0.8927814,"function_name":"uv_shutdown","code":"int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {\n  assert((stream-\u003etype == UV_TCP || stream-\u003etype == UV_NAMED_PIPE) \u0026\u0026\n         \"uv_shutdown (unix) only supports uv_handle_t right now\");\n  assert(uv__stream_fd(stream) \u003e= 0);\n\n  if (!(stream-\u003eflags \u0026 UV_STREAM_WRITABLE) ||\n      stream-\u003eflags \u0026 UV_STREAM_SHUT ||\n      stream-\u003eflags \u0026 UV_CLOSED ||\n      stream-\u003eflags \u0026 UV_CLOSING) {\n    return -ENOTCONN;\n  }\n\n  /* Initialize request */\n  uv__req_init(stream-\u003eloop, req, UV_SHUTDOWN);\n  req-\u003ehandle = stream;\n  req-\u003ecb = cb;\n  stream-\u003eshutdown_req = req;\n  stream-\u003eflags |= UV_STREAM_SHUTTING;\n\n  uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, UV__POLLOUT);\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1092,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.12"},"5186432":{"score":0.87616867,"function_name":"uv_write2","code":"int uv_write2(uv_write_t* req,\n              uv_stream_t* stream,\n              const uv_buf_t bufs[],\n              unsigned int nbufs,\n              uv_stream_t* send_handle,\n              uv_write_cb cb) {\n  int empty_queue;\n\n  assert(nbufs \u003e 0);\n  assert((stream-\u003etype == UV_TCP ||\n          stream-\u003etype == UV_NAMED_PIPE ||\n          stream-\u003etype == UV_TTY) \u0026\u0026\n         \"uv_write (unix) does not yet support other types of streams\");\n\n  if (uv__stream_fd(stream) \u003c 0)\n    return UV_EBADF;\n\n  if (!(stream-\u003eflags \u0026 UV_STREAM_WRITABLE))\n    return -EPIPE;\n\n  if (send_handle) {\n    if (stream-\u003etype != UV_NAMED_PIPE || !((uv_pipe_t*)stream)-\u003eipc)\n      return UV_EINVAL;\n\n    /* XXX We abuse uv_write2() to send over UDP handles to child processes.\n     * Don't call uv__stream_fd() on those handles, it's a macro that on OS X\n     * evaluates to a function that operates on a uv_stream_t with a couple of\n     * OS X specific fields. On other Unices it does (handle)-\u003eio_watcher.fd,\n     * which works but only by accident.\n     */\n    if (uv__handle_fd((uv_handle_t*) send_handle) \u003c 0)\n      return UV_EBADF;\n\n#if defined(__CYGWIN__) || defined(__MSYS__)\n    /* Cygwin recvmsg always sets msg_controllen to zero, so we cannot send it.\n       See https://github.com/mirror/newlib-cygwin/blob/86fc4bf0/winsup/cygwin/fhandler_socket.cc#L1736-L1743 */\n    return UV_ENOSYS;\n#endif\n  }\n\n  /* It's legal for write_queue_size \u003e 0 even when the write_queue is empty;\n   * it means there are error-state requests in the write_completed_queue that\n   * will touch up write_queue_size later, see also uv__write_req_finish().\n   * We could check that write_queue is empty instead but that implies making\n   * a write() syscall when we know that the handle is in error mode.\n   */\n  empty_queue = (stream-\u003ewrite_queue_size == 0);\n\n  /* Initialize the req */\n  uv__req_init(stream-\u003eloop, req, UV_WRITE);\n  req-\u003ecb = cb;\n  req-\u003ehandle = stream;\n  req-\u003eerror = 0;\n  req-\u003esend_handle = send_handle;\n  QUEUE_INIT(\u0026req-\u003equeue);\n\n  req-\u003ebufs = req-\u003ebufsml;\n  if (nbufs \u003e ARRAY_SIZE(req-\u003ebufsml))\n    req-\u003ebufs = uv__malloc(nbufs * sizeof(bufs[0]));\n\n  if (req-\u003ebufs == NULL)\n    return UV_ENOMEM;\n\n  memcpy(req-\u003ebufs, bufs, nbufs * sizeof(bufs[0]));\n  req-\u003enbufs = nbufs;\n  req-\u003ewrite_index = 0;\n  stream-\u003ewrite_queue_size += uv__count_bufs(bufs, nbufs);\n\n  /* Append the request to write_queue. */\n  QUEUE_INSERT_TAIL(\u0026stream-\u003ewrite_queue, \u0026req-\u003equeue);\n\n  /* If the queue was empty when this function began, we should attempt to\n   * do the write immediately. Otherwise start the write_watcher and wait\n   * for the fd to become writable.\n   */\n  if (stream-\u003econnect_req) {\n    /* Still connecting, do nothing. */\n  }\n  else if (empty_queue) {\n    uv__write(stream);\n  }\n  else {\n    /*\n     * blocking streams should never have anything in the queue.\n     * if this assert fires then somehow the blocking stream isn't being\n     * sufficiently flushed in uv__write.\n     */\n    assert(!(stream-\u003eflags \u0026 UV_STREAM_BLOCKING));\n    uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLOUT);\n    uv__stream_osx_interrupt_select(stream);\n  }\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1404,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5187072":{"score":0.7673741,"function_name":"uv_try_write","code":"int uv_try_write(uv_stream_t* stream,\n                 const uv_buf_t bufs[],\n                 unsigned int nbufs) {\n  int r;\n  int has_pollout;\n  size_t written;\n  size_t req_size;\n  uv_write_t req;\n\n  /* Connecting or already writing some data */\n  if (stream-\u003econnect_req != NULL || stream-\u003ewrite_queue_size != 0)\n    return UV_EAGAIN;\n\n  has_pollout = uv__io_active(\u0026stream-\u003eio_watcher, POLLOUT);\n\n  r = uv_write(\u0026req, stream, bufs, nbufs, uv_try_write_cb);\n  if (r != 0)\n    return r;\n\n  /* Remove not written bytes from write queue size */\n  written = uv__count_bufs(bufs, nbufs);\n  if (req.bufs != NULL)\n    req_size = uv__write_req_size(\u0026req);\n  else\n    req_size = 0;\n  written -= req_size;\n  stream-\u003ewrite_queue_size -= req_size;\n\n  /* Unqueue request, regardless of immediateness */\n  QUEUE_REMOVE(\u0026req.queue);\n  uv__req_unregister(stream-\u003eloop, \u0026req);\n  if (req.bufs != req.bufsml)\n    uv__free(req.bufs);\n  req.bufs = NULL;\n\n  /* Do not poll for writable, if we wasn't before calling this */\n  if (!has_pollout) {\n    uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLOUT);\n    uv__stream_osx_interrupt_select(stream);\n  }\n\n  if (written == 0 \u0026\u0026 req_size != 0)\n    return UV_EAGAIN;\n  else\n    return written;\n}","filepath":"src/unix/stream.c","line_number":1518,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5187472":{"score":0.83580464,"function_name":"uv_read_start","code":"int uv_read_start(uv_stream_t* stream,\n                  uv_alloc_cb alloc_cb,\n                  uv_read_cb read_cb) {\n  assert(stream-\u003etype == UV_TCP || stream-\u003etype == UV_NAMED_PIPE ||\n      stream-\u003etype == UV_TTY);\n\n  if (stream-\u003eflags \u0026 UV_CLOSING)\n    return UV_EINVAL;\n\n  if (!(stream-\u003eflags \u0026 UV_STREAM_READABLE))\n    return -ENOTCONN;\n\n  /* The UV_STREAM_READING flag is irrelevant of the state of the tcp - it just\n   * expresses the desired state of the user.\n   */\n  stream-\u003eflags |= UV_STREAM_READING;\n\n  /* TODO: try to do the read inline? */\n  /* TODO: keep track of tcp state. If we've gotten a EOF then we should\n   * not start the IO watcher.\n   */\n  assert(uv__stream_fd(stream) \u003e= 0);\n  assert(alloc_cb);\n\n  stream-\u003eread_cb = read_cb;\n  stream-\u003ealloc_cb = alloc_cb;\n\n  uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n  uv__handle_start(stream);\n  uv__stream_osx_interrupt_select(stream);\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1566,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5187680":{"score":0.88252956,"function_name":"uv_read_stop","code":"int uv_read_stop(uv_stream_t* stream) {\n  if (!(stream-\u003eflags \u0026 UV_STREAM_READING))\n    return 0;\n\n  stream-\u003eflags \u0026= ~UV_STREAM_READING;\n  uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n  if (!uv__io_active(\u0026stream-\u003eio_watcher, POLLOUT))\n    uv__handle_stop(stream);\n  uv__stream_osx_interrupt_select(stream);\n\n  stream-\u003eread_cb = NULL;\n  stream-\u003ealloc_cb = NULL;\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1601,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5187840":{"score":0.76711977,"function_name":"uv__stream_close","code":"void uv__stream_close(uv_stream_t* handle) {\n  unsigned int i;\n  uv__stream_queued_fds_t* queued_fds;\n\n#if defined(__APPLE__)\n  /* Terminate select loop first */\n  if (handle-\u003eselect != NULL) {\n    uv__stream_select_t* s;\n\n    s = handle-\u003eselect;\n\n    uv_sem_post(\u0026s-\u003eclose_sem);\n    uv_sem_post(\u0026s-\u003easync_sem);\n    uv__stream_osx_interrupt_select(handle);\n    uv_thread_join(\u0026s-\u003ethread);\n    uv_sem_destroy(\u0026s-\u003eclose_sem);\n    uv_sem_destroy(\u0026s-\u003easync_sem);\n    uv__close(s-\u003efake_fd);\n    uv__close(s-\u003eint_fd);\n    uv_close((uv_handle_t*) \u0026s-\u003easync, uv__stream_osx_cb_close);\n\n    handle-\u003eselect = NULL;\n  }\n#endif /* defined(__APPLE__) */\n\n  uv__io_close(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n  uv_read_stop(handle);\n  uv__handle_stop(handle);\n\n  if (handle-\u003eio_watcher.fd != -1) {\n    /* Don't close stdio file descriptors.  Nothing good comes from it. */\n    if (handle-\u003eio_watcher.fd \u003e STDERR_FILENO)\n      uv__close(handle-\u003eio_watcher.fd);\n    handle-\u003eio_watcher.fd = -1;\n  }\n\n  if (handle-\u003eaccepted_fd != -1) {\n    uv__close(handle-\u003eaccepted_fd);\n    handle-\u003eaccepted_fd = -1;\n  }\n\n  /* Close all queued fds */\n  if (handle-\u003equeued_fds != NULL) {\n    queued_fds = handle-\u003equeued_fds;\n    for (i = 0; i \u003c queued_fds-\u003eoffset; i++)\n      uv__close(queued_fds-\u003efds[i]);\n    uv__free(handle-\u003equeued_fds);\n    handle-\u003equeued_fds = NULL;\n  }\n\n  assert(!uv__io_active(\u0026handle-\u003eio_watcher, POLLIN | POLLOUT));\n}","filepath":"src/unix/stream.c","line_number":1644,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.21.0"},"5188176":{"score":0.66831404,"function_name":"maybe_new_socket","code":"static int maybe_new_socket(uv_tcp_t* handle, int domain, int flags) {\n  int sockfd;\n  int err;\n\n  if (uv__stream_fd(handle) != -1)\n    return 0;\n\n  err = uv__socket(domain, SOCK_STREAM, 0);\n  if (err \u003c 0)\n    return err;\n  sockfd = err;\n\n  err = uv__stream_open((uv_stream_t*) handle, sockfd, flags);\n  if (err) {\n    uv__close(sockfd);\n    return err;\n  }\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":37,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5188256":{"score":0.8209375,"function_name":"uv_tcp_init_ex","code":"int uv_tcp_init_ex(uv_loop_t* loop, uv_tcp_t* tcp, unsigned int flags) {\n  int domain;\n\n  /* Use the lower 8 bits for the domain */\n  domain = flags \u0026 0xFF;\n  if (domain != AF_INET \u0026\u0026 domain != AF_INET6 \u0026\u0026 domain != AF_UNSPEC)\n    return UV_EINVAL;\n\n  if (flags \u0026 ~0xFF)\n    return UV_EINVAL;\n\n  uv__stream_init(loop, (uv_stream_t*)tcp, UV_TCP);\n\n  /* If anything fails beyond this point we need to remove the handle from\n   * the handle queue, since it was added by uv__handle_init in uv_stream_init.\n   */\n\n  if (domain != AF_UNSPEC) {\n    int err = maybe_new_socket(tcp, domain, 0);\n    if (err) {\n      QUEUE_REMOVE(\u0026tcp-\u003ehandle_queue);\n      return err;\n    }\n  }\n\n  return 0;\n}","filepath":"ext/deps/libcat/deps/libuv/src/unix/tcp.c","line_number":114,"entry_url":"https://github.com/swow/swow.git","slot_name":"v0.1.0-nightly20210308"},"5188400":{"score":0.77363217,"function_name":"uv__tcp_bind","code":"int uv__tcp_bind(uv_tcp_t* tcp,\n                 const struct sockaddr* addr,\n                 unsigned int addrlen,\n                 unsigned int flags) {\n  int err;\n  int on;\n\n  /* Cannot set IPv6-only mode on non-IPv6 socket. */\n  if ((flags \u0026 UV_TCP_IPV6ONLY) \u0026\u0026 addr-\u003esa_family != AF_INET6)\n    return -EINVAL;\n\n  err = maybe_new_socket(tcp,\n                         addr-\u003esa_family,\n                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n  if (err)\n    return err;\n\n  on = 1;\n  if (setsockopt(tcp-\u003eio_watcher.fd, SOL_SOCKET, SO_REUSEADDR, \u0026on, sizeof(on)))\n    return -errno;\n\n#ifdef IPV6_V6ONLY\n  if (addr-\u003esa_family == AF_INET6) {\n    on = (flags \u0026 UV_TCP_IPV6ONLY) != 0;\n    if (setsockopt(tcp-\u003eio_watcher.fd,\n                   IPPROTO_IPV6,\n                   IPV6_V6ONLY,\n                   \u0026on,\n                   sizeof on) == -1) {\n      return -errno;\n    }\n  }\n#endif\n\n  errno = 0;\n  if (bind(tcp-\u003eio_watcher.fd, addr, addrlen) \u0026\u0026 errno != EADDRINUSE)\n    return -errno;\n  tcp-\u003edelayed_error = -errno;\n\n  if (addr-\u003esa_family == AF_INET6)\n    tcp-\u003eflags |= UV_HANDLE_IPV6;\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":59,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5188800":{"score":0.8800185,"function_name":"uv__tcp_connect","code":"int uv__tcp_connect(uv_connect_t* req,\n                    uv_tcp_t* handle,\n                    const struct sockaddr* addr,\n                    unsigned int addrlen,\n                    uv_connect_cb cb) {\n  int err;\n  int r;\n\n  assert(handle-\u003etype == UV_TCP);\n\n  if (handle-\u003econnect_req != NULL)\n    return -EALREADY;  /* FIXME(bnoordhuis) -EINVAL or maybe -EBUSY. */\n\n  err = maybe_new_socket(handle,\n                         addr-\u003esa_family,\n                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n  if (err)\n    return err;\n\n  handle-\u003edelayed_error = 0;\n\n  do\n    r = connect(uv__stream_fd(handle), addr, addrlen);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r == -1) {\n    if (errno == EINPROGRESS)\n      ; /* not an error */\n    else if (errno == ECONNREFUSED)\n    /* If we get a ECONNREFUSED wait until the next tick to report the\n     * error. Solaris wants to report immediately--other unixes want to\n     * wait.\n     */\n      handle-\u003edelayed_error = -errno;\n    else\n      return -errno;\n  }\n\n  uv__req_init(handle-\u003eloop, req, UV_CONNECT);\n  req-\u003ecb = cb;\n  req-\u003ehandle = (uv_stream_t*) handle;\n  QUEUE_INIT(\u0026req-\u003equeue);\n  handle-\u003econnect_req = req;\n\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, UV__POLLOUT);\n\n  if (handle-\u003edelayed_error)\n    uv__io_feed(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":105,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5189168":{"score":0.7555796,"function_name":"uv_tcp_open","code":"int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {\n  int err;\n\n  err = uv__nonblock(sock, 1);\n  if (err)\n    return err;\n\n  return uv__stream_open((uv_stream_t*)handle,\n                         sock,\n                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n}","filepath":"src/unix/tcp.c","line_number":158,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5189360":{"score":0.83300275,"function_name":"uv_tcp_getpeername","code":"int uv_tcp_getpeername(const uv_tcp_t* handle,\n                       struct sockaddr* name,\n                       int* namelen) {\n  socklen_t socklen;\n\n  if (handle-\u003edelayed_error)\n    return handle-\u003edelayed_error;\n\n  if (uv__stream_fd(handle) \u003c 0)\n    return -EINVAL;  /* FIXME(bnoordhuis) -EBADF */\n\n  /* sizeof(socklen_t) != sizeof(int) on some systems. */\n  socklen = (socklen_t) *namelen;\n\n  if (getpeername(uv__stream_fd(handle), name, \u0026socklen))\n    return -errno;\n\n  *namelen = (int) socklen;\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":193,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5189488":{"score":0.7861022,"function_name":"uv_tcp_listen","code":"int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n  if (tcp-\u003edelayed_error)\n    return uv__set_sys_error(tcp-\u003eloop, tcp-\u003edelayed_error);\n\n  if (maybe_new_socket(tcp, AF_INET, UV_STREAM_READABLE))\n    return -1;\n\n  if (listen(tcp-\u003efd, backlog))\n    return uv__set_sys_error(tcp-\u003eloop, errno);\n\n  tcp-\u003econnection_cb = cb;\n\n  /* Start listening for connections. */\n  uv__io_set(\u0026tcp-\u003eread_watcher, uv__server_io, tcp-\u003efd, UV__IO_READ);\n  uv__io_start(tcp-\u003eloop, \u0026tcp-\u003eread_watcher);\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":229,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"node-v0.8.11"},"5189824":{"score":0.73860925,"function_name":"uv__tcp_keepalive","code":"int uv__tcp_keepalive(int fd, int on, unsigned int delay) {\n  if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, \u0026on, sizeof(on)))\n    return -errno;\n\n#ifdef TCP_KEEPIDLE\n  if (on \u0026\u0026 setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, \u0026delay, sizeof(delay)))\n    return -errno;\n#endif\n\n  /* Solaris/SmartOS, if you don't support keep-alive,\n   * then don't advertise it in your system headers...\n   */\n  /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */\n#if defined(TCP_KEEPALIVE) \u0026\u0026 !defined(__sun)\n  if (on \u0026\u0026 setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, \u0026delay, sizeof(delay)))\n    return -errno;\n#endif\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":254,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5189952":{"score":0.7941627,"function_name":"uv_tcp_nodelay","code":"int uv_tcp_nodelay(uv_tcp_t* handle, int on) {\n  int err;\n\n  if (uv__stream_fd(handle) != -1) {\n    err = uv__tcp_nodelay(uv__stream_fd(handle), on);\n    if (err)\n      return err;\n  }\n\n  if (on)\n    handle-\u003eflags |= UV_TCP_NODELAY;\n  else\n    handle-\u003eflags \u0026= ~UV_TCP_NODELAY;\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":276,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5190144":{"score":0.67061645,"function_name":"uv__stream_close","code":"void uv__stream_close(uv_stream_t* handle) {\n  uv_read_stop(handle);\n  uv__io_stop(handle-\u003eloop, \u0026handle-\u003ewrite_watcher);\n\n  close(handle-\u003efd);\n  handle-\u003efd = -1;\n\n  if (handle-\u003eaccepted_fd \u003e= 0) {\n    close(handle-\u003eaccepted_fd);\n    handle-\u003eaccepted_fd = -1;\n  }\n\n  assert(!uv__io_active(\u0026handle-\u003eread_watcher));\n  assert(!uv__io_active(\u0026handle-\u003ewrite_watcher));\n}","filepath":"src/unix/stream.c","line_number":936,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"node-v0.8.11"},"5190160":{"score":0.8124909,"function_name":"uv__thread_start","code":"static void* uv__thread_start(void *arg)\n{\n  struct thread_ctx *ctx_p;\n  struct thread_ctx ctx;\n\n  ctx_p = arg;\n  ctx = *ctx_p;\n  uv__free(ctx_p);\n  ctx.entry(ctx.arg);\n\n  return 0;\n}","filepath":"src/unix/thread.c","line_number":41,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.5"},"5190192":{"score":0.8705281,"function_name":"uv_thread_create","code":"int uv_thread_create(uv_thread_t *tid, void (*entry)(void *arg), void *arg) {\n  struct thread_ctx* ctx;\n  int err;\n\n  ctx = uv__malloc(sizeof(*ctx));\n  if (ctx == NULL)\n    return UV_ENOMEM;\n\n  ctx-\u003eentry = entry;\n  ctx-\u003earg = arg;\n\n  err = pthread_create(tid, NULL, uv__thread_start, ctx);\n\n  if (err)\n    uv__free(ctx);\n\n  return -err;\n}","filepath":"src/unix/thread.c","line_number":55,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.5"},"5190656":{"score":0.6857872,"function_name":"uv_mutex_trylock","code":"int uv_mutex_trylock(uv_mutex_t* mutex) {\n  int err;\n\n  err = pthread_mutex_trylock(mutex);\n  if (err) {\n    if (err != EBUSY \u0026\u0026 err != EAGAIN)\n      abort();\n    return -EBUSY;\n  }\n\n  return 0;\n}","filepath":"src/unix/thread.c","line_number":124,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.5"},"5190992":{"score":0.78502125,"function_name":"uv_sem_wait","code":"void uv_sem_wait(uv_sem_t* sem) {\n  int r;\n\n  do\n    r = sem_wait(sem);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r)\n    abort();\n}","filepath":"src/unix/thread.c","line_number":292,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.5"},"5191056":{"score":0.8060929,"function_name":"uv_sem_trywait","code":"int uv_sem_trywait(uv_sem_t* sem) {\n  int r;\n\n  do\n    r = sem_trywait(sem);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r) {\n    if (errno == EAGAIN)\n      return -EAGAIN;\n    abort();\n  }\n\n  return 0;\n}","filepath":"src/unix/thread.c","line_number":304,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.5"},"5191152":{"score":0.6829095,"function_name":"uv_cond_init","code":"int uv_cond_init(uv_cond_t* cond) {\n  pthread_condattr_t attr;\n  int err;\n\n  err = pthread_condattr_init(\u0026attr);\n  if (err)\n    return -err;\n\n#if !(defined(__ANDROID__) \u0026\u0026 defined(HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC))\n  err = pthread_condattr_setclock(\u0026attr, CLOCK_MONOTONIC);\n  if (err)\n    goto error2;\n#endif\n\n  err = pthread_cond_init(cond, \u0026attr);\n  if (err)\n    goto error2;\n\n  err = pthread_condattr_destroy(\u0026attr);\n  if (err)\n    goto error;\n\n  return 0;\n\nerror:\n  pthread_cond_destroy(cond);\nerror2:\n  pthread_condattr_destroy(\u0026attr);\n  return -err;\n}","filepath":"src/unix/thread.c","line_number":331,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.5"},"5191440":{"score":0.8241451,"function_name":"uv_cond_timedwait","code":"int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {\n  int r;\n  struct timespec ts;\n#if defined(__MVS__)\n  struct timeval tv;\n#endif\n\n#if defined(__APPLE__) \u0026\u0026 defined(__MACH__)\n  ts.tv_sec = timeout / NANOSEC;\n  ts.tv_nsec = timeout % NANOSEC;\n  r = pthread_cond_timedwait_relative_np(cond, mutex, \u0026ts);\n#else\n#if defined(__MVS__)\n  if (gettimeofday(\u0026tv, NULL))\n    abort();\n  timeout += tv.tv_sec * NANOSEC + tv.tv_usec * 1e3;\n#else\n  timeout += uv__hrtime(UV_CLOCK_PRECISE);\n#endif\n  ts.tv_sec = timeout / NANOSEC;\n  ts.tv_nsec = timeout % NANOSEC;\n#if defined(__ANDROID_API__) \u0026\u0026 __ANDROID_API__ \u003c 21\n\n  /*\n   * The bionic pthread implementation doesn't support CLOCK_MONOTONIC,\n   * but has this alternative function instead.\n   */\n  r = pthread_cond_timedwait_monotonic_np(cond, mutex, \u0026ts);\n#else\n  r = pthread_cond_timedwait(cond, mutex, \u0026ts);\n#endif /* __ANDROID_API__ */\n#endif\n\n\n  if (r == 0)\n    return 0;\n\n  if (r == ETIMEDOUT)\n    return UV_ETIMEDOUT;\n\n  abort();\n#ifndef __SUNPRO_C\n  return UV_EINVAL;  /* Satisfy the compiler. */\n#endif\n}","filepath":"src/unix/thread.c","line_number":778,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.30.0"},"5192016":{"score":0.70214367,"function_name":"uv_timer_init","code":"int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle) {\n  loop-\u003ecounters.handle_init++;\n  loop-\u003ecounters.timer_init++;\n\n  handle-\u003etype = UV_TIMER;\n  handle-\u003eloop = loop;\n  handle-\u003eflags = 0;\n  handle-\u003etimer_cb = NULL;\n  handle-\u003erepeat = 0;\n\n  uv_ref(loop);\n\n  return 0;\n}","filepath":"src/win/timer.c","line_number":114,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"node-v0.6.4"},"5192096":{"score":0.6627526,"function_name":"uv_timer_stop","code":"int uv_timer_stop(uv_timer_t* handle) {\n  if (!uv__is_active(handle))\n    return 0;\n\n  heap_remove((struct heap*) \u0026handle-\u003eloop-\u003etimer_heap,\n              (struct heap_node*) \u0026handle-\u003eheap_node,\n              timer_less_than);\n  uv__handle_stop(handle);\n\n  return 0;\n}","filepath":"src/unix/timer.c","line_number":93,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.10.0"},"5192608":{"score":0.81740236,"function_name":"uv_timer_start","code":"int uv_timer_start(uv_timer_t* handle,\n                   uv_timer_cb cb,\n                   uint64_t timeout,\n                   uint64_t repeat) {\n  uint64_t clamped_timeout;\n\n  if (cb == NULL)\n    return -EINVAL;\n\n  if (uv__is_active(handle))\n    uv_timer_stop(handle);\n\n  clamped_timeout = handle-\u003eloop-\u003etime + timeout;\n  if (clamped_timeout \u003c timeout)\n    clamped_timeout = (uint64_t) -1;\n\n  handle-\u003etimer_cb = cb;\n  handle-\u003etimeout = clamped_timeout;\n  handle-\u003erepeat = repeat;\n  /* start_id is the second index to be compared in uv__timer_cmp() */\n  handle-\u003estart_id = handle-\u003eloop-\u003etimer_counter++;\n\n  heap_insert((struct heap*) \u0026handle-\u003eloop-\u003etimer_heap,\n              (struct heap_node*) \u0026handle-\u003eheap_node,\n              timer_less_than);\n  uv__handle_start(handle);\n\n  return 0;\n}","filepath":"src/unix/timer.c","line_number":62,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.10.0"},"5192992":{"score":0.9052598,"function_name":"uv_timer_again","code":"int uv_timer_again(uv_timer_t* handle) {\n  if (handle-\u003etimer_cb == NULL)\n    return -EINVAL;\n\n  if (handle-\u003erepeat) {\n    uv_timer_stop(handle);\n    uv_timer_start(handle, handle-\u003etimer_cb, handle-\u003erepeat, handle-\u003erepeat);\n  }\n\n  return 0;\n}","filepath":"src/unix/timer.c","line_number":106,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.10.0"},"5193088":{"score":0.83378196,"function_name":"uv__next_timeout","code":"int uv__next_timeout(const uv_loop_t* loop) {\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  heap_node = heap_min((const struct heap*) \u0026loop-\u003etimer_heap);\n  if (heap_node == NULL)\n    return -1; /* block indefinitely */\n\n  handle = container_of(heap_node, uv_timer_t, heap_node);\n  if (handle-\u003etimeout \u003c= loop-\u003etime)\n    return 0;\n\n  diff = handle-\u003etimeout - loop-\u003etime;\n  if (diff \u003e INT_MAX)\n    diff = INT_MAX;\n\n  return diff;\n}","filepath":"src/unix/timer.c","line_number":129,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.10.0"},"5193152":{"score":0.61826366,"function_name":"uv__run_timers","code":"void uv__run_timers(uv_loop_t* loop) {\n  struct heap_node* heap_node;\n  uv_timer_t* handle;\n\n  for (;;) {\n    heap_node = heap_min((struct heap*) \u0026loop-\u003etimer_heap);\n    if (heap_node == NULL)\n      break;\n\n    handle = container_of(heap_node, uv_timer_t, heap_node);\n    if (handle-\u003etimeout \u003e loop-\u003etime)\n      break;\n\n    uv_timer_stop(handle);\n    uv_timer_again(handle);\n    handle-\u003etimer_cb(handle);\n  }\n}","filepath":"src/unix/timer.c","line_number":150,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.10.0"},"5193328":{"score":0.6729103,"function_name":"uv_tty_set_mode","code":"int uv_tty_set_mode(uv_tty_t* tty, uv_tty_mode_t mode) {\n  struct termios tmp;\n  int fd;\n\n  if (tty-\u003emode == (int) mode)\n    return 0;\n\n  fd = uv__stream_fd(tty);\n  if (tty-\u003emode == UV_TTY_MODE_NORMAL \u0026\u0026 mode != UV_TTY_MODE_NORMAL) {\n    if (tcgetattr(fd, \u0026tty-\u003eorig_termios))\n      return -errno;\n\n    /* This is used for uv_tty_reset_mode() */\n    uv_spinlock_lock(\u0026termios_spinlock);\n    if (orig_termios_fd == -1) {\n      orig_termios = tty-\u003eorig_termios;\n      orig_termios_fd = fd;\n    }\n    uv_spinlock_unlock(\u0026termios_spinlock);\n  }\n\n  tmp = tty-\u003eorig_termios;\n  switch (mode) {\n    case UV_TTY_MODE_NORMAL:\n      break;\n    case UV_TTY_MODE_RAW:\n      tmp.c_iflag \u0026= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n      tmp.c_oflag |= (ONLCR);\n      tmp.c_cflag |= (CS8);\n      tmp.c_lflag \u0026= ~(ECHO | ICANON | IEXTEN | ISIG);\n      tmp.c_cc[VMIN] = 1;\n      tmp.c_cc[VTIME] = 0;\n      break;\n    case UV_TTY_MODE_IO:\n      cfmakeraw(\u0026tmp);\n      break;\n  }\n\n  /* Apply changes after draining */\n  if (tcsetattr(fd, TCSADRAIN, \u0026tmp))\n    return -errno;\n\n  tty-\u003emode = mode;\n  return 0;\n}","filepath":"src/unix/tty.c","line_number":107,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.2.1"},"5194032":{"score":0.82152843,"function_name":"uv_guess_handle","code":"uv_handle_type uv_guess_handle(uv_file file) {\n  struct sockaddr sa;\n  struct stat s;\n  socklen_t len;\n  int type;\n\n  if (file \u003c 0)\n    return UV_UNKNOWN_HANDLE;\n\n#if defined(__PASE__)\n  /* On IBMi PASE isatty() always returns true for stdin, stdout and stderr.\n   * Use ioctl() instead to identify whether it's actually a TTY.\n   */\n  if (!ioctl(file, TXISATTY + 0x81, NULL) || errno != ENOTTY)\n#else\n  if (isatty(file))\n#endif\n    return UV_TTY;\n\n  if (fstat(file, \u0026s))\n    return UV_UNKNOWN_HANDLE;\n\n  if (S_ISREG(s.st_mode))\n    return UV_FILE;\n\n  if (S_ISCHR(s.st_mode))\n    return UV_FILE;  /* XXX UV_NAMED_PIPE? */\n\n  if (S_ISFIFO(s.st_mode))\n    return UV_NAMED_PIPE;\n\n  if (!S_ISSOCK(s.st_mode))\n    return UV_UNKNOWN_HANDLE;\n\n  len = sizeof(type);\n  if (getsockopt(file, SOL_SOCKET, SO_TYPE, \u0026type, \u0026len))\n    return UV_UNKNOWN_HANDLE;\n\n  len = sizeof(sa);\n  if (getsockname(file, \u0026sa, \u0026len))\n    return UV_UNKNOWN_HANDLE;\n\n  if (type == SOCK_DGRAM)\n    if (sa.sa_family == AF_INET || sa.sa_family == AF_INET6)\n      return UV_UDP;\n\n  if (type == SOCK_STREAM) {\n#if defined(_AIX) || defined(__DragonFly__)\n    /* on AIX/DragonFly the getsockname call returns an empty sa structure\n     * for sockets of type AF_UNIX.  For all other types it will\n     * return a properly filled in structure.\n     */\n    if (len == 0)\n      return UV_NAMED_PIPE;\n#endif /* defined(_AIX) || defined(__DragonFly__) */\n\n    if (sa.sa_family == AF_INET || sa.sa_family == AF_INET6)\n      return UV_TCP;\n    if (sa.sa_family == AF_UNIX)\n      return UV_NAMED_PIPE;\n  }\n\n  return UV_UNKNOWN_HANDLE;\n}","filepath":"src/unix/tty.c","line_number":287,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.34.1"},"5194384":{"score":0.876047,"function_name":"uv_tty_init","code":"int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n  uv_handle_type type;\n  int flags;\n  int newfd;\n  int r;\n\n  /* File descriptors that refer to files cannot be monitored with epoll.\n   * That restriction also applies to character devices like /dev/random\n   * (but obviously not /dev/tty.)\n   */\n  type = uv_guess_handle(fd);\n  if (type == UV_FILE || type == UV_UNKNOWN_HANDLE)\n    return -EINVAL;\n\n  flags = 0;\n  newfd = -1;\n\n  /* Reopen the file descriptor when it refers to a tty. This lets us put the\n   * tty in non-blocking mode without affecting other processes that share it\n   * with us.\n   *\n   * Example: `node | cat` - if we put our fd 0 in non-blocking mode, it also\n   * affects fd 1 of `cat` because both file descriptors refer to the same\n   * struct file in the kernel. When we reopen our fd 0, it points to a\n   * different struct file, hence changing its properties doesn't affect\n   * other processes.\n   */\n  if (type == UV_TTY) {\n    r = uv__open_cloexec(\"/dev/tty\", O_RDWR);\n\n    if (r \u003c 0) {\n      /* fallback to using blocking writes */\n      if (!readable)\n        flags |= UV_STREAM_BLOCKING;\n      goto skip;\n    }\n\n    newfd = r;\n\n    r = uv__dup2_cloexec(newfd, fd);\n    if (r \u003c 0 \u0026\u0026 r != -EINVAL) {\n      /* EINVAL means newfd == fd which could conceivably happen if another\n       * thread called close(fd) between our calls to isatty() and open().\n       * That's a rather unlikely event but let's handle it anyway.\n       */\n      uv__close(newfd);\n      return r;\n    }\n\n    fd = newfd;\n  }\n\nskip:\n  uv__stream_init(loop, (uv_stream_t*) tty, UV_TTY);\n\n  /* If anything fails beyond this point we need to remove the handle from\n   * the handle queue, since it was added by uv__handle_init in uv_stream_init.\n   */\n\n#if defined(__APPLE__)\n  r = uv__stream_try_select((uv_stream_t*) tty, \u0026fd);\n  if (r) {\n    if (newfd != -1)\n      uv__close(newfd);\n    QUEUE_REMOVE(\u0026tty-\u003ehandle_queue);\n    return r;\n  }\n#endif\n\n  if (readable)\n    flags |= UV_STREAM_READABLE;\n  else\n    flags |= UV_STREAM_WRITABLE;\n\n  if (!(flags \u0026 UV_STREAM_BLOCKING))\n    uv__nonblock(fd, 1);\n\n  uv__stream_open((uv_stream_t*) tty, fd, flags);\n  tty-\u003emode = UV_TTY_MODE_NORMAL;\n\n  return 0;\n}","filepath":"src/unix/tty.c","line_number":37,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5194784":{"score":0.8335085,"function_name":"uv__udp_run_completed","code":"static void uv__udp_run_completed(uv_udp_t* handle) {\n  uv_udp_send_t* req;\n  QUEUE* q;\n\n  assert(!(handle-\u003eflags \u0026 UV_HANDLE_UDP_PROCESSING));\n  handle-\u003eflags |= UV_HANDLE_UDP_PROCESSING;\n\n  while (!QUEUE_EMPTY(\u0026handle-\u003ewrite_completed_queue)) {\n    q = QUEUE_HEAD(\u0026handle-\u003ewrite_completed_queue);\n    QUEUE_REMOVE(q);\n\n    req = QUEUE_DATA(q, uv_udp_send_t, queue);\n    uv__req_unregister(handle-\u003eloop, req);\n\n    handle-\u003esend_queue_size -= uv__count_bufs(req-\u003ebufs, req-\u003enbufs);\n    handle-\u003esend_queue_count--;\n\n    if (req-\u003ebufs != req-\u003ebufsml)\n      uv__free(req-\u003ebufs);\n    req-\u003ebufs = NULL;\n\n    if (req-\u003esend_cb == NULL)\n      continue;\n\n    /* req-\u003estatus \u003e= 0 == bytes written\n     * req-\u003estatus \u003c  0 == errno\n     */\n    if (req-\u003estatus \u003e= 0)\n      req-\u003esend_cb(req, 0);\n    else\n      req-\u003esend_cb(req, req-\u003estatus);\n  }\n\n  if (QUEUE_EMPTY(\u0026handle-\u003ewrite_queue)) {\n    /* Pending queue and completion queue empty, stop watcher. */\n    uv__io_stop(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLOUT);\n    if (!uv__io_active(\u0026handle-\u003eio_watcher, POLLIN))\n      uv__handle_stop(handle);\n  }\n\n  handle-\u003eflags \u0026= ~UV_HANDLE_UDP_PROCESSING;\n}","filepath":"src/unix/udp.c","line_number":91,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5195216":{"score":0.70142496,"function_name":"uv__set_reuse","code":"static int uv__set_reuse(int fd) {\n  int yes;\n\n#if defined(SO_REUSEPORT) \u0026\u0026 !defined(__linux__)\n  yes = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, \u0026yes, sizeof(yes)))\n    return UV__ERR(errno);\n#else\n  yes = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, \u0026yes, sizeof(yes)))\n    return UV__ERR(errno);\n#endif\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":272,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5195312":{"score":0.8718889,"function_name":"uv__udp_sendmsg","code":"static void uv__udp_sendmsg(uv_udp_t* handle) {\n  uv_udp_send_t* req;\n  QUEUE* q;\n  struct msghdr h;\n  ssize_t size;\n\n  while (!QUEUE_EMPTY(\u0026handle-\u003ewrite_queue)) {\n    q = QUEUE_HEAD(\u0026handle-\u003ewrite_queue);\n    assert(q != NULL);\n\n    req = QUEUE_DATA(q, uv_udp_send_t, queue);\n    assert(req != NULL);\n\n    memset(\u0026h, 0, sizeof h);\n    if (req-\u003eaddr.ss_family == AF_UNSPEC) {\n      h.msg_name = NULL;\n      h.msg_namelen = 0;\n    } else {\n      h.msg_name = \u0026req-\u003eaddr;\n      h.msg_namelen = req-\u003eaddr.ss_family == AF_INET6 ?\n        sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n    }\n    h.msg_iov = (struct iovec*) req-\u003ebufs;\n    h.msg_iovlen = req-\u003enbufs;\n\n    do {\n      size = sendmsg(handle-\u003eio_watcher.fd, \u0026h, 0);\n    } while (size == -1 \u0026\u0026 errno == EINTR);\n\n    if (size == -1) {\n      if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)\n        break;\n    }\n\n    req-\u003estatus = (size == -1 ? UV__ERR(errno) : size);\n\n    /* Sending a datagram is an atomic operation: either all data\n     * is written or nothing is (and EMSGSIZE is raised). That is\n     * why we don't handle partial writes. Just pop the request\n     * off the write queue and onto the completed queue, done.\n     */\n    QUEUE_REMOVE(\u0026req-\u003equeue);\n    QUEUE_INSERT_TAIL(\u0026handle-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n    uv__io_feed(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n  }\n}","filepath":"src/unix/udp.c","line_number":216,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5195744":{"score":0.7360789,"function_name":"uv__udp_io","code":"static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) {\n  uv_udp_t* handle;\n\n  handle = container_of(w, uv_udp_t, io_watcher);\n  assert(handle-\u003etype == UV_UDP);\n\n  if (revents \u0026 POLLIN)\n    uv__udp_recvmsg(handle);\n\n  if (revents \u0026 POLLOUT) {\n    uv__udp_sendmsg(handle);\n    uv__udp_run_completed(handle);\n  }\n}","filepath":"src/unix/udp.c","line_number":173,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.38.1"},"5196304":{"score":0.6336274,"function_name":"uv__setsockopt","code":"static int uv__setsockopt(uv_udp_t* handle,\n                         int option4,\n                         int option6,\n                         const void* val,\n                         size_t size) {\n  int r;\n\n  if (handle-\u003eflags \u0026 UV_HANDLE_IPV6)\n    r = setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IPV6,\n                   option6,\n                   val,\n                   size);\n  else\n    r = setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IP,\n                   option4,\n                   val,\n                   size);\n  if (r)\n    return UV__ERR(errno);\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":728,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5196384":{"score":0.7356264,"function_name":"uv__udp_close","code":"void uv__udp_close(uv_udp_t* handle) {\n  uv__io_close(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n  uv__handle_stop(handle);\n\n  if (handle-\u003eio_watcher.fd != -1) {\n    uv__close(handle-\u003eio_watcher.fd);\n    handle-\u003eio_watcher.fd = -1;\n  }\n}","filepath":"src/unix/udp.c","line_number":52,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5196480":{"score":0.92420053,"function_name":"uv__udp_finish_close","code":"void uv__udp_finish_close(uv_udp_t* handle) {\n  uv_udp_send_t* req;\n  QUEUE* q;\n\n  assert(!uv__io_active(\u0026handle-\u003eio_watcher, POLLIN | POLLOUT));\n  assert(handle-\u003eio_watcher.fd == -1);\n\n  while (!QUEUE_EMPTY(\u0026handle-\u003ewrite_queue)) {\n    q = QUEUE_HEAD(\u0026handle-\u003ewrite_queue);\n    QUEUE_REMOVE(q);\n\n    req = QUEUE_DATA(q, uv_udp_send_t, queue);\n    req-\u003estatus = UV_ECANCELED;\n    QUEUE_INSERT_TAIL(\u0026handle-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n  }\n\n  uv__udp_run_completed(handle);\n\n  assert(handle-\u003esend_queue_size == 0);\n  assert(handle-\u003esend_queue_count == 0);\n\n  /* Now tear down the handle. */\n  handle-\u003erecv_cb = NULL;\n  handle-\u003ealloc_cb = NULL;\n  /* but _do not_ touch close_cb */\n}","filepath":"src/unix/udp.c","line_number":63,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5196768":{"score":0.8086026,"function_name":"uv__udp_bind","code":"int uv__udp_bind(uv_udp_t* handle,\n                 const struct sockaddr* addr,\n                 unsigned int addrlen,\n                 unsigned int flags) {\n  int err;\n  int yes;\n  int fd;\n\n  /* Check for bad flags. */\n  if (flags \u0026 ~(UV_UDP_IPV6ONLY | UV_UDP_REUSEADDR))\n    return UV_EINVAL;\n\n  /* Cannot set IPv6-only mode on non-IPv6 socket. */\n  if ((flags \u0026 UV_UDP_IPV6ONLY) \u0026\u0026 addr-\u003esa_family != AF_INET6)\n    return UV_EINVAL;\n\n  fd = handle-\u003eio_watcher.fd;\n  if (fd == -1) {\n    err = uv__socket(addr-\u003esa_family, SOCK_DGRAM, 0);\n    if (err \u003c 0)\n      return err;\n    fd = err;\n    handle-\u003eio_watcher.fd = fd;\n  }\n\n  if (flags \u0026 UV_UDP_REUSEADDR) {\n    err = uv__set_reuse(fd);\n    if (err)\n      return err;\n  }\n\n  if (flags \u0026 UV_UDP_IPV6ONLY) {\n#ifdef IPV6_V6ONLY\n    yes = 1;\n    if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, \u0026yes, sizeof yes) == -1) {\n      err = UV__ERR(errno);\n      return err;\n    }\n#else\n    err = UV_ENOTSUP;\n    return err;\n#endif\n  }\n\n  if (bind(fd, addr, addrlen)) {\n    err = UV__ERR(errno);\n    if (errno == EAFNOSUPPORT)\n      /* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\n       * socket created with AF_INET to an AF_INET6 address or vice versa. */\n      err = UV_EINVAL;\n    return err;\n  }\n\n  if (addr-\u003esa_family == AF_INET6)\n    handle-\u003eflags |= UV_HANDLE_IPV6;\n\n  handle-\u003eflags |= UV_HANDLE_BOUND;\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":289,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5197200":{"score":0.88395983,"function_name":"uv__udp_maybe_deferred_bind","code":"static int uv__udp_maybe_deferred_bind(uv_udp_t* handle,\n                                       int domain,\n                                       unsigned int flags) {\n  union {\n    struct sockaddr_in6 in6;\n    struct sockaddr_in in;\n    struct sockaddr addr;\n  } taddr;\n  socklen_t addrlen;\n\n  if (handle-\u003eio_watcher.fd != -1)\n    return 0;\n\n  switch (domain) {\n  case AF_INET:\n  {\n    struct sockaddr_in* addr = \u0026taddr.in;\n    memset(addr, 0, sizeof *addr);\n    addr-\u003esin_family = AF_INET;\n    addr-\u003esin_addr.s_addr = INADDR_ANY;\n    addrlen = sizeof *addr;\n    break;\n  }\n  case AF_INET6:\n  {\n    struct sockaddr_in6* addr = \u0026taddr.in6;\n    memset(addr, 0, sizeof *addr);\n    addr-\u003esin6_family = AF_INET6;\n    addr-\u003esin6_addr = in6addr_any;\n    addrlen = sizeof *addr;\n    break;\n  }\n  default:\n    assert(0 \u0026\u0026 \"unsupported address family\");\n    abort();\n  }\n\n  return uv__udp_bind(handle, \u0026taddr.addr, addrlen, flags);\n}","filepath":"src/unix/udp.c","line_number":350,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5197424":{"score":0.8738082,"function_name":"uv__udp_send","code":"int uv__udp_send(uv_udp_send_t* req,\n                 uv_udp_t* handle,\n                 const uv_buf_t bufs[],\n                 unsigned int nbufs,\n                 const struct sockaddr* addr,\n                 unsigned int addrlen,\n                 uv_udp_send_cb send_cb) {\n  int err;\n  int empty_queue;\n\n  assert(nbufs \u003e 0);\n\n  err = uv__udp_maybe_deferred_bind(handle, addr-\u003esa_family, 0);\n  if (err)\n    return err;\n\n  /* It's legal for send_queue_count \u003e 0 even when the write_queue is empty;\n   * it means there are error-state requests in the write_completed_queue that\n   * will touch up send_queue_size/count later.\n   */\n  empty_queue = (handle-\u003esend_queue_count == 0);\n\n  uv__req_init(handle-\u003eloop, req, UV_UDP_SEND);\n  assert(addrlen \u003c= sizeof(req-\u003eaddr));\n  memcpy(\u0026req-\u003eaddr, addr, addrlen);\n  req-\u003esend_cb = send_cb;\n  req-\u003ehandle = handle;\n  req-\u003enbufs = nbufs;\n\n  req-\u003ebufs = req-\u003ebufsml;\n  if (nbufs \u003e ARRAY_SIZE(req-\u003ebufsml))\n    req-\u003ebufs = uv__malloc(nbufs * sizeof(bufs[0]));\n\n  if (req-\u003ebufs == NULL) {\n    uv__req_unregister(handle-\u003eloop, req);\n    return -ENOMEM;\n  }\n\n  memcpy(req-\u003ebufs, bufs, nbufs * sizeof(bufs[0]));\n  handle-\u003esend_queue_size += uv__count_bufs(req-\u003ebufs, req-\u003enbufs);\n  handle-\u003esend_queue_count++;\n  QUEUE_INSERT_TAIL(\u0026handle-\u003ewrite_queue, \u0026req-\u003equeue);\n  uv__handle_start(handle);\n\n  if (empty_queue \u0026\u0026 !(handle-\u003eflags \u0026 UV_UDP_PROCESSING)) {\n    uv__udp_sendmsg(handle);\n  } else {\n    uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, UV__POLLOUT);\n  }\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":380,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5198112":{"score":0.8649939,"function_name":"uv__udp_try_send","code":"int uv__udp_try_send(uv_udp_t* handle,\n                     const uv_buf_t bufs[],\n                     unsigned int nbufs,\n                     const struct sockaddr* addr,\n                     unsigned int addrlen) {\n  int err;\n  struct msghdr h;\n  ssize_t size;\n\n  assert(nbufs \u003e 0);\n\n  /* already sending a message */\n  if (handle-\u003esend_queue_count != 0)\n    return UV_EAGAIN;\n\n  if (addr) {\n    err = uv__udp_maybe_deferred_bind(handle, addr-\u003esa_family, 0);\n    if (err)\n      return err;\n  } else {\n    assert(handle-\u003eflags \u0026 UV_HANDLE_UDP_CONNECTED);\n  }\n\n  memset(\u0026h, 0, sizeof h);\n  h.msg_name = (struct sockaddr*) addr;\n  h.msg_namelen = addrlen;\n  h.msg_iov = (struct iovec*) bufs;\n  h.msg_iovlen = nbufs;\n\n  do {\n    size = sendmsg(handle-\u003eio_watcher.fd, \u0026h, 0);\n  } while (size == -1 \u0026\u0026 errno == EINTR);\n\n  if (size == -1) {\n    if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)\n      return UV_EAGAIN;\n    else\n      return UV__ERR(errno);\n  }\n\n  return size;\n}","filepath":"src/unix/udp.c","line_number":501,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5198368":{"score":0.8337257,"function_name":"uv_udp_init_ex","code":"int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned int flags) {\n  int domain;\n  int err;\n  int fd;\n\n  /* Use the lower 8 bits for the domain */\n  domain = flags \u0026 0xFF;\n  if (domain != AF_INET \u0026\u0026 domain != AF_INET6 \u0026\u0026 domain != AF_UNSPEC)\n    return UV_EINVAL;\n\n  if (flags \u0026 ~0xFF)\n    return UV_EINVAL;\n\n  if (domain != AF_UNSPEC) {\n    err = uv__socket(domain, SOCK_DGRAM, 0);\n    if (err \u003c 0)\n      return err;\n    fd = err;\n  } else {\n    fd = -1;\n  }\n\n  uv__handle_init(loop, (uv_handle_t*)handle, UV_UDP);\n  handle-\u003ealloc_cb = NULL;\n  handle-\u003erecv_cb = NULL;\n  handle-\u003esend_queue_size = 0;\n  handle-\u003esend_queue_count = 0;\n  uv__io_init(\u0026handle-\u003eio_watcher, uv__udp_io, fd);\n  QUEUE_INIT(\u0026handle-\u003ewrite_queue);\n  QUEUE_INIT(\u0026handle-\u003ewrite_completed_queue);\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":639,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5198640":{"score":0.73205096,"function_name":"uv_udp_open","code":"int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {\n  int err;\n\n  /* Check for already active socket. */\n  if (handle-\u003eio_watcher.fd != -1)\n    return UV_EBUSY;\n\n  if (uv__fd_exists(handle-\u003eloop, sock))\n    return UV_EEXIST;\n\n  err = uv__nonblock(sock, 1);\n  if (err)\n    return err;\n\n  err = uv__set_reuse(sock);\n  if (err)\n    return err;\n\n  handle-\u003eio_watcher.fd = sock;\n  if (uv__udp_is_connected(handle))\n    handle-\u003eflags |= UV_HANDLE_UDP_CONNECTED;\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":679,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5198736":{"score":0.78406143,"function_name":"uv_udp_set_membership","code":"int uv_udp_set_membership(uv_udp_t* handle,\n                          const char* multicast_addr,\n                          const char* interface_addr,\n                          uv_membership membership) {\n  int err;\n  struct sockaddr_in addr4;\n  struct sockaddr_in6 addr6;\n\n  if (uv_ip4_addr(multicast_addr, 0, \u0026addr4) == 0) {\n    err = uv__udp_maybe_deferred_bind(handle, AF_INET, UV_UDP_REUSEADDR);\n    if (err)\n      return err;\n    return uv__udp_set_membership4(handle, \u0026addr4, interface_addr, membership);\n  } else if (uv_ip6_addr(multicast_addr, 0, \u0026addr6) == 0) {\n    err = uv__udp_maybe_deferred_bind(handle, AF_INET6, UV_UDP_REUSEADDR);\n    if (err)\n      return err;\n    return uv__udp_set_membership6(handle, \u0026addr6, interface_addr, membership);\n  } else {\n    return UV_EINVAL;\n  }\n}","filepath":"src/unix/udp.c","line_number":705,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5199216":{"score":0.8040576,"function_name":"uv_udp_set_broadcast","code":"int uv_udp_set_broadcast(uv_udp_t* handle, int on) {\n  if (setsockopt(handle-\u003eio_watcher.fd,\n                 SOL_SOCKET,\n                 SO_BROADCAST,\n                 \u0026on,\n                 sizeof(on))) {\n    return UV__ERR(errno);\n  }\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":772,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5199280":{"score":0.8155833,"function_name":"uv_udp_set_ttl","code":"int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {\n  if (ttl \u003c 1 || ttl \u003e 255)\n    return UV_EINVAL;\n\n#if defined(__MVS__)\n  if (!(handle-\u003eflags \u0026 UV_HANDLE_IPV6))\n    return UV_ENOTSUP;  /* zOS does not support setting ttl for IPv4 */\n#endif\n\n/*\n * On Solaris and derivatives such as SmartOS, the length of socket options\n * is sizeof(int) for IP_TTL and IPV6_UNICAST_HOPS,\n * so hardcode the size of these options on this platform,\n * and use the general uv__setsockopt_maybe_char call on other platforms.\n */\n#if defined(__sun) || defined(_AIX) || defined(__OpenBSD__) || \\\n    defined(__MVS__)\n\n  return uv__setsockopt(handle,\n                        IP_TTL,\n                        IPV6_UNICAST_HOPS,\n                        \u0026ttl,\n                        sizeof(ttl));\n\n#else /* !(defined(__sun) || defined(_AIX) || defined (__OpenBSD__) ||\n           defined(__MVS__)) */\n\n  return uv__setsockopt_maybe_char(handle,\n                                   IP_TTL,\n                                   IPV6_UNICAST_HOPS,\n                                   ttl);\n\n#endif /* defined(__sun) || defined(_AIX) || defined (__OpenBSD__) ||\n          defined(__MVS__) */\n}","filepath":"src/unix/udp.c","line_number":785,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5199488":{"score":0.769101,"function_name":"uv_udp_set_ttl","code":"int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {\n  if (ttl \u003c 1 || ttl \u003e 255)\n    return -EINVAL;\n\n#if defined(__MVS__)\n  if (!(handle-\u003eflags \u0026 UV_HANDLE_IPV6))\n    return -ENOTSUP;  /* zOS does not support setting ttl for IPv4 */\n#endif\n\n/*\n * On Solaris and derivatives such as SmartOS, the length of socket options\n * is sizeof(int) for IP_TTL and IPV6_UNICAST_HOPS,\n * so hardcode the size of these options on this platform,\n * and use the general uv__setsockopt_maybe_char call on other platforms.\n */\n#if defined(__sun) || defined(_AIX) || defined(__OpenBSD__) || \\\n    defined(__MVS__)\n\n  return uv__setsockopt(handle,\n                        IP_TTL,\n                        IPV6_UNICAST_HOPS,\n                        \u0026ttl,\n                        sizeof(ttl));\n#endif /* defined(__sun) || defined(_AIX) || defined (__OpenBSD__) ||\n          defined(__MVS__) */\n\n  return uv__setsockopt_maybe_char(handle,\n                                   IP_TTL,\n                                   IPV6_UNICAST_HOPS,\n                                   ttl);\n}","filepath":"src/unix/udp.c","line_number":718,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.12.0"},"5199584":{"score":0.8860572,"function_name":"uv_udp_set_multicast_interface","code":"int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr) {\n  struct sockaddr_storage addr_st;\n  struct sockaddr_in* addr4;\n  struct sockaddr_in6* addr6;\n\n  addr4 = (struct sockaddr_in*) \u0026addr_st;\n  addr6 = (struct sockaddr_in6*) \u0026addr_st;\n\n  if (!interface_addr) {\n    memset(\u0026addr_st, 0, sizeof addr_st);\n    if (handle-\u003eflags \u0026 UV_HANDLE_IPV6) {\n      addr_st.ss_family = AF_INET6;\n      addr6-\u003esin6_scope_id = 0;\n    } else {\n      addr_st.ss_family = AF_INET;\n      addr4-\u003esin_addr.s_addr = htonl(INADDR_ANY);\n    }\n  } else if (uv_ip4_addr(interface_addr, 0, addr4) == 0) {\n    /* nothing, address was parsed */\n  } else if (uv_ip6_addr(interface_addr, 0, addr6) == 0) {\n    /* nothing, address was parsed */\n  } else {\n    return UV_EINVAL;\n  }\n\n  if (addr_st.ss_family == AF_INET) {\n    if (setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IP,\n                   IP_MULTICAST_IF,\n                   (void*) \u0026addr4-\u003esin_addr,\n                   sizeof(addr4-\u003esin_addr)) == -1) {\n      return UV__ERR(errno);\n    }\n  } else if (addr_st.ss_family == AF_INET6) {\n    if (setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IPV6,\n                   IPV6_MULTICAST_IF,\n                   \u0026addr6-\u003esin6_scope_id,\n                   sizeof(addr6-\u003esin6_scope_id)) == -1) {\n      return UV__ERR(errno);\n    }\n  } else {\n    assert(0 \u0026\u0026 \"unexpected address family\");\n    abort();\n  }\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":871,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5200064":{"score":0.8675715,"function_name":"uv__udp_recv_start","code":"int uv__udp_recv_start(uv_udp_t* handle,\n                       uv_alloc_cb alloc_cb,\n                       uv_udp_recv_cb recv_cb) {\n  int err;\n\n  if (alloc_cb == NULL || recv_cb == NULL)\n    return UV_EINVAL;\n\n  if (uv__io_active(\u0026handle-\u003eio_watcher, POLLIN))\n    return UV_EALREADY;  /* FIXME(bnoordhuis) Should be UV_EBUSY. */\n\n  err = uv__udp_maybe_deferred_bind(handle, AF_INET, 0);\n  if (err)\n    return err;\n\n  handle-\u003ealloc_cb = alloc_cb;\n  handle-\u003erecv_cb = recv_cb;\n\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLIN);\n  uv__handle_start(handle);\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":941,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5200256":{"score":0.8208335,"function_name":"uv__udp_recv_stop","code":"int uv__udp_recv_stop(uv_udp_t* handle) {\n  uv__io_stop(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLIN);\n\n  if (!uv__io_active(\u0026handle-\u003eio_watcher, POLLOUT))\n    uv__handle_stop(handle);\n\n  handle-\u003ealloc_cb = NULL;\n  handle-\u003erecv_cb = NULL;\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":966,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.27.0"},"5200368":{"score":0.80126965,"function_name":"read_models","code":"static int read_models(unsigned int numcpus, uv_cpu_info_t* ci) {\n  static const char model_marker[] = \"model name\\t: \";\n  static const char speed_marker[] = \"cpu MHz\\t\\t: \";\n  const char* inferred_model;\n  unsigned int model_idx;\n  unsigned int speed_idx;\n  char buf[1024];\n  char* model;\n  FILE* fp;\n\n  /* Most are unused on non-ARM, non-MIPS and non-x86 architectures. */\n  (void) \u0026model_marker;\n  (void) \u0026speed_marker;\n  (void) \u0026speed_idx;\n  (void) \u0026model;\n  (void) \u0026buf;\n  (void) \u0026fp;\n\n  model_idx = 0;\n  speed_idx = 0;\n\n#if defined(__arm__) || \\\n    defined(__i386__) || \\\n    defined(__mips__) || \\\n    defined(__x86_64__)\n  fp = fopen(\"/proc/cpuinfo\", \"r\");\n  if (fp == NULL)\n    return -errno;\n\n  while (fgets(buf, sizeof(buf), fp)) {\n    if (model_idx \u003c numcpus) {\n      if (strncmp(buf, model_marker, sizeof(model_marker) - 1) == 0) {\n        model = buf + sizeof(model_marker) - 1;\n        model = uv__strndup(model, strlen(model) - 1);  /* Strip newline. */\n        if (model == NULL) {\n          fclose(fp);\n          return -ENOMEM;\n        }\n        ci[model_idx++].model = model;\n        continue;\n      }\n    }\n#if defined(__arm__) || defined(__mips__)\n    if (model_idx \u003c numcpus) {\n#if defined(__arm__)\n      /* Fallback for pre-3.8 kernels. */\n      static const char model_marker[] = \"Processor\\t: \";\n#else\t/* defined(__mips__) */\n      static const char model_marker[] = \"cpu model\\t\\t: \";\n#endif\n      if (strncmp(buf, model_marker, sizeof(model_marker) - 1) == 0) {\n        model = buf + sizeof(model_marker) - 1;\n        model = uv__strndup(model, strlen(model) - 1);  /* Strip newline. */\n        if (model == NULL) {\n          fclose(fp);\n          return -ENOMEM;\n        }\n        ci[model_idx++].model = model;\n        continue;\n      }\n    }\n#else  /* !__arm__ \u0026\u0026 !__mips__ */\n    if (speed_idx \u003c numcpus) {\n      if (strncmp(buf, speed_marker, sizeof(speed_marker) - 1) == 0) {\n        ci[speed_idx++].speed = atoi(buf + sizeof(speed_marker) - 1);\n        continue;\n      }\n    }\n#endif  /* __arm__ || __mips__ */\n  }\n\n  fclose(fp);\n#endif  /* __arm__ || __i386__ || __mips__ || __x86_64__ */\n\n  /* Now we want to make sure that all the models contain *something* because\n   * it's not safe to leave them as null. Copy the last entry unless there\n   * isn't one, in that case we simply put \"unknown\" into everything.\n   */\n  inferred_model = \"unknown\";\n  if (model_idx \u003e 0)\n    inferred_model = ci[model_idx - 1].model;\n\n  while (model_idx \u003c numcpus) {\n    model = uv__strndup(inferred_model, strlen(inferred_model));\n    if (model == NULL)\n      return -ENOMEM;\n    ci[model_idx++].model = model;\n  }\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":586,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5200864":{"score":0.881022,"function_name":"read_times","code":"static int read_times(unsigned int numcpus, uv_cpu_info_t* ci) {\n  unsigned long clock_ticks;\n  struct uv_cpu_times_s ts;\n  unsigned long user;\n  unsigned long nice;\n  unsigned long sys;\n  unsigned long idle;\n  unsigned long dummy;\n  unsigned long irq;\n  unsigned int num;\n  unsigned int len;\n  char buf[1024];\n  FILE* fp;\n\n  clock_ticks = sysconf(_SC_CLK_TCK);\n  assert(clock_ticks != (unsigned long) -1);\n  assert(clock_ticks != 0);\n\n  fp = fopen(\"/proc/stat\", \"r\");\n  if (fp == NULL)\n    return -errno;\n\n  if (!fgets(buf, sizeof(buf), fp))\n    abort();\n\n  num = 0;\n\n  while (fgets(buf, sizeof(buf), fp)) {\n    if (num \u003e= numcpus)\n      break;\n\n    if (strncmp(buf, \"cpu\", 3))\n      break;\n\n    /* skip \"cpu\u003cnum\u003e \" marker */\n    {\n      unsigned int n;\n      int r = sscanf(buf, \"cpu%u \", \u0026n);\n      assert(r == 1);\n      (void) r;  /* silence build warning */\n      for (len = sizeof(\"cpu0\"); n /= 10; len++);\n    }\n\n    /* Line contains user, nice, system, idle, iowait, irq, softirq, steal,\n     * guest, guest_nice but we're only interested in the first four + irq.\n     *\n     * Don't use %*s to skip fields or %ll to read straight into the uint64_t\n     * fields, they're not allowed in C89 mode.\n     */\n    if (6 != sscanf(buf + len,\n                    \"%lu %lu %lu %lu %lu %lu\",\n                    \u0026user,\n                    \u0026nice,\n                    \u0026sys,\n                    \u0026idle,\n                    \u0026dummy,\n                    \u0026irq))\n      abort();\n\n    ts.user = clock_ticks * user;\n    ts.nice = clock_ticks * nice;\n    ts.sys  = clock_ticks * sys;\n    ts.idle = clock_ticks * idle;\n    ts.irq  = clock_ticks * irq;\n    ci[num++].cpu_times = ts;\n  }\n  fclose(fp);\n  assert(num == numcpus);\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":679,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5201472":{"score":0.9233323,"function_name":"read_cpufreq","code":"static unsigned long read_cpufreq(unsigned int cpunum) {\n  unsigned long val;\n  char buf[1024];\n  FILE* fp;\n\n  snprintf(buf,\n           sizeof(buf),\n           \"/sys/devices/system/cpu/cpu%u/cpufreq/scaling_cur_freq\",\n           cpunum);\n\n  fp = fopen(buf, \"r\");\n  if (fp == NULL)\n    return 0;\n\n  if (fscanf(fp, \"%lu\", \u0026val) != 1)\n    val = 0;\n\n  fclose(fp);\n\n  return val;\n}","filepath":"src/unix/linux-core.c","line_number":752,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5201648":{"score":0.7650763,"function_name":"uv__platform_loop_init","code":"int uv__platform_loop_init(uv_loop_t* loop) {\n  int fd;\n\n  fd = uv__epoll_create1(UV__EPOLL_CLOEXEC);\n\n  /* epoll_create1() can fail either because it's not implemented (old kernel)\n   * or because it doesn't understand the EPOLL_CLOEXEC flag.\n   */\n  if (fd == -1 \u0026\u0026 (errno == ENOSYS || errno == EINVAL)) {\n    fd = uv__epoll_create(256);\n\n    if (fd != -1)\n      uv__cloexec(fd, 1);\n  }\n\n  loop-\u003ebackend_fd = fd;\n  loop-\u003einotify_fd = -1;\n  loop-\u003einotify_watchers = NULL;\n\n  if (fd == -1)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":77,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5201824":{"score":0.6946449,"function_name":"uv__async_stop","code":"void uv__async_stop(uv_loop_t* loop) {\n  if (loop-\u003easync_io_watcher.fd == -1)\n    return;\n\n  if (loop-\u003easync_wfd != -1) {\n    if (loop-\u003easync_wfd != loop-\u003easync_io_watcher.fd)\n      uv__close(loop-\u003easync_wfd);\n    loop-\u003easync_wfd = -1;\n  }\n\n  uv__io_stop(loop, \u0026loop-\u003easync_io_watcher, POLLIN);\n  uv__close(loop-\u003easync_io_watcher.fd);\n  loop-\u003easync_io_watcher.fd = -1;\n}","filepath":"src/unix/async.c","line_number":227,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.35.0"},"5201888":{"score":0.8382697,"function_name":"uv__platform_invalidate_fd","code":"void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {\n  struct uv__epoll_event* events;\n  struct uv__epoll_event dummy;\n  uintptr_t i;\n  uintptr_t nfds;\n\n  assert(loop-\u003ewatchers != NULL);\n\n  events = (struct uv__epoll_event*) loop-\u003ewatchers[loop-\u003enwatchers];\n  nfds = (uintptr_t) loop-\u003ewatchers[loop-\u003enwatchers + 1];\n  if (events != NULL)\n    /* Invalidate events with same file descriptor */\n    for (i = 0; i \u003c nfds; i++)\n      if ((int) events[i].data == fd)\n        events[i].data = -1;\n\n  /* Remove the file descriptor from the epoll.\n   * This avoids a problem where the same file description remains open\n   * in another process, causing repeated junk epoll events.\n   *\n   * We pass in a dummy epoll_event, to work around a bug in old kernels.\n   */\n  if (loop-\u003ebackend_fd \u003e= 0) {\n    /* Work around a bug in kernels 3.10 to 3.19 where passing a struct that\n     * has the EPOLLWAKEUP flag set generates spurious audit syslog warnings.\n     */\n    memset(\u0026dummy, 0, sizeof(dummy));\n    uv__epoll_ctl(loop-\u003ebackend_fd, UV__EPOLL_CTL_DEL, fd, \u0026dummy);\n  }\n}","filepath":"src/unix/linux-core.c","line_number":111,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5202096":{"score":0.86012983,"function_name":"uv__hrtime","code":"uint64_t uv__hrtime(uv_clocktype_t type) {\n  static clock_t fast_clock_id = -1;\n  struct timespec t;\n  clock_t clock_id;\n\n  /* Prefer CLOCK_MONOTONIC_COARSE if available but only when it has\n   * millisecond granularity or better.  CLOCK_MONOTONIC_COARSE is\n   * serviced entirely from the vDSO, whereas CLOCK_MONOTONIC may\n   * decide to make a costly system call.\n   */\n  /* TODO(bnoordhuis) Use CLOCK_MONOTONIC_COARSE for UV_CLOCK_PRECISE\n   * when it has microsecond granularity or better (unlikely).\n   */\n  if (type == UV_CLOCK_FAST \u0026\u0026 fast_clock_id == -1) {\n    if (clock_getres(CLOCK_MONOTONIC_COARSE, \u0026t) == 0 \u0026\u0026\n        t.tv_nsec \u003c= 1 * 1000 * 1000) {\n      fast_clock_id = CLOCK_MONOTONIC_COARSE;\n    } else {\n      fast_clock_id = CLOCK_MONOTONIC;\n    }\n  }\n\n  clock_id = CLOCK_MONOTONIC;\n  if (type == UV_CLOCK_FAST)\n    clock_id = fast_clock_id;\n\n  if (clock_gettime(clock_id, \u0026t))\n    return 0;  /* Not really possible. */\n\n  return t.tv_sec * (uint64_t) 1e9 + t.tv_nsec;\n}","filepath":"src/unix/linux-core.c","line_number":379,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5202288":{"score":0.8914451,"function_name":"uv__io_poll","code":"void uv__io_poll(uv_loop_t* loop, int timeout) {\n  struct kevent events[1024];\n  struct kevent* ev;\n  struct timespec spec;\n  unsigned int nevents;\n  unsigned int revents;\n  QUEUE* q;\n  uint64_t base;\n  uint64_t diff;\n  uv__io_t* w;\n  int filter;\n  int fflags;\n  int count;\n  int nfds;\n  int fd;\n  int op;\n  int i;\n\n  if (loop-\u003enfds == 0) {\n    assert(QUEUE_EMPTY(\u0026loop-\u003ewatcher_queue));\n    return;\n  }\n\n  nevents = 0;\n\n  while (!QUEUE_EMPTY(\u0026loop-\u003ewatcher_queue)) {\n    q = QUEUE_HEAD(\u0026loop-\u003ewatcher_queue);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n\n    w = QUEUE_DATA(q, uv__io_t, watcher_queue);\n    assert(w-\u003epevents != 0);\n    assert(w-\u003efd \u003e= 0);\n    assert(w-\u003efd \u003c (int) loop-\u003enwatchers);\n\n    if ((w-\u003eevents \u0026 UV__POLLIN) == 0 \u0026\u0026 (w-\u003epevents \u0026 UV__POLLIN) != 0) {\n      filter = EVFILT_READ;\n      fflags = 0;\n      op = EV_ADD;\n\n      if (w-\u003ecb == uv__fs_event) {\n        filter = EVFILT_VNODE;\n        fflags = NOTE_ATTRIB | NOTE_WRITE  | NOTE_RENAME\n               | NOTE_DELETE | NOTE_EXTEND | NOTE_REVOKE;\n        op = EV_ADD | EV_ONESHOT; /* Stop the event from firing repeatedly. */\n      }\n\n      EV_SET(events + nevents, w-\u003efd, filter, op, fflags, 0, 0);\n\n      if (++nevents == ARRAY_SIZE(events)) {\n        if (kevent(loop-\u003ebackend_fd, events, nevents, NULL, 0, NULL))\n          abort();\n        nevents = 0;\n      }\n    }\n\n    if ((w-\u003eevents \u0026 UV__POLLOUT) == 0 \u0026\u0026 (w-\u003epevents \u0026 UV__POLLOUT) != 0) {\n      EV_SET(events + nevents, w-\u003efd, EVFILT_WRITE, EV_ADD, 0, 0, 0);\n\n      if (++nevents == ARRAY_SIZE(events)) {\n        if (kevent(loop-\u003ebackend_fd, events, nevents, NULL, 0, NULL))\n          abort();\n        nevents = 0;\n      }\n    }\n\n    w-\u003eevents = w-\u003epevents;\n  }\n\n  assert(timeout \u003e= -1);\n  base = loop-\u003etime;\n  count = 48; /* Benchmarks suggest this gives the best throughput. */\n\n  for (;; nevents = 0) {\n    if (timeout != -1) {\n      spec.tv_sec = timeout / 1000;\n      spec.tv_nsec = (timeout % 1000) * 1000000;\n    }\n\n    nfds = kevent(loop-\u003ebackend_fd,\n                  events,\n                  nevents,\n                  events,\n                  ARRAY_SIZE(events),\n                  timeout == -1 ? NULL : \u0026spec);\n\n    /* Update loop-\u003etime unconditionally. It's tempting to skip the update when\n     * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the\n     * operating system didn't reschedule our process while in the syscall.\n     */\n    SAVE_ERRNO(uv__update_time(loop));\n\n    if (nfds == 0) {\n      assert(timeout != -1);\n      return;\n    }\n\n    if (nfds == -1) {\n      if (errno != EINTR)\n        abort();\n\n      if (timeout == 0)\n        return;\n\n      if (timeout == -1)\n        continue;\n\n      /* Interrupted by a signal. Update timeout and poll again. */\n      goto update_timeout;\n    }\n\n    nevents = 0;\n\n    for (i = 0; i \u003c nfds; i++) {\n      ev = events + i;\n      fd = ev-\u003eident;\n      w = loop-\u003ewatchers[fd];\n\n      if (w == NULL) {\n        /* File descriptor that we've stopped watching, disarm it. */\n        /* TODO batch up */\n        struct kevent events[1];\n\n        EV_SET(events + 0, fd, ev-\u003efilter, EV_DELETE, 0, 0, 0);\n        if (kevent(loop-\u003ebackend_fd, events, 1, NULL, 0, NULL))\n          if (errno != EBADF \u0026\u0026 errno != ENOENT)\n            abort();\n\n        continue;\n      }\n\n      if (ev-\u003efilter == EVFILT_VNODE) {\n        assert(w-\u003eevents == UV__POLLIN);\n        assert(w-\u003epevents == UV__POLLIN);\n        w-\u003ecb(loop, w, ev-\u003efflags); /* XXX always uv__fs_event() */\n        nevents++;\n        continue;\n      }\n\n      revents = 0;\n\n      if (ev-\u003efilter == EVFILT_READ) {\n        if (w-\u003eevents \u0026 UV__POLLIN) {\n          revents |= UV__POLLIN;\n          w-\u003ercount = ev-\u003edata;\n        } else {\n          /* TODO batch up */\n          struct kevent events[1];\n          EV_SET(events + 0, fd, ev-\u003efilter, EV_DELETE, 0, 0, 0);\n          if (kevent(loop-\u003ebackend_fd, events, 1, NULL, 0, NULL))\n            if (errno != ENOENT)\n              abort();\n        }\n      }\n\n      if (ev-\u003efilter == EVFILT_WRITE) {\n        if (w-\u003eevents \u0026 UV__POLLOUT) {\n          revents |= UV__POLLOUT;\n          w-\u003ewcount = ev-\u003edata;\n        } else {\n          /* TODO batch up */\n          struct kevent events[1];\n          EV_SET(events + 0, fd, ev-\u003efilter, EV_DELETE, 0, 0, 0);\n          if (kevent(loop-\u003ebackend_fd, events, 1, NULL, 0, NULL))\n            if (errno != ENOENT)\n              abort();\n        }\n      }\n\n      if (ev-\u003eflags \u0026 EV_ERROR)\n        revents |= UV__POLLERR;\n\n      if (revents == 0)\n        continue;\n\n      w-\u003ecb(loop, w, revents);\n      nevents++;\n    }\n\n    if (nevents != 0) {\n      if (nfds == ARRAY_SIZE(events) \u0026\u0026 --count != 0) {\n        /* Poll for more events but don't block this time. */\n        timeout = 0;\n        continue;\n      }\n      return;\n    }\n\n    if (timeout == 0)\n      return;\n\n    if (timeout == -1)\n      continue;\n\nupdate_timeout:\n    assert(timeout \u003e 0);\n\n    diff = loop-\u003etime - base;\n    if (diff \u003e= (uint64_t) timeout)\n      return;\n\n    timeout -= diff;\n  }\n}","filepath":"src/unix/kqueue.c","line_number":52,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.2"},"5204320":{"score":0.88468677,"function_name":"uv_exepath","code":"int uv_exepath(char* buffer, size_t* size) {\n  ssize_t n;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return -EINVAL;\n\n  n = *size - 1;\n  if (n \u003e 0)\n    n = readlink(\"/proc/self/exe\", buffer, n);\n\n  if (n == -1)\n    return -errno;\n\n  buffer[n] = '\\0';\n  *size = n;\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":423,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5204496":{"score":0.7981086,"function_name":"uv_resident_set_memory","code":"int uv_resident_set_memory(size_t* rss) {\n  char buf[1024];\n  const char* s;\n  ssize_t n;\n  long val;\n  int fd;\n  int i;\n\n  do\n    fd = open(\"/proc/self/stat\", O_RDONLY);\n  while (fd == -1 \u0026\u0026 errno == EINTR);\n\n  if (fd == -1)\n    return -errno;\n\n  do\n    n = read(fd, buf, sizeof(buf) - 1);\n  while (n == -1 \u0026\u0026 errno == EINTR);\n\n  uv__close(fd);\n  if (n == -1)\n    return -errno;\n  buf[n] = '\\0';\n\n  s = strchr(buf, ' ');\n  if (s == NULL)\n    goto err;\n\n  s += 1;\n  if (*s != '(')\n    goto err;\n\n  s = strchr(s, ')');\n  if (s == NULL)\n    goto err;\n\n  for (i = 1; i \u003c= 22; i++) {\n    s = strchr(s + 1, ' ');\n    if (s == NULL)\n      goto err;\n  }\n\n  errno = 0;\n  val = strtol(s, NULL, 10);\n  if (errno != 0)\n    goto err;\n  if (val \u003c 0)\n    goto err;\n\n  *rss = val * getpagesize();\n  return 0;\n\nerr:\n  return -EINVAL;\n}","filepath":"src/unix/linux-core.c","line_number":453,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5204864":{"score":0.7280345,"function_name":"uv_uptime","code":"int uv_uptime(double* uptime) {\n  static volatile int no_clock_boottime;\n  struct timespec now;\n  int r;\n\n  /* Try CLOCK_BOOTTIME first, fall back to CLOCK_MONOTONIC if not available\n   * (pre-2.6.39 kernels). CLOCK_MONOTONIC doesn't increase when the system\n   * is suspended.\n   */\n  if (no_clock_boottime) {\n    retry: r = clock_gettime(CLOCK_MONOTONIC, \u0026now);\n  }\n  else if ((r = clock_gettime(CLOCK_BOOTTIME, \u0026now)) \u0026\u0026 errno == EINVAL) {\n    no_clock_boottime = 1;\n    goto retry;\n  }\n\n  if (r)\n    return -errno;\n\n  *uptime = now.tv_sec;\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":510,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5205040":{"score":0.8665441,"function_name":"uv_free_interface_addresses","code":"void uv_free_interface_addresses(uv_interface_address_t* addresses,\n  int count) {\n  int i;\n\n  for (i = 0; i \u003c count; i++) {\n    uv__free(addresses[i].name);\n  }\n\n  uv__free(addresses);\n}","filepath":"src/unix/linux-core.c","line_number":883,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5205120":{"score":0.86221725,"function_name":"uv_cpu_info","code":"int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n  unsigned int numcpus;\n  uv_cpu_info_t* ci;\n  int err;\n\n  *cpu_infos = NULL;\n  *count = 0;\n\n  numcpus = sysconf(_SC_NPROCESSORS_ONLN);\n  assert(numcpus != (unsigned int) -1);\n  assert(numcpus != 0);\n\n  ci = uv__calloc(numcpus, sizeof(*ci));\n  if (ci == NULL)\n    return -ENOMEM;\n\n  err = read_models(numcpus, ci);\n  if (err == 0)\n    err = read_times(numcpus, ci);\n\n  if (err) {\n    uv_free_cpu_info(ci, numcpus);\n    return err;\n  }\n\n  /* read_models() on x86 also reads the CPU speed from /proc/cpuinfo.\n   * We don't check for errors here. Worst case, the field is left zero.\n   */\n  if (ci[0].speed == 0)\n    read_speeds(numcpus, ci);\n\n  *cpu_infos = ci;\n  *count = numcpus;\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":535,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5209504":{"score":0.77940273,"function_name":"uv_fs_event_stop","code":"int uv_fs_event_stop(uv_fs_event_t* handle) {\n  struct watcher_list* w;\n\n  if (!uv__is_active(handle))\n    return 0;\n\n  w = find_watcher(handle-\u003eloop, handle-\u003ewd);\n  assert(w != NULL);\n\n  handle-\u003ewd = -1;\n  handle-\u003epath = NULL;\n  uv__handle_stop(handle);\n  QUEUE_REMOVE(\u0026handle-\u003ewatchers);\n\n  maybe_free_watcher_list(w, handle-\u003eloop);\n\n  return 0;\n}","filepath":"wpiutil/src/main/native/libuv/unix/linux-inotify.cpp","line_number":330,"entry_url":"https://github.com/wpilibsuite/allwpilib.git","slot_name":"v2019.1.1-beta-1"},"5210384":{"score":0.72753304,"function_name":"poll_cb","code":"static void poll_cb(uv_fs_t* req) {\n  uv_stat_t* statbuf;\n  struct poll_ctx* ctx;\n  uint64_t interval;\n\n  ctx = container_of(req, struct poll_ctx, fs_req);\n\n  if (ctx-\u003eparent_handle == NULL) { /* handle has been stopped or closed */\n    uv_close((uv_handle_t*)\u0026ctx-\u003etimer_handle, timer_close_cb);\n    uv_fs_req_cleanup(req);\n    return;\n  }\n\n  if (req-\u003eresult != 0) {\n    if (ctx-\u003ebusy_polling != req-\u003eresult) {\n      ctx-\u003epoll_cb(ctx-\u003eparent_handle,\n                   req-\u003eresult,\n                   \u0026ctx-\u003estatbuf,\n                   \u0026zero_statbuf);\n      ctx-\u003ebusy_polling = req-\u003eresult;\n    }\n    goto out;\n  }\n\n  statbuf = \u0026req-\u003estatbuf;\n\n  if (ctx-\u003ebusy_polling != 0)\n    if (ctx-\u003ebusy_polling \u003c 0 || !statbuf_eq(\u0026ctx-\u003estatbuf, statbuf))\n      ctx-\u003epoll_cb(ctx-\u003eparent_handle, 0, \u0026ctx-\u003estatbuf, statbuf);\n\n  ctx-\u003estatbuf = *statbuf;\n  ctx-\u003ebusy_polling = 1;\n\nout:\n  uv_fs_req_cleanup(req);\n\n  if (ctx-\u003eparent_handle == NULL) { /* handle has been stopped by callback */\n    uv_close((uv_handle_t*)\u0026ctx-\u003etimer_handle, timer_close_cb);\n    return;\n  }\n\n  /* Reschedule timer, subtract the delay from doing the stat(). */\n  interval = ctx-\u003einterval;\n  interval -= (uv_now(ctx-\u003eloop) - ctx-\u003estart_time) % interval;\n\n  if (uv_timer_start(\u0026ctx-\u003etimer_handle, timer_cb, interval, 0))\n    abort();\n}","filepath":"src/fs-poll.c","line_number":171,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5210976":{"score":0.76804745,"function_name":"timer_cb","code":"static void timer_cb(uv_timer_t* timer) {\n  struct poll_ctx* ctx;\n\n  ctx = container_of(timer, struct poll_ctx, timer_handle);\n  assert(ctx-\u003eparent_handle != NULL);\n  assert(ctx-\u003eparent_handle-\u003epoll_ctx == ctx);\n  ctx-\u003estart_time = uv_now(ctx-\u003eloop);\n\n  if (uv_fs_stat(ctx-\u003eloop, \u0026ctx-\u003efs_req, ctx-\u003epath, poll_cb))\n    abort();\n}","filepath":"src/fs-poll.c","line_number":158,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211168":{"score":0.801365,"function_name":"uv_fs_poll_start","code":"int uv_fs_poll_start(uv_fs_poll_t* handle,\n                     uv_fs_poll_cb cb,\n                     const char* path,\n                     unsigned int interval) {\n  struct poll_ctx* ctx;\n  uv_loop_t* loop;\n  size_t len;\n  int err;\n\n  if (uv__is_active(handle))\n    return 0;\n\n  loop = handle-\u003eloop;\n  len = strlen(path);\n  ctx = uv__calloc(1, sizeof(*ctx) + len);\n\n  if (ctx == NULL)\n    return UV_ENOMEM;\n\n  ctx-\u003eloop = loop;\n  ctx-\u003epoll_cb = cb;\n  ctx-\u003einterval = interval ? interval : 1;\n  ctx-\u003estart_time = uv_now(loop);\n  ctx-\u003eparent_handle = handle;\n  memcpy(ctx-\u003epath, path, len + 1);\n\n  err = uv_timer_init(loop, \u0026ctx-\u003etimer_handle);\n  if (err \u003c 0)\n    goto error;\n\n  ctx-\u003etimer_handle.flags |= UV__HANDLE_INTERNAL;\n  uv__handle_unref(\u0026ctx-\u003etimer_handle);\n\n  err = uv_fs_stat(loop, \u0026ctx-\u003efs_req, ctx-\u003epath, poll_cb);\n  if (err \u003c 0)\n    goto error;\n\n  handle-\u003epoll_ctx = ctx;\n  uv__handle_start(handle);\n\n  return 0;\n\nerror:\n  uv__free(ctx);\n  return err;\n}","filepath":"src/fs-poll.c","line_number":56,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211520":{"score":0.8483506,"function_name":"uv_fs_poll_stop","code":"int uv_fs_poll_stop(uv_fs_poll_t* handle) {\n  struct poll_ctx* ctx;\n\n  if (!uv__is_active(handle))\n    return 0;\n\n  ctx = handle-\u003epoll_ctx;\n  assert(ctx != NULL);\n  assert(ctx-\u003eparent_handle != NULL);\n  ctx-\u003eparent_handle = NULL;\n  handle-\u003epoll_ctx = NULL;\n\n  /* Close the timer if it's active. If it's inactive, there's a stat request\n   * in progress and poll_cb will take care of the cleanup.\n   */\n  if (uv__is_active(\u0026ctx-\u003etimer_handle))\n    uv_close((uv_handle_t*)\u0026ctx-\u003etimer_handle, timer_close_cb);\n\n  uv__handle_stop(handle);\n\n  return 0;\n}","filepath":"src/fs-poll.c","line_number":104,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211696":{"score":0.876194,"function_name":"uv_fs_poll_getpath","code":"int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buffer, size_t* size) {\n  struct poll_ctx* ctx;\n  size_t required_len;\n\n  if (!uv__is_active(handle)) {\n    *size = 0;\n    return UV_EINVAL;\n  }\n\n  ctx = handle-\u003epoll_ctx;\n  assert(ctx != NULL);\n\n  required_len = strlen(ctx-\u003epath);\n  if (required_len \u003e *size) {\n    *size = required_len;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, ctx-\u003epath, required_len);\n  *size = required_len;\n\n  return 0;\n}","filepath":"src/fs-poll.c","line_number":128,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211872":{"score":0.80084753,"function_name":"inet_ntop4","code":"static int inet_ntop4(const unsigned char *src, char *dst, size_t size) {\n  static const char fmt[] = \"%u.%u.%u.%u\";\n  char tmp[UV__INET_ADDRSTRLEN];\n  int l;\n\n  l = snprintf(tmp, sizeof(tmp), fmt, src[0], src[1], src[2], src[3]);\n  if (l \u003c= 0 || (size_t) l \u003e= size) {\n    return UV_ENOSPC;\n  }\n  strncpy(dst, tmp, size);\n  dst[size - 1] = '\\0';\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":53,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5212048":{"score":0.75353026,"function_name":"inet_pton4","code":"static int inet_pton4(const char *src, unsigned char *dst) {\n  static const char digits[] = \"0123456789\";\n  int saw_digit, octets, ch;\n  unsigned char tmp[sizeof(struct in_addr)], *tp;\n\n  saw_digit = 0;\n  octets = 0;\n  *(tp = tmp) = 0;\n  while ((ch = *src++) != '\\0') {\n    const char *pch;\n\n    if ((pch = strchr(digits, ch)) != NULL) {\n      unsigned int nw = *tp * 10 + (pch - digits);\n\n      if (saw_digit \u0026\u0026 *tp == 0)\n        return UV_EINVAL;\n      if (nw \u003e 255)\n        return UV_EINVAL;\n      *tp = nw;\n      if (!saw_digit) {\n        if (++octets \u003e 4)\n          return UV_EINVAL;\n        saw_digit = 1;\n      }\n    } else if (ch == '.' \u0026\u0026 saw_digit) {\n      if (octets == 4)\n        return UV_EINVAL;\n      *++tp = 0;\n      saw_digit = 0;\n    } else\n      return UV_EINVAL;\n  }\n  if (octets \u003c 4)\n    return UV_EINVAL;\n  memcpy(dst, tmp, sizeof(struct in_addr));\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":186,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5212320":{"score":0.6916133,"function_name":"uv_inet_ntop","code":"int uv_inet_ntop(int af, const void* src, char* dst, size_t size) {\n  switch (af) {\n  case AF_INET:\n    return (inet_ntop4(src, dst, size));\n  case AF_INET6:\n    return (inet_ntop6(src, dst, size));\n  default:\n    return UV_EAFNOSUPPORT;\n  }\n  /* NOTREACHED */\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":40,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5213168":{"score":0.68662477,"function_name":"uv_inet_pton","code":"int uv_inet_pton(int af, const char* src, void* dst) {\n  if (src == NULL || dst == NULL)\n    return UV_EINVAL;\n\n  switch (af) {\n  case AF_INET:\n    return (inet_pton4(src, dst));\n  case AF_INET6: {\n    int len;\n    char tmp[UV__INET6_ADDRSTRLEN], *s, *p;\n    s = (char*) src;\n    p = strchr(src, '%');\n    if (p != NULL) {\n      s = tmp;\n      len = p - src;\n      if (len \u003e UV__INET6_ADDRSTRLEN-1)\n        return UV_EINVAL;\n      memcpy(s, src, len);\n      s[len] = '\\0';\n    }\n    return inet_pton6(s, dst);\n  }\n  default:\n    return UV_EAFNOSUPPORT;\n  }\n  /* NOTREACHED */\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":157,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5213936":{"score":0.61398864,"function_name":"post","code":"static void post(QUEUE* q) {\n  int empty_queue;\n  uv_mutex_lock(\u0026mutex);\n  empty_queue = QUEUE_EMPTY(\u0026wq);\n  QUEUE_INSERT_TAIL(\u0026wq, q);\n  if (empty_queue)\n    uv_cond_signal(\u0026cond);\n  uv_mutex_unlock(\u0026mutex);\n}","filepath":"src/threadpool.c","line_number":103,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214016":{"score":0.6681741,"function_name":"worker","code":"static void worker(void* arg) {\n  struct uv__work* w;\n  QUEUE* q;\n\n  (void) arg;\n\n  for (;;) {\n    uv_mutex_lock(\u0026mutex);\n\n    while (QUEUE_EMPTY(\u0026wq))\n      uv_cond_wait(\u0026cond, \u0026mutex);\n\n    q = QUEUE_HEAD(\u0026wq);\n\n    if (q == \u0026exit_message)\n      uv_cond_signal(\u0026cond);\n    else {\n      QUEUE_REMOVE(q);\n      QUEUE_INIT(q);  /* Signal uv_cancel() that the work req is\n                             executing. */\n    }\n\n    uv_mutex_unlock(\u0026mutex);\n\n    if (q == \u0026exit_message)\n      break;\n\n    w = QUEUE_DATA(q, struct uv__work, wq);\n    w-\u003ework(w);\n\n    uv_mutex_lock(\u0026w-\u003eloop-\u003ewq_mutex);\n    w-\u003ework = NULL;  /* Signal uv_cancel() that the work req is done\n                        executing. */\n    QUEUE_INSERT_TAIL(\u0026w-\u003eloop-\u003ewq, \u0026w-\u003ewq);\n    uv_async_send(\u0026w-\u003eloop-\u003ewq_async);\n    uv_mutex_unlock(\u0026w-\u003eloop-\u003ewq_mutex);\n  }\n}","filepath":"src/threadpool.c","line_number":63,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214304":{"score":0.8741926,"function_name":"init_once","code":"static void init_once(void) {\n  unsigned int i;\n  const char* val;\n\n  nthreads = ARRAY_SIZE(default_threads);\n  val = getenv(\"UV_THREADPOOL_SIZE\");\n  if (val != NULL)\n    nthreads = atoi(val);\n  if (nthreads == 0)\n    nthreads = 1;\n  if (nthreads \u003e MAX_THREADPOOL_SIZE)\n    nthreads = MAX_THREADPOOL_SIZE;\n\n  threads = default_threads;\n  if (nthreads \u003e ARRAY_SIZE(default_threads)) {\n    threads = uv__malloc(nthreads * sizeof(threads[0]));\n    if (threads == NULL) {\n      nthreads = ARRAY_SIZE(default_threads);\n      threads = default_threads;\n    }\n  }\n\n  if (uv_cond_init(\u0026cond))\n    abort();\n\n  if (uv_mutex_init(\u0026mutex))\n    abort();\n\n  QUEUE_INIT(\u0026wq);\n\n  for (i = 0; i \u003c nthreads; i++)\n    if (uv_thread_create(threads + i, worker, NULL))\n      abort();\n\n  initialized = 1;\n}","filepath":"src/threadpool.c","line_number":140,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214736":{"score":0.82514644,"function_name":"uv__work_submit","code":"void uv__work_submit(uv_loop_t* loop,\n                     struct uv__work* w,\n                     void (*work)(struct uv__work* w),\n                     void (*done)(struct uv__work* w, int status)) {\n  uv_once(\u0026once, init_once);\n  w-\u003eloop = loop;\n  w-\u003ework = work;\n  w-\u003edone = done;\n  post(\u0026w-\u003ewq);\n}","filepath":"src/threadpool.c","line_number":178,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214816":{"score":0.59803456,"function_name":"uv__work_done","code":"void uv__work_done(uv_async_t* handle) {\n  struct uv__work* w;\n  uv_loop_t* loop;\n  QUEUE* q;\n  QUEUE wq;\n  int err;\n\n  loop = container_of(handle, uv_loop_t, wq_async);\n  QUEUE_INIT(\u0026wq);\n\n  uv_mutex_lock(\u0026loop-\u003ewq_mutex);\n  if (!QUEUE_EMPTY(\u0026loop-\u003ewq)) {\n    q = QUEUE_HEAD(\u0026loop-\u003ewq);\n    QUEUE_SPLIT(\u0026loop-\u003ewq, q, \u0026wq);\n  }\n  uv_mutex_unlock(\u0026loop-\u003ewq_mutex);\n\n  while (!QUEUE_EMPTY(\u0026wq)) {\n    q = QUEUE_HEAD(\u0026wq);\n    QUEUE_REMOVE(q);\n\n    w = container_of(q, struct uv__work, wq);\n    err = (w-\u003ework == uv__cancelled) ? UV_ECANCELED : 0;\n    w-\u003edone(w, err);\n  }\n}","filepath":"src/threadpool.c","line_number":216,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5215056":{"score":0.82766324,"function_name":"uv_queue_work","code":"int uv_queue_work(uv_loop_t* loop,\n                  uv_work_t* req,\n                  uv_work_cb work_cb,\n                  uv_after_work_cb after_work_cb) {\n  if (work_cb == NULL)\n    return UV_EINVAL;\n\n  uv__req_init(loop, req, UV_WORK);\n  req-\u003eloop = loop;\n  req-\u003ework_cb = work_cb;\n  req-\u003eafter_work_cb = after_work_cb;\n  uv__work_submit(loop, \u0026req-\u003ework_req, uv__queue_work, uv__queue_done);\n  return 0;\n}","filepath":"src/threadpool.c","line_number":264,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5215184":{"score":0.68883973,"function_name":"uv_cancel","code":"int uv_cancel(uv_req_t* req) {\n  struct uv__work* wreq;\n  uv_loop_t* loop;\n\n  switch (req-\u003etype) {\n  case UV_FS:\n    loop =  ((uv_fs_t*) req)-\u003eloop;\n    wreq = \u0026((uv_fs_t*) req)-\u003ework_req;\n    break;\n  case UV_GETADDRINFO:\n    loop =  ((uv_getaddrinfo_t*) req)-\u003eloop;\n    wreq = \u0026((uv_getaddrinfo_t*) req)-\u003ework_req;\n    break;\n  case UV_GETNAMEINFO:\n    loop = ((uv_getnameinfo_t*) req)-\u003eloop;\n    wreq = \u0026((uv_getnameinfo_t*) req)-\u003ework_req;\n    break;\n  case UV_WORK:\n    loop =  ((uv_work_t*) req)-\u003eloop;\n    wreq = \u0026((uv_work_t*) req)-\u003ework_req;\n    break;\n  default:\n    return UV_EINVAL;\n  }\n\n  return uv__work_cancel(loop, req, wreq);\n}","filepath":"src/threadpool.c","line_number":280,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5215590":{"score":0.74048376,"function_name":"cpuid_get_raw_data","code":"int cpuid_get_raw_data(struct cpu_raw_data_t* data)\n{\n\tunsigned i;\n\tif (!cpuid_present())\n\t\treturn set_error(ERR_NO_CPUID);\n\tfor (i = 0; i \u003c 32; i++)\n\t\tcpu_exec_cpuid(i, data-\u003ebasic_cpuid[i]);\n\tfor (i = 0; i \u003c 32; i++)\n\t\tcpu_exec_cpuid(0x80000000 + i, data-\u003eext_cpuid[i]);\n\tfor (i = 0; i \u003c MAX_INTELFN4_LEVEL; i++) {\n\t\tmemset(data-\u003eintel_fn4[i], 0, sizeof(data-\u003eintel_fn4[i]));\n\t\tdata-\u003eintel_fn4[i][0] = 4;\n\t\tdata-\u003eintel_fn4[i][2] = i;\n\t\tcpu_exec_cpuid_ext(data-\u003eintel_fn4[i]);\n\t}\n\tfor (i = 0; i \u003c MAX_INTELFN11_LEVEL; i++) {\n\t\tmemset(data-\u003eintel_fn11[i], 0, sizeof(data-\u003eintel_fn11[i]));\n\t\tdata-\u003eintel_fn11[i][0] = 11;\n\t\tdata-\u003eintel_fn11[i][2] = i;\n\t\tcpu_exec_cpuid_ext(data-\u003eintel_fn11[i]);\n\t}\n\tfor (i = 0; i \u003c MAX_INTELFN12H_LEVEL; i++) {\n\t\tmemset(data-\u003eintel_fn12h[i], 0, sizeof(data-\u003eintel_fn12h[i]));\n\t\tdata-\u003eintel_fn12h[i][0] = 0x12;\n\t\tdata-\u003eintel_fn12h[i][2] = i;\n\t\tcpu_exec_cpuid_ext(data-\u003eintel_fn12h[i]);\n\t}\n\tfor (i = 0; i \u003c MAX_INTELFN14H_LEVEL; i++) {\n\t\tmemset(data-\u003eintel_fn14h[i], 0, sizeof(data-\u003eintel_fn14h[i]));\n\t\tdata-\u003eintel_fn14h[i][0] = 0x14;\n\t\tdata-\u003eintel_fn14h[i][2] = i;\n\t\tcpu_exec_cpuid_ext(data-\u003eintel_fn14h[i]);\n\t}\n\treturn set_error(ERR_OK);\n}","filepath":"src/3rdparty/libcpuid/cpuid_main.c","line_number":319,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"5215917":{"score":0.5506566,"function_name":"cpu_ident_internal","code":"int cpu_ident_internal(struct cpu_raw_data_t* raw, struct cpu_id_t* data, struct internal_id_info_t* internal)\n{\n\tint r;\n\tstruct cpu_raw_data_t myraw;\n\tif (!raw) {\n\t\tif ((r = cpuid_get_raw_data(\u0026myraw)) \u003c 0)\n\t\t\treturn set_error(r);\n\t\traw = \u0026myraw;\n\t}\n\tcpu_id_t_constructor(data);\n\tif ((r = cpuid_basic_identify(raw, data)) \u003c 0)\n\t\treturn set_error(r);\n\tswitch (data-\u003evendor) {\n\t\tcase VENDOR_INTEL:\n\t\t\tr = cpuid_identify_intel(raw, data, internal);\n\t\t\tbreak;\n\t\tcase VENDOR_AMD:\n\t\t\tr = cpuid_identify_amd(raw, data, internal);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn set_error(r);\n}","filepath":"src/3rdparty/libcpuid/cpuid_main.c","line_number":355,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"5217961":{"score":0.50972426,"function_name":"load_features_common","code":"static void load_features_common(struct cpu_raw_data_t* raw, struct cpu_id_t* data)\n{\n\tconst struct feature_map_t matchtable_edx1[] = {\n\t\t{  0, CPU_FEATURE_FPU },\n\t\t{  1, CPU_FEATURE_VME },\n\t\t{  2, CPU_FEATURE_DE },\n\t\t{  3, CPU_FEATURE_PSE },\n\t\t{  4, CPU_FEATURE_TSC },\n\t\t{  5, CPU_FEATURE_MSR },\n\t\t{  6, CPU_FEATURE_PAE },\n\t\t{  7, CPU_FEATURE_MCE },\n\t\t{  8, CPU_FEATURE_CX8 },\n\t\t{  9, CPU_FEATURE_APIC },\n\t\t{ 11, CPU_FEATURE_SEP },\n\t\t{ 12, CPU_FEATURE_MTRR },\n\t\t{ 13, CPU_FEATURE_PGE },\n\t\t{ 14, CPU_FEATURE_MCA },\n\t\t{ 15, CPU_FEATURE_CMOV },\n\t\t{ 16, CPU_FEATURE_PAT },\n\t\t{ 17, CPU_FEATURE_PSE36 },\n\t\t{ 19, CPU_FEATURE_CLFLUSH },\n\t\t{ 23, CPU_FEATURE_MMX },\n\t\t{ 24, CPU_FEATURE_FXSR },\n\t\t{ 25, CPU_FEATURE_SSE },\n\t\t{ 26, CPU_FEATURE_SSE2 },\n\t\t{ 28, CPU_FEATURE_HT },\n\t};\n\tconst struct feature_map_t matchtable_ecx1[] = {\n\t\t{  0, CPU_FEATURE_PNI },\n\t\t{  1, CPU_FEATURE_PCLMUL },\n\t\t{  3, CPU_FEATURE_MONITOR },\n\t\t{  9, CPU_FEATURE_SSSE3 },\n\t\t{ 12, CPU_FEATURE_FMA3 },\n\t\t{ 13, CPU_FEATURE_CX16 },\n\t\t{ 19, CPU_FEATURE_SSE4_1 },\n\t\t{ 20, CPU_FEATURE_SSE4_2 },\n\t\t{ 22, CPU_FEATURE_MOVBE },\n\t\t{ 23, CPU_FEATURE_POPCNT },\n\t\t{ 25, CPU_FEATURE_AES },\n\t\t{ 26, CPU_FEATURE_XSAVE },\n\t\t{ 27, CPU_FEATURE_OSXSAVE },\n\t\t{ 28, CPU_FEATURE_AVX },\n\t\t{ 29, CPU_FEATURE_F16C },\n\t\t{ 30, CPU_FEATURE_RDRAND },\n\t};\n\tconst struct feature_map_t matchtable_ebx7[] = {\n\t\t{  3, CPU_FEATURE_BMI1 },\n\t\t{  5, CPU_FEATURE_AVX2 },\n\t\t{  8, CPU_FEATURE_BMI2 },\n\t};\n\tconst struct feature_map_t matchtable_edx81[] = {\n\t\t{ 11, CPU_FEATURE_SYSCALL },\n\t\t{ 27, CPU_FEATURE_RDTSCP },\n\t\t{ 29, CPU_FEATURE_LM },\n\t};\n\tconst struct feature_map_t matchtable_ecx81[] = {\n\t\t{  0, CPU_FEATURE_LAHF_LM },\n\t};\n\tconst struct feature_map_t matchtable_edx87[] = {\n\t\t{  8, CPU_FEATURE_CONSTANT_TSC },\n\t};\n\tif (raw-\u003ebasic_cpuid[0][0] \u003e= 1) {\n\t\tmatch_features(matchtable_edx1, COUNT_OF(matchtable_edx1), raw-\u003ebasic_cpuid[1][3], data);\n\t\tmatch_features(matchtable_ecx1, COUNT_OF(matchtable_ecx1), raw-\u003ebasic_cpuid[1][2], data);\n\t}\n\tif (raw-\u003ebasic_cpuid[0][0] \u003e= 7) {\n\t\tmatch_features(matchtable_ebx7, COUNT_OF(matchtable_ebx7), raw-\u003ebasic_cpuid[7][1], data);\n\t}\n\tif (raw-\u003eext_cpuid[0][0] \u003e= 0x80000001) {\n\t\tmatch_features(matchtable_edx81, COUNT_OF(matchtable_edx81), raw-\u003eext_cpuid[1][3], data);\n\t\tmatch_features(matchtable_ecx81, COUNT_OF(matchtable_ecx81), raw-\u003eext_cpuid[1][2], data);\n\t}\n\tif (raw-\u003eext_cpuid[0][0] \u003e= 0x80000007) {\n\t\tmatch_features(matchtable_edx87, COUNT_OF(matchtable_edx87), raw-\u003eext_cpuid[7][3], data);\n\t}\n\tif (data-\u003eflags[CPU_FEATURE_SSE]) {\n\t\t/* apply guesswork to check if the SSE unit width is 128 bit */\n\t\tswitch (data-\u003evendor) {\n\t\t\tcase VENDOR_AMD:\n\t\t\t\tdata-\u003esse_size = (data-\u003eext_family \u003e= 16 \u0026\u0026 data-\u003eext_family != 17) ? 128 : 64;\n\t\t\t\tbreak;\n\t\t\tcase VENDOR_INTEL:\n\t\t\t\tdata-\u003esse_size = (data-\u003efamily == 6 \u0026\u0026 data-\u003eext_model \u003e= 15) ? 128 : 64;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\t/* leave the CPU_FEATURE_128BIT_SSE_AUTH 0; the advanced per-vendor detection routines\n\t\t * will set it accordingly if they detect the needed bit */\n\t}\n}","filepath":"src/3rdparty/libcpuid/cpuid_main.c","line_number":130,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"5218746":{"score":0.5561601,"function_name":"cpuid_identify_intel","code":"int cpuid_identify_intel(struct cpu_raw_data_t* raw, struct cpu_id_t* data, struct internal_id_info_t* internal)\n{\n\tintel_code_and_bits_t brand;\n\n\tload_intel_features(raw, data);\n\tif (raw-\u003ebasic_cpuid[0][0] \u003e= 4) {\n\t\t/* Deterministic way is preferred, being more generic */\n\t\tdecode_intel_deterministic_cache_info(raw, data);\n\t} else if (raw-\u003ebasic_cpuid[0][0] \u003e= 2) {\n\t\tdecode_intel_oldstyle_cache_info(raw, data);\n\t}\n\tdecode_intel_number_of_cores(raw, data);\n\n\tbrand = get_brand_code_and_bits(data);\n\t\n\tinternal-\u003ecode.intel = brand.code;\n\tinternal-\u003ebits = brand.bits;\n\t\n\tif (data-\u003eflags[CPU_FEATURE_SGX]) {\n\t\t// if SGX is indicated by the CPU, verify its presence:\n\t\tdecode_intel_sgx_features(raw, data);\n\t}\n\n\treturn 0;\n}","filepath":"src/3rdparty/libcpuid/recog_intel.c","line_number":518,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.0"},"5222533":{"score":0.9098142,"function_name":"xmatch_entry","code":"static int xmatch_entry(char c, const char* p)\n{\n\tint i, j;\n\tif (c == 0) return -1;\n\tif (c == p[0]) return 1;\n\tif (p[0] == '.') return 1;\n\tif (p[0] == '#' \u0026\u0026 isdigit(c)) return 1;\n\tif (p[0] == '[') {\n\t\tj = 1;\n\t\twhile (p[j] \u0026\u0026 p[j] != ']') j++;\n\t\tif (!p[j]) return -1;\n\t\tfor (i = 1; i \u003c j; i++)\n\t\t\tif (p[i] == c) return j + 1;\n\t}\n\treturn -1;\n}","filepath":"libcpuid/libcpuid_util.c","line_number":141,"entry_url":"https://github.com/anrieff/libcpuid.git","slot_name":"v0.2.1"},"5222713":{"score":0.8855351,"function_name":"match_pattern","code":"int match_pattern(const char* s, const char* p)\n{\n\tint i, j, dj, k, n, m;\n\tn = (int) strlen(s);\n\tm = (int) strlen(p);\n\tfor (i = 0; i \u003c n; i++) {\n\t\tif (xmatch_entry(s[i], p) != -1) {\n\t\t\tj = 0;\n\t\t\tk = 0;\n\t\t\twhile (j \u003c m \u0026\u0026 ((dj = xmatch_entry(s[i + k], p + j)) != -1)) {\n\t\t\t\tk++;\n\t\t\t\tj += dj;\n\t\t\t}\n\t\t\tif (j == m) return i + 1;\n\t\t}\n\t}\n\treturn 0;\n}","filepath":"libcpuid/libcpuid_util.c","line_number":158,"entry_url":"https://github.com/anrieff/libcpuid.git","slot_name":"v0.2.1"},"5222867":{"score":0.7137586,"function_name":"get_cached_cpuid","code":"struct cpu_id_t* get_cached_cpuid(void)\n{\n\tstatic int initialized = 0;\n\tstatic struct cpu_id_t id;\n\tif (initialized) return \u0026id;\n\tif (cpu_identify(NULL, \u0026id))\n\t\tmemset(\u0026id, 0, sizeof(id));\n\tinitialized = 1;\n\treturn \u0026id;\n}","filepath":"libcpuid/libcpuid_util.c","line_number":177,"entry_url":"https://github.com/anrieff/libcpuid.git","slot_name":"v0.2.1"},"5223360":{"score":0.6911378,"function_name":"get_ttype_entry","code":"static const std::type_info *\nget_ttype_entry (lsda_header_info *info, _uleb128_t i)\n{\n  _Unwind_Ptr ptr;\n\n  i *= size_of_encoded_value (info-\u003ettype_encoding);\n  read_encoded_value_with_base (info-\u003ettype_encoding, info-\u003ettype_base,\n\t\t\t\tinfo-\u003eTType - i, \u0026ptr);\n\n  return reinterpret_cast\u003cconst std::type_info *\u003e(ptr);\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":90,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.4"},"5223536":{"score":0.8072144,"function_name":"base_of_encoded_value","code":"static _Unwind_Ptr\nbase_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding \u0026 0x70)\n    {\n    case DW_EH_PE_absptr:\n    case DW_EH_PE_pcrel:\n    case DW_EH_PE_aligned:\n      return 0;\n\n    case DW_EH_PE_textrel:\n      return _Unwind_GetTextRelBase (context);\n    case DW_EH_PE_datarel:\n      return _Unwind_GetDataRelBase (context);\n    case DW_EH_PE_funcrel:\n      return _Unwind_GetRegionStart (context);\n    }\n  __gxx_abort ();\n}","filepath":"libgcc/unwind-pe.h","line_number":100,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-5"},"5223648":{"score":0.69215703,"function_name":"parse_lsda_header","code":"static const unsigned char *\nparse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n\t\t   lsda_header_info *info)\n{\n  _uleb128_t tmp;\n  unsigned char lpstart_encoding;\n\n  info-\u003eStart = (context ? _Unwind_GetRegionStart (context) : 0);\n\n  // Find @LPStart, the base to which landing pad offsets are relative.\n  lpstart_encoding = *p++;\n  if (lpstart_encoding != DW_EH_PE_omit)\n    p = read_encoded_value (context, lpstart_encoding, p, \u0026info-\u003eLPStart);\n  else\n    info-\u003eLPStart = info-\u003eStart;\n\n  // Find @TType, the base of the handler and exception spec type data.\n  info-\u003ettype_encoding = *p++;\n  if (info-\u003ettype_encoding != DW_EH_PE_omit)\n    {\n#if _GLIBCXX_OVERRIDE_TTYPE_ENCODING\n      /* Older ARM EABI toolchains set this value incorrectly, so use a\n\t hardcoded OS-specific format.  */\n      info-\u003ettype_encoding = _GLIBCXX_OVERRIDE_TTYPE_ENCODING;\n#endif\n      p = read_uleb128 (p, \u0026tmp);\n      info-\u003eTType = p + tmp;\n    }\n  else\n    info-\u003eTType = 0;\n\n  // The encoding and length of the call-site table; the action table\n  // immediately follows.\n  info-\u003ecall_site_encoding = *p++;\n  p = read_uleb128 (p, \u0026tmp);\n  info-\u003eaction_table = p + tmp;\n\n  return p;\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":48,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.4"},"5223888":{"score":0.8105905,"function_name":"get_adjusted_ptr","code":"static bool\nget_adjusted_ptr (const std::type_info *catch_type,\n\t\t  const std::type_info *throw_type,\n\t\t  void **thrown_ptr_p)\n{\n  void *thrown_ptr = *thrown_ptr_p;\n\n  // Pointer types need to adjust the actual pointer, not\n  // the pointer to pointer that is the exception object.\n  // This also has the effect of passing pointer types\n  // \"by value\" through the __cxa_begin_catch return value.\n  if (throw_type-\u003e__is_pointer_p ())\n    thrown_ptr = *(void **) thrown_ptr;\n\n  if (catch_type-\u003e__do_catch (throw_type, \u0026thrown_ptr, 1))\n    {\n      *thrown_ptr_p = thrown_ptr;\n      return true;\n    }\n\n  return false;\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":214,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.4"},"5224016":{"score":0.61436355,"function_name":"check_exception_spec","code":"static bool\ncheck_exception_spec(lsda_header_info* info, _throw_typet* throw_type,\n\t\t      void* thrown_ptr, _sleb128_t filter_value)\n{\n  const unsigned char *e = info-\u003eTType - filter_value - 1;\n\n  while (1)\n    {\n      const std::type_info *catch_type;\n      _uleb128_t tmp;\n\n      e = read_uleb128 (e, \u0026tmp);\n\n      // Zero signals the end of the list.  If we've not found\n      // a match by now, then we've failed the specification.\n      if (tmp == 0)\n        return false;\n\n      // Match a ttype entry.\n      catch_type = get_ttype_entry (info, tmp);\n\n      // ??? There is currently no way to ask the RTTI code about the\n      // relationship between two types without reference to a specific\n      // object.  There should be; then we wouldn't need to mess with\n      // thrown_ptr here.\n      if (get_adjusted_ptr (catch_type, throw_type, \u0026thrown_ptr))\n\treturn true;\n    }\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":239,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.4"},"5224160":{"score":0.67453665,"function_name":"PERSONALITY_FUNCTION","code":"_Unwind_Reason_Code\nPERSONALITY_FUNCTION (int version,\n\t\t      _Unwind_Action actions,\n\t\t      _Unwind_Exception_Class exception_class,\n\t\t      struct _Unwind_Exception *ue_header,\n\t\t      struct _Unwind_Context *context)\n{\n  java_exception_header *xh = get_exception_header_from_ue (ue_header);\n\n  lsda_header_info info;\n  const unsigned char *language_specific_data;\n  const unsigned char *action_record;\n  const unsigned char *p;\n  _Unwind_Ptr landing_pad, ip;\n  int handler_switch_value;\n  bool saw_cleanup;\n  bool saw_handler;\n  int ip_before_insn = 0;\n\n\n  // Interface version check.\n  if (version != 1)\n    return _URC_FATAL_PHASE1_ERROR;\n\n  // Shortcut for phase 2 found handler for domestic exception.\n  if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)\n      \u0026\u0026 exception_class == __gcj_exception_class)\n    {\n      handler_switch_value = xh-\u003ehandlerSwitchValue;\n      landing_pad = xh-\u003elandingPad;\n      goto install_context;\n    }\n\n  // FIXME: In Phase 1, record _Unwind_GetIPInfo in xh-\u003eobj as a part of\n  // the stack trace for this exception.  This will only collect Java\n  // frames, but perhaps that is acceptable.\n  // FIXME2: _Unwind_GetIPInfo is nonsensical for SJLJ, being a call-site\n  // index instead of a PC value.  We could perhaps arrange for\n  // _Unwind_GetRegionStart to return context-\u003efc-\u003ejbuf[1], which\n  // is the address of the handler label for __builtin_longjmp, but\n  // there is no solution for DONT_USE_BUILTIN_SETJMP.\n\n  language_specific_data = (const unsigned char *)\n    _Unwind_GetLanguageSpecificData (context);\n\n  // If no LSDA, then there are no handlers or cleanups.\n  if (! language_specific_data)\n    return _URC_CONTINUE_UNWIND;\n\n  // Parse the LSDA header.\n  p = parse_lsda_header (context, language_specific_data, \u0026info);\n#ifdef HAVE_GETIPINFO\n  ip = _Unwind_GetIPInfo (context, \u0026ip_before_insn);\n  if (! ip_before_insn)\n    --ip;\n#else\n  ip = _Unwind_GetIP (context) - 1;\n#endif\n  landing_pad = 0;\n  action_record = 0;\n  handler_switch_value = 0;\n\n#ifdef SJLJ_EXCEPTIONS\n  // The given \"IP\" is an index into the call-site table, with two\n  // exceptions -- -1 means no-action, and 0 means terminate.  But\n  // since we're using uleb128 values, we've not got random access\n  // to the array.\n  if ((int) ip \u003c= 0)\n    return _URC_CONTINUE_UNWIND;\n  else\n    {\n      _Unwind_Word cs_lp, cs_action;\n      do\n\t{\n\t  p = read_uleb128 (p, \u0026cs_lp);\n\t  p = read_uleb128 (p, \u0026cs_action);\n\t}\n      while (--ip);\n\n      // Can never have null landing pad for sjlj -- that would have\n      // been indicated by a -1 call site index.\n      landing_pad = cs_lp + 1;\n      if (cs_action)\n\taction_record = info.action_table + cs_action - 1;\n      goto found_something;\n    }\n#else\n  // Search the call-site table for the action associated with this IP.\n  while (p \u003c info.action_table)\n    {\n      _Unwind_Ptr cs_start, cs_len, cs_lp;\n      _Unwind_Word cs_action;\n\n      // Note that all call-site encodings are \"absolute\" displacements.\n      p = read_encoded_value (0, info.call_site_encoding, p, \u0026cs_start);\n      p = read_encoded_value (0, info.call_site_encoding, p, \u0026cs_len);\n      p = read_encoded_value (0, info.call_site_encoding, p, \u0026cs_lp);\n      p = read_uleb128 (p, \u0026cs_action);\n\n      // The table is sorted, so if we've passed the ip, stop.\n      if (ip \u003c info.Start + cs_start)\n\tp = info.action_table;\n      else if (ip \u003c info.Start + cs_start + cs_len)\n\t{\n\t  if (cs_lp)\n\t    landing_pad = info.LPStart + cs_lp;\n\t  if (cs_action)\n\t    action_record = info.action_table + cs_action - 1;\n\t  goto found_something;\n\t}\n    }\n#endif // SJLJ_EXCEPTIONS\n\n  // If ip is not present in the table, C++ would call terminate.\n  // ??? It is perhaps better to tweek the LSDA so that no-action\n  // is mapped to no-entry for Java.\n  return _URC_CONTINUE_UNWIND;\n\n found_something:\n  saw_cleanup = false;\n  saw_handler = false;\n\n  if (landing_pad == 0)\n    {\n      // If ip is present, and has a null landing pad, there are\n      // no cleanups or handlers to be run.\n    }\n  else if (action_record == 0)\n    {\n      // If ip is present, has a non-null landing pad, and a null\n      // action table offset, then there are only cleanups present.\n      // Cleanups use a zero switch value, as set above.\n      saw_cleanup = true;\n    }\n  else\n    {\n      // Otherwise we have a catch handler.\n      _Unwind_Sword ar_filter, ar_disp;\n\n      while (1)\n\t{\n\t  p = action_record;\n\t  p = read_sleb128 (p, \u0026ar_filter);\n\t  read_sleb128 (p, \u0026ar_disp);\n\n\t  if (ar_filter == 0)\n\t    {\n\t      // Zero filter values are cleanups.\n\t      saw_cleanup = true;\n\t    }\n\n\t  // During forced unwinding, we only run cleanups.  With a\n\t  // foreign exception class, we have no class info to match.\n\t  else if ((actions \u0026 _UA_FORCE_UNWIND)\n\t      || exception_class != __gcj_exception_class)\n\t    ;\n\n\t  else if (ar_filter \u003e 0)\n\t    {\n\t      // Positive filter values are handlers.\n\n\t      void **catch_word = get_ttype_entry (context, \u0026info, ar_filter);\n\t      jclass catch_type = (jclass)*catch_word;\n\n\t      // FIXME: This line is a kludge to work around exception\n\t      // handlers written in C++, which don't yet use indirect\n\t      // dispatch.\n\t      if (catch_type == *(void **)\u0026java::lang::Class::class$)\n\t\tcatch_type = (jclass)catch_word;\n\n\t      if (_Jv_IsInstanceOf (xh-\u003evalue, catch_type))\n\t\t{\n\t\t  handler_switch_value = ar_filter;\n\t\t  saw_handler = true;\n\t\t  break;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      // Negative filter values are exception specifications,\n\t      // which Java does not use.\n\t      // ??? Perhaps better to make them an index into a table\n\t      // of null-terminated strings instead of playing games\n\t      // with Utf8Const+1 as above.\n\t      abort ();\n\t    }\n\n\t  if (ar_disp == 0)\n\t    break;\n\t  action_record = p + ar_disp;\n\t}\n    }\n\n  if (! saw_handler \u0026\u0026 ! saw_cleanup)\n    return _URC_CONTINUE_UNWIND;\n\n  if (actions \u0026 _UA_SEARCH_PHASE)\n    {\n      if (! saw_handler)\n\treturn _URC_CONTINUE_UNWIND;\n\n      // For domestic exceptions, we cache data from phase 1 for phase 2.\n      if (exception_class == __gcj_exception_class)\n        {\n          xh-\u003ehandlerSwitchValue = handler_switch_value;\n          xh-\u003elandingPad = landing_pad;\n\t}\n      return _URC_HANDLER_FOUND;\n    }\n\n install_context:\n  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n\t\t (_Unwind_Ptr) \u0026xh-\u003eunwindHeader);\n  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),\n\t\t handler_switch_value);\n  _Unwind_SetIP (context, landing_pad);\n  return _URC_INSTALL_CONTEXT;\n}","filepath":"libjava/exception.cc","line_number":183,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5226000":{"score":0.68154585,"function_name":"__cxa_begin_catch","code":"void *\n__cxa_begin_catch (void *exc_obj_in) throw()\n{\n  _Unwind_Exception *exceptionObject\n    = reinterpret_cast \u003c_Unwind_Exception *\u003e(exc_obj_in);\n  __cxa_eh_globals *globals = __cxa_get_globals ();\n  __cxa_exception *prev = globals-\u003ecaughtExceptions;\n  __cxa_exception *header = __get_exception_header_from_ue (exceptionObject);\n\n  // Foreign exceptions can't be stacked here.  If the exception stack is\n  // empty, then fine.  Otherwise we really have no choice but to terminate.\n  // Note that this use of \"header\" is a lie.  It's fine so long as we only\n  // examine header-\u003eunwindHeader though.\n  if (header-\u003eunwindHeader.exception_class != __gxx_exception_class)\n    {\n      if (prev != 0)\n\tstd::terminate ();\n\n      // Remember for end_catch and rethrow.\n      globals-\u003ecaughtExceptions = header;\n\n      // ??? No sensible value to return; we don't know what the \n      // object is, much less where it is in relation to the header.\n      return 0;\n    }\n\n  int count = header-\u003ehandlerCount;\n  if (count \u003c 0)\n    // This exception was rethrown from an immediately enclosing region.\n    count = -count + 1;\n  else\n    {\n      count += 1;\n      globals-\u003euncaughtExceptions -= 1;\n    }\n  header-\u003ehandlerCount = count;\n\n  if (header != prev)\n    {\n      header-\u003enextException = prev;\n      globals-\u003ecaughtExceptions = header;\n    }\n\n  return header-\u003eadjustedPtr;\n}","filepath":"libstdc++-v3/libsupc++/eh_catch.cc","line_number":37,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.1"},"5226112":{"score":0.6793668,"function_name":"__cxa_end_catch","code":"void\n__cxa_end_catch ()\n{\n  __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n  __cxa_exception *header = globals-\u003ecaughtExceptions;\n\n  // A rethrow of a foreign exception will be removed from the\n  // the exception stack immediately by __cxa_rethrow.\n  if (!header)\n    return;\n\n  // A foreign exception couldn't have been stacked (see above),\n  // so by definition processing must be complete.\n  if (header-\u003eunwindHeader.exception_class != __gxx_exception_class)\n    {\n      globals-\u003ecaughtExceptions = 0;\n      _Unwind_DeleteException (\u0026header-\u003eunwindHeader);\n      return;\n    }\n\n  int count = header-\u003ehandlerCount;\n  if (count \u003c 0)\n    {\n      // This exception was rethrown.  Decrement the (inverted) catch\n      // count and remove it from the chain when it reaches zero.\n      if (++count == 0)\n\t{\n\t  globals-\u003euncaughtExceptions += 1;\n\t  globals-\u003ecaughtExceptions = header-\u003enextException;\n\t}\n    }\n  else if (--count == 0)\n    {\n      // Handling for this exception is complete.  Destroy the object.\n      globals-\u003ecaughtExceptions = header-\u003enextException;\n      _Unwind_DeleteException (\u0026header-\u003eunwindHeader);\n      return;\n    }\n  else if (count \u003c 0)\n    // A bug in the exception handling library or compiler.\n    std::terminate ();\n\n  header-\u003ehandlerCount = count;\n}","filepath":"libstdc++-v3/libsupc++/eh_catch.cc","line_number":84,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.1"},"5226352":{"score":0.5600512,"function_name":"__cxxabiv1::__cxa_throw","code":"void\n__cxxabiv1::__cxa_throw (void *obj, std::type_info *tinfo,\n\t\t\t void (_GLIBCXX_CDTOR_CALLABI *dest) (void *))\n{\n  PROBE2 (throw, obj, tinfo);\n\n  __cxa_eh_globals *globals = __cxa_get_globals ();\n  globals-\u003euncaughtExceptions += 1;\n\n  // Definitely a primary.\n  __cxa_refcounted_exception *header\n    = __get_refcounted_exception_header_from_obj (obj);\n  header-\u003ereferenceCount = 1;\n  header-\u003eexc.exceptionType = tinfo;\n  header-\u003eexc.exceptionDestructor = dest;\n  header-\u003eexc.unexpectedHandler = std::get_unexpected ();\n  header-\u003eexc.terminateHandler = std::get_terminate ();\n  __GXX_INIT_PRIMARY_EXCEPTION_CLASS(header-\u003eexc.unwindHeader.exception_class);\n  header-\u003eexc.unwindHeader.exception_cleanup = __gxx_exception_cleanup;\n\n#ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n  _Unwind_SjLj_RaiseException (\u0026header-\u003eexc.unwindHeader);\n#else\n  _Unwind_RaiseException (\u0026header-\u003eexc.unwindHeader);\n#endif\n\n  // Some sort of unwinding error.  Note that terminate is a handler.\n  __cxa_begin_catch (\u0026header-\u003eexc.unwindHeader);\n  std::terminate ();\n}","filepath":"libstdc++-v3/libsupc++/eh_throw.cc","line_number":59,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5226464":{"score":0.52773476,"function_name":"__cxxabiv1::__cxa_rethrow","code":"void\n__cxxabiv1::__cxa_rethrow ()\n{\n  __cxa_eh_globals *globals = __cxa_get_globals ();\n  __cxa_exception *header = globals-\u003ecaughtExceptions;\n\n  globals-\u003euncaughtExceptions += 1;\n\n  // Watch for luser rethrowing with no active exception.\n  if (header)\n    {\n      // Tell __cxa_end_catch this is a rethrow.\n      if (!__is_gxx_exception_class(header-\u003eunwindHeader.exception_class))\n\tglobals-\u003ecaughtExceptions = 0;\n      else\n\theader-\u003ehandlerCount = -header-\u003ehandlerCount;\n\n#ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n      _Unwind_SjLj_Resume_or_Rethrow (\u0026header-\u003eunwindHeader);\n#else\n#if defined(_LIBUNWIND_STD_ABI)\n      _Unwind_RaiseException (\u0026header-\u003eunwindHeader);\n#else\n      _Unwind_Resume_or_Rethrow (\u0026header-\u003eunwindHeader);\n#endif\n#endif\n  \n      // Some sort of unwinding error.  Note that terminate is a handler.\n      __cxa_begin_catch (\u0026header-\u003eunwindHeader);\n    }\n  std::terminate ();\n}","filepath":"libstdc++-v3/libsupc++/eh_throw.cc","line_number":86,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5227712":{"score":0.5611937,"function_name":"__cxa_allocate_exception","code":"void *\n__cxa_allocate_exception(std::size_t thrown_size)\n{\n  void *ret;\n\n  thrown_size += sizeof (__cxa_exception);\n  ret = std::malloc (thrown_size);\n\n  if (! ret)\n    {\n#ifdef __GTHREADS\n#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n      static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n      __gthread_once (\u0026once, emergency_mutex_init);\n#endif\n      __gthread_mutex_lock (\u0026emergency_mutex);\n#endif\n\n      bitmask_type used = emergency_used;\n      unsigned int which = 0;\n\n      if (thrown_size \u003e EMERGENCY_OBJ_SIZE)\n\tgoto failed;\n      while (used \u0026 1)\n\t{\n\t  used \u003e\u003e= 1;\n\t  if (++which \u003e= EMERGENCY_OBJ_COUNT)\n\t    goto failed;\n\t}\n\n      emergency_used |= (bitmask_type)1 \u003c\u003c which;\n      ret = \u0026emergency_buffer[which][0];\n\n    failed:;\n#ifdef __GTHREADS\n      __gthread_mutex_unlock (\u0026emergency_mutex);\n#endif\n      if (!ret)\n\tstd::terminate ();\n    }\n\n  std::memset (ret, 0, sizeof (__cxa_exception));\n\n  return (void *)((char *)ret + sizeof (__cxa_exception));\n}","filepath":"libstdc++-v3/libsupc++/eh_alloc.cc","line_number":96,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.0.0"},"5227840":{"score":0.69187105,"function_name":"__cxa_free_exception","code":"void\n__cxa_free_exception(void *vptr)\n{\n  char *ptr = (char *) vptr;\n  if (ptr \u003e= \u0026emergency_buffer[0][0]\n      \u0026\u0026 ptr \u003c \u0026emergency_buffer[0][0] + sizeof (emergency_buffer))\n    {\n      unsigned int which\n\t= (unsigned)(ptr - \u0026emergency_buffer[0][0]) / EMERGENCY_OBJ_SIZE;\n\n#ifdef __GTHREADS\n      __gthread_mutex_lock (\u0026emergency_mutex);\n      emergency_used \u0026= ~((bitmask_type)1 \u003c\u003c which);\n      __gthread_mutex_unlock (\u0026emergency_mutex);\n#else\n      emergency_used \u0026= ~((bitmask_type)1 \u003c\u003c which);\n#endif\n    }\n  else\n    std::free (ptr - sizeof (__cxa_exception));\n}","filepath":"libstdc++-v3/libsupc++/eh_alloc.cc","line_number":143,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.0.0"},"5228352":{"score":0.8038093,"function_name":"__si_class_type_info::\n__do_dyncast","code":"bool __si_class_type_info::\n__do_dyncast (ptrdiff_t src2dst,\n              __sub_kind access_path,\n              const __class_type_info *dst_type,\n              const void *obj_ptr,\n              const __class_type_info *src_type,\n              const void *src_ptr,\n              __dyncast_result \u0026__restrict result) const\n{\n  if (*this == *dst_type)\n    {\n      result.dst_ptr = obj_ptr;\n      result.whole2dst = access_path;\n      if (src2dst \u003e= 0)\n        result.dst2src = adjust_pointer \u003cvoid\u003e (obj_ptr, src2dst) == src_ptr\n              ? __contained_public : __not_contained;\n      else if (src2dst == -2)\n        result.dst2src = __not_contained;\n      return false;\n    }\n  if (obj_ptr == src_ptr \u0026\u0026 *this == *src_type)\n    {\n      // The src object we started from. Indicate how we are accessible from\n      // the most derived object.\n      result.whole2src = access_path;\n      return false;\n    }\n  return __base_type-\u003e__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n                             src_type, src_ptr, result);\n}","filepath":"libstdc++-v3/libsupc++/si_class_type_info.cc","line_number":43,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5228672":{"score":0.71817434,"function_name":"__si_class_type_info::\n__do_find_public_src","code":"__class_type_info::__sub_kind __si_class_type_info::\n__do_find_public_src (ptrdiff_t src2dst,\n                      const void *obj_ptr,\n                      const __class_type_info *src_type,\n                      const void *src_ptr) const\n{\n  if (src_ptr == obj_ptr \u0026\u0026 *this == *src_type)\n    return __contained_public;\n  return __base_type-\u003e__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n}","filepath":"libstdc++-v3/libsupc++/si_class_type_info.cc","line_number":32,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5228800":{"score":0.6203318,"function_name":"__si_class_type_info::\n__do_upcast","code":"bool __si_class_type_info::\n__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n             __upcast_result \u0026__restrict result) const\n{\n  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n    return true;\n  \n  return __base_type-\u003e__do_upcast (dst, obj_ptr, result);\n}","filepath":"libstdc++-v3/libsupc++/si_class_type_info.cc","line_number":74,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5228896":{"score":0.7583214,"function_name":"_Rb_tree_decrement","code":"_Rb_tree_node_base*\n  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ()\n  {\n    if (__x-\u003e_M_color == _S_red \n        \u0026\u0026 __x-\u003e_M_parent-\u003e_M_parent == __x)\n      __x = __x-\u003e_M_right;\n    else if (__x-\u003e_M_left != 0) \n      {\n        _Rb_tree_node_base* __y = __x-\u003e_M_left;\n        while (__y-\u003e_M_right != 0)\n          __y = __y-\u003e_M_right;\n        __x = __y;\n      }\n    else \n      {\n        _Rb_tree_node_base* __y = __x-\u003e_M_parent;\n        while (__x == __y-\u003e_M_left) \n          {\n            __x = __y;\n            __y = __y-\u003e_M_parent;\n          }\n        __x = __y;\n      }\n    return __x;\n  }","filepath":"libstdc++-v3/src/tree.cc","line_number":88,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5228992":{"score":0.8103364,"function_name":"_Rb_tree_increment","code":"_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  _Rb_tree_node_base*\n  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ()\n  {\n    if (__x-\u003e_M_right != 0) \n      {\n        __x = __x-\u003e_M_right;\n        while (__x-\u003e_M_left != 0)\n          __x = __x-\u003e_M_left;\n      }\n    else \n      {\n        _Rb_tree_node_base* __y = __x-\u003e_M_parent;\n        while (__x == __y-\u003e_M_right) \n          {\n            __x = __y;\n            __y = __y-\u003e_M_parent;\n          }\n        if (__x-\u003e_M_right != __y)\n          __x = __y;\n      }\n    return __x;\n  }","filepath":"libstdc++-v3/src/tree.cc","line_number":57,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5229216":{"score":0.84993035,"function_name":"local_Rb_tree_rotate_left","code":"static void \n  local_Rb_tree_rotate_left(_Rb_tree_node_base* const __x, \n\t\t             _Rb_tree_node_base*\u0026 __root)\n  {\n    _Rb_tree_node_base* const __y = __x-\u003e_M_right;\n\n    __x-\u003e_M_right = __y-\u003e_M_left;\n    if (__y-\u003e_M_left !=0)\n      __y-\u003e_M_left-\u003e_M_parent = __x;\n    __y-\u003e_M_parent = __x-\u003e_M_parent;\n    \n    if (__x == __root)\n      __root = __y;\n    else if (__x == __x-\u003e_M_parent-\u003e_M_left)\n      __x-\u003e_M_parent-\u003e_M_left = __y;\n    else\n      __x-\u003e_M_parent-\u003e_M_right = __y;\n    __y-\u003e_M_left = __x;\n    __x-\u003e_M_parent = __y;\n  }","filepath":"libstdc++-v3/src/tree.cc","line_number":120,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5229312":{"score":0.81955117,"function_name":"_Rb_tree_insert_and_rebalance","code":"void \n  _Rb_tree_insert_and_rebalance(const bool          __insert_left,\n                                _Rb_tree_node_base* __x,\n                                _Rb_tree_node_base* __p,\n                                _Rb_tree_node_base\u0026 __header) throw ()\n  {\n    _Rb_tree_node_base *\u0026 __root = __header._M_parent;\n\n    // Initialize fields in new node to insert.\n    __x-\u003e_M_parent = __p;\n    __x-\u003e_M_left = 0;\n    __x-\u003e_M_right = 0;\n    __x-\u003e_M_color = _S_red;\n\n    // Insert.\n    // Make new node child of parent and maintain root, leftmost and\n    // rightmost nodes.\n    // N.B. First node is always inserted left.\n    if (__insert_left)\n      {\n        __p-\u003e_M_left = __x; // also makes leftmost = __x when __p == \u0026__header\n\n        if (__p == \u0026__header)\n        {\n            __header._M_parent = __x;\n            __header._M_right = __x;\n        }\n        else if (__p == __header._M_left)\n          __header._M_left = __x; // maintain leftmost pointing to min node\n      }\n    else\n      {\n        __p-\u003e_M_right = __x;\n\n        if (__p == __header._M_right)\n          __header._M_right = __x; // maintain rightmost pointing to max node\n      }\n    // Rebalance.\n    while (__x != __root \n\t   \u0026\u0026 __x-\u003e_M_parent-\u003e_M_color == _S_red) \n      {\n\t_Rb_tree_node_base* const __xpp = __x-\u003e_M_parent-\u003e_M_parent;\n\n\tif (__x-\u003e_M_parent == __xpp-\u003e_M_left) \n\t  {\n\t    _Rb_tree_node_base* const __y = __xpp-\u003e_M_right;\n\t    if (__y \u0026\u0026 __y-\u003e_M_color == _S_red) \n\t      {\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__y-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\t__x = __xpp;\n\t      }\n\t    else \n\t      {\n\t\tif (__x == __x-\u003e_M_parent-\u003e_M_right) \n\t\t  {\n\t\t    __x = __x-\u003e_M_parent;\n\t\t    local_Rb_tree_rotate_left(__x, __root);\n\t\t  }\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\tlocal_Rb_tree_rotate_right(__xpp, __root);\n\t      }\n\t  }\n\telse \n\t  {\n\t    _Rb_tree_node_base* const __y = __xpp-\u003e_M_left;\n\t    if (__y \u0026\u0026 __y-\u003e_M_color == _S_red) \n\t      {\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__y-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\t__x = __xpp;\n\t      }\n\t    else \n\t      {\n\t\tif (__x == __x-\u003e_M_parent-\u003e_M_left) \n\t\t  {\n\t\t    __x = __x-\u003e_M_parent;\n\t\t    local_Rb_tree_rotate_right(__x, __root);\n\t\t  }\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\tlocal_Rb_tree_rotate_left(__xpp, __root);\n\t      }\n\t  }\n      }\n    __root-\u003e_M_color = _S_black;\n  }","filepath":"libstdc++-v3/src/tree.cc","line_number":182,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231424":{"score":0.83333635,"function_name":"_Rb_tree_black_count","code":"unsigned int\n  _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n                       const _Rb_tree_node_base* __root) throw ()\n  {\n    if (__node == 0)\n      return 0;\n    unsigned int __sum = 0;\n    do \n      {\n\tif (__node-\u003e_M_color == _S_black) \n\t  ++__sum;\n\tif (__node == __root) \n\t  break;\n\t__node = __node-\u003e_M_parent;\n      } \n    while (1);\n    return __sum;\n  }","filepath":"libstdc++-v3/src/tree.cc","line_number":434,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231472":{"score":0.85598814,"function_name":"_List_node_base::swap","code":"_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n    void\n    _List_node_base::swap(_List_node_base\u0026 __x, _List_node_base\u0026 __y) throw()\n    {\n      if ( __x._M_next != \u0026__x )\n\t{\n\t  if ( __y._M_next != \u0026__y )\n\t    {\n\t      // Both __x and __y are not empty.\n\t      std::swap(__x._M_next,__y._M_next);\n\t      std::swap(__x._M_prev,__y._M_prev);\n\t      __x._M_next-\u003e_M_prev = __x._M_prev-\u003e_M_next = \u0026__x;\n\t      __y._M_next-\u003e_M_prev = __y._M_prev-\u003e_M_next = \u0026__y;\n\t    }\n\t  else\n\t    {\n\t      // __x is not empty, __y is empty.\n\t      __y._M_next = __x._M_next;\n\t      __y._M_prev = __x._M_prev;\n\t      __y._M_next-\u003e_M_prev = __y._M_prev-\u003e_M_next = \u0026__y;\n\t      __x._M_next = __x._M_prev = \u0026__x;\n\t    }\n\t}\n      else if ( __y._M_next != \u0026__y )\n\t{\n\t  // __x is empty, __y is not empty.\n\t  __x._M_next = __y._M_next;\n\t  __x._M_prev = __y._M_prev;\n\t  __x._M_next-\u003e_M_prev = __x._M_prev-\u003e_M_next = \u0026__x;\n\t  __y._M_next = __y._M_prev = \u0026__y;\n\t}\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":57,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231616":{"score":0.8811842,"function_name":"_List_node_base::_M_transfer","code":"void\n    _List_node_base::_M_transfer(_List_node_base * const __first,\n\t\t\t\t _List_node_base * const __last) throw()\n    {\n      if (this != __last)\n\t{\n\t  // Remove [first, last) from its old position.\n\t  __last-\u003e_M_prev-\u003e_M_next  = this;\n\t  __first-\u003e_M_prev-\u003e_M_next = __last;\n\t  this-\u003e_M_prev-\u003e_M_next    = __first;\n\n\t  // Splice [first, last) into its new position.\n\t  _List_node_base* const __tmp = this-\u003e_M_prev;\n\t  this-\u003e_M_prev                = __last-\u003e_M_prev;\n\t  __last-\u003e_M_prev              = __first-\u003e_M_prev;\n\t  __first-\u003e_M_prev             = __tmp;\n\t}\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":91,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231664":{"score":0.84922385,"function_name":"_List_node_base::_M_reverse","code":"void\n    _List_node_base::_M_reverse() throw()\n    {\n      _List_node_base* __tmp = this;\n      do\n\t{\n\t  std::swap(__tmp-\u003e_M_next, __tmp-\u003e_M_prev);\n\n\t  // Old next node is now prev.\n\t  __tmp = __tmp-\u003e_M_prev;\n\t}\n      while (__tmp != this);\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":110,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231696":{"score":0.7502545,"function_name":"_List_node_base::_M_hook","code":"void\n    _List_node_base::_M_hook(_List_node_base* const __position) throw()\n    {\n      this-\u003e_M_next = __position;\n      this-\u003e_M_prev = __position-\u003e_M_prev;\n      __position-\u003e_M_prev-\u003e_M_next = this;\n      __position-\u003e_M_prev = this;\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":124,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231728":{"score":0.8445474,"function_name":"_List_node_base::_M_unhook","code":"void\n    _List_node_base::_M_unhook() throw()\n    {\n      _List_node_base* const __next_node = this-\u003e_M_next;\n      _List_node_base* const __prev_node = this-\u003e_M_prev;\n      __prev_node-\u003e_M_next = __next_node;\n      __next_node-\u003e_M_prev = __prev_node;\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":133,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231744":{"score":0.7232274,"function_name":"system_clock::now","code":"system_clock::time_point\n    system_clock::now() throw ()\n    {\n#ifdef _GLIBCXX_USE_CLOCK_REALTIME\n      timespec tp;\n      // -EINVAL, -EFAULT\n      clock_gettime(CLOCK_REALTIME, \u0026tp);\n      return time_point(duration(chrono::seconds(tp.tv_sec)\n\t\t\t\t + chrono::nanoseconds(tp.tv_nsec)));\n#elif defined(_GLIBCXX_USE_GETTIMEOFDAY)\n      timeval tv;\n      // EINVAL, EFAULT\n      gettimeofday(\u0026tv, NULL);\n      return time_point(duration(chrono::seconds(tv.tv_sec)\n\t\t\t\t + chrono::microseconds(tv.tv_usec)));\n#else\n      std::time_t __sec = std::time(0);\n      return system_clock::from_time_t(__sec);\n#endif\n    }","filepath":"libstdc++-v3/src/chrono.cc","line_number":42,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5231824":{"score":0.6776695,"function_name":"monotonic_clock::now","code":"monotonic_clock::time_point\n    monotonic_clock::now()\n    {\n      timespec tp;\n      // -EINVAL, -EFAULT\n      clock_gettime(CLOCK_MONOTONIC, \u0026tp);\n      return time_point(duration(chrono::seconds(tp.tv_sec)\n\t\t\t\t + chrono::nanoseconds(tp.tv_nsec)));\n    }","filepath":"libstdc++-v3/src/chrono.cc","line_number":66,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5232160":{"score":0.5992901,"function_name":"clone","code":"class pass_tsan : public gimple_opt_pass\n{\npublic:\n  pass_tsan (gcc::context *ctxt)\n    : gimple_opt_pass (pass_data_tsan, ctxt)\n  {}\n\n  /* opt_pass methods: */\n  opt_pass * clone () { return new pass_tsan (m_ctxt); }\n  virtual bool gate (function *)\n{\n  return sanitize_flags_p (SANITIZE_THREAD);\n}\n\n  virtual unsigned int execute (function *) { return tsan_pass (); }\n\n}","filepath":"gcc/tsan.c","line_number":891,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-9"},"5232640":{"score":0.5935876,"function_name":"__throw_out_of_range_fmt","code":"void\n  __throw_out_of_range_fmt(const char* __fmt, ...)\n  {\n#if _GLIBCXX_HOSTED \u0026\u0026 _GLIBCXX_VERBOSE \u0026\u0026 __cpp_exceptions\n    const size_t __len = __builtin_strlen(__fmt);\n    // We expect at most 2 numbers, and 1 short string. The additional\n    // 512 bytes should provide more than enough space for expansion.\n    const size_t __alloca_size = __len + 512;\n    char *const __s = static_cast\u003cchar*\u003e(__builtin_alloca(__alloca_size));\n    va_list __ap;\n\n    va_start(__ap, __fmt);\n    __gnu_cxx::__snprintf_lite(__s, __alloca_size, _(__fmt), __ap);\n    throw out_of_range(__s);\n    va_end(__ap);  // Not reached.\n#else\n    __throw_out_of_range(__fmt);\n#endif\n  }","filepath":"libstdc++-v3/src/c++11/functexcept.cc","line_number":88,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5233664":{"score":0.5597505,"function_name":"replace_func_exit","code":"static void\nreplace_func_exit (gimple *stmt)\n{\n  tree builtin_decl = builtin_decl_implicit (BUILT_IN_TSAN_FUNC_EXIT);\n  gimple *g = gimple_build_call (builtin_decl, 0);\n  gimple_set_location (g, cfun-\u003efunction_end_locus);\n  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n  gsi_replace (\u0026gsi, g, true);\n}","filepath":"gcc/tsan.c","line_number":737,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-9"},"5234384":{"score":0.8408429,"function_name":"message","code":"virtual std::string message(int __ec) const\n    {\n      std::string __msg;\n      switch (std::future_errc(__ec))\n      {\n      case std::future_errc::broken_promise:\n          __msg = \"Broken promise\";\n          break;\n      case std::future_errc::future_already_retrieved:\n          __msg = \"Future already retrieved\";\n          break;\n      case std::future_errc::promise_already_satisfied:\n          __msg = \"Promise already satisfied\";\n          break;\n      case std::future_errc::no_state:\n          __msg = \"No associated state\";\n          break;\n      default:\n          __msg = \"Unknown error\";\n          break;\n      }\n      return __msg;\n    }","filepath":"libstdc++-v3/src/c++11/future.cc","line_number":35,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5234640":{"score":0.5645551,"function_name":"locale::facet::_S_get_c_locale","code":"__c_locale\n  locale::facet::_S_get_c_locale()\n  {\n#ifdef __GHTREADS\n    if (__gthread_active_p())\n      __gthread_once(\u0026_S_once, _S_initialize_once);\n    else\n#endif\n      {\n\tif (!_S_c_locale)\n\t  _S_initialize_once();\n      }\n    return _S_c_locale;\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":206,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5235936":{"score":0.61825,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_construct","code":"void\n      __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_construct(_InIterator __beg, _InIterator __end,\n\t\t   std::forward_iterator_tag)\n      {\n\t// NB: Not required, but considered best practice.\n\tif (__is_null_pointer(__beg) \u0026\u0026 __beg != __end)\n\t  std::__throw_logic_error(__N(\"__sso_string_base::\"\n\t\t\t\t       \"_M_construct null not valid\"));\n\n\tsize_type __dnew = static_cast\u003csize_type\u003e(std::distance(__beg, __end));\n\n\tif (__dnew \u003e size_type(_S_local_capacity))\n\t  {\n\t    _M_data(_M_create(__dnew, size_type(0)));\n\t    _M_capacity(__dnew);\n\t  }\n\n\t// Check for out_of_range and length_error exceptions.\n\t__try\n\t  { this-\u003e_S_copy_chars(_M_data(), __beg, __end); }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":434,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5236672":{"score":0.68413365,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    __sso_string_base","code":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    __sso_string_base(__sso_string_base\u0026\u0026 __rcs)\n    : _M_dataplus(__rcs._M_get_allocator(), _M_local_data)\n    {\n      if (__rcs._M_is_local())\n\t{\n\t  if (__rcs._M_length())\n\t    traits_type::copy(_M_local_data, __rcs._M_local_data,\n\t\t\t      _S_local_capacity + 1);\n\t}\n      else\n\t{\n\t  _M_data(__rcs._M_data());\n\t  _M_capacity(__rcs._M_allocated_capacity);\n\t}\n\n      _M_length(__rcs._M_length());\n      __rcs._M_length(0);\n      __rcs._M_data(__rcs._M_local_data);\n    }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":349,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5236912":{"score":0.62724876,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_create","code":"_CharT*\n    __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_create(size_type\u0026 __capacity, size_type __old_capacity)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 83.  String::npos vs. string::max_size()\n      if (__capacity \u003e _M_max_size())\n\tstd::__throw_length_error(__N(\"__sso_string_base::_M_create\"));\n\n      // The below implements an exponential growth policy, necessary to\n      // meet amortized linear time requirements of the library: see\n      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n      if (__capacity \u003e __old_capacity \u0026\u0026 __capacity \u003c 2 * __old_capacity)\n\t{\n\t  __capacity = 2 * __old_capacity;\n\t  // Never allocate a string bigger than max_size.\n\t  if (__capacity \u003e _M_max_size())\n\t    __capacity = _M_max_size();\n\t}\n\n      // NB: Need an array of char_type[__capacity], plus a terminating\n      // null char_type() element.\n      return _M_get_allocator().allocate(__capacity + 1);\n    }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":310,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5237072":{"score":0.7606778,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_construct","code":"void\n    __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_construct(size_type __n, _CharT __c)\n    {\n      if (__n \u003e size_type(_S_local_capacity))\n\t{\n\t  _M_data(_M_create(__n, size_type(0)));\n\t  _M_capacity(__n);\n\t}\n\n      if (__n)\n\tthis-\u003e_S_assign(_M_data(), __n, __c);\n\n      _M_set_length(__n);\n    }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":465,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5237648":{"score":0.831076,"function_name":"_S_compare","code":"_GLIBCXX20_CONSTEXPR\n      static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d \u003e __gnu_cxx::__numeric_traits\u003cint\u003e::__max)\n\t  return __gnu_cxx::__numeric_traits\u003cint\u003e::__max;\n\telse if (__d \u003c __gnu_cxx::__numeric_traits\u003cint\u003e::__min)\n\t  return __gnu_cxx::__numeric_traits\u003cint\u003e::__min;\n\telse\n\t  return int(__d);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":479,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5237696":{"score":0.7428063,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_assign","code":"void\n    __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_assign(const __sso_string_base\u0026 __rcs)\n    {\n      if (this != \u0026__rcs)\n\t{\n\t  const size_type __rsize = __rcs._M_length();\n\t  const size_type __capacity = _M_capacity();\n\n\t  if (__rsize \u003e __capacity)\n\t    {\n\t      size_type __new_capacity = __rsize;\n\t      _CharT* __tmp = _M_create(__new_capacity, __capacity);\n\t      _M_dispose();\n\t      _M_data(__tmp);\n\t      _M_capacity(__new_capacity);\n\t    }\n\n\t  if (__rsize)\n\t    this-\u003e_S_copy(_M_data(), __rcs._M_data(), __rsize);\n\n\t  _M_set_length(__rsize);\n\t}\n    }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":482,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5237936":{"score":0.8292528,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_mutate","code":"void\n    __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n\t      size_type __len2)\n    {\n      const size_type __how_much = _M_length() - __pos - __len1;\n      \n      size_type __new_capacity = _M_length() + __len2 - __len1;\n      _CharT* __r = _M_create(__new_capacity, _M_capacity());\n\n      if (__pos)\n\tthis-\u003e_S_copy(__r, _M_data(), __pos);\n      if (__s \u0026\u0026 __len2)\n\tthis-\u003e_S_copy(__r + __pos, __s, __len2);\n      if (__how_much)\n\tthis-\u003e_S_copy(__r + __pos + __len2,\n\t\t      _M_data() + __pos + __len1, __how_much);\n      \n      _M_dispose();\n      _M_data(__r);\n      _M_capacity(__new_capacity);\n    }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":538,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5238304":{"score":0.7396618,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_erase","code":"void\n    __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_erase(size_type __pos, size_type __n)\n    {\n      const size_type __how_much = _M_length() - __pos - __n;\n\n      if (__how_much \u0026\u0026 __n)\n\tthis-\u003e_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);\n\n      _M_set_length(_M_length() - __n);\n    }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":562,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5238912":{"score":0.74609214,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_reserve","code":"void\n    __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_reserve(size_type __res)\n    {\n      // Make sure we don't shrink below the current size.\n      if (__res \u003c _M_length())\n\t__res = _M_length();\n\n      const size_type __capacity = _M_capacity();\n      if (__res != __capacity)\n\t{\n\t  if (__res \u003e __capacity\n\t      || __res \u003e size_type(_S_local_capacity))\n\t    {\n\t      _CharT* __tmp = _M_create(__res, __capacity);\n\t      this-\u003e_S_copy(__tmp, _M_data(), _M_length() + 1);\n\t      _M_dispose();\n\t      _M_data(__tmp);\n\t      _M_capacity(__res);\n\t    }\n\t  else if (!_M_is_local())\n\t    {\n\t      this-\u003e_S_copy(_M_local_data, _M_data(), _M_length() + 1);\n\t      _M_destroy(__capacity);\n\t      _M_data(_M_local_data);\n\t    }\n\t}\n    }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":508,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.1"},"5239456":{"score":0.6604205,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\n    operator+","code":"_GLIBCXX20_CONSTEXPR\n    inline basic_string\u003c_CharT, _Traits, _Alloc\u003e\n    operator+(const basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026 __lhs, _CharT __rhs)\n    {\n      typedef basic_string\u003c_CharT, _Traits, _Alloc\u003e\t__string_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n      __string_type __str(__lhs);\n      __str.append(__size_type(1), __rhs);\n      return __str;\n    }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":3487,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5239568":{"score":0.7367005,"function_name":"push_back","code":"_GLIBCXX20_CONSTEXPR\n      void\n      push_back(_CharT __c)\n      {\n\tconst size_type __size = this-\u003esize();\n\tif (__size + 1 \u003e this-\u003ecapacity())\n\t  this-\u003e_M_mutate(__size, size_type(0), 0, size_type(1));\n\ttraits_type::assign(this-\u003e_M_data()[__size], __c);\n\tthis-\u003e_M_set_length(__size + 1);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1522,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5239888":{"score":0.84285235,"function_name":"_M_replace_aux","code":"basic_string\u0026\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c)\n      {\n\tif (this-\u003emax_size() - (this-\u003esize() - __n1) \u003c __n2)\n\t  __throw_length_error(__N(\"basic_string::_M_replace_aux\"));\n\t_M_mutate(__pos1, __n1, __n2);\n\tif (__n2 == 1)\n\t  _M_data()[__pos1] = __c;\n\telse if (__n2)\n\t  traits_type::assign(_M_data() + __pos1, __n2, __c);\n\treturn *this;\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1354,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.3"},"5240560":{"score":0.76569116,"function_name":"replace","code":"basic_string\u0026 \n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      { \n\tconst size_type __size = this-\u003esize();\n \tif (__pos \u003e __size)\n\t  __throw_out_of_range(\"basic_string::replace\");\n\tconst bool __testn1 = __n1 \u003c __size - __pos;\n\tconst size_type __foldn1 = __testn1 ? __n1 : __size - __pos;\n\tif (__size - __foldn1 \u003e this-\u003emax_size() - __n2)\n\t  __throw_length_error(\"basic_string::replace\");\n\tif (_M_rep()-\u003e_M_is_shared() || less\u003cconst _CharT*\u003e()(__s, _M_data())\n\t    || less\u003cconst _CharT*\u003e()(_M_data() + __size, __s))\n\t  return _M_replace_safe(_M_ibegin() + __pos,\n\t\t\t\t _M_ibegin() + __pos + __foldn1, __s, __s + __n2);\t\n\telse return this-\u003ereplace(_M_check(__pos), _M_fold(__pos, __n1),\n\t\t\t\t  __s, __s + __n2); \n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":638,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.1.0"},"5241264":{"score":0.6780585,"function_name":"_If_sv\u003c_Tp, basic_string\u0026\u003e\n\tassign","code":"_GLIBCXX20_CONSTEXPR\n\t_If_sv\u003c_Tp, basic_string\u0026\u003e\n\tassign(const _Tp\u0026 __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return _M_replace(size_type(0), this-\u003esize(),\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos, \"basic_string::assign\"),\n\t      std::__sv_limit(__sv.size(), __pos, __n));\n\t}","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1719,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5241488":{"score":0.7233173,"function_name":"replace","code":"basic_string\u0026 \n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      { \n\tconst size_type __size = this-\u003esize();\n \tif (__pos \u003e __size)\n\t  __throw_out_of_range(\"basic_string::replace\");\n\tif (__size - __n1 \u003e this-\u003emax_size() - __n2)\n\t  __throw_length_error(\"basic_string::replace\");\n\tconst bool __testn1 = __n1 \u003c __size - __pos;\n\tconst size_type __foldn1 = __testn1 ? __n1 : __size - __pos;\n\tif (_M_rep()-\u003e_M_is_shared() || less\u003cconst _CharT*\u003e()(__s, _M_data())\n\t    || less\u003cconst _CharT*\u003e()(_M_data() + __size, __s))\n\t  return _M_replace_safe(_M_ibegin() + __pos,\n\t\t\t\t _M_ibegin() + __pos + __foldn1, __s, __s + __n2);\t\n\telse return this-\u003ereplace(_M_check(__pos), _M_fold(__pos, __n1),\n\t\t\t\t  __s, __s + __n2); \n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":635,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-3.0.97"},"5241776":{"score":0.7125778,"function_name":"_If_sv\u003c_Tp, int\u003e\n\tcompare","code":"_GLIBCXX20_CONSTEXPR\n\t_If_sv\u003c_Tp, int\u003e\n\tcompare(size_type __pos, size_type __n, const _Tp\u0026 __svt) const\n\tnoexcept(is_same\u003c_Tp, __sv_type\u003e::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this).substr(__pos, __n).compare(__sv);\n\t}","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":3186,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5241888":{"score":0.7177282,"function_name":"insert","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003ereplace(__pos, size_type(0), __s,\n\t\t\t     traits_type::length(__s));\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1923,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5242288":{"score":0.76391447,"function_name":"replace","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t \u0026\u0026 __i2 \u003c= end());\n\treturn this-\u003ereplace(__i1 - begin(), __i2 - __i1, __s, __n);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2256,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5242416":{"score":0.7399796,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_replace_dispatch","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n      basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n\t\t\t  _InputIterator __k2, __false_type)\n      {\n\tconst basic_string __s(__k1, __k2);\n\tconst size_type __n1 = __i2 - __i1;\n\t_M_check_length(__n1, __s.size(), \"basic_string::_M_replace_dispatch\");\n\treturn _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),\n\t\t\t       __s.size());\n      }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3583,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5242576":{"score":0.662226,"function_name":"replace","code":"basic_string\u0026\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      {\n\t__glibcxx_requires_string_len(__s, __n2);\n\treturn _M_replace(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t  _M_limit(__pos, __n1), __s, __n2);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1682,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.4.0"},"5242720":{"score":0.7473519,"function_name":"compare","code":"_If_sv\u003c_Tp, int\u003e\n\tcompare(size_type __pos1, size_type __n1, const _Tp\u0026 __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same\u003c_Tp, __sv_type\u003e::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":2824,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5243248":{"score":0.7634093,"function_name":"append","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\tconst size_type __n = traits_type::length(__s);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1430,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5243328":{"score":0.6295129,"function_name":"assign","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn _M_replace(size_type(0), this-\u003esize(), __s,\n\t\t\t  traits_type::length(__s));\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1642,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5243408":{"score":0.73052907,"function_name":"append","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      append(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1416,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5245648":{"score":0.69142777,"function_name":"compare","code":"int\n      compare(const basic_string\u0026 __str) const\n      {\n\tconst size_type __size = this-\u003esize();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = _S_compare(__size, __osize);\n\treturn __r;\n      }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":2761,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5246592":{"score":0.66635287,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\n    operator+","code":"_GLIBCXX20_CONSTEXPR\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e\n    operator+(const basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026 __lhs,\n\t      const basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026 __rhs)\n    {\n      basic_string\u003c_CharT, _Traits, _Alloc\u003e __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":3430,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5247712":{"score":0.5972196,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n      _S_construct","code":"_CharT*\n      basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc\u0026 __a,\n\t\t   forward_iterator_tag)\n      {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\tif (__beg == __end \u0026\u0026 __a == _Alloc())\n\t  return _S_empty_rep()._M_refdata();\n#endif\n\t// NB: Not required, but considered best practice.\n\tif (__gnu_cxx::__is_null_pointer(__beg) \u0026\u0026 __beg != __end)\n\t  __throw_logic_error(__N(\"basic_string::_S_construct null not valid\"));\n\n\tconst size_type __dnew = static_cast\u003csize_type\u003e(std::distance(__beg,\n\t\t\t\t\t\t\t\t      __end));\n\t// Check for out_of_range and length_error exceptions.\n\t_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);\n\t__try\n\t  { _S_copy_chars(__r-\u003e_M_refdata(), __beg, __end); }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3080,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5248016":{"score":0.69033444,"function_name":"basic_string","code":"_GLIBCXX20_CONSTEXPR\n      basic_string(const basic_string\u0026 __str, size_type __pos,\n\t\t   size_type __n, const _Alloc\u0026 __a)\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start\n\t  = __str._M_data() + __str._M_check(__pos, \"string::string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, __n),\n\t\t     std::forward_iterator_tag());\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":591,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5248144":{"score":0.69783145,"function_name":"basic_string","code":"_GLIBCXX20_CONSTEXPR\n      basic_string(const _CharT* __s, const _Alloc\u0026 __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\t// NB: Not required, but considered best practice.\n\tif (__s == 0)\n\t  std::__throw_logic_error(__N(\"basic_string: \"\n\t\t\t\t       \"construction from null is not valid\"));\n\tconst _CharT* __end = __s + traits_type::length(__s);\n\t_M_construct(__s, __end, forward_iterator_tag());\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":633,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5249440":{"score":0.54969287,"function_name":"thread::_M_start_thread","code":"void\n  thread::_M_start_thread(__shared_base_type __b)\n  {\n    __b-\u003e_M_this_ptr = __b;\n    int __e = __gthread_create(\u0026_M_id._M_thread,\n\t\t\t       \u0026execute_native_thread_routine, __b.get());\n    if (__e)\n    {\n      __b-\u003e_M_this_ptr.reset();\n      __throw_system_error(__e);\n    }\n  }","filepath":"libstdc++-v3/src/thread.cc","line_number":83,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5249728":{"score":0.63338155,"function_name":"thread::_M_start_thread","code":"void\n  thread::_M_start_thread(__shared_base_type __b)\n  {\n    if (!__gthread_active_p())\n#if __cpp_exceptions\n      throw system_error(make_error_code(errc::operation_not_permitted),\n\t\t\t \"Enable multithreading to use std::thread\");\n#else\n      __throw_system_error(int(errc::operation_not_permitted));\n#endif\n\n    _M_start_thread(__b, nullptr);\n  }","filepath":"libstdc++-v3/src/c++11/thread.cc","line_number":129,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5255504":{"score":0.5458675,"function_name":"std::rethrow_exception","code":"void\nstd::rethrow_exception(std::exception_ptr ep)\n{\n  void *obj = ep._M_get();\n  __cxa_refcounted_exception *eh\n    = __get_refcounted_exception_header_from_obj (obj);\n\n  __cxa_dependent_exception *dep = __cxa_allocate_dependent_exception ();\n  dep-\u003eprimaryException = obj;\n  __atomic_add_fetch (\u0026eh-\u003ereferenceCount, 1,  __ATOMIC_ACQ_REL);\n\n  dep-\u003eunexpectedHandler = get_unexpected ();\n  dep-\u003eterminateHandler = get_terminate ();\n  __GXX_INIT_DEPENDENT_EXCEPTION_CLASS(dep-\u003eunwindHeader.exception_class);\n  dep-\u003eunwindHeader.exception_cleanup = __gxx_dependent_exception_cleanup;\n\n  __cxa_eh_globals *globals = __cxa_get_globals ();\n  globals-\u003euncaughtExceptions += 1;\n\n#ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n  _Unwind_SjLj_RaiseException (\u0026dep-\u003eunwindHeader);\n#else\n  _Unwind_RaiseException (\u0026dep-\u003eunwindHeader);\n#endif\n\n  // Some sort of unwinding error.  Note that terminate is a handler.\n  __cxa_begin_catch (\u0026dep-\u003eunwindHeader);\n  std::terminate();\n}","filepath":"libstdc++-v3/libsupc++/eh_ptr.cc","line_number":232,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-5.3.0"},"5255616":{"score":0.90889144,"function_name":"__verbose_terminate_handler","code":"void __verbose_terminate_handler()\n  {\n    static bool terminating;\n    if (terminating)\n      {\n\tfputs(\"terminate called recursively\\n\", stderr);\n\tabort ();\n      }\n    terminating = true;\n\n    // Make sure there was an exception; terminate is also called for an\n    // attempt to rethrow when there is no suitable exception.\n    type_info *t = __cxa_current_exception_type();\n    if (t)\n      {\n\t// Note that \"name\" is the mangled name.\n\tchar const *name = t-\u003ename();\n\t{\n\t  int status = -1;\n\t  char *dem = 0;\n\t  \n\t  dem = __cxa_demangle(name, 0, 0, \u0026status);\n\n\t  fputs(\"terminate called after throwing an instance of '\", stderr);\n\t  if (status == 0)\n\t    fputs(dem, stderr);\n\t  else\n\t    fputs(name, stderr);\n\t  fputs(\"'\\n\", stderr);\n\n\t  if (status == 0)\n\t    free(dem);\n\t}\n\n\t// If the exception is derived from std::exception, we can\n\t// give more information.\n\ttry { __throw_exception_again; }\n#ifdef __EXCEPTIONS\n\tcatch (exception \u0026exc)\n\t  {\n\t    char const *w = exc.what();\n\t    fputs(\"  what():  \", stderr);\n\t    fputs(w, stderr);\n\t    fputs(\"\\n\", stderr);\n          }\n#endif\n\tcatch (...) { }\n      }\n    else\n      fputs(\"terminate called without an active exception\\n\", stderr);\n    \n    abort();\n  }","filepath":"libstdc++-v3/libsupc++/vterminate.cc","line_number":42,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5256048":{"score":0.5205971,"function_name":"_S_initialize_once","code":"static void\n      _S_initialize_once()\n      { \n\tstatic bool __init;\n\tif (__builtin_expect(__init == false, false))\n\t  {\n\t    if (__gthread_active_p())\n\t      {\n\t\t// On some platforms, __gthread_once_t is an aggregate.\n\t\tstatic __gthread_once_t __once = __GTHREAD_ONCE_INIT;\n\t\t__gthread_once(\u0026__once, _S_initialize);\n\t      }\n\n\t    // Double check initialization. May be necessary on some\n\t    // systems for proper construction when not compiling with\n\t    // thread flags.\n\t    _S_get_pool()._M_initialize_once(); \n\t    __init = true;\n\t  }\n      }","filepath":"contrib/libstdc++/include/ext/mt_allocator.h","line_number":434,"entry_url":"https://github.com/freebsd/freebsd-src.git","slot_name":"release/9.3.0"},"5256912":{"score":0.6294782,"function_name":"__class_type_info::\n__do_upcast","code":"bool __class_type_info::\n__do_upcast (const __class_type_info *dst, const void *obj,\n             __upcast_result \u0026__restrict result) const\n{\n  if (*this == *dst)\n    {\n      result.dst_ptr = obj;\n      result.base_type = nonvirtual_base_type;\n      result.part2dst = __contained_public;\n      return true;\n    }\n  return false;\n}","filepath":"libstdc++-v3/libsupc++/class_type_info.cc","line_number":96,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5257312":{"score":0.81767666,"function_name":"d_make_comp","code":"static struct demangle_component *\nd_make_comp (struct d_info *di, enum demangle_component_type type,\n             struct demangle_component *left,\n             struct demangle_component *right)\n{\n  struct demangle_component *p;\n\n  /* We check for errors here.  A typical error would be a NULL return\n     from a subroutine.  We catch those here, and return NULL\n     upward.  */\n  switch (type)\n    {\n      /* These types require two parameters.  */\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_TEMPLATE:\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_UNARY:\n    case DEMANGLE_COMPONENT_BINARY:\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n    case DEMANGLE_COMPONENT_TRINARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case DEMANGLE_COMPONENT_CLONE:\n      if (left == NULL || right == NULL)\n\treturn NULL;\n      break;\n\n      /* These types only require one parameter.  */\n    case DEMANGLE_COMPONENT_VTABLE:\n    case DEMANGLE_COMPONENT_VTT:\n    case DEMANGLE_COMPONENT_TYPEINFO:\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case DEMANGLE_COMPONENT_THUNK:\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n    case DEMANGLE_COMPONENT_GUARD:\n    case DEMANGLE_COMPONENT_TLS_INIT:\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case DEMANGLE_COMPONENT_REFTEMP:\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case DEMANGLE_COMPONENT_CAST:\n    case DEMANGLE_COMPONENT_CONVERSION:\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case DEMANGLE_COMPONENT_DECLTYPE:\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n    case DEMANGLE_COMPONENT_NULLARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      if (left == NULL)\n\treturn NULL;\n      break;\n\n      /* This needs a right parameter, but the left parameter can be\n\t empty.  */\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      if (right == NULL)\n\treturn NULL;\n      break;\n\n      /* These are allowed to have no parameters--in some cases they\n\t will be filled in later.  */\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n      break;\n\n      /* Other types should not be seen here.  */\n    default:\n      return NULL;\n    }\n\n  p = d_make_empty (di);\n  if (p != NULL)\n    {\n      p-\u003etype = type;\n      p-\u003eu.s_binary.left = left;\n      p-\u003eu.s_binary.right = right;\n    }\n  return p;\n}","filepath":"libiberty/cp-demangle.c","line_number":905,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5257456":{"score":0.8629663,"function_name":"d_cv_qualifiers","code":"static struct demangle_component **\nd_cv_qualifiers (struct d_info *di,\n                 struct demangle_component **pret, int member_fn)\n{\n  struct demangle_component **pstart;\n  char peek;\n\n  pstart = pret;\n  peek = d_peek_char (di);\n  while (peek == 'r' || peek == 'V' || peek == 'K'\n\t || (peek == 'D' \u0026\u0026 d_peek_next_char (di) == 'x'))\n    {\n      enum demangle_component_type t;\n\n      d_advance (di, 1);\n      if (peek == 'r')\n\t{\n\t  t = (member_fn\n\t       ? DEMANGLE_COMPONENT_RESTRICT_THIS\n\t       : DEMANGLE_COMPONENT_RESTRICT);\n\t  di-\u003eexpansion += sizeof \"restrict\";\n\t}\n      else if (peek == 'V')\n\t{\n\t  t = (member_fn\n\t       ? DEMANGLE_COMPONENT_VOLATILE_THIS\n\t       : DEMANGLE_COMPONENT_VOLATILE);\n\t  di-\u003eexpansion += sizeof \"volatile\";\n\t}\n      else if (peek == 'K')\n\t{\n\t  t = (member_fn\n\t       ? DEMANGLE_COMPONENT_CONST_THIS\n\t       : DEMANGLE_COMPONENT_CONST);\n\t  di-\u003eexpansion += sizeof \"const\";\n\t}\n      else\n\t{\n\t  t = DEMANGLE_COMPONENT_TRANSACTION_SAFE;\n\t  di-\u003eexpansion += sizeof \"transaction_safe\";\n\t  d_advance (di, 1);\n\t}\n\n      *pret = d_make_comp (di, t, NULL, NULL);\n      if (*pret == NULL)\n\treturn NULL;\n      pret = \u0026d_left (*pret);\n\n      peek = d_peek_char (di);\n    }\n\n  if (!member_fn \u0026\u0026 peek == 'F')\n    {\n      while (pstart != pret)\n\t{\n\t  switch ((*pstart)-\u003etype)\n\t    {\n\t    case DEMANGLE_COMPONENT_RESTRICT:\n\t      (*pstart)-\u003etype = DEMANGLE_COMPONENT_RESTRICT_THIS;\n\t      break;\n\t    case DEMANGLE_COMPONENT_VOLATILE:\n\t      (*pstart)-\u003etype = DEMANGLE_COMPONENT_VOLATILE_THIS;\n\t      break;\n\t    case DEMANGLE_COMPONENT_CONST:\n\t      (*pstart)-\u003etype = DEMANGLE_COMPONENT_CONST_THIS;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t  pstart = \u0026d_left (*pstart);\n\t}\n    }\n\n  return pret;\n}","filepath":"libiberty/cp-demangle.c","line_number":2637,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5257744":{"score":0.55061364,"function_name":"d_make_demangle_mangled_name","code":"static struct demangle_component *\nd_make_demangle_mangled_name (struct d_info *di, const char *s)\n{\n  if (d_peek_char (di) != '_' || d_peek_next_char (di) != 'Z')\n    return d_make_name (di, s, strlen (s));\n  d_advance (di, 2);\n  return d_encoding (di, 0);\n}","filepath":"libiberty/cp-demangle.c","line_number":1017,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5257840":{"score":0.80462635,"function_name":"d_count_templates_scopes","code":"static void\nd_count_templates_scopes (int *num_templates, int *num_scopes,\n\t\t\t  const struct demangle_component *dc)\n{\n  if (dc == NULL)\n    return;\n\n  switch (dc-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_NAME:\n    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n    case DEMANGLE_COMPONENT_SUB_STD:\n    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n    case DEMANGLE_COMPONENT_OPERATOR:\n    case DEMANGLE_COMPONENT_CHARACTER:\n    case DEMANGLE_COMPONENT_NUMBER:\n    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n      break;\n\n    case DEMANGLE_COMPONENT_TEMPLATE:\n      (*num_templates)++;\n      goto recurse_left_right;\n\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      if (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n\t(*num_scopes)++;\n      goto recurse_left_right;\n\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n    case DEMANGLE_COMPONENT_VTABLE:\n    case DEMANGLE_COMPONENT_VTT:\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case DEMANGLE_COMPONENT_TYPEINFO:\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case DEMANGLE_COMPONENT_THUNK:\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n    case DEMANGLE_COMPONENT_GUARD:\n    case DEMANGLE_COMPONENT_TLS_INIT:\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case DEMANGLE_COMPONENT_REFTEMP:\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n    case DEMANGLE_COMPONENT_CAST:\n    case DEMANGLE_COMPONENT_CONVERSION:\n    case DEMANGLE_COMPONENT_NULLARY:\n    case DEMANGLE_COMPONENT_UNARY:\n    case DEMANGLE_COMPONENT_BINARY:\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n    case DEMANGLE_COMPONENT_TRINARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case DEMANGLE_COMPONENT_DECLTYPE:\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_CLONE:\n    recurse_left_right:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\td_left (dc));\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\td_right (dc));\n      break;\n\n    case DEMANGLE_COMPONENT_CTOR:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_ctor.name);\n      break;\n\n    case DEMANGLE_COMPONENT_DTOR:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_dtor.name);\n      break;\n\n    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_extended_operator.name);\n      break;\n\n    case DEMANGLE_COMPONENT_FIXED_TYPE:\n      d_count_templates_scopes (num_templates, num_scopes,\n                                dc-\u003eu.s_fixed.length);\n      break;\n\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\td_left (dc));\n      break;\n\n    case DEMANGLE_COMPONENT_LAMBDA:\n    case DEMANGLE_COMPONENT_DEFAULT_ARG:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_unary_num.sub);\n      break;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":3914,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5258160":{"score":0.8886219,"function_name":"d_number","code":"static int\nd_number (struct d_info *di)\n{\n  int negative;\n  char peek;\n  int ret;\n\n  negative = 0;\n  peek = d_peek_char (di);\n  if (peek == 'n')\n    {\n      negative = 1;\n      d_advance (di, 1);\n      peek = d_peek_char (di);\n    }\n\n  ret = 0;\n  while (1)\n    {\n      if (! IS_DIGIT (peek))\n\t{\n\t  if (negative)\n\t    ret = - ret;\n\t  return ret;\n\t}\n      ret = ret * 10 + peek - '0';\n      d_advance (di, 1);\n      peek = d_peek_char (di);\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":1647,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5258288":{"score":0.616398,"function_name":"d_make_empty","code":"static struct demangle_component *\nd_make_empty (struct d_info *di)\n{\n  struct demangle_component *p;\n\n  if (di-\u003enext_comp \u003e= di-\u003enum_comps)\n    return NULL;\n  p = \u0026di-\u003ecomps[di-\u003enext_comp];\n  p-\u003ed_printing = 0;\n  ++di-\u003enext_comp;\n  return p;\n}","filepath":"libr/bin/mangling/cxx/cp-demangle.c","line_number":925,"entry_url":"https://github.com/radareorg/radare2.git","slot_name":"5.7.4"},"5258368":{"score":0.7306656,"function_name":"d_discriminator","code":"static int\nd_discriminator (struct d_info *di)\n{\n  int discrim;\n\n  if (d_peek_char (di) != '_')\n    return 1;\n  d_advance (di, 1);\n  discrim = d_number (di);\n  if (discrim \u003c 0)\n    return 0;\n  return 1;\n}","filepath":"libiberty/cp-demangle.c","line_number":3544,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5258448":{"score":0.83429277,"function_name":"d_template_param","code":"static struct demangle_component *\nd_template_param (struct d_info *di)\n{\n  int param;\n\n  if (! d_check_char (di, 'T'))\n    return NULL;\n\n  param = d_compact_number (di);\n  if (param \u003c 0)\n    return NULL;\n\n  ++di-\u003edid_subs;\n\n  return d_make_template_param (di, param);\n}","filepath":"libiberty/cp-demangle.c","line_number":2990,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5258544":{"score":0.6390325,"function_name":"d_identifier","code":"static struct demangle_component *\nd_identifier (struct d_info *di, int len)\n{\n  const char *name;\n\n  name = d_str (di);\n\n  if (di-\u003esend - name \u003c len)\n    return NULL;\n\n  d_advance (di, len);\n\n  /* A Java mangled name may have a trailing '$' if it is a C++\n     keyword.  This '$' is not included in the length count.  We just\n     ignore the '$'.  */\n  if ((di-\u003eoptions \u0026 DMGL_JAVA) != 0\n      \u0026\u0026 d_peek_char (di) == '$')\n    d_advance (di, 1);\n\n  /* Look for something which looks like a gcc encoding of an\n     anonymous namespace, and replace it with a more user friendly\n     name.  */\n  if (len \u003e= (int) ANONYMOUS_NAMESPACE_PREFIX_LEN + 2\n      \u0026\u0026 memcmp (name, ANONYMOUS_NAMESPACE_PREFIX,\n\t\t ANONYMOUS_NAMESPACE_PREFIX_LEN) == 0)\n    {\n      const char *s;\n\n      s = name + ANONYMOUS_NAMESPACE_PREFIX_LEN;\n      if ((*s == '.' || *s == '_' || *s == '$')\n\t  \u0026\u0026 s[1] == 'N')\n\t{\n\t  di-\u003eexpansion -= len - sizeof \"(anonymous namespace)\";\n\t  return d_make_name (di, \"(anonymous namespace)\",\n\t\t\t      sizeof \"(anonymous namespace)\" - 1);\n\t}\n    }\n\n  return d_make_name (di, name, len);\n}","filepath":"libiberty/cp-demangle.c","line_number":1694,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5258864":{"score":0.85478616,"function_name":"d_abi_tags","code":"static struct demangle_component *\nd_abi_tags (struct d_info *di, struct demangle_component *dc)\n{\n  struct demangle_component *hold_last_name;\n  char peek;\n\n  /* Preserve the last name, so the ABI tag doesn't clobber it.  */\n  hold_last_name = di-\u003elast_name;\n\n  while (peek = d_peek_char (di),\n\t peek == 'B')\n    {\n      struct demangle_component *tag;\n      d_advance (di, 1);\n      tag = d_source_name (di);\n      dc = d_make_comp (di, DEMANGLE_COMPONENT_TAGGED_NAME, dc, tag);\n    }\n\n  di-\u003elast_name = hold_last_name;\n\n  return dc;\n}","filepath":"libiberty/cp-demangle.c","line_number":1330,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5258960":{"score":0.86522377,"function_name":"d_substitution","code":"static struct demangle_component *\nd_substitution (struct d_info *di, int prefix)\n{\n  char c;\n\n  if (! d_check_char (di, 'S'))\n    return NULL;\n\n  c = d_next_char (di);\n  if (c == '_' || IS_DIGIT (c) || IS_UPPER (c))\n    {\n      unsigned int id;\n\n      id = 0;\n      if (c != '_')\n\t{\n\t  do\n\t    {\n\t      unsigned int new_id;\n\n\t      if (IS_DIGIT (c))\n\t\tnew_id = id * 36 + c - '0';\n\t      else if (IS_UPPER (c))\n\t\tnew_id = id * 36 + c - 'A' + 10;\n\t      else\n\t\treturn NULL;\n\t      if (new_id \u003c id)\n\t\treturn NULL;\n\t      id = new_id;\n\t      c = d_next_char (di);\n\t    }\n\t  while (c != '_');\n\n\t  ++id;\n\t}\n\n      if (id \u003e= (unsigned int) di-\u003enext_sub)\n\treturn NULL;\n\n      ++di-\u003edid_subs;\n\n      return di-\u003esubs[id];\n    }\n  else\n    {\n      int verbose;\n      const struct d_standard_sub_info *p;\n      const struct d_standard_sub_info *pend;\n\n      verbose = (di-\u003eoptions \u0026 DMGL_VERBOSE) != 0;\n      if (! verbose \u0026\u0026 prefix)\n\t{\n\t  char peek;\n\n\t  peek = d_peek_char (di);\n\t  if (peek == 'C' || peek == 'D')\n\t    verbose = 1;\n\t}\n\n      pend = (\u0026standard_subs[0]\n\t      + sizeof standard_subs / sizeof standard_subs[0]);\n      for (p = \u0026standard_subs[0]; p \u003c pend; ++p)\n\t{\n\t  if (c == p-\u003ecode)\n\t    {\n\t      const char *s;\n\t      int len;\n\t      struct demangle_component *c;\n\n\t      if (p-\u003eset_last_name != NULL)\n\t\tdi-\u003elast_name = d_make_sub (di, p-\u003eset_last_name,\n\t\t\t\t\t    p-\u003eset_last_name_len);\n\t      if (verbose)\n\t\t{\n\t\t  s = p-\u003efull_expansion;\n\t\t  len = p-\u003efull_len;\n\t\t}\n\t      else\n\t\t{\n\t\t  s = p-\u003esimple_expansion;\n\t\t  len = p-\u003esimple_len;\n\t\t}\n\t      di-\u003eexpansion += len;\n\t      c = d_make_sub (di, s, len);\n\t      if (d_peek_char (di) == 'B')\n\t\t{\n\t\t  /* If there are ABI tags on the abbreviation, it becomes\n\t\t     a substitution candidate.  */\n\t\t  c = d_abi_tags (di, c);\n\t\t  d_add_substitution (di, c);\n\t\t}\n\t      return c;\n\t    }\n\t}\n\n      return NULL;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":3712,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5259520":{"score":0.66206723,"function_name":"d_call_offset","code":"static int\nd_call_offset (struct d_info *di, int c)\n{\n  if (c == '\\0')\n    c = d_next_char (di);\n\n  if (c == 'h')\n    d_number (di);\n  else if (c == 'v')\n    {\n      d_number (di);\n      if (! d_check_char (di, '_'))\n\treturn 0;\n      d_number (di);\n    }\n  else\n    return 0;\n\n  if (! d_check_char (di, '_'))\n    return 0;\n\n  return 1;\n}","filepath":"libiberty/cp-demangle.c","line_number":2127,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5259744":{"score":0.7734889,"function_name":"d_find_pack","code":"static struct demangle_component *\nd_find_pack (struct d_print_info *dpi,\n\t     const struct demangle_component *dc)\n{\n  struct demangle_component *a;\n  if (dc == NULL)\n    return NULL;\n\n  switch (dc-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n      a = d_lookup_template_argument (dpi, dc);\n      if (a \u0026\u0026 a-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\treturn a;\n      return NULL;\n\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n      return NULL;\n      \n    case DEMANGLE_COMPONENT_LAMBDA:\n    case DEMANGLE_COMPONENT_NAME:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_OPERATOR:\n    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n    case DEMANGLE_COMPONENT_SUB_STD:\n    case DEMANGLE_COMPONENT_CHARACTER:\n    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n    case DEMANGLE_COMPONENT_FIXED_TYPE:\n    case DEMANGLE_COMPONENT_DEFAULT_ARG:\n    case DEMANGLE_COMPONENT_NUMBER:\n      return NULL;\n\n    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n      return d_find_pack (dpi, dc-\u003eu.s_extended_operator.name);\n    case DEMANGLE_COMPONENT_CTOR:\n      return d_find_pack (dpi, dc-\u003eu.s_ctor.name);\n    case DEMANGLE_COMPONENT_DTOR:\n      return d_find_pack (dpi, dc-\u003eu.s_dtor.name);\n\n    default:\n      a = d_find_pack (dpi, d_left (dc));\n      if (a)\n\treturn a;\n      return d_find_pack (dpi, d_right (dc));\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":4264,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5259872":{"score":0.6105412,"function_name":"d_growable_string_append_buffer","code":"static inline void\nd_growable_string_append_buffer (struct d_growable_string *dgs,\n                                 const char *s, size_t l)\n{\n  size_t need;\n\n  need = dgs-\u003elen + l + 1;\n  if (need \u003e dgs-\u003ealc)\n    d_growable_string_resize (dgs, need);\n\n  if (dgs-\u003eallocation_failure)\n    return;\n\n  memcpy (dgs-\u003ebuf + dgs-\u003elen, s, l);\n  dgs-\u003ebuf[dgs-\u003elen + l] = '\\0';\n  dgs-\u003elen += l;\n}","filepath":"libiberty/cp-demangle.c","line_number":3879,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5260112":{"score":0.63134617,"function_name":"d_exprlist","code":"static struct demangle_component *\nd_exprlist (struct d_info *di, char terminator)\n{\n  struct demangle_component *list = NULL;\n  struct demangle_component **p = \u0026list;\n\n  if (d_peek_char (di) == terminator)\n    {\n      d_advance (di, 1);\n      return d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, NULL, NULL);\n    }\n\n  while (1)\n    {\n      struct demangle_component *arg = d_expression (di);\n      if (arg == NULL)\n\treturn NULL;\n\n      *p = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, arg, NULL);\n      if (*p == NULL)\n\treturn NULL;\n      p = \u0026d_right (*p);\n\n      if (d_peek_char (di) == terminator)\n\t{\n\t  d_advance (di, 1);\n\t  break;\n\t}\n    }\n\n  return list;\n}","filepath":"libiberty/cp-demangle.c","line_number":3103,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5262048":{"score":0.8904715,"function_name":"d_expression_1","code":"static inline struct demangle_component *\nd_expression_1 (struct d_info *di)\n{\n  char peek;\n\n  peek = d_peek_char (di);\n  if (peek == 'L')\n    return d_expr_primary (di);\n  else if (peek == 'T')\n    return d_template_param (di);\n  else if (peek == 's' \u0026\u0026 d_peek_next_char (di) == 'r')\n    {\n      struct demangle_component *type;\n      struct demangle_component *name;\n\n      d_advance (di, 2);\n      type = cplus_demangle_type (di);\n      name = d_unqualified_name (di);\n      if (d_peek_char (di) != 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n      else\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,\n\t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t\t\t d_template_args (di)));\n    }\n  else if (peek == 's' \u0026\u0026 d_peek_next_char (di) == 'p')\n    {\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n\t\t\t  d_expression_1 (di), NULL);\n    }\n  else if (peek == 'f' \u0026\u0026 d_peek_next_char (di) == 'p')\n    {\n      /* Function parameter used in a late-specified return type.  */\n      int index;\n      d_advance (di, 2);\n      if (d_peek_char (di) == 'T')\n\t{\n\t  /* 'this' parameter.  */\n\t  d_advance (di, 1);\n\t  index = 0;\n\t}\n      else\n\t{\n\t  index = d_compact_number (di);\n\t  if (index == INT_MAX || index == -1)\n\t    return NULL;\n\t  index++;\n\t}\n      return d_make_function_param (di, index);\n    }\n  else if (IS_DIGIT (peek)\n\t   || (peek == 'o' \u0026\u0026 d_peek_next_char (di) == 'n'))\n    {\n      /* We can get an unqualified name as an expression in the case of\n         a dependent function call, i.e. decltype(f(t)).  */\n      struct demangle_component *name;\n\n      if (peek == 'o')\n\t/* operator-function-id, i.e. operator+(t).  */\n\td_advance (di, 2);\n\n      name = d_unqualified_name (di);\n      if (name == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t    d_template_args (di));\n      else\n\treturn name;\n    }\n  else if ((peek == 'i' || peek == 't')\n\t   \u0026\u0026 d_peek_next_char (di) == 'l')\n    {\n      /* Brace-enclosed initializer list, untyped or typed.  */\n      struct demangle_component *type = NULL;\n      if (peek == 't')\n\ttype = cplus_demangle_type (di);\n      if (!d_peek_next_char (di))\n\treturn NULL;\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_INITIALIZER_LIST,\n\t\t\t  type, d_exprlist (di, 'E'));\n    }\n  else\n    {\n      struct demangle_component *op;\n      const char *code = NULL;\n      int args;\n\n      op = d_operator_name (di);\n      if (op == NULL)\n\treturn NULL;\n\n      if (op-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n\t{\n\t  code = op-\u003eu.s_operator.op-\u003ecode;\n\t  di-\u003eexpansion += op-\u003eu.s_operator.op-\u003elen - 2;\n\t  if (strcmp (code, \"st\") == 0)\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\tcplus_demangle_type (di));\n\t}\n\n      switch (op-\u003etype)\n\t{\n\tdefault:\n\t  return NULL;\n\tcase DEMANGLE_COMPONENT_OPERATOR:\n\t  args = op-\u003eu.s_operator.op-\u003eargs;\n\t  break;\n\tcase DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n\t  args = op-\u003eu.s_extended_operator.args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_CAST:\n\t  args = 1;\n\t  break;\n\t}\n\n      switch (args)\n\t{\n\tcase 0:\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_NULLARY, op, NULL);\n\n\tcase 1:\n\t  {\n\t    struct demangle_component *operand;\n\t    int suffix = 0;\n\n\t    if (code \u0026\u0026 (code[0] == 'p' || code[0] == 'm')\n\t\t\u0026\u0026 code[1] == code[0])\n\t      /* pp_ and mm_ are the prefix variants.  */\n\t      suffix = !d_check_char (di, '_');\n\n\t    if (op-\u003etype == DEMANGLE_COMPONENT_CAST\n\t\t\u0026\u0026 d_check_char (di, '_'))\n\t      operand = d_exprlist (di, 'E');\n\t    else if (code \u0026\u0026 !strcmp (code, \"sP\"))\n\t      operand = d_template_args_1 (di);\n\t    else\n\t      operand = d_expression_1 (di);\n\n\t    if (suffix)\n\t      /* Indicate the suffix variant for d_print_comp.  */\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  d_make_comp (di,\n\t\t\t\t\t       DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t       operand, operand));\n\t    else\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  operand);\n\t  }\n\tcase 2:\n\t  {\n\t    struct demangle_component *left;\n\t    struct demangle_component *right;\n\n\t    if (code == NULL)\n\t      return NULL;\n\t    if (op_is_new_cast (op))\n\t      left = cplus_demangle_type (di);\n\t    else if (code[0] == 'f')\n\t      /* fold-expression.  */\n\t      left = d_operator_name (di);\n\t    else\n\t      left = d_expression_1 (di);\n\t    if (!strcmp (code, \"cl\"))\n\t      right = d_exprlist (di, 'E');\n\t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n\t      {\n\t\tright = d_unqualified_name (di);\n\t\tif (d_peek_char (di) == 'I')\n\t\t  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n\t\t\t\t       right, d_template_args (di));\n\t      }\n\t    else\n\t      right = d_expression_1 (di);\n\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t     left, right));\n\t  }\n\tcase 3:\n\t  {\n\t    struct demangle_component *first;\n\t    struct demangle_component *second;\n\t    struct demangle_component *third;\n\n\t    if (code == NULL)\n\t      return NULL;\n\t    else if (!strcmp (code, \"qu\"))\n\t      {\n\t\t/* ?: expression.  */\n\t\tfirst = d_expression_1 (di);\n\t\tsecond = d_expression_1 (di);\n\t\tthird = d_expression_1 (di);\n\t      }\n\t    else if (code[0] == 'f')\n\t      {\n\t\t/* fold-expression.  */\n\t\tfirst = d_operator_name (di);\n\t\tsecond = d_expression_1 (di);\n\t\tthird = d_expression_1 (di);\n\t      }\n\t    else if (code[0] == 'n')\n\t      {\n\t\t/* new-expression.  */\n\t\tif (code[1] != 'w' \u0026\u0026 code[1] != 'a')\n\t\t  return NULL;\n\t\tfirst = d_exprlist (di, '_');\n\t\tsecond = cplus_demangle_type (di);\n\t\tif (d_peek_char (di) == 'E')\n\t\t  {\n\t\t    d_advance (di, 1);\n\t\t    third = NULL;\n\t\t  }\n\t\telse if (d_peek_char (di) == 'p'\n\t\t\t \u0026\u0026 d_peek_next_char (di) == 'i')\n\t\t  {\n\t\t    /* Parenthesized initializer.  */\n\t\t    d_advance (di, 2);\n\t\t    third = d_exprlist (di, 'E');\n\t\t  }\n\t\telse if (d_peek_char (di) == 'i'\n\t\t\t \u0026\u0026 d_peek_next_char (di) == 'l')\n\t\t  /* initializer-list.  */\n\t\t  third = d_expression_1 (di);\n\t\telse\n\t\t  return NULL;\n\t      }\n\t    else\n\t      return NULL;\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_TRINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_TRINARY_ARG1,\n\t\t\t\t\t     first,\n\t\t\t\t\t     d_make_comp (di,\n\t\t\t\t\t\t\t  DEMANGLE_COMPONENT_TRINARY_ARG2,\n\t\t\t\t\t\t\t  second, third)));\n\t  }\n\tdefault:\n\t  return NULL;\n\t}\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":3159,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5263648":{"score":0.83977115,"function_name":"d_template_args_1","code":"static struct demangle_component *\nd_template_args_1 (struct d_info *di)\n{\n  struct demangle_component *hold_last_name;\n  struct demangle_component *al;\n  struct demangle_component **pal;\n\n  /* Preserve the last name we saw--don't let the template arguments\n     clobber it, as that would give us the wrong name for a subsequent\n     constructor or destructor.  */\n  hold_last_name = di-\u003elast_name;\n\n  if (d_peek_char (di) == 'E')\n    {\n      /* An argument pack can be empty.  */\n      d_advance (di, 1);\n      return d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, NULL, NULL);\n    }\n\n  al = NULL;\n  pal = \u0026al;\n  while (1)\n    {\n      struct demangle_component *a;\n\n      a = d_template_arg (di);\n      if (a == NULL)\n\treturn NULL;\n\n      *pal = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, a, NULL);\n      if (*pal == NULL)\n\treturn NULL;\n      pal = \u0026d_right (*pal);\n\n      if (d_peek_char (di) == 'E')\n\t{\n\t  d_advance (di, 1);\n\t  break;\n\t}\n    }\n\n  di-\u003elast_name = hold_last_name;\n\n  return al;\n}","filepath":"libiberty/cp-demangle.c","line_number":3022,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5264032":{"score":0.78718066,"function_name":"d_name","code":"static struct demangle_component *\nd_name (struct d_info *di)\n{\n  char peek = d_peek_char (di);\n  struct demangle_component *dc;\n\n  switch (peek)\n    {\n    case 'N':\n      return d_nested_name (di);\n\n    case 'Z':\n      return d_local_name (di);\n\n    case 'U':\n      return d_unqualified_name (di);\n\n    case 'S':\n      {\n\tint subst;\n\n\tif (d_peek_next_char (di) != 't')\n\t  {\n\t    dc = d_substitution (di, 0);\n\t    subst = 1;\n\t  }\n\telse\n\t  {\n\t    d_advance (di, 2);\n\t    dc = d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME,\n\t\t\t      d_make_name (di, \"std\", 3),\n\t\t\t      d_unqualified_name (di));\n\t    di-\u003eexpansion += 3;\n\t    subst = 0;\n\t  }\n\n\tif (d_peek_char (di) != 'I')\n\t  {\n\t    /* The grammar does not permit this case to occur if we\n\t       called d_substitution() above (i.e., subst == 1).  We\n\t       don't bother to check.  */\n\t  }\n\telse\n\t  {\n\t    /* This is \u003ctemplate-args\u003e, which means that we just saw\n\t       \u003cunscoped-template-name\u003e, which is a substitution\n\t       candidate if we didn't just get it from a\n\t       substitution.  */\n\t    if (! subst)\n\t      {\n\t\tif (! d_add_substitution (di, dc))\n\t\t  return NULL;\n\t      }\n\t    dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,\n\t\t\t      d_template_args (di));\n\t  }\n\n\treturn dc;\n      }\n\n    case 'L':\n    default:\n      dc = d_unqualified_name (di);\n      if (d_peek_char (di) == 'I')\n\t{\n\t  /* This is \u003ctemplate-args\u003e, which means that we just saw\n\t     \u003cunscoped-template-name\u003e, which is a substitution\n\t     candidate.  */\n\t  if (! d_add_substitution (di, dc))\n\t    return NULL;\n\t  dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,\n\t\t\t    d_template_args (di));\n\t}\n      return dc;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":1365,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5265520":{"score":0.7617079,"function_name":"cplus_demangle_type","code":"demangle_component *\ncplus_demangle_type (struct d_info *di)\n{\n  char peek;\n  struct demangle_component *ret;\n  int can_subst;\n\n  /* The ABI specifies that when CV-qualifiers are used, the base type\n     is substitutable, and the fully qualified type is substitutable,\n     but the base type with a strict subset of the CV-qualifiers is\n     not substitutable.  The natural recursive implementation of the\n     CV-qualifiers would cause subsets to be substitutable, so instead\n     we pull them all off now.\n\n     FIXME: The ABI says that order-insensitive vendor qualifiers\n     should be handled in the same way, but we have no way to tell\n     which vendor qualifiers are order-insensitive and which are\n     order-sensitive.  So we just assume that they are all\n     order-sensitive.  g++ 3.4 supports only one vendor qualifier,\n     __vector, and it treats it as order-sensitive when mangling\n     names.  */\n\n  peek = d_peek_char (di);\n  if (peek == 'r' || peek == 'V' || peek == 'K'\n      || (peek == 'D' \u0026\u0026 d_peek_next_char (di) == 'x'))\n    {\n      struct demangle_component **pret;\n\n      pret = d_cv_qualifiers (di, \u0026ret, 0);\n      if (pret == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'F')\n\t{\n\t  /* cv-qualifiers before a function type apply to 'this',\n\t     so avoid adding the unqualified function type to\n\t     the substitution list.  */\n\t  *pret = d_function_type (di);\n\t}\n      else\n\t*pret = cplus_demangle_type (di);\n      if (!*pret)\n\treturn NULL;\n      if ((*pret)-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t  || (*pret)-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t{\n\t  /* Move the ref-qualifier outside the cv-qualifiers so that\n\t     they are printed in the right order.  */\n\t  struct demangle_component *fn = d_left (*pret);\n\t  d_left (*pret) = ret;\n\t  ret = *pret;\n\t  *pret = fn;\n\t}\n      if (! d_add_substitution (di, ret))\n\treturn NULL;\n      return ret;\n    }\n\n  can_subst = 1;\n\n  switch (peek)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':\n    case 'h': case 'i': case 'j':           case 'l': case 'm': case 'n':\n    case 'o':                               case 's': case 't':\n    case 'v': case 'w': case 'x': case 'y': case 'z':\n      ret = d_make_builtin_type (di,\n\t\t\t\t \u0026cplus_demangle_builtin_types[peek - 'a']);\n      di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n      can_subst = 0;\n      d_advance (di, 1);\n      break;\n\n    case 'u':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,\n\t\t\t d_source_name (di), NULL);\n      break;\n\n    case 'F':\n      ret = d_function_type (di);\n      break;\n\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case 'N':\n    case 'Z':\n      ret = d_class_enum_type (di);\n      break;\n\n    case 'A':\n      ret = d_array_type (di);\n      break;\n\n    case 'M':\n      ret = d_pointer_to_member_type (di);\n      break;\n\n    case 'T':\n      ret = d_template_param (di);\n      if (d_peek_char (di) == 'I')\n\t{\n\t  /* This may be \u003ctemplate-template-param\u003e \u003ctemplate-args\u003e.\n\t     If this is the type for a conversion operator, we can\n\t     have a \u003ctemplate-template-param\u003e here only by following\n\t     a derivation like this:\n\n\t     \u003cnested-name\u003e\n\t     -\u003e \u003ctemplate-prefix\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cprefix\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cunqualified-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003coperator-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctype\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctemplate-template-param\u003e \u003ctemplate-args\u003e \u003ctemplate-args\u003e\n\n\t     where the \u003ctemplate-args\u003e is followed by another.\n\t     Otherwise, we must have a derivation like this:\n\n\t     \u003cnested-name\u003e\n\t     -\u003e \u003ctemplate-prefix\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cprefix\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cunqualified-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003coperator-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctype\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctemplate-param\u003e \u003ctemplate-args\u003e\n\n\t     where we need to leave the \u003ctemplate-args\u003e to be processed\n\t     by d_prefix (following the \u003ctemplate-prefix\u003e).\n\n\t     The \u003ctemplate-template-param\u003e part is a substitution\n\t     candidate.  */\n\t  if (! di-\u003eis_conversion)\n\t    {\n\t      if (! d_add_substitution (di, ret))\n\t\treturn NULL;\n\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t d_template_args (di));\n\t    }\n\t  else\n\t    {\n\t      struct demangle_component *args;\n\t      struct d_info_checkpoint checkpoint;\n\n\t      d_checkpoint (di, \u0026checkpoint);\n\t      args = d_template_args (di);\n\t      if (d_peek_char (di) == 'I')\n\t\t{\n\t\t  if (! d_add_substitution (di, ret))\n\t\t    return NULL;\n\t\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t     args);\n\t\t}\n\t      else\n\t\td_backtrack (di, \u0026checkpoint);\n\t    }\n\t}\n      break;\n\n    case 'S':\n      /* If this is a special substitution, then it is the start of\n\t \u003cclass-enum-type\u003e.  */\n      {\n\tchar peek_next;\n\n\tpeek_next = d_peek_next_char (di);\n\tif (IS_DIGIT (peek_next)\n\t    || peek_next == '_'\n\t    || IS_UPPER (peek_next))\n\t  {\n\t    ret = d_substitution (di, 0);\n\t    /* The substituted name may have been a template name and\n\t       may be followed by tepmlate args.  */\n\t    if (d_peek_char (di) == 'I')\n\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t d_template_args (di));\n\t    else\n\t      can_subst = 0;\n\t  }\n\telse\n\t  {\n\t    ret = d_class_enum_type (di);\n\t    /* If the substitution was a complete type, then it is not\n\t       a new substitution candidate.  However, if the\n\t       substitution was followed by template arguments, then\n\t       the whole thing is a substitution candidate.  */\n\t    if (ret != NULL \u0026\u0026 ret-\u003etype == DEMANGLE_COMPONENT_SUB_STD)\n\t      can_subst = 0;\n\t  }\n      }\n      break;\n\n    case 'O':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_RVALUE_REFERENCE,\n                         cplus_demangle_type (di), NULL);\n      break;\n\n    case 'P':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_POINTER,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'R':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_REFERENCE,\n                         cplus_demangle_type (di), NULL);\n      break;\n\n    case 'C':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_COMPLEX,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'G':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_IMAGINARY,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'U':\n      d_advance (di, 1);\n      ret = d_source_name (di);\n      if (d_peek_char (di) == 'I')\n\tret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t   d_template_args (di));\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,\n\t\t\t cplus_demangle_type (di), ret);\n      break;\n\n    case 'D':\n      can_subst = 0;\n      d_advance (di, 1);\n      peek = d_next_char (di);\n      switch (peek)\n\t{\n\tcase 'T':\n\tcase 't':\n\t  /* decltype (expression) */\n\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_DECLTYPE,\n\t\t\t     d_expression (di), NULL);\n\t  if (ret \u0026\u0026 d_next_char (di) != 'E')\n\t    ret = NULL;\n\t  can_subst = 1;\n\t  break;\n\t  \n\tcase 'p':\n\t  /* Pack expansion.  */\n\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n\t\t\t     cplus_demangle_type (di), NULL);\n\t  can_subst = 1;\n\t  break;\n\n\tcase 'a':\n\t  /* auto */\n\t  ret = d_make_name (di, \"auto\", 4);\n\t  break;\n\tcase 'c':\n\t  /* decltype(auto) */\n\t  ret = d_make_name (di, \"decltype(auto)\", 14);\n\t  break;\n\n\tcase 'f':\n\t  /* 32-bit decimal floating point */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[26]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'd':\n\t  /* 64-bit DFP */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[27]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'e':\n\t  /* 128-bit DFP */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[28]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'h':\n\t  /* 16-bit half-precision FP */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[29]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 's':\n\t  /* char16_t */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[30]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'i':\n\t  /* char32_t */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[31]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\n\tcase 'F':\n\t  /* Fixed point types. DF\u003cint bits\u003e\u003clength\u003e\u003cfract bits\u003e\u003csat\u003e  */\n\t  ret = d_make_empty (di);\n\t  ret-\u003etype = DEMANGLE_COMPONENT_FIXED_TYPE;\n\t  if ((ret-\u003eu.s_fixed.accum = IS_DIGIT (d_peek_char (di))))\n\t    /* For demangling we don't care about the bits.  */\n\t    d_number (di);\n\t  ret-\u003eu.s_fixed.length = cplus_demangle_type (di);\n\t  if (ret-\u003eu.s_fixed.length == NULL)\n\t    return NULL;\n\t  d_number (di);\n\t  peek = d_next_char (di);\n\t  ret-\u003eu.s_fixed.sat = (peek == 's');\n\t  break;\n\n\tcase 'v':\n\t  ret = d_vector_type (di);\n\t  can_subst = 1;\n\t  break;\n\n        case 'n':\n          /* decltype(nullptr) */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[32]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\n\tdefault:\n\t  return NULL;\n\t}\n      break;\n\n    default:\n      return NULL;\n    }\n\n  if (can_subst)\n    {\n      if (! d_add_substitution (di, ret))\n\treturn NULL;\n    }\n\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":2296,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5268064":{"score":0.58716935,"function_name":"d_vector_type","code":"static struct demangle_component *\nd_vector_type (struct d_info *di)\n{\n  char peek;\n  struct demangle_component *dim;\n\n  peek = d_peek_char (di);\n  if (peek == '_')\n    {\n      d_advance (di, 1);\n      dim = d_expression (di);\n    }\n  else\n    dim = d_number_component (di);\n\n  if (dim == NULL)\n    return NULL;\n\n  if (! d_check_char (di, '_'))\n    return NULL;\n\n  return d_make_comp (di, DEMANGLE_COMPONENT_VECTOR_TYPE, dim,\n\t\t      cplus_demangle_type (di));\n}","filepath":"libiberty/cp-demangle.c","line_number":2906,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5268480":{"score":0.60346806,"function_name":"d_nested_name","code":"static struct demangle_component *\nd_nested_name (struct d_info *di)\n{\n  struct demangle_component *ret;\n  struct demangle_component **pret;\n  struct demangle_component *rqual;\n\n  if (! d_check_char (di, 'N'))\n    return NULL;\n\n  pret = d_cv_qualifiers (di, \u0026ret, 1);\n  if (pret == NULL)\n    return NULL;\n\n  /* Parse the ref-qualifier now and then attach it\n     once we have something to attach it to.  */\n  rqual = d_ref_qualifier (di, NULL);\n\n  *pret = d_prefix (di);\n  if (*pret == NULL)\n    return NULL;\n\n  if (rqual)\n    {\n      d_left (rqual) = ret;\n      ret = rqual;\n    }\n\n  if (! d_check_char (di, 'E'))\n    return NULL;\n\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":1446,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5268736":{"score":0.7650378,"function_name":"d_expression","code":"static struct demangle_component *\nd_expression (struct d_info *di)\n{\n  char peek;\n\n  peek = d_peek_char (di);\n  if (peek == 'L')\n    return d_expr_primary (di);\n  else if (peek == 'T')\n    return d_template_param (di);\n  else if (peek == 's' \u0026\u0026 d_peek_next_char (di) == 'r')\n    {\n      struct demangle_component *type;\n      struct demangle_component *name;\n\n      d_advance (di, 2);\n      type = cplus_demangle_type (di);\n      name = d_unqualified_name (di);\n      if (d_peek_char (di) != 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n      else\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,\n\t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t\t\t d_template_args (di)));\n    }\n  else if (peek == 's' \u0026\u0026 d_peek_next_char (di) == 'p')\n    {\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n\t\t\t  d_expression (di), NULL);\n    }\n  else if (peek == 'f' \u0026\u0026 d_peek_next_char (di) == 'p')\n    {\n      /* Function parameter used in a late-specified return type.  */\n      int index;\n      d_advance (di, 2);\n      if (d_peek_char (di) == '_')\n\tindex = 1;\n      else\n\t{\n\t  index = d_number (di);\n\t  if (index \u003c 0)\n\t    return NULL;\n\t  index += 2;\n\t}\n\n      if (! d_check_char (di, '_'))\n\treturn NULL;\n\n      return d_make_function_param (di, index);\n    }\n  else if (IS_DIGIT (peek))\n    {\n      /* We can get an unqualified name as an expression in the case of\n         a dependent member access, i.e. decltype(T().i).  */\n      struct demangle_component *name = d_unqualified_name (di);\n      if (name == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t    d_template_args (di));\n      else\n\treturn name;\n    }\n  else\n    {\n      struct demangle_component *op;\n      int args;\n\n      op = d_operator_name (di);\n      if (op == NULL)\n\treturn NULL;\n\n      if (op-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n\tdi-\u003eexpansion += op-\u003eu.s_operator.op-\u003elen - 2;\n\n      if (op-\u003etype == DEMANGLE_COMPONENT_OPERATOR\n\t  \u0026\u0026 strcmp (op-\u003eu.s_operator.op-\u003ecode, \"st\") == 0)\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t    cplus_demangle_type (di));\n\n      switch (op-\u003etype)\n\t{\n\tdefault:\n\t  return NULL;\n\tcase DEMANGLE_COMPONENT_OPERATOR:\n\t  args = op-\u003eu.s_operator.op-\u003eargs;\n\t  break;\n\tcase DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n\t  args = op-\u003eu.s_extended_operator.args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_CAST:\n\t  args = 1;\n\t  break;\n\t}\n\n      switch (args)\n\t{\n\tcase 1:\n\t  {\n\t    struct demangle_component *operand;\n\t    if (op-\u003etype == DEMANGLE_COMPONENT_CAST\n\t\t\u0026\u0026 d_check_char (di, '_'))\n\t      operand = d_exprlist (di);\n\t    else\n\t      operand = d_expression (di);\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\toperand);\n\t  }\n\tcase 2:\n\t  {\n\t    struct demangle_component *left;\n\t    struct demangle_component *right;\n\n\t    left = d_expression (di);\n\t    if (!strcmp (op-\u003eu.s_operator.op-\u003ecode, \"cl\"))\n\t      right = d_exprlist (di);\n\t    else\n\t      right = d_expression (di);\n\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t     left, right));\n\t  }\n\tcase 3:\n\t  {\n\t    struct demangle_component *first;\n\t    struct demangle_component *second;\n\n\t    first = d_expression (di);\n\t    second = d_expression (di);\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_TRINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_TRINARY_ARG1,\n\t\t\t\t\t     first,\n\t\t\t\t\t     d_make_comp (di,\n\t\t\t\t\t\t\t  DEMANGLE_COMPONENT_TRINARY_ARG2,\n\t\t\t\t\t\t\t  second,\n\t\t\t\t\t\t\t  d_expression (di))));\n\t  }\n\tdefault:\n\t  return NULL;\n\t}\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":2566,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.0.1a"},"5269760":{"score":0.8690478,"function_name":"d_bare_function_type","code":"static struct demangle_component *\nd_bare_function_type (struct d_info *di, int has_return_type)\n{\n  struct demangle_component *return_type;\n  struct demangle_component *tl;\n  char peek;\n\n  /* Detect special qualifier indicating that the first argument\n     is the return type.  */\n  peek = d_peek_char (di);\n  if (peek == 'J')\n    {\n      d_advance (di, 1);\n      has_return_type = 1;\n    }\n\n  if (has_return_type)\n    {\n      return_type = cplus_demangle_type (di);\n      if (return_type == NULL)\n\treturn NULL;\n    }\n  else\n    return_type = NULL;\n\n  tl = d_parmlist (di);\n  if (tl == NULL)\n    return NULL;\n\n  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE,\n\t\t      return_type, tl);\n}","filepath":"libiberty/cp-demangle.c","line_number":2817,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5269872":{"score":0.86295354,"function_name":"d_function_type","code":"static struct demangle_component *\nd_function_type (struct d_info *di)\n{\n  struct demangle_component *ret;\n\n  if (! d_check_char (di, 'F'))\n    return NULL;\n  if (d_peek_char (di) == 'Y')\n    {\n      /* Function has C linkage.  We don't print this information.\n\t FIXME: We should print it in verbose mode.  */\n      d_advance (di, 1);\n    }\n  ret = d_bare_function_type (di, 1);\n  ret = d_ref_qualifier (di, ret);\n\n  if (! d_check_char (di, 'E'))\n    return NULL;\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":2746,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5269984":{"score":0.66445136,"function_name":"d_encoding","code":"static struct demangle_component *\nd_encoding (struct d_info *di, int top_level)\n{\n  char peek = d_peek_char (di);\n\n  if (peek == 'G' || peek == 'T')\n    return d_special_name (di);\n  else\n    {\n      struct demangle_component *dc;\n\n      dc = d_name (di);\n\n      if (dc != NULL \u0026\u0026 top_level \u0026\u0026 (di-\u003eoptions \u0026 DMGL_PARAMS) == 0)\n\t{\n\t  /* Strip off any initial CV-qualifiers, as they really apply\n\t     to the `this' parameter, and they were not output by the\n\t     v2 demangler without DMGL_PARAMS.  */\n\t  while (dc-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t || dc-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t || dc-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t\t || dc-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t\t || dc-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t\t || dc-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n\t    dc = d_left (dc);\n\n\t  /* If the top level is a DEMANGLE_COMPONENT_LOCAL_NAME, then\n\t     there may be CV-qualifiers on its right argument which\n\t     really apply here; this happens when parsing a class\n\t     which is local to a function.  */\n\t  if (dc-\u003etype == DEMANGLE_COMPONENT_LOCAL_NAME)\n\t    {\n\t      struct demangle_component *dcr;\n\n\t      dcr = d_right (dc);\n\t      while (dcr-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t     || dcr-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t     || dcr-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t\t     || dcr-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t\t     || dcr-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t\t     || dcr-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n\t\tdcr = d_left (dcr);\n\t      dc-\u003eu.s_binary.right = dcr;\n\t    }\n\n\t  return dc;\n\t}\n\n      peek = d_peek_char (di);\n      if (dc == NULL || peek == '\\0' || peek == 'E')\n\treturn dc;\n      return d_make_comp (di, DEMANGLE_COMPONENT_TYPED_NAME, dc,\n\t\t\t  d_bare_function_type (di, has_return_type (dc)));\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":1272,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5271504":{"score":0.8680072,"function_name":"d_expr_primary","code":"static struct demangle_component *\nd_expr_primary (struct d_info *di)\n{\n  struct demangle_component *ret;\n\n  if (! d_check_char (di, 'L'))\n    return NULL;\n  if (d_peek_char (di) == '_'\n      /* Workaround for G++ bug; see comment in write_template_arg.  */\n      || d_peek_char (di) == 'Z')\n    ret = cplus_demangle_mangled_name (di, 0);\n  else\n    {\n      struct demangle_component *type;\n      enum demangle_component_type t;\n      const char *s;\n\n      type = cplus_demangle_type (di);\n      if (type == NULL)\n\treturn NULL;\n\n      /* If we have a type we know how to print, we aren't going to\n\t print the type name itself.  */\n      if (type-\u003etype == DEMANGLE_COMPONENT_BUILTIN_TYPE\n\t  \u0026\u0026 type-\u003eu.s_builtin.type-\u003eprint != D_PRINT_DEFAULT)\n\tdi-\u003eexpansion -= type-\u003eu.s_builtin.type-\u003elen;\n\n      /* Rather than try to interpret the literal value, we just\n\t collect it as a string.  Note that it's possible to have a\n\t floating point literal here.  The ABI specifies that the\n\t format of such literals is machine independent.  That's fine,\n\t but what's not fine is that versions of g++ up to 3.2 with\n\t -fabi-version=1 used upper case letters in the hex constant,\n\t and dumped out gcc's internal representation.  That makes it\n\t hard to tell where the constant ends, and hard to dump the\n\t constant in any readable form anyhow.  We don't attempt to\n\t handle these cases.  */\n\n      t = DEMANGLE_COMPONENT_LITERAL;\n      if (d_peek_char (di) == 'n')\n\t{\n\t  t = DEMANGLE_COMPONENT_LITERAL_NEG;\n\t  d_advance (di, 1);\n\t}\n      s = d_str (di);\n      while (d_peek_char (di) != 'E')\n\t{\n\t  if (d_peek_char (di) == '\\0')\n\t    return NULL;\n\t  d_advance (di, 1);\n\t}\n      ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));\n    }\n  if (! d_check_char (di, 'E'))\n    return NULL;\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":3422,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5271920":{"score":0.8254493,"function_name":"d_print_comp_inner","code":"static void\nd_print_comp_inner (struct d_print_info *dpi, int options,\n\t\t  const struct demangle_component *dc)\n{\n  /* Magic variable to let reference smashing skip over the next modifier\n     without needing to modify *dc.  */\n  const struct demangle_component *mod_inner = NULL;\n\n  /* Variable used to store the current templates while a previously\n     captured scope is used.  */\n  struct d_print_template *saved_templates;\n\n  /* Nonzero if templates have been stored in the above variable.  */\n  int need_template_restore = 0;\n\n  if (dc == NULL)\n    {\n      d_print_error (dpi);\n      return;\n    }\n  if (d_print_saw_error (dpi))\n    return;\n\n  switch (dc-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_NAME:\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_buffer (dpi, dc-\u003eu.s_name.s, dc-\u003eu.s_name.len);\n      else\n\td_print_java_identifier (dpi, dc-\u003eu.s_name.s, dc-\u003eu.s_name.len);\n      return;\n\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \"[abi:\");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_char (dpi, ']');\n      return;\n\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_string (dpi, \"::\");\n      else\n\td_append_char (dpi, '.');\n      {\n\tstruct demangle_component *local_name = d_right (dc);\n\tif (local_name-\u003etype == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t  {\n\t    d_append_string (dpi, \"{default arg#\");\n\t    d_append_num (dpi, local_name-\u003eu.s_unary_num.num + 1);\n\t    d_append_string (dpi, \"}::\");\n\t    local_name = local_name-\u003eu.s_unary_num.sub;\n\t  }\n\td_print_comp (dpi, options, local_name);\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n      {\n\tstruct d_print_mod *hold_modifiers;\n\tstruct demangle_component *typed_name;\n\tstruct d_print_mod adpm[4];\n\tunsigned int i;\n\tstruct d_print_template dpt;\n\n\t/* Pass the name down to the type so that it can be printed in\n\t   the right place for the type.  We also have to pass down\n\t   any CV-qualifiers, which apply to the this parameter.  */\n\thold_modifiers = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = 0;\n\ti = 0;\n\ttyped_name = d_left (dc);\n\twhile (typed_name != NULL)\n\t  {\n\t    if (i \u003e= sizeof adpm / sizeof adpm[0])\n\t      {\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    adpm[i].next = dpi-\u003emodifiers;\n\t    dpi-\u003emodifiers = \u0026adpm[i];\n\t    adpm[i].mod = typed_name;\n\t    adpm[i].printed = 0;\n\t    adpm[i].templates = dpi-\u003etemplates;\n\t    ++i;\n\n\t    if (typed_name-\u003etype != DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_CONST_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t      break;\n\n\t    typed_name = d_left (typed_name);\n\t  }\n\n\tif (typed_name == NULL)\n\t  {\n\t    d_print_error (dpi);\n\t    return;\n\t  }\n\n\t/* If typed_name is a template, then it applies to the\n\t   function type as well.  */\n\tif (typed_name-\u003etype == DEMANGLE_COMPONENT_TEMPLATE)\n\t  {\n\t    dpt.next = dpi-\u003etemplates;\n\t    dpi-\u003etemplates = \u0026dpt;\n\t    dpt.template_decl = typed_name;\n\t  }\n\n\t/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then\n\t   there may be CV-qualifiers on its right argument which\n\t   really apply here; this happens when parsing a class which\n\t   is local to a function.  */\n\tif (typed_name-\u003etype == DEMANGLE_COMPONENT_LOCAL_NAME)\n\t  {\n\t    struct demangle_component *local_name;\n\n\t    local_name = d_right (typed_name);\n\t    if (local_name-\u003etype == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t      local_name = local_name-\u003eu.s_unary_num.sub;\n\t    if (local_name == NULL)\n\t      {\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\t    while (local_name-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t\t   || (local_name-\u003etype\n\t\t       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))\n\t      {\n\t\tif (i \u003e= sizeof adpm / sizeof adpm[0])\n\t\t  {\n\t\t    d_print_error (dpi);\n\t\t    return;\n\t\t  }\n\n\t\tadpm[i] = adpm[i - 1];\n\t\tadpm[i].next = \u0026adpm[i - 1];\n\t\tdpi-\u003emodifiers = \u0026adpm[i];\n\n\t\tadpm[i - 1].mod = local_name;\n\t\tadpm[i - 1].printed = 0;\n\t\tadpm[i - 1].templates = dpi-\u003etemplates;\n\t\t++i;\n\n\t\tlocal_name = d_left (local_name);\n\t      }\n\t  }\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\tif (typed_name-\u003etype == DEMANGLE_COMPONENT_TEMPLATE)\n\t  dpi-\u003etemplates = dpt.next;\n\n\t/* If the modifiers didn't get printed by the type, print them\n\t   now.  */\n\twhile (i \u003e 0)\n\t  {\n\t    --i;\n\t    if (! adpm[i].printed)\n\t      {\n\t\td_append_char (dpi, ' ');\n\t\td_print_mod (dpi, options, adpm[i].mod);\n\t      }\n\t  }\n\n\tdpi-\u003emodifiers = hold_modifiers;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_TEMPLATE:\n      {\n\tstruct d_print_mod *hold_dpm;\n\tstruct demangle_component *dcl;\n\tconst struct demangle_component *hold_current;\n\n\t/* This template may need to be referenced by a cast operator\n\t   contained in its subtree.  */\n\thold_current = dpi-\u003ecurrent_template;\n\tdpi-\u003ecurrent_template = dc;\n\n\t/* Don't push modifiers into a template definition.  Doing so\n\t   could give the wrong definition for a template argument.\n\t   Instead, treat the template essentially as a name.  */\n\n\thold_dpm = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = NULL;\n\n        dcl = d_left (dc);\n\n        if ((options \u0026 DMGL_JAVA) != 0\n            \u0026\u0026 dcl-\u003etype == DEMANGLE_COMPONENT_NAME\n            \u0026\u0026 dcl-\u003eu.s_name.len == 6\n            \u0026\u0026 strncmp (dcl-\u003eu.s_name.s, \"JArray\", 6) == 0)\n          {\n            /* Special-case Java arrays, so that JArray\u003cTYPE\u003e appears\n               instead as TYPE[].  */\n\n            d_print_comp (dpi, options, d_right (dc));\n            d_append_string (dpi, \"[]\");\n          }\n        else\n          {\n\t    d_print_comp (dpi, options, dcl);\n\t    if (d_last_char (dpi) == '\u003c')\n\t      d_append_char (dpi, ' ');\n\t    d_append_char (dpi, '\u003c');\n\t    d_print_comp (dpi, options, d_right (dc));\n\t    /* Avoid generating two consecutive '\u003e' characters, to avoid\n\t       the C++ syntactic ambiguity.  */\n\t    if (d_last_char (dpi) == '\u003e')\n\t      d_append_char (dpi, ' ');\n\t    d_append_char (dpi, '\u003e');\n          }\n\n\tdpi-\u003emodifiers = hold_dpm;\n\tdpi-\u003ecurrent_template = hold_current;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n      if (dpi-\u003eis_lambda_arg)\n\t{\n\t  /* Show the template parm index, as that's how g++ displays\n\t     these, and future proofs us against potential\n\t     '[]\u003ctypename T\u003e (T *a, T *b) {...}'.  */\n\t  d_append_buffer (dpi, \"auto:\", 5);\n\t  d_append_num (dpi, dc-\u003eu.s_number.number + 1);\n\t}\n      else\n\t{\n\t  struct d_print_template *hold_dpt;\n\t  struct demangle_component *a = d_lookup_template_argument (dpi, dc);\n\n\t  if (a \u0026\u0026 a-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\t    a = d_index_template_argument (a, dpi-\u003epack_index);\n\n\t  if (a == NULL)\n\t    {\n\t      d_print_error (dpi);\n\t      return;\n\t    }\n\n\t  /* While processing this parameter, we need to pop the list\n\t     of templates.  This is because the template parameter may\n\t     itself be a reference to a parameter of an outer\n\t     template.  */\n\n\t  hold_dpt = dpi-\u003etemplates;\n\t  dpi-\u003etemplates = hold_dpt-\u003enext;\n\n\t  d_print_comp (dpi, options, a);\n\n\t  dpi-\u003etemplates = hold_dpt;\n\t}\n      return;\n\n    case DEMANGLE_COMPONENT_CTOR:\n      d_print_comp (dpi, options, dc-\u003eu.s_ctor.name);\n      return;\n\n    case DEMANGLE_COMPONENT_DTOR:\n      d_append_char (dpi, '~');\n      d_print_comp (dpi, options, dc-\u003eu.s_dtor.name);\n      return;\n\n    case DEMANGLE_COMPONENT_VTABLE:\n      d_append_string (dpi, \"vtable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_VTT:\n      d_append_string (dpi, \"VTT for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n      d_append_string (dpi, \"construction vtable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \"-in-\");\n      d_print_comp (dpi, options, d_right (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO:\n      d_append_string (dpi, \"typeinfo for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n      d_append_string (dpi, \"typeinfo name for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n      d_append_string (dpi, \"typeinfo fn for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_THUNK:\n      d_append_string (dpi, \"non-virtual thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n      d_append_string (dpi, \"virtual thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n      d_append_string (dpi, \"covariant return thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n      d_append_string (dpi, \"java Class for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_GUARD:\n      d_append_string (dpi, \"guard variable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TLS_INIT:\n      d_append_string (dpi, \"TLS init function for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n      d_append_string (dpi, \"TLS wrapper function for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_REFTEMP:\n      d_append_string (dpi, \"reference temporary #\");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_string (dpi, \" for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n      d_append_string (dpi, \"hidden alias for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n      d_append_string (dpi, \"transaction clone for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n      d_append_string (dpi, \"non-transaction clone for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_SUB_STD:\n      d_append_buffer (dpi, dc-\u003eu.s_string.string, dc-\u003eu.s_string.len);\n      return;\n\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n      {\n\tstruct d_print_mod *pdpm;\n\n\t/* When printing arrays, it's possible to have cases where the\n\t   same CV-qualifier gets pushed on the stack multiple times.\n\t   We only need to print it once.  */\n\n\tfor (pdpm = dpi-\u003emodifiers; pdpm != NULL; pdpm = pdpm-\u003enext)\n\t  {\n\t    if (! pdpm-\u003eprinted)\n\t      {\n\t\tif (pdpm-\u003emod-\u003etype != DEMANGLE_COMPONENT_RESTRICT\n\t\t    \u0026\u0026 pdpm-\u003emod-\u003etype != DEMANGLE_COMPONENT_VOLATILE\n\t\t    \u0026\u0026 pdpm-\u003emod-\u003etype != DEMANGLE_COMPONENT_CONST)\n\t\t  break;\n\t\tif (pdpm-\u003emod-\u003etype == dc-\u003etype)\n\t\t  {\n\t\t    d_print_comp (dpi, options, d_left (dc));\n\t\t    return;\n\t\t  }\n\t      }\n\t  }\n      }\n      goto modifier;\n\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      {\n\t/* Handle reference smashing: \u0026 + \u0026\u0026 = \u0026.  */\n\tconst struct demangle_component *sub = d_left (dc);\n\tif (!dpi-\u003eis_lambda_arg\n\t    \u0026\u0026 sub-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n\t  {\n\t    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);\n\t    struct demangle_component *a;\n\n\t    if (scope == NULL)\n\t      {\n\t\t/* This is the first time SUB has been traversed.\n\t\t   We need to capture the current templates so\n\t\t   they can be restored if SUB is reentered as a\n\t\t   substitution.  */\n\t\td_save_scope (dpi, sub);\n\t\tif (d_print_saw_error (dpi))\n\t\t  return;\n\t      }\n\t    else\n\t      {\n\t\tconst struct d_component_stack *dcse;\n\t\tint found_self_or_parent = 0;\n\n\t\t/* This traversal is reentering SUB as a substition.\n\t\t   If we are not beneath SUB or DC in the tree then we\n\t\t   need to restore SUB's template stack temporarily.  */\n\t\tfor (dcse = dpi-\u003ecomponent_stack; dcse != NULL;\n\t\t     dcse = dcse-\u003eparent)\n\t\t  {\n\t\t    if (dcse-\u003edc == sub\n\t\t\t|| (dcse-\u003edc == dc\n\t\t\t    \u0026\u0026 dcse != dpi-\u003ecomponent_stack))\n\t\t      {\n\t\t\tfound_self_or_parent = 1;\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\n\t\tif (!found_self_or_parent)\n\t\t  {\n\t\t    saved_templates = dpi-\u003etemplates;\n\t\t    dpi-\u003etemplates = scope-\u003etemplates;\n\t\t    need_template_restore = 1;\n\t\t  }\n\t      }\n\n\t    a = d_lookup_template_argument (dpi, sub);\n\t    if (a \u0026\u0026 a-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\t      a = d_index_template_argument (a, dpi-\u003epack_index);\n\n\t    if (a == NULL)\n\t      {\n\t\tif (need_template_restore)\n\t\t  dpi-\u003etemplates = saved_templates;\n\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    sub = a;\n\t  }\n\n\tif (sub-\u003etype == DEMANGLE_COMPONENT_REFERENCE\n\t    || sub-\u003etype == dc-\u003etype)\n\t  dc = sub;\n\telse if (sub-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE)\n\t  mod_inner = d_left (sub);\n      }\n      /* Fall through.  */\n\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    modifier:\n      {\n\t/* We keep a list of modifiers on the stack.  */\n\tstruct d_print_mod dpm;\n\n\tdpm.next = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = \u0026dpm;\n\tdpm.mod = dc;\n\tdpm.printed = 0;\n\tdpm.templates = dpi-\u003etemplates;\n\n\tif (!mod_inner)\n\t  mod_inner = d_left (dc);\n\n\td_print_comp (dpi, options, mod_inner);\n\n\t/* If the modifier didn't get printed by the type, print it\n\t   now.  */\n\tif (! dpm.printed)\n\t  d_print_mod (dpi, options, dc);\n\n\tdpi-\u003emodifiers = dpm.next;\n\n\tif (need_template_restore)\n\t  dpi-\u003etemplates = saved_templates;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_buffer (dpi, dc-\u003eu.s_builtin.type-\u003ename,\n\t\t\t dc-\u003eu.s_builtin.type-\u003elen);\n      else\n\td_append_buffer (dpi, dc-\u003eu.s_builtin.type-\u003ejava_name,\n\t\t\t dc-\u003eu.s_builtin.type-\u003ejava_len);\n      return;\n\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n      {\n\tif ((options \u0026 DMGL_RET_POSTFIX) != 0)\n\t  d_print_function_type (dpi,\n\t\t\t\t options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t\t dc, dpi-\u003emodifiers);\n\n\t/* Print return type if present */\n\tif (d_left (dc) != NULL \u0026\u0026 (options \u0026 DMGL_RET_POSTFIX) != 0)\n\t  d_print_comp (dpi, options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\td_left (dc));\n\telse if (d_left (dc) != NULL \u0026\u0026 (options \u0026 DMGL_RET_DROP) == 0)\n\t  {\n\t    struct d_print_mod dpm;\n\n\t    /* We must pass this type down as a modifier in order to\n\t       print it in the right location.  */\n\t    dpm.next = dpi-\u003emodifiers;\n\t    dpi-\u003emodifiers = \u0026dpm;\n\t    dpm.mod = dc;\n\t    dpm.printed = 0;\n\t    dpm.templates = dpi-\u003etemplates;\n\n\t    d_print_comp (dpi, options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t  d_left (dc));\n\n\t    dpi-\u003emodifiers = dpm.next;\n\n\t    if (dpm.printed)\n\t      return;\n\n\t    /* In standard prefix notation, there is a space between the\n\t       return type and the function signature.  */\n\t    if ((options \u0026 DMGL_RET_POSTFIX) == 0)\n\t      d_append_char (dpi, ' ');\n\t  }\n\n\tif ((options \u0026 DMGL_RET_POSTFIX) == 0)\n\t  d_print_function_type (dpi,\n\t\t\t\t options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t\t dc, dpi-\u003emodifiers);\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n      {\n\tstruct d_print_mod *hold_modifiers;\n\tstruct d_print_mod adpm[4];\n\tunsigned int i;\n\tstruct d_print_mod *pdpm;\n\n\t/* We must pass this type down as a modifier in order to print\n\t   multi-dimensional arrays correctly.  If the array itself is\n\t   CV-qualified, we act as though the element type were\n\t   CV-qualified.  We do this by copying the modifiers down\n\t   rather than fiddling pointers, so that we don't wind up\n\t   with a d_print_mod higher on the stack pointing into our\n\t   stack frame after we return.  */\n\n\thold_modifiers = dpi-\u003emodifiers;\n\n\tadpm[0].next = hold_modifiers;\n\tdpi-\u003emodifiers = \u0026adpm[0];\n\tadpm[0].mod = dc;\n\tadpm[0].printed = 0;\n\tadpm[0].templates = dpi-\u003etemplates;\n\n\ti = 1;\n\tpdpm = hold_modifiers;\n\twhile (pdpm != NULL\n\t       \u0026\u0026 (pdpm-\u003emod-\u003etype == DEMANGLE_COMPONENT_RESTRICT\n\t\t   || pdpm-\u003emod-\u003etype == DEMANGLE_COMPONENT_VOLATILE\n\t\t   || pdpm-\u003emod-\u003etype == DEMANGLE_COMPONENT_CONST))\n\t  {\n\t    if (! pdpm-\u003eprinted)\n\t      {\n\t\tif (i \u003e= sizeof adpm / sizeof adpm[0])\n\t\t  {\n\t\t    d_print_error (dpi);\n\t\t    return;\n\t\t  }\n\n\t\tadpm[i] = *pdpm;\n\t\tadpm[i].next = dpi-\u003emodifiers;\n\t\tdpi-\u003emodifiers = \u0026adpm[i];\n\t\tpdpm-\u003eprinted = 1;\n\t\t++i;\n\t      }\n\n\t    pdpm = pdpm-\u003enext;\n\t  }\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\tdpi-\u003emodifiers = hold_modifiers;\n\n\tif (adpm[0].printed)\n\t  return;\n\n\twhile (i \u003e 1)\n\t  {\n\t    --i;\n\t    d_print_mod (dpi, options, adpm[i].mod);\n\t  }\n\n\td_print_array_type (dpi, options, dc, dpi-\u003emodifiers);\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n      {\n\tstruct d_print_mod dpm;\n\n\tdpm.next = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = \u0026dpm;\n\tdpm.mod = dc;\n\tdpm.printed = 0;\n\tdpm.templates = dpi-\u003etemplates;\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\t/* If the modifier didn't get printed by the type, print it\n\t   now.  */\n\tif (! dpm.printed)\n\t  d_print_mod (dpi, options, dc);\n\n\tdpi-\u003emodifiers = dpm.next;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_FIXED_TYPE:\n      if (dc-\u003eu.s_fixed.sat)\n\td_append_string (dpi, \"_Sat \");\n      /* Don't print \"int _Accum\".  */\n      if (dc-\u003eu.s_fixed.length-\u003eu.s_builtin.type\n\t  != \u0026cplus_demangle_builtin_types['i'-'a'])\n\t{\n\t  d_print_comp (dpi, options, dc-\u003eu.s_fixed.length);\n\t  d_append_char (dpi, ' ');\n\t}\n      if (dc-\u003eu.s_fixed.accum)\n\td_append_string (dpi, \"_Accum\");\n      else\n\td_append_string (dpi, \"_Fract\");\n      return;\n\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n      if (d_left (dc) != NULL)\n\td_print_comp (dpi, options, d_left (dc));\n      if (d_right (dc) != NULL)\n\t{\n\t  size_t len;\n\t  unsigned long int flush_count;\n\t  /* Make sure \", \" isn't flushed by d_append_string, otherwise\n\t     dpi-\u003elen -= 2 wouldn't work.  */\n\t  if (dpi-\u003elen \u003e= sizeof (dpi-\u003ebuf) - 2)\n\t    d_print_flush (dpi);\n\t  d_append_string (dpi, \", \");\n\t  len = dpi-\u003elen;\n\t  flush_count = dpi-\u003eflush_count;\n\t  d_print_comp (dpi, options, d_right (dc));\n\t  /* If that didn't print anything (which can happen with empty\n\t     template argument packs), remove the comma and space.  */\n\t  if (dpi-\u003eflush_count == flush_count \u0026\u0026 dpi-\u003elen == len)\n\t    dpi-\u003elen -= 2;\n\t}\n      return;\n\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      {\n\tstruct demangle_component *type = d_left (dc);\n\tstruct demangle_component *list = d_right (dc);\n\n\tif (type)\n\t  d_print_comp (dpi, options, type);\n\td_append_char (dpi, '{');\n\td_print_comp (dpi, options, list);\n\td_append_char (dpi, '}');\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_OPERATOR:\n      {\n\tconst struct demangle_operator_info *op = dc-\u003eu.s_operator.op;\n\tint len = op-\u003elen;\n\n\td_append_string (dpi, \"operator\");\n\t/* Add a space before new/delete.  */\n\tif (IS_LOWER (op-\u003ename[0]))\n\t  d_append_char (dpi, ' ');\n\t/* Omit a trailing space.  */\n\tif (op-\u003ename[len-1] == ' ')\n\t  --len;\n\td_append_buffer (dpi, op-\u003ename, len);\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n      d_append_string (dpi, \"operator \");\n      d_print_comp (dpi, options, dc-\u003eu.s_extended_operator.name);\n      return;\n\n    case DEMANGLE_COMPONENT_CONVERSION:\n      d_append_string (dpi, \"operator \");\n      d_print_conversion (dpi, options, dc);\n      return;\n\n    case DEMANGLE_COMPONENT_NULLARY:\n      d_print_expr_op (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_UNARY:\n      {\n\tstruct demangle_component *op = d_left (dc);\n\tstruct demangle_component *operand = d_right (dc);\n\tconst char *code = NULL;\n\n\tif (op-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n\t  {\n\t    code = op-\u003eu.s_operator.op-\u003ecode;\n\t    if (!strcmp (code, \"ad\"))\n\t      {\n\t\t/* Don't print the argument list for the address of a\n\t\t   function.  */\n\t\tif (operand-\u003etype == DEMANGLE_COMPONENT_TYPED_NAME\n\t\t    \u0026\u0026 d_left (operand)-\u003etype == DEMANGLE_COMPONENT_QUAL_NAME\n\t\t    \u0026\u0026 d_right (operand)-\u003etype == DEMANGLE_COMPONENT_FUNCTION_TYPE)\n\t\t  operand = d_left (operand);\n\t      }\n\t    if (operand-\u003etype == DEMANGLE_COMPONENT_BINARY_ARGS)\n\t      {\n\t\t/* This indicates a suffix operator.  */\n\t\toperand = d_left (operand);\n\t\td_print_subexpr (dpi, options, operand);\n\t\td_print_expr_op (dpi, options, op);\n\t\treturn;\n\t      }\n\t  }\n\n\t/* For sizeof..., just print the pack length.  */\n\tif (code \u0026\u0026 !strcmp (code, \"sZ\"))\n\t  {\n\t    struct demangle_component *a = d_find_pack (dpi, operand);\n\t    int len = d_pack_length (a);\n\t    d_append_num (dpi, len);\n\t    return;\n\t  }\n\telse if (code \u0026\u0026 !strcmp (code, \"sP\"))\n\t  {\n\t    int len = d_args_length (dpi, operand);\n\t    d_append_num (dpi, len);\n\t    return;\n\t  }\n\n\tif (op-\u003etype != DEMANGLE_COMPONENT_CAST)\n\t  d_print_expr_op (dpi, options, op);\n\telse\n\t  {\n\t    d_append_char (dpi, '(');\n\t    d_print_cast (dpi, options, op);\n\t    d_append_char (dpi, ')');\n\t  }\n\tif (code \u0026\u0026 !strcmp (code, \"gs\"))\n\t  /* Avoid parens after '::'.  */\n\t  d_print_comp (dpi, options, operand);\n\telse if (code \u0026\u0026 !strcmp (code, \"st\"))\n\t  /* Always print parens for sizeof (type).  */\n\t  {\n\t    d_append_char (dpi, '(');\n\t    d_print_comp (dpi, options, operand);\n\t    d_append_char (dpi, ')');\n\t  }\n\telse\n\t  d_print_subexpr (dpi, options, operand);\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_BINARY:\n      if (d_right (dc)-\u003etype != DEMANGLE_COMPONENT_BINARY_ARGS)\n\t{\n\t  d_print_error (dpi);\n\t  return;\n\t}\n\n      if (op_is_new_cast (d_left (dc)))\n\t{\n\t  d_print_expr_op (dpi, options, d_left (dc));\n\t  d_append_char (dpi, '\u003c');\n\t  d_print_comp (dpi, options, d_left (d_right (dc)));\n\t  d_append_string (dpi, \"\u003e(\");\n\t  d_print_comp (dpi, options, d_right (d_right (dc)));\n\t  d_append_char (dpi, ')');\n\t  return;\n\t}\n\n      if (d_maybe_print_fold_expression (dpi, options, dc))\n\treturn;\n\n      /* We wrap an expression which uses the greater-than operator in\n\t an extra layer of parens so that it does not get confused\n\t with the '\u003e' which ends the template parameters.  */\n      if (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_OPERATOR\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003elen == 1\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003ename[0] == '\u003e')\n\td_append_char (dpi, '(');\n\n      if (strcmp (d_left (dc)-\u003eu.s_operator.op-\u003ecode, \"cl\") == 0\n          \u0026\u0026 d_left (d_right (dc))-\u003etype == DEMANGLE_COMPONENT_TYPED_NAME)\n\t{\n\t  /* Function call used in an expression should not have printed types\n\t     of the function arguments.  Values of the function arguments still\n\t     get printed below.  */\n\n\t  const struct demangle_component *func = d_left (d_right (dc));\n\n\t  if (d_right (func)-\u003etype != DEMANGLE_COMPONENT_FUNCTION_TYPE)\n\t    d_print_error (dpi);\n\t  d_print_subexpr (dpi, options, d_left (func));\n\t}\n      else\n\td_print_subexpr (dpi, options, d_left (d_right (dc)));\n      if (strcmp (d_left (dc)-\u003eu.s_operator.op-\u003ecode, \"ix\") == 0)\n\t{\n\t  d_append_char (dpi, '[');\n\t  d_print_comp (dpi, options, d_right (d_right (dc)));\n\t  d_append_char (dpi, ']');\n\t}\n      else\n\t{\n\t  if (strcmp (d_left (dc)-\u003eu.s_operator.op-\u003ecode, \"cl\") != 0)\n\t    d_print_expr_op (dpi, options, d_left (dc));\n\t  d_print_subexpr (dpi, options, d_right (d_right (dc)));\n\t}\n\n      if (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_OPERATOR\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003elen == 1\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003ename[0] == '\u003e')\n\td_append_char (dpi, ')');\n\n      return;\n\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n      /* We should only see this as part of DEMANGLE_COMPONENT_BINARY.  */\n      d_print_error (dpi);\n      return;\n\n    case DEMANGLE_COMPONENT_TRINARY:\n      if (d_right (dc)-\u003etype != DEMANGLE_COMPONENT_TRINARY_ARG1\n\t  || d_right (d_right (dc))-\u003etype != DEMANGLE_COMPONENT_TRINARY_ARG2)\n\t{\n\t  d_print_error (dpi);\n\t  return;\n\t}\n      if (d_maybe_print_fold_expression (dpi, options, dc))\n\treturn;\n      {\n\tstruct demangle_component *op = d_left (dc);\n\tstruct demangle_component *first = d_left (d_right (dc));\n\tstruct demangle_component *second = d_left (d_right (d_right (dc)));\n\tstruct demangle_component *third = d_right (d_right (d_right (dc)));\n\n\tif (!strcmp (op-\u003eu.s_operator.op-\u003ecode, \"qu\"))\n\t  {\n\t    d_print_subexpr (dpi, options, first);\n\t    d_print_expr_op (dpi, options, op);\n\t    d_print_subexpr (dpi, options, second);\n\t    d_append_string (dpi, \" : \");\n\t    d_print_subexpr (dpi, options, third);\n\t  }\n\telse\n\t  {\n\t    d_append_string (dpi, \"new \");\n\t    if (d_left (first) != NULL)\n\t      {\n\t\td_print_subexpr (dpi, options, first);\n\t\td_append_char (dpi, ' ');\n\t      }\n\t    d_print_comp (dpi, options, second);\n\t    if (third)\n\t      d_print_subexpr (dpi, options, third);\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      /* We should only see these are part of DEMANGLE_COMPONENT_TRINARY.  */\n      d_print_error (dpi);\n      return;\n\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n      {\n\tenum d_builtin_type_print tp;\n\n\t/* For some builtin types, produce simpler output.  */\n\ttp = D_PRINT_DEFAULT;\n\tif (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_BUILTIN_TYPE)\n\t  {\n\t    tp = d_left (dc)-\u003eu.s_builtin.type-\u003eprint;\n\t    switch (tp)\n\t      {\n\t      case D_PRINT_INT:\n\t      case D_PRINT_UNSIGNED:\n\t      case D_PRINT_LONG:\n\t      case D_PRINT_UNSIGNED_LONG:\n\t      case D_PRINT_LONG_LONG:\n\t      case D_PRINT_UNSIGNED_LONG_LONG:\n\t\tif (d_right (dc)-\u003etype == DEMANGLE_COMPONENT_NAME)\n\t\t  {\n\t\t    if (dc-\u003etype == DEMANGLE_COMPONENT_LITERAL_NEG)\n\t\t      d_append_char (dpi, '-');\n\t\t    d_print_comp (dpi, options, d_right (dc));\n\t\t    switch (tp)\n\t\t      {\n\t\t      default:\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED:\n\t\t\td_append_char (dpi, 'u');\n\t\t\tbreak;\n\t\t      case D_PRINT_LONG:\n\t\t\td_append_char (dpi, 'l');\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED_LONG:\n\t\t\td_append_string (dpi, \"ul\");\n\t\t\tbreak;\n\t\t      case D_PRINT_LONG_LONG:\n\t\t\td_append_string (dpi, \"ll\");\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED_LONG_LONG:\n\t\t\td_append_string (dpi, \"ull\");\n\t\t\tbreak;\n\t\t      }\n\t\t    return;\n\t\t  }\n\t\tbreak;\n\n\t      case D_PRINT_BOOL:\n\t\tif (d_right (dc)-\u003etype == DEMANGLE_COMPONENT_NAME\n\t\t    \u0026\u0026 d_right (dc)-\u003eu.s_name.len == 1\n\t\t    \u0026\u0026 dc-\u003etype == DEMANGLE_COMPONENT_LITERAL)\n\t\t  {\n\t\t    switch (d_right (dc)-\u003eu.s_name.s[0])\n\t\t      {\n\t\t      case '0':\n\t\t\td_append_string (dpi, \"false\");\n\t\t\treturn;\n\t\t      case '1':\n\t\t\td_append_string (dpi, \"true\");\n\t\t\treturn;\n\t\t      default:\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t      }\n\t  }\n\n\td_append_char (dpi, '(');\n\td_print_comp (dpi, options, d_left (dc));\n\td_append_char (dpi, ')');\n\tif (dc-\u003etype == DEMANGLE_COMPONENT_LITERAL_NEG)\n\t  d_append_char (dpi, '-');\n\tif (tp == D_PRINT_FLOAT)\n\t  d_append_char (dpi, '[');\n\td_print_comp (dpi, options, d_right (dc));\n\tif (tp == D_PRINT_FLOAT)\n\t  d_append_char (dpi, ']');\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_NUMBER:\n      d_append_num (dpi, dc-\u003eu.s_number.number);\n      return;\n\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n      d_append_string (dpi, \"java resource \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      d_print_comp (dpi, options, d_right (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_CHARACTER:\n      d_append_char (dpi, dc-\u003eu.s_character.character);\n      return;\n\n    case DEMANGLE_COMPONENT_DECLTYPE:\n      d_append_string (dpi, \"decltype (\");\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_char (dpi, ')');\n      return;\n\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n      {\n\tint len;\n\tint i;\n\tstruct demangle_component *a = d_find_pack (dpi, d_left (dc));\n\tif (a == NULL)\n\t  {\n\t    /* d_find_pack won't find anything if the only packs involved\n\t       in this expansion are function parameter packs; in that\n\t       case, just print the pattern and \"...\".  */\n\t    d_print_subexpr (dpi, options, d_left (dc));\n\t    d_append_string (dpi, \"...\");\n\t    return;\n\t  }\n\n\tlen = d_pack_length (a);\n\tdc = d_left (dc);\n\tfor (i = 0; i \u003c len; ++i)\n\t  {\n\t    dpi-\u003epack_index = i;\n\t    d_print_comp (dpi, options, dc);\n\t    if (i \u003c len-1)\n\t      d_append_string (dpi, \", \");\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n      {\n\tlong num = dc-\u003eu.s_number.number;\n\tif (num == 0)\n\t  d_append_string (dpi, \"this\");\n\telse\n\t  {\n\t    d_append_string (dpi, \"{parm#\");\n\t    d_append_num (dpi, num);\n\t    d_append_char (dpi, '}');\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n      d_append_string (dpi, \"global constructors keyed to \");\n      d_print_comp (dpi, options, dc-\u003eu.s_binary.left);\n      return;\n\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n      d_append_string (dpi, \"global destructors keyed to \");\n      d_print_comp (dpi, options, dc-\u003eu.s_binary.left);\n      return;\n\n    case DEMANGLE_COMPONENT_LAMBDA:\n      d_append_string (dpi, \"{lambda(\");\n      /* Generic lambda auto parms are mangled as the template type\n\t parm they are.  */\n      dpi-\u003eis_lambda_arg++;\n      d_print_comp (dpi, options, dc-\u003eu.s_unary_num.sub);\n      dpi-\u003eis_lambda_arg--;\n      d_append_string (dpi, \")#\");\n      d_append_num (dpi, dc-\u003eu.s_unary_num.num + 1);\n      d_append_char (dpi, '}');\n      return;\n\n    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n      d_append_string (dpi, \"{unnamed type#\");\n      d_append_num (dpi, dc-\u003eu.s_number.number + 1);\n      d_append_char (dpi, '}');\n      return;\n\n    case DEMANGLE_COMPONENT_CLONE:\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \" [clone \");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_char (dpi, ']');\n      return;\n\n    default:\n      d_print_error (dpi);\n      return;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":4493,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5288304":{"score":0.6298891,"function_name":"d_print_comp","code":"static void\nd_print_comp (struct d_print_info *dpi, int options,\n\t      const struct demangle_component *dc)\n{\n  struct d_component_stack self;\n\n  self.dc = dc;\n  self.parent = dpi-\u003ecomponent_stack;\n  dpi-\u003ecomponent_stack = \u0026self;\n\n  d_print_comp_inner (dpi, options, dc);\n\n  dpi-\u003ecomponent_stack = self.parent;\n}","filepath":"libiberty/cp-demangle.c","line_number":5601,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5288400":{"score":0.71355456,"function_name":"d_print_mod","code":"static void\nd_print_mod (struct d_print_info *dpi, int options,\n             const struct demangle_component *mod)\n{\n  switch (mod-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n      d_append_string (dpi, \" restrict\");\n      return;\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n      d_append_string (dpi, \" volatile\");\n      return;\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n      d_append_string (dpi, \" const\");\n      return;\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n      d_append_string (dpi, \" transaction_safe\");\n      return;\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n      d_append_char (dpi, ' ');\n      d_print_comp (dpi, options, d_right (mod));\n      return;\n    case DEMANGLE_COMPONENT_POINTER:\n      /* There is no pointer symbol in Java.  */\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_char (dpi, '*');\n      return;\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n      /* For the ref-qualifier, put a space before the \u0026.  */\n      d_append_char (dpi, ' ');\n    case DEMANGLE_COMPONENT_REFERENCE:\n      d_append_char (dpi, '\u0026');\n      return;\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n      d_append_char (dpi, ' ');\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      d_append_string (dpi, \"\u0026\u0026\");\n      return;\n    case DEMANGLE_COMPONENT_COMPLEX:\n      d_append_string (dpi, \"complex \");\n      return;\n    case DEMANGLE_COMPONENT_IMAGINARY:\n      d_append_string (dpi, \"imaginary \");\n      return;\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n      if (d_last_char (dpi) != '(')\n\td_append_char (dpi, ' ');\n      d_print_comp (dpi, options, d_left (mod));\n      d_append_string (dpi, \"::*\");\n      return;\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n      d_print_comp (dpi, options, d_left (mod));\n      return;\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n      d_append_string (dpi, \" __vector(\");\n      d_print_comp (dpi, options, d_left (mod));\n      d_append_char (dpi, ')');\n      return;\n\n    default:\n      /* Otherwise, we have something that won't go back on the\n\t modifier stack, so we can just print it.  */\n      d_print_comp (dpi, options, mod);\n      return;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":5764,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5290416":{"score":0.7553977,"function_name":"d_print_array_type","code":"static void\nd_print_array_type (struct d_print_info *dpi, int options,\n                    const struct demangle_component *dc,\n                    struct d_print_mod *mods)\n{\n  int need_space;\n\n  need_space = 1;\n  if (mods != NULL)\n    {\n      int need_paren;\n      struct d_print_mod *p;\n\n      need_paren = 0;\n      for (p = mods; p != NULL; p = p-\u003enext)\n\t{\n\t  if (! p-\u003eprinted)\n\t    {\n\t      if (p-\u003emod-\u003etype == DEMANGLE_COMPONENT_ARRAY_TYPE)\n\t\t{\n\t\t  need_space = 0;\n\t\t  break;\n\t\t}\n\t      else\n\t\t{\n\t\t  need_paren = 1;\n\t\t  need_space = 1;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (need_paren)\n\td_append_string (dpi, \" (\");\n\n      d_print_mod_list (dpi, options, mods, 0);\n\n      if (need_paren)\n\td_append_char (dpi, ')');\n    }\n\n  if (need_space)\n    d_append_char (dpi, ' ');\n\n  d_append_char (dpi, '[');\n\n  if (d_left (dc) != NULL)\n    d_print_comp (dpi, options, d_left (dc));\n\n  d_append_char (dpi, ']');\n}","filepath":"libiberty/cp-demangle.c","line_number":5919,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5291184":{"score":0.812752,"function_name":"d_print_mod_list","code":"static void\nd_print_mod_list (struct d_print_info *dpi, int options,\n                  struct d_print_mod *mods, int suffix)\n{\n  struct d_print_template *hold_dpt;\n\n  if (mods == NULL || d_print_saw_error (dpi))\n    return;\n\n  if (mods-\u003eprinted\n      || (! suffix\n\t  \u0026\u0026 (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t      || (mods-\u003emod-\u003etype\n\t\t  == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))))\n    {\n      d_print_mod_list (dpi, options, mods-\u003enext, suffix);\n      return;\n    }\n\n  mods-\u003eprinted = 1;\n\n  hold_dpt = dpi-\u003etemplates;\n  dpi-\u003etemplates = mods-\u003etemplates;\n\n  if (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_FUNCTION_TYPE)\n    {\n      d_print_function_type (dpi, options, mods-\u003emod, mods-\u003enext);\n      dpi-\u003etemplates = hold_dpt;\n      return;\n    }\n  else if (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_ARRAY_TYPE)\n    {\n      d_print_array_type (dpi, options, mods-\u003emod, mods-\u003enext);\n      dpi-\u003etemplates = hold_dpt;\n      return;\n    }\n  else if (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_LOCAL_NAME)\n    {\n      struct d_print_mod *hold_modifiers;\n      struct demangle_component *dc;\n\n      /* When this is on the modifier stack, we have pulled any\n\t qualifiers off the right argument already.  Otherwise, we\n\t print it as usual, but don't let the left argument see any\n\t modifiers.  */\n\n      hold_modifiers = dpi-\u003emodifiers;\n      dpi-\u003emodifiers = NULL;\n      d_print_comp (dpi, options, d_left (mods-\u003emod));\n      dpi-\u003emodifiers = hold_modifiers;\n\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_string (dpi, \"::\");\n      else\n\td_append_char (dpi, '.');\n\n      dc = d_right (mods-\u003emod);\n\n      if (dc-\u003etype == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t{\n\t  d_append_string (dpi, \"{default arg#\");\n\t  d_append_num (dpi, dc-\u003eu.s_unary_num.num + 1);\n\t  d_append_string (dpi, \"}::\");\n\t  dc = dc-\u003eu.s_unary_num.sub;\n\t}\n\n      while (dc-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n\tdc = d_left (dc);\n\n      d_print_comp (dpi, options, dc);\n\n      dpi-\u003etemplates = hold_dpt;\n      return;\n    }\n\n  d_print_mod (dpi, options, mods-\u003emod);\n\n  dpi-\u003etemplates = hold_dpt;\n\n  d_print_mod_list (dpi, options, mods-\u003enext, suffix);\n}","filepath":"libiberty/cp-demangle.c","line_number":5671,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5292416":{"score":0.7937829,"function_name":"d_print_function_type","code":"static void\nd_print_function_type (struct d_print_info *dpi, int options,\n                       const struct demangle_component *dc,\n                       struct d_print_mod *mods)\n{\n  int need_paren;\n  int need_space;\n  struct d_print_mod *p;\n  struct d_print_mod *hold_modifiers;\n\n  need_paren = 0;\n  need_space = 0;\n  for (p = mods; p != NULL; p = p-\u003enext)\n    {\n      if (p-\u003eprinted)\n\tbreak;\n\n      switch (p-\u003emod-\u003etype)\n\t{\n\tcase DEMANGLE_COMPONENT_POINTER:\n\tcase DEMANGLE_COMPONENT_REFERENCE:\n\tcase DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n\t  need_paren = 1;\n\t  break;\n\tcase DEMANGLE_COMPONENT_RESTRICT:\n\tcase DEMANGLE_COMPONENT_VOLATILE:\n\tcase DEMANGLE_COMPONENT_CONST:\n\tcase DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n\tcase DEMANGLE_COMPONENT_COMPLEX:\n\tcase DEMANGLE_COMPONENT_IMAGINARY:\n\tcase DEMANGLE_COMPONENT_PTRMEM_TYPE:\n\t  need_space = 1;\n\t  need_paren = 1;\n\t  break;\n\tcase DEMANGLE_COMPONENT_RESTRICT_THIS:\n\tcase DEMANGLE_COMPONENT_VOLATILE_THIS:\n\tcase DEMANGLE_COMPONENT_CONST_THIS:\n\tcase DEMANGLE_COMPONENT_REFERENCE_THIS:\n\tcase DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n\tcase DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      if (need_paren)\n\tbreak;\n    }\n\n  if (need_paren)\n    {\n      if (! need_space)\n\t{\n\t  if (d_last_char (dpi) != '('\n\t      \u0026\u0026 d_last_char (dpi) != '*')\n\t    need_space = 1;\n\t}\n      if (need_space \u0026\u0026 d_last_char (dpi) != ' ')\n\td_append_char (dpi, ' ');\n      d_append_char (dpi, '(');\n    }\n\n  hold_modifiers = dpi-\u003emodifiers;\n  dpi-\u003emodifiers = NULL;\n\n  d_print_mod_list (dpi, options, mods, 0);\n\n  if (need_paren)\n    d_append_char (dpi, ')');\n\n  d_append_char (dpi, '(');\n\n  if (d_right (dc) != NULL)\n    d_print_comp (dpi, options, d_right (dc));\n\n  d_append_char (dpi, ')');\n\n  d_print_mod_list (dpi, options, mods, 1);\n\n  dpi-\u003emodifiers = hold_modifiers;\n}","filepath":"libiberty/cp-demangle.c","line_number":5836,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5293248":{"score":0.5438171,"function_name":"d_print_expr_op","code":"static void\nd_print_expr_op (struct d_print_info *dpi, int options,\n                 const struct demangle_component *dc)\n{\n  if (dc-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n    d_append_buffer (dpi, dc-\u003eu.s_operator.op-\u003ename,\n\t\t     dc-\u003eu.s_operator.op-\u003elen);\n  else\n    d_print_comp (dpi, options, dc);\n}","filepath":"libiberty/cp-demangle.c","line_number":5973,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5293504":{"score":0.65208125,"function_name":"d_print_subexpr","code":"static void\nd_print_subexpr (struct d_print_info *dpi, int options,\n\t\t const struct demangle_component *dc)\n{\n  int simple = 0;\n  if (dc-\u003etype == DEMANGLE_COMPONENT_NAME\n      || dc-\u003etype == DEMANGLE_COMPONENT_QUAL_NAME\n      || dc-\u003etype == DEMANGLE_COMPONENT_INITIALIZER_LIST\n      || dc-\u003etype == DEMANGLE_COMPONENT_FUNCTION_PARAM)\n    simple = 1;\n  if (!simple)\n    d_append_char (dpi, '(');\n  d_print_comp (dpi, options, dc);\n  if (!simple)\n    d_append_char (dpi, ')');\n}","filepath":"libiberty/cp-demangle.c","line_number":4354,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5295312":{"score":0.713784,"function_name":"__cxa_demangle","code":"char *\n__cxa_demangle (const char *mangled_name, char *output_buffer,\n                size_t *length, int *status)\n{\n  char *demangled;\n  size_t alc;\n\n  if (mangled_name == NULL)\n    {\n      if (status != NULL)\n\t*status = -3;\n      return NULL;\n    }\n\n  if (output_buffer != NULL \u0026\u0026 length == NULL)\n    {\n      if (status != NULL)\n\t*status = -3;\n      return NULL;\n    }\n\n  demangled = d_demangle (mangled_name, DMGL_PARAMS | DMGL_TYPES, \u0026alc);\n\n  if (demangled == NULL)\n    {\n      if (status != NULL)\n\t{\n\t  if (alc == 1)\n\t    *status = -1;\n\t  else\n\t    *status = -2;\n\t}\n      return NULL;\n    }\n\n  if (output_buffer == NULL)\n    {\n      if (length != NULL)\n\t*length = alc;\n    }\n  else\n    {\n      if (strlen (demangled) \u003c *length)\n\t{\n\t  strcpy (output_buffer, demangled);\n\t  free (demangled);\n\t  demangled = output_buffer;\n\t}\n      else\n\t{\n\t  free (output_buffer);\n\t  *length = alc;\n\t}\n    }\n\n  if (status != NULL)\n    *status = 0;\n\n  return demangled;\n}","filepath":"libiberty/cp-demangle.c","line_number":6220,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5295712":{"score":0.6762104,"function_name":"__gcclibcxx_demangle_callback","code":"int\n__gcclibcxx_demangle_callback (const char *mangled_name,\n                               void (*callback) (const char *, size_t, void *),\n                               void *opaque)\n{\n  int status;\n\n  if (mangled_name == NULL || callback == NULL)\n    return -3;\n\n  status = d_demangle_callback (mangled_name, DMGL_PARAMS | DMGL_TYPES,\n                                callback, opaque);\n  if (status == 0)\n    return -2;\n\n  return 0;\n}","filepath":"libiberty/cp-demangle.c","line_number":6305,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-6.3.0"},"5297280":{"score":0.67479694,"function_name":"_M_copy","code":"static void\n      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::copy(__d, __s, __n);\n      }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":398,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5297344":{"score":0.69004047,"function_name":"_S_assign","code":"_GLIBCXX20_CONSTEXPR\n      static void\n      _S_assign(_CharT* __d, size_type __n, _CharT __c)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, __c);\n\telse\n\t  traits_type::assign(__d, __n, __c);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":436,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5297520":{"score":0.8275262,"function_name":"_S_compare","code":"static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d \u003e __gnu_cxx::__numeric_traits\u003cint\u003e::__max)\n\t  return __gnu_cxx::__numeric_traits\u003cint\u003e::__max;\n\telse if (__d \u003c __gnu_cxx::__numeric_traits\u003cint\u003e::__min)\n\t  return __gnu_cxx::__numeric_traits\u003cint\u003e::__min;\n\telse\n\t  return int(__d);\n      }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":453,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5297920":{"score":0.73173773,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    copy","code":"typename basic_string\u003c_CharT, _Traits, _Alloc\u003e::size_type\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    copy(_CharT* __s, size_type __n, size_type __pos) const\n    {\n      _M_check(__pos, \"basic_string::copy\");\n      __n = _M_limit(__pos, __n);\n      __glibcxx_requires_string_len(__s, __n);\n      if (__n)\n\t_M_copy(__s, _M_data() + __pos, __n);\n      // 21.3.5.7 par 3: do not append null.  (good.)\n      return __n;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3642,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5300048":{"score":0.66911185,"function_name":"_If_sv\u003c_Tp, int\u003e\n\tcompare","code":"_GLIBCXX20_CONSTEXPR\n\t_If_sv\u003c_Tp, int\u003e\n\tcompare(size_type __pos1, size_type __n1, const _Tp\u0026 __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same\u003c_Tp, __sv_type\u003e::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":3206,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5300864":{"score":0.657001,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::_Rep::\n    _S_create","code":"typename basic_string\u003c_CharT, _Traits, _Alloc\u003e::_Rep*\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::_Rep::\n    _S_create(size_type __capacity, size_type __old_capacity,\n\t      const _Alloc\u0026 __alloc)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 83.  String::npos vs. string::max_size()\n      if (__capacity \u003e _S_max_size)\n\t__throw_length_error(__N(\"basic_string::_S_create\"));\n\n      // The standard places no restriction on allocating more memory\n      // than is strictly needed within this layer at the moment or as\n      // requested by an explicit application call to reserve(n).\n\n      // Many malloc implementations perform quite poorly when an\n      // application attempts to allocate memory in a stepwise fashion\n      // growing each allocation size by only 1 char.  Additionally,\n      // it makes little sense to allocate less linear memory than the\n      // natural blocking size of the malloc implementation.\n      // Unfortunately, we would need a somewhat low-level calculation\n      // with tuned parameters to get this perfect for any particular\n      // malloc implementation.  Fortunately, generalizations about\n      // common features seen among implementations seems to suffice.\n\n      // __pagesize need not match the actual VM page size for good\n      // results in practice, thus we pick a common value on the low\n      // side.  __malloc_header_size is an estimate of the amount of\n      // overhead per memory allocation (in practice seen N * sizeof\n      // (void*) where N is 0, 2 or 4).  According to folklore,\n      // picking this value on the high side is better than\n      // low-balling it (especially when this algorithm is used with\n      // malloc implementations that allocate memory blocks rounded up\n      // to a size which is a power of 2).\n      const size_type __pagesize = 4096;\n      const size_type __malloc_header_size = 4 * sizeof(void*);\n\n      // The below implements an exponential growth policy, necessary to\n      // meet amortized linear time requirements of the library: see\n      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n      // It's active for allocations requiring an amount of memory above\n      // system pagesize. This is consistent with the requirements of the\n      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\n      if (__capacity \u003e __old_capacity \u0026\u0026 __capacity \u003c 2 * __old_capacity)\n\t__capacity = 2 * __old_capacity;\n\n      // NB: Need an array of char_type[__capacity], plus a terminating\n      // null char_type() element, plus enough for the _Rep data structure.\n      // Whew. Seemingly so needy, yet so elemental.\n      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n\n      const size_type __adj_size = __size + __malloc_header_size;\n      if (__adj_size \u003e __pagesize \u0026\u0026 __capacity \u003e __old_capacity)\n\t{\n\t  const size_type __extra = __pagesize - __adj_size % __pagesize;\n\t  __capacity += __extra / sizeof(_CharT);\n\t  // Never allocate a string bigger than _S_max_size.\n\t  if (__capacity \u003e _S_max_size)\n\t    __capacity = _S_max_size;\n\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n\t}\n\n      // NB: Might throw, but no worries about a leak, mate: _Rep()\n      // does not throw.\n      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);\n      _Rep *__p = new (__place) _Rep;\n      __p-\u003e_M_capacity = __capacity;\n      // ABI compatibility - 3.4.x set in _S_create both\n      // _M_refcount and _M_length.  All callers of _S_create\n      // in basic_string.tcc then set just _M_length.\n      // In 4.0.x and later both _M_refcount and _M_length\n      // are initialized in the callers, unfortunately we can\n      // have 3.4.x compiled code with _S_create callers inlined\n      // calling 4.0.x+ _S_create.\n      __p-\u003e_M_set_sharable();\n      return __p;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3474,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5301632":{"score":0.7226961,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_mutate","code":"void\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_mutate(size_type __pos, size_type __len1, size_type __len2)\n    {\n      const size_type __old_size = this-\u003esize();\n      const size_type __new_size = __old_size + __len2 - __len1;\n      const size_type __how_much = __old_size - __pos - __len1;\n\n      if (__new_size \u003e this-\u003ecapacity() || _M_rep()-\u003e_M_is_shared())\n\t{\n\t  // Must reallocate.\n\t  const allocator_type __a = get_allocator();\n\t  _Rep* __r = _Rep::_S_create(__new_size, this-\u003ecapacity(), __a);\n\n\t  if (__pos)\n\t    _M_copy(__r-\u003e_M_refdata(), _M_data(), __pos);\n\t  if (__how_much)\n\t    _M_copy(__r-\u003e_M_refdata() + __pos + __len2,\n\t\t    _M_data() + __pos + __len1, __how_much);\n\n\t  _M_rep()-\u003e_M_dispose(__a);\n\t  _M_data(__r-\u003e_M_refdata());\n\t}\n      else if (__how_much \u0026\u0026 __len1 != __len2)\n\t{\n\t  // Work in-place.\n\t  _M_move(_M_data() + __pos + __len2,\n\t\t  _M_data() + __pos + __len1, __how_much);\n\t}\n      _M_rep()-\u003e_M_set_length_and_sharable(__new_size);\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3387,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5302144":{"score":0.579958,"function_name":"_M_dispose","code":"void\n\t_M_dispose(const _Alloc\u0026 __a) _GLIBCXX_NOEXCEPT\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != \u0026_S_empty_rep(), false))\n#endif\n\t    {\n\t      // Be race-detector-friendly.  For more info see bits/c++config.\n\t      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(\u0026this-\u003e_M_refcount);\n\t      // Decrement of _M_refcount is acq_rel, because:\n\t      // - all but last decrements need to release to synchronize with\n\t      //   the last decrement that will delete the object.\n\t      // - the last decrement needs to acquire to synchronize with\n\t      //   all the previous decrements.\n\t      // - last but one decrement needs to release to synchronize with\n\t      //   the acquire load in _M_is_shared that will conclude that\n\t      //   the object is not shared anymore.\n\t      if (__gnu_cxx::__exchange_and_add_dispatch(\u0026this-\u003e_M_refcount,\n\t\t\t\t\t\t\t -1) \u003c= 0)\n\t\t{\n\t\t  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(\u0026this-\u003e_M_refcount);\n\t\t  _M_destroy(__a);\n\t\t}\n\t    }\n\t}","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":271,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5302560":{"score":0.7164379,"function_name":"at","code":"_GLIBCXX20_CONSTEXPR\n      reference\n      at(size_type __n)\n      {\n\tif (__n \u003e= size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) \u003e= this-\u003esize() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this-\u003esize());\n\treturn _M_data()[__n];\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1259,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5302640":{"score":0.74571425,"function_name":"erase","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      erase(size_type __pos = 0, size_type __n = npos)\n      {\n\t_M_check(__pos, \"basic_string::erase\");\n\tif (__n == npos)\n\t  this-\u003e_M_set_length(__pos);\n\telse if (__n != 0)\n\t  this-\u003e_M_erase(__pos, _M_limit(__pos, __n));\n\treturn *this;\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2030,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5302720":{"score":0.63521636,"function_name":"erase","code":"_GLIBCXX20_CONSTEXPR\n      iterator\n      erase(__const_iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position \u003e= begin()\n\t\t\t\t \u0026\u0026 __position \u003c end());\n\tconst size_type __pos = __position - begin();\n\tthis-\u003e_M_erase(__pos, size_type(1));\n\treturn iterator(_M_data() + __pos);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2050,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5302848":{"score":0.7619682,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_replace_aux","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t   _CharT __c)\n    {\n      _M_check_length(__n1, __n2, \"basic_string::_M_replace_aux\");\n      _M_mutate(__pos1, __n1, __n2);\n      if (__n2)\n\t_M_assign(_M_data() + __pos1, __n2, __c);\n      return *this;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3596,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5303056":{"score":0.555442,"function_name":"insert","code":"basic_string\u0026 \n      insert(size_type __pos1, const basic_string\u0026 __str,\n\t     size_type __pos2, size_type __n)\n      {\n\tconst size_type __strsize = __str.size();\n \tif (__pos2 \u003e __strsize)\n\t  __throw_out_of_range(\"basic_string::insert\");\n\tconst bool __testn = __n \u003c __strsize - __pos2;\n\tconst size_type __newsize = __testn ? __n : __strsize - __pos2;\n\treturn this-\u003einsert(__pos1, __str._M_data() + __pos2, __newsize); \n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":537,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-3.0.96"},"5303120":{"score":0.6563099,"function_name":"insert","code":"_GLIBCXX20_CONSTEXPR\n      iterator\n      insert(__const_iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p \u003e= begin() \u0026\u0026 __p \u003c= end());\n\tconst size_type __pos = __p - begin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\treturn iterator(_M_data() + __pos);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":1967,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5303184":{"score":0.7330666,"function_name":"replace","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      {\n\t__glibcxx_requires_string_len(__s, __n2);\n\treturn _M_replace(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t  _M_limit(__pos, __n1), __s, __n2);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2165,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5303296":{"score":0.67324424,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_replace_safe","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\n\t\t    size_type __n2)\n    {\n      _M_mutate(__pos1, __n1, __n2);\n      if (__n2)\n\t_M_copy(_M_data() + __pos1, __s, __n2);\n      return *this;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3609,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5303408":{"score":0.72297746,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    assign","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    assign(const _CharT* __s, size_type __n)\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      _M_check_length(this-\u003esize(), __n, \"basic_string::assign\");\n      if (_M_disjunct(__s) || _M_rep()-\u003e_M_is_shared())\n\treturn _M_replace_safe(size_type(0), this-\u003esize(), __s, __n);\n      else\n\t{\n\t  // Work in-place.\n\t  const size_type __pos = __s - _M_data();\n\t  if (__pos \u003e= __n)\n\t    _M_copy(_M_data(), __s, __n);\n\t  else if (__pos)\n\t    _M_move(_M_data(), __s, __n);\n\t  _M_rep()-\u003e_M_set_length_and_sharable(__n);\n\t  return *this;\n\t}\n     }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3174,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5303664":{"score":0.6870588,"function_name":"assign","code":"_If_sv\u003c_Tp, basic_string\u0026\u003e\n\tassign(const _Tp\u0026 __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return assign(__sv.data()\n\t      + std::__sv_check(__sv.size(), __pos, \"basic_string::assign\"),\n\t      std::__sv_limit(__sv.size(), __pos, __n));\n\t}","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":1473,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5303840":{"score":0.6378344,"function_name":"find_first_not_of","code":"_GLIBCXX20_CONSTEXPR\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003efind_first_not_of(__s, __pos, traits_type::length(__s));\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2997,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5303856":{"score":0.8107624,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n     insert","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n     basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n     insert(size_type __pos, const _CharT* __s, size_type __n)\n     {\n       __glibcxx_requires_string_len(__s, __n);\n       _M_check(__pos, \"basic_string::insert\");\n       _M_check_length(size_type(0), __n, \"basic_string::insert\");\n       if (_M_disjunct(__s) || _M_rep()-\u003e_M_is_shared())\n\t return _M_replace_safe(__pos, size_type(0), __s, __n);\n       else\n\t {\n\t   // Work in-place.\n\t   const size_type __off = __s - _M_data();\n\t   _M_mutate(__pos, 0, __n);\n\t   __s = _M_data() + __off;\n\t   _CharT* __p = _M_data() + __pos;\n\t   if (__s  + __n \u003c= __p)\n\t     _M_copy(__p, __s, __n);\n\t   else if (__s \u003e= __p)\n\t     _M_copy(__p, __s + __n, __n);\n\t   else\n\t     {\n\t       const size_type __nleft = __p - __s;\n\t       _M_copy(__p, __s, __nleft);\n\t       _M_copy(__p + __nleft, __p + __n, __n - __nleft);\n\t     }\n\t   return *this;\n\t }\n     }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3275,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5304304":{"score":0.70788306,"function_name":"_If_sv\u003c_Tp, basic_string\u0026\u003e\n\tinsert","code":"_GLIBCXX20_CONSTEXPR\n\t_If_sv\u003c_Tp, basic_string\u0026\u003e\n\tinsert(size_type __pos1, const _Tp\u0026 __svt,\n\t       size_type __pos2, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this-\u003ereplace(__pos1, size_type(0),\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos2, \"basic_string::insert\"),\n\t      std::__sv_limit(__sv.size(), __pos2, __n));\n\t}","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2002,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5304448":{"score":0.62455225,"function_name":"_M_check_length","code":"_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @class __versa_string vstring.h\n   *  @brief  Template class __versa_string. \n   *  @ingroup extensions\n   *\n   *  Data structure managing sequences of characters and\n   *  character-like objects. \n   */\n  template\u003ctypename _CharT, typename _Traits, typename _Alloc,\n\t   template \u003ctypename, typename, typename\u003e class _Base\u003e\n    class __versa_string\n    : private _Base\u003c_CharT, _Traits, _Alloc\u003e\n    {\n      typedef _Base\u003c_CharT, _Traits, _Alloc\u003e                __vstring_base;    \n      typedef typename __vstring_base::_CharT_alloc_type    _CharT_alloc_type;\n\n      // Types:\n    public:\n      typedef _Traits\t\t\t\t\t    traits_type;\n      typedef typename _Traits::char_type\t\t    value_type;\n      typedef _Alloc\t\t\t\t\t    allocator_type;\n      typedef typename _CharT_alloc_type::size_type\t    size_type;\n      typedef typename _CharT_alloc_type::difference_type   difference_type;\n      typedef value_type\u0026               \t            reference;\n      typedef const value_type\u0026                             const_reference;\n      typedef typename _CharT_alloc_type::pointer\t    pointer;\n      typedef typename _CharT_alloc_type::const_pointer\t    const_pointer;\n      typedef __gnu_cxx::__normal_iterator\u003cpointer, __versa_string\u003e  iterator;\n      typedef __gnu_cxx::__normal_iterator\u003cconst_pointer, __versa_string\u003e\n                                                            const_iterator;\n      typedef std::reverse_iterator\u003cconst_iterator\u003e\tconst_reverse_iterator;\n      typedef std::reverse_iterator\u003citerator\u003e\t\t    reverse_iterator;\n\n      // Data Member (public):\n      ///  Value returned by various member functions when they fail.\n      static const size_type\tnpos = static_cast\u003csize_type\u003e(-1);\n\n    private:\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos \u003e this-\u003esize())\n\t  std::__throw_out_of_range(__N(__s));\n\treturn __pos;\n      }\n\n      void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n\tif (this-\u003emax_size() - (this-\u003esize() - __n1) \u003c __n2)\n\t  std::__throw_length_error(__N(__s));\n      }\n\n      // NB: _M_limit doesn't check for a bad __pos value.\n      size_type\n      _M_limit(size_type __pos, size_type __off) const\n      {\n\tconst bool __testoff =  __off \u003c this-\u003esize() - __pos;\n\treturn __testoff ? __off : this-\u003esize() - __pos;\n      }\n\n      // True if _Rep and source do not overlap.\n      bool\n      _M_disjunct(const _CharT* __s) const\n      {\n\treturn (std::less\u003cconst _CharT*\u003e()(__s, this-\u003e_M_data())\n\t\t|| std::less\u003cconst _CharT*\u003e()(this-\u003e_M_data()\n\t\t\t\t\t      + this-\u003esize(), __s));\n      }\n\n      // For the internal use we have functions similar to `begin'/`end'\n      // but they do not call _M_leak.\n      iterator\n      _M_ibegin() const\n      { return iterator(this-\u003e_M_data()); }\n\n      iterator\n      _M_iend() const\n      { return iterator(this-\u003e_M_data() + this-\u003e_M_length()); }\n\n    public:\n      // Construct/copy/destroy:\n      // NB: We overload ctors in some cases instead of using default\n      // arguments, per 17.4.4.4 para. 2 item 2.\n\n      /**\n       *  @brief  Default constructor creates an empty string.\n       */\n      __versa_string()\n      : __vstring_base() { }\n      \n      /**\n       *  @brief  Construct an empty string using allocator @a a.\n       */\n      explicit\n      __versa_string(const _Alloc\u0026 __a)\n      : __vstring_base(__a) { }\n\n      // NB: per LWG issue 42, semantics different from IS:\n      /**\n       *  @brief  Construct string with copy of value of @a __str.\n       *  @param  __str  Source string.\n       */\n      __versa_string(const __versa_string\u0026 __str)\n      : __vstring_base(__str) { }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  String move constructor.\n       *  @param  __str  Source string.\n       *\n       *  The newly-constructed %string contains the exact contents of\n       *  @a __str.  The contents of @a __str are a valid, but unspecified\n       *  string.\n       */\n      __versa_string(__versa_string\u0026\u0026 __str) noexcept\n      : __vstring_base(std::move(__str)) { }\n\n      /**\n       *  @brief  Construct string from an initializer list.\n       *  @param  __l  std::initializer_list of characters.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      __versa_string(std::initializer_list\u003c_CharT\u003e __l,\n\t\t     const _Alloc\u0026 __a = _Alloc())\n      : __vstring_base(__l.begin(), __l.end(), __a) { }\n#endif\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy (default remainder).\n       */\n      __versa_string(const __versa_string\u0026 __str, size_type __pos,\n\t\t     size_type __n = npos)\n      : __vstring_base(__str._M_data()\n\t\t       + __str._M_check(__pos,\n\t\t\t\t\t\"__versa_string::__versa_string\"),\n\t\t       __str._M_data() + __str._M_limit(__pos, __n)\n\t\t       + __pos, _Alloc()) { }\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use.\n       */\n      __versa_string(const __versa_string\u0026 __str, size_type __pos,\n\t\t     size_type __n, const _Alloc\u0026 __a)\n      : __vstring_base(__str._M_data()\n\t\t       + __str._M_check(__pos,\n\t\t\t\t\t\"__versa_string::__versa_string\"),\n\t\t       __str._M_data() + __str._M_limit(__pos, __n)\n\t\t       + __pos, __a) { }\n\n      /**\n       *  @brief  Construct string initialized by a character array.\n       *  @param  __s  Source character array.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use (default is default allocator).\n       *\n       *  NB: @a __s must have at least @a __n characters, '\\\\0' has no special\n       *  meaning.\n       */\n      __versa_string(const _CharT* __s, size_type __n,\n\t\t     const _Alloc\u0026 __a = _Alloc())\n      : __vstring_base(__s, __s + __n, __a) { }\n\n      /**\n       *  @brief  Construct string as copy of a C string.\n       *  @param  __s  Source C string.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      __versa_string(const _CharT* __s, const _Alloc\u0026 __a = _Alloc())\n      : __vstring_base(__s, __s ? __s + traits_type::length(__s) :\n\t\t       __s + npos, __a) { }\n\n      /**\n       *  @brief  Construct string as multiple characters.\n       *  @param  __n  Number of characters.\n       *  @param  __c  Character to use.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      __versa_string(size_type __n, _CharT __c, const _Alloc\u0026 __a = _Alloc())\n      : __vstring_base(__n, __c, __a) { }\n\n      /**\n       *  @brief  Construct string as copy of a range.\n       *  @param  __beg  Start of range.\n       *  @param  __end  End of range.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template\u003cclass _InputIterator\u003e\n        __versa_string(_InputIterator __beg, _InputIterator __end,\n\t\t       const _Alloc\u0026 __a = _Alloc())\n\t: __vstring_base(__beg, __end, __a) { }\n\n      /**\n       *  @brief  Destroy the string instance.\n       */\n      ~__versa_string() _GLIBCXX_NOEXCEPT { }\t\n\n      /**\n       *  @brief  Assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       */\n      __versa_string\u0026\n      operator=(const __versa_string\u0026 __str) \n      { return this-\u003eassign(__str); }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  String move assignment operator.\n       *  @param  __str  Source string.\n       *\n       *  The contents of @a __str are moved into this string (without\n       *  copying).  @a __str is a valid, but unspecified string.\n       */\n      __versa_string\u0026\n      operator=(__versa_string\u0026\u0026 __str)\n      {\n\t// NB: DR 1204.\n\tthis-\u003eswap(__str);\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Set value to string constructed from initializer list.\n       *  @param  __l  std::initializer_list.\n       */\n      __versa_string\u0026\n      operator=(std::initializer_list\u003c_CharT\u003e __l)\n      {\n\tthis-\u003eassign(__l.begin(), __l.end());\n\treturn *this;\n      }\n#endif\n\n      /**\n       *  @brief  Copy contents of @a __s into this string.\n       *  @param  __s  Source null-terminated string.\n       */\n      __versa_string\u0026\n      operator=(const _CharT* __s) \n      { return this-\u003eassign(__s); }\n\n      /**\n       *  @brief  Set value to string of length 1.\n       *  @param  __c  Source character.\n       *\n       *  Assigning to a character makes this string length 1 and\n       *  (*this)[0] == @a __c.\n       */\n      __versa_string\u0026\n      operator=(_CharT __c) \n      { \n\tthis-\u003eassign(1, __c); \n\treturn *this;\n      }\n\n      // Iterators:\n      /**\n       *  Returns a read/write iterator that points to the first character in\n       *  the %string.  Unshares the string.\n       */\n      iterator\n      begin() _GLIBCXX_NOEXCEPT\n      {\n\tthis-\u003e_M_leak();\n\treturn iterator(this-\u003e_M_data());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(this-\u003e_M_data()); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  character in the %string.  Unshares the string.\n       */\n      iterator\n      end() _GLIBCXX_NOEXCEPT\n      {\n\tthis-\u003e_M_leak();\n\treturn iterator(this-\u003e_M_data() + this-\u003esize());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(this-\u003e_M_data() + this-\u003esize()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last\n       *  character in the %string.  Iteration is done in reverse element\n       *  order.  Unshares the string.\n       */\n      reverse_iterator\n      rbegin() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this-\u003eend()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this-\u003eend()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first character in the %string.  Iteration is done in reverse\n       *  element order.  Unshares the string.\n       */\n      reverse_iterator\n      rend() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this-\u003ebegin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this-\u003ebegin()); }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this-\u003e_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this-\u003e_M_data() + this-\u003esize()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this-\u003eend()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this-\u003ebegin()); }\n#endif\n\n    public:\n      // Capacity:\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return this-\u003e_M_length(); }\n\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      length() const _GLIBCXX_NOEXCEPT\n      { return this-\u003e_M_length(); }\n\n      /// Returns the size() of the largest possible %string.\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return this-\u003e_M_max_size(); }\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *  @param  __c  Character to fill any new elements.\n       *\n       *  This function will %resize the %string to the specified\n       *  number of characters.  If the number is smaller than the\n       *  %string's current size the %string is truncated, otherwise\n       *  the %string is extended and new elements are set to @a __c.\n       */\n      void\n      resize(size_type __n, _CharT __c);\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *\n       *  This function will resize the %string to the specified\n       *  length.  If the new size is smaller than the %string's\n       *  current size the %string is truncated, otherwise the %string\n       *  is extended and new characters are default-constructed.  For\n       *  basic types such as char, this means setting them to 0.\n       */\n      void\n      resize(size_type __n)\n      { this-\u003eresize(__n, _CharT()); }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /// A non-binding request to reduce capacity() to size().\n      void\n      shrink_to_fit()\n      {\n\tif (capacity() \u003e size())\n\t  {\n\t    __try\n\t      { this-\u003ereserve(0); }\n\t    __catch(...)\n\t      { }\n\t  }\n      }\n#endif\n\n      /**\n       *  Returns the total number of characters that the %string can\n       *  hold before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      { return this-\u003e_M_capacity(); }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          characters.\n       *  @param  __res_arg  Number of characters required.\n       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %string to hold the specified number of characters.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the string length that\n       *  will be required, the user can reserve the memory in\n       *  %advance, and thus prevent a possible reallocation of memory\n       *  and copying of %string data.\n       */\n      void\n      reserve(size_type __res_arg = 0)\n      { this-\u003e_M_reserve(__res_arg); }\n\n      /**\n       *  Erases the string, making it empty.\n       */\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      { this-\u003e_M_clear(); }\n\n      /**\n       *  Returns true if the %string is empty.  Equivalent to \n       *  \u003ccode\u003e*this == \"\"\u003c/code\u003e.\n       */\n      bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return this-\u003esize() == 0; }\n\n      // Element access:\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read-only (constant) reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[] (size_type __pos) const\n      {\n\t_GLIBCXX_DEBUG_ASSERT(__pos \u003c= this-\u003esize());\n\treturn this-\u003e_M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)  Unshares the string.\n       */\n      reference\n      operator[](size_type __pos)\n      {\n        // allow pos == size() as v3 extension:\n\t_GLIBCXX_DEBUG_ASSERT(__pos \u003c= this-\u003esize());\n        // but be strict in pedantic mode:\n\t_GLIBCXX_DEBUG_PEDASSERT(__pos \u003c this-\u003esize());\n\tthis-\u003e_M_leak();\n\treturn this-\u003e_M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read-only (const) reference to the character.\n       *  @throw  std::out_of_range  If @a __n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter\n       *  is first checked that it is in the range of the string.  The\n       *  function throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\tif (__n \u003e= this-\u003esize())\n\t  std::__throw_out_of_range(__N(\"__versa_string::at\"));\n\treturn this-\u003e_M_data()[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *  @throw  std::out_of_range  If @a __n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter\n       *  is first checked that it is in the range of the string.  The\n       *  function throws out_of_range if the check fails.  Success\n       *  results in unsharing the string.\n       */\n      reference\n      at(size_type __n)\n      {\n\tif (__n \u003e= this-\u003esize())\n\t  std::__throw_out_of_range(__N(\"__versa_string::at\"));\n\tthis-\u003e_M_leak();\n\treturn this-\u003e_M_data()[__n];\n      }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %string.\n       */\n      reference\n      front()\n      { return operator[](0); }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %string.\n       */\n      const_reference\n      front() const\n      { return operator[](0); }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %string.\n       */\n      reference\n      back()\n      { return operator[](this-\u003esize() - 1); }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %string.\n       */\n      const_reference\n      back() const\n      { return operator[](this-\u003esize() - 1); }\n#endif\n\n      // Modifiers:\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      operator+=(const __versa_string\u0026 __str)\n      { return this-\u003eappend(__str); }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      operator+=(const _CharT* __s)\n      { return this-\u003eappend(__s); }\n\n      /**\n       *  @brief  Append a character.\n       *  @param __c  The character to append.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      operator+=(_CharT __c)\n      { \n\tthis-\u003epush_back(__c);\n\treturn *this;\n      }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to be appended.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      operator+=(std::initializer_list\u003c_CharT\u003e __l)\n      { return this-\u003eappend(__l.begin(), __l.end()); }\n#endif // __GXX_EXPERIMENTAL_CXX0X__\n\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      append(const __versa_string\u0026 __str)\n      { return _M_append(__str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Append a substring.\n       *  @param __str  The string to append.\n       *  @param __pos  Index of the first character of str to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a pos is not a valid index.\n       *\n       *  This function appends @a __n characters from @a __str\n       *  starting at @a __pos to this string.  If @a __n is is larger\n       *  than the number of available characters in @a __str, the\n       *  remainder of @a __str is appended.\n       */\n      __versa_string\u0026\n      append(const __versa_string\u0026 __str, size_type __pos, size_type __n)\n      { return _M_append(__str._M_data()\n\t\t\t + __str._M_check(__pos, \"__versa_string::append\"),\n\t\t\t __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Append a C substring.\n       *  @param __s  The C string to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      append(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\t_M_check_length(size_type(0), __n, \"__versa_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\tconst size_type __n = traits_type::length(__s);\n\t_M_check_length(size_type(0), __n, \"__versa_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append multiple characters.\n       *  @param __n  The number of characters to append.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  Appends n copies of c to this string.\n       */\n      __versa_string\u0026\n      append(size_type __n, _CharT __c)\n      { return _M_replace_aux(this-\u003esize(), size_type(0), __n, __c); }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to append.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      append(std::initializer_list\u003c_CharT\u003e __l)\n      { return this-\u003eappend(__l.begin(), __l.end()); }\n#endif // __GXX_EXPERIMENTAL_CXX0X__\n\n      /**\n       *  @brief  Append a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Appends characters in the range [first,last) to this string.\n       */\n      template\u003cclass _InputIterator\u003e\n        __versa_string\u0026\n        append(_InputIterator __first, _InputIterator __last)\n        { return this-\u003ereplace(_M_iend(), _M_iend(), __first, __last); }\n\n      /**\n       *  @brief  Append a single character.\n       *  @param __c  Character to append.\n       */\n      void\n      push_back(_CharT __c)\n      { \n\tconst size_type __size = this-\u003esize();\n\tif (__size + 1 \u003e this-\u003ecapacity() || this-\u003e_M_is_shared())\n\t  this-\u003e_M_mutate(__size, size_type(0), 0, size_type(1));\n\ttraits_type::assign(this-\u003e_M_data()[__size], __c);\n\tthis-\u003e_M_set_length(__size + 1);\n      }\n\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      assign(const __versa_string\u0026 __str)\n      {\n\tthis-\u003e_M_assign(__str);\n\treturn *this;\n      }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets this string to the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      __versa_string\u0026\n      assign(__versa_string\u0026\u0026 __str)\n      {\n\tthis-\u003eswap(__str);\n\treturn *this;\n      }\n#endif // __GXX_EXPERIMENTAL_CXX0X__\n\n      /**\n       *  @brief  Set value to a substring of a string.\n       *  @param __str  The string to use.\n       *  @param __pos  Index of the first character of str.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a __pos is not a valid index.\n       *\n       *  This function sets this string to the substring of @a __str\n       *  consisting of @a __n characters at @a __pos.  If @a __n is\n       *  is larger than the number of available characters in @a\n       *  __str, the remainder of @a __str is used.\n       */\n      __versa_string\u0026\n      assign(const __versa_string\u0026 __str, size_type __pos, size_type __n)\n      { return _M_replace(size_type(0), this-\u003esize(), __str._M_data()\n\t\t\t  + __str._M_check(__pos, \"__versa_string::assign\"),\n\t\t\t  __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Set value to a C substring.\n       *  @param __s  The C string to use.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the first @a\n       *  __n characters of @a __s.  If @a __n is is larger than the\n       *  number of available characters in @a __s, the remainder of\n       *  @a __s is used.\n       */\n      __versa_string\u0026\n      assign(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\treturn _M_replace(size_type(0), this-\u003esize(), __s, __n);\n      }\n\n      /**\n       *  @brief  Set value to contents of a C string.\n       *  @param __s  The C string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the value of\n       *  @a __s.  The data is copied, so there is no dependence on @a\n       *  __s once the function returns.\n       */\n      __versa_string\u0026\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn _M_replace(size_type(0), this-\u003esize(), __s,\n\t\t\t  traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Set value to multiple characters.\n       *  @param __n  Length of the resulting string.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to @a __n copies of\n       *  character @a __c.\n       */\n      __versa_string\u0026\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this-\u003esize(), __n, __c); }\n\n      /**\n       *  @brief  Set value to a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Sets value of string to characters in the range\n       *  [first,last).\n      */\n      template\u003cclass _InputIterator\u003e\n        __versa_string\u0026\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this-\u003ereplace(_M_ibegin(), _M_iend(), __first, __last); }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  Set value to an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to assign.\n       *  @return  Reference to this string.\n       */\n      __versa_string\u0026\n      assign(std::initializer_list\u003c_CharT\u003e __l)\n      { return this-\u003eassign(__l.begin(), __l.end()); }\n#endif // __GXX_EXPERIMENTAL_CXX0X__\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      void\n      insert(iterator __p, size_type __n, _CharT __c)\n      {\tthis-\u003ereplace(__p, __p, __n, __c);  }\n\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [beg,end).  If adding characters\n       *  causes the length to exceed max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      template\u003cclass _InputIterator\u003e\n        void\n        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n        { this-\u003ereplace(__p, __p, __beg, __end); }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  Insert an initializer_list of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       */\n      void\n      insert(iterator __p, std::initializer_list\u003c_CharT\u003e __l)\n      { this-\u003einsert(__p, __l.begin(), __l.end()); }\n#endif // __GXX_EXPERIMENTAL_CXX0X__\n\n      /**\n       *  @brief  Insert value of a string.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts value of @a __str starting at @a __pos1.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      __versa_string\u0026\n      insert(size_type __pos1, const __versa_string\u0026 __str)\n      { return this-\u003ereplace(__pos1, size_type(0),\n\t\t\t     __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Insert a substring.\n       *  @param __pos1  Iterator referencing location in string to insert at.\n       *  @param __str  The string to insert.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n  Number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos1 \u003e size() or\n       *  @a __pos2 \u003e @a __str.size().\n       *\n       *  Starting at @a __pos1, insert @a __n character of @a __str\n       *  beginning with @a __pos2.  If adding characters causes the\n       *  length to exceed max_size(), length_error is thrown.  If @a\n       *  __pos1 is beyond the end of this string or @a __pos2 is\n       *  beyond the end of @a __str, out_of_range is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      insert(size_type __pos1, const __versa_string\u0026 __str,\n\t     size_type __pos2, size_type __n)\n      { return this-\u003ereplace(__pos1, size_type(0), __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"__versa_string::insert\"),\n\t\t\t     __str._M_limit(__pos2, __n)); }\n\n      /**\n       *  @brief  Insert a C substring.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @param __n  The number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      insert(size_type __pos, const _CharT* __s, size_type __n)\n      { return this-\u003ereplace(__pos, size_type(0), __s, __n); }\n\n      /**\n       *  @brief  Insert a C string.\n       *  @param __pos  Iterator referencing location in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003ereplace(__pos, size_type(0), __s,\n\t\t\t     traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __pos  Index in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts @a __n copies of character @a __c starting at index\n       *  @a __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos \u003e length(),\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      __versa_string\u0026\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"__versa_string::insert\"),\n\t\t\t      size_type(0), __n, __c); }\n\n      /**\n       *  @brief  Insert one character.\n       *  @param __p  Iterator referencing position in string to insert at.\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing newly inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts character @a __c at position referenced by @a __p.\n       *  If adding character causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p \u003e= _M_ibegin() \u0026\u0026 __p \u003c= _M_iend());\n\tconst size_type __pos = __p - _M_ibegin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\tthis-\u003e_M_set_leaked();\n\treturn iterator(this-\u003e_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove characters.\n       *  @param __pos  Index of first character to remove (default 0).\n       *  @param __n  Number of characters to remove (default remainder).\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Removes @a __n characters from this string starting at @a\n       *  __pos.  The length of the string is reduced by @a __n.  If\n       *  there are \u003c @a __n characters to remove, the remainder of\n       *  the string is truncated.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      __versa_string\u0026\n      erase(size_type __pos = 0, size_type __n = npos)\n      { \n\tthis-\u003e_M_erase(_M_check(__pos, \"__versa_string::erase\"),\n\t\t       _M_limit(__pos, __n));\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Remove one character.\n       *  @param __position  Iterator referencing the character to remove.\n       *  @return  iterator referencing same location after removal.\n       *\n       *  Removes the character at @a __position from this string. The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position \u003e= _M_ibegin()\n\t\t\t\t \u0026\u0026 __position \u003c _M_iend());\n\tconst size_type __pos = __position - _M_ibegin();\n\tthis-\u003e_M_erase(__pos, size_type(1));\n\tthis-\u003e_M_set_leaked();\n\treturn iterator(this-\u003e_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove a range of characters.\n       *  @param __first  Iterator referencing the first character to remove.\n       *  @param __last  Iterator referencing the end of the range.\n       *  @return  Iterator referencing location of first after removal.\n       *\n       *  Removes the characters in the range [first,last) from this\n       *  string.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      iterator\n      erase(iterator __first, iterator __last)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__first \u003e= _M_ibegin() \u0026\u0026 __first \u003c= __last\n\t\t\t\t \u0026\u0026 __last \u003c= _M_iend());\n        const size_type __pos = __first - _M_ibegin();\n\tthis-\u003e_M_erase(__pos, __last - __first);\n\tthis-\u003e_M_set_leaked();\n\treturn iterator(this-\u003e_M_data() + __pos);\n      }\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  Remove the last character.\n       *\n       *  The string must be non-empty.\n       */\n      void\n      pop_back()\n      { this-\u003e_M_erase(size()-1, 1); }\n#endif // __GXX_EXPERIMENTAL_CXX0X__\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos+n) from this\n       *  string.  In place, the value of @a __str is inserted.  If @a\n       *  __pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of the result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      __versa_string\u0026\n      replace(size_type __pos, size_type __n, const __versa_string\u0026 __str)\n      { return this-\u003ereplace(__pos, __n, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos1  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @param __pos2  Index of first character of str to use.\n       *  @param __n2  Number of characters from str to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 \u003e size() or @a __pos2 \u003e\n       *  str.size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos1,pos1 + n) from\n       *  this string.  In place, the value of @a __str is inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of the result exceeds max_size(), length_error\n       *  is thrown.  The value of the string doesn't change if an\n       *  error is thrown.\n      */\n      __versa_string\u0026\n      replace(size_type __pos1, size_type __n1, const __versa_string\u0026 __str,\n\t      size_type __pos2, size_type __n2)\n      {\n\treturn this-\u003ereplace(__pos1, __n1, __str._M_data()\n\t\t\t     + __str._M_check(__pos2,\n\t\t\t\t\t      \"__versa_string::replace\"),\n\t\t\t     __str._M_limit(__pos2, __n2));\n      }\n\n      /**\n       *  @brief  Replace characters with value of a C substring.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @param __n2  Number of characters from @a __s to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 \u003e size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, the first @a __n2 characters of @a __s\n       *  are inserted, or all of @a __s if @a __n2 is too large.  If\n       *  @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      __versa_string\u0026\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      {\n\t__glibcxx_requires_string_len(__s, __n2);\n\treturn _M_replace(_M_check(__pos, \"__versa_string::replace\"),\n\t\t\t  _M_limit(__pos, __n1), __s, __n2);\n      }\n\n      /**\n       *  @brief  Replace characters with value of a C string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos \u003e size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, the characters of @a __s are inserted.  If\n       *  @a pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of result exceeds max_size(), length_error is thrown.  \n       *  The value of the string doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003ereplace(__pos, __n1, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace characters with multiple characters.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __n2  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos \u003e size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, @a __n2 copies of @a __c are inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      __versa_string\u0026\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"__versa_string::replace\"),\n\t\t\t      _M_limit(__pos, __n1), __n2, __c); }\n\n      /**\n       *  @brief  Replace range of characters with string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __str  String value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [i1,i2).  In place, the\n       *  value of @a __str is inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2, const __versa_string\u0026 __str)\n      { return this-\u003ereplace(__i1, __i2, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace range of characters with C substring.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @param __n  Number of characters from s to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [i1,i2).  In place, the\n       *  first @a n characters of @a __s are inserted.  If the length\n       *  of result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t \u0026\u0026 __i2 \u003c= _M_iend());\n\treturn this-\u003ereplace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);\n      }\n\n      /**\n       *  @brief  Replace range of characters with C string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [i1,i2).  In place, the\n       *  characters of @a __s are inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003ereplace(__i1, __i2, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace range of characters with multiple characters\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __n  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [i1,i2).  In place, @a\n       *  __n copies of @a __c are inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t \u0026\u0026 __i2 \u003c= _M_iend());\n\treturn _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);\n      }\n\n      /**\n       *  @brief  Replace range of characters with range.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __k1  Iterator referencing start of range to insert.\n       *  @param __k2  Iterator referencing end of range to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [i1,i2).  In place,\n       *  characters in the range [k1,k2) are inserted.  If the length\n       *  of result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      template\u003cclass _InputIterator\u003e\n        __versa_string\u0026\n        replace(iterator __i1, iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t   \u0026\u0026 __i2 \u003c= _M_iend());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  typedef typename std::__is_integer\u003c_InputIterator\u003e::__type _Integral;\n\t  return this-\u003e_M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n\t}\n\n      // Specializations for the common case of pointer and iterator:\n      // useful to avoid the overhead of temporary buffering in _M_replace.\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t \u0026\u0026 __i2 \u003c= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this-\u003ereplace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2,\n\t      const _CharT* __k1, const _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t \u0026\u0026 __i2 \u003c= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this-\u003ereplace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t \u0026\u0026 __i2 \u003c= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this-\u003ereplace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n      __versa_string\u0026\n      replace(iterator __i1, iterator __i2,\n\t      const_iterator __k1, const_iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() \u003c= __i1 \u0026\u0026 __i1 \u003c= __i2\n\t\t\t\t \u0026\u0026 __i2 \u003c= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this-\u003ereplace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n      \n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n      /**\n       *  @brief  Replace range of characters with initializer_list.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [i1,i2).  In place,\n       *  characters in the range [k1,k2) are inserted.  If the length\n       *  of result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      __versa_string\u0026 replace(iterator __i1, iterator __i2,\n\t\t\t      std::initializer_list\u003c_CharT\u003e __l)\n      { return this-\u003ereplace(__i1, __i2, __l.begin(), __l.end()); }\n#endif // __GXX_EXPERIMENTAL_CXX0X__\n\n    private:\n      template\u003cclass _Integer\u003e\n\t__versa_string\u0026\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,\n\t\t\t    _Integer __val, std::__true_type)\n        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }\n\n      template\u003cclass _InputIterator\u003e\n\t__versa_string\u0026\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n\t\t\t    _InputIterator __k2, std::__false_type);\n\n      __versa_string\u0026\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c);\n\n      __versa_string\u0026\n      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n\t\t const size_type __len2);\n\n      __versa_string\u0026\n      _M_append(const _CharT* __s, size_type __n);\n\n    public:\n\n      /**\n       *  @brief  Copy substring into C string.\n       *  @param __s  C string to copy value into.\n       *  @param __n  Number of characters to copy.\n       *  @param __pos  Index of first character to copy.\n       *  @return  Number of characters actually copied\n       *  @throw  std::out_of_range  If pos \u003e size().\n       *\n       *  Copies up to @a __n characters starting at @a __pos into the\n       *  C string @a s.  If @a __pos is greater than size(),\n       *  out_of_range is thrown.\n      */\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n\n      /**\n       *  @brief  Swap contents with another string.\n       *  @param __s  String to swap with.\n       *\n       *  Exchanges the contents of this string with that of @a __s in\n       *  constant time.\n      */\n      void\n      swap(__versa_string\u0026 __s)\n      { this-\u003e_M_swap(__s); }\n\n      // String operations:\n      /**\n       *  @brief  Return const pointer to null-terminated contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      c_str() const _GLIBCXX_NOEXCEPT\n      { return this-\u003e_M_data(); }\n\n      /**\n       *  @brief  Return const pointer to contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      data() const _GLIBCXX_NOEXCEPT\n      { return this-\u003e_M_data(); }\n\n      /**\n       *  @brief  Return copy of allocator used to construct this string.\n      */\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return allocator_type(this-\u003e_M_get_allocator()); }\n\n      /**\n       *  @brief  Find position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from @a __s to search for.\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const;\n\n      /**\n       *  @brief  Find position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const __versa_string\u0026 __str, size_type __pos = 0) const\n\t_GLIBCXX_NOEXCEPT\n      { return this-\u003efind(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the value of @a\n       *  __s within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos = 0) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003efind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const __versa_string\u0026 __str, size_type __pos = npos) const\n\t_GLIBCXX_NOEXCEPT\n      { return this-\u003erfind(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const;\n\n      /**\n       *  @brief  Find last position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to start search at (default end).\n       *  @return  Index of start of  last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the value of\n       *  @a __s within this string.  If found, returns the index\n       *  where it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003erfind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the characters of\n       *  @a __str within this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const __versa_string\u0026 __str, size_type __pos = 0) const\n\t_GLIBCXX_NOEXCEPT\n      { return this-\u003efind_first_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character of C substring.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;\n\n      /**\n       *  @brief  Find position of a character of C string.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003efind_first_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the character\n       *  @a __c within this string.  If found, returns the index\n       *  where it was found.  If not found, returns npos.\n       *\n       *  Note: equivalent to find(c, pos).\n      */\n      size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      { return this-\u003efind(__c, __pos); }\n\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_of(const __versa_string\u0026 __str, size_type __pos = npos) const\n\t_GLIBCXX_NOEXCEPT\n      { return this-\u003efind_last_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character of C substring.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;\n\n      /**\n       *  @brief  Find last position of a character of C string.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003efind_last_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n       *\n       *  Note: equivalent to rfind(c, pos).\n      */\n      size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this-\u003erfind(__c, __pos); }\n\n      /**\n       *  @brief  Find position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __str within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const __versa_string\u0026 __str, size_type __pos = 0) const\n\t_GLIBCXX_NOEXCEPT\n      { return this-\u003efind_first_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in the first @a __n characters of @a __s within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n\t\t\tsize_type __n) const;\n\n      /**\n       *  @brief  Find position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003efind_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n\t_GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const __versa_string\u0026 __str,\n\t\t       size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this-\u003efind_last_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in the first @a __n characters of @a __s\n       *  within this string.  If found, returns the index where it\n       *  was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n\t\t       size_type __n) const;\n      /**\n       *  @brief  Find last position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __s within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003efind_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n\t_GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Get a substring.\n       *  @param __pos  Index of first character (default 0).\n       *  @param __n  Number of characters in substring (default remainder).\n       *  @return  The new string.\n       *  @throw  std::out_of_range  If pos \u003e size().\n       *\n       *  Construct and return a new string using the @a __n\n       *  characters starting at @a __pos.  If the string is too\n       *  short, use the remainder of the characters.  If @a __pos is\n       *  beyond the end of the string, out_of_range is thrown.\n      */\n      __versa_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      {\n\treturn __versa_string(*this, _M_check(__pos, \"__versa_string::substr\"),\n\t\t\t      __n);\n      }\n\n      /**\n       *  @brief  Compare to a string.\n       *  @param __str  String to compare against.\n       *  @return  Integer \u003c 0, 0, or \u003e 0.\n       *\n       *  Returns an integer \u003c 0 if this string is ordered before @a\n       *  __str, 0 if their values are equivalent, or \u003e 0 if this\n       *  string is ordered after @a __str.  Determines the effective\n       *  length rlen of the strings to compare as the smallest of\n       *  size() and str.size().  The function then compares the two\n       *  strings by calling traits::compare(data(), str.data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(const __versa_string\u0026 __str) const\n      {\n\tif (this-\u003e_M_compare(__str))\n\t  return 0;\n\n\tconst size_type __size = this-\u003esize();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(this-\u003e_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = this-\u003e_S_compare(__size, __osize);\n\treturn __r;\n      }\n\n      /**\n       *  @brief  Compare substring to a string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @return  Integer \u003c 0, 0, or \u003e 0.\n       *\n       *  Form the substring of this string from the @a __n characters\n       *  starting at @a __pos.  Returns an integer \u003c 0 if the\n       *  substring is ordered before @a __str, 0 if their values are\n       *  equivalent, or \u003e 0 if the substring is ordered after @a\n       *  __str.  Determines the effective length rlen of the strings\n       *  to compare as the smallest of the length of the substring\n       *  and @a __str.size().  The function then compares the two\n       *  strings by calling\n       *  traits::compare(substring.data(),str.data(),rlen).  If the\n       *  result of the comparison is nonzero returns it, otherwise\n       *  the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n,\n\t      const __versa_string\u0026 __str) const;\n\n      /**\n       *  @brief  Compare substring to a substring.\n       *  @param __pos1  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @param __pos2  Index of first character of substring of str.\n       *  @param __n2  Number of characters in substring of str.\n       *  @return  Integer \u003c 0, 0, or \u003e 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos1.  Form the substring of @a\n       *  __str from the @a __n2 characters starting at @a __pos2.\n       *  Returns an integer \u003c 0 if this substring is ordered before\n       *  the substring of @a __str, 0 if their values are equivalent,\n       *  or \u003e 0 if this substring is ordered after the substring of\n       *  @a __str.  Determines the effective length rlen of the\n       *  strings to compare as the smallest of the lengths of the\n       *  substrings.  The function then compares the two strings by\n       *  calling\n       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos1, size_type __n1, const __versa_string\u0026 __str,\n\t      size_type __pos2, size_type __n2) const;\n\n      /**\n       *  @brief  Compare to a C string.\n       *  @param __s  C string to compare against.\n       *  @return  Integer \u003c 0, 0, or \u003e 0.\n       *\n       *  Returns an integer \u003c 0 if this string is ordered before @a\n       *  __s, 0 if their values are equivalent, or \u003e 0 if this string\n       *  is ordered after @a __s.  Determines the effective length\n       *  rlen of the strings to compare as the smallest of size() and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(data(),s,rlen).  If the result of the\n       *  comparison is nonzero returns it, otherwise the shorter one\n       *  is ordered first.\n      */\n      int\n      compare(const _CharT* __s) const;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 5 String::compare specification questionable\n      /**\n       *  @brief  Compare substring to a C string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  C string to compare against.\n       *  @return  Integer \u003c 0, 0, or \u003e 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Returns an integer \u003c 0 if\n       *  the substring is ordered before @a __s, 0 if their values\n       *  are equivalent, or \u003e 0 if the substring is ordered after @a\n       *  __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of the length of the substring and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two string by calling\n       *  traits::compare(substring.data(),s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n\n      /**\n       *  @brief  Compare substring against a character array.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  character array to compare against.\n       *  @param __n2  Number of characters of s.\n       *  @return  Integer \u003c 0, 0, or \u003e 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Form a string from the\n       *  first @a __n2 characters of @a __s.  Returns an integer \u003c 0\n       *  if this substring is ordered before the string from @a __s,\n       *  0 if their values are equivalent, or \u003e 0 if this substring\n       *  is ordered after the string from @a __s.  Determines the\n       *  effective length rlen of the strings to compare as the\n       *  smallest of the length of the substring and @a __n2.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(substring.data(),__s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n       *\n       *  NB: __s must have at least n2 characters, \u003cem\u003e\\\\0\u003c/em\u003e has no special\n       *  meaning.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2) const;\n    }","filepath":"libstdc++-v3/include/ext/vstring.h","line_number":45,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5304560":{"score":0.7018179,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::_Rep::\n    _M_clone","code":"_CharT*\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::_Rep::\n    _M_clone(const _Alloc\u0026 __alloc, size_type __res)\n    {\n      // Requested capacity of the clone.\n      const size_type __requested_cap = this-\u003e_M_length + __res;\n      _Rep* __r = _Rep::_S_create(__requested_cap, this-\u003e_M_capacity,\n\t\t\t\t  __alloc);\n      if (this-\u003e_M_length)\n\t_M_copy(__r-\u003e_M_refdata(), _M_refdata(), this-\u003e_M_length);\n\n      __r-\u003e_M_set_length_and_sharable(this-\u003e_M_length);\n      return __r-\u003e_M_refdata();\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3552,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5305136":{"score":0.7285732,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    append","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    append(const basic_string\u0026 __str, size_type __pos, size_type __n)\n    {\n      __str._M_check(__pos, \"basic_string::append\");\n      __n = __str._M_limit(__pos, __n);\n      if (__n)\n\t{\n\t  const size_type __len = __n + this-\u003esize();\n\t  if (__len \u003e this-\u003ecapacity() || _M_rep()-\u003e_M_is_shared())\n\t    this-\u003ereserve(__len);\n\t  _M_copy(_M_data() + this-\u003esize(), __str._M_data() + __pos, __n);\n\t  _M_rep()-\u003e_M_set_length_and_sharable(__len);\n\t}\n      return *this;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3257,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5305344":{"score":0.7399198,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    append","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    append(const _CharT* __s, size_type __n)\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      if (__n)\n\t{\n\t  _M_check_length(size_type(0), __n, \"basic_string::append\");\n\t  const size_type __len = __n + this-\u003esize();\n\t  if (__len \u003e this-\u003ecapacity() || _M_rep()-\u003e_M_is_shared())\n\t    {\n\t      if (_M_disjunct(__s))\n\t\tthis-\u003ereserve(__len);\n\t      else\n\t\t{\n\t\t  const size_type __off = __s - _M_data();\n\t\t  this-\u003ereserve(__len);\n\t\t  __s = _M_data() + __off;\n\t\t}\n\t    }\n\t  _M_copy(_M_data() + this-\u003esize(), __s, __n);\n\t  _M_rep()-\u003e_M_set_length_and_sharable(__len);\n\t}\n      return *this;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3213,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5305712":{"score":0.7383168,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    append","code":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    append(size_type __n, _CharT __c)\n    {\n      if (__n)\n\t{\n\t  _M_check_length(size_type(0), __n, \"basic_string::append\");\n\t  const size_type __len = __n + this-\u003esize();\n\t  if (__len \u003e this-\u003ecapacity() || _M_rep()-\u003e_M_is_shared())\n\t    this-\u003ereserve(__len);\n\t  _M_assign(_M_data() + this-\u003esize(), __n, __c);\n\t  _M_rep()-\u003e_M_set_length_and_sharable(__len);\n\t}\n      return *this;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3196,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5305904":{"score":0.8710379,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    resize","code":"void\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    resize(size_type __n, _CharT __c)\n    {\n      const size_type __size = this-\u003esize();\n      _M_check_length(__size, __n, \"basic_string::resize\");\n      if (__size \u003c __n)\n\tthis-\u003eappend(__n - __size, __c);\n      else if (__n \u003c __size)\n\tthis-\u003eerase(__n);\n      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3568,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5306000":{"score":0.5869047,"function_name":"push_back","code":"void\n      push_back(_CharT __c)\n      {\n\tconst size_type __len = 1 + this-\u003esize();\n\tif (__len \u003e this-\u003ecapacity() || _M_rep()-\u003e_M_is_shared())\n\t  this-\u003ereserve(__len);\n\ttraits_type::assign(_M_data()[this-\u003esize()], __c);\n\t_M_rep()-\u003e_M_set_length_and_sharable(__len);\n      }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":1330,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5306752":{"score":0.6698241,"function_name":"operator+","code":"__versa_string\u003c_CharT, _Traits, _Alloc, _Base\u003e\n    operator+(const __versa_string\u003c_CharT, _Traits, _Alloc, _Base\u003e\u0026 __lhs,\n\t      const __versa_string\u003c_CharT, _Traits, _Alloc, _Base\u003e\u0026 __rhs)\n    {\n      __versa_string\u003c_CharT, _Traits, _Alloc, _Base\u003e __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }","filepath":"libstdc++-v3/include/ext/vstring.h","line_number":1771,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5307088":{"score":0.6713494,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e\n    operator+","code":"_GLIBCXX20_CONSTEXPR\n    inline basic_string\u003c_CharT, _Traits, _Alloc\u003e\n    operator+(const basic_string\u003c_CharT, _Traits, _Alloc\u003e\u0026 __lhs,\n\t      const _CharT* __rhs)\n    {\n      basic_string\u003c_CharT, _Traits, _Alloc\u003e __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":3470,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5307600":{"score":0.69577503,"function_name":"_M_check","code":"_GLIBCXX20_CONSTEXPR\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos \u003e this-\u003esize())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) \u003e \"\n\t\t\t\t       \"this-\u003esize() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this-\u003esize());\n\treturn __pos;\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":377,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5307904":{"score":0.8466661,"function_name":"replace","code":"basic_string\u0026 \n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      { \n\tconst size_type __size = this-\u003esize();\n \tif (__pos \u003e __size)\n\t  __throw_out_of_range(\"basic_string::replace\");\n\tif (__size - __n1 \u003e this-\u003emax_size() - __n2)\n\t  __throw_length_error(\"basic_string::replace\");\n\tconst bool __testn1 = __n1 \u003c __size - __pos;\n\tconst size_type __foldn1 = __testn1 ? __n1 : __size - __pos;\n\tif (_M_rep()-\u003e_M_is_shared() || less\u003cconst _CharT*\u003e()(__s, _M_data())\n\t    || less\u003cconst _CharT*\u003e()(_M_data() + __size, __s))\n\t  return _M_replace_safe(_M_ibegin() + __pos,\n\t\t\t\t _M_ibegin() + __pos + __foldn1, __s, __s + __n2);\t\n\telse return this-\u003ereplace(_M_check(__pos), _M_fold(__pos, __n1),\n\t\t\t\t  __s, __s + __n2); \n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":636,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-3.0.96"},"5308448":{"score":0.74830973,"function_name":"_If_sv\u003c_Tp, basic_string\u0026\u003e\n\treplace","code":"_GLIBCXX20_CONSTEXPR\n\t_If_sv\u003c_Tp, basic_string\u0026\u003e\n\treplace(size_type __pos1, size_type __n1, const _Tp\u0026 __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this-\u003ereplace(__pos1, __n1,\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos2, \"basic_string::replace\"),\n\t      std::__sv_limit(__sv.size(), __pos2, __n2));\n\t}","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2456,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5308800":{"score":0.50472486,"function_name":"find_last_not_of","code":"_GLIBCXX20_CONSTEXPR\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this-\u003efind_last_not_of(__s, __pos, traits_type::length(__s));\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":3084,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5309136":{"score":0.8784598,"function_name":"random_device::_M_init","code":"void\n  random_device::_M_init(const std::string\u0026 token)\n  {\n    const char *fname = token.c_str();\n\n    if (token == \"default\")\n      {\n#if (defined __i386__ || defined __x86_64__) \u0026\u0026 defined _GLIBCXX_X86_RDRAND\n\tunsigned int eax, ebx, ecx, edx;\n\t// Check availability of cpuid and, for now at least, also the\n\t// CPU signature for Intel's\n\tif (__get_cpuid_max(0, \u0026ebx) \u003e 0 \u0026\u0026 ebx == signature_INTEL_ebx)\n\t  {\n\t    __cpuid(1, eax, ebx, ecx, edx);\n\t    if (ecx \u0026 bit_RDRND)\n\t      {\n\t\t_M_file = nullptr;\n\t\treturn;\n\t      }\n\t  }\n#endif\n\n\tfname = \"/dev/urandom\";\n      }\n    else if (token != \"/dev/urandom\" \u0026\u0026 token != \"/dev/random\")\n    fail:\n      std::__throw_runtime_error(__N(\"random_device::\"\n\t\t\t\t     \"random_device(const std::string\u0026)\"));\n\n    _M_file = static_cast\u003cvoid*\u003e(std::fopen(fname, \"rb\"));\n    if (!_M_file)\n      goto fail;\n  }","filepath":"libstdc++-v3/src/c++11/cow-string-inst.cc","line_number":70,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5309312":{"score":0.8040323,"function_name":"random_device::_M_init_pretr1","code":"void\n  random_device::_M_init_pretr1(const std::string\u0026 token)\n  {\n    unsigned long __seed = 5489UL;\n    if (token != \"mt19937\")\n      {\n\tconst char* __nptr = token.c_str();\n\tchar* __endptr;\n\t__seed = std::strtoul(__nptr, \u0026__endptr, 0);\n\tif (*__nptr == '\\0' || *__endptr != '\\0')\n\t  std::__throw_runtime_error(__N(\"random_device::random_device\"\n\t\t\t\t\t \"(const std::string\u0026)\"));\n      }\n    _M_mt.seed(__seed);\n  }","filepath":"libstdc++-v3/src/c++11/cow-string-inst.cc","line_number":104,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5309504":{"score":0.6694107,"function_name":"__throw_insufficient_space","code":"void\n  __throw_insufficient_space(const char *__buf, const char *__bufend)\n  {\n    // Include space for trailing NUL.\n    const size_t __len = __bufend - __buf + 1;\n\n    const char __err[] = \"not enough space for format expansion \"\n      \"(Please submit full bug report at http://gcc.gnu.org/bugs.html):\\n    \";\n    const size_t __errlen = sizeof(__err) - 1;\n\n    char *const __e\n      = static_cast\u003cchar*\u003e(__builtin_alloca(__errlen + __len));\n\n    __builtin_memcpy(__e, __err, __errlen);\n    __builtin_memcpy(__e + __errlen, __buf, __len - 1);\n    __e[__errlen + __len - 1] = '\\0';\n    std::__throw_logic_error(__e);\n  }","filepath":"libstdc++-v3/src/c++11/snprintf_lite.cc","line_number":48,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5309904":{"score":0.672813,"function_name":"__concat_size_t","code":"int __concat_size_t(char *__buf, size_t __bufsize, size_t __val)\n  {\n    // __int_to_char is explicitly instantiated and available only for\n    // some, but not all, types. See locale-inst.cc.\n#ifdef _GLIBCXX_USE_LONG_LONG\n    unsigned long long __val2 = __val;\n#else\n    unsigned long __val2 = __val;\n#endif\n    // Long enough for decimal representation.\n    int __ilen = 3 * sizeof(__val2);\n    char *__cs = static_cast\u003cchar*\u003e(__builtin_alloca(__ilen));\n    size_t __len = std::__int_to_char(__cs + __ilen, __val2,\n\t\t\t\t      std::__num_base::_S_atoms_out,\n\t\t\t\t      std::ios_base::dec, true);\n    if (__bufsize \u003c __len)\n      return -1;\n\n    __builtin_memcpy(__buf, __cs + __ilen - __len, __len);\n    return __len;\n  }","filepath":"libstdc++-v3/src/c++11/snprintf_lite.cc","line_number":72,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5310064":{"score":0.84687966,"function_name":"__snprintf_lite","code":"int __snprintf_lite(char *__buf, size_t __bufsize, const char *__fmt,\n\t\t      va_list __ap)\n  {\n    char *__d = __buf;\n    const char *__s = __fmt;\n    const char *const __limit = __d + __bufsize - 1;  // Leave space for NUL.\n\n    while (__s[0] != '\\0' \u0026\u0026 __d \u003c __limit)\n      {\n\tif (__s[0] == '%')\n\t  switch (__s[1])\n\t    {\n\t    default:  // Stray '%'. Just print it.\n\t      break;\n\t    case '%':  // '%%'\n\t      __s += 1;\n\t      break;\n\t    case 's':  // '%s'.\n\t      {\n\t\tconst char *__v = va_arg(__ap, const char *);\n\n\t\twhile (__v[0] != '\\0' \u0026\u0026 __d \u003c __limit)\n\t\t  *__d++ = *__v++;\n\n\t\tif (__v[0] != '\\0')\n\t\t  // Not enough space for __fmt expansion.\n\t\t  __throw_insufficient_space(__buf, __d);\n\n\t\t__s += 2;  // Step over %s.\n\t\tcontinue;\n\t      }\n\t      break;\n\t    case 'z':\n\t      if (__s[2] == 'u')  // '%zu' -- expand next size_t arg.\n\t\t{\n\t\t  const int __len = __concat_size_t(__d, __limit - __d,\n\t\t\t\t\t\t    va_arg(__ap, size_t));\n\t\t  if (__len \u003e 0)\n\t\t    __d += __len;\n\t\t  else\n\t\t    // Not enough space for __fmt expansion.\n\t\t    __throw_insufficient_space(__buf, __d);\n\n\t\t  __s += 3;  // Step over %zu\n\t\t  continue;\n\t\t}\n\t      // Stray '%zX'. Just print it.\n\t      break;\n\t    }\n\t*__d++ = *__s++;\n      }\n\n    if (__s[0] != '\\0')\n      // Not enough space for __fmt expansion.\n      __throw_insufficient_space(__buf, __d);\n\n    *__d = '\\0';\n    return __d - __buf;\n  }","filepath":"libstdc++-v3/src/c++11/snprintf_lite.cc","line_number":101,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5310496":{"score":0.7826087,"function_name":"run","code":"void run(void* p)\n    {\n      auto elt = (__at_thread_exit_elt*)p;\n      while (elt)\n\t{\n\t  auto next = elt-\u003e_M_next;\n\t  elt-\u003e_M_cb(elt);\n\t  elt = next;\n\t}\n    }","filepath":"libstdc++-v3/src/c++11/condition_variable.cc","line_number":88,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5310640":{"score":0.5749251,"function_name":"locale::_S_initialize","code":"void  \n  locale::_S_initialize()\n  {\n#ifdef __GTHREADS\n    if (__gthread_active_p())\n      __gthread_once(\u0026_S_once, _S_initialize_once);\n#endif\n    if (!_S_classic)\n      _S_initialize_once();\n  }","filepath":"libstdc++-v3/src/locale_init.cc","line_number":260,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5310960":{"score":0.756866,"function_name":"__at_thread_exit","code":"void\n  __at_thread_exit(__at_thread_exit_elt* elt)\n  {\n    static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n    __gthread_once (\u0026once, key_init);\n\n    elt-\u003e_M_next = (__at_thread_exit_elt*)__gthread_getspecific(key);\n    __gthread_setspecific(key, elt);\n  }","filepath":"libstdc++-v3/src/c++11/condition_variable.cc","line_number":139,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5314160":{"score":0.64742136,"function_name":"~sentry","code":"~sentry()\n      {\n\t// XXX MT\n\tif (_M_os.flags() \u0026 ios_base::unitbuf \u0026\u0026 !uncaught_exception())\n\t  {\n\t    // Can't call flush directly or else will get into recursive lock.\n\t    if (_M_os.rdbuf() \u0026\u0026 _M_os.rdbuf()-\u003epubsync() == -1)\n\t      _M_os.setstate(ios_base::badbit);\n\t  }\n      }","filepath":"libstdc++-v3/include/std/std_ostream.h","line_number":402,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.0.2"},"5318064":{"score":0.7072144,"function_name":"operator\u003c\u003c","code":"__ostream_type\u0026 \n      operator\u003c\u003c(short __n)\n      { \n\tconst ios_base::fmtflags __fmt = this-\u003eflags() \u0026 ios_base::basefield;\n\tif (__fmt == ios_base::oct || __fmt == ios_base::hex)\n\t  return this-\u003eoperator\u003c\u003c(static_cast\u003clong\u003e\n\t\t\t\t  (static_cast\u003cunsigned short\u003e(__n)));\n\telse\n\t  return this-\u003eoperator\u003c\u003c(static_cast\u003clong\u003e(__n));\n      }","filepath":"libstdc++-v3/include/std/std_ostream.h","line_number":175,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.0.2"},"5318112":{"score":0.6387567,"function_name":"operator\u003c\u003c","code":"__ostream_type\u0026 \n      operator\u003c\u003c(int __n)\n      { \n\tconst ios_base::fmtflags __fmt = this-\u003eflags() \u0026 ios_base::basefield;\n\tif (__fmt == ios_base::oct || __fmt == ios_base::hex)\n\t  return this-\u003eoperator\u003c\u003c(static_cast\u003clong\u003e\n\t\t\t\t  (static_cast\u003cunsigned int\u003e(__n)));\n\telse\n\t  return this-\u003eoperator\u003c\u003c(static_cast\u003clong\u003e(__n));\n      }","filepath":"libstdc++-v3/include/std/std_ostream.h","line_number":190,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.0.2"},"5324720":{"score":0.6515042,"function_name":"~sentry","code":"~sentry()\n      {\n\t// XXX MT\n\tif (_M_os.flags() \u0026 ios_base::unitbuf \u0026\u0026 !uncaught_exception())\n\t  {\n\t    // Can't call flush directly or else will get into recursive lock.\n\t    if (_M_os.rdbuf() \u0026\u0026 _M_os.rdbuf()-\u003epubsync() == -1)\n\t      _M_os.setstate(ios_base::badbit);\n\t  }\n      }","filepath":"libstdc++-v3/include/bits/std_ostream.h","line_number":194,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-2.92"},"5328480":{"score":0.6208938,"function_name":"operator\u003c\u003c","code":"__ostream_type\u0026 \n      operator\u003c\u003c(short __n)\n      { \n\tios_base::fmtflags __fmt = this-\u003eflags() \u0026 ios_base::basefield;\n\tif (__fmt \u0026 ios_base::oct || __fmt \u0026 ios_base::hex)\n\t  return this-\u003eoperator\u003c\u003c(static_cast\u003cunsigned long\u003e\n\t\t\t\t  (static_cast\u003cunsigned short\u003e(__n)));\n\telse\n\t  return this-\u003eoperator\u003c\u003c(static_cast\u003clong\u003e(__n));\n      }","filepath":"libstdc++-v3/include/bits/std_ostream.h","line_number":98,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-2.92"},"5332496":{"score":0.7421175,"function_name":"ios_base::_M_grow_words","code":"ios_base::_Words\u0026\n  ios_base::_M_grow_words(int __ix, bool __iword)\n  {\n    // Precondition: _M_word_size \u003c= __ix\n    int __newsize = _S_local_word_size;\n    _Words* __words = _M_local_word;\n    if (__ix \u003e _S_local_word_size - 1)\n      {\n\tif (__ix \u003c numeric_limits\u003cint\u003e::max())\n\t  {\n\t    __newsize = __ix + 1;\n\t    try\n\t      { __words = new _Words[__newsize]; }\n\t    catch (...)\n\t      {\n\t\t_M_streambuf_state |= badbit;\n\t\tif (_M_streambuf_state \u0026 _M_exception)\n\t\t  __throw_ios_failure(__N(\"ios_base::_M_grow_words \"\n\t\t\t\t      \"allocation failed\"));\n\t\tif (__iword)\n\t\t  _M_word_zero._M_iword = 0;\n\t\telse\n\t\t  _M_word_zero._M_pword = 0;\n\t\treturn _M_word_zero;\n\t      }\n\t    for (int __i = 0; __i \u003c _M_word_size; __i++) \n\t      __words[__i] = _M_word[__i];\n\t    if (_M_word \u0026\u0026 _M_word != _M_local_word) \n\t      {\n\t\tdelete [] _M_word;\n\t\t_M_word = 0;\n\t      }\n\t  }\n\telse\n\t  {\n\t    _M_streambuf_state |= badbit;\n\t    if (_M_streambuf_state \u0026 _M_exception)\n\t      __throw_ios_failure(__N(\"ios_base::_M_grow_words is not valid\"));\n\t    if (__iword)\n\t      _M_word_zero._M_iword = 0;\n\t    else\n\t      _M_word_zero._M_pword = 0;\n\t    return _M_word_zero;\n\t  }\n      }\n    _M_word = __words;\n    _M_word_size = __newsize;\n    return _M_word[__ix];\n  }","filepath":"libstdc++-v3/src/ios.cc","line_number":117,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5332944":{"score":0.79807854,"function_name":"ios_base::_M_call_callbacks","code":"void \n  ios_base::_M_call_callbacks(event __e) throw()\n  {\n    _Callback_list* __p = _M_callbacks;\n    while (__p)\n      {\n\ttry \n\t  { (*__p-\u003e_M_fn) (__e, *this, __p-\u003e_M_index); } \n\tcatch (...) \n\t  { }\n\t__p = __p-\u003e_M_next;\n      }\n  }","filepath":"libstdc++-v3/src/ios.cc","line_number":167,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5333136":{"score":0.47819567,"function_name":"ios_base::~ios_base","code":"ios_base::~ios_base()\n  {\n    _M_call_callbacks(erase_event);\n    _M_dispose_callbacks();\n    if (_M_word != _M_local_word) \n      {\n\tdelete [] _M_word;\n\t_M_word = 0;\n      }\n  }","filepath":"libstdc++-v3/src/c++98/ios.cc","line_number":87,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5333520":{"score":0.8483246,"function_name":"PB_ASSOC_CLASS_C_DEC::\nswap","code":"void\nPB_ASSOC_CLASS_C_DEC::\nswap(PB_ASSOC_CLASS_C_DEC\u0026 r_other)\n{\n  PB_ASSOC_DBG_ONLY(assert_valid(true, true);)\n    PB_ASSOC_DBG_ONLY(r_other.assert_valid(true, true);)\n\n    PB_ASSOC_DBG_ONLY(my_map_debug_base::swap(r_other);)\n\n    std::swap(m_p_head, r_other.m_p_head);\n\n  std::swap(m_size, r_other.m_size);\n\n  std::swap(m_end_it, r_other.m_end_it);\n\n  std::swap(m_rend_it, r_other.m_rend_it);\n\n  std::swap((Cmp_Fn\u0026 )(*this), (Cmp_Fn\u0026 )r_other);\n\n  Node_Updator::swap(r_other);\n\n  PB_ASSOC_DBG_ONLY(assert_valid(true, true);)\n    PB_ASSOC_DBG_ONLY(r_other.assert_valid(true, true);)\n    }","filepath":"libstdc++-v3/include/ext/pb_assoc/detail/bin_search_tree_/constructors_destructor_fn_imps.hpp","line_number":135,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5334528":{"score":0.4783224,"function_name":"PB_ASSOC_CLASS_C_DEC::\nnotify_resized","code":"PB_ASSOC_CLASS_T_DEC\nvoid\nPB_ASSOC_CLASS_C_DEC::\nnotify_resized(size_type new_size)\n{\n  my_trigger_policy_base::notify_resized(new_size);\n\n  m_size = new_size;\n}","filepath":"libstdc++-v3/include/ext/pb_assoc/detail/resize_policy/hash_standard_resize_policy_imp.hpp","line_number":232,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5335488":{"score":0.5494492,"function_name":"PB_ASSOC_CLASS_C_DEC::\nhash_standard_resize_policy","code":"PB_ASSOC_CLASS_T_DEC\nPB_ASSOC_CLASS_C_DEC::\nhash_standard_resize_policy(size_type suggested_size /*= 8*/) :\n  m_size(Size_Policy::get_init_size(suggested_size))\n{\n  my_trigger_policy_base::notify_externally_resized(\n\t\t\t\t\t\t    Size_Policy::get_init_size(suggested_size));\n}","filepath":"libstdc++-v3/include/ext/pb_assoc/detail/resize_policy/hash_standard_resize_policy_imp.hpp","line_number":59,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5336448":{"score":0.5523195,"function_name":"PB_ASSOC_CLASS_C_DEC::\nswap","code":"PB_ASSOC_CLASS_T_DEC\nvoid\nPB_ASSOC_CLASS_C_DEC::\nswap(PB_ASSOC_CLASS_C_DEC\u0026 r_other)\n{\n  my_trigger_policy_base::swap(r_other);\n\n  my_size_policy_base::swap(r_other);\n\n  std::swap(m_size, r_other.m_size);\n}","filepath":"libstdc++-v3/include/ext/pb_assoc/detail/resize_policy/hash_standard_resize_policy_imp.hpp","line_number":88,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5338736":{"score":0.5821831,"function_name":"PB_ASSOC_CLASS_C_DEC::\nswap","code":"PB_ASSOC_CLASS_T_DEC\nvoid\nPB_ASSOC_CLASS_C_DEC::\nswap(PB_ASSOC_CLASS_C_DEC\u0026 r_other)\n{\n  my_trigger_policy_base::swap(r_other);\n\n  my_size_policy_base::swap(r_other);\n\n  std::swap(m_size, r_other.m_size);\n}","filepath":"libstdc++-v3/include/ext/pb_assoc/detail/resize_policy/hash_standard_resize_policy_imp.hpp","line_number":88,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5339616":{"score":0.73802185,"function_name":"ctype\u003cchar\u003e::\n  _M_narrow_init","code":"void\n  ctype\u003cchar\u003e::\n  _M_narrow_init() const\n  {\n    char __tmp[sizeof(_M_narrow)];\n    for (size_t __i = 0; __i \u003c sizeof(_M_narrow); ++__i)\n      __tmp[__i] = __i;\n    do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);\n\n    _M_narrow_ok = 1;\n    if (__builtin_memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))\n      _M_narrow_ok = 2;\n    else\n      {\n\t// Deal with the special case of zero: renarrow with a\n\t// different default and compare.\n\tchar __c;\n\tdo_narrow(__tmp, __tmp + 1, 1, \u0026__c);\n\tif (__c == 1)\n\t  _M_narrow_ok = 2;\n      }\n  }","filepath":"libstdc++-v3/src/c++11/ctype.cc","line_number":64,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5340016":{"score":0.6944692,"function_name":"ctype_byname\u003cwchar_t\u003e::ctype_byname","code":"ctype_byname\u003cwchar_t\u003e::ctype_byname(const char* __s, size_t __refs)\n  : ctype\u003cwchar_t\u003e(__refs)\n  {\n    if (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n      {\n\tthis-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_ctype);\n\tthis-\u003e_S_create_c_locale(this-\u003e_M_c_locale_ctype, __s);\n\tthis-\u003e_M_initialize_ctype();\n      }\n  }","filepath":"libstdc++-v3/src/c++11/ctype.cc","line_number":116,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5340288":{"score":0.81458324,"function_name":"__vmi_class_type_info::\n__do_find_public_src","code":"__class_type_info::__sub_kind __vmi_class_type_info::\n__do_find_public_src (ptrdiff_t src2dst,\n                      const void *obj_ptr,\n                      const __class_type_info *src_type,\n                      const void *src_ptr) const\n{\n  if (obj_ptr == src_ptr \u0026\u0026 *this == *src_type)\n    return __contained_public;\n  \n  for (std::size_t i = __base_count; i--;)\n    {\n      if (!__base_info[i].__is_public_p ())\n        continue; // Not public, can't be here.\n      \n      const void *base = obj_ptr;\n      ptrdiff_t offset = __base_info[i].__offset ();\n      bool is_virtual = __base_info[i].__is_virtual_p ();\n      \n      if (is_virtual)\n        {\n          if (src2dst == -3)\n            continue; // Not a virtual base, so can't be here.\n        }\n      base = convert_to_base (base, is_virtual, offset);\n      \n      __sub_kind base_kind = __base_info[i].__base_type-\u003e__do_find_public_src\n                              (src2dst, base, src_type, src_ptr);\n      if (contained_p (base_kind))\n        {\n          if (is_virtual)\n            base_kind = __sub_kind (base_kind | __contained_virtual_mask);\n          return base_kind;\n        }\n    }\n  \n  return __not_contained;\n}","filepath":"libstdc++-v3/libsupc++/vmi_class_type_info.cc","line_number":32,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5340544":{"score":0.90483165,"function_name":"__vmi_class_type_info::\n__do_dyncast","code":"bool __vmi_class_type_info::\n__do_dyncast (ptrdiff_t src2dst,\n              __sub_kind access_path,\n              const __class_type_info *dst_type,\n              const void *obj_ptr,\n              const __class_type_info *src_type,\n              const void *src_ptr,\n              __dyncast_result \u0026__restrict result) const\n{\n  if (result.whole_details \u0026 __flags_unknown_mask)\n    result.whole_details = __flags;\n  \n  if (obj_ptr == src_ptr \u0026\u0026 *this == *src_type)\n    {\n      // The src object we started from. Indicate how we are accessible from\n      // the most derived object.\n      result.whole2src = access_path;\n      return false;\n    }\n  if (*this == *dst_type)\n    {\n      result.dst_ptr = obj_ptr;\n      result.whole2dst = access_path;\n      if (src2dst \u003e= 0)\n        result.dst2src = adjust_pointer \u003cvoid\u003e (obj_ptr, src2dst) == src_ptr\n              ? __contained_public : __not_contained;\n      else if (src2dst == -2)\n        result.dst2src = __not_contained;\n      return false;\n    }\n\n  // If src_type is a unique non-virtual base of dst_type, we have a good\n  // guess at the address we want, so in the first pass try skipping any\n  // bases which don't contain that address.\n  const void *dst_cand = NULL;\n  if (src2dst \u003e= 0)\n    dst_cand = adjust_pointer\u003cvoid\u003e(src_ptr, -src2dst);\n  bool first_pass = true;\n  bool skipped = false;\n\n  bool result_ambig = false;\n again:\n  for (std::size_t i = __base_count; i--;)\n    {\n      __dyncast_result result2 (result.whole_details);\n      void const *base = obj_ptr;\n      __sub_kind base_access = access_path;\n      ptrdiff_t offset = __base_info[i].__offset ();\n      bool is_virtual = __base_info[i].__is_virtual_p ();\n      \n      if (is_virtual)\n        base_access = __sub_kind (base_access | __contained_virtual_mask);\n      base = convert_to_base (base, is_virtual, offset);\n\n      if (dst_cand)\n\t{\n\t  bool skip_on_first_pass = base \u003e dst_cand;\n\t  if (skip_on_first_pass == first_pass)\n\t    {\n\t      // We aren't interested in this base on this pass: either\n\t      // we're on the first pass and this base doesn't contain the\n\t      // likely address, or we're on the second pass and we checked\n\t      // this base on the first pass.\n\t      skipped = true;\n\t      continue;\n\t    }\n\t}\n\n      if (!__base_info[i].__is_public_p ())\n        {\n          if (src2dst == -2 \u0026\u0026\n              !(result.whole_details\n                \u0026 (__non_diamond_repeat_mask | __diamond_shaped_mask)))\n            // The hierarchy has no duplicate bases (which might ambiguate\n            // things) and where we started is not a public base of what we\n            // want (so it cannot be a downcast). There is nothing of interest\n            // hiding in a non-public base.\n            continue;\n          base_access = __sub_kind (base_access \u0026 ~__contained_public_mask);\n        }\n      \n      bool result2_ambig\n          = __base_info[i].__base_type-\u003e__do_dyncast (src2dst, base_access,\n                                             dst_type, base,\n                                             src_type, src_ptr, result2);\n      result.whole2src = __sub_kind (result.whole2src | result2.whole2src);\n      if (result2.dst2src == __contained_public\n          || result2.dst2src == __contained_ambig)\n        {\n          result.dst_ptr = result2.dst_ptr;\n          result.whole2dst = result2.whole2dst;\n          result.dst2src = result2.dst2src;\n          // Found a downcast which can't be bettered or an ambiguous downcast\n          // which can't be disambiguated\n          return result2_ambig;\n        }\n      \n      if (!result_ambig \u0026\u0026 !result.dst_ptr)\n        {\n          // Not found anything yet.\n          result.dst_ptr = result2.dst_ptr;\n          result.whole2dst = result2.whole2dst;\n          result_ambig = result2_ambig;\n          if (result.dst_ptr \u0026\u0026 result.whole2src != __unknown\n              \u0026\u0026 !(__flags \u0026 __non_diamond_repeat_mask))\n            // Found dst and src and we don't have repeated bases.\n            return result_ambig;\n        }\n      else if (result.dst_ptr \u0026\u0026 result.dst_ptr == result2.dst_ptr)\n        {\n          // Found at same address, must be via virtual.  Pick the most\n          // accessible path.\n          result.whole2dst =\n              __sub_kind (result.whole2dst | result2.whole2dst);\n        }\n      else if ((result.dst_ptr != 0 \u0026\u0026 result2.dst_ptr != 0)\n\t       || (result.dst_ptr != 0 \u0026\u0026 result2_ambig)\n\t       || (result2.dst_ptr != 0 \u0026\u0026 result_ambig))\n        {\n          // Found two different DST_TYPE bases, or a valid one and a set of\n          // ambiguous ones, must disambiguate. See whether SRC_PTR is\n          // contained publicly within one of the non-ambiguous choices. If it\n          // is in only one, then that's the choice. If it is in both, then\n          // we're ambiguous and fail. If it is in neither, we're ambiguous,\n          // but don't yet fail as we might later find a third base which does\n          // contain SRC_PTR.\n        \n          __sub_kind new_sub_kind = result2.dst2src;\n          __sub_kind old_sub_kind = result.dst2src;\n          \n          if (contained_p (result.whole2src)\n              \u0026\u0026 (!virtual_p (result.whole2src)\n                  || !(result.whole_details \u0026 __diamond_shaped_mask)))\n            {\n              // We already found SRC_PTR as a base of most derived, and\n              // either it was non-virtual, or the whole hierarchy is\n              // not-diamond shaped. Therefore if it is in either choice, it\n              // can only be in one of them, and we will already know.\n              if (old_sub_kind == __unknown)\n                old_sub_kind = __not_contained;\n              if (new_sub_kind == __unknown)\n                new_sub_kind = __not_contained;\n            }\n          else\n            {\n              if (old_sub_kind \u003e= __not_contained)\n                ;// already calculated\n              else if (contained_p (new_sub_kind)\n                       \u0026\u0026 (!virtual_p (new_sub_kind)\n                           || !(__flags \u0026 __diamond_shaped_mask)))\n                // Already found inside the other choice, and it was\n                // non-virtual or we are not diamond shaped.\n                old_sub_kind = __not_contained;\n              else\n                old_sub_kind = dst_type-\u003e__find_public_src\n                                (src2dst, result.dst_ptr, src_type, src_ptr);\n          \n              if (new_sub_kind \u003e= __not_contained)\n                ;// already calculated\n              else if (contained_p (old_sub_kind)\n                       \u0026\u0026 (!virtual_p (old_sub_kind)\n                           || !(__flags \u0026 __diamond_shaped_mask)))\n                // Already found inside the other choice, and it was\n                // non-virtual or we are not diamond shaped.\n                new_sub_kind = __not_contained;\n              else\n                new_sub_kind = dst_type-\u003e__find_public_src\n                                (src2dst, result2.dst_ptr, src_type, src_ptr);\n            }\n          \n          // Neither sub_kind can be contained_ambig -- we bail out early\n          // when we find those.\n          if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))\n            {\n              // Only on one choice, not ambiguous.\n              if (contained_p (new_sub_kind))\n                {\n                  // Only in new.\n                  result.dst_ptr = result2.dst_ptr;\n                  result.whole2dst = result2.whole2dst;\n                  result_ambig = false;\n                  old_sub_kind = new_sub_kind;\n                }\n              result.dst2src = old_sub_kind;\n              if (public_p (result.dst2src))\n                return false; // Can't be an ambiguating downcast for later discovery.\n              if (!virtual_p (result.dst2src))\n                return false; // Found non-virtually can't be bettered\n            }\n          else if (contained_p (__sub_kind (new_sub_kind \u0026 old_sub_kind)))\n            {\n              // In both.\n              result.dst_ptr = NULL;\n              result.dst2src = __contained_ambig;\n              return true;  // Fail.\n            }\n          else\n            {\n              // In neither publicly, ambiguous for the moment, but keep\n              // looking. It is possible that it was private in one or\n              // both and therefore we should fail, but that's just tough.\n              result.dst_ptr = NULL;\n              result.dst2src = __not_contained;\n              result_ambig = true;\n            }\n        }\n      \n      if (result.whole2src == __contained_private)\n        // We found SRC_PTR as a private non-virtual base, therefore all\n        // cross casts will fail. We have already found a down cast, if\n        // there is one.\n        return result_ambig;\n    }\n\n  if (skipped \u0026\u0026 first_pass)\n    {\n      // We didn't find dst where we expected it, so let's go back and try\n      // the bases we skipped (if any).\n      first_pass = false;\n      goto again;\n    }\n\n  return result_ambig;\n}","filepath":"libstdc++-v3/libsupc++/vmi_class_type_info.cc","line_number":79,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5342336":{"score":0.76582694,"function_name":"__vmi_class_type_info::\n__do_upcast","code":"bool __vmi_class_type_info::\n__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n             __upcast_result \u0026__restrict result) const\n{\n  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n    return true;\n  \n  int src_details = result.src_details;\n  if (src_details \u0026 __flags_unknown_mask)\n    src_details = __flags;\n  \n  for (std::size_t i = __base_count; i--;)\n    {\n      __upcast_result result2 (src_details);\n      const void *base = obj_ptr;\n      ptrdiff_t offset = __base_info[i].__offset ();\n      bool is_virtual = __base_info[i].__is_virtual_p ();\n      bool is_public = __base_info[i].__is_public_p ();\n      \n      if (!is_public \u0026\u0026 !(src_details \u0026 __non_diamond_repeat_mask))\n        // original cannot have an ambiguous base, so skip private bases\n        continue;\n\n      if (base)\n        base = convert_to_base (base, is_virtual, offset);\n      \n      if (__base_info[i].__base_type-\u003e__do_upcast (dst, base, result2))\n        {\n          if (result2.base_type == nonvirtual_base_type \u0026\u0026 is_virtual)\n            result2.base_type = __base_info[i].__base_type;\n          if (contained_p (result2.part2dst) \u0026\u0026 !is_public)\n            result2.part2dst = __sub_kind (result2.part2dst \u0026 ~__contained_public_mask);\n          \n          if (!result.base_type)\n            {\n              result = result2;\n              if (!contained_p (result.part2dst))\n                return true; // found ambiguously\n              \n              if (result.part2dst \u0026 __contained_public_mask)\n                {\n                  if (!(__flags \u0026 __non_diamond_repeat_mask))\n                    return true;  // cannot have an ambiguous other base\n                }\n              else\n                {\n                  if (!virtual_p (result.part2dst))\n                    return true; // cannot have another path\n                  if (!(__flags \u0026 __diamond_shaped_mask))\n                    return true; // cannot have a more accessible path\n                }\n            }\n          else if (result.dst_ptr != result2.dst_ptr)\n            {\n              // Found an ambiguity.\n\t      result.dst_ptr = NULL;\n\t      result.part2dst = __contained_ambig;\n\t      return true;\n            }\n          else if (result.dst_ptr)\n            {\n              // Ok, found real object via a virtual path.\n              result.part2dst\n                  = __sub_kind (result.part2dst | result2.part2dst);\n            }\n          else\n            {\n              // Dealing with a null pointer, need to check vbase\n              // containing each of the two choices.\n              if (result2.base_type == nonvirtual_base_type\n                  || result.base_type == nonvirtual_base_type\n                  || !(*result2.base_type == *result.base_type))\n                {\n                  // Already ambiguous, not virtual or via different virtuals.\n                  // Cannot match.\n                  result.part2dst = __contained_ambig;\n                  return true;\n                }\n              result.part2dst\n                  = __sub_kind (result.part2dst | result2.part2dst);\n            }\n        }\n    }\n  return result.part2dst != __unknown;\n}","filepath":"libstdc++-v3/libsupc++/vmi_class_type_info.cc","line_number":304,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5344288":{"score":0.8129854,"function_name":"__convert_to_v","code":"void\n    __convert_to_v(const char* __s, long double\u0026 __v, ios_base::iostate\u0026 __err,\n\t\t   const __c_locale\u0026 __cloc) throw()\n    {\n      char* __sanity;\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n      // Prefer strtold_l, as __strtold_l isn't prototyped in more recent\n      // glibc versions.\n      __v = strtold_l(__s, \u0026__sanity, __cloc);\n#else\n      __v = __strtold_l(__s, \u0026__sanity, __cloc);\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 23. Num_get overflow result.\n      if (__sanity == __s || *__sanity != '\\0')\n\t{\n\t  __v = 0.0l;\n\t  __err = ios_base::failbit;\n\t}\n      else if (__v == numeric_limits\u003clong double\u003e::infinity())\n\t{\n\t  __v = numeric_limits\u003clong double\u003e::max();\n\t  __err = ios_base::failbit;\n\t}\n      else if (__v == -numeric_limits\u003clong double\u003e::infinity())\n\t{\n\t  __v = -numeric_limits\u003clong double\u003e::max();\n\t  __err = ios_base::failbit;\n\t}\n    }","filepath":"libstdc++-v3/config/locale/gnu/c_locale.cc","line_number":99,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5344640":{"score":0.8595587,"function_name":"locale::facet::_S_create_c_locale","code":"void\n  locale::facet::_S_create_c_locale(__c_locale\u0026 __cloc, const char* __s,\n\t\t\t\t    __c_locale __old)\n  {\n    __cloc = __newlocale(1 \u003c\u003c LC_ALL, __s, __old);\n    if (!__cloc)\n      {\n\t// This named locale is not supported by the underlying OS.\n\t__throw_runtime_error(__N(\"locale::facet::_S_create_c_locale \"\n\t\t\t\t  \"name not valid\"));\n      }\n  }","filepath":"libstdc++-v3/config/locale/gnu/c_locale.cc","line_number":131,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5344752":{"score":0.87188745,"function_name":"locale::facet::_S_lc_ctype_c_locale","code":"__c_locale\n  locale::facet::_S_lc_ctype_c_locale(__c_locale __cloc, const char* __s)\n  {\n    __c_locale __dup = __duplocale(__cloc);\n    if (__dup == __c_locale(0))\n      __throw_runtime_error(__N(\"locale::facet::_S_lc_ctype_c_locale \"\n\t\t\t\t\"duplocale error\"));\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __changed = __newlocale(LC_CTYPE_MASK, __s, __dup);\n#else\n    __c_locale __changed = __newlocale(1 \u003c\u003c LC_CTYPE, __s, __dup);\n#endif\n    if (__changed == __c_locale(0))\n      {\n\t__freelocale(__dup);\n\t__throw_runtime_error(__N(\"locale::facet::_S_lc_ctype_c_locale \"\n\t\t\t\t  \"newlocale error\"));\n      }\n    return __changed;\n  }","filepath":"libstdc++-v3/config/locale/gnu/c_locale.cc","line_number":155,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5347776":{"score":0.7206743,"function_name":"locale::name","code":"_GLIBCXX_DEFAULT_ABI_TAG\n  string\n  locale::name() const\n  {\n    string __ret;\n    if (!_M_impl-\u003e_M_names[0])\n      __ret = '*';\n    else if (_M_impl-\u003e_M_check_same_name())\n      __ret = _M_impl-\u003e_M_names[0];\n    else\n      {\n\t__ret.reserve(128);\n\t__ret += _S_categories[0];\n\t__ret += '=';\n\t__ret += _M_impl-\u003e_M_names[0];\n\tfor (size_t __i = 1; __i \u003c _S_categories_size; ++__i)\n\t  {\n\t    __ret += ';';\n\t    __ret += _S_categories[__i];\n\t    __ret += '=';\n\t    __ret += _M_impl-\u003e_M_names[__i];\n\t  }\n      }\n    return __ret;\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":129,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5348592":{"score":0.6771625,"function_name":"locale::operator==","code":"bool\n  locale::operator==(const locale\u0026 __rhs) const throw()\n  {\n    // Deal first with the common cases, fast to process: refcopies,\n    // unnamed (i.e., !_M_names[0]), \"simple\" (!_M_names[1] =\u003e all the\n    // categories same name, i.e., _M_names[0]). Otherwise fall back\n    // to the general locale::name().\n    bool __ret;\n    if (_M_impl == __rhs._M_impl)\n      __ret = true;\n    else if (!_M_impl-\u003e_M_names[0] || !__rhs._M_impl-\u003e_M_names[0]\n\t     || std::strcmp(_M_impl-\u003e_M_names[0],\n\t\t\t    __rhs._M_impl-\u003e_M_names[0]) != 0)\n      __ret = false;\n    else if (!_M_impl-\u003e_M_names[1] \u0026\u0026 !__rhs._M_impl-\u003e_M_names[1])\n      __ret = true;\n    else\n      __ret = this-\u003ename() == __rhs.name();\n    return __ret;\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":97,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5348944":{"score":0.74418545,"function_name":"locale::_S_normalize_category","code":"locale::category\n  locale::_S_normalize_category(category __cat)\n  {\n    int __ret = 0;\n    if (__cat == none || ((__cat \u0026 all) \u0026\u0026 !(__cat \u0026 ~all)))\n      __ret = __cat;\n    else\n      {\n\t// NB: May be a C-style \"LC_ALL\" category; convert.\n\tswitch (__cat)\n\t  {\n\t  case LC_COLLATE:\n\t    __ret = collate;\n\t    break;\n\t  case LC_CTYPE:\n\t    __ret = ctype;\n\t    break;\n\t  case LC_MONETARY:\n\t    __ret = monetary;\n\t    break;\n\t  case LC_NUMERIC:\n\t    __ret = numeric;\n\t    break;\n\t  case LC_TIME:\n\t    __ret = time;\n\t    break;\n#ifdef _GLIBCXX_HAVE_LC_MESSAGES\n\t  case LC_MESSAGES:\n\t    __ret = messages;\n\t    break;\n#endif\n\t  case LC_ALL:\n\t    __ret = all;\n\t    break;\n\t  default:\n\t    __throw_runtime_error(__N(\"locale::_S_normalize_category \"\n\t\t\t\t  \"category not found\"));\n\t  }\n      }\n    return __ret;\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":155,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5349216":{"score":0.64990836,"function_name":"locale::_Impl::\n  ~_Impl","code":"locale::_Impl::\n  ~_Impl() throw()\n  {\n    if (_M_facets)\n      for (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\tif (_M_facets[__i])\n\t  _M_facets[__i]-\u003e_M_remove_reference();\n    delete [] _M_facets;\n\n    if (_M_caches)\n      for (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\tif (_M_caches[__i])\n\t  _M_caches[__i]-\u003e_M_remove_reference();\n    delete [] _M_caches;\n\n    if (_M_names)\n      for (size_t __i = 0; __i \u003c _S_categories_size; ++__i)\n\tdelete [] _M_names[__i];\n    delete [] _M_names;\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":236,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5350272":{"score":0.7267579,"function_name":"locale::id::_M_id","code":"size_t\n  locale::id::_M_id() const throw()\n  {\n    if (!_M_index)\n      {\n\t// XXX GLIBCXX_ABI Deprecated\n#ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n\tif (locale::id* f = find_ldbl_sync_facet(this))\n\t{\n\t  const size_t sync_id = f-\u003e_M_id();\n\t  _M_index = 1 + sync_id;\n\t  return sync_id;\n\t}\n#endif\n\n#ifdef __GTHREADS\n\tif (!__gnu_cxx::__is_single_threaded())\n\t  {\n\t    if (__atomic_always_lock_free(sizeof(_M_index), \u0026_M_index))\n\t      {\n\t\tconst _Atomic_word next\n\t\t  = 1 + __gnu_cxx::__exchange_and_add(\u0026_S_refcount, 1);\n\t\tsize_t expected = 0;\n\t\t__atomic_compare_exchange_n(\u0026_M_index, \u0026expected, next,\n\t\t\t\t\t    /* weak = */ false,\n\t\t\t\t\t    /* success = */ __ATOMIC_ACQ_REL,\n\t\t\t\t\t    /* failure = */ __ATOMIC_ACQUIRE);\n\t      }\n\t    else\n\t      {\n\t\tstatic __gnu_cxx::__mutex m;\n\t\t__gnu_cxx::__scoped_lock l(m);\n\t\tif (!_M_index)\n\t\t  _M_index = ++_S_refcount;\n\t      }\n\t  }\n\telse\n#endif\n\t_M_index = ++_S_refcount; // single-threaded case\n      }\n    return _M_index - 1;\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":502,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5350336":{"score":0.70826936,"function_name":"locale::_Impl::\n  _M_install_facet","code":"void\n  locale::_Impl::\n  _M_install_facet(const locale::id* __idp, const facet* __fp)\n  {\n    if (__fp)\n      {\n\tsize_t __index = __idp-\u003e_M_id();\n\n\t// Check size of facet vector to ensure adequate room.\n\tif (__index \u003e _M_facets_size - 1)\n\t  {\n\t    const size_t __new_size = __index + 4;\n\n\t    // New facet array.\n\t    const facet** __oldf = _M_facets;\n\t    const facet** __newf;\n\t    __newf = new const facet*[__new_size];\n\t    for (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\t      __newf[__i] = _M_facets[__i];\n\t    for (size_t __l = _M_facets_size; __l \u003c __new_size; ++__l)\n\t      __newf[__l] = 0;\n\n\t    // New cache array.\n\t    const facet** __oldc = _M_caches;\n\t    const facet** __newc;\n\t    __try\n\t      {\n\t\t__newc = new const facet*[__new_size];\n\t      }\n\t    __catch(...)\n\t      {\n\t\tdelete [] __newf;\n\t\t__throw_exception_again;\n\t      }\n\t    for (size_t __j = 0; __j \u003c _M_facets_size; ++__j)\n\t      __newc[__j] = _M_caches[__j];\n\t    for (size_t __k = _M_facets_size; __k \u003c __new_size; ++__k)\n\t      __newc[__k] = 0;\n\n\t    _M_facets_size = __new_size;\n\t    _M_facets = __newf;\n\t    _M_caches = __newc;\n\t    delete [] __oldf;\n\t    delete [] __oldc;\n\t  }\n\n\t__fp-\u003e_M_add_reference();\n\tconst facet*\u0026 __fpr = _M_facets[__index];\n\tif (__fpr)\n\t  {\n#if _GLIBCXX_USE_DUAL_ABI\n            // If this is a twinned facet replace its twin with a shim.\n            for (const id* const* p = _S_twinned_facets; *p != 0; p += 2)\n              {\n                if (p[0]-\u003e_M_id() == __index)\n                  {\n                    // replacing the old ABI facet, also replace new ABI twin\n                    const facet*\u0026 __fpr2 = _M_facets[p[1]-\u003e_M_id()];\n                    if (__fpr2)\n                      {\n                        const facet* __fp2 = __fp-\u003e_M_sso_shim(p[1]);\n                        __fp2-\u003e_M_add_reference();\n                        __fpr2-\u003e_M_remove_reference();\n                        __fpr2 = __fp2;\n                      }\n                    break;\n                  }\n                else if (p[1]-\u003e_M_id() == __index)\n                  {\n                    // replacing the new ABI facet, also replace old ABI twin\n                    const facet*\u0026 __fpr2 = _M_facets[p[0]-\u003e_M_id()];\n                    if (__fpr2)\n                      {\n                        const facet* __fp2 = __fp-\u003e_M_cow_shim(p[0]);\n                        __fp2-\u003e_M_add_reference();\n                        __fpr2-\u003e_M_remove_reference();\n                        __fpr2 = __fp2;\n                      }\n                    break;\n                  }\n              }\n#endif\n\t    // Replacing an existing facet. Order matters.\n\t    __fpr-\u003e_M_remove_reference();\n\t    __fpr = __fp;\n\t  }\n\telse\n\t  {\n\t    // Installing a newly created facet into an empty\n\t    // _M_facets container, say a newly-constructed,\n\t    // swanky-fresh _Impl.\n\t    _M_facets[__index] = __fp;\n\t  }\n\n\t// Ideally, it would be nice to only remove the caches that\n\t// are now incorrect. However, some of the caches depend on\n\t// multiple facets, and we only know about one facet\n\t// here. It's no great loss: the first use of the new facet\n\t// will create a new, correctly cached facet anyway.\n\tfor (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\t  {\n\t    const facet* __cpr = _M_caches[__i];\n\t    if (__cpr)\n\t      {\n\t\t__cpr-\u003e_M_remove_reference();\n\t\t_M_caches[__i] = 0;\n\t      }\n\t  }\n      }\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":319,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5351440":{"score":0.8938172,"function_name":"locale::_Impl::\n  _M_replace_facet","code":"void\n  locale::_Impl::\n  _M_replace_facet(const _Impl* __imp, const locale::id* __idp)\n  {\n    size_t __index = __idp-\u003e_M_id();\n    if ((__index \u003e (__imp-\u003e_M_facets_size - 1))\n\t|| !__imp-\u003e_M_facets[__index])\n      __throw_runtime_error(__N(\"locale::_Impl::_M_replace_facet\"));\n    _M_install_facet(__idp, __imp-\u003e_M_facets[__index]);\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":308,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5351520":{"score":0.7918063,"function_name":"locale::_Impl::\n  _M_replace_category","code":"void\n  locale::_Impl::\n  _M_replace_category(const _Impl* __imp,\n\t\t      const locale::id* const* __idpp)\n  {\n    for (; *__idpp; ++__idpp)\n      _M_replace_facet(__imp, *__idpp);\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":299,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5351584":{"score":0.6035982,"function_name":"locale::_Impl::\n  _M_install_cache","code":"void\n  locale::_Impl::\n  _M_install_cache(const facet* __cache, size_t __index)\n  {\n    __gnu_cxx::__scoped_lock sentry(get_locale_cache_mutex());\n#if _GLIBCXX_USE_DUAL_ABI\n    // If this cache is for one of the facets that is instantiated twice,\n    // for old and new std::string ABI, install it in both slots.\n    size_t __index2 = -1;\n    for (const id* const* p = _S_twinned_facets; *p != 0; p += 2)\n      {\n        if (p[0]-\u003e_M_id() == __index)\n          {\n            __index2 = p[1]-\u003e_M_id();\n            break;\n          }\n        else if (p[1]-\u003e_M_id() == __index)\n          {\n            __index2 = __index;\n            __index = p[0]-\u003e_M_id();\n            break;\n          }\n      }\n#endif\n    if (_M_caches[__index] != 0)\n      {\n\t// Some other thread got in first.\n\tdelete __cache;\n      }\n    else\n      {\n\t__cache-\u003e_M_add_reference();\n\t_M_caches[__index] = __cache;\n#if _GLIBCXX_USE_DUAL_ABI\n        if (__index2 != size_t(-1))\n          {\n            __cache-\u003e_M_add_reference();\n            _M_caches[__index2] = __cache;\n          }\n#endif\n      }\n  }","filepath":"libstdc++-v3/src/c++98/locale.cc","line_number":430,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5352208":{"score":0.73254615,"function_name":"ios_base::_M_init","code":"_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // Called only by basic_ios\u003c\u003e::init.\n  void\n  ios_base::_M_init() throw()\n  {\n    // NB: May be called more than once\n    _M_precision = 6;\n    _M_width = 0;\n    _M_flags = skipws | dec;\n    _M_ios_locale = locale();\n  }","filepath":"libstdc++-v3/src/c++98/ios_locale.cc","line_number":34,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5357264":{"score":0.6207216,"function_name":"locale::_S_initialize","code":"void\n  locale::_S_initialize()\n  {\n#ifdef __GTHREADS\n    if (__gthread_active_p())\n      __gthread_once(\u0026_S_once, _S_initialize_once);\n#endif\n    if (!_S_classic)\n      _S_initialize_once();\n  }","filepath":"libstdc++-v3/src/c++98/locale_init.cc","line_number":319,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-9.3.0"},"5357344":{"score":0.63237345,"function_name":"locale::locale","code":"locale::locale() throw() : _M_impl(0)\n  { \n    _S_initialize();\n\n    // Checked locking to optimize the common case where _S_global\n    // still points to _S_classic (locale::_S_initialize_once()):\n    // - If they are the same, just increment the reference count and\n    //   we are done.  This effectively constructs a C locale object\n    //   identical to the static c_locale.\n    // - Otherwise, _S_global can and may be destroyed due to\n    //   locale::global() call on another thread, in which case we\n    //   fall back to lock protected access to both _S_global and\n    //   its reference count.\n    _M_impl = _S_global;\n    if (_M_impl == _S_classic)\n      _M_impl-\u003e_M_add_reference();\n    else\n      {\n        __gnu_cxx::__scoped_lock sentry(get_locale_mutex());\n        _S_global-\u003e_M_add_reference();\n        _M_impl = _S_global;\n      }\n  }","filepath":"libstdc++-v3/src/locale_init.cc","line_number":208,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5357632":{"score":0.5652965,"function_name":"locale::global","code":"locale\n  locale::global(const locale\u0026 __other)\n  {\n    _S_initialize();\n    _Impl* __old;\n    {\n      __gnu_cxx::lock sentry(__gnu_internal::locale_mutex);\n      __old = _S_global;\n      __other._M_impl-\u003e_M_add_reference();\n      _S_global = __other._M_impl; \n      if (__other.name() != \"*\")\n\tsetlocale(LC_ALL, __other.name().c_str());\n    }\n\n    // Reference count sanity check: one reference removed for the\n    // subsition of __other locale, one added by return-by-value. Net\n    // difference: zero. When the returned locale object's destrutor\n    // is called, then the reference count is decremented and possibly\n    // destroyed.\n    return locale(__old);\n  }","filepath":"libstdc++-v3/src/locale_init.cc","line_number":108,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.2"},"5362816":{"score":0.5804419,"function_name":"_Parameter","code":"_Parameter(const _Type*\u0026 __it, const char* __name, _Is_iterator)\n        : _M_kind(__iterator), _M_variant()\n        {\n\t  _M_variant._M_iterator._M_name = __name;\n\t  _M_variant._M_iterator._M_address = \u0026__it;\n#if __cpp_rtti\n\t  _M_variant._M_iterator._M_type = \u0026typeid(__it);\n#else\n\t  _M_variant._M_iterator._M_type = 0;\n#endif\n\t  _M_variant._M_iterator._M_constness = __mutable_iterator;\n\t  _M_variant._M_iterator._M_state = __it? __unknown_state : __singular;\n\t  _M_variant._M_iterator._M_sequence = 0;\n\t  _M_variant._M_iterator._M_seq_type = 0;\n\t}","filepath":"libstdc++-v3/include/debug/formatter.h","line_number":289,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5364960":{"score":0.61671793,"function_name":"ctype_byname\u003cchar\u003e::ctype_byname","code":"ctype_byname\u003cchar\u003e::ctype_byname(const char* __s, size_t __refs)\n  : ctype\u003cchar\u003e(0, false, __refs) \n  { \t\n    if (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n      {\n\tthis-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_ctype);\n\tthis-\u003e_S_create_c_locale(this-\u003e_M_c_locale_ctype, __s); \n      }\n  }","filepath":"libstdc++-v3/config/locale/generic/ctype_members.cc","line_number":45,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5366880":{"score":0.6168562,"function_name":"numpunct_byname","code":"explicit\n      numpunct_byname(const char* __s, size_t __refs = 0)\n      : numpunct\u003c_CharT\u003e(__refs)\n      {\n\tif (__builtin_strcmp(__s, \"C\") != 0\n\t    \u0026\u0026 __builtin_strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    __c_locale __tmp;\n\t    this-\u003e_S_create_c_locale(__tmp, __s);\n\t    this-\u003e_M_initialize_numpunct(__tmp);\n\t    this-\u003e_S_destroy_c_locale(__tmp);\n\t  }\n      }","filepath":"libstdc++-v3/include/bits/locale_facets.h","line_number":1909,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.4.0"},"5369648":{"score":0.6833249,"function_name":"messages\u003c_CharT\u003e::messages","code":"messages\u003c_CharT\u003e::messages(__c_locale __cloc, const char* __s,\n\t\t\t       size_t __refs)\n    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)\n    {\n      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)\n\t{\n\t  const size_t __len = __builtin_strlen(__s) + 1;\n\t  char* __tmp = new char[__len];\n\t  __builtin_memcpy(__tmp, __s, __len);\n\t  _M_name_messages = __tmp;\n\t}\n      else\n\t_M_name_messages = _S_get_c_name();\n\n      // Last to avoid leaking memory if new throws.\n      _M_c_locale_messages = _S_clone_c_locale(__cloc);\n    }","filepath":"libstdc++-v3/config/locale/gnu/messages_members.h","line_number":50,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-git"},"5370016":{"score":0.74346316,"function_name":"messages_byname\u003c_CharT\u003e::messages_byname","code":"messages_byname\u003c_CharT\u003e::messages_byname(const char* __s, size_t __refs)\n    : messages\u003c_CharT\u003e(__refs)\n    {\n      if (this-\u003e_M_name_messages != locale::facet::_S_get_c_name())\n\t{\n\t  delete [] this-\u003e_M_name_messages;\n\t  if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)\n\t    {\n\t      const size_t __len = __builtin_strlen(__s) + 1;\n\t      char* __tmp = new char[__len];\n\t      __builtin_memcpy(__tmp, __s, __len);\n\t      this-\u003e_M_name_messages = __tmp;\n\t    }\n\t  else\n\t    this-\u003e_M_name_messages = locale::facet::_S_get_c_name();\n\t}\n\n      if (__builtin_strcmp(__s, \"C\") != 0\n\t  \u0026\u0026 __builtin_strcmp(__s, \"POSIX\") != 0)\n\t{\n\t  this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_messages);\n\t  this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_messages, __s);\n\t}\n    }","filepath":"libstdc++-v3/config/locale/gnu/messages_members.h","line_number":104,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-git"},"5370304":{"score":0.77893466,"function_name":"messages_byname\u003c_CharT\u003e::messages_byname","code":"messages_byname\u003c_CharT\u003e::messages_byname(const char* __s, size_t __refs)\n     : messages\u003c_CharT\u003e(__refs) \n     { \n\tif (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_messages);\n\t    this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_messages, __s); \n\t  }\n     }","filepath":"libstdc++-v3/config/locale/generic/messages_members.h","line_number":76,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5371040":{"score":0.59383035,"function_name":"messages_byname\u003c_CharT\u003e::messages_byname","code":"messages_byname\u003c_CharT\u003e::messages_byname(const char* __s, size_t __refs)\n     : messages\u003c_CharT\u003e(__refs) \n     { \n       if (this-\u003e_M_name_messages != locale::facet::_S_get_c_name())\n\t {\n\t   delete [] this-\u003e_M_name_messages;\n\t   if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)\n\t     {\n\t       const size_t __len = __builtin_strlen(__s) + 1;\n\t       char* __tmp = new char[__len];\n\t       __builtin_memcpy(__tmp, __s, __len);\n\t       this-\u003e_M_name_messages = __tmp;\n\t     }\n\t   else\n\t     this-\u003e_M_name_messages = locale::facet::_S_get_c_name();\n\t }\n\n       if (__builtin_strcmp(__s, \"C\") != 0\n\t   \u0026\u0026 __builtin_strcmp(__s, \"POSIX\") != 0)\n\t {\n\t   this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_messages);\n\t   this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_messages, __s); \n\t }\n     }","filepath":"libstdc++-v3/config/locale/gnu/messages_members.h","line_number":104,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5382960":{"score":0.66642845,"function_name":"operator++","code":"__istreambufiter_type\u0026 \n      operator++()\n      { \n\tif (_M_istreambuf)\n\t  _M_istreambuf-\u003esbumpc();\n\t_M_c = -2;\n\treturn *this; \n      }","filepath":"libstdc++-v3/include/bits/sbuf_iter.h","line_number":179,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-2.92"},"5391088":{"score":0.67121446,"function_name":"equal","code":"bool \n      equal(const istreambuf_iterator\u0026 __b) const\n      {\n\tconst int_type __eof = traits_type::eof();\n\tbool __thiseof = _M_get() == __eof;\n\tbool __beof = __b._M_get() == __eof;\n\treturn (__thiseof \u0026\u0026 __beof || (!__thiseof \u0026\u0026 !__beof));\n      }","filepath":"libstdc++-v3/include/bits/streambuf_iterator.h","line_number":109,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.1.0"},"5391344":{"score":0.78070366,"function_name":"_M_get","code":"int_type \n      _M_get() const\n      { \n\tint_type __ret = traits_type::eof();\n\tif (_M_sbuf)\n\t  { \n\t    if (_M_c != static_cast\u003cint_type\u003e(-2))\n\t      __ret = _M_c;\n\t    else \n\t      if ((__ret = _M_sbuf-\u003esgetc()) == traits_type::eof())\n\t\t_M_sbuf = 0;\n\t  }\n\treturn __ret;\n      }","filepath":"libstdc++-v3/include/bits/streambuf_iterator.h","line_number":120,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.1.0"},"5431088":{"score":0.5357167,"function_name":"__codecvt_utf8_base\u003cwchar_t\u003e::\ndo_in","code":"codecvt_base::result\n__codecvt_utf8_base\u003cwchar_t\u003e::\ndo_in(state_type\u0026, const extern_type* __from, const extern_type* __from_end,\n      const extern_type*\u0026 __from_next,\n      intern_type* __to, intern_type* __to_end,\n      intern_type*\u0026 __to_next) const\n{\n  range\u003cconst char\u003e from{ __from, __from_end };\n#if __SIZEOF_WCHAR_T__ == 2\n  range\u003cchar16_t\u003e to{\n    reinterpret_cast\u003cchar16_t*\u003e(__to),\n    reinterpret_cast\u003cchar16_t*\u003e(__to_end)\n  };\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n  codecvt_mode mode = {};\n#else\n  codecvt_mode mode = little_endian;\n#endif\n  auto res = ucs2_in(from, to, _M_maxcode, mode);\n#elif __SIZEOF_WCHAR_T__ == 4\n  range\u003cchar32_t\u003e to{\n    reinterpret_cast\u003cchar32_t*\u003e(__to),\n    reinterpret_cast\u003cchar32_t*\u003e(__to_end)\n  };\n  auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n#else\n  return codecvt_base::error;\n#endif\n  __from_next = from.next;\n  __to_next = reinterpret_cast\u003cwchar_t*\u003e(to.next);\n  return res;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1236,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5431504":{"score":0.72193706,"function_name":"ctype_byname\u003cchar\u003e::ctype_byname","code":"ctype_byname\u003cchar\u003e::ctype_byname(const char* __s, size_t __refs)\n    : ctype\u003cchar\u003e(0, false, __refs) \n    { \t\t\n      if (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n\t{\n\t  this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_ctype);\n\t  this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_ctype, __s); \n\t  this-\u003e_M_toupper = this-\u003e_M_c_locale_ctype-\u003e__ctype_toupper;\n\t  this-\u003e_M_tolower = this-\u003e_M_c_locale_ctype-\u003e__ctype_tolower;\n\t  this-\u003e_M_table = this-\u003e_M_c_locale_ctype-\u003e__ctype_b;\n\t}\n    }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":44,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5431664":{"score":0.63192236,"function_name":"ctype\u003cwchar_t\u003e::_M_convert_to_wmask","code":"ctype\u003cwchar_t\u003e::__wmask_type\n  ctype\u003cwchar_t\u003e::_M_convert_to_wmask(const mask __m) const\n  {\n    __wmask_type __ret;\n    switch (__m)\n      {\n      case space:\n\t__ret = __wctype_l(\"space\", _M_c_locale_ctype);\n\tbreak;\n      case print:\n\t__ret = __wctype_l(\"print\", _M_c_locale_ctype);\n\tbreak;\n      case cntrl:\n\t__ret = __wctype_l(\"cntrl\", _M_c_locale_ctype);\n\tbreak;\n      case upper:\n\t__ret = __wctype_l(\"upper\", _M_c_locale_ctype);\n\tbreak;\n      case lower:\n\t__ret = __wctype_l(\"lower\", _M_c_locale_ctype);\n\tbreak;\n      case alpha:\n\t__ret = __wctype_l(\"alpha\", _M_c_locale_ctype);\n\tbreak;\n      case digit:\n\t__ret = __wctype_l(\"digit\", _M_c_locale_ctype);\n\tbreak;\n      case punct:\n\t__ret = __wctype_l(\"punct\", _M_c_locale_ctype);\n\tbreak;\n      case xdigit:\n\t__ret = __wctype_l(\"xdigit\", _M_c_locale_ctype);\n\tbreak;\n      case alnum:\n\t__ret = __wctype_l(\"alnum\", _M_c_locale_ctype);\n\tbreak;\n      case graph:\n\t__ret = __wctype_l(\"graph\", _M_c_locale_ctype);\n\tbreak;\n      default:\n\t__ret = 0;\n      }\n    return __ret;\n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":58,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.1"},"5433104":{"score":0.6451626,"function_name":"ctype\u003cwchar_t\u003e::_M_initialize_ctype","code":"void\n  ctype\u003cwchar_t\u003e::_M_initialize_ctype() throw()\n  {\n    wint_t __i;\n    for (__i = 0; __i \u003c 128; ++__i)\n      {\n\tconst int __c = wctob(__i);\n\tif (__c == EOF)\n\t  break;\n\telse\n\t  _M_narrow[__i] = static_cast\u003cchar\u003e(__c);\n      }\n    if (__i == 128)\n      _M_narrow_ok = true;\n    else\n      _M_narrow_ok = false;\n    for (size_t __i = 0;\n\t __i \u003c sizeof(_M_widen) / sizeof(wint_t); ++__i)\n      _M_widen[__i] = btowc(__i);\n\n    for (size_t __i = 0; __i \u003c= 15; ++__i)\n      { \n\t_M_bit[__i] = static_cast\u003cmask\u003e(1 \u003c\u003c __i);\n\t_M_wmask[__i] = _M_convert_to_wmask(_M_bit[__i]);\n      }  \n  }","filepath":"libstdc++-v3/config/locale/generic/ctype_members.cc","line_number":247,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5433344":{"score":0.86195767,"function_name":"read_utf8_code_point","code":"char32_t\n  read_utf8_code_point(range\u003cconst C\u003e\u0026 from, unsigned long maxcode)\n  {\n    const size_t avail = from.size();\n    if (avail == 0)\n      return incomplete_mb_character;\n    char32_t c1 = (unsigned char) from[0];\n    // https://en.wikipedia.org/wiki/UTF-8#Sample_code\n    if (c1 \u003c 0x80)\n    {\n      ++from;\n      return c1;\n    }\n    else if (c1 \u003c 0xC2) // continuation or overlong 2-byte sequence\n      return invalid_mb_sequence;\n    else if (c1 \u003c 0xE0) // 2-byte sequence\n    {\n      if (avail \u003c 2)\n\treturn incomplete_mb_character;\n      char32_t c2 = (unsigned char) from[1];\n      if ((c2 \u0026 0xC0) != 0x80)\n\treturn invalid_mb_sequence;\n      char32_t c = (c1 \u003c\u003c 6) + c2 - 0x3080;\n      if (c \u003c= maxcode)\n\tfrom += 2;\n      return c;\n    }\n    else if (c1 \u003c 0xF0) // 3-byte sequence\n    {\n      if (avail \u003c 3)\n\treturn incomplete_mb_character;\n      char32_t c2 = (unsigned char) from[1];\n      if ((c2 \u0026 0xC0) != 0x80)\n\treturn invalid_mb_sequence;\n      if (c1 == 0xE0 \u0026\u0026 c2 \u003c 0xA0) // overlong\n\treturn invalid_mb_sequence;\n      char32_t c3 = (unsigned char) from[2];\n      if ((c3 \u0026 0xC0) != 0x80)\n\treturn invalid_mb_sequence;\n      char32_t c = (c1 \u003c\u003c 12) + (c2 \u003c\u003c 6) + c3 - 0xE2080;\n      if (c \u003c= maxcode)\n\tfrom += 3;\n      return c;\n    }\n    else if (c1 \u003c 0xF5) // 4-byte sequence\n    {\n      if (avail \u003c 4)\n\treturn incomplete_mb_character;\n      char32_t c2 = (unsigned char) from[1];\n      if ((c2 \u0026 0xC0) != 0x80)\n\treturn invalid_mb_sequence;\n      if (c1 == 0xF0 \u0026\u0026 c2 \u003c 0x90) // overlong\n\treturn invalid_mb_sequence;\n      if (c1 == 0xF4 \u0026\u0026 c2 \u003e= 0x90) // \u003e U+10FFFF\n      return invalid_mb_sequence;\n      char32_t c3 = (unsigned char) from[2];\n      if ((c3 \u0026 0xC0) != 0x80)\n\treturn invalid_mb_sequence;\n      char32_t c4 = (unsigned char) from[3];\n      if ((c4 \u0026 0xC0) != 0x80)\n\treturn invalid_mb_sequence;\n      char32_t c = (c1 \u003c\u003c 18) + (c2 \u003c\u003c 12) + (c3 \u003c\u003c 6) + c4 - 0x3C82080;\n      if (c \u003c= maxcode)\n\tfrom += 4;\n      return c;\n    }\n    else // \u003e U+10FFFF\n      return invalid_mb_sequence;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":251,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5434480":{"score":0.6342411,"function_name":"__codecvt_utf16_base\u003cchar32_t\u003e::\ndo_in","code":"codecvt_base::result\n__codecvt_utf16_base\u003cchar32_t\u003e::\ndo_in(state_type\u0026, const extern_type* __from, const extern_type* __from_end,\n      const extern_type*\u0026 __from_next,\n      intern_type* __to, intern_type* __to_end,\n      intern_type*\u0026 __to_next) const\n{\n  range\u003cconst char16_t, false\u003e from{ __from, __from_end };\n  range\u003cchar32_t\u003e to{ __to, __to_end };\n  auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n  __from_next = reinterpret_cast\u003cconst char*\u003e(from.next);\n  __to_next = to.next;\n  if (res == codecvt_base::ok \u0026\u0026 __from_next != __from_end)\n    res = codecvt_base::error;\n  return res;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1410,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5434832":{"score":0.7382517,"function_name":"read_utf16_code_point","code":"char32_t\n    read_utf16_code_point(range\u003cconst char16_t, Aligned\u003e\u0026 from,\n\t\t\t  unsigned long maxcode, codecvt_mode mode)\n    {\n      const size_t avail = from.size();\n      if (avail == 0)\n\treturn incomplete_mb_character;\n      int inc = 1;\n      char32_t c = adjust_byte_order(from[0], mode);\n      if (is_high_surrogate(c))\n\t{\n\t  if (avail \u003c 2)\n\t    return incomplete_mb_character;\n\t  const char16_t c2 = adjust_byte_order(from[1], mode);\n\t  if (is_low_surrogate(c2))\n\t    {\n\t      c = surrogate_pair_to_code_point(c, c2);\n\t      inc = 2;\n\t    }\n\t  else\n\t    return invalid_mb_sequence;\n\t}\n      else if (is_low_surrogate(c))\n\treturn invalid_mb_sequence;\n      if (c \u003c= maxcode)\n\tfrom += inc;\n      return c;\n    }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":395,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5435584":{"score":0.69462395,"function_name":"ucs4_span","code":"const C*\n  ucs4_span(const C* begin, const C* end, size_t max,\n            char32_t maxcode = max_code_point, codecvt_mode mode = {})\n  {\n    range\u003cconst C\u003e from{ begin, end };\n    read_utf8_bom(from, mode);\n    char32_t c = 0;\n    while (max-- \u0026\u0026 c \u003c= maxcode)\n      c = read_utf8_code_point(from, maxcode);\n    return from.next;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":716,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5435744":{"score":0.725695,"function_name":"__codecvt_utf16_base\u003cwchar_t\u003e::\ndo_length","code":"int\n__codecvt_utf16_base\u003cwchar_t\u003e::\ndo_length(state_type\u0026, const extern_type* __from,\n\t  const extern_type* __end, size_t __max) const\n{\n  range\u003cconst char16_t, false\u003e from{ __from, __end };\n#if __SIZEOF_WCHAR_T__ == 2\n  const char16_t* next = ucs2_span(from, __max, _M_maxcode, _M_mode);\n#elif __SIZEOF_WCHAR_T__ == 4\n  const char16_t* next = ucs4_span(from, __max, _M_maxcode, _M_mode);\n#endif\n  return reinterpret_cast\u003cconst char*\u003e(next) - __from;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1537,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5436320":{"score":0.5737059,"function_name":"write_bom","code":"bool\n    write_bom(range\u003cC, A\u003e\u0026 to, const unsigned char (\u0026bom)[N])\n    {\n      static_assert( (N / sizeof(C)) != 0, \"\" );\n      static_assert( (N % sizeof(C)) == 0, \"\" );\n\n      if (to.nbytes() \u003c N)\n\treturn false;\n      memcpy(to.next, bom, N);\n      to += (N / sizeof(C));\n      return true;\n    }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":166,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5436384":{"score":0.8636936,"function_name":"write_utf8_code_point","code":"bool\n  write_utf8_code_point(range\u003cC\u003e\u0026 to, char32_t code_point)\n  {\n    if (code_point \u003c 0x80)\n      {\n\tif (to.size() \u003c 1)\n\t  return false;\n\tto = code_point;\n      }\n    else if (code_point \u003c= 0x7FF)\n      {\n\tif (to.size() \u003c 2)\n\t  return false;\n\tto = (code_point \u003e\u003e 6) + 0xC0;\n\tto = (code_point \u0026 0x3F) + 0x80;\n      }\n    else if (code_point \u003c= 0xFFFF)\n      {\n\tif (to.size() \u003c 3)\n\t  return false;\n\tto = (code_point \u003e\u003e 12) + 0xE0;\n\tto = ((code_point \u003e\u003e 6) \u0026 0x3F) + 0x80;\n\tto = (code_point \u0026 0x3F) + 0x80;\n      }\n    else if (code_point \u003c= 0x10FFFF)\n      {\n\tif (to.size() \u003c 4)\n\t  return false;\n\tto = (code_point \u003e\u003e 18) + 0xF0;\n\tto = ((code_point \u003e\u003e 12) \u0026 0x3F) + 0x80;\n\tto = ((code_point \u003e\u003e 6) \u0026 0x3F) + 0x80;\n\tto = (code_point \u0026 0x3F) + 0x80;\n      }\n    else\n      return false;\n    return true;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":322,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5437408":{"score":0.6708844,"function_name":"write_utf16_bom","code":"bool\n  write_utf16_bom(range\u003cchar16_t, Aligned\u003e\u0026 to, codecvt_mode mode)\n  {\n    if (mode \u0026 generate_header)\n    {\n      if (mode \u0026 little_endian)\n\treturn write_bom(to, utf16le_bom);\n      else\n\treturn write_bom(to, utf16_bom);\n    }\n    return true;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":208,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5437600":{"score":0.7107264,"function_name":"__codecvt_utf8_utf16_base\u003cchar32_t\u003e::\ndo_out","code":"codecvt_base::result\n__codecvt_utf8_utf16_base\u003cchar32_t\u003e::\ndo_out(state_type\u0026, const intern_type* __from, const intern_type* __from_end,\n       const intern_type*\u0026 __from_next,\n       extern_type* __to, extern_type* __to_end,\n       extern_type*\u0026 __to_next) const\n{\n  range\u003cconst char32_t\u003e from{ __from, __from_end };\n  range\u003cchar\u003e to{ __to, __to_end };\n  auto res = utf16_out(from, to, _M_maxcode, _M_mode);\n  __from_next = from.next;\n  __to_next = to.next;\n  return res;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1646,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5437856":{"score":0.734519,"function_name":"codecvt\u003cchar32_t, char, mbstate_t\u003e::\ndo_in","code":"codecvt_base::result\ncodecvt\u003cchar32_t, char, mbstate_t\u003e::\ndo_in(state_type\u0026, const extern_type* __from, const extern_type* __from_end,\n      const extern_type*\u0026 __from_next,\n      intern_type* __to, intern_type* __to_end,\n      intern_type*\u0026 __to_next) const\n{\n  range\u003cconst char\u003e from{ __from, __from_end };\n  range\u003cchar32_t\u003e to{ __to, __to_end };\n  auto res = ucs4_in(from, to);\n  __from_next = from.next;\n  __to_next = to.next;\n  return res;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":849,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5438464":{"score":0.80359113,"function_name":"write_utf16_code_point","code":"bool\n  write_utf16_code_point(range\u003cC, A\u003e\u0026 to, char32_t codepoint, codecvt_mode mode)\n  {\n    static_assert(sizeof(C) \u003e= 2, \"a code unit must be at least 16-bit\");\n\n    if (codepoint \u003c= max_single_utf16_unit)\n      {\n\tif (to.size() \u003e 0)\n\t  {\n\t    to = adjust_byte_order(codepoint, mode);\n\t    return true;\n\t  }\n      }\n    else if (to.size() \u003e 1)\n      {\n\t// Algorithm from http://www.unicode.org/faq/utf_bom.html#utf16-4\n\tconst char32_t LEAD_OFFSET = 0xD800 - (0x10000 \u003e\u003e 10);\n\tchar16_t lead = LEAD_OFFSET + (codepoint \u003e\u003e 10);\n\tchar16_t trail = 0xDC00 + (codepoint \u0026 0x3FF);\n\tto = adjust_byte_order(lead, mode);\n\tto = adjust_byte_order(trail, mode);\n\treturn true;\n      }\n    return false;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":425,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5438880":{"score":0.58159995,"function_name":"ucs4_in","code":"codecvt_base::result\n  ucs4_in(range\u003cconst C\u003e\u0026 from, range\u003cchar32_t\u003e\u0026 to,\n          unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n  {\n    read_utf8_bom(from, mode);\n    while (from.size() \u0026\u0026 to.size())\n      {\n\tconst char32_t codepoint = read_utf8_code_point(from, maxcode);\n\tif (codepoint == incomplete_mb_character)\n\t  return codecvt_base::partial;\n\tif (codepoint \u003e maxcode)\n\t  return codecvt_base::error;\n\tto = codepoint;\n      }\n    return from.size() ? codecvt_base::partial : codecvt_base::ok;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":453,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5439152":{"score":0.7834698,"function_name":"__codecvt_utf8_base\u003cchar32_t\u003e::\ndo_in","code":"codecvt_base::result\n__codecvt_utf8_base\u003cchar32_t\u003e::\ndo_in(state_type\u0026, const extern_type* __from, const extern_type* __from_end,\n      const extern_type*\u0026 __from_next,\n      intern_type* __to, intern_type* __to_end,\n      intern_type*\u0026 __to_next) const\n{\n  range\u003cconst char\u003e from{ __from, __from_end };\n  range\u003cchar32_t\u003e to{ __to, __to_end };\n  auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n  __from_next = from.next;\n  __to_next = to.next;\n  return res;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1144,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5439408":{"score":0.7270376,"function_name":"__codecvt_utf8_base\u003cchar16_t\u003e::\ndo_in","code":"codecvt_base::result\n__codecvt_utf8_base\u003cchar16_t\u003e::\ndo_in(state_type\u0026, const extern_type* __from, const extern_type* __from_end,\n      const extern_type*\u0026 __from_next,\n      intern_type* __to, intern_type* __to_end,\n      intern_type*\u0026 __to_next) const\n{\n  range\u003cconst char\u003e from{ __from, __from_end };\n  range\u003cchar16_t\u003e to{ __to, __to_end };\n  codecvt_mode mode = codecvt_mode(_M_mode \u0026 (consume_header|generate_header));\n#if __BYTE_ORDER__ != __ORDER_BIG_ENDIAN__\n  mode = codecvt_mode(mode | little_endian);\n#endif\n  auto res = ucs2_in(from, to, _M_maxcode, mode);\n  __from_next = from.next;\n  __to_next = to.next;\n  return res;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1068,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5439696":{"score":0.5699791,"function_name":"__codecvt_utf16_base\u003cchar32_t\u003e::\ndo_length","code":"int\n__codecvt_utf16_base\u003cchar32_t\u003e::\ndo_length(state_type\u0026, const extern_type* __from,\n\t  const extern_type* __end, size_t __max) const\n{\n  range\u003cconst char16_t, false\u003e from{ __from, __end };\n  const char16_t* next = ucs4_span(from, __max, _M_maxcode, _M_mode);\n  return reinterpret_cast\u003cconst char*\u003e(next) - __from;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1435,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5440896":{"score":0.56683713,"function_name":"ucs2_span","code":"const char16_t*\n  ucs2_span(range\u003cconst char16_t, false\u003e\u0026 from, size_t max,\n            char32_t maxcode, codecvt_mode mode)\n  {\n    read_utf16_bom(from, mode);\n    // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n    maxcode = std::min(max_single_utf16_unit, maxcode);\n    char32_t c = 0;\n    while (max-- \u0026\u0026 c \u003c= maxcode)\n      c = read_utf16_code_point(from, maxcode, mode);\n    return reinterpret_cast\u003cconst char16_t*\u003e(from.next);\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":686,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5441104":{"score":0.7341112,"function_name":"__codecvt_utf8_base\u003cwchar_t\u003e::\ndo_length","code":"int\n__codecvt_utf8_base\u003cwchar_t\u003e::\ndo_length(state_type\u0026, const extern_type* __from,\n\t  const extern_type* __end, size_t __max) const\n{\n#if __SIZEOF_WCHAR_T__ == 2\n  __end = ucs2_span(__from, __end, __max, _M_maxcode, _M_mode);\n#elif __SIZEOF_WCHAR_T__ == 4\n  __end = ucs4_span(__from, __end, __max, _M_maxcode, _M_mode);\n#else\n  __end = __from;\n#endif\n  return __end - __from;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1277,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5441136":{"score":0.71154284,"function_name":"codecvt\u003cchar32_t, char, mbstate_t\u003e::\ndo_length","code":"int\ncodecvt\u003cchar32_t, char, mbstate_t\u003e::\ndo_length(state_type\u0026, const extern_type* __from,\n\t  const extern_type* __end, size_t __max) const\n{\n  __end = ucs4_span(__from, __end, __max);\n  return __end - __from;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":872,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5441168":{"score":0.7064771,"function_name":"utf16_span","code":"const C*\n  utf16_span(const C* begin, const C* end, size_t max,\n\t     char32_t maxcode = max_code_point, codecvt_mode mode = {})\n  {\n    range\u003cconst C\u003e from{ begin, end };\n    read_utf8_bom(from, mode);\n    size_t count = 0;\n    while (count+1 \u003c max)\n      {\n\tchar32_t c = read_utf8_code_point(from, maxcode);\n\tif (c \u003e maxcode)\n\t  return from.next;\n\telse if (c \u003e max_single_utf16_unit)\n\t  ++count;\n\t++count;\n      }\n    if (count+1 == max) // take one more character if it fits in a single unit\n      read_utf8_code_point(from, std::min(max_single_utf16_unit, maxcode));\n    return from.next;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":603,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5441456":{"score":0.722154,"function_name":"codecvt\u003cchar32_t, char8_t, mbstate_t\u003e::\ndo_length","code":"int\ncodecvt\u003cchar32_t, char8_t, mbstate_t\u003e::\ndo_length(state_type\u0026, const extern_type* __from,\n\t  const extern_type* __end, size_t __max) const\n{\n  __end = ucs4_span(__from, __end, __max);\n  return __end - __from;\n}","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":1021,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5441552":{"score":0.6656221,"function_name":"ucs4_out","code":"codecvt_base::result\n  ucs4_out(range\u003cconst char32_t\u003e\u0026 from, range\u003cchar16_t, false\u003e\u0026 to,\n           unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n  {\n    if (!write_utf16_bom(to, mode))\n      return codecvt_base::partial;\n    while (from.size())\n      {\n\tconst char32_t c = from[0];\n\tif (c \u003e maxcode)\n\t  return codecvt_base::error;\n\tif (!write_utf16_code_point(to, c, mode))\n\t  return codecvt_base::partial;\n\t++from;\n      }\n    return codecvt_base::ok;\n  }","filepath":"libstdc++-v3/src/c++11/codecvt.cc","line_number":509,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5444896":{"score":0.5458203,"function_name":"__messages_open","code":"messages_base::catalog\n    __messages_open(current_abi, const facet* f, const char* s, size_t n,\n\t\t    const locale\u0026 l)\n    {\n      auto* m = static_cast\u003cconst messages\u003cC\u003e*\u003e(f);\n      string str(s, n);\n      return m-\u003eopen(str, l);\n    }","filepath":"libstdc++-v3/src/c++11/cxx11-shim_facets.cc","line_number":616,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5445088":{"score":0.54884005,"function_name":"do_get","code":"virtual iter_type\n\tdo_get(iter_type s, iter_type end, bool intl, ios_base\u0026 io,\n\t       ios_base::iostate\u0026 err, string_type\u0026 digits) const\n\t{\n\t  __any_string st;\n\t  ios_base::iostate err2 = ios_base::goodbit;\n\t  s = __money_get(other_abi{}, _M_get(), s, end, intl, io, err2,\n\t\t\t  nullptr, \u0026st);\n\t  if (err2 == ios_base::goodbit)\n\t    digits = st;\n\t  else\n\t    err = err2;\n\t  return s;\n\t}","filepath":"libstdc++-v3/src/c++11/cxx11-shim_facets.cc","line_number":384,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5449152":{"score":0.6147635,"function_name":"__numpunct_fill_cache","code":"void\n    __numpunct_fill_cache(current_abi, const facet* f, __numpunct_cache\u003cC\u003e* c)\n    {\n      auto* m = static_cast\u003cconst numpunct\u003cC\u003e*\u003e(f);\n\n      c-\u003e_M_decimal_point = m-\u003edecimal_point();\n      c-\u003e_M_thousands_sep = m-\u003ethousands_sep();\n\n      c-\u003e_M_grouping = nullptr;\n      c-\u003e_M_truename = nullptr;\n      c-\u003e_M_falsename = nullptr;\n      // set _M_allocated so that if any allocation fails the previously\n      // allocated strings will be deleted in ~__numpunct_cache()\n      c-\u003e_M_allocated = true;\n\n      c-\u003e_M_grouping_size = __copy(c-\u003e_M_grouping, m-\u003egrouping());\n      c-\u003e_M_truename_size = __copy(c-\u003e_M_truename, m-\u003etruename());\n      c-\u003e_M_falsename_size = __copy(c-\u003e_M_falsename, m-\u003efalsename());\n    }","filepath":"libstdc++-v3/src/c++11/cxx11-shim_facets.cc","line_number":499,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5452144":{"score":0.6348197,"function_name":"__moneypunct_fill_cache","code":"void\n    __moneypunct_fill_cache(current_abi, const facet* f,\n\t\t\t    __moneypunct_cache\u003cC, Intl\u003e* c)\n    {\n      auto* m = static_cast\u003cconst moneypunct\u003cC, Intl\u003e*\u003e(f);\n\n      c-\u003e_M_decimal_point = m-\u003edecimal_point();\n      c-\u003e_M_thousands_sep = m-\u003ethousands_sep();\n      c-\u003e_M_frac_digits = m-\u003efrac_digits();\n\n      c-\u003e_M_grouping = nullptr;\n      c-\u003e_M_curr_symbol = nullptr;\n      c-\u003e_M_positive_sign = nullptr;\n      c-\u003e_M_negative_sign = nullptr;\n      // Set _M_allocated so that if any allocation fails the previously\n      // allocated strings will be deleted in ~__moneypunct_cache().\n      c-\u003e_M_allocated = true;\n\n      c-\u003e_M_grouping_size = __copy(c-\u003e_M_grouping, m-\u003egrouping());\n      c-\u003e_M_curr_symbol_size = __copy(c-\u003e_M_curr_symbol, m-\u003ecurr_symbol());\n      c-\u003e_M_positive_sign_size\n\t= __copy(c-\u003e_M_positive_sign, m-\u003epositive_sign());\n      c-\u003e_M_negative_sign_size\n\t= __copy(c-\u003e_M_negative_sign, m-\u003enegative_sign());\n\n      c-\u003e_M_pos_format = m-\u003epos_format();\n      c-\u003e_M_neg_format = m-\u003eneg_format();\n    }","filepath":"libstdc++-v3/src/c++11/cxx11-shim_facets.cc","line_number":568,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5453104":{"score":0.6919499,"function_name":"__messages_get","code":"void\n    __messages_get(current_abi, const facet* f, __any_string\u0026 st,\n\t\t   messages_base::catalog c, int set, int msgid,\n\t\t   const C* s, size_t n)\n    {\n      auto* m = static_cast\u003cconst messages\u003cC\u003e*\u003e(f);\n      st = m-\u003eget(c, set, msgid, basic_string\u003cC\u003e(s, n));\n    }","filepath":"libstdc++-v3/src/c++11/cxx11-shim_facets.cc","line_number":636,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5453808":{"score":0.7938981,"function_name":"__time_get","code":"istreambuf_iterator\u003cC\u003e\n    __time_get(current_abi, const facet* f,\n\t       istreambuf_iterator\u003cC\u003e beg, istreambuf_iterator\u003cC\u003e end,\n\t       ios_base\u0026 io, ios_base::iostate\u0026 err, tm* t, char which)\n    {\n      auto* g = static_cast\u003cconst time_get\u003cC\u003e*\u003e(f);\n      switch(which)\n      {\n      case 't':\n\treturn g-\u003eget_time(beg, end, io, err, t);\n      case 'd':\n\treturn g-\u003eget_date(beg, end, io, err, t);\n      case 'w':\n\treturn g-\u003eget_weekday(beg, end, io, err, t);\n      case 'm':\n\treturn g-\u003eget_monthname(beg, end, io, err, t);\n      case 'y':\n\treturn g-\u003eget_year(beg, end, io, err, t);\n      default:\n\t__builtin_unreachable();\n      }\n    }","filepath":"libstdc++-v3/src/c++11/cxx11-shim_facets.cc","line_number":685,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5463136":{"score":0.5537799,"function_name":"istream::ignore","code":"istream\u0026 istream::ignore(int n /* = 1 */, int delim /* = EOF */)\n{\n    _gcount = 0;\n    if (ipfx1()) {\n\tregister streambuf* sb = _strbuf;\n\tif (delim == EOF) {\n\t    _gcount = sb-\u003eignore(n);\n\t    return *this;\n\t}\n\tfor (;;) {\n#if 0\n\t    if (n != MAXINT) // FIXME\n#endif\n\t    if (--n \u003c 0)\n\t\tbreak;\n\t    int ch = sb-\u003esbumpc();\n\t    if (ch == EOF) {\n\t\tset(ios::eofbit|ios::failbit);\n\t\tbreak;\n\t    }\n\t    _gcount++;\n\t    if (ch == delim)\n\t\tbreak;\n\t}\n    }\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":89,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/start"},"5464128":{"score":0.6163206,"function_name":"istream::peek","code":"int istream::peek()\n{\n  if (!good())\n    return EOF;\n  if (_tie \u0026\u0026 rdbuf()-\u003ein_avail() == 0)\n    _tie-\u003eflush();\n  int ch = _strbuf-\u003esgetc();\n  if (ch == EOF)\n    set(ios::eofbit);\n  return ch;\n}","filepath":"libio/iostream.cc","line_number":77,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/start"},"5464416":{"score":0.5471879,"function_name":"istream::read","code":"istream\u0026 istream::read(char *s, streamsize n)\n{\n    if (ipfx1()) {\n\t_gcount = _strbuf-\u003esgetn(s, n);\n\tif (_gcount != n)\n\t    set(ios::failbit|ios::eofbit);\n    }\n    else\n      _gcount = 0;\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":117,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/start"},"5465056":{"score":0.4950788,"function_name":"ostream::operator\u003c\u003c","code":"ostream\u0026 ostream::operator\u003c\u003c(char c)\n{\n    if (opfx()) {\n#if 1\n\t// This is what the cfront implementation does.\n\tif (_strbuf-\u003esputc(c) == EOF)\n\t  goto failed;\n#else\n\t// This is what cfront documentation and current ANSI drafts say.\n\tint w = width(0);\n\tchar fill_char = fill();\n\tregister int padding = w \u003e 0 ? w - 1 : 0;\n\tregister streambuf *sb = _strbuf;\n\tif (!(flags() \u0026 ios::left) \u0026\u0026 padding) // Default adjustment.\n\t    if (_IO_padn(sb, fill_char, padding) \u003c padding)\n\t      goto failed;\n\tif (sb-\u003esputc(c) == EOF)\n\t  goto failed;\n\tif (flags() \u0026 ios::left \u0026\u0026 padding) // Left adjustment.\n\t    if (_IO_padn(sb, fill_char, padding) \u003c padding)\n\t      goto failed;\n#endif\n\tosfx();\n    }\n    return *this;\n  failed:\n    set(ios::badbit);\n    osfx();\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":362,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/start"},"5465712":{"score":0.6518937,"function_name":"istream::sync","code":"int\nistream::sync ()\n{\n  streambuf *sb = rdbuf ();\n  if (sb == NULL)\n    return EOF;\n  if (sb-\u003esync ()) // Later: pubsync\n    { \n      setstate (ios::badbit);\n      return EOF;\n    }\n  else\n    return 0;\n}","filepath":"libio/iostream.cc","line_number":129,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/start"},"5467168":{"score":0.6572492,"function_name":"istream::get","code":"istream\u0026 istream::get(char\u0026 c)\n{\n    if (ipfx1()) {\n\tint ch = _strbuf-\u003esbumpc();\n\tif (ch == EOF) {\n\t  set(ios::eofbit|ios::failbit);\n\t  _gcount = 0;\n\t}\n\telse {\n\t  c = (char)ch;\n\t  _gcount = 1;\n\t}\n    }\n    else\n      _gcount = 0;\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":59,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/start"},"5467728":{"score":0.54747844,"function_name":"istream::skip","code":"int istream::skip(int i)\n{\n    int old = (_flags \u0026 ios::skipws) != 0;\n    if (i)\n\t_flags |= ios::skipws;\n    else\n\t_flags \u0026= ~ios::skipws;\n    return old;\n}","filepath":"libio/iostream.cc","line_number":812,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/start"},"5475584":{"score":0.64080673,"function_name":"istream::ignore","code":"istream\u0026 istream::ignore(int n /* = 1 */, int delim /* = EOF */)\n{\n    _gcount = 0;\n    if (ipfx1()) {\n\tregister streambuf* sb = _strbuf;\n\tif (delim == EOF) {\n\t    _gcount = sb-\u003eignore(n);\n\t    return *this;\n\t}\n\tfor (;;) {\n#if 0\n\t    if (n != MAXINT) // FIXME\n#endif\n\t    if (--n \u003c 0)\n\t\tbreak;\n\t    int ch = sb-\u003esbumpc();\n\t    if (ch == EOF) {\n\t\tset(ios::eofbit|ios::failbit);\n\t\tbreak;\n\t    }\n\t    _gcount++;\n\t    if (ch == delim)\n\t\tbreak;\n\t}\n    }\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":101,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5476816":{"score":0.54271334,"function_name":"istream::read","code":"istream\u0026 istream::read(char *s, streamsize n)\n{\n    if (ipfx1()) {\n\t_gcount = _strbuf-\u003esgetn(s, n);\n\tif (_gcount != n)\n\t    set(ios::failbit|ios::eofbit);\n    }\n    else\n      _gcount = 0;\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":129,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5477456":{"score":0.46647626,"function_name":"ostream::operator\u003c\u003c","code":"ostream\u0026 ostream::operator\u003c\u003c(int n)\n{\n    if (opfx()) {\n\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n\t\t\t\t  _strbuf);\n\tint sign = 1;\n\tunsigned int abs_n = (unsigned)n;\n\tif (n \u003c 0 \u0026\u0026 (flags() \u0026 (ios::oct|ios::hex)) == 0)\n\t    abs_n = -((unsigned)n), sign = -1;\n\twrite_int(*this, abs_n, sign);\n\t_IO_cleanup_region_end (0);\n    }\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":515,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5478112":{"score":0.5947982,"function_name":"istream::peek","code":"int istream::peek()\n{\n  if (!good())\n    return EOF;\n  if (_tie \u0026\u0026 rdbuf()-\u003ein_avail() == 0)\n    _tie-\u003eflush();\n  int ch = _strbuf-\u003esgetc();\n  if (ch == EOF)\n    set(ios::eofbit);\n  return ch;\n}","filepath":"libio/iostream.cc","line_number":89,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5479280":{"score":0.4960646,"function_name":"istream::tellg","code":"streampos istream::tellg()\n{\n#if 0\n    streampos pos = _strbuf-\u003epubseekoff(0, ios::cur, ios::in);\n#else\n    streampos pos = _IO_seekoff (_strbuf, 0, _IO_seek_cur, _IOS_INPUT);\n#endif\n    if (pos == streampos(EOF))\n\tset(ios::badbit);\n    return pos;\n}","filepath":"libio/iostream.cc","line_number":172,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5479568":{"score":0.728482,"function_name":"istream::operator\u003e\u003e","code":"istream\u0026 istream::operator\u003e\u003e(char\u0026 c)\n{\n    if (ipfx0()) {\n\tint ch = _strbuf-\u003esbumpc();\n\tif (ch == EOF)\n\t    set(ios::eofbit|ios::failbit);\n\telse\n\t    c = (char)ch;\n    }\n    return *this;\n}","filepath":"libio/iostream.cc","line_number":184,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5479856":{"score":0.5565493,"function_name":"istream::operator\u003e\u003e","code":"istream\u0026\nistream::operator\u003e\u003e (char* ptr)\n{\n  register char *p = ptr;\n  int w = width(0);\n  if (ipfx0())\n    {\n      register streambuf* sb = _strbuf;\n      for (;;)\n\t{\n\t  int ch = sb-\u003esbumpc();\n\t  if (ch == EOF)\n\t    {\n\t      set(ios::eofbit);\n\t      break;\n\t    }\n\t  else if (isspace(ch) || w == 1)\n\t    {\n\t      sb-\u003esputbackc(ch);\n\t      break;\n\t    }\n\t  else *p++ = ch;\n\t  w--;\n\t}\n      if (p == ptr)\n\tset(ios::failbit);\n    }\n  *p = '\\0';\n  return *this;\n}","filepath":"libio/iostream.cc","line_number":196,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5480704":{"score":0.55482054,"function_name":"istream::skip","code":"int istream::skip(int i)\n{\n    int old = (_flags \u0026 ios::skipws) != 0;\n    if (i)\n\t_flags |= ios::skipws;\n    else\n\t_flags \u0026= ~ios::skipws;\n    return old;\n}","filepath":"libio/iostream.cc","line_number":971,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/egcs-1.0.0"},"5485344":{"score":0.7082088,"function_name":"basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    copy","code":"typename basic_string\u003c_CharT, _Traits, _Alloc\u003e::size_type\n    basic_string\u003c_CharT, _Traits, _Alloc\u003e::\n    copy(_CharT* __s, size_type __n, size_type __pos) const\n    {\n      _M_check(__pos, \"basic_string::copy\");\n      __n = _M_limit(__pos, __n);\n      __glibcxx_requires_string_len(__s, __n);\n      if (__n)\n\t_M_copy(__s, _M_data() + __pos, __n);\n      // 21.3.5.7 par 3: do not append null.  (good.)\n      return __n;\n    }","filepath":"libstdc++-v3/include/bits/cow_string.h","line_number":3642,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5491328":{"score":0.8293133,"function_name":"insert","code":"basic_string\u0026 \n      insert(size_type __pos, const _CharT* __s, size_type __n)\n      {\n\tconst size_type __size = this-\u003esize();\n \tif (__pos \u003e __size)\n\t  __throw_out_of_range(\"basic_string::insert\");\n\tif (__size \u003e this-\u003emax_size() - __n)\n\t  __throw_length_error(\"basic_string::insert\");\n\tif (_M_rep()-\u003e_M_is_shared() || less\u003cconst _CharT*\u003e()(__s, _M_data())\n\t    || less\u003cconst _CharT*\u003e()(_M_data() + __size, __s))\n\t  return _M_replace_safe(_M_ibegin() + __pos, _M_ibegin() + __pos,\n\t\t\t\t __s, __s + __n);\n\telse\n\t  {\n\t    // Work in-place. If _M_mutate reallocates the string, __s\n\t    // does not point anymore to valid data, therefore we save its\n\t    // offset, then we restore it.\n\t    const size_type __off = __s - _M_data();\n\t    _M_mutate(__pos, 0, __n);\n\t    __s = _M_data() + __off;\n\t    _CharT* __p = _M_data() + __pos;\n\t    if (__s  + __n \u003c= __p)\n\t      traits_type::copy(__p, __s, __n);\n\t    else if (__s \u003e= __p)\n\t      traits_type::copy(__p, __s + __n, __n);\n\t    else\n\t      {\n\t\ttraits_type::copy(__p, __s, __p - __s);\n\t\ttraits_type::copy(__p + (__p - __s), __p + __n, __n - (__p - __s));\n\t      }\n\t    return *this;\n\t  }\n       }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":548,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-3.0.97"},"5496048":{"score":0.674615,"function_name":"replace","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      {\n\t__glibcxx_requires_string_len(__s, __n2);\n\treturn _M_replace(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t  _M_limit(__pos, __n1), __s, __n2);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2165,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"release-12.2.mpacbti-bet1"},"5505904":{"score":0.71265644,"function_name":"erase","code":"_GLIBCXX20_CONSTEXPR\n      basic_string\u0026\n      erase(size_type __pos = 0, size_type __n = npos)\n      {\n\t_M_check(__pos, \"basic_string::erase\");\n\tif (__n == npos)\n\t  this-\u003e_M_set_length(__pos);\n\telse if (__n != 0)\n\t  this-\u003e_M_erase(__pos, _M_limit(__pos, __n));\n\treturn *this;\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2030,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5507520":{"score":0.7682648,"function_name":"assign","code":"basic_string\u0026 \n      assign(const basic_string\u0026 __str, size_type __pos, size_type __n)\n      {\n\tconst size_type __strsize = __str.size();\n\tif (__pos \u003e __strsize)\n\t  __throw_out_of_range(\"basic_string::assign\");\n\tconst bool __testn = __n \u003c __strsize - __pos;\n\tconst size_type __newsize = __testn ? __n : __strsize - __pos;\n\treturn this-\u003eassign(__str._M_data() + __pos, __newsize);\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":479,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/libstdc++-3.0.96"},"5507968":{"score":0.6111592,"function_name":"replace","code":"_If_sv\u003c_Tp, basic_string\u0026\u003e\n\treplace(size_type __pos1, size_type __n1, const _Tp\u0026 __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this-\u003ereplace(__pos1, __n1,\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos2, \"basic_string::replace\"),\n\t      std::__sv_limit(__sv.size(), __pos2, __n2));\n\t}","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":2216,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-9.4.0"},"5508144":{"score":0.62029684,"function_name":"_M_check","code":"_GLIBCXX20_CONSTEXPR\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos \u003e this-\u003esize())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) \u003e \"\n\t\t\t\t       \"this-\u003esize() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this-\u003esize());\n\treturn __pos;\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":377,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5513840":{"score":0.66760427,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_construct","code":"void\n      __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_construct(_InIterator __beg, _InIterator __end,\n\t\t   std::forward_iterator_tag)\n      {\n\t// NB: Not required, but considered best practice.\n\tif (__is_null_pointer(__beg) \u0026\u0026 __beg != __end)\n\t  std::__throw_logic_error(__N(\"__sso_string_base::\"\n\t\t\t\t       \"_M_construct null not valid\"));\n\n\tsize_type __dnew = static_cast\u003csize_type\u003e(std::distance(__beg, __end));\n\n\tif (__dnew \u003e size_type(_S_local_capacity))\n\t  {\n\t    _M_data(_M_create(__dnew, size_type(0)));\n\t    _M_capacity(__dnew);\n\t  }\n\n\t// Check for out_of_range and length_error exceptions.\n\t__try\n\t  { this-\u003e_S_copy_chars(_M_data(), __beg, __end); }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":433,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5514048":{"score":0.6451033,"function_name":"basic_string","code":"basic_string(const basic_string\u0026 __str, size_type __pos,\n\t\t   const _Alloc\u0026 __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start = __str._M_data()\n\t  + __str._M_check(__pos, \"basic_string::basic_string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, npos));\n      }","filepath":"libstdc++-v3/include/bits/basic_string.h","line_number":461,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-git"},"5518272":{"score":0.61826247,"function_name":"_Parameter","code":"_Parameter(_Type*\u0026 __it, const char* __name, _Is_iterator)\n        : _M_kind(__iterator), _M_variant()\n        {\n\t  _M_variant._M_iterator._M_name = __name;\n\t  _M_variant._M_iterator._M_address = \u0026__it;\n#ifdef __GXX_RTTI\n\t  _M_variant._M_iterator._M_type = \u0026typeid(__it);\n#else\n\t  _M_variant._M_iterator._M_type = 0;\n#endif\n\t  _M_variant._M_iterator._M_constness = __const_iterator;\n\t  _M_variant._M_iterator._M_state = __it? __unknown_state : __singular;\n\t  _M_variant._M_iterator._M_sequence = 0;\n\t  _M_variant._M_iterator._M_seq_type = 0;\n\t}","filepath":"libstdc++-v3/include/debug/formatter.h","line_number":299,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5518352":{"score":0.54133534,"function_name":"_Parameter","code":"_Parameter(const _Type*\u0026 __it, const char* __name, _Is_iterator)\n        : _M_kind(__iterator), _M_variant()\n        {\n\t  _M_variant._M_iterator._M_name = __name;\n\t  _M_variant._M_iterator._M_address = \u0026__it;\n#ifdef __GXX_RTTI\n\t  _M_variant._M_iterator._M_type = \u0026typeid(__it);\n#else\n\t  _M_variant._M_iterator._M_type = 0;\n#endif\n\t  _M_variant._M_iterator._M_constness = __mutable_iterator;\n\t  _M_variant._M_iterator._M_state = __it? __unknown_state : __singular;\n\t  _M_variant._M_iterator._M_sequence = 0;\n\t  _M_variant._M_iterator._M_seq_type = 0;\n\t}","filepath":"libstdc++-v3/include/debug/formatter.h","line_number":282,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5521152":{"score":0.6321835,"function_name":"ctype_byname\u003cchar\u003e::ctype_byname","code":"ctype_byname\u003cchar\u003e::ctype_byname(const char* __s, size_t __refs)\n  : ctype\u003cchar\u003e(0, false, __refs) \n  { \t\n    if (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n      {\n\tthis-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_ctype);\n\tthis-\u003e_S_create_c_locale(this-\u003e_M_c_locale_ctype, __s); \n      }\n  }","filepath":"libstdc++-v3/config/locale/generic/ctype_members.cc","line_number":41,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5533136":{"score":0.5061257,"function_name":"Type::method_constructor","code":"Expression*\nType::method_constructor(Gogo*, Type* method_type,\n\t\t\t const std::string\u0026 method_name,\n\t\t\t const Method* m,\n\t\t\t bool only_value_methods) const\n{\n  Location bloc = Linemap::predeclared_location();\n\n  const Struct_field_list* fields = method_type-\u003estruct_type()-\u003efields();\n\n  Expression_list* vals = new Expression_list();\n  vals-\u003ereserve(5);\n\n  Struct_field_list::const_iterator p = fields-\u003ebegin();\n  go_assert(p-\u003eis_field_name(\"name\"));\n  const std::string n = Gogo::unpack_hidden_name(method_name);\n  Expression* s = Expression::make_string(n, bloc);\n  vals-\u003epush_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n\n  ++p;\n  go_assert(p-\u003eis_field_name(\"pkgPath\"));\n  if (!Gogo::is_hidden_name(method_name))\n    vals-\u003epush_back(Expression::make_nil(bloc));\n  else\n    {\n      s = Expression::make_string(Gogo::hidden_name_pkgpath(method_name),\n\t\t\t\t  bloc);\n      vals-\u003epush_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n    }\n\n  Named_object* no = (m-\u003eneeds_stub_method()\n\t\t      ? m-\u003estub_object()\n\t\t      : m-\u003enamed_object());\n\n  Function_type* mtype;\n  if (no-\u003eis_function())\n    mtype = no-\u003efunc_value()-\u003etype();\n  else\n    mtype = no-\u003efunc_declaration_value()-\u003etype();\n  go_assert(mtype-\u003eis_method());\n  Type* nonmethod_type = mtype-\u003ecopy_without_receiver();\n\n  ++p;\n  go_assert(p-\u003eis_field_name(\"mtyp\"));\n  vals-\u003epush_back(Expression::make_type_descriptor(nonmethod_type, bloc));\n\n  ++p;\n  go_assert(p-\u003eis_field_name(\"typ\"));\n  bool want_pointer_receiver = !only_value_methods \u0026\u0026 m-\u003eis_value_method();\n  nonmethod_type = mtype-\u003ecopy_with_receiver_as_param(want_pointer_receiver);\n  vals-\u003epush_back(Expression::make_type_descriptor(nonmethod_type, bloc));\n\n  ++p;\n  go_assert(p-\u003eis_field_name(\"tfn\"));\n  vals-\u003epush_back(Expression::make_func_code_reference(no, bloc));\n\n  ++p;\n  go_assert(p == fields-\u003eend());\n\n  return Expression::make_struct_composite_literal(method_type, vals, bloc);\n}","filepath":"gcc/go/gofrontend/types.cc","line_number":2217,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.3"},"5542688":{"score":0.5103855,"function_name":"in","code":"result\n      in(state_type\u0026 __state, const extern_type* __from,\n\t const extern_type* __from_end, const extern_type*\u0026 __from_next,\n\t intern_type* __to, intern_type* __to_end,\n\t intern_type*\u0026 __to_next) const\n      {\n\treturn this-\u003edo_in(__state, __from, __from_end, __from_next,\n\t\t\t   __to, __to_end, __to_next);\n      }","filepath":"libstdc++-v3/include/bits/codecvt.h","line_number":199,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5544112":{"score":0.70829713,"function_name":"codecvt_byname","code":"explicit\n      codecvt_byname(const char* __s, size_t __refs = 0)\n      : codecvt\u003c_InternT, _ExternT, _StateT\u003e(__refs)\n      {\n\tif (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_codecvt);\n\t    this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_codecvt, __s);\n\t  }\n      }","filepath":"libstdc++-v3/include/bits/codecvt.h","line_number":456,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.2.0"},"5548048":{"score":0.58691376,"function_name":"prune_phi_opnds","code":"static bool\nprune_phi_opnds (gphi *phi, unsigned opnds, gphi *flag_def,\n\t\t tree boundary_cst, tree_code cmp_code,\n\t\t predicate::func_t \u0026eval,\n\t\t hash_set\u003cgphi *\u003e *visited_phis,\n\t\t bitmap *visited_flag_phis)\n{\n  /* The Boolean predicate guarding the PHI definition.  Initialized\n     lazily from PHI in the first call to is_use_guarded() and cached\n     for subsequent iterations.  */\n  predicate def_preds (eval);\n\n  unsigned n = MIN (eval.max_phi_args, gimple_phi_num_args (flag_def));\n  for (unsigned i = 0; i \u003c n; i++)\n    {\n      if (!MASK_TEST_BIT (opnds, i))\n\tcontinue;\n\n      tree flag_arg = gimple_phi_arg_def (flag_def, i);\n      if (!is_gimple_constant (flag_arg))\n\t{\n\t  if (TREE_CODE (flag_arg) != SSA_NAME)\n\t    return false;\n\n\t  gphi *flag_arg_def = dyn_cast\u003cgphi *\u003e (SSA_NAME_DEF_STMT (flag_arg));\n\t  if (!flag_arg_def)\n\t    return false;\n\n\t  tree phi_arg = gimple_phi_arg_def (phi, i);\n\t  if (TREE_CODE (phi_arg) != SSA_NAME)\n\t    return false;\n\n\t  gphi *phi_arg_def = dyn_cast\u003cgphi *\u003e (SSA_NAME_DEF_STMT (phi_arg));\n\t  if (!phi_arg_def)\n\t    return false;\n\n\t  if (gimple_bb (phi_arg_def) != gimple_bb (flag_arg_def))\n\t    return false;\n\n\t  if (!*visited_flag_phis)\n\t    *visited_flag_phis = BITMAP_ALLOC (NULL);\n\n\t  tree phi_result = gimple_phi_result (flag_arg_def);\n\t  if (bitmap_bit_p (*visited_flag_phis, SSA_NAME_VERSION (phi_result)))\n\t    return false;\n\n\t  bitmap_set_bit (*visited_flag_phis, SSA_NAME_VERSION (phi_result));\n\n\t  /* Now recursively try to prune the interesting phi args.  */\n\t  unsigned opnds_arg_phi = eval.phi_arg_set (phi_arg_def);\n\t  if (!prune_phi_opnds (phi_arg_def, opnds_arg_phi, flag_arg_def,\n\t\t\t\tboundary_cst, cmp_code, eval, visited_phis,\n\t\t\t\tvisited_flag_phis))\n\t    return false;\n\n\t  bitmap_clear_bit (*visited_flag_phis, SSA_NAME_VERSION (phi_result));\n\t  continue;\n\t}\n\n      /* Now check if the constant is in the guarded range.  */\n      if (is_value_included_in (flag_arg, boundary_cst, cmp_code))\n\t{\n\t  /* Now that we know that this undefined edge is not pruned.\n\t     If the operand is defined by another phi, we can further\n\t     prune the incoming edges of that phi by checking\n\t     the predicates of this operands.  */\n\n\t  tree opnd = gimple_phi_arg_def (phi, i);\n\t  gimple *opnd_def = SSA_NAME_DEF_STMT (opnd);\n\t  if (gphi *opnd_def_phi = dyn_cast \u003cgphi *\u003e (opnd_def))\n\t    {\n\t      unsigned opnds2 = eval.phi_arg_set (opnd_def_phi);\n\t      if (!MASK_EMPTY (opnds2))\n\t\t{\n\t\t  edge opnd_edge = gimple_phi_arg_edge (phi, i);\n\t\t  if (def_preds.is_use_guarded (phi, opnd_edge-\u003esrc,\n\t\t\t\t\t\topnd_def_phi, opnds2,\n\t\t\t\t\t\tvisited_phis))\n\t\t    return false;\n\t\t}\n\t    }\n\t  else\n\t    return false;\n\t}\n    }\n\n  return true;\n}","filepath":"gcc/gimple-predicate-analysis.cc","line_number":479,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5579216":{"score":0.76067984,"function_name":"ctype\u003cchar\u003e::ctype","code":"ctype\u003cchar\u003e::ctype(__c_locale, const mask* __table, bool __del, \n\t\t     size_t __refs) \n  : facet(__refs), _M_del(__table != 0 \u0026\u0026 __del), \n  _M_toupper(__trans_upper), _M_tolower(__trans_lower), \n  _M_table(__table ? __table : classic_table()) \n  { \n    memset(_M_widen, 0, sizeof(_M_widen));\n    _M_widen_ok = 0;\n    memset(_M_narrow, 0, sizeof(_M_narrow));\n    _M_narrow_ok = 0;\n  }","filepath":"libstdc++-v3/config/os/solaris/solaris2.6/ctype_noninline.h","line_number":40,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5579456":{"score":0.77195233,"function_name":"ctype\u003cchar\u003e::ctype","code":"ctype\u003cchar\u003e::ctype(const mask* __table, bool __del, size_t __refs) \n  : facet(__refs), _M_del(__table != 0 \u0026\u0026 __del), \n  _M_toupper(__trans_upper), _M_tolower(__trans_lower), \n  _M_table(__table ? __table : classic_table()) \n  { \n    memset(_M_widen, 0, sizeof(_M_widen));\n    _M_widen_ok = 0;\n    memset(_M_narrow, 0, sizeof(_M_narrow));\n    _M_narrow_ok = 0;\n  }","filepath":"libstdc++-v3/config/os/solaris/solaris2.6/ctype_noninline.h","line_number":52,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5579712":{"score":0.8874679,"function_name":"ctype\u003cchar\u003e::do_tolower","code":"const char* \n  ctype\u003cchar\u003e::do_tolower(char* __low, const char* __high) const\n  {\n    while (__low \u003c __high)\n      {\n\t*__low = _M_tolower[static_cast\u003cunsigned char\u003e(*__low)];\n\t++__low;\n      }\n    return __high;\n  }","filepath":"libstdc++-v3/config/os/solaris/solaris2.6/ctype_noninline.h","line_number":82,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5586768":{"score":0.6618202,"function_name":"messages_byname\u003c_CharT\u003e::messages_byname","code":"messages_byname\u003c_CharT\u003e::messages_byname(const char* __s, size_t __refs)\n     : messages\u003c_CharT\u003e(__refs) \n     { \n\tif (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_messages);\n\t    this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_messages, __s); \n\t  }\n     }","filepath":"libstdc++-v3/config/locale/generic/messages_members.h","line_number":76,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5588464":{"score":0.619658,"function_name":"ctype_byname\u003cchar\u003e::ctype_byname","code":"ctype_byname\u003cchar\u003e::ctype_byname(const char* __s, size_t __refs)\n    : ctype\u003cchar\u003e(0, false, __refs) \n    { \t\n      if (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n\t{\n\t  _S_destroy_c_locale(_M_c_locale_ctype);\n\t  _S_create_c_locale(_M_c_locale_ctype, __s); \n\t}\n    }","filepath":"libstdc++-v3/config/locale/generic/ctype_members.cc","line_number":43,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.0"},"5591552":{"score":0.75420356,"function_name":"messages_byname\u003c_CharT\u003e::messages_byname","code":"messages_byname\u003c_CharT\u003e::messages_byname(const char* __s, size_t __refs)\n     : messages\u003c_CharT\u003e(__refs) \n     { \n       if (this-\u003e_M_name_messages != locale::facet::_S_get_c_name())\n\t {\n\t   delete [] this-\u003e_M_name_messages;\n\t   if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)\n\t     {\n\t       const size_t __len = __builtin_strlen(__s) + 1;\n\t       char* __tmp = new char[__len];\n\t       __builtin_memcpy(__tmp, __s, __len);\n\t       this-\u003e_M_name_messages = __tmp;\n\t     }\n\t   else\n\t     this-\u003e_M_name_messages = locale::facet::_S_get_c_name();\n\t }\n\n       if (__builtin_strcmp(__s, \"C\") != 0\n\t   \u0026\u0026 __builtin_strcmp(__s, \"POSIX\") != 0)\n\t {\n\t   this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_messages);\n\t   this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_messages, __s); \n\t }\n     }","filepath":"libstdc++-v3/config/locale/gnu/messages_members.h","line_number":108,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5591840":{"score":0.7721354,"function_name":"messages_byname\u003c_CharT\u003e::messages_byname","code":"messages_byname\u003c_CharT\u003e::messages_byname(const char* __s, size_t __refs)\n     : messages\u003c_CharT\u003e(__refs) \n     { \n\tif (__builtin_strcmp(__s, \"C\") != 0\n\t    \u0026\u0026 __builtin_strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_messages);\n\t    this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_messages, __s); \n\t  }\n     }","filepath":"libstdc++-v3/config/locale/generic/messages_members.h","line_number":81,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5639600":{"score":0.48210305,"function_name":"wide_int_range_div","code":"bool\nwide_int_range_div (wide_int \u0026wmin, wide_int \u0026wmax,\n\t\t    tree_code code, signop sign, unsigned prec,\n\t\t    const wide_int \u0026dividend_min, const wide_int \u0026dividend_max,\n\t\t    const wide_int \u0026divisor_min, const wide_int \u0026divisor_max,\n\t\t    bool overflow_undefined,\n\t\t    bool \u0026extra_range_p,\n\t\t    wide_int \u0026extra_min, wide_int \u0026extra_max)\n{\n  extra_range_p = false;\n\n  /* If we know we won't divide by zero, just do the division.  */\n  if (!wide_int_range_includes_zero_p (divisor_min, divisor_max, sign))\n    return wide_int_range_multiplicative_op (wmin, wmax, code, sign, prec,\n\t\t\t\t\t     dividend_min, dividend_max,\n\t\t\t\t\t     divisor_min, divisor_max,\n\t\t\t\t\t     overflow_undefined);\n\n  /* If flag_non_call_exceptions, we must not eliminate a division\n     by zero.  */\n  if (cfun-\u003ecan_throw_non_call_exceptions)\n    return false;\n\n  /* If we're definitely dividing by zero, there's nothing to do.  */\n  if (wide_int_range_zero_p (divisor_min, divisor_max, prec))\n    return false;\n\n  /* Perform the division in 2 parts, [LB, -1] and [1, UB],\n     which will skip any division by zero.\n\n     First divide by the negative numbers, if any.  */\n  if (wi::neg_p (divisor_min, sign))\n    {\n      if (!wide_int_range_multiplicative_op (wmin, wmax,\n\t\t\t\t\t     code, sign, prec,\n\t\t\t\t\t     dividend_min, dividend_max,\n\t\t\t\t\t     divisor_min, wi::minus_one (prec),\n\t\t\t\t\t     overflow_undefined))\n\treturn false;\n      extra_range_p = true;\n    }\n  /* Then divide by the non-zero positive numbers, if any.  */\n  if (wi::gt_p (divisor_max, wi::zero (prec), sign))\n    {\n      if (!wide_int_range_multiplicative_op (extra_range_p ? extra_min : wmin,\n\t\t\t\t\t     extra_range_p ? extra_max : wmax,\n\t\t\t\t\t     code, sign, prec,\n\t\t\t\t\t     dividend_min, dividend_max,\n\t\t\t\t\t     wi::one (prec), divisor_max,\n\t\t\t\t\t     overflow_undefined))\n\treturn false;\n    }\n  else\n    extra_range_p = false;\n  return true;\n}","filepath":"gcc/wide-int-range.cc","line_number":810,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5648240":{"score":0.5314261,"function_name":"wide_int_range_multiplicative_op","code":"bool\nwide_int_range_multiplicative_op (wide_int \u0026res_lb, wide_int \u0026res_ub,\n\t\t\t\t  enum tree_code code,\n\t\t\t\t  signop sign,\n\t\t\t\t  unsigned prec,\n\t\t\t\t  const wide_int \u0026vr0_lb,\n\t\t\t\t  const wide_int \u0026vr0_ub,\n\t\t\t\t  const wide_int \u0026vr1_lb,\n\t\t\t\t  const wide_int \u0026vr1_ub,\n\t\t\t\t  bool overflow_undefined)\n{\n  /* Multiplications, divisions and shifts are a bit tricky to handle,\n     depending on the mix of signs we have in the two ranges, we\n     need to operate on different values to get the minimum and\n     maximum values for the new range.  One approach is to figure\n     out all the variations of range combinations and do the\n     operations.\n\n     However, this involves several calls to compare_values and it\n     is pretty convoluted.  It's simpler to do the 4 operations\n     (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n     MAX1) and then figure the smallest and largest values to form\n     the new range.  */\n  if (code == MULT_EXPR \u0026\u0026 !overflow_undefined)\n    return wide_int_range_mult_wrapping (res_lb, res_ub,\n\t\t\t\t\t sign, prec,\n\t\t\t\t\t vr0_lb, vr0_ub, vr1_lb, vr1_ub);\n  return wide_int_range_cross_product (res_lb, res_ub,\n\t\t\t\t       code, sign,\n\t\t\t\t       vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n\t\t\t\t       overflow_undefined);\n}","filepath":"gcc/wide-int-range.cc","line_number":275,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5649248":{"score":0.48783612,"function_name":"wide_int_range_lshift","code":"bool\nwide_int_range_lshift (wide_int \u0026res_lb, wide_int \u0026res_ub,\n\t\t       signop sign, unsigned prec,\n\t\t       const wide_int \u0026vr0_lb, const wide_int \u0026vr0_ub,\n\t\t       const wide_int \u0026vr1_lb, const wide_int \u0026vr1_ub,\n\t\t       bool overflow_undefined)\n{\n  /* Transform left shifts by constants into multiplies.  */\n  if (wi::eq_p (vr1_lb, vr1_ub))\n    {\n      unsigned shift = vr1_ub.to_uhwi ();\n      wide_int tmp = wi::set_bit_in_zero (shift, prec);\n      return wide_int_range_multiplicative_op (res_lb, res_ub,\n\t\t\t\t\t       MULT_EXPR, sign, prec,\n\t\t\t\t\t       vr0_lb, vr0_ub, tmp, tmp,\n\t\t\t\t\t       /*overflow_undefined=*/false);\n    }\n\n  int overflow_pos = prec;\n  if (sign == SIGNED)\n    overflow_pos -= 1;\n  int bound_shift = overflow_pos - vr1_ub.to_shwi ();\n  /* If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can\n     overflow.  However, for that to happen, vr1.max needs to be\n     zero, which means vr1 is a singleton range of zero, which\n     means it should be handled by the previous LSHIFT_EXPR\n     if-clause.  */\n  wide_int bound = wi::set_bit_in_zero (bound_shift, prec);\n  wide_int complement = ~(bound - 1);\n  wide_int low_bound, high_bound;\n  bool in_bounds = false;\n  if (sign == UNSIGNED)\n    {\n      low_bound = bound;\n      high_bound = complement;\n      if (wi::ltu_p (vr0_ub, low_bound))\n\t{\n\t  /* [5, 6] \u003c\u003c [1, 2] == [10, 24].  */\n\t  /* We're shifting out only zeroes, the value increases\n\t     monotonically.  */\n\t  in_bounds = true;\n\t}\n      else if (wi::ltu_p (high_bound, vr0_lb))\n\t{\n\t  /* [0xffffff00, 0xffffffff] \u003c\u003c [1, 2]\n\t     == [0xfffffc00, 0xfffffffe].  */\n\t  /* We're shifting out only ones, the value decreases\n\t     monotonically.  */\n\t  in_bounds = true;\n\t}\n    }\n  else\n    {\n      /* [-1, 1] \u003c\u003c [1, 2] == [-4, 4].  */\n      low_bound = complement;\n      high_bound = bound;\n      if (wi::lts_p (vr0_ub, high_bound)\n\t  \u0026\u0026 wi::lts_p (low_bound, vr0_lb))\n\t{\n\t  /* For non-negative numbers, we're shifting out only\n\t     zeroes, the value increases monotonically.\n\t     For negative numbers, we're shifting out only ones, the\n\t     value decreases monotomically.  */\n\t  in_bounds = true;\n\t}\n    }\n  if (in_bounds)\n    return wide_int_range_multiplicative_op (res_lb, res_ub,\n\t\t\t\t\t     LSHIFT_EXPR, sign, prec,\n\t\t\t\t\t     vr0_lb, vr0_ub,\n\t\t\t\t\t     vr1_lb, vr1_ub,\n\t\t\t\t\t     overflow_undefined);\n  return false;\n}","filepath":"gcc/wide-int-range.cc","line_number":317,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5664496":{"score":0.63360244,"function_name":"numpunct_byname","code":"explicit\n      numpunct_byname(const char* __s, size_t __refs = 0)\n      : numpunct\u003c_CharT\u003e(__refs)\n      {\n\tif (__builtin_strcmp(__s, \"C\") != 0\n\t    \u0026\u0026 __builtin_strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    __c_locale __tmp;\n\t    this-\u003e_S_create_c_locale(__tmp, __s);\n\t    this-\u003e_M_initialize_numpunct(__tmp);\n\t    this-\u003e_S_destroy_c_locale(__tmp);\n\t  }\n      }","filepath":"libstdc++-v3/include/bits/locale_facets.h","line_number":1909,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.4.0"},"5733856":{"score":0.74455744,"function_name":"money_base::_S_construct_pattern","code":"money_base::pattern\n  money_base::_S_construct_pattern(char __precedes, char __space, \n\t\t\t\t   char __posn) throw()\n  { \n    pattern __ret;\n\n    // This insanely complicated routine attempts to construct a valid\n    // pattern for use with moneypunct. A couple of invariants:\n\n    // if (__precedes) symbol -\u003e value\n    // else value -\u003e symbol\n    \n    // if (__space) space\n    // else none\n\n    // none == never first\n    // space never first or last\n\n    // Any elegant implementations of this are welcome.\n    switch (__posn)\n      {\n      case 0:\n      case 1:\n\t// 1 The sign precedes the value and symbol.\n\t__ret.field[0] = sign;\n\tif (__space)\n\t  {\n\t    // Pattern starts with sign.\n\t    if (__precedes)\n\t      {\n\t\t__ret.field[1] = symbol;\n\t\t__ret.field[3] = value;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[1] = value;\n\t\t__ret.field[3] = symbol;\n\t      }\n\t    __ret.field[2] = space;\n\t  }\n\telse\n\t  {\n\t    // Pattern starts with sign and ends with none.\n\t    if (__precedes)\n\t      {\n\t\t__ret.field[1] = symbol;\n\t\t__ret.field[2] = value;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[1] = value;\n\t\t__ret.field[2] = symbol;\n\t      }\n\t    __ret.field[3] = none;\n\t  }\n\tbreak;\n      case 2:\n\t// 2 The sign follows the value and symbol.\n\tif (__space)\n\t  {\n\t    // Pattern either ends with sign.\n\t    if (__precedes)\n\t      {\n\t\t__ret.field[0] = symbol;\n\t\t__ret.field[2] = value;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[0] = value;\n\t\t__ret.field[2] = symbol;\n\t      }\n\t    __ret.field[1] = space;\n\t    __ret.field[3] = sign;\n\t  }\n\telse\n\t  {\n\t    // Pattern ends with sign then none.\n\t    if (__precedes)\n\t      {\n\t\t__ret.field[0] = symbol;\n\t\t__ret.field[1] = value;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[0] = value;\n\t\t__ret.field[1] = symbol;\n\t      }\n\t    __ret.field[2] = sign;\n\t    __ret.field[3] = none;\n\t  }\n\tbreak;\n      case 3:\n\t// 3 The sign immediately precedes the symbol.\n\tif (__precedes)\n\t  {\n\t    __ret.field[0] = sign;\n\t    __ret.field[1] = symbol;\t    \n\t    if (__space)\n\t      {\n\t\t__ret.field[2] = space;\n\t\t__ret.field[3] = value;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[2] = value;\t\t\n\t\t__ret.field[3] = none;\n\t      }\n\t  }\n\telse\n\t  {\n\t    __ret.field[0] = value;\n\t    if (__space)\n\t      {\n\t\t__ret.field[1] = space;\n\t\t__ret.field[2] = sign;\n\t\t__ret.field[3] = symbol;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[1] = sign;\n\t\t__ret.field[2] = symbol;\n\t\t__ret.field[3] = none;\n\t      }\n\t  }\n\tbreak;\n      case 4:\n\t// 4 The sign immediately follows the symbol.\n\tif (__precedes)\n\t  {\n\t    __ret.field[0] = symbol;\n\t    __ret.field[1] = sign;\n\t    if (__space)\n\t      {\n\t\t__ret.field[2] = space;\n\t\t__ret.field[3] = value;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[2] = value;\n\t\t__ret.field[3] = none;\n\t      }\n\t  }\n\telse\n\t  {\n\t    __ret.field[0] = value;\n\t    if (__space)\n\t      {\n\t\t__ret.field[1] = space;\n\t\t__ret.field[2] = symbol;\n\t\t__ret.field[3] = sign;\n\t      }\n\t    else\n\t      {\n\t\t__ret.field[1] = symbol;\n\t\t__ret.field[2] = sign;\n\t\t__ret.field[3] = none;\n\t      }\n\t  }\n\tbreak;\n      default:\n\t__ret = pattern();\n      }\n    return __ret;\n  }","filepath":"contrib/gcc-5.0/libstdc++-v3/config/locale/dragonfly/monetary_members.cc","line_number":46,"entry_url":"https://github.com/DragonFlyBSD/DragonFlyBSD.git","slot_name":"v4.3.1"},"5737584":{"score":0.6850667,"function_name":"moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct","code":"void\n    moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct(__c_locale __cloc, \n\t\t\t\t\t\t      const char*)\n    {\n      if (!_M_data)\n\t_M_data = new __moneypunct_cache\u003cchar, false\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_data-\u003e_M_decimal_point = '.';\n\t  _M_data-\u003e_M_thousands_sep = ',';\n\t  _M_data-\u003e_M_grouping = \"\";\n\t  _M_data-\u003e_M_grouping_size = 0;\n\t  _M_data-\u003e_M_use_grouping = false;\n\t  _M_data-\u003e_M_curr_symbol = \"\";\n\t  _M_data-\u003e_M_curr_symbol_size = 0;\n\t  _M_data-\u003e_M_positive_sign = \"\";\n\t  _M_data-\u003e_M_positive_sign_size = 0;\n\t  _M_data-\u003e_M_negative_sign = \"\";\n\t  _M_data-\u003e_M_negative_sign_size = 0;\n\t  _M_data-\u003e_M_frac_digits = 0;\n\t  _M_data-\u003e_M_pos_format = money_base::_S_default_pattern;\n\t  _M_data-\u003e_M_neg_format = money_base::_S_default_pattern;\n\n\t  for (size_t __i = 0; __i \u003c money_base::_S_end; ++__i)\n\t    _M_data-\u003e_M_atoms[__i] = money_base::_S_atoms[__i];\n\t}\n      else\n\t{\n\t  // Named locale.\n\t  lconv* lc = localeconv_l((locale_t) __cloc);\n\n\t  // Check for NULL, which implies no fractional digits.\n\t  if (lc-\u003emon_decimal_point == NULL ||\n\t      lc-\u003emon_decimal_point[0] == '\\0')\n\t    {\n\t      // Like in \"C\" locale.\n\t      _M_data-\u003e_M_frac_digits = 0;\n\t      _M_data-\u003e_M_decimal_point = '.';\n\t    }\n\t  else\n\t    {\n\t      _M_data-\u003e_M_decimal_point = lc-\u003emon_decimal_point[0];\n\t      _M_data-\u003e_M_frac_digits = lc-\u003efrac_digits;\n            }\n\n\t  const char* __cgroup = lc-\u003emon_grouping;\n\t  const char* __cpossign = lc-\u003epositive_sign;\n\t  const char* __cnegsign = lc-\u003enegative_sign;\n\t  // _Intl == false\n\t  const char* __ccurr = lc-\u003ecurrency_symbol;\n\n\t  char* __group = 0;\n\t  char* __ps = 0;\n\t  char* __ns = 0;\n\t  const char __nposn = lc-\u003en_sign_posn;\n\t  __try\n\t    {\n\t      size_t __len;\n\n\t      // Check for NULL, which implies no grouping.\n\t      if (lc-\u003emon_thousands_sep == NULL ||\n\t          lc-\u003emon_thousands_sep[0] == '\\0')\n\t\t{\n\t\t  // Like in \"C\" locale.\n\t\t  _M_data-\u003e_M_grouping = \"\";\n\t\t  _M_data-\u003e_M_grouping_size = 0;\n\t\t  _M_data-\u003e_M_use_grouping = false;\n\t\t  _M_data-\u003e_M_thousands_sep = ',';\n\t\t}\n\t      else\n\t\t{\n\t          _M_data-\u003e_M_thousands_sep = lc-\u003emon_thousands_sep[0];\n\n\t\t  __len = strlen(__cgroup);\n\t\t  if (__len)\n\t\t    {\n\t\t      __group = new char[__len + 1];\n\t\t      memcpy(__group, __cgroup, __len + 1);\n\t\t      _M_data-\u003e_M_grouping = __group;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      _M_data-\u003e_M_grouping = \"\";\n\t\t      _M_data-\u003e_M_use_grouping = false;\n\t\t    }\n\t\t  _M_data-\u003e_M_grouping_size = __len;\n\t\t}\n\n\t      __len = strlen(__cpossign);\n\t      if (__len)\n\t\t{\n\t\t  __ps = new char[__len + 1];\n\t\t  memcpy(__ps, __cpossign, __len + 1);\n\t\t  _M_data-\u003e_M_positive_sign = __ps;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_positive_sign = \"\";\n\t      _M_data-\u003e_M_positive_sign_size = __len;\n\n\t      if (!__nposn)\n\t\t{\n\t\t  _M_data-\u003e_M_negative_sign = \"()\";\n\t\t  _M_data-\u003e_M_negative_sign_size = 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  __len = strlen(__cnegsign);\n\t\t  if (__len)\n\t\t    {\n\t\t      __ns = new char[__len + 1];\n\t\t      memcpy(__ns, __cnegsign, __len + 1);\n\t\t      _M_data-\u003e_M_negative_sign = __ns;\n\t\t    }\n\t\t  else\n\t\t    _M_data-\u003e_M_negative_sign = \"\";\n\t\t  _M_data-\u003e_M_negative_sign_size = __len;\n\t\t}\n\n\t      __len = strlen(__ccurr);\n\t      if (__len)\n\t\t{\n\t\t  char* __curr = new char[__len + 1];\n\t\t  memcpy(__curr, __ccurr, __len + 1);\n\t\t  _M_data-\u003e_M_curr_symbol = __curr;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_curr_symbol = \"\";\n\t      _M_data-\u003e_M_curr_symbol_size = __len;\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete _M_data;\n\t      _M_data = 0;\n\t      delete [] __group;\n\t      delete [] __ps;\n\t      delete [] __ns;\n\t      __throw_exception_again;\n\t    }\n\n\t  char __pprecedes = lc-\u003ep_cs_precedes;\n\t  char __pspace = lc-\u003ep_sep_by_space;\n\t  char __pposn = lc-\u003ep_sign_posn;\n\t  _M_data-\u003e_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n\t\t\t\t\t\t\t__pposn);\n\t  char __nprecedes = lc-\u003en_cs_precedes;\n\t  char __nspace = lc-\u003en_sep_by_space;\n\t  _M_data-\u003e_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n\t\t\t\t\t\t\t__nposn);\n\t}","filepath":"contrib/gcc-5.0/libstdc++-v3/config/locale/dragonfly/monetary_members.cc","line_number":367,"entry_url":"https://github.com/DragonFlyBSD/DragonFlyBSD.git","slot_name":"v4.3.1"},"5745808":{"score":0.6888586,"function_name":"moneypunct\u003cchar, true\u003e::_M_initialize_moneypunct","code":"void\n    moneypunct\u003cchar, true\u003e::_M_initialize_moneypunct(__c_locale __cloc, \n\t\t\t\t\t\t     const char*)\n    {\n      if (!_M_data)\n\t_M_data = new __moneypunct_cache\u003cchar, true\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_data-\u003e_M_decimal_point = '.';\n\t  _M_data-\u003e_M_thousands_sep = ',';\n\t  _M_data-\u003e_M_grouping = \"\";\n\t  _M_data-\u003e_M_grouping_size = 0;\n\t  _M_data-\u003e_M_use_grouping = false;\n\t  _M_data-\u003e_M_curr_symbol = \"\";\n\t  _M_data-\u003e_M_curr_symbol_size = 0;\n\t  _M_data-\u003e_M_positive_sign = \"\";\n\t  _M_data-\u003e_M_positive_sign_size = 0;\n\t  _M_data-\u003e_M_negative_sign = \"\";\n\t  _M_data-\u003e_M_negative_sign_size = 0;\n\t  _M_data-\u003e_M_frac_digits = 0;\n\t  _M_data-\u003e_M_pos_format = money_base::_S_default_pattern;\n\t  _M_data-\u003e_M_neg_format = money_base::_S_default_pattern;\n\n\t  for (size_t __i = 0; __i \u003c money_base::_S_end; ++__i)\n\t    _M_data-\u003e_M_atoms[__i] = money_base::_S_atoms[__i];\n\t}\n      else\n\t{\n\t  // Named locale.\n\t  _M_data-\u003e_M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT, \n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP, \n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_positive_sign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n\t  _M_data-\u003e_M_positive_sign_size = strlen(_M_data-\u003e_M_positive_sign);\n\n\t  // Check for NULL, which implies no grouping.\n\t  if (_M_data-\u003e_M_thousands_sep == '\\0')\n\t    {\n\t      // Like in \"C\" locale.\n\t      _M_data-\u003e_M_grouping = \"\";\n\t      _M_data-\u003e_M_grouping_size = 0;\n\t      _M_data-\u003e_M_use_grouping = false;\n\t      _M_data-\u003e_M_thousands_sep = ',';\n\t    }\n\t  else\n\t    {\n\t      _M_data-\u003e_M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);\n\t      _M_data-\u003e_M_grouping_size = strlen(_M_data-\u003e_M_grouping);\n\t    }\n\n\t  // Check for NULL, which implies no fractional digits.\n\t  if (_M_data-\u003e_M_decimal_point == '\\0')\n\t    {\n\t      // Like in \"C\" locale.\n\t      _M_data-\u003e_M_frac_digits = 0;\n\t      _M_data-\u003e_M_decimal_point = '.';\n\t    }\n\t  else\n\t    _M_data-\u003e_M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS, \n\t\t\t\t\t\t\t__cloc));\n\n\t  char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));\n\t  if (!__nposn)\n\t    _M_data-\u003e_M_negative_sign = \"()\";\n\t  else\n\t    _M_data-\u003e_M_negative_sign = __nl_langinfo_l(__NEGATIVE_SIGN, \n\t\t\t\t\t\t\t__cloc);\n\t  _M_data-\u003e_M_negative_sign_size = strlen(_M_data-\u003e_M_negative_sign);\n\n\t  // _Intl == true\n\t  _M_data-\u003e_M_curr_symbol = __nl_langinfo_l(__INT_CURR_SYMBOL, __cloc);\n\t  _M_data-\u003e_M_curr_symbol_size = strlen(_M_data-\u003e_M_curr_symbol);\n\t  char __pprecedes = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, __cloc));\n\t  char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));\n\t  char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));\n\t  _M_data-\u003e_M_pos_format = _S_construct_pattern(__pprecedes, __pspace, \n\t\t\t\t\t\t\t__pposn);\n\t  char __nprecedes = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, __cloc));\n\t  char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));\n\t  _M_data-\u003e_M_neg_format = _S_construct_pattern(__nprecedes, __nspace, \n\t\t\t\t\t\t\t__nposn);\n\t}\n    }","filepath":"libstdc++-v3/config/locale/gnu/monetary_members.cc","line_number":204,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5747360":{"score":0.6825485,"function_name":"moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct","code":"void\n    moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct(__c_locale __cloc, \n\t\t\t\t\t\t      const char*)\n    {\n      if (!_M_data)\n\t_M_data = new __moneypunct_cache\u003cchar, false\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_data-\u003e_M_decimal_point = '.';\n\t  _M_data-\u003e_M_thousands_sep = ',';\n\t  _M_data-\u003e_M_grouping = \"\";\n\t  _M_data-\u003e_M_grouping_size = 0;\n\t  _M_data-\u003e_M_curr_symbol = \"\";\n\t  _M_data-\u003e_M_curr_symbol_size = 0;\n\t  _M_data-\u003e_M_positive_sign = \"\";\n\t  _M_data-\u003e_M_positive_sign_size = 0;\n\t  _M_data-\u003e_M_negative_sign = \"\";\n\t  _M_data-\u003e_M_negative_sign_size = 0;\n\t  _M_data-\u003e_M_frac_digits = 0;\n\t  _M_data-\u003e_M_pos_format = money_base::_S_default_pattern;\n\t  _M_data-\u003e_M_neg_format = money_base::_S_default_pattern;\n\n\t  for (size_t __i = 0; __i \u003c money_base::_S_end; ++__i)\n\t    _M_data-\u003e_M_atoms[__i] = money_base::_S_atoms[__i];\n\t}\n      else\n\t{\n\t  // Named locale.\n\t  _M_data-\u003e_M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT, \n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP, \n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);\n\t  _M_data-\u003e_M_grouping_size = strlen(_M_data-\u003e_M_grouping);\n\t  _M_data-\u003e_M_positive_sign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n\t  _M_data-\u003e_M_positive_sign_size = strlen(_M_data-\u003e_M_positive_sign);\n\n\t  char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n\t  if (!__nposn)\n\t    _M_data-\u003e_M_negative_sign = \"()\";\n\t  else\n\t    _M_data-\u003e_M_negative_sign = __nl_langinfo_l(__NEGATIVE_SIGN,\n\t\t\t\t\t\t\t__cloc);\n\t  _M_data-\u003e_M_negative_sign_size = strlen(_M_data-\u003e_M_negative_sign);\n\n\t  // _Intl == false\n\t  _M_data-\u003e_M_curr_symbol = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);\n\t  _M_data-\u003e_M_curr_symbol_size = strlen(_M_data-\u003e_M_curr_symbol);\n\t  _M_data-\u003e_M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));\n\t  char __pprecedes = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n\t  char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n\t  char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n\t  _M_data-\u003e_M_pos_format = _S_construct_pattern(__pprecedes, __pspace, \n\t\t\t\t\t\t\t__pposn);\n\t  char __nprecedes = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n\t  char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n\t  _M_data-\u003e_M_neg_format = _S_construct_pattern(__nprecedes, __nspace, \n\t\t\t\t\t\t\t__nposn);\n\t}\n    }","filepath":"libstdc++-v3/config/locale/gnu/monetary_members.cc","line_number":273,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5753312":{"score":0.58099663,"function_name":"moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct","code":"void\n    moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct(__c_locale __cloc, \n\t\t\t\t\t\t      const char*)\n    {\n      if (!_M_data)\n\t_M_data = new __moneypunct_cache\u003cchar, false\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_data-\u003e_M_decimal_point = '.';\n\t  _M_data-\u003e_M_thousands_sep = ',';\n\t  _M_data-\u003e_M_grouping = \"\";\n\t  _M_data-\u003e_M_grouping_size = 0;\n\t  _M_data-\u003e_M_use_grouping = false;\n\t  _M_data-\u003e_M_curr_symbol = \"\";\n\t  _M_data-\u003e_M_curr_symbol_size = 0;\n\t  _M_data-\u003e_M_positive_sign = \"\";\n\t  _M_data-\u003e_M_positive_sign_size = 0;\n\t  _M_data-\u003e_M_negative_sign = \"\";\n\t  _M_data-\u003e_M_negative_sign_size = 0;\n\t  _M_data-\u003e_M_frac_digits = 0;\n\t  _M_data-\u003e_M_pos_format = money_base::_S_default_pattern;\n\t  _M_data-\u003e_M_neg_format = money_base::_S_default_pattern;\n\n\t  for (size_t __i = 0; __i \u003c money_base::_S_end; ++__i)\n\t    _M_data-\u003e_M_atoms[__i] = money_base::_S_atoms[__i];\n\t}\n      else\n\t{\n\t  // Named locale.\n\t  _M_data-\u003e_M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT, \n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP, \n\t\t\t\t\t\t\t__cloc));\n\n\t  // Check for NULL, which implies no fractional digits.\n\t  if (_M_data-\u003e_M_decimal_point == '\\0')\n\t    {\n\t      // Like in \"C\" locale.\n\t      _M_data-\u003e_M_frac_digits = 0;\n\t      _M_data-\u003e_M_decimal_point = '.';\n\t    }\n\t  else\n\t    _M_data-\u003e_M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS,\n\t\t\t\t\t\t\t__cloc));\n\n\t  const char* __cgroup = __nl_langinfo_l(__MON_GROUPING, __cloc);\n\t  const char* __cpossign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n\t  const char* __cnegsign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);\n\t  // _Intl == false\n\t  const char* __ccurr = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);\n\n\t  char* __group = 0;\n\t  char* __ps = 0;\n\t  char* __ns = 0;\n\t  const char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n\t  __try\n\t    {\n\t      size_t __len;\n\n\t      // Check for NULL, which implies no grouping.\n\t      if (_M_data-\u003e_M_thousands_sep == '\\0')\n\t\t{\n\t\t  // Like in \"C\" locale.\n\t\t  _M_data-\u003e_M_grouping = \"\";\n\t\t  _M_data-\u003e_M_grouping_size = 0;\n\t\t  _M_data-\u003e_M_use_grouping = false;\n\t\t  _M_data-\u003e_M_thousands_sep = ',';\n\t\t}\n\t      else\n\t\t{\n\t\t  __len = strlen(__cgroup);\n\t\t  if (__len)\n\t\t    {\n\t\t      __group = new char[__len + 1];\n\t\t      memcpy(__group, __cgroup, __len + 1);\n\t\t      _M_data-\u003e_M_grouping = __group;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      _M_data-\u003e_M_grouping = \"\";\n\t\t      _M_data-\u003e_M_use_grouping = false;\n\t\t    }\n\t\t  _M_data-\u003e_M_grouping_size = __len;\n\t\t}\n\n\t      __len = strlen(__cpossign);\n\t      if (__len)\n\t\t{\n\t\t  __ps = new char[__len + 1];\n\t\t  memcpy(__ps, __cpossign, __len + 1);\n\t\t  _M_data-\u003e_M_positive_sign = __ps;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_positive_sign = \"\";\n\t      _M_data-\u003e_M_positive_sign_size = __len;\n\n\t      if (!__nposn)\n\t\t{\n\t\t  _M_data-\u003e_M_negative_sign = \"()\";\n\t\t  _M_data-\u003e_M_negative_sign_size = 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  __len = strlen(__cnegsign);\n\t\t  if (__len)\n\t\t    {\n\t\t      __ns = new char[__len + 1];\n\t\t      memcpy(__ns, __cnegsign, __len + 1);\n\t\t      _M_data-\u003e_M_negative_sign = __ns;\n\t\t    }\n\t\t  else\n\t\t    _M_data-\u003e_M_negative_sign = \"\";\n\t\t  _M_data-\u003e_M_negative_sign_size = __len;\n\t\t}\n\n\t      __len = strlen(__ccurr);\n\t      if (__len)\n\t\t{\n\t\t  char* __curr = new char[__len + 1];\n\t\t  memcpy(__curr, __ccurr, __len + 1);\n\t\t  _M_data-\u003e_M_curr_symbol = __curr;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_curr_symbol = \"\";\n\t      _M_data-\u003e_M_curr_symbol_size = __len;\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete _M_data;\n\t      _M_data = 0;\n\t      delete [] __group;\n\t      delete [] __ps;\n\t      delete [] __ns;\n\t      __throw_exception_again;\n\t    }\n\n\t  char __pprecedes = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n\t  char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n\t  char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n\t  _M_data-\u003e_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n\t\t\t\t\t\t\t__pposn);\n\t  char __nprecedes = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n\t  char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n\t  _M_data-\u003e_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n\t\t\t\t\t\t\t__nposn);\n\t}","filepath":"libstdc++-v3/config/locale/gnu/monetary_members.cc","line_number":358,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5758352":{"score":0.5947872,"function_name":"__sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_construct","code":"void\n      __sso_string_base\u003c_CharT, _Traits, _Alloc\u003e::\n      _M_construct(_InIterator __beg, _InIterator __end,\n\t\t   std::forward_iterator_tag)\n      {\n\t// NB: Not required, but considered best practice.\n\tif (__builtin_expect(_S_is_null_pointer(__beg) \u0026\u0026 __beg != __end, 0))\n\t  std::__throw_logic_error(__N(\"__sso_string_base::\"\n\t\t\t\t       \"_M_construct NULL not valid\"));\n\n\tsize_type __dnew = static_cast\u003csize_type\u003e(std::distance(__beg, __end));\n\n\tif (__dnew \u003e size_type(_S_local_capacity))\n\t  {\n\t    _M_data(_M_create(__dnew, size_type(0)));\n\t    _M_capacity(__dnew);\n\t  }\n\n\t// Check for out_of_range and length_error exceptions.\n\ttry\n\t  { _S_copy_chars(_M_data(), __beg, __end); }\n\tcatch(...)\n\t  {\n\t    _M_dispose();\n\t    __throw_exception_again;\n\t  }\n\n\t_M_set_length(__dnew);\n      }","filepath":"libstdc++-v3/include/ext/sso_string_base.h","line_number":418,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.1.2"},"5759520":{"score":0.643729,"function_name":"messages\u003cchar\u003e::do_get","code":"string\n    messages\u003cchar\u003e::do_get(catalog __c, int, int,\n\t\t\t   const string\u0026 __dfault) const\n    {\n      if (__c \u003c 0 || __dfault.empty())\n\treturn __dfault;\n\n      const Catalog_info* __cat_info = get_catalogs()._M_get(__c);\n\n      if (!__cat_info)\n\treturn __dfault;\n\n      return get_glibc_msg(_M_c_locale_messages, _M_name_messages,\n\t\t\t   __cat_info-\u003e_M_domain.c_str(),\n\t\t\t   __dfault.c_str());\n    }","filepath":"libstdc++-v3/config/locale/gnu/messages_members.cc","line_number":192,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5760896":{"score":0.5977814,"function_name":"_M_erase","code":"void\n    _M_erase(catalog __c)\n    {\n      __gnu_cxx::__scoped_lock lock(_M_mutex);\n\n      vector\u003cCatalog_info*\u003e::iterator __res =\n\tlower_bound(_M_infos.begin(), _M_infos.end(), __c, _Comp());\n      if (__res == _M_infos.end() || (*__res)-\u003e_M_id != __c)\n\treturn;\n\n      delete *__res;\n      _M_infos.erase(__res);\n\n      // Just in case closed catalog was the last open.\n      if (__c == _M_catalog_counter - 1)\n\t--_M_catalog_counter;\n    }","filepath":"libstdc++-v3/config/locale/gnu/messages_members.cc","line_number":89,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5766912":{"score":0.7836184,"function_name":"numpunct\u003cchar\u003e::_M_initialize_numpunct","code":"void\n    numpunct\u003cchar\u003e::_M_initialize_numpunct(__c_locale __cloc)\n    {\n      if (!_M_data)\n\t_M_data = new __numpunct_cache\u003cchar\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_data-\u003e_M_grouping = \"\";\n\t  _M_data-\u003e_M_grouping_size = 0;\n\t  _M_data-\u003e_M_use_grouping = false;\n\n\t  _M_data-\u003e_M_decimal_point = '.';\n\t  _M_data-\u003e_M_thousands_sep = ',';\n\n\t  for (size_t __i = 0; __i \u003c __num_base::_S_oend; ++__i)\n\t    _M_data-\u003e_M_atoms_out[__i] = __num_base::_S_atoms_out[__i];\n\n\t  for (size_t __j = 0; __j \u003c __num_base::_S_iend; ++__j)\n\t    _M_data-\u003e_M_atoms_in[__j] = __num_base::_S_atoms_in[__j];\n\t}\n      else\n\t{\n\t  // Named locale.\n\t  _M_data-\u003e_M_decimal_point = *(__nl_langinfo_l(DECIMAL_POINT, \n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_thousands_sep = *(__nl_langinfo_l(THOUSANDS_SEP, \n\t\t\t\t\t\t\t__cloc));\n\n\t  // Check for NULL, which implies no grouping.\n\t  if (_M_data-\u003e_M_thousands_sep == '\\0')\n\t    {\n\t      // Like in \"C\" locale.\n\t      _M_data-\u003e_M_grouping = \"\";\n\t      _M_data-\u003e_M_grouping_size = 0;\n\t      _M_data-\u003e_M_use_grouping = false;\n\t      _M_data-\u003e_M_thousands_sep = ',';\n\t    }\n\t  else\n\t    {\n\t      _M_data-\u003e_M_grouping = __nl_langinfo_l(GROUPING, __cloc);\n\t      _M_data-\u003e_M_grouping_size = strlen(_M_data-\u003e_M_grouping);\n\t    }\n\t}\n\n      // NB: There is no way to extact this info from posix locales.\n      // _M_truename = __nl_langinfo_l(YESSTR, __cloc);\n      _M_data-\u003e_M_truename = \"true\";\n      _M_data-\u003e_M_truename_size = 4;\n      // _M_falsename = __nl_langinfo_l(NOSTR, __cloc);\n      _M_data-\u003e_M_falsename = \"false\";\n      _M_data-\u003e_M_falsename_size = 5;\n    }","filepath":"libstdc++-v3/config/locale/gnu/numeric_members.cc","line_number":38,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5767616":{"score":0.6519966,"function_name":"basic_istream\u003cchar\u003e::\n    getline","code":"basic_istream\u003cchar\u003e\u0026\n    basic_istream\u003cchar\u003e::\n    getline(char_type* __s, streamsize __n, char_type __delim)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n          try\n\t    {\n\t      const int_type __idelim = traits_type::to_int_type(__delim);\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __sb = this-\u003erdbuf();\n\t      int_type __c = __sb-\u003esgetc();\n\t      \n\t      while (_M_gcount + 1 \u003c __n\n\t\t     \u0026\u0026 !traits_type::eq_int_type(__c, __eof)\n\t\t     \u0026\u0026 !traits_type::eq_int_type(__c, __idelim))\n\t\t{\n\t\t  streamsize __size = std::min(streamsize(__sb-\u003eegptr()\n\t\t\t\t\t\t\t  - __sb-\u003egptr()),\n\t\t\t\t\t       streamsize(__n - _M_gcount\n\t\t\t\t\t\t\t  - 1));\n\t\t  if (__size \u003e 1)\n\t\t    {\n\t\t      const char_type* __p = traits_type::find(__sb-\u003egptr(),\n\t\t\t\t\t\t\t       __size,\n\t\t\t\t\t\t\t       __delim);\n\t\t      if (__p)\n\t\t\t__size = __p - __sb-\u003egptr();\n\t\t      traits_type::copy(__s, __sb-\u003egptr(), __size);\n\t\t      __s += __size;\n\t\t      __sb-\u003egbump(__size);\n\t\t      _M_gcount += __size;\n\t\t      __c = __sb-\u003esgetc();\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *__s++ = traits_type::to_char_type(__c);\n\t\t      ++_M_gcount;\n\t\t      __c = __sb-\u003esnextc();\n\t\t    }\n\t\t}\n\n\t      if (traits_type::eq_int_type(__c, __eof))\n\t\t__err |= ios_base::eofbit;\n\t      else if (traits_type::eq_int_type(__c, __idelim))\n\t\t{\n\t\t  ++_M_gcount;\t\t  \n\t\t  __sb-\u003esbumpc();\n\t\t}\n\t      else\n\t\t__err |= ios_base::failbit;\n\t    }\n\t  catch(...)\n\t    { this-\u003e_M_setstate(ios_base::badbit); }\n\t}\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 243. get and getline when sentry reports failure.\n      if (__n \u003e 0)\n\t*__s = char_type();\n      if (!_M_gcount)\n\t__err |= ios_base::failbit;\n      if (__err)\n\tthis-\u003esetstate(__err);\n      return *this;\n    }","filepath":"libstdc++-v3/src/istream.cc","line_number":39,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.0.0"},"5768464":{"score":0.6062224,"function_name":"basic_istream\u003cchar\u003e::\n    ignore","code":"basic_istream\u003cchar\u003e\u0026\n    basic_istream\u003cchar\u003e::\n    ignore(streamsize __n)\n    {\n      if (__n == 1)\n\treturn ignore();\n      \n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb \u0026\u0026 __n \u003e 0)\n\t{\n\t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n\t  try\n\t    {\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __sb = this-\u003erdbuf();\n\t      int_type __c = __sb-\u003esgetc();\n\n\t      // See comment in istream.tcc.\n\t      bool __large_ignore = false;\n\t      while (true)\n\t\t{\n\t\t  while (_M_gcount \u003c __n\n\t\t\t \u0026\u0026 !traits_type::eq_int_type(__c, __eof))\n\t\t    {\n\t\t      streamsize __size = std::min(streamsize(__sb-\u003eegptr()\n\t\t\t\t\t\t\t      - __sb-\u003egptr()),\n\t\t\t\t\t\t   streamsize(__n - _M_gcount));\n\t\t      if (__size \u003e 1)\n\t\t\t{\n\t\t\t  __sb-\u003egbump(__size);\n\t\t\t  _M_gcount += __size;\n\t\t\t  __c = __sb-\u003esgetc();\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  ++_M_gcount;\n\t\t\t  __c = __sb-\u003esnextc();\n\t\t\t} \n\t\t    }\n\t\t  if (__n == numeric_limits\u003cstreamsize\u003e::max()\n\t\t      \u0026\u0026 !traits_type::eq_int_type(__c, __eof))\n\t\t    {\n\t\t      _M_gcount = numeric_limits\u003cstreamsize\u003e::min();\n\t\t      __large_ignore = true;\n\t\t    }\n\t\t  else\n\t\t    break;\n\t\t}\n\n\t      if (__large_ignore)\n\t\t_M_gcount = numeric_limits\u003cstreamsize\u003e::max();\n\n\t      if (traits_type::eq_int_type(__c, __eof))\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  catch(...)\n\t    { this-\u003e_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this-\u003esetstate(__err);\n\t}\n      return *this;\n    }","filepath":"libstdc++-v3/src/istream.cc","line_number":109,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.0.0"},"5771952":{"score":0.7077137,"function_name":"codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_out","code":"codecvt_base::result\n  codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_out(state_type\u0026 __state, const intern_type* __from, \n\t const intern_type* __from_end, const intern_type*\u0026 __from_next,\n\t extern_type* __to, extern_type* __to_end,\n\t extern_type*\u0026 __to_next) const\n  {\n    result __ret = ok;\n    state_type __tmp_state(__state);\n\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __old = __uselocale(_M_c_locale_codecvt);\n#endif\n\n    // wcsnrtombs is *very* fast but stops if encounters NUL characters:\n    // in case we fall back to wcrtomb and then continue, in a loop.\n    // NB: wcsnrtombs is a GNU extension\n    for (__from_next = __from, __to_next = __to;\n\t __from_next \u003c __from_end \u0026\u0026 __to_next \u003c __to_end\n\t \u0026\u0026 __ret == ok;)\n      {\n\tconst intern_type* __from_chunk_end = wmemchr(__from_next, L'\\0',\n\t\t\t\t\t\t      __from_end - __from_next);\n\tif (!__from_chunk_end)\n\t  __from_chunk_end = __from_end;\n\n\t__from = __from_next;\n\tconst size_t __conv = wcsnrtombs(__to_next, \u0026__from_next,\n\t\t\t\t\t __from_chunk_end - __from_next,\n\t\t\t\t\t __to_end - __to_next, \u0026__state);\n\tif (__conv == static_cast\u003csize_t\u003e(-1))\n\t  {\n\t    // In case of error, in order to stop at the exact place we\n\t    // have to start again from the beginning with a series of\n\t    // wcrtomb.\n\t    for (; __from \u003c __from_next; ++__from)\n\t      __to_next += wcrtomb(__to_next, *__from, \u0026__tmp_state);\n\t    __state = __tmp_state;\n\t    __ret = error;\n\t  }\n\telse if (__from_next \u0026\u0026 __from_next \u003c __from_chunk_end)\n\t  {\n\t    __to_next += __conv;\n\t    __ret = partial;\n\t  }\n\telse\n\t  {\n\t    __from_next = __from_chunk_end;\n\t    __to_next += __conv;\n\t  }\n\n\tif (__from_next \u003c __from_end \u0026\u0026 __ret == ok)\n\t  {\n\t    extern_type __buf[MB_LEN_MAX];\n\t    __tmp_state = __state;\n\t    const size_t __conv = wcrtomb(__buf, *__from_next, \u0026__tmp_state);\n\t    if (__conv \u003e static_cast\u003csize_t\u003e(__to_end - __to_next))\n\t      __ret = partial;\n\t    else\n\t      {\n\t\tmemcpy(__to_next, __buf, __conv);\n\t\t__state = __tmp_state;\n\t\t__to_next += __conv;\n\t\t++__from_next;\n\t      }\n\t  }\n      }\n\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __uselocale(__old);\n#endif\n\n    return __ret; \n  }","filepath":"libstdc++-v3/config/locale/gnu/codecvt_members.cc","line_number":43,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5772560":{"score":0.71905917,"function_name":"codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_in","code":"codecvt_base::result\n  codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_in(state_type\u0026 __state, const extern_type* __from, \n\tconst extern_type* __from_end, const extern_type*\u0026 __from_next,\n\tintern_type* __to, intern_type* __to_end,\n\tintern_type*\u0026 __to_next) const\n  {\n    result __ret = ok;\n    state_type __tmp_state(__state);\n\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __old = __uselocale(_M_c_locale_codecvt);\n#endif\n\n    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n    // in case we store a L'\\0' and then continue, in a loop.\n    // NB: mbsnrtowcs is a GNU extension\n    for (__from_next = __from, __to_next = __to;\n\t __from_next \u003c __from_end \u0026\u0026 __to_next \u003c __to_end\n\t \u0026\u0026 __ret == ok;)\n      {\n\tconst extern_type* __from_chunk_end;\n\t__from_chunk_end = static_cast\u003cconst extern_type*\u003e(memchr(__from_next, '\\0',\n\t\t\t\t\t\t\t\t  __from_end\n\t\t\t\t\t\t\t\t  - __from_next));\n\tif (!__from_chunk_end)\n\t  __from_chunk_end = __from_end;\n\n\t__from = __from_next;\n\tsize_t __conv = mbsnrtowcs(__to_next, \u0026__from_next,\n\t\t\t\t   __from_chunk_end - __from_next,\n\t\t\t\t   __to_end - __to_next, \u0026__state);\n\tif (__conv == static_cast\u003csize_t\u003e(-1))\n\t  {\n\t    // In case of error, in order to stop at the exact place we\n\t    // have to start again from the beginning with a series of\n\t    // mbrtowc.\n\t    for (;; ++__to_next, __from += __conv)\n\t      {\n\t\t__conv = mbrtowc(__to_next, __from, __from_end - __from,\n\t\t\t\t \u0026__tmp_state);\n\t\tif (__conv == static_cast\u003csize_t\u003e(-1)\n\t\t    || __conv == static_cast\u003csize_t\u003e(-2))\n\t\t  break;\n\t      }\n\t    __from_next = __from;\n\t    __state = __tmp_state;\t    \n\t    __ret = error;\n\t  }\n\telse if (__from_next \u0026\u0026 __from_next \u003c __from_chunk_end)\n\t  {\n\t    // It is unclear what to return in this case (see DR 382). \n\t    __to_next += __conv;\n\t    __ret = partial;\n\t  }\n\telse\n\t  {\n\t    __from_next = __from_chunk_end;\n\t    __to_next += __conv;\n\t  }\n\n\tif (__from_next \u003c __from_end \u0026\u0026 __ret == ok)\n\t  {\n\t    if (__to_next \u003c __to_end)\n\t      {\n\t\t// XXX Probably wrong for stateful encodings\n\t\t__tmp_state = __state;\t\t\n\t\t++__from_next;\n\t\t*__to_next++ = L'\\0';\n\t      }\n\t    else\n\t      __ret = partial;\n\t  }\n      }\n\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __uselocale(__old);\n#endif\n\n    return __ret; \n  }","filepath":"libstdc++-v3/config/locale/gnu/codecvt_members.cc","line_number":118,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5773232":{"score":0.6634889,"function_name":"codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_length","code":"int \n  codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_length(state_type\u0026 __state, const extern_type* __from,\n\t    const extern_type* __end, size_t __max) const\n  {\n    int __ret = 0;\n    state_type __tmp_state(__state);\n\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __old = __uselocale(_M_c_locale_codecvt);\n#endif\n\n    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n    // in case we advance past it and then continue, in a loop.\n    // NB: mbsnrtowcs is a GNU extension\n  \n    // A dummy internal buffer is needed in order for mbsnrtocws to consider\n    // its fourth parameter (it wouldn't with NULL as first parameter).\n    wchar_t* __to = static_cast\u003cwchar_t*\u003e(__builtin_alloca(sizeof(wchar_t) \n\t\t\t\t\t\t\t   * __max));\n    while (__from \u003c __end \u0026\u0026 __max)\n      {\n\tconst extern_type* __from_chunk_end;\n\t__from_chunk_end = static_cast\u003cconst extern_type*\u003e(memchr(__from, '\\0',\n\t\t\t\t\t\t\t\t  __end\n\t\t\t\t\t\t\t\t  - __from));\n\tif (!__from_chunk_end)\n\t  __from_chunk_end = __end;\n\n\tconst extern_type* __tmp_from = __from;\n\tsize_t __conv = mbsnrtowcs(__to, \u0026__from,\n\t\t\t\t   __from_chunk_end - __from,\n\t\t\t\t   __max, \u0026__state);\n\tif (__conv == static_cast\u003csize_t\u003e(-1))\n\t  {\n\t    // In case of error, in order to stop at the exact place we\n\t    // have to start again from the beginning with a series of\n\t    // mbrtowc.\n\t    for (__from = __tmp_from;; __from += __conv)\n\t      {\n\t\t__conv = mbrtowc(NULL, __from, __end - __from,\n\t\t\t\t \u0026__tmp_state);\n\t\tif (__conv == static_cast\u003csize_t\u003e(-1)\n\t\t    || __conv == static_cast\u003csize_t\u003e(-2))\n\t\t  break;\n\t      }\n\t    __state = __tmp_state;\n\t    __ret += __from - __tmp_from;\n\t    break;\n\t  }\n\tif (!__from)\n\t  __from = __from_chunk_end;\n\t\n\t__ret += __from - __tmp_from;\n\t__max -= __conv;\n\n\tif (__from \u003c __end \u0026\u0026 __max)\n\t  {\n\t    // XXX Probably wrong for stateful encodings\n\t    __tmp_state = __state;\n\t    ++__from;\n\t    ++__ret;\n\t    --__max;\n\t  }\n      }\n\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __uselocale(__old);\n#endif\n\n    return __ret; \n  }","filepath":"libstdc++-v3/config/locale/gnu/codecvt_members.cc","line_number":233,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"misc/cutover-cvs2svn"},"5773696":{"score":0.7685618,"function_name":"basic_istream\u003cchar\u003e::\n    ignore","code":"basic_istream\u003cchar\u003e\u0026\n    basic_istream\u003cchar\u003e::\n    ignore(streamsize __n)\n    {\n      if (__n == 1)\n\treturn ignore();\n      \n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb \u0026\u0026 __n \u003e 0)\n\t{\n\t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n\t  try\n\t    {\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __sb = this-\u003erdbuf();\n\t      int_type __c = __sb-\u003esgetc();\n\n\t      // See comment in istream.tcc.\n\t      bool __large_ignore = false;\n\t      while (true)\n\t\t{\n\t\t  while (_M_gcount \u003c __n\n\t\t\t \u0026\u0026 !traits_type::eq_int_type(__c, __eof))\n\t\t    {\n\t\t      streamsize __size = std::min(streamsize(__sb-\u003eegptr()\n\t\t\t\t\t\t\t      - __sb-\u003egptr()),\n\t\t\t\t\t          streamsize(__n - _M_gcount));\n\t\t      if (__size \u003e 1)\n\t\t\t{\n\t\t\t  __sb-\u003egbump(__size);\n\t\t\t  _M_gcount += __size;\n\t\t\t  __c = __sb-\u003esgetc();\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  ++_M_gcount;\n\t\t\t  __c = __sb-\u003esnextc();\n\t\t\t} \n\t\t    }\n\t\t  if (__n == __gnu_cxx::__numeric_traits\u003cstreamsize\u003e::__max\n\t\t      \u0026\u0026 !traits_type::eq_int_type(__c, __eof))\n\t\t    {\n\t\t      _M_gcount =\n\t\t\t__gnu_cxx::__numeric_traits\u003cstreamsize\u003e::__min;\n\t\t      __large_ignore = true;\n\t\t    }\n\t\t  else\n\t\t    break;\n\t\t}\n\n\t      if (__large_ignore)\n\t\t_M_gcount = __gnu_cxx::__numeric_traits\u003cstreamsize\u003e::__max;\n\n\t      if (traits_type::eq_int_type(__c, __eof))\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  catch(__cxxabiv1::__forced_unwind\u0026)\n\t    {\n\t      this-\u003e_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  catch(...)\n\t    { this-\u003e_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this-\u003esetstate(__err);\n\t}\n      return *this;\n    }","filepath":"libstdc++-v3/src/compatibility.cc","line_number":60,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5778304":{"score":0.818627,"function_name":"execute_cfa_program","code":"static void\nexecute_cfa_program (const unsigned char *insn_ptr,\n\t\t     const unsigned char *insn_end,\n\t\t     struct _Unwind_Context *context,\n\t\t     _Unwind_FrameState *fs)\n{\n  struct frame_state_reg_info *unused_rs = NULL;\n\n  /* Don't allow remember/restore between CIE and FDE programs.  */\n  fs-\u003eregs.prev = NULL;\n\n  /* The comparison with the return address uses \u003c rather than \u003c= because\n     we are only interested in the effects of code before the call; for a\n     noreturn function, the return address may point to unrelated code with\n     a different stack configuration that we are not interested in.  We\n     assume that the call itself is unwind info-neutral; if not, or if\n     there are delay instructions that adjust the stack, these must be\n     reflected at the point immediately before the call insn.  */\n  while (insn_ptr \u003c insn_end \u0026\u0026 fs-\u003epc \u003c context-\u003era)\n    {\n      unsigned char insn = *insn_ptr++;\n      _Unwind_Word reg, utmp;\n      _Unwind_Sword offset, stmp;\n\n      if ((insn \u0026 0xc0) == DW_CFA_advance_loc)\n\tfs-\u003epc += (insn \u0026 0x3f) * fs-\u003ecode_align;\n      else if ((insn \u0026 0xc0) == DW_CFA_offset)\n\t{\n\t  reg = insn \u0026 0x3f;\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  offset = (_Unwind_Sword) utmp * fs-\u003edata_align;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n\t    = REG_SAVED_OFFSET;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n\t}\n      else if ((insn \u0026 0xc0) == DW_CFA_restore)\n\t{\n\t  reg = insn \u0026 0x3f;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_UNSAVED;\n\t}\n      else switch (insn)\n\t{\n\tcase DW_CFA_set_loc:\n\t  insn_ptr = read_encoded_value (context, fs-\u003efde_encoding,\n\t\t\t\t\t insn_ptr, (_Unwind_Ptr *) \u0026fs-\u003epc);\n\t  break;\n\n\tcase DW_CFA_advance_loc1:\n\t  fs-\u003epc += read_1u (insn_ptr) * fs-\u003ecode_align;\n\t  insn_ptr += 1;\n\t  break;\n\tcase DW_CFA_advance_loc2:\n\t  fs-\u003epc += read_2u (insn_ptr) * fs-\u003ecode_align;\n\t  insn_ptr += 2;\n\t  break;\n\tcase DW_CFA_advance_loc4:\n\t  fs-\u003epc += read_4u (insn_ptr) * fs-\u003ecode_align;\n\t  insn_ptr += 4;\n\t  break;\n\n\tcase DW_CFA_offset_extended:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  offset = (_Unwind_Sword) utmp * fs-\u003edata_align;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n\t    = REG_SAVED_OFFSET;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n\t  break;\n\n\tcase DW_CFA_restore_extended:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n\t  break;\n\n\tcase DW_CFA_undefined:\n\tcase DW_CFA_same_value:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  break;\n\n\tcase DW_CFA_nop:\n\t  break;\n\n\tcase DW_CFA_register:\n\t  {\n\t    _Unwind_Word reg2;\n\t    insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t    insn_ptr = read_uleb128 (insn_ptr, \u0026reg2);\n\t    fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_REG;\n\t    fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.reg = reg2;\n\t  }\n\t  break;\n\n\tcase DW_CFA_remember_state:\n\t  {\n\t    struct frame_state_reg_info *new_rs;\n\t    if (unused_rs)\n\t      {\n\t\tnew_rs = unused_rs;\n\t\tunused_rs = unused_rs-\u003eprev;\n\t      }\n\t    else\n\t      new_rs = __builtin_alloca (sizeof (struct frame_state_reg_info));\n\n\t    *new_rs = fs-\u003eregs;\n\t    fs-\u003eregs.prev = new_rs;\n\t  }\n\t  break;\n\n\tcase DW_CFA_restore_state:\n\t  {\n\t    struct frame_state_reg_info *old_rs = fs-\u003eregs.prev;\n\t    fs-\u003eregs = *old_rs;\n\t    old_rs-\u003eprev = unused_rs;\n\t    unused_rs = old_rs;\n\t  }\n\t  break;\n\n\tcase DW_CFA_def_cfa:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026fs-\u003ecfa_reg);\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  fs-\u003ecfa_offset = utmp;\n\t  fs-\u003ecfa_how = CFA_REG_OFFSET;\n\t  break;\n\n\tcase DW_CFA_def_cfa_register:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026fs-\u003ecfa_reg);\n\t  fs-\u003ecfa_how = CFA_REG_OFFSET;\n\t  break;\n\n\tcase DW_CFA_def_cfa_offset:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  fs-\u003ecfa_offset = utmp;\n\t  /* cfa_how deliberately not set.  */\n\t  break;\n\n\tcase DW_CFA_def_cfa_expression:\n\t  fs-\u003ecfa_exp = insn_ptr;\n\t  fs-\u003ecfa_how = CFA_EXP;\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  insn_ptr += utmp;\n\t  break;\n\n\tcase DW_CFA_expression:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_EXP;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.exp = insn_ptr;\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  insn_ptr += utmp;\n\t  break;\n\n\t  /* From the 2.1 draft.  */\n\tcase DW_CFA_offset_extended_sf:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_sleb128 (insn_ptr, \u0026stmp);\n\t  offset = stmp * fs-\u003edata_align;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n\t    = REG_SAVED_OFFSET;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n\t  break;\n\n\tcase DW_CFA_def_cfa_sf:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026fs-\u003ecfa_reg);\n\t  insn_ptr = read_sleb128 (insn_ptr, \u0026fs-\u003ecfa_offset);\n\t  fs-\u003ecfa_how = CFA_REG_OFFSET;\n\t  break;\n\n\tcase DW_CFA_def_cfa_offset_sf:\n\t  insn_ptr = read_sleb128 (insn_ptr, \u0026fs-\u003ecfa_offset);\n\t  /* cfa_how deliberately not set.  */\n\t  break;\n\n\tcase DW_CFA_GNU_window_save:\n\t  /* ??? Hardcoded for SPARC register window configuration.  */\n\t  for (reg = 16; reg \u003c 32; ++reg)\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_OFFSET;\n\t      fs-\u003eregs.reg[reg].loc.offset = (reg - 16) * sizeof (void *);\n\t    }\n\t  break;\n\n\tcase DW_CFA_GNU_args_size:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026context-\u003eargs_size);\n\t  break;\n\n\tcase DW_CFA_GNU_negative_offset_extended:\n\t  /* Obsoleted by DW_CFA_offset_extended_sf, but used by\n\t     older PowerPC code.  */\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  offset = (_Unwind_Word) utmp * fs-\u003edata_align;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n\t    = REG_SAVED_OFFSET;\n\t  fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = -offset;\n\t  break;\n\n\tdefault:\n\t  abort ();\n\t}\n    }\n}","filepath":"gcc/unwind-dw2.c","line_number":804,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.4"},"5780736":{"score":0.53223264,"function_name":"uw_frame_state_for","code":"static _Unwind_Reason_Code\nuw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n{\n  const struct dwarf_fde *fde;\n  const struct dwarf_cie *cie;\n  const unsigned char *aug, *insn, *end;\n\n  memset (fs, 0, sizeof (*fs));\n  context-\u003eargs_size = 0;\n  context-\u003elsda = 0;\n\n  if (context-\u003era == 0)\n    return _URC_END_OF_STACK;\n\n  fde = _Unwind_Find_FDE (context-\u003era + _Unwind_IsSignalFrame (context) - 1,\n\t\t\t  \u0026context-\u003ebases);\n  if (fde == NULL)\n    {\n#ifdef MD_FALLBACK_FRAME_STATE_FOR\n      /* Couldn't find frame unwind info for this function.  Try a\n\t target-specific fallback mechanism.  This will necessarily\n\t not provide a personality routine or LSDA.  */\n      return MD_FALLBACK_FRAME_STATE_FOR (context, fs);\n#else\n      return _URC_END_OF_STACK;\n#endif\n    }\n\n  fs-\u003epc = context-\u003ebases.func;\n\n  cie = get_cie (fde);\n  insn = extract_cie_info (cie, context, fs);\n  if (insn == NULL)\n    /* CIE contained unknown augmentation.  */\n    return _URC_FATAL_PHASE1_ERROR;\n\n  /* First decode all the insns in the CIE.  */\n  end = (const unsigned char *) next_fde ((const struct dwarf_fde *) cie);\n  execute_cfa_program (insn, end, context, fs);\n\n  /* Locate augmentation for the fde.  */\n  aug = (const unsigned char *) fde + sizeof (*fde);\n  aug += 2 * size_of_encoded_value (fs-\u003efde_encoding);\n  insn = NULL;\n  if (fs-\u003esaw_z)\n    {\n      _uleb128_t i;\n      aug = read_uleb128 (aug, \u0026i);\n      insn = aug + i;\n    }\n  if (fs-\u003elsda_encoding != DW_EH_PE_omit)\n    {\n      _Unwind_Ptr lsda;\n\n      aug = read_encoded_value (context, fs-\u003elsda_encoding, aug, \u0026lsda);\n      context-\u003elsda = (void *) lsda;\n    }\n\n  /* Then the insns in the FDE up to our target PC.  */\n  if (insn == NULL)\n    insn = aug;\n  end = (const unsigned char *) next_fde (fde);\n  execute_cfa_program (insn, end, context, fs);\n\n  return _URC_NO_REASON;\n}","filepath":"gcc/unwind-dw2.c","line_number":1123,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5782352":{"score":0.85016274,"function_name":"execute_stack_op","code":"static _Unwind_Word\nexecute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n\t\t  struct _Unwind_Context *context, _Unwind_Word initial)\n{\n  _Unwind_Word stack[64];\t/* ??? Assume this is enough.  */\n  int stack_elt;\n\n  stack[0] = initial;\n  stack_elt = 1;\n\n  while (op_ptr \u003c op_end)\n    {\n      enum dwarf_location_atom op = *op_ptr++;\n      _Unwind_Word result;\n      _uleb128_t reg, utmp;\n      _sleb128_t offset, stmp;\n\n      switch (op)\n\t{\n\tcase DW_OP_lit0:\n\tcase DW_OP_lit1:\n\tcase DW_OP_lit2:\n\tcase DW_OP_lit3:\n\tcase DW_OP_lit4:\n\tcase DW_OP_lit5:\n\tcase DW_OP_lit6:\n\tcase DW_OP_lit7:\n\tcase DW_OP_lit8:\n\tcase DW_OP_lit9:\n\tcase DW_OP_lit10:\n\tcase DW_OP_lit11:\n\tcase DW_OP_lit12:\n\tcase DW_OP_lit13:\n\tcase DW_OP_lit14:\n\tcase DW_OP_lit15:\n\tcase DW_OP_lit16:\n\tcase DW_OP_lit17:\n\tcase DW_OP_lit18:\n\tcase DW_OP_lit19:\n\tcase DW_OP_lit20:\n\tcase DW_OP_lit21:\n\tcase DW_OP_lit22:\n\tcase DW_OP_lit23:\n\tcase DW_OP_lit24:\n\tcase DW_OP_lit25:\n\tcase DW_OP_lit26:\n\tcase DW_OP_lit27:\n\tcase DW_OP_lit28:\n\tcase DW_OP_lit29:\n\tcase DW_OP_lit30:\n\tcase DW_OP_lit31:\n\t  result = op - DW_OP_lit0;\n\t  break;\n\n\tcase DW_OP_addr:\n\t  result = (_Unwind_Word) (_Unwind_Ptr) read_pointer (op_ptr);\n\t  op_ptr += sizeof (void *);\n\t  break;\n\n\tcase DW_OP_GNU_encoded_addr:\n\t  {\n\t    _Unwind_Ptr presult;\n\t    op_ptr = read_encoded_value (context, *op_ptr, op_ptr+1, \u0026presult);\n\t    result = presult;\n\t  }\n\t  break;\n\n\tcase DW_OP_const1u:\n\t  result = read_1u (op_ptr);\n\t  op_ptr += 1;\n\t  break;\n\tcase DW_OP_const1s:\n\t  result = read_1s (op_ptr);\n\t  op_ptr += 1;\n\t  break;\n\tcase DW_OP_const2u:\n\t  result = read_2u (op_ptr);\n\t  op_ptr += 2;\n\t  break;\n\tcase DW_OP_const2s:\n\t  result = read_2s (op_ptr);\n\t  op_ptr += 2;\n\t  break;\n\tcase DW_OP_const4u:\n\t  result = read_4u (op_ptr);\n\t  op_ptr += 4;\n\t  break;\n\tcase DW_OP_const4s:\n\t  result = read_4s (op_ptr);\n\t  op_ptr += 4;\n\t  break;\n\tcase DW_OP_const8u:\n\t  result = read_8u (op_ptr);\n\t  op_ptr += 8;\n\t  break;\n\tcase DW_OP_const8s:\n\t  result = read_8s (op_ptr);\n\t  op_ptr += 8;\n\t  break;\n\tcase DW_OP_constu:\n\t  op_ptr = read_uleb128 (op_ptr, \u0026utmp);\n\t  result = (_Unwind_Word)utmp;\n\t  break;\n\tcase DW_OP_consts:\n\t  op_ptr = read_sleb128 (op_ptr, \u0026stmp);\n\t  result = (_Unwind_Sword)stmp;\n\t  break;\n\n\tcase DW_OP_reg0:\n\tcase DW_OP_reg1:\n\tcase DW_OP_reg2:\n\tcase DW_OP_reg3:\n\tcase DW_OP_reg4:\n\tcase DW_OP_reg5:\n\tcase DW_OP_reg6:\n\tcase DW_OP_reg7:\n\tcase DW_OP_reg8:\n\tcase DW_OP_reg9:\n\tcase DW_OP_reg10:\n\tcase DW_OP_reg11:\n\tcase DW_OP_reg12:\n\tcase DW_OP_reg13:\n\tcase DW_OP_reg14:\n\tcase DW_OP_reg15:\n\tcase DW_OP_reg16:\n\tcase DW_OP_reg17:\n\tcase DW_OP_reg18:\n\tcase DW_OP_reg19:\n\tcase DW_OP_reg20:\n\tcase DW_OP_reg21:\n\tcase DW_OP_reg22:\n\tcase DW_OP_reg23:\n\tcase DW_OP_reg24:\n\tcase DW_OP_reg25:\n\tcase DW_OP_reg26:\n\tcase DW_OP_reg27:\n\tcase DW_OP_reg28:\n\tcase DW_OP_reg29:\n\tcase DW_OP_reg30:\n\tcase DW_OP_reg31:\n\t  result = _Unwind_GetGR (context, op - DW_OP_reg0);\n\t  break;\n\tcase DW_OP_regx:\n\t  op_ptr = read_uleb128 (op_ptr, \u0026reg);\n\t  result = _Unwind_GetGR (context, reg);\n\t  break;\n\n\tcase DW_OP_breg0:\n\tcase DW_OP_breg1:\n\tcase DW_OP_breg2:\n\tcase DW_OP_breg3:\n\tcase DW_OP_breg4:\n\tcase DW_OP_breg5:\n\tcase DW_OP_breg6:\n\tcase DW_OP_breg7:\n\tcase DW_OP_breg8:\n\tcase DW_OP_breg9:\n\tcase DW_OP_breg10:\n\tcase DW_OP_breg11:\n\tcase DW_OP_breg12:\n\tcase DW_OP_breg13:\n\tcase DW_OP_breg14:\n\tcase DW_OP_breg15:\n\tcase DW_OP_breg16:\n\tcase DW_OP_breg17:\n\tcase DW_OP_breg18:\n\tcase DW_OP_breg19:\n\tcase DW_OP_breg20:\n\tcase DW_OP_breg21:\n\tcase DW_OP_breg22:\n\tcase DW_OP_breg23:\n\tcase DW_OP_breg24:\n\tcase DW_OP_breg25:\n\tcase DW_OP_breg26:\n\tcase DW_OP_breg27:\n\tcase DW_OP_breg28:\n\tcase DW_OP_breg29:\n\tcase DW_OP_breg30:\n\tcase DW_OP_breg31:\n\t  op_ptr = read_sleb128 (op_ptr, \u0026offset);\n\t  result = _Unwind_GetGR (context, op - DW_OP_breg0) + offset;\n\t  break;\n\tcase DW_OP_bregx:\n\t  op_ptr = read_uleb128 (op_ptr, \u0026reg);\n\t  op_ptr = read_sleb128 (op_ptr, \u0026offset);\n\t  result = _Unwind_GetGR (context, reg) + (_Unwind_Word)offset;\n\t  break;\n\n\tcase DW_OP_dup:\n\t  gcc_assert (stack_elt);\n\t  result = stack[stack_elt - 1];\n\t  break;\n\n\tcase DW_OP_drop:\n\t  gcc_assert (stack_elt);\n\t  stack_elt -= 1;\n\t  goto no_push;\n\n\tcase DW_OP_pick:\n\t  offset = *op_ptr++;\n\t  gcc_assert (offset \u003c stack_elt - 1);\n\t  result = stack[stack_elt - 1 - offset];\n\t  break;\n\n\tcase DW_OP_over:\n\t  gcc_assert (stack_elt \u003e= 2);\n\t  result = stack[stack_elt - 2];\n\t  break;\n\n\tcase DW_OP_swap:\n\t  {\n\t    _Unwind_Word t;\n\t    gcc_assert (stack_elt \u003e= 2);\n\t    t = stack[stack_elt - 1];\n\t    stack[stack_elt - 1] = stack[stack_elt - 2];\n\t    stack[stack_elt - 2] = t;\n\t    goto no_push;\n\t  }\n\n\tcase DW_OP_rot:\n\t  {\n\t    _Unwind_Word t1, t2, t3;\n\n\t    gcc_assert (stack_elt \u003e= 3);\n\t    t1 = stack[stack_elt - 1];\n\t    t2 = stack[stack_elt - 2];\n\t    t3 = stack[stack_elt - 3];\n\t    stack[stack_elt - 1] = t2;\n\t    stack[stack_elt - 2] = t3;\n\t    stack[stack_elt - 3] = t1;\n\t    goto no_push;\n\t  }\n\n\tcase DW_OP_deref:\n\tcase DW_OP_deref_size:\n\tcase DW_OP_abs:\n\tcase DW_OP_neg:\n\tcase DW_OP_not:\n\tcase DW_OP_plus_uconst:\n\t  /* Unary operations.  */\n\t  gcc_assert (stack_elt);\n\t  stack_elt -= 1;\n\n\t  result = stack[stack_elt];\n\n\t  switch (op)\n\t    {\n\t    case DW_OP_deref:\n\t      {\n\t\tvoid *ptr = (void *) (_Unwind_Ptr) result;\n\t\tresult = (_Unwind_Ptr) read_pointer (ptr);\n\t      }\n\t      break;\n\n\t    case DW_OP_deref_size:\n\t      {\n\t\tvoid *ptr = (void *) (_Unwind_Ptr) result;\n\t\tswitch (*op_ptr++)\n\t\t  {\n\t\t  case 1:\n\t\t    result = read_1u (ptr);\n\t\t    break;\n\t\t  case 2:\n\t\t    result = read_2u (ptr);\n\t\t    break;\n\t\t  case 4:\n\t\t    result = read_4u (ptr);\n\t\t    break;\n\t\t  case 8:\n\t\t    result = read_8u (ptr);\n\t\t    break;\n\t\t  default:\n\t\t    gcc_unreachable ();\n\t\t  }\n\t      }\n\t      break;\n\n\t    case DW_OP_abs:\n\t      if ((_Unwind_Sword) result \u003c 0)\n\t\tresult = -result;\n\t      break;\n\t    case DW_OP_neg:\n\t      result = -result;\n\t      break;\n\t    case DW_OP_not:\n\t      result = ~result;\n\t      break;\n\t    case DW_OP_plus_uconst:\n\t      op_ptr = read_uleb128 (op_ptr, \u0026utmp);\n\t      result += (_Unwind_Word)utmp;\n\t      break;\n\n\t    default:\n\t      gcc_unreachable ();\n\t    }\n\t  break;\n\n\tcase DW_OP_and:\n\tcase DW_OP_div:\n\tcase DW_OP_minus:\n\tcase DW_OP_mod:\n\tcase DW_OP_mul:\n\tcase DW_OP_or:\n\tcase DW_OP_plus:\n\tcase DW_OP_shl:\n\tcase DW_OP_shr:\n\tcase DW_OP_shra:\n\tcase DW_OP_xor:\n\tcase DW_OP_le:\n\tcase DW_OP_ge:\n\tcase DW_OP_eq:\n\tcase DW_OP_lt:\n\tcase DW_OP_gt:\n\tcase DW_OP_ne:\n\t  {\n\t    /* Binary operations.  */\n\t    _Unwind_Word first, second;\n\t    gcc_assert (stack_elt \u003e= 2);\n\t    stack_elt -= 2;\n\n\t    second = stack[stack_elt];\n\t    first = stack[stack_elt + 1];\n\n\t    switch (op)\n\t      {\n\t      case DW_OP_and:\n\t\tresult = second \u0026 first;\n\t\tbreak;\n\t      case DW_OP_div:\n\t\tresult = (_Unwind_Sword) second / (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_minus:\n\t\tresult = second - first;\n\t\tbreak;\n\t      case DW_OP_mod:\n\t\tresult = second % first;\n\t\tbreak;\n\t      case DW_OP_mul:\n\t\tresult = second * first;\n\t\tbreak;\n\t      case DW_OP_or:\n\t\tresult = second | first;\n\t\tbreak;\n\t      case DW_OP_plus:\n\t\tresult = second + first;\n\t\tbreak;\n\t      case DW_OP_shl:\n\t\tresult = second \u003c\u003c first;\n\t\tbreak;\n\t      case DW_OP_shr:\n\t\tresult = second \u003e\u003e first;\n\t\tbreak;\n\t      case DW_OP_shra:\n\t\tresult = (_Unwind_Sword) second \u003e\u003e first;\n\t\tbreak;\n\t      case DW_OP_xor:\n\t\tresult = second ^ first;\n\t\tbreak;\n\t      case DW_OP_le:\n\t\tresult = (_Unwind_Sword) second \u003c= (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_ge:\n\t\tresult = (_Unwind_Sword) second \u003e= (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_eq:\n\t\tresult = (_Unwind_Sword) second == (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_lt:\n\t\tresult = (_Unwind_Sword) second \u003c (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_gt:\n\t\tresult = (_Unwind_Sword) second \u003e (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_ne:\n\t\tresult = (_Unwind_Sword) second != (_Unwind_Sword) first;\n\t\tbreak;\n\n\t      default:\n\t\tgcc_unreachable ();\n\t      }\n\t  }\n\t  break;\n\n\tcase DW_OP_skip:\n\t  offset = read_2s (op_ptr);\n\t  op_ptr += 2;\n\t  op_ptr += offset;\n\t  goto no_push;\n\n\tcase DW_OP_bra:\n\t  gcc_assert (stack_elt);\n\t  stack_elt -= 1;\n\n\t  offset = read_2s (op_ptr);\n\t  op_ptr += 2;\n\t  if (stack[stack_elt] != 0)\n\t    op_ptr += offset;\n\t  goto no_push;\n\n\tcase DW_OP_nop:\n\t  goto no_push;\n\n\tdefault:\n\t  gcc_unreachable ();\n\t}\n\n      /* Most things push a result value.  */\n      gcc_assert ((size_t) stack_elt \u003c sizeof(stack)/sizeof(*stack));\n      stack[stack_elt++] = result;\n    no_push:;\n    }\n\n  /* We were executing this program to get a value.  It should be\n     at top of stack.  */\n  gcc_assert (stack_elt);\n  stack_elt -= 1;\n  return stack[stack_elt];\n}","filepath":"gcc/unwind-dw2.c","line_number":442,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5785440":{"score":0.68067557,"function_name":"uw_init_context_1","code":"static void __attribute__((noinline))\nuw_init_context_1 (struct _Unwind_Context *context,\n\t\t   void *outer_cfa, void *outer_ra)\n{\n  void *ra = __builtin_extract_return_addr (__builtin_return_address (0));\n  _Unwind_FrameState fs;\n  _Unwind_SpTmp sp_slot;\n  _Unwind_Reason_Code code;\n\n  memset (context, 0, sizeof (struct _Unwind_Context));\n  context-\u003era = ra;\n  context-\u003eflags = EXTENDED_CONTEXT_BIT;\n\n  code = uw_frame_state_for (context, \u0026fs);\n  gcc_assert (code == _URC_NO_REASON);\n\n#if __GTHREADS\n  {\n    static __gthread_once_t once_regsizes = __GTHREAD_ONCE_INIT;\n    if (__gthread_once (\u0026once_regsizes, init_dwarf_reg_size_table) != 0\n\t\u0026\u0026 dwarf_reg_size_table[0] == 0)\n      init_dwarf_reg_size_table ();\n  }\n#else\n  if (dwarf_reg_size_table[0] == 0)\n    init_dwarf_reg_size_table ();\n#endif\n\n  /* Force the frame state to use the known cfa value.  */\n  _Unwind_SetSpColumn (context, outer_cfa, \u0026sp_slot);\n  fs.regs.cfa_how = CFA_REG_OFFSET;\n  fs.regs.cfa_reg = __builtin_dwarf_sp_column ();\n  fs.regs.cfa_offset = 0;\n\n  uw_update_context_1 (context, \u0026fs);\n\n  /* If the return address column was saved in a register in the\n     initialization context, then we can't see it in the given\n     call frame data.  So have the initialization context tell us.  */\n  context-\u003era = __builtin_extract_return_addr (outer_ra);\n}","filepath":"gcc/unwind-dw2.c","line_number":1443,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5785824":{"score":0.7084719,"function_name":"uw_update_context","code":"static void\nuw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n{\n  uw_update_context_1 (context, fs);\n\n  /* In general this unwinder doesn't make any distinction between\n     undefined and same_value rule.  Call-saved registers are assumed\n     to have same_value rule by default and explicit undefined\n     rule is handled like same_value.  The only exception is\n     DW_CFA_undefined on retaddr_column which is supposed to\n     mark outermost frame in DWARF 3.  */\n  if (fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (fs-\u003eretaddr_column)].how\n      == REG_UNDEFINED)\n    /* uw_frame_state_for uses context-\u003era == 0 check to find outermost\n       stack frame.  */\n    context-\u003era = 0;\n  else\n    /* Compute the return address now, since the return address column\n       can change from frame to frame.  */\n    context-\u003era = __builtin_extract_return_addr\n      (_Unwind_GetPtr (context, fs-\u003eretaddr_column));\n}","filepath":"gcc/unwind-dw2.c","line_number":1394,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5786832":{"score":0.6806321,"function_name":"_Unwind_GetGR","code":"inline _Unwind_Word\n_Unwind_GetGR (struct _Unwind_Context *context, int index)\n{\n  int size;\n  void *ptr;\n\n#ifdef DWARF_ZERO_REG\n  if (index == DWARF_ZERO_REG)\n    return 0;\n#endif\n\n  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n  gcc_assert (index \u003c (int) sizeof(dwarf_reg_size_table));\n  size = dwarf_reg_size_table[index];\n  ptr = context-\u003ereg[index];\n\n  if (_Unwind_IsExtendedContext (context) \u0026\u0026 context-\u003eby_value[index])\n    return (_Unwind_Word) (_Unwind_Internal_Ptr) ptr;\n\n  /* This will segfault if the register hasn't been saved.  */\n  if (size == sizeof(_Unwind_Ptr))\n    return * (_Unwind_Ptr *) ptr;\n  else\n    {\n      gcc_assert (size == sizeof(_Unwind_Word));\n      return * (_Unwind_Word *) ptr;\n    }\n}","filepath":"gcc/unwind-dw2.c","line_number":151,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5786928":{"score":0.766388,"function_name":"_Unwind_SetGR","code":"inline void\n_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n{\n  int size;\n  void *ptr;\n\n  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n  gcc_assert (index \u003c (int) sizeof(dwarf_reg_size_table));\n  size = dwarf_reg_size_table[index];\n\n  if (_Unwind_IsExtendedContext (context) \u0026\u0026 context-\u003eby_value[index])\n    {\n      context-\u003ereg[index] = (void *) (_Unwind_Internal_Ptr) val;\n      return;\n    }\n\n  ptr = context-\u003ereg[index];\n\n  if (size == sizeof(_Unwind_Ptr))\n    * (_Unwind_Ptr *) ptr = val;\n  else\n    {\n      gcc_assert (size == sizeof(_Unwind_Word));\n      * (_Unwind_Word *) ptr = val;\n    }\n}","filepath":"gcc/unwind-dw2.c","line_number":196,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5787136":{"score":0.804587,"function_name":"_Unwind_FindEnclosingFunction","code":"void *\n_Unwind_FindEnclosingFunction (void *pc)\n{\n  struct dwarf_eh_bases bases;\n  const struct dwarf_fde *fde = _Unwind_Find_FDE (pc-1, \u0026bases);\n  if (fde)\n    return bases.func;\n  else\n    return NULL;\n}","filepath":"gcc/unwind-dw2.c","line_number":307,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5787216":{"score":0.83035827,"function_name":"__frame_state_for","code":"struct frame_state *\n__frame_state_for (void *pc_target, struct frame_state *state_in)\n{\n  struct _Unwind_Context context;\n  _Unwind_FrameState fs;\n  int reg;\n\n  memset (\u0026context, 0, sizeof (struct _Unwind_Context));\n  context.flags = EXTENDED_CONTEXT_BIT;\n  context.ra = pc_target + 1;\n\n  if (uw_frame_state_for (\u0026context, \u0026fs) != _URC_NO_REASON)\n    return 0;\n\n  /* We have no way to pass a location expression for the CFA to our\n     caller.  It wouldn't understand it anyway.  */\n  if (fs.regs.cfa_how == CFA_EXP)\n    return 0;\n\n  for (reg = 0; reg \u003c PRE_GCC3_DWARF_FRAME_REGISTERS + 1; reg++)\n    {\n      state_in-\u003esaved[reg] = fs.regs.reg[reg].how;\n      switch (state_in-\u003esaved[reg])\n\t{\n\tcase REG_SAVED_REG:\n\t  state_in-\u003ereg_or_offset[reg] = fs.regs.reg[reg].loc.reg;\n\t  break;\n\tcase REG_SAVED_OFFSET:\n\t  state_in-\u003ereg_or_offset[reg] = fs.regs.reg[reg].loc.offset;\n\t  break;\n\tdefault:\n\t  state_in-\u003ereg_or_offset[reg] = 0;\n\t  break;\n\t}\n    }\n\n  state_in-\u003ecfa_offset = fs.regs.cfa_offset;\n  state_in-\u003ecfa_reg = fs.regs.cfa_reg;\n  state_in-\u003eretaddr_column = fs.retaddr_column;\n  state_in-\u003eargs_size = context.args_size;\n  state_in-\u003eeh_ptr = fs.eh_ptr;\n\n  return state_in;\n}","filepath":"gcc/unwind-dw2.c","line_number":1208,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5788688":{"score":0.67332196,"function_name":"fde_unencoded_compare","code":"static int\nfde_unencoded_compare (struct object *ob __attribute__((unused)),\n\t\t       const fde *x, const fde *y)\n{\n  _Unwind_Ptr x_ptr, y_ptr;\n  memcpy (\u0026x_ptr, x-\u003epc_begin, sizeof (_Unwind_Ptr));\n  memcpy (\u0026y_ptr, y-\u003epc_begin, sizeof (_Unwind_Ptr));\n\n  if (x_ptr \u003e y_ptr)\n    return 1;\n  if (x_ptr \u003c y_ptr)\n    return -1;\n  return 0;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":357,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5788720":{"score":0.88118756,"function_name":"frame_downheap","code":"static void\nframe_downheap (struct object *ob, fde_compare_t fde_compare, const fde **a,\n\t\tint lo, int hi)\n{\n  int i, j;\n\n  for (i = lo, j = 2*i+1;\n       j \u003c hi;\n       j = 2*i+1)\n    {\n      if (j+1 \u003c hi \u0026\u0026 fde_compare (ob, a[j], a[j+1]) \u003c 0)\n\t++j;\n\n      if (fde_compare (ob, a[i], a[j]) \u003c 0)\n\t{\n\t  SWAP (a[i], a[j]);\n\t  i = j;\n\t}\n      else\n\tbreak;\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":513,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5788928":{"score":0.8345427,"function_name":"frame_heapsort","code":"static void\nframe_heapsort (struct object *ob, fde_compare_t fde_compare,\n\t\tstruct fde_vector *erratic)\n{\n  /* For a description of this algorithm, see:\n     Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,\n     p. 60-61.  */\n  const fde ** a = erratic-\u003earray;\n  /* A portion of the array is called a \"heap\" if for all i\u003e=0:\n     If i and 2i+1 are valid indices, then a[i] \u003e= a[2i+1].\n     If i and 2i+2 are valid indices, then a[i] \u003e= a[2i+2].  */\n  size_t n = erratic-\u003ecount;\n  int m;\n\n  /* Expand our heap incrementally from the end of the array, heapifying\n     each resulting semi-heap as we go.  After each step, a[m] is the top\n     of a heap.  */\n  for (m = n/2-1; m \u003e= 0; --m)\n    frame_downheap (ob, fde_compare, a, m, n);\n\n  /* Shrink our heap incrementally from the end of the array, first\n     swapping out the largest element a[0] and then re-heapifying the\n     resulting semi-heap.  After each step, a[0..m) is a heap.  */\n  for (m = n-1; m \u003e= 1; --m)\n    {\n      SWAP (a[0], a[m]);\n      frame_downheap (ob, fde_compare, a, 0, m);\n    }\n#undef SWAP\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":539,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5789104":{"score":0.7635616,"function_name":"size_of_encoded_value","code":"static unsigned int\nsize_of_encoded_value (unsigned char encoding)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding \u0026 0x07)\n    {\n    case DW_EH_PE_absptr:\n      return sizeof (void *);\n    case DW_EH_PE_udata2:\n      return 2;\n    case DW_EH_PE_udata4:\n      return 4;\n    case DW_EH_PE_udata8:\n      return 8;\n    }\n  __gxx_abort ();\n}","filepath":"libgcc/unwind-pe.h","line_number":71,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-5"},"5789216":{"score":0.86358154,"function_name":"base_from_object","code":"static _Unwind_Ptr\nbase_from_object (unsigned char encoding, struct object *ob)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding \u0026 0x70)\n    {\n    case DW_EH_PE_absptr:\n    case DW_EH_PE_pcrel:\n    case DW_EH_PE_aligned:\n      return 0;\n\n    case DW_EH_PE_textrel:\n      return (_Unwind_Ptr) ob-\u003etbase;\n    case DW_EH_PE_datarel:\n      return (_Unwind_Ptr) ob-\u003edbase;\n    default:\n      gcc_unreachable ();\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":266,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5789408":{"score":0.80758095,"function_name":"read_encoded_value_with_base","code":"static const unsigned char *\nread_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n\t\t\t      const unsigned char *p, _Unwind_Ptr *val)\n{\n  union unaligned\n    {\n      void *ptr;\n      unsigned u2 __attribute__ ((mode (HI)));\n      unsigned u4 __attribute__ ((mode (SI)));\n      unsigned u8 __attribute__ ((mode (DI)));\n      signed s2 __attribute__ ((mode (HI)));\n      signed s4 __attribute__ ((mode (SI)));\n      signed s8 __attribute__ ((mode (DI)));\n    } __attribute__((__packed__));\n\n  const union unaligned *u = (const union unaligned *) p;\n  _Unwind_Internal_Ptr result;\n\n  if (encoding == DW_EH_PE_aligned)\n    {\n      _Unwind_Internal_Ptr a = (_Unwind_Internal_Ptr) p;\n      a = (a + sizeof (void *) - 1) \u0026 - sizeof(void *);\n      result = *(_Unwind_Internal_Ptr *) a;\n      p = (const unsigned char *) (_Unwind_Internal_Ptr) (a + sizeof (void *));\n    }\n  else\n    {\n      switch (encoding \u0026 0x0f)\n\t{\n\tcase DW_EH_PE_absptr:\n\t  result = (_Unwind_Internal_Ptr) u-\u003eptr;\n\t  p += sizeof (void *);\n\t  break;\n\n\tcase DW_EH_PE_uleb128:\n\t  {\n\t    _uleb128_t tmp;\n\t    p = read_uleb128 (p, \u0026tmp);\n\t    result = (_Unwind_Internal_Ptr) tmp;\n\t  }\n\t  break;\n\n\tcase DW_EH_PE_sleb128:\n\t  {\n\t    _sleb128_t tmp;\n\t    p = read_sleb128 (p, \u0026tmp);\n\t    result = (_Unwind_Internal_Ptr) tmp;\n\t  }\n\t  break;\n\n\tcase DW_EH_PE_udata2:\n\t  result = u-\u003eu2;\n\t  p += 2;\n\t  break;\n\tcase DW_EH_PE_udata4:\n\t  result = u-\u003eu4;\n\t  p += 4;\n\t  break;\n\tcase DW_EH_PE_udata8:\n\t  result = u-\u003eu8;\n\t  p += 8;\n\t  break;\n\n\tcase DW_EH_PE_sdata2:\n\t  result = u-\u003es2;\n\t  p += 2;\n\t  break;\n\tcase DW_EH_PE_sdata4:\n\t  result = u-\u003es4;\n\t  p += 4;\n\t  break;\n\tcase DW_EH_PE_sdata8:\n\t  result = u-\u003es8;\n\t  p += 8;\n\t  break;\n\n\tdefault:\n\t  __gxx_abort ();\n\t}\n\n      if (result != 0)\n\t{\n\t  result += ((encoding \u0026 0x70) == DW_EH_PE_pcrel\n\t\t     ? (_Unwind_Internal_Ptr) u : base);\n\t  if (encoding \u0026 DW_EH_PE_indirect)\n\t    result = *(_Unwind_Internal_Ptr *) result;\n\t}\n    }\n\n  *val = result;\n  return p;\n}","filepath":"libgcc/unwind-pe.h","line_number":180,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-5"},"5789744":{"score":0.82409185,"function_name":"fde_single_encoding_compare","code":"static int\nfde_single_encoding_compare (struct object *ob, const fde *x, const fde *y)\n{\n  _Unwind_Ptr base, x_ptr, y_ptr;\n\n  base = base_from_object (ob-\u003es.b.encoding, ob);\n  read_encoded_value_with_base (ob-\u003es.b.encoding, base, x-\u003epc_begin, \u0026x_ptr);\n  read_encoded_value_with_base (ob-\u003es.b.encoding, base, y-\u003epc_begin, \u0026y_ptr);\n\n  if (x_ptr \u003e y_ptr)\n    return 1;\n  if (x_ptr \u003c y_ptr)\n    return -1;\n  return 0;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":372,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5789888":{"score":0.7985918,"function_name":"get_cie_encoding","code":"static int\nget_cie_encoding (const struct dwarf_cie *cie)\n{\n  const unsigned char *aug, *p;\n  _Unwind_Ptr dummy;\n  _uleb128_t utmp;\n  _sleb128_t stmp;\n\n  aug = cie-\u003eaugmentation;\n  p = aug + strlen ((const char *)aug) + 1; /* Skip the augmentation string.  */\n  if (__builtin_expect (cie-\u003eversion \u003e= 4, 0))\n    {\n      if (p[0] != sizeof (void *) || p[1] != 0)\n\treturn DW_EH_PE_omit;\t\t/* We are not prepared to handle unexpected\n\t\t\t\t\t   address sizes or segment selectors.  */\n      p += 2;\t\t\t\t/* Skip address size and segment size.  */\n    }\n\n  if (aug[0] != 'z')\n    return DW_EH_PE_absptr;\n\n  p = read_uleb128 (p, \u0026utmp);\t\t/* Skip code alignment.  */\n  p = read_sleb128 (p, \u0026stmp);\t\t/* Skip data alignment.  */\n  if (cie-\u003eversion == 1)\t\t/* Skip return address column.  */\n    p++;\n  else\n    p = read_uleb128 (p, \u0026utmp);\n\n  aug++;\t\t\t\t/* Skip 'z' */\n  p = read_uleb128 (p, \u0026utmp);\t\t/* Skip augmentation length.  */\n  while (1)\n    {\n      /* This is what we're looking for.  */\n      if (*aug == 'R')\n\treturn *p;\n      /* Personality encoding and pointer.  */\n      else if (*aug == 'P')\n\t{\n\t  /* ??? Avoid dereferencing indirect pointers, since we're\n\t     faking the base address.  Gotta keep DW_EH_PE_aligned\n\t     intact, however.  */\n\t  p = read_encoded_value_with_base (*p \u0026 0x7F, 0, p + 1, \u0026dummy);\n\t}\n      /* LSDA encoding.  */\n      else if (*aug == 'L')\n\tp++;\n      /* Otherwise end of string, or unknown augmentation.  */\n      else\n\treturn DW_EH_PE_absptr;\n      aug++;\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":291,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5790176":{"score":0.71890986,"function_name":"linear_search_fdes","code":"static const fde *\nlinear_search_fdes (struct object *ob, const fde *this_fde, void *pc)\n{\n  const struct dwarf_cie *last_cie = 0;\n  int encoding = ob-\u003es.b.encoding;\n  _Unwind_Ptr base = base_from_object (ob-\u003es.b.encoding, ob);\n\n  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))\n    {\n      const struct dwarf_cie *this_cie;\n      _Unwind_Ptr pc_begin, pc_range;\n\n      /* Skip CIEs.  */\n      if (this_fde-\u003eCIE_delta == 0)\n\tcontinue;\n\n      if (ob-\u003es.b.mixed_encoding)\n\t{\n\t  /* Determine the encoding for this FDE.  Note mixed encoded\n\t     objects for later.  */\n\t  this_cie = get_cie (this_fde);\n\t  if (this_cie != last_cie)\n\t    {\n\t      last_cie = this_cie;\n\t      encoding = get_cie_encoding (this_cie);\n\t      base = base_from_object (encoding, ob);\n\t    }\n\t}\n\n      if (encoding == DW_EH_PE_absptr)\n\t{\n\t  const _Unwind_Ptr *pc_array = (const _Unwind_Ptr *) this_fde-\u003epc_begin;\n\t  pc_begin = pc_array[0];\n\t  pc_range = pc_array[1];\n\t  if (pc_begin == 0)\n\t    continue;\n\t}\n      else\n\t{\n\t  _Unwind_Ptr mask;\n\t  const unsigned char *p;\n\n\t  p = read_encoded_value_with_base (encoding, base,\n\t\t\t\t\t    this_fde-\u003epc_begin, \u0026pc_begin);\n\t  read_encoded_value_with_base (encoding \u0026 0x0F, 0, p, \u0026pc_range);\n\n\t  /* Take care to ignore link-once functions that were removed.\n\t     In these cases, the function address will be NULL, but if\n\t     the encoding is smaller than a pointer a true NULL may not\n\t     be representable.  Assume 0 in the representable bits is NULL.  */\n\t  mask = size_of_encoded_value (encoding);\n\t  if (mask \u003c sizeof (void *))\n\t    mask = (((_Unwind_Ptr) 1) \u003c\u003c (mask \u003c\u003c 3)) - 1;\n\t  else\n\t    mask = -1;\n\n\t  if ((pc_begin \u0026 mask) == 0)\n\t    continue;\n\t}\n\n      if ((_Unwind_Ptr) pc - pc_begin \u003c pc_range)\n\treturn this_fde;\n    }\n\n  return NULL;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":825,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5790576":{"score":0.7872132,"function_name":"_Unwind_IteratePhdrCallback","code":"static int\n_Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n{\n  struct unw_eh_callback_data *data = (struct unw_eh_callback_data *) ptr;\n  const ElfW(Phdr) *phdr, *p_eh_frame_hdr, *p_dynamic;\n  long n, match;\n#ifdef __FRV_FDPIC__\n  struct elf32_fdpic_loadaddr load_base;\n#else\n  _Unwind_Ptr load_base;\n#endif\n  const unsigned char *p;\n  const struct unw_eh_frame_hdr *hdr;\n  _Unwind_Ptr eh_frame;\n  struct object ob;\n  \n  struct ext_dl_phdr_info\n    {\n      ElfW(Addr) dlpi_addr;\n      const char *dlpi_name;\n      const ElfW(Phdr) *dlpi_phdr;\n      ElfW(Half) dlpi_phnum;\n      unsigned long long int dlpi_adds;\n      unsigned long long int dlpi_subs;\n    };\n\n  match = 0;\n  phdr = info-\u003edlpi_phdr;\n  load_base = info-\u003edlpi_addr;\n  p_eh_frame_hdr = NULL;\n  p_dynamic = NULL;\n\n  struct frame_hdr_cache_element *prev_cache_entry = NULL,\n    *last_cache_entry = NULL;\n\n  if (data-\u003echeck_cache \u0026\u0026 size \u003e= sizeof (struct ext_dl_phdr_info))\n    {\n      static unsigned long long adds = -1ULL, subs;\n      struct ext_dl_phdr_info *einfo = (struct ext_dl_phdr_info *) info;\n\n      /* We use a least recently used cache replacement policy.  Also,\n\t the most recently used cache entries are placed at the head\n\t of the search chain.  */\n\n      if (einfo-\u003edlpi_adds == adds \u0026\u0026 einfo-\u003edlpi_subs == subs)\n\t{\n\t  /* Find data-\u003epc in shared library cache.\n\t     Set load_base, p_eh_frame_hdr and p_dynamic\n\t     plus match from the cache and goto\n\t     \"Read .eh_frame_hdr header.\" below.  */\n\n\t  struct frame_hdr_cache_element *cache_entry;\n\n\t  for (cache_entry = frame_hdr_cache_head;\n\t       cache_entry;\n\t       cache_entry = cache_entry-\u003elink)\n\t    {\n\t      if (data-\u003epc \u003e= cache_entry-\u003epc_low\n\t\t  \u0026\u0026 data-\u003epc \u003c cache_entry-\u003epc_high)\n\t\t{\n\t\t  load_base = cache_entry-\u003eload_base;\n\t\t  p_eh_frame_hdr = cache_entry-\u003ep_eh_frame_hdr;\n\t\t  p_dynamic = cache_entry-\u003ep_dynamic;\n\n\t\t  /* And move the entry we're using to the head.  */\n\t\t  if (cache_entry != frame_hdr_cache_head)\n\t\t    {\n\t\t      prev_cache_entry-\u003elink = cache_entry-\u003elink;\n\t\t      cache_entry-\u003elink = frame_hdr_cache_head;\n\t\t      frame_hdr_cache_head = cache_entry;\n\t\t    }\n\t\t  goto found;\n\t\t}\n\t\t  \n\t      last_cache_entry = cache_entry;\n\t      /* Exit early if we found an unused entry.  */\n\t      if ((cache_entry-\u003epc_low | cache_entry-\u003epc_high) == 0)\n\t\tbreak;\n\t      if (cache_entry-\u003elink != NULL)\n\t\tprev_cache_entry = cache_entry;\t\t  \n\t    }\n\t}\n      else\n\t{\n\t  adds = einfo-\u003edlpi_adds;\n\t  subs = einfo-\u003edlpi_subs;\n\t  /* Initialize the cache.  Create a chain of cache entries,\n\t     with the final one terminated by a NULL link.  */\n\t  int i;\n\t  for (i = 0; i \u003c FRAME_HDR_CACHE_SIZE; i++)\n\t    {\n\t      frame_hdr_cache[i].pc_low = 0;\n\t      frame_hdr_cache[i].pc_high = 0;\n\t      frame_hdr_cache[i].link = \u0026frame_hdr_cache[i+1];\n\t    }\n\t  frame_hdr_cache[i-1].link = NULL;\n\t  frame_hdr_cache_head = \u0026frame_hdr_cache[0];\n\t  data-\u003echeck_cache = 0;\n\t}\n    }\n\n  /* Make sure struct dl_phdr_info is at least as big as we need.  */\n  if (size \u003c offsetof (struct dl_phdr_info, dlpi_phnum)\n\t     + sizeof (info-\u003edlpi_phnum))\n    return -1;\n \n  _Unwind_Ptr pc_low = 0, pc_high = 0;\n\n  /* See if PC falls into one of the loaded segments.  Find the eh_frame\n     segment at the same time.  */\n  for (n = info-\u003edlpi_phnum; --n \u003e= 0; phdr++)\n    {\n      if (phdr-\u003ep_type == PT_LOAD)\n\t{\n\t  _Unwind_Ptr vaddr = (_Unwind_Ptr)\n\t    __RELOC_POINTER (phdr-\u003ep_vaddr, load_base);\n\t  if (data-\u003epc \u003e= vaddr \u0026\u0026 data-\u003epc \u003c vaddr + phdr-\u003ep_memsz)\n\t    {\n\t      match = 1;\n\t      pc_low = vaddr;\n\t      pc_high =  vaddr + phdr-\u003ep_memsz;\n\t    }\n\t}\n      else if (phdr-\u003ep_type == PT_GNU_EH_FRAME)\n\tp_eh_frame_hdr = phdr;\n      else if (phdr-\u003ep_type == PT_DYNAMIC)\n\tp_dynamic = phdr;\n    }\n  \n  if (!match)\n    return 0;\n\n  if (size \u003e= sizeof (struct ext_dl_phdr_info))\n    {\n      /* Move the cache entry we're about to overwrite to the head of\n\t the list.  If either last_cache_entry or prev_cache_entry are\n\t NULL, that cache entry is already at the head.  */\n      if (last_cache_entry != NULL \u0026\u0026 prev_cache_entry != NULL)\n\t{\n\t  prev_cache_entry-\u003elink = last_cache_entry-\u003elink;\n\t  last_cache_entry-\u003elink = frame_hdr_cache_head;\n\t  frame_hdr_cache_head = last_cache_entry;\n\t}\n\n      frame_hdr_cache_head-\u003eload_base = load_base;\n      frame_hdr_cache_head-\u003ep_eh_frame_hdr = p_eh_frame_hdr;\n      frame_hdr_cache_head-\u003ep_dynamic = p_dynamic;\n      frame_hdr_cache_head-\u003epc_low = pc_low;\n      frame_hdr_cache_head-\u003epc_high = pc_high;\n    }\n\n found:\n\n  if (!p_eh_frame_hdr)\n    return 0;\n\n  /* Read .eh_frame_hdr header.  */\n  hdr = (const struct unw_eh_frame_hdr *)\n    __RELOC_POINTER (p_eh_frame_hdr-\u003ep_vaddr, load_base);\n  if (hdr-\u003eversion != 1)\n    return 1;\n\n#ifdef CRT_GET_RFIB_DATA\n# ifdef __i386__\n  data-\u003edbase = NULL;\n  if (p_dynamic)\n    {\n      /* For dynamically linked executables and shared libraries,\n\t DT_PLTGOT is the gp value for that object.  */\n      ElfW(Dyn) *dyn = (ElfW(Dyn) *)\n\t__RELOC_POINTER (p_dynamic-\u003ep_vaddr, load_base);\n      for (; dyn-\u003ed_tag != DT_NULL ; dyn++)\n\tif (dyn-\u003ed_tag == DT_PLTGOT)\n\t  {\n\t    /* On IA-32, _DYNAMIC is writable and GLIBC has relocated it.  */\n\t    data-\u003edbase = (void *) dyn-\u003ed_un.d_ptr;\n\t    break;\n\t  }\n    }\n# elif defined __FRV_FDPIC__ \u0026\u0026 defined __linux__\n  data-\u003edbase = load_base.got_value;\n# else\n#  error What is DW_EH_PE_datarel base on this platform?\n# endif\n#endif\n\n  p = read_encoded_value_with_base (hdr-\u003eeh_frame_ptr_enc,\n\t\t\t\t    base_from_cb_data (hdr-\u003eeh_frame_ptr_enc,\n\t\t\t\t\t\t       data),\n\t\t\t\t    (const unsigned char *) (hdr + 1),\n\t\t\t\t    \u0026eh_frame);\n\n  /* We require here specific table encoding to speed things up.\n     Also, DW_EH_PE_datarel here means using PT_GNU_EH_FRAME start\n     as base, not the processor specific DW_EH_PE_datarel.  */\n  if (hdr-\u003efde_count_enc != DW_EH_PE_omit\n      \u0026\u0026 hdr-\u003etable_enc == (DW_EH_PE_datarel | DW_EH_PE_sdata4))\n    {\n      _Unwind_Ptr fde_count;\n\n      p = read_encoded_value_with_base (hdr-\u003efde_count_enc,\n\t\t\t\t\tbase_from_cb_data (hdr-\u003efde_count_enc,\n\t\t\t\t\t\t\t   data),\n\t\t\t\t\tp, \u0026fde_count);\n      /* Shouldn't happen.  */\n      if (fde_count == 0)\n\treturn 1;\n      if ((((_Unwind_Ptr) p) \u0026 3) == 0)\n\t{\n\t  struct fde_table {\n\t    signed initial_loc __attribute__ ((mode (SI)));\n\t    signed fde __attribute__ ((mode (SI)));\n\t  };\n\t  const struct fde_table *table = (const struct fde_table *) p;\n\t  size_t lo, hi, mid;\n\t  _Unwind_Ptr data_base = (_Unwind_Ptr) hdr;\n\t  fde *f;\n\t  unsigned int f_enc, f_enc_size;\n\t  _Unwind_Ptr range;\n\n\t  mid = fde_count - 1;\n\t  if (data-\u003epc \u003c table[0].initial_loc + data_base)\n\t    return 1;\n\t  else if (data-\u003epc \u003c table[mid].initial_loc + data_base)\n\t    {\n\t      lo = 0;\n\t      hi = mid;\n\n\t      while (lo \u003c hi)\n\t\t{\n\t\t  mid = (lo + hi) / 2;\n\t\t  if (data-\u003epc \u003c table[mid].initial_loc + data_base)\n\t\t    hi = mid;\n\t\t  else if (data-\u003epc \u003e= table[mid + 1].initial_loc + data_base)\n\t\t    lo = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\n\t      if (lo \u003e= hi)\n\t\t__gxx_abort ();\n\t    }\n\n\t  f = (fde *) (table[mid].fde + data_base);\n\t  f_enc = get_fde_encoding (f);\n\t  f_enc_size = size_of_encoded_value (f_enc);\n\t  read_encoded_value_with_base (f_enc \u0026 0x0f, 0,\n\t\t\t\t\t\u0026f-\u003epc_begin[f_enc_size], \u0026range);\n\t  if (data-\u003epc \u003c table[mid].initial_loc + data_base + range)\n\t    data-\u003eret = f;\n\t  data-\u003efunc = (void *) (table[mid].initial_loc + data_base);\n\t  return 1;\n\t}\n    }\n\n  /* We have no sorted search table, so need to go the slow way.\n     As soon as GLIBC will provide API so to notify that a library has been\n     removed, we could cache this (and thus use search_object).  */\n  ob.pc_begin = NULL;\n  ob.tbase = data-\u003etbase;\n  ob.dbase = data-\u003edbase;\n  ob.u.single = (fde *) eh_frame;\n  ob.s.i = 0;\n  ob.s.b.mixed_encoding = 1;  /* Need to assume worst case.  */\n  data-\u003eret = linear_search_fdes (\u0026ob, (fde *) eh_frame, (void *) data-\u003epc);\n  if (data-\u003eret != NULL)\n    {\n      unsigned int encoding = get_fde_encoding (data-\u003eret);\n      read_encoded_value_with_base (encoding,\n\t\t\t\t    base_from_cb_data (encoding, data),\n\t\t\t\t    data-\u003eret-\u003epc_begin,\n\t\t\t\t    (_Unwind_Ptr *)\u0026data-\u003efunc);\n    }\n  return 1;\n}","filepath":"gcc/unwind-dw2-fde-glibc.c","line_number":126,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.0.3"},"5791728":{"score":0.8238097,"function_name":"fde_mixed_encoding_compare","code":"static int\nfde_mixed_encoding_compare (struct object *ob, const fde *x, const fde *y)\n{\n  int x_encoding, y_encoding;\n  _Unwind_Ptr x_ptr, y_ptr;\n\n  x_encoding = get_fde_encoding (x);\n  read_encoded_value_with_base (x_encoding, base_from_object (x_encoding, ob),\n\t\t\t\tx-\u003epc_begin, \u0026x_ptr);\n\n  y_encoding = get_fde_encoding (y);\n  read_encoded_value_with_base (y_encoding, base_from_object (y_encoding, ob),\n\t\t\t\ty-\u003epc_begin, \u0026y_ptr);\n\n  if (x_ptr \u003e y_ptr)\n    return 1;\n  if (x_ptr \u003c y_ptr)\n    return -1;\n  return 0;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":388,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5791888":{"score":0.7462899,"function_name":"classify_object_over_fdes","code":"static size_t\nclassify_object_over_fdes (struct object *ob, const fde *this_fde)\n{\n  const struct dwarf_cie *last_cie = 0;\n  size_t count = 0;\n  int encoding = DW_EH_PE_absptr;\n  _Unwind_Ptr base = 0;\n\n  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))\n    {\n      const struct dwarf_cie *this_cie;\n      _Unwind_Ptr mask, pc_begin;\n\n      /* Skip CIEs.  */\n      if (this_fde-\u003eCIE_delta == 0)\n\tcontinue;\n\n      /* Determine the encoding for this FDE.  Note mixed encoded\n\t objects for later.  */\n      this_cie = get_cie (this_fde);\n      if (this_cie != last_cie)\n\t{\n\t  last_cie = this_cie;\n\t  encoding = get_cie_encoding (this_cie);\n\t  if (encoding == DW_EH_PE_omit)\n\t    return -1;\n\t  base = base_from_object (encoding, ob);\n\t  if (ob-\u003es.b.encoding == DW_EH_PE_omit)\n\t    ob-\u003es.b.encoding = encoding;\n\t  else if (ob-\u003es.b.encoding != encoding)\n\t    ob-\u003es.b.mixed_encoding = 1;\n\t}\n\n      read_encoded_value_with_base (encoding, base, this_fde-\u003epc_begin,\n\t\t\t\t    \u0026pc_begin);\n\n      /* Take care to ignore link-once functions that were removed.\n\t In these cases, the function address will be NULL, but if\n\t the encoding is smaller than a pointer a true NULL may not\n\t be representable.  Assume 0 in the representable bits is NULL.  */\n      mask = size_of_encoded_value (encoding);\n      if (mask \u003c sizeof (void *))\n\tmask = (((_Unwind_Ptr) 1) \u003c\u003c (mask \u003c\u003c 3)) - 1;\n      else\n\tmask = -1;\n\n      if ((pc_begin \u0026 mask) == 0)\n\tcontinue;\n\n      count += 1;\n      if ((void *) pc_begin \u003c ob-\u003epc_begin)\n\tob-\u003epc_begin = (void *) pc_begin;\n    }\n\n  return count;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":633,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5792240":{"score":0.6664794,"function_name":"add_fdes","code":"static void\nadd_fdes (struct object *ob, struct fde_accumulator *accu, const fde *this_fde)\n{\n  const struct dwarf_cie *last_cie = 0;\n  int encoding = ob-\u003es.b.encoding;\n  _Unwind_Ptr base = base_from_object (ob-\u003es.b.encoding, ob);\n\n  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))\n    {\n      const struct dwarf_cie *this_cie;\n\n      /* Skip CIEs.  */\n      if (this_fde-\u003eCIE_delta == 0)\n\tcontinue;\n\n      if (ob-\u003es.b.mixed_encoding)\n\t{\n\t  /* Determine the encoding for this FDE.  Note mixed encoded\n\t     objects for later.  */\n\t  this_cie = get_cie (this_fde);\n\t  if (this_cie != last_cie)\n\t    {\n\t      last_cie = this_cie;\n\t      encoding = get_cie_encoding (this_cie);\n\t      base = base_from_object (encoding, ob);\n\t    }\n\t}\n\n      if (encoding == DW_EH_PE_absptr)\n\t{\n\t  _Unwind_Ptr ptr;\n\t  memcpy (\u0026ptr, this_fde-\u003epc_begin, sizeof (_Unwind_Ptr));\n\t  if (ptr == 0)\n\t    continue;\n\t}\n      else\n\t{\n\t  _Unwind_Ptr pc_begin, mask;\n\n\t  read_encoded_value_with_base (encoding, base, this_fde-\u003epc_begin,\n\t\t\t\t\t\u0026pc_begin);\n\n\t  /* Take care to ignore link-once functions that were removed.\n\t     In these cases, the function address will be NULL, but if\n\t     the encoding is smaller than a pointer a true NULL may not\n\t     be representable.  Assume 0 in the representable bits is NULL.  */\n\t  mask = size_of_encoded_value (encoding);\n\t  if (mask \u003c sizeof (void *))\n\t    mask = (((_Unwind_Ptr) 1) \u003c\u003c (mask \u003c\u003c 3)) - 1;\n\t  else\n\t    mask = -1;\n\n\t  if ((pc_begin \u0026 mask) == 0)\n\t    continue;\n\t}\n\n      fde_insert (accu, this_fde);\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":690,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5792560":{"score":0.6356181,"function_name":"search_object","code":"static const fde *\nsearch_object (struct object* ob, void *pc)\n{\n  /* If the data hasn't been sorted, try to do this now.  We may have\n     more memory available than last time we tried.  */\n  if (! ob-\u003es.b.sorted)\n    {\n      init_object (ob);\n\n      /* Despite the above comment, the normal reason to get here is\n\t that we've not processed this object before.  A quick range\n\t check is in order.  */\n      if (pc \u003c ob-\u003epc_begin)\n\treturn NULL;\n    }\n\n  if (ob-\u003es.b.sorted)\n    {\n      if (ob-\u003es.b.mixed_encoding)\n\treturn binary_search_mixed_encoding_fdes (ob, pc);\n      else if (ob-\u003es.b.encoding == DW_EH_PE_absptr)\n\treturn binary_search_unencoded_fdes (ob, pc);\n      else\n\treturn binary_search_single_encoding_fdes (ob, pc);\n    }\n  else\n    {\n      /* Long slow laborious linear search, cos we've no memory.  */\n      if (ob-\u003es.b.from_array)\n\t{\n\t  fde **p;\n\t  for (p = ob-\u003eu.array; *p ; p++)\n\t    {\n\t      const fde *f = linear_search_fdes (ob, *p, pc);\n\t      if (f)\n\t\treturn f;\n\t    }\n\t  return NULL;\n\t}\n      else\n\treturn linear_search_fdes (ob, ob-\u003eu.single, pc);\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":982,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5794352":{"score":0.6265144,"function_name":"__register_frame_info","code":"void\n__register_frame_info (void *begin, struct object *ob)\n{\n  ob-\u003efde_begin = begin;\n\n  ob-\u003epc_begin = ob-\u003epc_end = 0;\n  ob-\u003efde_array = 0;\n  ob-\u003ecount = 0;\n\n  ob-\u003enext = objects;\n  objects = ob;\n}","filepath":"gcc/frame.c","line_number":502,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"prereleases/egcs-1.0.1-prerelease"},"5794480":{"score":0.8094466,"function_name":"__register_frame_info_bases","code":"void\n__register_frame_info_bases (const void *begin, struct object *ob,\n\t\t\t     void *tbase, void *dbase)\n{\n  /* If .eh_frame is empty, don't register at all.  */\n  if ((const uword *) begin == 0 || *(const uword *) begin == 0)\n    return;\n\n  ob-\u003epc_begin = (void *)-1;\n  ob-\u003etbase = tbase;\n  ob-\u003edbase = dbase;\n  ob-\u003eu.single = begin;\n  ob-\u003es.i = 0;\n  ob-\u003es.b.encoding = DW_EH_PE_omit;\n#ifdef DWARF2_OBJECT_END_PTR_EXTENSION\n  ob-\u003efde_end = NULL;\n#endif\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  ob-\u003enext = unseen_objects;\n  unseen_objects = ob;\n#ifdef ATOMIC_FDE_FAST_PATH\n  /* Set flag that at least one library has registered FDEs.\n     Use relaxed MO here, it is up to the app to ensure that the library\n     loading/initialization happens-before using that library in other\n     threads (in particular unwinding with that library's functions\n     appearing in the backtraces).  Calling that library's functions\n     without waiting for the library to initialize would be racy.  */\n  if (!any_objects_registered)\n    __atomic_store_n (\u0026any_objects_registered, 1, __ATOMIC_RELAXED);\n#endif\n\n  __gthread_mutex_unlock (\u0026object_mutex);\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":84,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5794656":{"score":0.68322206,"function_name":"__register_frame","code":"void\n__register_frame (void *begin)\n{\n  struct object *ob;\n\n  /* If .eh_frame is empty, don't register at all.  */\n  if (*(uword *) begin == 0)\n    return;\n\n  ob = malloc (sizeof (struct object));\n  __register_frame_info (begin, ob);\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":127,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5794704":{"score":0.69949025,"function_name":"__register_frame_info_table_bases","code":"void\n__register_frame_info_table_bases (void *begin, struct object *ob,\n\t\t\t\t   void *tbase, void *dbase)\n{\n  ob-\u003epc_begin = (void *)-1;\n  ob-\u003etbase = tbase;\n  ob-\u003edbase = dbase;\n  ob-\u003eu.array = begin;\n  ob-\u003es.i = 0;\n  ob-\u003es.b.from_array = 1;\n  ob-\u003es.b.encoding = DW_EH_PE_omit;\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  ob-\u003enext = unseen_objects;\n  unseen_objects = ob;\n#ifdef ATOMIC_FDE_FAST_PATH\n  /* Set flag that at least one library has registered FDEs.\n     Use relaxed MO here, it is up to the app to ensure that the library\n     loading/initialization happens-before using that library in other\n     threads (in particular unwinding with that library's functions\n     appearing in the backtraces).  Calling that library's functions\n     without waiting for the library to initialize would be racy.  */\n  if (!any_objects_registered)\n    __atomic_store_n (\u0026any_objects_registered, 1, __ATOMIC_RELAXED);\n#endif\n\n  __gthread_mutex_unlock (\u0026object_mutex);\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":144,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5794880":{"score":0.6558627,"function_name":"__deregister_frame_info_bases","code":"void *\n__deregister_frame_info_bases (const void *begin)\n{\n  struct object **p;\n  struct object *ob = 0;\n\n  /* If .eh_frame is empty, we haven't registered.  */\n  if ((const uword *) begin == 0 || *(const uword *) begin == 0)\n    return ob;\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  for (p = \u0026unseen_objects; *p ; p = \u0026(*p)-\u003enext)\n    if ((*p)-\u003eu.single == begin)\n      {\n\tob = *p;\n\t*p = ob-\u003enext;\n\tgoto out;\n      }\n\n  for (p = \u0026seen_objects; *p ; p = \u0026(*p)-\u003enext)\n    if ((*p)-\u003es.b.sorted)\n      {\n\tif ((*p)-\u003eu.sort-\u003eorig_data == begin)\n\t  {\n\t    ob = *p;\n\t    *p = ob-\u003enext;\n\t    free (ob-\u003eu.sort);\n\t    goto out;\n\t  }\n      }\n    else\n      {\n\tif ((*p)-\u003eu.single == begin)\n\t  {\n\t    ob = *p;\n\t    *p = ob-\u003enext;\n\t    goto out;\n\t  }\n      }\n\n out:\n  __gthread_mutex_unlock (\u0026object_mutex);\n  gcc_assert (ob);\n  return (void *) ob;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":200,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5795248":{"score":0.7248318,"function_name":"_Unwind_Find_FDE","code":"const fde *\n_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n{\n  struct object *ob;\n  const fde *f = NULL;\n\n#ifdef ATOMIC_FDE_FAST_PATH\n  /* For targets where unwind info is usually not registered through these\n     APIs anymore, avoid taking a global lock.\n     Use relaxed MO here, it is up to the app to ensure that the library\n     loading/initialization happens-before using that library in other\n     threads (in particular unwinding with that library's functions\n     appearing in the backtraces).  Calling that library's functions\n     without waiting for the library to initialize would be racy.  */\n  if (__builtin_expect (!__atomic_load_n (\u0026any_objects_registered,\n\t\t\t\t\t  __ATOMIC_RELAXED), 1))\n    return NULL;\n#endif\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  /* Linear search through the classified objects, to find the one\n     containing the pc.  Note that pc_begin is sorted descending, and\n     we expect objects to be non-overlapping.  */\n  for (ob = seen_objects; ob; ob = ob-\u003enext)\n    if (pc \u003e= ob-\u003epc_begin)\n      {\n\tf = search_object (ob, pc);\n\tif (f)\n\t  goto fini;\n\tbreak;\n      }\n\n  /* Classify and search the objects we've not yet processed.  */\n  while ((ob = unseen_objects))\n    {\n      struct object **p;\n\n      unseen_objects = ob-\u003enext;\n      f = search_object (ob, pc);\n\n      /* Insert the object into the classified list.  */\n      for (p = \u0026seen_objects; *p ; p = \u0026(*p)-\u003enext)\n\tif ((*p)-\u003epc_begin \u003c ob-\u003epc_begin)\n\t  break;\n      ob-\u003enext = *p;\n      *p = ob;\n\n      if (f)\n\tgoto fini;\n    }\n\n fini:\n  __gthread_mutex_unlock (\u0026object_mutex);\n\n  if (f)\n    {\n      int encoding;\n      _Unwind_Ptr func;\n\n      bases-\u003etbase = ob-\u003etbase;\n      bases-\u003edbase = ob-\u003edbase;\n\n      encoding = ob-\u003es.b.encoding;\n      if (ob-\u003es.b.mixed_encoding)\n\tencoding = get_fde_encoding (f);\n      read_encoded_value_with_base (encoding, base_from_object (encoding, ob),\n\t\t\t\t    f-\u003epc_begin, \u0026func);\n      bases-\u003efunc = (void *) func;\n    }\n\n  return f;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":1026,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"}}}